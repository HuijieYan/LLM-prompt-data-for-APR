{
    "1.1.1": "def _get_merge_keys(self):\n\n    # note this function has side effects\n    (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n\n    # validate index types are the same\n    for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n        if not is_dtype_equal(lk.dtype, rk.dtype):\n            if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                # The generic error message is confusing for categoricals.\n                #\n                # In this function, the join keys include both the original\n                # ones of the merge_asof() call, and also the keys passed\n                # to its by= argument. Unordered but equal categories\n                # are not supported for the former, but will fail\n                # later with a ValueError, so we don't *need* to check\n                # for them here.\n                msg = (\n                    \"incompatible merge keys [{i}] {lkdtype} and \"\n                    \"{rkdtype}, both sides category, but not equal ones\".format(\n                        i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                    )\n                )\n            else:\n                msg = (\n                    \"incompatible merge keys [{i}] {lkdtype} and \"\n                    \"{rkdtype}, must be the same type\".format(\n                        i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                    )\n                )\n            raise MergeError(msg)\n\n    # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n    if self.tolerance is not None:\n\n        if self.left_index:\n            lt = self.left.index\n        else:\n            lt = left_join_keys[-1]\n\n        msg = (\n            \"incompatible tolerance {tolerance}, must be compat \"\n            \"with type {lkdtype}\".format(\n                tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n            )\n        )\n\n        if is_datetimelike(lt):\n            if not isinstance(self.tolerance, datetime.timedelta):\n                raise MergeError(msg)\n            if self.tolerance < Timedelta(0):\n                raise MergeError(\"tolerance must be positive\")\n\n        elif is_int64_dtype(lt):\n            if not is_integer(self.tolerance):\n                raise MergeError(msg)\n            if self.tolerance < 0:\n                raise MergeError(\"tolerance must be positive\")\n\n        elif is_float_dtype(lt):\n            if not is_number(self.tolerance):\n                raise MergeError(msg)\n            if self.tolerance < 0:\n                raise MergeError(\"tolerance must be positive\")\n\n        else:\n            raise MergeError(\"key must be integer, timestamp or float\")\n\n    # validate allow_exact_matches\n    if not is_bool(self.allow_exact_matches):\n        msg = \"allow_exact_matches must be boolean, passed {passed}\"\n        raise MergeError(msg.format(passed=self.allow_exact_matches))\n\n    return left_join_keys, right_join_keys, join_names\n",
    "1.1.2": null,
    "1.2.1": "class _AsOfMerge(_OrderedMerge)",
    "1.2.2": null,
    "1.2.3": [
        "_get_merge_keys(self)"
    ],
    "1.3.1": "pandas/core/reshape/merge.py",
    "1.3.2": [
        "_get_merge_keys(self)",
        "_get_merge_keys(self)"
    ],
    "1.4.1": [
        "    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n\n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n\n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n\n        result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n        assert_frame_equal(result, expected)",
        "    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n\n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n\n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n\n        result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n        assert_frame_equal(result, expected)",
        "    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n\n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n\n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n\n        result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n        assert_frame_equal(result, expected)",
        "    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n\n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n\n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n\n        result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n        assert_frame_equal(result, expected)",
        "    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n\n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n\n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n\n        result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n        assert_frame_equal(result, expected)",
        "    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n\n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n\n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n\n        result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n        assert_frame_equal(result, expected)",
        "    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n\n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n\n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n\n        result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n        assert_frame_equal(result, expected)"
    ],
    "1.4.2": [
        "pandas/tests/reshape/merge/test_merge_asof.py",
        "pandas/tests/reshape/merge/test_merge_asof.py",
        "pandas/tests/reshape/merge/test_merge_asof.py",
        "pandas/tests/reshape/merge/test_merge_asof.py",
        "pandas/tests/reshape/merge/test_merge_asof.py",
        "pandas/tests/reshape/merge/test_merge_asof.py",
        "pandas/tests/reshape/merge/test_merge_asof.py"
    ],
    "2.1.1": [
        [
            "E               pandas.errors.MergeError: key must be integer, timestamp or float"
        ],
        [
            "E               pandas.errors.MergeError: key must be integer, timestamp or float"
        ],
        [
            "E               pandas.errors.MergeError: key must be integer, timestamp or float"
        ],
        [
            "E               pandas.errors.MergeError: key must be integer, timestamp or float"
        ],
        [
            "E               pandas.errors.MergeError: key must be integer, timestamp or float"
        ],
        [
            "E               pandas.errors.MergeError: key must be integer, timestamp or float"
        ],
        [
            "E               pandas.errors.MergeError: key must be integer, timestamp or float"
        ]
    ],
    "2.1.2": [
        [
            "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x7fd1c6b735e0>\nany_int_dtype = 'uint8'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x7fd1c6b3c0a0>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
            "\npandas/core/reshape/merge.py:1657: MergeError"
        ],
        [
            "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x7fd1c46ec070>\nany_int_dtype = 'uint16'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x7fd1c6b38c10>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
            "\npandas/core/reshape/merge.py:1657: MergeError"
        ],
        [
            "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x7fd1c6b2d490>\nany_int_dtype = 'uint32'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x7fd1c6b32520>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
            "\npandas/core/reshape/merge.py:1657: MergeError"
        ],
        [
            "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x7fd1c4302550>\nany_int_dtype = 'uint64'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x7fd1c6b1c190>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
            "\npandas/core/reshape/merge.py:1657: MergeError"
        ],
        [
            "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x7fd1c6b28490>\nany_int_dtype = 'int8'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x7fd1c430abb0>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
            "\npandas/core/reshape/merge.py:1657: MergeError"
        ],
        [
            "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x7fd1c6b32400>\nany_int_dtype = 'int16'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x7fd1c6b1c040>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
            "\npandas/core/reshape/merge.py:1657: MergeError"
        ],
        [
            "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x7fd1c6b0c2e0>\nany_int_dtype = 'int32'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x7fd1c43072e0>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
            "\npandas/core/reshape/merge.py:1657: MergeError"
        ]
    ],
    "2.1.3": [
        [
            {
                "self.tolerance": {
                    "value": "10",
                    "shape": null,
                    "omitted": false
                },
                "self.left_index": {
                    "value": "False",
                    "shape": null,
                    "omitted": false
                },
                "self.left": {
                    "value": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                    "shape": "(3, 2)",
                    "omitted": false
                },
                "self.allow_exact_matches": {
                    "value": "True",
                    "shape": null,
                    "omitted": false
                }
            },
            {
                "left_join_keys": {
                    "value": "[array([ 0, 10, 20])]",
                    "shape": "1",
                    "omitted": false
                },
                "right_join_keys": {
                    "value": "[array([ 5, 15, 25])]",
                    "shape": "1",
                    "omitted": false
                },
                "join_names": {
                    "value": "['a']",
                    "shape": "1",
                    "omitted": false
                },
                "i": {
                    "value": "0",
                    "shape": null,
                    "omitted": false
                },
                "lk": {
                    "value": "array([ 0, 10, 20])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "rk": {
                    "value": "array([ 5, 15, 25])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "lk.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                },
                "rk.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                },
                "msg": {
                    "value": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('int64')\"",
                    "shape": "77",
                    "omitted": false
                },
                "lt": {
                    "value": "array([ 0, 10, 20])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "lt.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                }
            }
        ],
        [
            {
                "self.tolerance": {
                    "value": "10",
                    "shape": null,
                    "omitted": false
                },
                "self.left_index": {
                    "value": "False",
                    "shape": null,
                    "omitted": false
                },
                "self.left": {
                    "value": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                    "shape": "(3, 2)",
                    "omitted": false
                },
                "self.allow_exact_matches": {
                    "value": "True",
                    "shape": null,
                    "omitted": false
                }
            },
            {
                "left_join_keys": {
                    "value": "[array([ 0, 10, 20])]",
                    "shape": "1",
                    "omitted": false
                },
                "right_join_keys": {
                    "value": "[array([ 5, 15, 25])]",
                    "shape": "1",
                    "omitted": false
                },
                "join_names": {
                    "value": "['a']",
                    "shape": "1",
                    "omitted": false
                },
                "i": {
                    "value": "0",
                    "shape": null,
                    "omitted": false
                },
                "lk": {
                    "value": "array([ 0, 10, 20])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "rk": {
                    "value": "array([ 5, 15, 25])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "lk.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                },
                "rk.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                },
                "msg": {
                    "value": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('int64')\"",
                    "shape": "77",
                    "omitted": false
                },
                "lt": {
                    "value": "array([ 0, 10, 20])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "lt.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                }
            }
        ]
    ],
    "2.1.4": [
        [
            {
                "self.tolerance": "int",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ]
    ],
    "2.1.5": [
        [
            {
                "self.tolerance": {
                    "value": "10",
                    "shape": null,
                    "omitted": false
                },
                "self.left_index": {
                    "value": "False",
                    "shape": null,
                    "omitted": false
                },
                "self.left": {
                    "value": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                    "shape": "(3, 2)",
                    "omitted": false
                },
                "self.allow_exact_matches": {
                    "value": "True",
                    "shape": null,
                    "omitted": false
                }
            },
            {
                "left_join_keys": {
                    "value": "[array([ 0, 10, 20], dtype=uint8)]",
                    "shape": "1",
                    "omitted": false
                },
                "right_join_keys": {
                    "value": "[array([ 5, 15, 25], dtype=uint8)]",
                    "shape": "1",
                    "omitted": false
                },
                "join_names": {
                    "value": "['a']",
                    "shape": "1",
                    "omitted": false
                },
                "i": {
                    "value": "0",
                    "shape": null,
                    "omitted": false
                },
                "lk": {
                    "value": "array([ 0, 10, 20], dtype=uint8)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "rk": {
                    "value": "array([ 5, 15, 25], dtype=uint8)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "lk.dtype": {
                    "value": "dtype('uint8')",
                    "shape": "()",
                    "omitted": false
                },
                "rk.dtype": {
                    "value": "dtype('uint8')",
                    "shape": "()",
                    "omitted": false
                },
                "msg": {
                    "value": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('uint8')\"",
                    "shape": "77",
                    "omitted": false
                },
                "lt": {
                    "value": "array([ 0, 10, 20], dtype=uint8)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "lt.dtype": {
                    "value": "dtype('uint8')",
                    "shape": "()",
                    "omitted": false
                }
            }
        ],
        [
            {
                "self.tolerance": {
                    "value": "10",
                    "shape": null,
                    "omitted": false
                },
                "self.left_index": {
                    "value": "False",
                    "shape": null,
                    "omitted": false
                },
                "self.left": {
                    "value": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                    "shape": "(3, 2)",
                    "omitted": false
                },
                "self.allow_exact_matches": {
                    "value": "True",
                    "shape": null,
                    "omitted": false
                }
            },
            {
                "left_join_keys": {
                    "value": "[array([ 0, 10, 20], dtype=uint16)]",
                    "shape": "1",
                    "omitted": false
                },
                "right_join_keys": {
                    "value": "[array([ 5, 15, 25], dtype=uint16)]",
                    "shape": "1",
                    "omitted": false
                },
                "join_names": {
                    "value": "['a']",
                    "shape": "1",
                    "omitted": false
                },
                "i": {
                    "value": "0",
                    "shape": null,
                    "omitted": false
                },
                "lk": {
                    "value": "array([ 0, 10, 20], dtype=uint16)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "rk": {
                    "value": "array([ 5, 15, 25], dtype=uint16)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "lk.dtype": {
                    "value": "dtype('uint16')",
                    "shape": "()",
                    "omitted": false
                },
                "rk.dtype": {
                    "value": "dtype('uint16')",
                    "shape": "()",
                    "omitted": false
                },
                "msg": {
                    "value": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('uint16')\"",
                    "shape": "78",
                    "omitted": false
                },
                "lt": {
                    "value": "array([ 0, 10, 20], dtype=uint16)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "lt.dtype": {
                    "value": "dtype('uint16')",
                    "shape": "()",
                    "omitted": false
                }
            }
        ],
        [
            {
                "self.tolerance": {
                    "value": "10",
                    "shape": null,
                    "omitted": false
                },
                "self.left_index": {
                    "value": "False",
                    "shape": null,
                    "omitted": false
                },
                "self.left": {
                    "value": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                    "shape": "(3, 2)",
                    "omitted": false
                },
                "self.allow_exact_matches": {
                    "value": "True",
                    "shape": null,
                    "omitted": false
                }
            },
            {
                "left_join_keys": {
                    "value": "[array([ 0, 10, 20], dtype=uint32)]",
                    "shape": "1",
                    "omitted": false
                },
                "right_join_keys": {
                    "value": "[array([ 5, 15, 25], dtype=uint32)]",
                    "shape": "1",
                    "omitted": false
                },
                "join_names": {
                    "value": "['a']",
                    "shape": "1",
                    "omitted": false
                },
                "i": {
                    "value": "0",
                    "shape": null,
                    "omitted": false
                },
                "lk": {
                    "value": "array([ 0, 10, 20], dtype=uint32)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "rk": {
                    "value": "array([ 5, 15, 25], dtype=uint32)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "lk.dtype": {
                    "value": "dtype('uint32')",
                    "shape": "()",
                    "omitted": false
                },
                "rk.dtype": {
                    "value": "dtype('uint32')",
                    "shape": "()",
                    "omitted": false
                },
                "msg": {
                    "value": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('uint32')\"",
                    "shape": "78",
                    "omitted": false
                },
                "lt": {
                    "value": "array([ 0, 10, 20], dtype=uint32)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "lt.dtype": {
                    "value": "dtype('uint32')",
                    "shape": "()",
                    "omitted": false
                }
            }
        ],
        [
            {
                "self.tolerance": {
                    "value": "10",
                    "shape": null,
                    "omitted": false
                },
                "self.left_index": {
                    "value": "False",
                    "shape": null,
                    "omitted": false
                },
                "self.left": {
                    "value": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                    "shape": "(3, 2)",
                    "omitted": false
                },
                "self.allow_exact_matches": {
                    "value": "True",
                    "shape": null,
                    "omitted": false
                }
            },
            {
                "left_join_keys": {
                    "value": "[array([ 0, 10, 20], dtype=uint64)]",
                    "shape": "1",
                    "omitted": false
                },
                "right_join_keys": {
                    "value": "[array([ 5, 15, 25], dtype=uint64)]",
                    "shape": "1",
                    "omitted": false
                },
                "join_names": {
                    "value": "['a']",
                    "shape": "1",
                    "omitted": false
                },
                "i": {
                    "value": "0",
                    "shape": null,
                    "omitted": false
                },
                "lk": {
                    "value": "array([ 0, 10, 20], dtype=uint64)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "rk": {
                    "value": "array([ 5, 15, 25], dtype=uint64)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "lk.dtype": {
                    "value": "dtype('uint64')",
                    "shape": "()",
                    "omitted": false
                },
                "rk.dtype": {
                    "value": "dtype('uint64')",
                    "shape": "()",
                    "omitted": false
                },
                "msg": {
                    "value": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('uint64')\"",
                    "shape": "78",
                    "omitted": false
                },
                "lt": {
                    "value": "array([ 0, 10, 20], dtype=uint64)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "lt.dtype": {
                    "value": "dtype('uint64')",
                    "shape": "()",
                    "omitted": false
                }
            }
        ],
        [
            {
                "self.tolerance": {
                    "value": "10",
                    "shape": null,
                    "omitted": false
                },
                "self.left_index": {
                    "value": "False",
                    "shape": null,
                    "omitted": false
                },
                "self.left": {
                    "value": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                    "shape": "(3, 2)",
                    "omitted": false
                },
                "self.allow_exact_matches": {
                    "value": "True",
                    "shape": null,
                    "omitted": false
                }
            },
            {
                "left_join_keys": {
                    "value": "[array([ 0, 10, 20])]",
                    "shape": "1",
                    "omitted": false
                },
                "right_join_keys": {
                    "value": "[array([ 5, 15, 25])]",
                    "shape": "1",
                    "omitted": false
                },
                "join_names": {
                    "value": "['a']",
                    "shape": "1",
                    "omitted": false
                },
                "i": {
                    "value": "0",
                    "shape": null,
                    "omitted": false
                },
                "lk": {
                    "value": "array([ 0, 10, 20])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "rk": {
                    "value": "array([ 5, 15, 25])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "lk.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                },
                "rk.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                },
                "msg": {
                    "value": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('int64')\"",
                    "shape": "77",
                    "omitted": false
                },
                "lt": {
                    "value": "array([ 0, 10, 20])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "lt.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                }
            }
        ],
        [
            {
                "self.tolerance": {
                    "value": "10",
                    "shape": null,
                    "omitted": false
                },
                "self.left_index": {
                    "value": "False",
                    "shape": null,
                    "omitted": false
                },
                "self.left": {
                    "value": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                    "shape": "(3, 2)",
                    "omitted": false
                },
                "self.allow_exact_matches": {
                    "value": "True",
                    "shape": null,
                    "omitted": false
                }
            },
            {
                "left_join_keys": {
                    "value": "[array([ 0, 10, 20], dtype=int8)]",
                    "shape": "1",
                    "omitted": false
                },
                "right_join_keys": {
                    "value": "[array([ 5, 15, 25], dtype=int8)]",
                    "shape": "1",
                    "omitted": false
                },
                "join_names": {
                    "value": "['a']",
                    "shape": "1",
                    "omitted": false
                },
                "i": {
                    "value": "0",
                    "shape": null,
                    "omitted": false
                },
                "lk": {
                    "value": "array([ 0, 10, 20], dtype=int8)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "rk": {
                    "value": "array([ 5, 15, 25], dtype=int8)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "lk.dtype": {
                    "value": "dtype('int8')",
                    "shape": "()",
                    "omitted": false
                },
                "rk.dtype": {
                    "value": "dtype('int8')",
                    "shape": "()",
                    "omitted": false
                },
                "msg": {
                    "value": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('int8')\"",
                    "shape": "76",
                    "omitted": false
                },
                "lt": {
                    "value": "array([ 0, 10, 20], dtype=int8)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "lt.dtype": {
                    "value": "dtype('int8')",
                    "shape": "()",
                    "omitted": false
                }
            }
        ],
        [
            {
                "self.tolerance": {
                    "value": "10",
                    "shape": null,
                    "omitted": false
                },
                "self.left_index": {
                    "value": "False",
                    "shape": null,
                    "omitted": false
                },
                "self.left": {
                    "value": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                    "shape": "(3, 2)",
                    "omitted": false
                },
                "self.allow_exact_matches": {
                    "value": "True",
                    "shape": null,
                    "omitted": false
                }
            },
            {
                "left_join_keys": {
                    "value": "[array([ 0, 10, 20], dtype=int16)]",
                    "shape": "1",
                    "omitted": false
                },
                "right_join_keys": {
                    "value": "[array([ 5, 15, 25], dtype=int16)]",
                    "shape": "1",
                    "omitted": false
                },
                "join_names": {
                    "value": "['a']",
                    "shape": "1",
                    "omitted": false
                },
                "i": {
                    "value": "0",
                    "shape": null,
                    "omitted": false
                },
                "lk": {
                    "value": "array([ 0, 10, 20], dtype=int16)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "rk": {
                    "value": "array([ 5, 15, 25], dtype=int16)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "lk.dtype": {
                    "value": "dtype('int16')",
                    "shape": "()",
                    "omitted": false
                },
                "rk.dtype": {
                    "value": "dtype('int16')",
                    "shape": "()",
                    "omitted": false
                },
                "msg": {
                    "value": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('int16')\"",
                    "shape": "77",
                    "omitted": false
                },
                "lt": {
                    "value": "array([ 0, 10, 20], dtype=int16)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "lt.dtype": {
                    "value": "dtype('int16')",
                    "shape": "()",
                    "omitted": false
                }
            }
        ],
        [
            {
                "self.tolerance": {
                    "value": "10",
                    "shape": null,
                    "omitted": false
                },
                "self.left_index": {
                    "value": "False",
                    "shape": null,
                    "omitted": false
                },
                "self.left": {
                    "value": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                    "shape": "(3, 2)",
                    "omitted": false
                },
                "self.allow_exact_matches": {
                    "value": "True",
                    "shape": null,
                    "omitted": false
                }
            },
            {
                "left_join_keys": {
                    "value": "[array([ 0, 10, 20], dtype=int32)]",
                    "shape": "1",
                    "omitted": false
                },
                "right_join_keys": {
                    "value": "[array([ 5, 15, 25], dtype=int32)]",
                    "shape": "1",
                    "omitted": false
                },
                "join_names": {
                    "value": "['a']",
                    "shape": "1",
                    "omitted": false
                },
                "i": {
                    "value": "0",
                    "shape": null,
                    "omitted": false
                },
                "lk": {
                    "value": "array([ 0, 10, 20], dtype=int32)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "rk": {
                    "value": "array([ 5, 15, 25], dtype=int32)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "lk.dtype": {
                    "value": "dtype('int32')",
                    "shape": "()",
                    "omitted": false
                },
                "rk.dtype": {
                    "value": "dtype('int32')",
                    "shape": "()",
                    "omitted": false
                },
                "msg": {
                    "value": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('int32')\"",
                    "shape": "77",
                    "omitted": false
                },
                "lt": {
                    "value": "array([ 0, 10, 20], dtype=int32)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "lt.dtype": {
                    "value": "dtype('int32')",
                    "shape": "()",
                    "omitted": false
                }
            }
        ],
        [
            {
                "self.tolerance": {
                    "value": "10",
                    "shape": null,
                    "omitted": false
                },
                "self.left_index": {
                    "value": "False",
                    "shape": null,
                    "omitted": false
                },
                "self.left": {
                    "value": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                    "shape": "(3, 2)",
                    "omitted": false
                },
                "self.allow_exact_matches": {
                    "value": "True",
                    "shape": null,
                    "omitted": false
                }
            },
            {
                "left_join_keys": {
                    "value": "[array([ 0, 10, 20])]",
                    "shape": "1",
                    "omitted": false
                },
                "right_join_keys": {
                    "value": "[array([ 5, 15, 25])]",
                    "shape": "1",
                    "omitted": false
                },
                "join_names": {
                    "value": "['a']",
                    "shape": "1",
                    "omitted": false
                },
                "i": {
                    "value": "0",
                    "shape": null,
                    "omitted": false
                },
                "lk": {
                    "value": "array([ 0, 10, 20])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "rk": {
                    "value": "array([ 5, 15, 25])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "lk.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                },
                "rk.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                },
                "msg": {
                    "value": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('int64')\"",
                    "shape": "77",
                    "omitted": false
                },
                "lt": {
                    "value": "array([ 0, 10, 20])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "lt.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                }
            }
        ]
    ],
    "2.1.6": [
        [
            {
                "self.tolerance": "int",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ]
    ],
    "3.1.1": [
        "Merge_asof() Requires specific int type, not reflected in error or documentation\n"
    ],
    "3.1.2": [
        "Code Sample, a copy-pastable example if possible\nimport pandas as pd\n\nleft = pd.DataFrame({'ts_int': [0, 100, 200], 'left_val': [1, 2, 3]})\nright = pd.DataFrame({'ts_int': [50, 150, 250], 'right_val': [1, 2, 3]})\nleft['ts_int'] = left['ts_int'].astype(int)\nright['ts_int'] = right['ts_int'].astype(int)\npd.merge_asof(left, right, on='ts_int', tolerance=100)\n\n> pandas.errors.MergeError: key must be integer, timestamp or float\n\nprint(left['ts_int'].dtype)\n>>> int32\nprint(right['ts_int'].dtype)\n>>> int32\nProblem description\nmerge_asof() throws the MergeError key must be integer, timestamp or float even when the data used to merge on is a valid integer type.\n\nThis happens with all types of int with the exception of int64, as a result of the check performed when a tolerance is passed (pandas/core/reshape/merge.py:1641). This check uses the is_int64_dtype(lt), which will ofcourse return False for every type of int that isn't int64. This requirement of the on key being int64 is however not documented in the docs, nor is it reflected from the raised error.\n\nExpected Output\nThe expected output can go either of two ways. If it should be possible to perform the merge on every integer type, the expected output would be:\n\n   ts_int  left_val  right_val\n0       0         1        NaN\n1     100         2        1.0\n2     200         3        2.0\nIf it shouldn't be possible, I'd expect the returned MergeError and/or the docs to reflect that the integer type that should be used as key to merge on has to be of int64 type.\n"
    ],
    "used_imports": "import datetime\nfrom pandas.errors import MergeError\nfrom pandas.core.dtypes.common import ensure_float64, ensure_int64, ensure_object, is_array_like, is_bool, is_bool_dtype, is_categorical_dtype, is_datetime64tz_dtype, is_datetimelike, is_dtype_equal, is_extension_array_dtype, is_float_dtype, is_int64_dtype, is_integer, is_integer_dtype, is_list_like, is_number, is_numeric_dtype, is_object_dtype, needs_i8_conversion\nfrom pandas import Categorical, DataFrame, Index, MultiIndex, Series, Timedelta"
}