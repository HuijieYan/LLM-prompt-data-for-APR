{
    "1.1.1": "@cache_readonly\ndef _on(self):\n\n    if self.on is None:\n        return self.obj.index\n    elif isinstance(self.obj, ABCDataFrame) and self.on in self.obj.columns:\n        return Index(self.obj[self.on])\n    else:\n        raise ValueError(\n            \"invalid on specified as {0}, \"\n            \"must be a column (if DataFrame) \"\n            \"or None\".format(self.on)\n        )\n",
    "1.1.2": null,
    "1.2.1": "pandas/core/window/rolling.py",
    "1.2.2": "from pandas.util._decorators import Appender, Substitution, cache_readonly\nfrom pandas.core.dtypes.generic import ABCDataFrame, ABCDateOffset, ABCDatetimeIndex, ABCPeriodIndex, ABCSeries, ABCTimedeltaIndex\nfrom pandas.core.index import Index, ensure_index",
    "1.3.1": "class Rolling(_Rolling_and_Expanding)",
    "1.3.2": null,
    "1.4.1": null,
    "1.4.2": null,
    "1.5.1": [
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)"
    ],
    "1.5.2": [
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py",
        "pandas/tests/window/test_rolling.py"
    ],
    "2.1.1": [
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ]
    ],
    "2.1.2": [
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3ffc161d00>\naxis_frame = 1, tz_naive_fixture = None\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3ffc4f40a0>\naxis_frame = 1, tz_naive_fixture = 'UTC'\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3ff75a57c0>\naxis_frame = 1, tz_naive_fixture = 'US/Eastern'\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3ff75dcfa0>\naxis_frame = 1, tz_naive_fixture = 'Asia/Tokyo'\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3ff99ab9a0>\naxis_frame = 1, tz_naive_fixture = 'dateutil/US/Pacific'\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3ff98ef9a0>\naxis_frame = 1, tz_naive_fixture = 'dateutil/Asia/Singapore'\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3ff71a19a0>\naxis_frame = 1, tz_naive_fixture = tzutc()\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3ff74db7f0>\naxis_frame = 1, tz_naive_fixture = tzlocal()\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3ff9df91c0>\naxis_frame = 1, tz_naive_fixture = pytz.FixedOffset(300)\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3ff9cf8a60>\naxis_frame = 1, tz_naive_fixture = <UTC>\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3ff98709d0>\naxis_frame = 1, tz_naive_fixture = pytz.FixedOffset(-300)\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3fe3d13a00>\naxis_frame = 1, tz_naive_fixture = datetime.timezone.utc\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3fe3c8dc70>\naxis_frame = 1\ntz_naive_fixture = datetime.timezone(datetime.timedelta(seconds=3600))\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3ff7498d90>\naxis_frame = 1\ntz_naive_fixture = datetime.timezone(datetime.timedelta(days=-1, seconds=82800), 'foo')\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3ff7101070>\naxis_frame = 'columns', tz_naive_fixture = None\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3ff7494640>\naxis_frame = 'columns', tz_naive_fixture = 'UTC'\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3ff71d59d0>\naxis_frame = 'columns', tz_naive_fixture = 'US/Eastern'\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3fe3d136d0>\naxis_frame = 'columns', tz_naive_fixture = 'Asia/Tokyo'\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3ff7562190>\naxis_frame = 'columns', tz_naive_fixture = 'dateutil/US/Pacific'\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3ff9874a00>\naxis_frame = 'columns', tz_naive_fixture = 'dateutil/Asia/Singapore'\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3ff98cb8e0>\naxis_frame = 'columns', tz_naive_fixture = tzutc()\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3ff7562520>\naxis_frame = 'columns', tz_naive_fixture = tzlocal()\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3fe3d05c40>\naxis_frame = 'columns', tz_naive_fixture = pytz.FixedOffset(300)\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3ff7556cd0>\naxis_frame = 'columns', tz_naive_fixture = <UTC>\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3fe3c98e20>\naxis_frame = 'columns', tz_naive_fixture = pytz.FixedOffset(-300)\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3ff74a64f0>\naxis_frame = 'columns', tz_naive_fixture = datetime.timezone.utc\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3ff7513280>\naxis_frame = 'columns'\ntz_naive_fixture = datetime.timezone(datetime.timedelta(seconds=3600))\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f3ff9ca4be0>\naxis_frame = 'columns'\ntz_naive_fixture = datetime.timezone(datetime.timedelta(days=-1, seconds=82800), 'foo')\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ]
    ],
    "2.2.1": [
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=0]",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "            0  1\n2019-08-01  1  1\n2019-08-02  1  1\n2019-08-03  1  1",
                    "shape": "(3, 2)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=0]",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "                           0  1\n2019-08-01 00:00:00+00:00  1  1\n2019-08-02 00:00:00+00:00  1  1\n2019-08-03 00:00:00+00:00  1  1",
                    "shape": "(3, 2)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=0]",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "                           0  1\n2019-08-01 00:00:00-04:00  1  1\n2019-08-02 00:00:00-04:00  1  1\n2019-08-03 00:00:00-04:00  1  1",
                    "shape": "(3, 2)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=0]",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "                           0  1\n2019-08-01 00:00:00+09:00  1  1\n2019-08-02 00:00:00+09:00  1  1\n2019-08-03 00:00:00+09:00  1  1",
                    "shape": "(3, 2)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=0]",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "                           0  1\n2019-08-01 00:00:00-07:00  1  1\n2019-08-02 00:00:00-07:00  1  1\n2019-08-03 00:00:00-07:00  1  1",
                    "shape": "(3, 2)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=0]",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "                           0  1\n2019-08-01 00:00:00+08:00  1  1\n2019-08-02 00:00:00+08:00  1  1\n2019-08-03 00:00:00+08:00  1  1",
                    "shape": "(3, 2)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=0]",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "                           0  1\n2019-08-01 00:00:00+01:00  1  1\n2019-08-02 00:00:00+01:00  1  1\n2019-08-03 00:00:00+01:00  1  1",
                    "shape": "(3, 2)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=0]",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "                           0  1\n2019-08-01 00:00:00+05:00  1  1\n2019-08-02 00:00:00+05:00  1  1\n2019-08-03 00:00:00+05:00  1  1",
                    "shape": "(3, 2)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=0]",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "                           0  1\n2019-08-01 00:00:00-05:00  1  1\n2019-08-02 00:00:00-05:00  1  1\n2019-08-03 00:00:00-05:00  1  1",
                    "shape": "(3, 2)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=0]",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "                           0  1\n2019-08-01 00:00:00-01:00  1  1\n2019-08-02 00:00:00-01:00  1  1\n2019-08-03 00:00:00-01:00  1  1",
                    "shape": "(3, 2)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=1]",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "   2019-08-01  2019-08-02  2019-08-03\n0           1           1           1\n1           1           1           1",
                    "shape": "(2, 3)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=1]",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "   2019-08-01 00:00:00+00:00  ...  2019-08-03 00:00:00+00:00\n0                          1  ...                          1\n1                          1  ...                          1\n\n[2 rows x 3 columns]",
                    "shape": "(2, 3)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=1]",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "   2019-08-01 00:00:00-04:00  ...  2019-08-03 00:00:00-04:00\n0                          1  ...                          1\n1                          1  ...                          1\n\n[2 rows x 3 columns]",
                    "shape": "(2, 3)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=1]",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "   2019-08-01 00:00:00+09:00  ...  2019-08-03 00:00:00+09:00\n0                          1  ...                          1\n1                          1  ...                          1\n\n[2 rows x 3 columns]",
                    "shape": "(2, 3)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=1]",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "   2019-08-01 00:00:00-07:00  ...  2019-08-03 00:00:00-07:00\n0                          1  ...                          1\n1                          1  ...                          1\n\n[2 rows x 3 columns]",
                    "shape": "(2, 3)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=1]",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "   2019-08-01 00:00:00+08:00  ...  2019-08-03 00:00:00+08:00\n0                          1  ...                          1\n1                          1  ...                          1\n\n[2 rows x 3 columns]",
                    "shape": "(2, 3)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=1]",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "   2019-08-01 00:00:00+01:00  ...  2019-08-03 00:00:00+01:00\n0                          1  ...                          1\n1                          1  ...                          1\n\n[2 rows x 3 columns]",
                    "shape": "(2, 3)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=1]",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "   2019-08-01 00:00:00+05:00  ...  2019-08-03 00:00:00+05:00\n0                          1  ...                          1\n1                          1  ...                          1\n\n[2 rows x 3 columns]",
                    "shape": "(2, 3)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=1]",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "   2019-08-01 00:00:00-05:00  ...  2019-08-03 00:00:00-05:00\n0                          1  ...                          1\n1                          1  ...                          1\n\n[2 rows x 3 columns]",
                    "shape": "(2, 3)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=1]",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "   2019-08-01 00:00:00-01:00  ...  2019-08-03 00:00:00-01:00\n0                          1  ...                          1\n1                          1  ...                          1\n\n[2 rows x 3 columns]",
                    "shape": "(2, 3)",
                    "omitted": false
                }
            },
            {}
        ]
    ],
    "2.2.2": [
        [
            {
                "self": "Rolling",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.obj": "DataFrame"
            },
            {}
        ]
    ],
    "2.3.1": [
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=0]",
                    "shape": null,
                    "omitted": false
                },
                "self.axis": {
                    "value": "0",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "            0  1\n2019-08-01  1  1\n2019-08-02  1  1\n2019-08-03  1  1",
                    "shape": "(3, 2)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=0]",
                    "shape": null,
                    "omitted": false
                },
                "self.axis": {
                    "value": "0",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "                           0  1\n2019-08-01 00:00:00+00:00  1  1\n2019-08-02 00:00:00+00:00  1  1\n2019-08-03 00:00:00+00:00  1  1",
                    "shape": "(3, 2)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=0]",
                    "shape": null,
                    "omitted": false
                },
                "self.axis": {
                    "value": "0",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "                           0  1\n2019-08-01 00:00:00-04:00  1  1\n2019-08-02 00:00:00-04:00  1  1\n2019-08-03 00:00:00-04:00  1  1",
                    "shape": "(3, 2)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=0]",
                    "shape": null,
                    "omitted": false
                },
                "self.axis": {
                    "value": "0",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "                           0  1\n2019-08-01 00:00:00+09:00  1  1\n2019-08-02 00:00:00+09:00  1  1\n2019-08-03 00:00:00+09:00  1  1",
                    "shape": "(3, 2)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=0]",
                    "shape": null,
                    "omitted": false
                },
                "self.axis": {
                    "value": "0",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "                           0  1\n2019-08-01 00:00:00-07:00  1  1\n2019-08-02 00:00:00-07:00  1  1\n2019-08-03 00:00:00-07:00  1  1",
                    "shape": "(3, 2)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=0]",
                    "shape": null,
                    "omitted": false
                },
                "self.axis": {
                    "value": "0",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "                           0  1\n2019-08-01 00:00:00+08:00  1  1\n2019-08-02 00:00:00+08:00  1  1\n2019-08-03 00:00:00+08:00  1  1",
                    "shape": "(3, 2)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=0]",
                    "shape": null,
                    "omitted": false
                },
                "self.axis": {
                    "value": "0",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "                           0  1\n2019-08-01 00:00:00+01:00  1  1\n2019-08-02 00:00:00+01:00  1  1\n2019-08-03 00:00:00+01:00  1  1",
                    "shape": "(3, 2)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=0]",
                    "shape": null,
                    "omitted": false
                },
                "self.axis": {
                    "value": "0",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "                           0  1\n2019-08-01 00:00:00+05:00  1  1\n2019-08-02 00:00:00+05:00  1  1\n2019-08-03 00:00:00+05:00  1  1",
                    "shape": "(3, 2)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=0]",
                    "shape": null,
                    "omitted": false
                },
                "self.axis": {
                    "value": "0",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "                           0  1\n2019-08-01 00:00:00-05:00  1  1\n2019-08-02 00:00:00-05:00  1  1\n2019-08-03 00:00:00-05:00  1  1",
                    "shape": "(3, 2)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=0]",
                    "shape": null,
                    "omitted": false
                },
                "self.axis": {
                    "value": "0",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "                           0  1\n2019-08-01 00:00:00-01:00  1  1\n2019-08-02 00:00:00-01:00  1  1\n2019-08-03 00:00:00-01:00  1  1",
                    "shape": "(3, 2)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=1]",
                    "shape": null,
                    "omitted": false
                },
                "self.axis": {
                    "value": "1",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "   2019-08-01  2019-08-02  2019-08-03\n0           1           1           1\n1           1           1           1",
                    "shape": "(2, 3)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=1]",
                    "shape": null,
                    "omitted": false
                },
                "self.axis": {
                    "value": "1",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "   2019-08-01 00:00:00+00:00  ...  2019-08-03 00:00:00+00:00\n0                          1  ...                          1\n1                          1  ...                          1\n\n[2 rows x 3 columns]",
                    "shape": "(2, 3)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=1]",
                    "shape": null,
                    "omitted": false
                },
                "self.axis": {
                    "value": "1",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "   2019-08-01 00:00:00-04:00  ...  2019-08-03 00:00:00-04:00\n0                          1  ...                          1\n1                          1  ...                          1\n\n[2 rows x 3 columns]",
                    "shape": "(2, 3)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=1]",
                    "shape": null,
                    "omitted": false
                },
                "self.axis": {
                    "value": "1",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "   2019-08-01 00:00:00+09:00  ...  2019-08-03 00:00:00+09:00\n0                          1  ...                          1\n1                          1  ...                          1\n\n[2 rows x 3 columns]",
                    "shape": "(2, 3)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=1]",
                    "shape": null,
                    "omitted": false
                },
                "self.axis": {
                    "value": "1",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "   2019-08-01 00:00:00-07:00  ...  2019-08-03 00:00:00-07:00\n0                          1  ...                          1\n1                          1  ...                          1\n\n[2 rows x 3 columns]",
                    "shape": "(2, 3)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=1]",
                    "shape": null,
                    "omitted": false
                },
                "self.axis": {
                    "value": "1",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "   2019-08-01 00:00:00+08:00  ...  2019-08-03 00:00:00+08:00\n0                          1  ...                          1\n1                          1  ...                          1\n\n[2 rows x 3 columns]",
                    "shape": "(2, 3)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=1]",
                    "shape": null,
                    "omitted": false
                },
                "self.axis": {
                    "value": "1",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "   2019-08-01 00:00:00+01:00  ...  2019-08-03 00:00:00+01:00\n0                          1  ...                          1\n1                          1  ...                          1\n\n[2 rows x 3 columns]",
                    "shape": "(2, 3)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=1]",
                    "shape": null,
                    "omitted": false
                },
                "self.axis": {
                    "value": "1",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "   2019-08-01 00:00:00+05:00  ...  2019-08-03 00:00:00+05:00\n0                          1  ...                          1\n1                          1  ...                          1\n\n[2 rows x 3 columns]",
                    "shape": "(2, 3)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=1]",
                    "shape": null,
                    "omitted": false
                },
                "self.axis": {
                    "value": "1",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "   2019-08-01 00:00:00-05:00  ...  2019-08-03 00:00:00-05:00\n0                          1  ...                          1\n1                          1  ...                          1\n\n[2 rows x 3 columns]",
                    "shape": "(2, 3)",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "self": {
                    "value": "Rolling [window=2D,center=False,axis=1]",
                    "shape": null,
                    "omitted": false
                },
                "self.axis": {
                    "value": "1",
                    "shape": null,
                    "omitted": false
                },
                "self.obj": {
                    "value": "   2019-08-01 00:00:00-01:00  ...  2019-08-03 00:00:00-01:00\n0                          1  ...                          1\n1                          1  ...                          1\n\n[2 rows x 3 columns]",
                    "shape": "(2, 3)",
                    "omitted": false
                }
            },
            {}
        ]
    ],
    "2.3.2": [
        [
            {
                "self": "Rolling",
                "self.axis": "int",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.axis": "int",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.axis": "int",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.axis": "int",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.axis": "int",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.axis": "int",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.axis": "int",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.axis": "int",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.axis": "int",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.axis": "int",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.axis": "int",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.axis": "int",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.axis": "int",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.axis": "int",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.axis": "int",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.axis": "int",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.axis": "int",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.axis": "int",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.axis": "int",
                "self.obj": "DataFrame"
            },
            {}
        ],
        [
            {
                "self": "Rolling",
                "self.axis": "int",
                "self.obj": "DataFrame"
            },
            {}
        ]
    ],
    "3.1.1": [
        "Rolling with offset and axis=1\n"
    ],
    "3.1.2": [
        "Code Sample\nHere I have a DataFrame with a DatetimeIndex for the columns:\n\ncols = pd.date_range('2019-8-01', '2019-08-07', freq='D')\ndata = np.ones((5, len(cols)))\ndf = pd.DataFrame(data, columns=cols)\ndf.rolling('1d', axis=1).sum()\nThe above gives 'ValueError: window must be an integer'\n\nHere I have a DataFrame with a DatetimeIndex for the rows:\n\ndf2 = df.transpose()\ndf2.rolling('2d', axis=0).sum()\nHowever this works totally fine.\n\nProblem description\nI believe there may be a bug: If I have a DatetimeIndex in the columns, specifying an offset for df.rolling does not work but gives a value error (that the window must be an integer). It works however as expected if I transpose the dataframe.\n"
    ]
}