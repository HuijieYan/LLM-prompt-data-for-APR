{
    "1.1.1": "def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n    \n    left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n    right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n\n    target = np.asarray(target)\n    left_distances = abs(self.values[left_indexer] - target)\n    right_distances = abs(self.values[right_indexer] - target)\n\n    op = operator.lt if self.is_monotonic_increasing else operator.le\n    indexer = np.where(\n        op(left_distances, right_distances) | (right_indexer == -1),\n        left_indexer,\n        right_indexer,\n    )\n    if tolerance is not None:\n        indexer = self._filter_indexer_tolerance(target, indexer, tolerance)\n    return indexer\n",
    "1.1.2": "Get the indexer for the nearest index labels; requires an index with\nvalues that can be subtracted from each other (e.g., not strings or\ntuples).",
    "1.2.1": "pandas/core/indexes/base.py",
    "1.2.2": "import operator\nimport numpy as np",
    "1.3.1": "class Index(IndexOpsMixin, PandasObject)",
    "1.3.2": "Immutable ndarray implementing an ordered, sliceable set. The basic object\nstoring axis labels for all pandas objects.\n\nParameters\n----------\ndata : array-like (1-dimensional)\ndtype : NumPy dtype (default: object)\n    If dtype is None, we find the dtype that best fits the data.\n    If an actual dtype is provided, we coerce to that dtype if it's safe.\n    Otherwise, an error will be raised.\ncopy : bool\n    Make a copy of input ndarray.\nname : object\n    Name to be stored in the index.\ntupleize_cols : bool (default: True)\n    When True, attempt to create a MultiIndex if possible.\n\nSee Also\n--------\nRangeIndex : Index implementing a monotonic integer range.\nCategoricalIndex : Index of :class:`Categorical` s.\nMultiIndex : A multi-level, or hierarchical, Index.\nIntervalIndex : An Index of :class:`Interval` s.\nDatetimeIndex, TimedeltaIndex, PeriodIndex\nInt64Index, UInt64Index,  Float64Index\n\nNotes\n-----\nAn Index instance can **only** contain hashable objects\n\nExamples\n--------\n>>> pd.Index([1, 2, 3])\nInt64Index([1, 2, 3], dtype='int64')\n\n>>> pd.Index(list('abc'))\nIndex(['a', 'b', 'c'], dtype='object')",
    "1.4.1": [
        "is_monotonic_increasing(self) -> bool",
        "get_indexer(self, target, method=None, limit=None, tolerance=None) -> np.ndarray",
        "_filter_indexer_tolerance(self, target: 'Index', indexer: np.ndarray, tolerance) -> np.ndarray",
        "values(self) -> np.ndarray",
        "where(self, cond, other=None)"
    ],
    "1.4.2": null,
    "1.5.1": [
        "    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n\n        expected = df.head(3)\n        actual = df.reindex(idx[:3], method=\"nearest\")\n        tm.assert_frame_equal(expected, actual)",
        "    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n\n        expected = df.head(3)\n        actual = df.reindex(idx[:3], method=\"nearest\")\n        tm.assert_frame_equal(expected, actual)",
        "    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n\n        expected = df.head(3)\n        actual = df.reindex(idx[:3], method=\"nearest\")\n        tm.assert_frame_equal(expected, actual)",
        "    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n\n        expected = df.head(3)\n        actual = df.reindex(idx[:3], method=\"nearest\")\n        tm.assert_frame_equal(expected, actual)",
        "    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n\n        expected = df.head(3)\n        actual = df.reindex(idx[:3], method=\"nearest\")\n        tm.assert_frame_equal(expected, actual)",
        "    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n\n        expected = df.head(3)\n        actual = df.reindex(idx[:3], method=\"nearest\")\n        tm.assert_frame_equal(expected, actual)",
        "    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n\n        expected = df.head(3)\n        actual = df.reindex(idx[:3], method=\"nearest\")\n        tm.assert_frame_equal(expected, actual)",
        "    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n\n        expected = df.head(3)\n        actual = df.reindex(idx[:3], method=\"nearest\")\n        tm.assert_frame_equal(expected, actual)",
        "    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n\n        expected = df.head(3)\n        actual = df.reindex(idx[:3], method=\"nearest\")\n        tm.assert_frame_equal(expected, actual)",
        "    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n\n        expected = df.head(3)\n        actual = df.reindex(idx[:3], method=\"nearest\")\n        tm.assert_frame_equal(expected, actual)",
        "    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n\n        expected = df.head(3)\n        actual = df.reindex(idx[:3], method=\"nearest\")\n        tm.assert_frame_equal(expected, actual)",
        "    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n\n        expected = df.head(3)\n        actual = df.reindex(idx[:3], method=\"nearest\")\n        tm.assert_frame_equal(expected, actual)",
        "    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n\n        expected = df.head(3)\n        actual = df.reindex(idx[:3], method=\"nearest\")\n        tm.assert_frame_equal(expected, actual)"
    ],
    "1.5.2": [
        "pandas/tests/frame/indexing/test_indexing.py",
        "pandas/tests/frame/indexing/test_indexing.py",
        "pandas/tests/frame/indexing/test_indexing.py",
        "pandas/tests/frame/indexing/test_indexing.py",
        "pandas/tests/frame/indexing/test_indexing.py",
        "pandas/tests/frame/indexing/test_indexing.py",
        "pandas/tests/frame/indexing/test_indexing.py",
        "pandas/tests/frame/indexing/test_indexing.py",
        "pandas/tests/frame/indexing/test_indexing.py",
        "pandas/tests/frame/indexing/test_indexing.py",
        "pandas/tests/frame/indexing/test_indexing.py",
        "pandas/tests/frame/indexing/test_indexing.py",
        "pandas/tests/frame/indexing/test_indexing.py"
    ],
    "2.1.1": [
        [
            "E       numpy.core._exceptions.UFuncTypeError: ufunc 'subtract' cannot use operands with types dtype('<M8[ns]') and dtype('O')"
        ],
        [
            "E       numpy.core._exceptions.UFuncTypeError: ufunc 'subtract' cannot use operands with types dtype('<M8[ns]') and dtype('O')"
        ],
        [
            "E       numpy.core._exceptions.UFuncTypeError: ufunc 'subtract' cannot use operands with types dtype('<M8[ns]') and dtype('O')"
        ],
        [
            "E       numpy.core._exceptions.UFuncTypeError: ufunc 'subtract' cannot use operands with types dtype('<M8[ns]') and dtype('O')"
        ],
        [
            "E       numpy.core._exceptions.UFuncTypeError: ufunc 'subtract' cannot use operands with types dtype('<M8[ns]') and dtype('O')"
        ],
        [
            "E       numpy.core._exceptions.UFuncTypeError: ufunc 'subtract' cannot use operands with types dtype('<M8[ns]') and dtype('O')"
        ],
        [
            "E       numpy.core._exceptions.UFuncTypeError: ufunc 'subtract' cannot use operands with types dtype('<M8[ns]') and dtype('O')"
        ],
        [
            "E       numpy.core._exceptions.UFuncTypeError: ufunc 'subtract' cannot use operands with types dtype('<M8[ns]') and dtype('O')"
        ],
        [
            "E       numpy.core._exceptions.UFuncTypeError: ufunc 'subtract' cannot use operands with types dtype('<M8[ns]') and dtype('O')"
        ],
        [
            "E       numpy.core._exceptions.UFuncTypeError: ufunc 'subtract' cannot use operands with types dtype('<M8[ns]') and dtype('O')"
        ],
        [
            "E       numpy.core._exceptions.UFuncTypeError: ufunc 'subtract' cannot use operands with types dtype('<M8[ns]') and dtype('O')"
        ],
        [
            "E       numpy.core._exceptions.UFuncTypeError: ufunc 'subtract' cannot use operands with types dtype('<M8[ns]') and dtype('O')"
        ],
        [
            "E       numpy.core._exceptions.UFuncTypeError: ufunc 'subtract' cannot use operands with types dtype('<M8[ns]') and dtype('O')"
        ]
    ],
    "2.1.2": [
        [
            "self = <test_indexing.TestDataFrameIndexing object at 0x7fda72e8eb50>\ntz_aware_fixture = 'UTC'\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00+00:00', '2019-01-02 00:00:00+00:00',\n               '2019-01-03 00:00:00+00:00', '...1-04 00:00:00+00:00',\n               '2019-01-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00+0000', tz='UTC', freq='D'),\n       Timestamp('2019-01-02 00:00:00+0000', tz='UTC', freq='D'),\n       Timestamp('2019-01-03 00:00:00+0000', tz='UTC', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
            "\npandas/core/indexes/base.py:3077: UFuncTypeError"
        ],
        [
            "self = <test_indexing.TestDataFrameIndexing object at 0x7fda6bc05f70>\ntz_aware_fixture = 'US/Eastern'\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00-05:00', '2019-01-02 00:00:00-05:00',\n               '2019-01-03 00:00:00-05:00', '...:00:00-05:00',\n               '2019-01-05 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00-0500', tz='US/Eastern', freq='D'),\n       Timestamp('2019-01-02 00:00:00-0500', tz='US/Eastern', freq='D'),\n       Timestamp('2019-01-03 00:00:00-0500', tz='US/Eastern', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
            "\npandas/core/indexes/base.py:3077: UFuncTypeError"
        ],
        [
            "self = <test_indexing.TestDataFrameIndexing object at 0x7fda58ad9eb0>\ntz_aware_fixture = 'Asia/Tokyo'\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00+09:00', '2019-01-02 00:00:00+09:00',\n               '2019-01-03 00:00:00+09:00', '...:00:00+09:00',\n               '2019-01-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00+0900', tz='Asia/Tokyo', freq='D'),\n       Timestamp('2019-01-02 00:00:00+0900', tz='Asia/Tokyo', freq='D'),\n       Timestamp('2019-01-03 00:00:00+0900', tz='Asia/Tokyo', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
            "\npandas/core/indexes/base.py:3077: UFuncTypeError"
        ],
        [
            "self = <test_indexing.TestDataFrameIndexing object at 0x7fda58b1cd00>\ntz_aware_fixture = 'dateutil/US/Pacific'\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00-08:00', '2019-01-02 00:00:00-08:00',\n               '2019-01-03 00:00:00-08:00', '...'2019-01-05 00:00:00-08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00-0800', tz='dateutil//usr/share/zoneinfo/US/Pacific', freq='D'),\n       Timestamp...    Timestamp('2019-01-03 00:00:00-0800', tz='dateutil//usr/share/zoneinfo/US/Pacific', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
            "\npandas/core/indexes/base.py:3077: UFuncTypeError"
        ],
        [
            "self = <test_indexing.TestDataFrameIndexing object at 0x7fda58e67d30>\ntz_aware_fixture = 'dateutil/Asia/Singapore'\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00+08:00', '2019-01-02 00:00:00+08:00',\n               '2019-01-03 00:00:00+08:00', '...9-01-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00+0800', tz='dateutil//usr/share/zoneinfo/Asia/Singapore', freq='D'),\n       Times...Timestamp('2019-01-03 00:00:00+0800', tz='dateutil//usr/share/zoneinfo/Asia/Singapore', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
            "\npandas/core/indexes/base.py:3077: UFuncTypeError"
        ],
        [
            "self = <test_indexing.TestDataFrameIndexing object at 0x7fda58791400>\ntz_aware_fixture = tzutc()\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00+00:00', '2019-01-02 00:00:00+00:00',\n               '2019-01-03 00:00:00+00:00', '... 00:00:00+00:00',\n               '2019-01-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00+0000', tz='tzutc()', freq='D'),\n       Timestamp('2019-01-02 00:00:00+0000', tz='tzutc()', freq='D'),\n       Timestamp('2019-01-03 00:00:00+0000', tz='tzutc()', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
            "\npandas/core/indexes/base.py:3077: UFuncTypeError"
        ],
        [
            "self = <test_indexing.TestDataFrameIndexing object at 0x7fda593ee190>\ntz_aware_fixture = tzlocal()\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00+00:00', '2019-01-02 00:00:00+00:00',\n               '2019-01-03 00:00:00+00:00', '...0:00:00+00:00',\n               '2019-01-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00+0000', tz='tzlocal()', freq='D'),\n       Timestamp('2019-01-02 00:00:00+0000', tz='tzlocal()', freq='D'),\n       Timestamp('2019-01-03 00:00:00+0000', tz='tzlocal()', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
            "\npandas/core/indexes/base.py:3077: UFuncTypeError"
        ],
        [
            "self = <test_indexing.TestDataFrameIndexing object at 0x7fda592761c0>\ntz_aware_fixture = pytz.FixedOffset(300)\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00+05:00', '2019-01-02 00:00:00+05:00',\n               '2019-01-03 00:00:00+05:00', '...0',\n               '2019-01-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00+0500', tz='pytz.FixedOffset(300)', freq='D'),\n       Timestamp('2019-01-02 00:00...)', freq='D'),\n       Timestamp('2019-01-03 00:00:00+0500', tz='pytz.FixedOffset(300)', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
            "\npandas/core/indexes/base.py:3077: UFuncTypeError"
        ],
        [
            "self = <test_indexing.TestDataFrameIndexing object at 0x7fda596fcbb0>\ntz_aware_fixture = <UTC>\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00+00:00', '2019-01-02 00:00:00+00:00',\n               '2019-01-03 00:00:00+00:00', '...1-04 00:00:00+00:00',\n               '2019-01-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00+0000', tz='UTC', freq='D'),\n       Timestamp('2019-01-02 00:00:00+0000', tz='UTC', freq='D'),\n       Timestamp('2019-01-03 00:00:00+0000', tz='UTC', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
            "\npandas/core/indexes/base.py:3077: UFuncTypeError"
        ],
        [
            "self = <test_indexing.TestDataFrameIndexing object at 0x7fda59afd280>\ntz_aware_fixture = pytz.FixedOffset(-300)\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00-05:00', '2019-01-02 00:00:00-05:00',\n               '2019-01-03 00:00:00-05:00', '...',\n               '2019-01-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00-0500', tz='pytz.FixedOffset(-300)', freq='D'),\n       Timestamp('2019-01-02 00:0...', freq='D'),\n       Timestamp('2019-01-03 00:00:00-0500', tz='pytz.FixedOffset(-300)', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
            "\npandas/core/indexes/base.py:3077: UFuncTypeError"
        ],
        [
            "self = <test_indexing.TestDataFrameIndexing object at 0x7fda6e7ef3d0>\ntz_aware_fixture = datetime.timezone.utc\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00+00:00', '2019-01-02 00:00:00+00:00',\n               '2019-01-03 00:00:00+00:00', '...1-04 00:00:00+00:00',\n               '2019-01-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00+0000', tz='UTC', freq='D'),\n       Timestamp('2019-01-02 00:00:00+0000', tz='UTC', freq='D'),\n       Timestamp('2019-01-03 00:00:00+0000', tz='UTC', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
            "\npandas/core/indexes/base.py:3077: UFuncTypeError"
        ],
        [
            "self = <test_indexing.TestDataFrameIndexing object at 0x7fda59b54ca0>\ntz_aware_fixture = datetime.timezone(datetime.timedelta(seconds=3600))\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00+01:00', '2019-01-02 00:00:00+01:00',\n               '2019-01-03 00:00:00+01:00', '...0:00:00+01:00',\n               '2019-01-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00+0100', tz='UTC+01:00', freq='D'),\n       Timestamp('2019-01-02 00:00:00+0100', tz='UTC+01:00', freq='D'),\n       Timestamp('2019-01-03 00:00:00+0100', tz='UTC+01:00', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
            "\npandas/core/indexes/base.py:3077: UFuncTypeError"
        ],
        [
            "self = <test_indexing.TestDataFrameIndexing object at 0x7fda6eb93790>\ntz_aware_fixture = datetime.timezone(datetime.timedelta(days=-1, seconds=82800), 'foo')\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00-01:00', '2019-01-02 00:00:00-01:00',\n               '2019-01-03 00:00:00-01:00', '...1-04 00:00:00-01:00',\n               '2019-01-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00-0100', tz='foo', freq='D'),\n       Timestamp('2019-01-02 00:00:00-0100', tz='foo', freq='D'),\n       Timestamp('2019-01-03 00:00:00-0100', tz='foo', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
            "\npandas/core/indexes/base.py:3077: UFuncTypeError"
        ]
    ],
    "2.2.1": null,
    "2.2.2": null,
    "2.3.1": [
        [
            {
                "self": {
                    "value": "DatetimeIndex(['2019-01-01 00:00:00+00:00', '2019-01-02 00:00:00+00:00',\n               '2019-01-03 00:00:00+00:00', '2019-01-04 00:00:00+00:00',\n               '2019-01-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='D')",
                    "shape": "(5,)",
                    "omitted": false
                },
                "target": {
                    "value": "DatetimeIndex(['2019-01-01 00:00:00+00:00', '2019-01-02 00:00:00+00:00',\n               '2019-01-03 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='D')",
                    "shape": "(3,)",
                    "omitted": false
                },
                "self.is_monotonic_increasing": {
                    "value": "True",
                    "shape": null,
                    "omitted": false
                }
            },
            {
                "left_indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "right_indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "left_distances": {
                    "value": "TimedeltaIndex(['0 days', '0 days', '0 days'], dtype='timedelta64[ns]', freq=None)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "right_distances": {
                    "value": "TimedeltaIndex(['0 days', '0 days', '0 days'], dtype='timedelta64[ns]', freq=None)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "op": {
                    "value": "<built-in function lt>",
                    "shape": null,
                    "omitted": false
                },
                "indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                }
            }
        ],
        [
            {
                "self": {
                    "value": "DatetimeIndex(['2019-01-01 00:00:00-05:00', '2019-01-02 00:00:00-05:00',\n               '2019-01-03 00:00:00-05:00', '2019-01-04 00:00:00-05:00',\n               '2019-01-05 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='D')",
                    "shape": "(5,)",
                    "omitted": false
                },
                "target": {
                    "value": "DatetimeIndex(['2019-01-01 00:00:00-05:00', '2019-01-02 00:00:00-05:00',\n               '2019-01-03 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='D')",
                    "shape": "(3,)",
                    "omitted": false
                },
                "self.is_monotonic_increasing": {
                    "value": "True",
                    "shape": null,
                    "omitted": false
                }
            },
            {
                "left_indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "right_indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "left_distances": {
                    "value": "TimedeltaIndex(['0 days', '0 days', '0 days'], dtype='timedelta64[ns]', freq=None)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "right_distances": {
                    "value": "TimedeltaIndex(['0 days', '0 days', '0 days'], dtype='timedelta64[ns]', freq=None)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "op": {
                    "value": "<built-in function lt>",
                    "shape": null,
                    "omitted": false
                },
                "indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                }
            }
        ],
        [
            {
                "self": {
                    "value": "DatetimeIndex(['2019-01-01 00:00:00+09:00', '2019-01-02 00:00:00+09:00',\n               '2019-01-03 00:00:00+09:00', '2019-01-04 00:00:00+09:00',\n               '2019-01-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='D')",
                    "shape": "(5,)",
                    "omitted": false
                },
                "target": {
                    "value": "DatetimeIndex(['2019-01-01 00:00:00+09:00', '2019-01-02 00:00:00+09:00',\n               '2019-01-03 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='D')",
                    "shape": "(3,)",
                    "omitted": false
                },
                "self.is_monotonic_increasing": {
                    "value": "True",
                    "shape": null,
                    "omitted": false
                }
            },
            {
                "left_indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "right_indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "left_distances": {
                    "value": "TimedeltaIndex(['0 days', '0 days', '0 days'], dtype='timedelta64[ns]', freq=None)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "right_distances": {
                    "value": "TimedeltaIndex(['0 days', '0 days', '0 days'], dtype='timedelta64[ns]', freq=None)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "op": {
                    "value": "<built-in function lt>",
                    "shape": null,
                    "omitted": false
                },
                "indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                }
            }
        ],
        [
            {
                "self": {
                    "value": "DatetimeIndex(['2019-01-01 00:00:00-08:00', '2019-01-02 00:00:00-08:00',\n               '2019-01-03 00:00:00-08:00', '2019-01-04 00:00:00-08:00',\n               '2019-01-05 00:00:00-08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='D')",
                    "shape": "(5,)",
                    "omitted": false
                },
                "target": {
                    "value": "DatetimeIndex(['2019-01-01 00:00:00-08:00', '2019-01-02 00:00:00-08:00',\n               '2019-01-03 00:00:00-08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='D')",
                    "shape": "(3,)",
                    "omitted": false
                },
                "self.is_monotonic_increasing": {
                    "value": "True",
                    "shape": null,
                    "omitted": false
                }
            },
            {
                "left_indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "right_indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "left_distances": {
                    "value": "TimedeltaIndex(['0 days', '0 days', '0 days'], dtype='timedelta64[ns]', freq=None)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "right_distances": {
                    "value": "TimedeltaIndex(['0 days', '0 days', '0 days'], dtype='timedelta64[ns]', freq=None)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "op": {
                    "value": "<built-in function lt>",
                    "shape": null,
                    "omitted": false
                },
                "indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                }
            }
        ],
        [
            {
                "self": {
                    "value": "DatetimeIndex(['2019-01-01 00:00:00+08:00', '2019-01-02 00:00:00+08:00',\n               '2019-01-03 00:00:00+08:00', '2019-01-04 00:00:00+08:00',\n               '2019-01-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='D')",
                    "shape": "(5,)",
                    "omitted": false
                },
                "target": {
                    "value": "DatetimeIndex(['2019-01-01 00:00:00+08:00', '2019-01-02 00:00:00+08:00',\n               '2019-01-03 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='D')",
                    "shape": "(3,)",
                    "omitted": false
                },
                "self.is_monotonic_increasing": {
                    "value": "True",
                    "shape": null,
                    "omitted": false
                }
            },
            {
                "left_indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "right_indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "left_distances": {
                    "value": "TimedeltaIndex(['0 days', '0 days', '0 days'], dtype='timedelta64[ns]', freq=None)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "right_distances": {
                    "value": "TimedeltaIndex(['0 days', '0 days', '0 days'], dtype='timedelta64[ns]', freq=None)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "op": {
                    "value": "<built-in function lt>",
                    "shape": null,
                    "omitted": false
                },
                "indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                }
            }
        ],
        [
            {
                "self": {
                    "value": "DatetimeIndex(['2019-01-01 00:00:00+00:00', '2019-01-02 00:00:00+00:00',\n               '2019-01-03 00:00:00+00:00', '2019-01-04 00:00:00+00:00',\n               '2019-01-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='D')",
                    "shape": "(5,)",
                    "omitted": false
                },
                "target": {
                    "value": "DatetimeIndex(['2019-01-01 00:00:00+00:00', '2019-01-02 00:00:00+00:00',\n               '2019-01-03 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='D')",
                    "shape": "(3,)",
                    "omitted": false
                },
                "self.is_monotonic_increasing": {
                    "value": "True",
                    "shape": null,
                    "omitted": false
                }
            },
            {
                "left_indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "right_indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "left_distances": {
                    "value": "TimedeltaIndex(['0 days', '0 days', '0 days'], dtype='timedelta64[ns]', freq=None)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "right_distances": {
                    "value": "TimedeltaIndex(['0 days', '0 days', '0 days'], dtype='timedelta64[ns]', freq=None)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "op": {
                    "value": "<built-in function lt>",
                    "shape": null,
                    "omitted": false
                },
                "indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                }
            }
        ],
        [
            {
                "self": {
                    "value": "DatetimeIndex(['2019-01-01 00:00:00+00:00', '2019-01-02 00:00:00+00:00',\n               '2019-01-03 00:00:00+00:00', '2019-01-04 00:00:00+00:00',\n               '2019-01-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='D')",
                    "shape": "(5,)",
                    "omitted": false
                },
                "target": {
                    "value": "DatetimeIndex(['2019-01-01 00:00:00+00:00', '2019-01-02 00:00:00+00:00',\n               '2019-01-03 00:00:00+00:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='D')",
                    "shape": "(3,)",
                    "omitted": false
                },
                "self.is_monotonic_increasing": {
                    "value": "True",
                    "shape": null,
                    "omitted": false
                }
            },
            {
                "left_indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "right_indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "left_distances": {
                    "value": "TimedeltaIndex(['0 days', '0 days', '0 days'], dtype='timedelta64[ns]', freq=None)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "right_distances": {
                    "value": "TimedeltaIndex(['0 days', '0 days', '0 days'], dtype='timedelta64[ns]', freq=None)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "op": {
                    "value": "<built-in function lt>",
                    "shape": null,
                    "omitted": false
                },
                "indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                }
            }
        ],
        [
            {
                "self": {
                    "value": "DatetimeIndex(['2019-01-01 00:00:00+05:00', '2019-01-02 00:00:00+05:00',\n               '2019-01-03 00:00:00+05:00', '2019-01-04 00:00:00+05:00',\n               '2019-01-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='D')",
                    "shape": "(5,)",
                    "omitted": false
                },
                "target": {
                    "value": "DatetimeIndex(['2019-01-01 00:00:00+05:00', '2019-01-02 00:00:00+05:00',\n               '2019-01-03 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='D')",
                    "shape": "(3,)",
                    "omitted": false
                },
                "self.is_monotonic_increasing": {
                    "value": "True",
                    "shape": null,
                    "omitted": false
                }
            },
            {
                "left_indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "right_indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "left_distances": {
                    "value": "TimedeltaIndex(['0 days', '0 days', '0 days'], dtype='timedelta64[ns]', freq=None)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "right_distances": {
                    "value": "TimedeltaIndex(['0 days', '0 days', '0 days'], dtype='timedelta64[ns]', freq=None)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "op": {
                    "value": "<built-in function lt>",
                    "shape": null,
                    "omitted": false
                },
                "indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                }
            }
        ],
        [
            {
                "self": {
                    "value": "DatetimeIndex(['2019-01-01 00:00:00-05:00', '2019-01-02 00:00:00-05:00',\n               '2019-01-03 00:00:00-05:00', '2019-01-04 00:00:00-05:00',\n               '2019-01-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='D')",
                    "shape": "(5,)",
                    "omitted": false
                },
                "target": {
                    "value": "DatetimeIndex(['2019-01-01 00:00:00-05:00', '2019-01-02 00:00:00-05:00',\n               '2019-01-03 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='D')",
                    "shape": "(3,)",
                    "omitted": false
                },
                "self.is_monotonic_increasing": {
                    "value": "True",
                    "shape": null,
                    "omitted": false
                }
            },
            {
                "left_indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "right_indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "left_distances": {
                    "value": "TimedeltaIndex(['0 days', '0 days', '0 days'], dtype='timedelta64[ns]', freq=None)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "right_distances": {
                    "value": "TimedeltaIndex(['0 days', '0 days', '0 days'], dtype='timedelta64[ns]', freq=None)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "op": {
                    "value": "<built-in function lt>",
                    "shape": null,
                    "omitted": false
                },
                "indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                }
            }
        ],
        [
            {
                "self": {
                    "value": "DatetimeIndex(['2019-01-01 00:00:00+01:00', '2019-01-02 00:00:00+01:00',\n               '2019-01-03 00:00:00+01:00', '2019-01-04 00:00:00+01:00',\n               '2019-01-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='D')",
                    "shape": "(5,)",
                    "omitted": false
                },
                "target": {
                    "value": "DatetimeIndex(['2019-01-01 00:00:00+01:00', '2019-01-02 00:00:00+01:00',\n               '2019-01-03 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='D')",
                    "shape": "(3,)",
                    "omitted": false
                },
                "self.is_monotonic_increasing": {
                    "value": "True",
                    "shape": null,
                    "omitted": false
                }
            },
            {
                "left_indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "right_indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "left_distances": {
                    "value": "TimedeltaIndex(['0 days', '0 days', '0 days'], dtype='timedelta64[ns]', freq=None)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "right_distances": {
                    "value": "TimedeltaIndex(['0 days', '0 days', '0 days'], dtype='timedelta64[ns]', freq=None)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "op": {
                    "value": "<built-in function lt>",
                    "shape": null,
                    "omitted": false
                },
                "indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                }
            }
        ],
        [
            {
                "self": {
                    "value": "DatetimeIndex(['2019-01-01 00:00:00-01:00', '2019-01-02 00:00:00-01:00',\n               '2019-01-03 00:00:00-01:00', '2019-01-04 00:00:00-01:00',\n               '2019-01-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='D')",
                    "shape": "(5,)",
                    "omitted": false
                },
                "target": {
                    "value": "DatetimeIndex(['2019-01-01 00:00:00-01:00', '2019-01-02 00:00:00-01:00',\n               '2019-01-03 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='D')",
                    "shape": "(3,)",
                    "omitted": false
                },
                "self.is_monotonic_increasing": {
                    "value": "True",
                    "shape": null,
                    "omitted": false
                }
            },
            {
                "left_indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "right_indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                },
                "left_distances": {
                    "value": "TimedeltaIndex(['0 days', '0 days', '0 days'], dtype='timedelta64[ns]', freq=None)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "right_distances": {
                    "value": "TimedeltaIndex(['0 days', '0 days', '0 days'], dtype='timedelta64[ns]', freq=None)",
                    "shape": "(3,)",
                    "omitted": false
                },
                "op": {
                    "value": "<built-in function lt>",
                    "shape": null,
                    "omitted": false
                },
                "indexer": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)",
                    "omitted": false
                }
            }
        ]
    ],
    "2.3.2": [
        [
            {
                "self": "DatetimeIndex",
                "target": "DatetimeIndex",
                "self.is_monotonic_increasing": "bool"
            },
            {
                "left_indexer": "ndarray",
                "right_indexer": "ndarray",
                "left_distances": "TimedeltaIndex",
                "right_distances": "TimedeltaIndex",
                "op": "builtin_function_or_method",
                "indexer": "ndarray"
            }
        ],
        [
            {
                "self": "DatetimeIndex",
                "target": "DatetimeIndex",
                "self.is_monotonic_increasing": "bool"
            },
            {
                "left_indexer": "ndarray",
                "right_indexer": "ndarray",
                "left_distances": "TimedeltaIndex",
                "right_distances": "TimedeltaIndex",
                "op": "builtin_function_or_method",
                "indexer": "ndarray"
            }
        ],
        [
            {
                "self": "DatetimeIndex",
                "target": "DatetimeIndex",
                "self.is_monotonic_increasing": "bool"
            },
            {
                "left_indexer": "ndarray",
                "right_indexer": "ndarray",
                "left_distances": "TimedeltaIndex",
                "right_distances": "TimedeltaIndex",
                "op": "builtin_function_or_method",
                "indexer": "ndarray"
            }
        ],
        [
            {
                "self": "DatetimeIndex",
                "target": "DatetimeIndex",
                "self.is_monotonic_increasing": "bool"
            },
            {
                "left_indexer": "ndarray",
                "right_indexer": "ndarray",
                "left_distances": "TimedeltaIndex",
                "right_distances": "TimedeltaIndex",
                "op": "builtin_function_or_method",
                "indexer": "ndarray"
            }
        ],
        [
            {
                "self": "DatetimeIndex",
                "target": "DatetimeIndex",
                "self.is_monotonic_increasing": "bool"
            },
            {
                "left_indexer": "ndarray",
                "right_indexer": "ndarray",
                "left_distances": "TimedeltaIndex",
                "right_distances": "TimedeltaIndex",
                "op": "builtin_function_or_method",
                "indexer": "ndarray"
            }
        ],
        [
            {
                "self": "DatetimeIndex",
                "target": "DatetimeIndex",
                "self.is_monotonic_increasing": "bool"
            },
            {
                "left_indexer": "ndarray",
                "right_indexer": "ndarray",
                "left_distances": "TimedeltaIndex",
                "right_distances": "TimedeltaIndex",
                "op": "builtin_function_or_method",
                "indexer": "ndarray"
            }
        ],
        [
            {
                "self": "DatetimeIndex",
                "target": "DatetimeIndex",
                "self.is_monotonic_increasing": "bool"
            },
            {
                "left_indexer": "ndarray",
                "right_indexer": "ndarray",
                "left_distances": "TimedeltaIndex",
                "right_distances": "TimedeltaIndex",
                "op": "builtin_function_or_method",
                "indexer": "ndarray"
            }
        ],
        [
            {
                "self": "DatetimeIndex",
                "target": "DatetimeIndex",
                "self.is_monotonic_increasing": "bool"
            },
            {
                "left_indexer": "ndarray",
                "right_indexer": "ndarray",
                "left_distances": "TimedeltaIndex",
                "right_distances": "TimedeltaIndex",
                "op": "builtin_function_or_method",
                "indexer": "ndarray"
            }
        ],
        [
            {
                "self": "DatetimeIndex",
                "target": "DatetimeIndex",
                "self.is_monotonic_increasing": "bool"
            },
            {
                "left_indexer": "ndarray",
                "right_indexer": "ndarray",
                "left_distances": "TimedeltaIndex",
                "right_distances": "TimedeltaIndex",
                "op": "builtin_function_or_method",
                "indexer": "ndarray"
            }
        ],
        [
            {
                "self": "DatetimeIndex",
                "target": "DatetimeIndex",
                "self.is_monotonic_increasing": "bool"
            },
            {
                "left_indexer": "ndarray",
                "right_indexer": "ndarray",
                "left_distances": "TimedeltaIndex",
                "right_distances": "TimedeltaIndex",
                "op": "builtin_function_or_method",
                "indexer": "ndarray"
            }
        ],
        [
            {
                "self": "DatetimeIndex",
                "target": "DatetimeIndex",
                "self.is_monotonic_increasing": "bool"
            },
            {
                "left_indexer": "ndarray",
                "right_indexer": "ndarray",
                "left_distances": "TimedeltaIndex",
                "right_distances": "TimedeltaIndex",
                "op": "builtin_function_or_method",
                "indexer": "ndarray"
            }
        ]
    ],
    "3.1.1": [
        "Warning while reindexing tz aware index with method='nearest'\n"
    ],
    "3.1.2": [
        "Reindexing a tz aware dataframe using method='nearest' raise an internal warning.\n\nfrom pandas.util.testing import makeTimeDataFrame\ndf = makeTimeDataFrame(freq='1h')\ndf = df.tz_localize('UTC')\ndf.reindex(df.index[1:4], method='nearest')\nraises a warning:\n\n/lib/python3.7/site-packages/pandas/core/indexes/base.py:2820: FutureWarning: Converting timezone-aware DatetimeArray to timezone-naive ndarray with 'datetime64[ns]' dtype. In the future, this will return an ndarray with 'object' dtype where each element is a 'pandas.Timestamp' with the correct 'tz'.\n        To accept the future behavior, pass 'dtype=object'.\n        To keep the old behavior, pass 'dtype=\"datetime64[ns]\"'.\n  target = np.asarray(target)\nin pandas 0.24.2\n"
    ]
}