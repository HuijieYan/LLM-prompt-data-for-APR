{
    "pandas:61": {
        "/home/ubuntu/Desktop/bgp_envs_local/repos/pandas_61/pandas/core/series.py": {
            "buggy_functions": [
                {
                    "function_name": "_get_with",
                    "function_code": "def _get_with(self, key):\n    # other: fancy integer or otherwise\n    if isinstance(key, slice):\n        return self._slice(key)\n    elif isinstance(key, ABCDataFrame):\n        raise TypeError(\n            \"Indexing a Series with DataFrame is not \"\n            \"supported, use the appropriate DataFrame column\"\n        )\n    elif isinstance(key, tuple):\n        try:\n            return self._get_values_tuple(key)\n        except ValueError:\n            # if we don't have a MultiIndex, we may still be able to handle\n            #  a 1-tuple.  see test_1tuple_without_multiindex\n            if len(key) == 1:\n                key = key[0]\n                if isinstance(key, slice):\n                    return self._get_values(key)\n            raise\n\n    if not isinstance(key, (list, np.ndarray, Series, Index)):\n        key = list(key)\n\n    if isinstance(key, Index):\n        key_type = key.inferred_type\n    else:\n        key_type = lib.infer_dtype(key, skipna=False)\n\n    # Note: The key_type == \"boolean\" case should be caught by the\n    #  com.is_bool_indexer check in __getitem__\n    if key_type == \"integer\":\n        if self.index.is_integer() or self.index.is_floating():\n            return self.loc[key]\n        elif isinstance(self.index, IntervalIndex):\n            indexer = self.index.get_indexer_for(key)\n            return self.iloc[indexer]\n        else:\n            return self._get_values(key)\n\n    if isinstance(key, (list, tuple)):\n        # TODO: de-dup with tuple case handled above?\n        # handle the dup indexing case GH#4246\n        if len(key) == 1 and isinstance(key[0], slice):\n            # [slice(0, 5, None)] will break if you convert to ndarray,\n            # e.g. as requested by np.median\n            # FIXME: hack\n            return self._get_values(key)\n\n        return self.loc[key]\n\n    return self.reindex(key)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 884,
                    "end_line": 935,
                    "variables": {
                        "isinstance": [
                            901,
                            905,
                            908,
                            886,
                            918,
                            888,
                            924,
                            893,
                            927
                        ],
                        "key": [
                            899,
                            900,
                            901,
                            902,
                            905,
                            906,
                            908,
                            909,
                            911,
                            917,
                            919,
                            922,
                            924,
                            927,
                            931,
                            933,
                            935,
                            886,
                            887,
                            888,
                            893,
                            895
                        ],
                        "slice": [
                            901,
                            886,
                            927
                        ],
                        "self._slice": [
                            887
                        ],
                        "self": [
                            931,
                            933,
                            902,
                            935,
                            919,
                            916,
                            917,
                            918,
                            887,
                            920,
                            922,
                            895
                        ],
                        "ABCDataFrame": [
                            888
                        ],
                        "TypeError": [
                            889
                        ],
                        "tuple": [
                            924,
                            893
                        ],
                        "self._get_values_tuple": [
                            895
                        ],
                        "ValueError": [
                            896
                        ],
                        "len": [
                            899,
                            927
                        ],
                        "self._get_values": [
                            922,
                            931,
                            902
                        ],
                        "list": [
                            905,
                            906,
                            924
                        ],
                        "np.ndarray": [
                            905
                        ],
                        "np": [
                            905
                        ],
                        "Series": [
                            905
                        ],
                        "Index": [
                            905,
                            908
                        ],
                        "key_type": [
                            915,
                            909,
                            911
                        ],
                        "key.inferred_type": [
                            909
                        ],
                        "lib.infer_dtype": [
                            911
                        ],
                        "lib": [
                            911
                        ],
                        "self.index.is_integer": [
                            916
                        ],
                        "self.index": [
                            916,
                            918,
                            919
                        ],
                        "self.index.is_floating": [
                            916
                        ],
                        "self.loc": [
                            917,
                            933
                        ],
                        "IntervalIndex": [
                            918
                        ],
                        "indexer": [
                            920,
                            919
                        ],
                        "self.index.get_indexer_for": [
                            919
                        ],
                        "self.iloc": [
                            920
                        ],
                        "self.reindex": [
                            935
                        ]
                    },
                    "filtered_variables": {
                        "key": [
                            899,
                            900,
                            901,
                            902,
                            905,
                            906,
                            908,
                            909,
                            911,
                            917,
                            919,
                            922,
                            924,
                            927,
                            931,
                            933,
                            935,
                            886,
                            887,
                            888,
                            893,
                            895
                        ],
                        "self._slice": [
                            887
                        ],
                        "self": [
                            931,
                            933,
                            902,
                            935,
                            919,
                            916,
                            917,
                            918,
                            887,
                            920,
                            922,
                            895
                        ],
                        "ABCDataFrame": [
                            888
                        ],
                        "self._get_values_tuple": [
                            895
                        ],
                        "self._get_values": [
                            922,
                            931,
                            902
                        ],
                        "np.ndarray": [
                            905
                        ],
                        "np": [
                            905
                        ],
                        "Series": [
                            905
                        ],
                        "Index": [
                            905,
                            908
                        ],
                        "key_type": [
                            915,
                            909,
                            911
                        ],
                        "key.inferred_type": [
                            909
                        ],
                        "lib.infer_dtype": [
                            911
                        ],
                        "lib": [
                            911
                        ],
                        "self.index.is_integer": [
                            916
                        ],
                        "self.index": [
                            916,
                            918,
                            919
                        ],
                        "self.index.is_floating": [
                            916
                        ],
                        "self.loc": [
                            917,
                            933
                        ],
                        "IntervalIndex": [
                            918
                        ],
                        "indexer": [
                            920,
                            919
                        ],
                        "self.index.get_indexer_for": [
                            919
                        ],
                        "self.iloc": [
                            920
                        ],
                        "self.reindex": [
                            935
                        ]
                    },
                    "diff_line_number": 922,
                    "class_data": {
                        "signature": "class Series(base.IndexOpsMixin, generic.NDFrame)",
                        "docstring": "One-dimensional ndarray with axis labels (including time series).\n\nLabels need not be unique but must be a hashable type. The object\nsupports both integer- and label-based indexing and provides a host of\nmethods for performing operations involving the index. Statistical\nmethods from ndarray have been overridden to automatically exclude\nmissing data (currently represented as NaN).\n\nOperations between Series (+, -, /, *, **) align values based on their\nassociated index values-- they need not be the same length. The result\nindex will be the sorted union of the two indexes.\n\nParameters\n----------\ndata : array-like, Iterable, dict, or scalar value\n    Contains data stored in Series.\n\n    .. versionchanged:: 0.23.0\n       If data is a dict, argument order is maintained for Python 3.6\n       and later.\n\nindex : array-like or Index (1d)\n    Values must be hashable and have the same length as `data`.\n    Non-unique index values are allowed. Will default to\n    RangeIndex (0, 1, 2, ..., n) if not provided. If both a dict and index\n    sequence are used, the index will override the keys found in the\n    dict.\ndtype : str, numpy.dtype, or ExtensionDtype, optional\n    Data type for the output Series. If not specified, this will be\n    inferred from `data`.\n    See the :ref:`user guide <basics.dtypes>` for more usages.\nname : str, optional\n    The name to give to the Series.\ncopy : bool, default False\n    Copy input data.",
                        "constructor_docstring": null,
                        "functions": [
                            "def __init__(self, data=None, index=None, dtype=None, name=None, copy=False, fastpath=False):\n    if fastpath:\n        if not isinstance(data, SingleBlockManager):\n            data = SingleBlockManager(data, index, fastpath=True)\n        if copy:\n            data = data.copy()\n        if index is None:\n            index = data.index\n    else:\n        name = ibase.maybe_extract_name(name, data, type(self))\n        if is_empty_data(data) and dtype is None:\n            warnings.warn(\"The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.\", DeprecationWarning, stacklevel=2)\n        if index is not None:\n            index = ensure_index(index)\n        if data is None:\n            data = {}\n        if dtype is not None:\n            dtype = self._validate_dtype(dtype)\n        if isinstance(data, MultiIndex):\n            raise NotImplementedError('initializing a Series from a MultiIndex is not supported')\n        elif isinstance(data, Index):\n            if dtype is not None:\n                data = data.astype(dtype)\n            else:\n                data = data._values.copy()\n                if isinstance(data, ABCDatetimeIndex) and data.tz is not None:\n                    data = data._values.copy(deep=True)\n            copy = False\n        elif isinstance(data, np.ndarray):\n            if len(data.dtype):\n                raise ValueError('Cannot construct a Series from an ndarray with compound dtype.  Use DataFrame instead.')\n            pass\n        elif isinstance(data, ABCSeries):\n            if index is None:\n                index = data.index\n            else:\n                data = data.reindex(index, copy=copy)\n            data = data._data\n        elif is_dict_like(data):\n            (data, index) = self._init_dict(data, index, dtype)\n            dtype = None\n            copy = False\n        elif isinstance(data, SingleBlockManager):\n            if index is None:\n                index = data.index\n            elif not data.index.equals(index) or copy:\n                raise AssertionError('Cannot pass both SingleBlockManager `data` argument and a different `index` argument. `copy` must be False.')\n        elif is_extension_array_dtype(data):\n            pass\n        elif isinstance(data, (set, frozenset)):\n            raise TypeError(f\"'{type(data).__name__}' type is unordered\")\n        elif isinstance(data, ABCSparseArray):\n            data = data.to_dense()\n        else:\n            data = com.maybe_iterable_to_list(data)\n        if index is None:\n            if not is_list_like(data):\n                data = [data]\n            index = ibase.default_index(len(data))\n        elif is_list_like(data):\n            try:\n                if len(index) != len(data):\n                    raise ValueError(f'Length of passed values is {len(data)}, index implies {len(index)}.')\n            except TypeError:\n                pass\n        if isinstance(data, SingleBlockManager):\n            if dtype is not None:\n                data = data.astype(dtype=dtype, errors='ignore', copy=copy)\n            elif copy:\n                data = data.copy()\n        else:\n            data = sanitize_array(data, index, dtype, copy, raise_cast_failure=True)\n            data = SingleBlockManager(data, index, fastpath=True)\n    generic.NDFrame.__init__(self, data, fastpath=True)\n    self.name = name\n    self._set_axis(0, index, fastpath=True)",
                            "def _init_dict(self, data, index=None, dtype=None):\n    \"\"\"\n    Derive the \"_data\" and \"index\" attributes of a new Series from a\n    dictionary input.\n\n    Parameters\n    ----------\n    data : dict or dict-like\n        Data used to populate the new Series.\n    index : Index or index-like, default None\n        Index for the new Series: if None, use dict keys.\n    dtype : dtype, default None\n        The dtype for the new Series: if None, infer from data.\n\n    Returns\n    -------\n    _data : BlockManager for the new Series\n    index : index for the new Series\n    \"\"\"\n    if data:\n        (keys, values) = zip(*data.items())\n        values = list(values)\n    elif index is not None:\n        values = na_value_for_dtype(dtype)\n        keys = index\n    else:\n        (keys, values) = ([], [])\n    s = create_series_with_explicit_dtype(values, index=keys, dtype=dtype, dtype_if_empty=np.float64)\n    if data and index is not None:\n        s = s.reindex(index, copy=False)\n    return (s._data, s.index)",
                            "@property\ndef _constructor(self) -> Type['Series']:\n    return Series",
                            "@property\ndef _constructor_expanddim(self) -> Type['DataFrame']:\n    from pandas.core.frame import DataFrame\n    return DataFrame",
                            "@property\ndef _can_hold_na(self):\n    return self._data._can_hold_na",
                            "def _set_axis(self, axis, labels, fastpath: bool=False) -> None:\n    \"\"\"\n    Override generic, we want to set the _typ here.\n    \"\"\"\n    if not fastpath:\n        labels = ensure_index(labels)\n    is_all_dates = labels.is_all_dates\n    if is_all_dates:\n        if not isinstance(labels, (DatetimeIndex, PeriodIndex, TimedeltaIndex)):\n            try:\n                labels = DatetimeIndex(labels)\n                if fastpath:\n                    self._data.set_axis(axis, labels)\n            except (tslibs.OutOfBoundsDatetime, ValueError):\n                pass\n    object.__setattr__(self, '_index', labels)\n    if not fastpath:\n        self._data.set_axis(axis, labels)",
                            "def _update_inplace(self, result, **kwargs):\n    return generic.NDFrame._update_inplace(self, result, **kwargs)",
                            "@property\ndef dtype(self):\n    \"\"\"\n    Return the dtype object of the underlying data.\n    \"\"\"\n    return self._data.dtype",
                            "@property\ndef dtypes(self):\n    \"\"\"\n    Return the dtype object of the underlying data.\n    \"\"\"\n    return self._data.dtype",
                            "@property\ndef name(self) -> Optional[Hashable]:\n    return self._name",
                            "@name.setter\ndef name(self, value: Optional[Hashable]) -> None:\n    if not is_hashable(value):\n        raise TypeError('Series.name must be a hashable type')\n    object.__setattr__(self, '_name', value)",
                            "@property\ndef values(self):\n    \"\"\"\n    Return Series as ndarray or ndarray-like depending on the dtype.\n\n    .. warning::\n\n       We recommend using :attr:`Series.array` or\n       :meth:`Series.to_numpy`, depending on whether you need\n       a reference to the underlying data or a NumPy array.\n\n    Returns\n    -------\n    numpy.ndarray or ndarray-like\n\n    See Also\n    --------\n    Series.array : Reference to the underlying data.\n    Series.to_numpy : A NumPy array representing the underlying data.\n\n    Examples\n    --------\n    >>> pd.Series([1, 2, 3]).values\n    array([1, 2, 3])\n\n    >>> pd.Series(list('aabc')).values\n    array(['a', 'a', 'b', 'c'], dtype=object)\n\n    >>> pd.Series(list('aabc')).astype('category').values\n    [a, a, b, c]\n    Categories (3, object): [a, b, c]\n\n    Timezone aware datetime data is converted to UTC:\n\n    >>> pd.Series(pd.date_range('20130101', periods=3,\n    ...                         tz='US/Eastern')).values\n    array(['2013-01-01T05:00:00.000000000',\n           '2013-01-02T05:00:00.000000000',\n           '2013-01-03T05:00:00.000000000'], dtype='datetime64[ns]')\n    \"\"\"\n    return self._data.external_values()",
                            "@property\ndef _values(self):\n    \"\"\"\n    Return the internal repr of this data (defined by Block.interval_values).\n    This are the values as stored in the Block (ndarray or ExtensionArray\n    depending on the Block class), with datetime64[ns] and timedelta64[ns]\n    wrapped in ExtensionArrays to match Index._values behavior.\n\n    Differs from the public ``.values`` for certain data types, because of\n    historical backwards compatibility of the public attribute (e.g. period\n    returns object ndarray and datetimetz a datetime64[ns] ndarray for\n    ``.values`` while it returns an ExtensionArray for ``._values`` in those\n    cases).\n\n    Differs from ``.array`` in that this still returns the numpy array if\n    the Block is backed by a numpy array (except for datetime64 and\n    timedelta64 dtypes), while ``.array`` ensures to always return an\n    ExtensionArray.\n\n    Differs from ``._ndarray_values``, as that ensures to always return a\n    numpy array (it will call ``_ndarray_values`` on the ExtensionArray, if\n    the Series was backed by an ExtensionArray).\n\n    Overview:\n\n    dtype       | values        | _values       | array         | _ndarray_values |\n    ----------- | ------------- | ------------- | ------------- | --------------- |\n    Numeric     | ndarray       | ndarray       | PandasArray   | ndarray         |\n    Category    | Categorical   | Categorical   | Categorical   | ndarray[int]    |\n    dt64[ns]    | ndarray[M8ns] | DatetimeArray | DatetimeArray | ndarray[M8ns]   |\n    dt64[ns tz] | ndarray[M8ns] | DatetimeArray | DatetimeArray | ndarray[M8ns]   |\n    td64[ns]    | ndarray[m8ns] | TimedeltaArray| ndarray[m8ns] | ndarray[m8ns]   |\n    Period      | ndarray[obj]  | PeriodArray   | PeriodArray   | ndarray[int]    |\n    Nullable    | EA            | EA            | EA            | ndarray         |\n\n    \"\"\"\n    return self._data.internal_values()",
                            "@Appender(base.IndexOpsMixin.array.__doc__)\n@property\ndef array(self) -> ExtensionArray:\n    return self._data._block.array_values()",
                            "def _internal_get_values(self):\n    \"\"\"\n    Same as values (but handles sparseness conversions); is a view.\n\n    Returns\n    -------\n    numpy.ndarray\n        Data of the Series.\n    \"\"\"\n    return self._data.get_values()",
                            "def ravel(self, order='C'):\n    \"\"\"\n    Return the flattened underlying data as an ndarray.\n\n    Returns\n    -------\n    numpy.ndarray or ndarray-like\n        Flattened data of the Series.\n\n    See Also\n    --------\n    numpy.ndarray.ravel\n    \"\"\"\n    return self._values.ravel(order=order)",
                            "def __len__(self) -> int:\n    \"\"\"\n    Return the length of the Series.\n    \"\"\"\n    return len(self._data)",
                            "def view(self, dtype=None) -> 'Series':\n    \"\"\"\n    Create a new view of the Series.\n\n    This function will return a new Series with a view of the same\n    underlying values in memory, optionally reinterpreted with a new data\n    type. The new data type must preserve the same size in bytes as to not\n    cause index misalignment.\n\n    Parameters\n    ----------\n    dtype : data type\n        Data type object or one of their string representations.\n\n    Returns\n    -------\n    Series\n        A new Series object as a view of the same data in memory.\n\n    See Also\n    --------\n    numpy.ndarray.view : Equivalent numpy function to create a new view of\n        the same data in memory.\n\n    Notes\n    -----\n    Series are instantiated with ``dtype=float64`` by default. While\n    ``numpy.ndarray.view()`` will return a view with the same data type as\n    the original array, ``Series.view()`` (without specified dtype)\n    will try using ``float64`` and may fail if the original data type size\n    in bytes is not the same.\n\n    Examples\n    --------\n    >>> s = pd.Series([-2, -1, 0, 1, 2], dtype='int8')\n    >>> s\n    0   -2\n    1   -1\n    2    0\n    3    1\n    4    2\n    dtype: int8\n\n    The 8 bit signed integer representation of `-1` is `0b11111111`, but\n    the same bytes represent 255 if read as an 8 bit unsigned integer:\n\n    >>> us = s.view('uint8')\n    >>> us\n    0    254\n    1    255\n    2      0\n    3      1\n    4      2\n    dtype: uint8\n\n    The views share the same underlying values:\n\n    >>> us[0] = 128\n    >>> s\n    0   -128\n    1     -1\n    2      0\n    3      1\n    4      2\n    dtype: int8\n    \"\"\"\n    return self._constructor(self._values.view(dtype), index=self.index).__finalize__(self)",
                            "def __array_ufunc__(self, ufunc: Callable, method: str, *inputs: Any, **kwargs: Any):\n    cls = type(self)\n    result = ops.maybe_dispatch_ufunc_to_dunder_op(self, ufunc, method, *inputs, **kwargs)\n    if result is not NotImplemented:\n        return result\n    no_defer = (np.ndarray.__array_ufunc__, cls.__array_ufunc__)\n    for item in inputs:\n        higher_priority = hasattr(item, '__array_priority__') and item.__array_priority__ > self.__array_priority__\n        has_array_ufunc = hasattr(item, '__array_ufunc__') and type(item).__array_ufunc__ not in no_defer and (not isinstance(item, self._HANDLED_TYPES))\n        if higher_priority or has_array_ufunc:\n            return NotImplemented\n    names = [getattr(x, 'name') for x in inputs if hasattr(x, 'name')]\n    types = tuple((type(x) for x in inputs))\n    alignable = [x for (x, t) in zip(inputs, types) if issubclass(t, Series)]\n    if len(alignable) > 1:\n        index = alignable[0].index\n        for s in alignable[1:]:\n            index |= s.index\n        inputs = tuple((x.reindex(index) if issubclass(t, Series) else x for (x, t) in zip(inputs, types)))\n    else:\n        index = self.index\n    inputs = tuple((extract_array(x, extract_numpy=True) for x in inputs))\n    result = getattr(ufunc, method)(*inputs, **kwargs)\n    name: Optional[Hashable]\n    if len(set(names)) == 1:\n        name = names[0]\n    else:\n        name = None\n\n    def construct_return(result):\n        if lib.is_scalar(result):\n            return result\n        elif result.ndim > 1:\n            if method == 'outer':\n                raise NotImplementedError\n            return result\n        return self._constructor(result, index=index, name=name, copy=False)\n    if type(result) is tuple:\n        return tuple((construct_return(x) for x in result))\n    elif method == 'at':\n        return None\n    else:\n        return construct_return(result)",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    \"\"\"\n    Return the values as a NumPy array.\n\n    Users should not call this directly. Rather, it is invoked by\n    :func:`numpy.array` and :func:`numpy.asarray`.\n\n    Parameters\n    ----------\n    dtype : str or numpy.dtype, optional\n        The dtype to use for the resulting NumPy array. By default,\n        the dtype is inferred from the data.\n\n    Returns\n    -------\n    numpy.ndarray\n        The values in the series converted to a :class:`numpy.ndarray`\n        with the specified `dtype`.\n\n    See Also\n    --------\n    array : Create a new array from data.\n    Series.array : Zero-copy view to the array backing the Series.\n    Series.to_numpy : Series method for similar behavior.\n\n    Examples\n    --------\n    >>> ser = pd.Series([1, 2, 3])\n    >>> np.asarray(ser)\n    array([1, 2, 3])\n\n    For timezone-aware data, the timezones may be retained with\n    ``dtype='object'``\n\n    >>> tzser = pd.Series(pd.date_range('2000', periods=2, tz=\"CET\"))\n    >>> np.asarray(tzser, dtype=\"object\")\n    array([Timestamp('2000-01-01 00:00:00+0100', tz='CET', freq='D'),\n           Timestamp('2000-01-02 00:00:00+0100', tz='CET', freq='D')],\n          dtype=object)\n\n    Or the values may be localized to UTC and the tzinfo discarded with\n    ``dtype='datetime64[ns]'``\n\n    >>> np.asarray(tzser, dtype=\"datetime64[ns]\")  # doctest: +ELLIPSIS\n    array(['1999-12-31T23:00:00.000000000', ...],\n          dtype='datetime64[ns]')\n    \"\"\"\n    return np.asarray(self.array, dtype)",
                            "@property\ndef axes(self) -> List[Index]:\n    \"\"\"\n    Return a list of the row axis labels.\n    \"\"\"\n    return [self.index]",
                            "@Appender(generic.NDFrame.take.__doc__)\ndef take(self, indices, axis=0, is_copy=None, **kwargs) -> 'Series':\n    if is_copy is not None:\n        warnings.warn(\"is_copy is deprecated and will be removed in a future version. 'take' always returns a copy, so there is no need to specify this.\", FutureWarning, stacklevel=2)\n    nv.validate_take(tuple(), kwargs)\n    indices = ensure_platform_int(indices)\n    new_index = self.index.take(indices)\n    if is_categorical_dtype(self):\n        indices = maybe_convert_indices(indices, len(self._get_axis(axis)))\n        kwargs = {'allow_fill': False}\n    else:\n        kwargs = {}\n    new_values = self._values.take(indices, **kwargs)\n    return self._constructor(new_values, index=new_index, fastpath=True).__finalize__(self)",
                            "def _take_with_is_copy(self, indices, axis=0, **kwargs):\n    \"\"\"\n    Internal version of the `take` method that sets the `_is_copy`\n    attribute to keep track of the parent dataframe (using in indexing\n    for the SettingWithCopyWarning). For Series this does the same\n    as the public take (it never sets `_is_copy`).\n\n    See the docstring of `take` for full explanation of the parameters.\n    \"\"\"\n    return self.take(indices=indices, axis=axis, **kwargs)",
                            "def _ixs(self, i: int, axis: int=0):\n    \"\"\"\n    Return the i-th value or values in the Series by location.\n\n    Parameters\n    ----------\n    i : int\n\n    Returns\n    -------\n    scalar (int) or Series (slice, sequence)\n    \"\"\"\n    return self._values[i]",
                            "def _slice(self, slobj: slice, axis: int=0, kind: str='getitem') -> 'Series':\n    assert kind in ['getitem', 'iloc']\n    slobj = self.index._convert_slice_indexer(slobj, kind=kind)\n    return self._get_values(slobj)",
                            "def __getitem__(self, key):\n    key = com.apply_if_callable(key, self)\n    if key is Ellipsis:\n        return self\n    key_is_scalar = is_scalar(key)\n    if key_is_scalar:\n        key = self.index._convert_scalar_indexer(key, kind='getitem')\n    if key_is_scalar or isinstance(self.index, MultiIndex):\n        try:\n            result = self.index.get_value(self, key)\n            return result\n        except InvalidIndexError:\n            pass\n        except (KeyError, ValueError):\n            if isinstance(key, tuple) and isinstance(self.index, MultiIndex):\n                pass\n            else:\n                raise\n    if not key_is_scalar:\n        if is_iterator(key):\n            key = list(key)\n        if com.is_bool_indexer(key):\n            key = check_bool_indexer(self.index, key)\n            return self._get_values(key)\n    return self._get_with(key)",
                            "def _get_with(self, key):\n    if isinstance(key, slice):\n        return self._slice(key)\n    elif isinstance(key, ABCDataFrame):\n        raise TypeError('Indexing a Series with DataFrame is not supported, use the appropriate DataFrame column')\n    elif isinstance(key, tuple):\n        try:\n            return self._get_values_tuple(key)\n        except ValueError:\n            if len(key) == 1:\n                key = key[0]\n                if isinstance(key, slice):\n                    return self._get_values(key)\n            raise\n    if not isinstance(key, (list, np.ndarray, Series, Index)):\n        key = list(key)\n    if isinstance(key, Index):\n        key_type = key.inferred_type\n    else:\n        key_type = lib.infer_dtype(key, skipna=False)\n    if key_type == 'integer':\n        if self.index.is_integer() or self.index.is_floating():\n            return self.loc[key]\n        elif isinstance(self.index, IntervalIndex):\n            indexer = self.index.get_indexer_for(key)\n            return self.iloc[indexer]\n        else:\n            return self._get_values(key)\n    if isinstance(key, (list, tuple)):\n        if len(key) == 1 and isinstance(key[0], slice):\n            return self._get_values(key)\n        return self.loc[key]\n    return self.reindex(key)",
                            "def _get_values_tuple(self, key):\n    if com.any_none(*key):\n        with warnings.catch_warnings():\n            warnings.filterwarnings('ignore', 'Support for multi-dim', DeprecationWarning)\n            return self._get_values(key)\n    if not isinstance(self.index, MultiIndex):\n        raise ValueError('Can only tuple-index with a MultiIndex')\n    (indexer, new_index) = self.index.get_loc_level(key)\n    return self._constructor(self._values[indexer], index=new_index).__finalize__(self)",
                            "def _get_values(self, indexer):\n    try:\n        return self._constructor(self._data.get_slice(indexer), fastpath=True).__finalize__(self)\n    except ValueError:\n        return self._values[indexer]",
                            "def _get_value(self, label, takeable: bool=False):\n    \"\"\"\n    Quickly retrieve single value at passed index label.\n\n    Parameters\n    ----------\n    label : object\n    takeable : interpret the index as indexers, default False\n\n    Returns\n    -------\n    scalar value\n    \"\"\"\n    if takeable:\n        return self._values[label]\n    return self.index.get_value(self, label)",
                            "def __setitem__(self, key, value):\n    key = com.apply_if_callable(key, self)\n    cacher_needs_updating = self._check_is_chained_assignment_possible()\n    try:\n        self._set_with_engine(key, value)\n    except com.SettingWithCopyError:\n        raise\n    except (KeyError, ValueError):\n        values = self._values\n        if is_integer(key) and (not self.index.inferred_type == 'integer'):\n            values[key] = value\n        elif key is Ellipsis:\n            self[:] = value\n        else:\n            self.loc[key] = value\n    except InvalidIndexError:\n        self._set_with(key, value)\n    except TypeError as e:\n        if isinstance(key, tuple) and (not isinstance(self.index, MultiIndex)):\n            raise ValueError('Can only tuple-index with a MultiIndex')\n        if _is_unorderable_exception(e):\n            raise IndexError(key)\n        if com.is_bool_indexer(key):\n            key = check_bool_indexer(self.index, key)\n            try:\n                self._where(~key, value, inplace=True)\n                return\n            except InvalidIndexError:\n                pass\n        self._set_with(key, value)\n    if cacher_needs_updating:\n        self._maybe_update_cacher()",
                            "def _set_with_engine(self, key, value):\n    loc = self.index._engine.get_loc(key)\n    validate_numeric_casting(self.dtype, value)\n    self._values[loc] = value",
                            "def _set_with(self, key, value):\n    if isinstance(key, slice):\n        indexer = self.index._convert_slice_indexer(key, kind='getitem')\n        return self._set_values(indexer, value)\n    elif is_scalar(key) and (not is_integer(key)) and (key not in self.index):\n        self.loc[key] = value\n        return\n    else:\n        if isinstance(key, tuple):\n            try:\n                self._set_values(key, value)\n            except Exception:\n                pass\n        if is_scalar(key):\n            key = [key]\n        if isinstance(key, Index):\n            key_type = key.inferred_type\n            key = key._values\n        else:\n            key_type = lib.infer_dtype(key, skipna=False)\n        if key_type == 'integer':\n            if self.index.inferred_type == 'integer':\n                self._set_labels(key, value)\n            else:\n                return self._set_values(key, value)\n        elif key_type == 'boolean':\n            self._set_values(key.astype(np.bool_), value)\n        else:\n            self._set_labels(key, value)",
                            "def _set_labels(self, key, value):\n    key = com.asarray_tuplesafe(key)\n    indexer = self.index.get_indexer(key)\n    mask = indexer == -1\n    if mask.any():\n        raise ValueError(f'{key[mask]} not contained in the index')\n    self._set_values(indexer, value)",
                            "def _set_values(self, key, value):\n    if isinstance(key, Series):\n        key = key._values\n    self._data = self._data.setitem(indexer=key, value=value)\n    self._maybe_update_cacher()",
                            "def _set_value(self, label, value, takeable: bool=False):\n    \"\"\"\n    Quickly set single value at passed label.\n\n    If label is not contained, a new object is created with the label\n    placed at the end of the result index.\n\n    Parameters\n    ----------\n    label : object\n        Partial indexing with MultiIndex not allowed.\n    value : object\n        Scalar value.\n    takeable : interpret the index as indexers, default False\n\n    Returns\n    -------\n    Series\n        If label is contained, will be reference to calling Series,\n        otherwise a new object.\n    \"\"\"\n    try:\n        if takeable:\n            self._values[label] = value\n        else:\n            loc = self.index.get_loc(label)\n            validate_numeric_casting(self.dtype, value)\n            self._values[loc] = value\n    except KeyError:\n        self.loc[label] = value\n    return self",
                            "@property\ndef _is_mixed_type(self):\n    return False",
                            "def repeat(self, repeats, axis=None) -> 'Series':\n    \"\"\"\n    Repeat elements of a Series.\n\n    Returns a new Series where each element of the current Series\n    is repeated consecutively a given number of times.\n\n    Parameters\n    ----------\n    repeats : int or array of ints\n        The number of repetitions for each element. This should be a\n        non-negative integer. Repeating 0 times will return an empty\n        Series.\n    axis : None\n        Must be ``None``. Has no effect but is accepted for compatibility\n        with numpy.\n\n    Returns\n    -------\n    Series\n        Newly created Series with repeated elements.\n\n    See Also\n    --------\n    Index.repeat : Equivalent function for Index.\n    numpy.repeat : Similar method for :class:`numpy.ndarray`.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s\n    0    a\n    1    b\n    2    c\n    dtype: object\n    >>> s.repeat(2)\n    0    a\n    0    a\n    1    b\n    1    b\n    2    c\n    2    c\n    dtype: object\n    >>> s.repeat([1, 2, 3])\n    0    a\n    1    b\n    1    b\n    2    c\n    2    c\n    2    c\n    dtype: object\n    \"\"\"\n    nv.validate_repeat(tuple(), dict(axis=axis))\n    new_index = self.index.repeat(repeats)\n    new_values = self._values.repeat(repeats)\n    return self._constructor(new_values, index=new_index).__finalize__(self)",
                            "def reset_index(self, level=None, drop=False, name=None, inplace=False):\n    \"\"\"\n    Generate a new DataFrame or Series with the index reset.\n\n    This is useful when the index needs to be treated as a column, or\n    when the index is meaningless and needs to be reset to the default\n    before another operation.\n\n    Parameters\n    ----------\n    level : int, str, tuple, or list, default optional\n        For a Series with a MultiIndex, only remove the specified levels\n        from the index. Removes all levels by default.\n    drop : bool, default False\n        Just reset the index, without inserting it as a column in\n        the new DataFrame.\n    name : object, optional\n        The name to use for the column containing the original Series\n        values. Uses ``self.name`` by default. This argument is ignored\n        when `drop` is True.\n    inplace : bool, default False\n        Modify the Series in place (do not create a new object).\n\n    Returns\n    -------\n    Series or DataFrame\n        When `drop` is False (the default), a DataFrame is returned.\n        The newly created columns will come first in the DataFrame,\n        followed by the original Series values.\n        When `drop` is True, a `Series` is returned.\n        In either case, if ``inplace=True``, no value is returned.\n\n    See Also\n    --------\n    DataFrame.reset_index: Analogous function for DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4], name='foo',\n    ...               index=pd.Index(['a', 'b', 'c', 'd'], name='idx'))\n\n    Generate a DataFrame with default index.\n\n    >>> s.reset_index()\n      idx  foo\n    0   a    1\n    1   b    2\n    2   c    3\n    3   d    4\n\n    To specify the name of the new column use `name`.\n\n    >>> s.reset_index(name='values')\n      idx  values\n    0   a       1\n    1   b       2\n    2   c       3\n    3   d       4\n\n    To generate a new Series with the default set `drop` to True.\n\n    >>> s.reset_index(drop=True)\n    0    1\n    1    2\n    2    3\n    3    4\n    Name: foo, dtype: int64\n\n    To update the Series in place, without generating a new one\n    set `inplace` to True. Note that it also requires ``drop=True``.\n\n    >>> s.reset_index(inplace=True, drop=True)\n    >>> s\n    0    1\n    1    2\n    2    3\n    3    4\n    Name: foo, dtype: int64\n\n    The `level` parameter is interesting for Series with a multi-level\n    index.\n\n    >>> arrays = [np.array(['bar', 'bar', 'baz', 'baz']),\n    ...           np.array(['one', 'two', 'one', 'two'])]\n    >>> s2 = pd.Series(\n    ...     range(4), name='foo',\n    ...     index=pd.MultiIndex.from_arrays(arrays,\n    ...                                     names=['a', 'b']))\n\n    To remove a specific level from the Index, use `level`.\n\n    >>> s2.reset_index(level='a')\n           a  foo\n    b\n    one  bar    0\n    two  bar    1\n    one  baz    2\n    two  baz    3\n\n    If `level` is not set, all levels are removed from the Index.\n\n    >>> s2.reset_index()\n         a    b  foo\n    0  bar  one    0\n    1  bar  two    1\n    2  baz  one    2\n    3  baz  two    3\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    if drop:\n        new_index = ibase.default_index(len(self))\n        if level is not None:\n            if not isinstance(level, (tuple, list)):\n                level = [level]\n            level = [self.index._get_level_number(lev) for lev in level]\n            if len(level) < self.index.nlevels:\n                new_index = self.index.droplevel(level)\n        if inplace:\n            self.index = new_index\n            self.name = name or self.name\n        else:\n            return self._constructor(self._values.copy(), index=new_index).__finalize__(self)\n    elif inplace:\n        raise TypeError('Cannot reset_index inplace on a Series to create a DataFrame')\n    else:\n        df = self.to_frame(name)\n        return df.reset_index(level=level, drop=drop)",
                            "def __repr__(self) -> str:\n    \"\"\"\n    Return a string representation for a particular Series.\n    \"\"\"\n    buf = StringIO('')\n    (width, height) = get_terminal_size()\n    max_rows = height if get_option('display.max_rows') == 0 else get_option('display.max_rows')\n    min_rows = height if get_option('display.max_rows') == 0 else get_option('display.min_rows')\n    show_dimensions = get_option('display.show_dimensions')\n    self.to_string(buf=buf, name=self.name, dtype=self.dtype, min_rows=min_rows, max_rows=max_rows, length=show_dimensions)\n    result = buf.getvalue()\n    return result",
                            "def to_string(self, buf=None, na_rep='NaN', float_format=None, header=True, index=True, length=False, dtype=False, name=False, max_rows=None, min_rows=None):\n    \"\"\"\n    Render a string representation of the Series.\n\n    Parameters\n    ----------\n    buf : StringIO-like, optional\n        Buffer to write to.\n    na_rep : str, optional\n        String representation of NaN to use, default 'NaN'.\n    float_format : one-parameter function, optional\n        Formatter function to apply to columns' elements if they are\n        floats, default None.\n    header : bool, default True\n        Add the Series header (index name).\n    index : bool, optional\n        Add index (row) labels, default True.\n    length : bool, default False\n        Add the Series length.\n    dtype : bool, default False\n        Add the Series dtype.\n    name : bool, default False\n        Add the Series name if not None.\n    max_rows : int, optional\n        Maximum number of rows to show before truncating. If None, show\n        all.\n    min_rows : int, optional\n        The number of rows to display in a truncated repr (when number\n        of rows is above `max_rows`).\n\n    Returns\n    -------\n    str or None\n        String representation of Series if ``buf=None``, otherwise None.\n    \"\"\"\n    formatter = fmt.SeriesFormatter(self, name=name, length=length, header=header, index=index, dtype=dtype, na_rep=na_rep, float_format=float_format, min_rows=min_rows, max_rows=max_rows)\n    result = formatter.to_string()\n    if not isinstance(result, str):\n        raise AssertionError(f'result must be of type str, type of result is {repr(type(result).__name__)}')\n    if buf is None:\n        return result\n    else:\n        try:\n            buf.write(result)\n        except AttributeError:\n            with open(buf, 'w') as f:\n                f.write(result)",
                            "@Appender('\\n        Examples\\n        --------\\n        >>> s = pd.Series([\"elk\", \"pig\", \"dog\", \"quetzal\"], name=\"animal\")\\n        >>> print(s.to_markdown())\\n        |    | animal   |\\n        |---:|:---------|\\n        |  0 | elk      |\\n        |  1 | pig      |\\n        |  2 | dog      |\\n        |  3 | quetzal  |\\n        ')\n@Substitution(klass='Series')\n@Appender(generic._shared_docs['to_markdown'])\ndef to_markdown(self, buf: Optional[IO[str]]=None, mode: Optional[str]=None, **kwargs) -> Optional[str]:\n    return self.to_frame().to_markdown(buf, mode, **kwargs)",
                            "def items(self) -> Iterable[Tuple[Label, Any]]:\n    \"\"\"\n    Lazily iterate over (index, value) tuples.\n\n    This method returns an iterable tuple (index, value). This is\n    convenient if you want to create a lazy iterator.\n\n    Returns\n    -------\n    iterable\n        Iterable of tuples containing the (index, value) pairs from a\n        Series.\n\n    See Also\n    --------\n    DataFrame.items : Iterate over (column name, Series) pairs.\n    DataFrame.iterrows : Iterate over DataFrame rows as (index, Series) pairs.\n\n    Examples\n    --------\n    >>> s = pd.Series(['A', 'B', 'C'])\n    >>> for index, value in s.items():\n    ...     print(f\"Index : {index}, Value : {value}\")\n    Index : 0, Value : A\n    Index : 1, Value : B\n    Index : 2, Value : C\n    \"\"\"\n    return zip(iter(self.index), iter(self))",
                            "@Appender(items.__doc__)\ndef iteritems(self) -> Iterable[Tuple[Label, Any]]:\n    return self.items()",
                            "def keys(self) -> Index:\n    \"\"\"\n    Return alias for index.\n\n    Returns\n    -------\n    Index\n        Index of the Series.\n    \"\"\"\n    return self.index",
                            "def to_dict(self, into=dict):\n    \"\"\"\n    Convert Series to {label -> value} dict or dict-like object.\n\n    Parameters\n    ----------\n    into : class, default dict\n        The collections.abc.Mapping subclass to use as the return\n        object. Can be the actual class or an empty\n        instance of the mapping type you want.  If you want a\n        collections.defaultdict, you must pass it initialized.\n\n        .. versionadded:: 0.21.0\n\n    Returns\n    -------\n    collections.abc.Mapping\n        Key-value representation of Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4])\n    >>> s.to_dict()\n    {0: 1, 1: 2, 2: 3, 3: 4}\n    >>> from collections import OrderedDict, defaultdict\n    >>> s.to_dict(OrderedDict)\n    OrderedDict([(0, 1), (1, 2), (2, 3), (3, 4)])\n    >>> dd = defaultdict(list)\n    >>> s.to_dict(dd)\n    defaultdict(<class 'list'>, {0: 1, 1: 2, 2: 3, 3: 4})\n    \"\"\"\n    into_c = com.standardize_mapping(into)\n    return into_c(self.items())",
                            "def to_frame(self, name=None) -> 'DataFrame':\n    \"\"\"\n    Convert Series to DataFrame.\n\n    Parameters\n    ----------\n    name : object, default None\n        The passed name should substitute for the series name (if it has\n        one).\n\n    Returns\n    -------\n    DataFrame\n        DataFrame representation of Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"a\", \"b\", \"c\"],\n    ...               name=\"vals\")\n    >>> s.to_frame()\n      vals\n    0    a\n    1    b\n    2    c\n    \"\"\"\n    if name is None:\n        df = self._constructor_expanddim(self)\n    else:\n        df = self._constructor_expanddim({name: self})\n    return df",
                            "def _set_name(self, name, inplace=False) -> 'Series':\n    \"\"\"\n    Set the Series name.\n\n    Parameters\n    ----------\n    name : str\n    inplace : bool\n        Whether to modify `self` directly or return a copy.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    ser = self if inplace else self.copy()\n    ser.name = name\n    return ser",
                            "@Appender('\\nExamples\\n--------\\n>>> ser = pd.Series([390., 350., 30., 20.],\\n...                 index=[\\'Falcon\\', \\'Falcon\\', \\'Parrot\\', \\'Parrot\\'], name=\"Max Speed\")\\n>>> ser\\nFalcon    390.0\\nFalcon    350.0\\nParrot     30.0\\nParrot     20.0\\nName: Max Speed, dtype: float64\\n>>> ser.groupby([\"a\", \"b\", \"a\", \"b\"]).mean()\\na    210.0\\nb    185.0\\nName: Max Speed, dtype: float64\\n>>> ser.groupby(level=0).mean()\\nFalcon    370.0\\nParrot     25.0\\nName: Max Speed, dtype: float64\\n>>> ser.groupby(ser > 100).mean()\\nMax Speed\\nFalse     25.0\\nTrue     370.0\\nName: Max Speed, dtype: float64\\n\\n**Grouping by Indexes**\\n\\nWe can groupby different levels of a hierarchical index\\nusing the `level` parameter:\\n\\n>>> arrays = [[\\'Falcon\\', \\'Falcon\\', \\'Parrot\\', \\'Parrot\\'],\\n...           [\\'Captive\\', \\'Wild\\', \\'Captive\\', \\'Wild\\']]\\n>>> index = pd.MultiIndex.from_arrays(arrays, names=(\\'Animal\\', \\'Type\\'))\\n>>> ser = pd.Series([390., 350., 30., 20.], index=index, name=\"Max Speed\")\\n>>> ser\\nAnimal  Type\\nFalcon  Captive    390.0\\n        Wild       350.0\\nParrot  Captive     30.0\\n        Wild        20.0\\nName: Max Speed, dtype: float64\\n>>> ser.groupby(level=0).mean()\\nAnimal\\nFalcon    370.0\\nParrot     25.0\\nName: Max Speed, dtype: float64\\n>>> ser.groupby(level=\"Type\").mean()\\nType\\nCaptive    210.0\\nWild       185.0\\nName: Max Speed, dtype: float64\\n')\n@Appender(generic._shared_docs['groupby'] % _shared_doc_kwargs)\ndef groupby(self, by=None, axis=0, level=None, as_index: bool=True, sort: bool=True, group_keys: bool=True, squeeze: bool=False, observed: bool=False) -> 'SeriesGroupBy':\n    from pandas.core.groupby.generic import SeriesGroupBy\n    if level is None and by is None:\n        raise TypeError(\"You have to supply one of 'by' and 'level'\")\n    axis = self._get_axis_number(axis)\n    return SeriesGroupBy(obj=self, keys=by, axis=axis, level=level, as_index=as_index, sort=sort, group_keys=group_keys, squeeze=squeeze, observed=observed)",
                            "def count(self, level=None):\n    \"\"\"\n    Return number of non-NA/null observations in the Series.\n\n    Parameters\n    ----------\n    level : int or level name, default None\n        If the axis is a MultiIndex (hierarchical), count along a\n        particular level, collapsing into a smaller Series.\n\n    Returns\n    -------\n    int or Series (if level specified)\n        Number of non-null values in the Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([0.0, 1.0, np.nan])\n    >>> s.count()\n    2\n    \"\"\"\n    if level is None:\n        return notna(self.array).sum()\n    if isinstance(level, str):\n        level = self.index._get_level_number(level)\n    lev = self.index.levels[level]\n    level_codes = np.array(self.index.codes[level], subok=False, copy=True)\n    mask = level_codes == -1\n    if mask.any():\n        level_codes[mask] = cnt = len(lev)\n        lev = lev.insert(cnt, lev._na_value)\n    obs = level_codes[notna(self.values)]\n    out = np.bincount(obs, minlength=len(lev) or None)\n    return self._constructor(out, index=lev, dtype='int64').__finalize__(self)",
                            "def mode(self, dropna=True) -> 'Series':\n    \"\"\"\n    Return the mode(s) of the dataset.\n\n    Always returns Series even if only one value is returned.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't consider counts of NaN/NaT.\n\n        .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    Series\n        Modes of the Series in sorted order.\n    \"\"\"\n    return algorithms.mode(self, dropna=dropna)",
                            "def unique(self):\n    \"\"\"\n    Return unique values of Series object.\n\n    Uniques are returned in order of appearance. Hash table-based unique,\n    therefore does NOT sort.\n\n    Returns\n    -------\n    ndarray or ExtensionArray\n        The unique values returned as a NumPy array. See Notes.\n\n    See Also\n    --------\n    unique : Top-level unique method for any 1-d array-like object.\n    Index.unique : Return Index with unique values from an Index object.\n\n    Notes\n    -----\n    Returns the unique values as a NumPy array. In case of an\n    extension-array backed Series, a new\n    :class:`~api.extensions.ExtensionArray` of that type with just\n    the unique values is returned. This includes\n\n        * Categorical\n        * Period\n        * Datetime with Timezone\n        * Interval\n        * Sparse\n        * IntegerNA\n\n    See Examples section.\n\n    Examples\n    --------\n    >>> pd.Series([2, 1, 3, 3], name='A').unique()\n    array([2, 1, 3])\n\n    >>> pd.Series([pd.Timestamp('2016-01-01') for _ in range(3)]).unique()\n    array(['2016-01-01T00:00:00.000000000'], dtype='datetime64[ns]')\n\n    >>> pd.Series([pd.Timestamp('2016-01-01', tz='US/Eastern')\n    ...            for _ in range(3)]).unique()\n    <DatetimeArray>\n    ['2016-01-01 00:00:00-05:00']\n    Length: 1, dtype: datetime64[ns, US/Eastern]\n\n    An unordered Categorical will return categories in the order of\n    appearance.\n\n    >>> pd.Series(pd.Categorical(list('baabc'))).unique()\n    [b, a, c]\n    Categories (3, object): [b, a, c]\n\n    An ordered Categorical preserves the category ordering.\n\n    >>> pd.Series(pd.Categorical(list('baabc'), categories=list('abc'),\n    ...                          ordered=True)).unique()\n    [b, a, c]\n    Categories (3, object): [a < b < c]\n    \"\"\"\n    result = super().unique()\n    return result",
                            "def drop_duplicates(self, keep='first', inplace=False) -> 'Series':\n    \"\"\"\n    Return Series with duplicate values removed.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', ``False``}, default 'first'\n        Method to handle dropping duplicates:\n\n        - 'first' : Drop duplicates except for the first occurrence.\n        - 'last' : Drop duplicates except for the last occurrence.\n        - ``False`` : Drop all duplicates.\n\n    inplace : bool, default ``False``\n        If ``True``, performs operation inplace and returns None.\n\n    Returns\n    -------\n    Series\n        Series with duplicates dropped.\n\n    See Also\n    --------\n    Index.drop_duplicates : Equivalent method on Index.\n    DataFrame.drop_duplicates : Equivalent method on DataFrame.\n    Series.duplicated : Related method on Series, indicating duplicate\n        Series values.\n\n    Examples\n    --------\n    Generate a Series with duplicated entries.\n\n    >>> s = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama', 'hippo'],\n    ...               name='animal')\n    >>> s\n    0      lama\n    1       cow\n    2      lama\n    3    beetle\n    4      lama\n    5     hippo\n    Name: animal, dtype: object\n\n    With the 'keep' parameter, the selection behaviour of duplicated values\n    can be changed. The value 'first' keeps the first occurrence for each\n    set of duplicated entries. The default value of keep is 'first'.\n\n    >>> s.drop_duplicates()\n    0      lama\n    1       cow\n    3    beetle\n    5     hippo\n    Name: animal, dtype: object\n\n    The value 'last' for parameter 'keep' keeps the last occurrence for\n    each set of duplicated entries.\n\n    >>> s.drop_duplicates(keep='last')\n    1       cow\n    3    beetle\n    4      lama\n    5     hippo\n    Name: animal, dtype: object\n\n    The value ``False`` for parameter 'keep' discards all sets of\n    duplicated entries. Setting the value of 'inplace' to ``True`` performs\n    the operation inplace and returns ``None``.\n\n    >>> s.drop_duplicates(keep=False, inplace=True)\n    >>> s\n    1       cow\n    3    beetle\n    5     hippo\n    Name: animal, dtype: object\n    \"\"\"\n    return super().drop_duplicates(keep=keep, inplace=inplace)",
                            "def duplicated(self, keep='first') -> 'Series':\n    \"\"\"\n    Indicate duplicate Series values.\n\n    Duplicated values are indicated as ``True`` values in the resulting\n    Series. Either all duplicates, all except the first or all except the\n    last occurrence of duplicates can be indicated.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', False}, default 'first'\n        Method to handle dropping duplicates:\n\n        - 'first' : Mark duplicates as ``True`` except for the first\n          occurrence.\n        - 'last' : Mark duplicates as ``True`` except for the last\n          occurrence.\n        - ``False`` : Mark all duplicates as ``True``.\n\n    Returns\n    -------\n    Series\n        Series indicating whether each value has occurred in the\n        preceding values.\n\n    See Also\n    --------\n    Index.duplicated : Equivalent method on pandas.Index.\n    DataFrame.duplicated : Equivalent method on pandas.DataFrame.\n    Series.drop_duplicates : Remove duplicate values from Series.\n\n    Examples\n    --------\n    By default, for each set of duplicated values, the first occurrence is\n    set on False and all others on True:\n\n    >>> animals = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama'])\n    >>> animals.duplicated()\n    0    False\n    1    False\n    2     True\n    3    False\n    4     True\n    dtype: bool\n\n    which is equivalent to\n\n    >>> animals.duplicated(keep='first')\n    0    False\n    1    False\n    2     True\n    3    False\n    4     True\n    dtype: bool\n\n    By using 'last', the last occurrence of each set of duplicated values\n    is set on False and all others on True:\n\n    >>> animals.duplicated(keep='last')\n    0     True\n    1    False\n    2     True\n    3    False\n    4    False\n    dtype: bool\n\n    By setting keep on ``False``, all duplicates are True:\n\n    >>> animals.duplicated(keep=False)\n    0     True\n    1    False\n    2     True\n    3    False\n    4     True\n    dtype: bool\n    \"\"\"\n    return super().duplicated(keep=keep)",
                            "def idxmin(self, axis=0, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the row label of the minimum value.\n\n    If multiple values equal the minimum, the first row label with that\n    value is returned.\n\n    Parameters\n    ----------\n    axis : int, default 0\n        For compatibility with DataFrame.idxmin. Redundant for application\n        on Series.\n    skipna : bool, default True\n        Exclude NA/null values. If the entire Series is NA, the result\n        will be NA.\n    *args, **kwargs\n        Additional arguments and keywords have no effect but might be\n        accepted for compatibility with NumPy.\n\n    Returns\n    -------\n    Index\n        Label of the minimum value.\n\n    Raises\n    ------\n    ValueError\n        If the Series is empty.\n\n    See Also\n    --------\n    numpy.argmin : Return indices of the minimum values\n        along the given axis.\n    DataFrame.idxmin : Return index of first occurrence of minimum\n        over requested axis.\n    Series.idxmax : Return index *label* of the first occurrence\n        of maximum of values.\n\n    Notes\n    -----\n    This method is the Series version of ``ndarray.argmin``. This method\n    returns the label of the minimum, while ``ndarray.argmin`` returns\n    the position. To get the position, use ``series.values.argmin()``.\n\n    Examples\n    --------\n    >>> s = pd.Series(data=[1, None, 4, 1],\n    ...               index=['A', 'B', 'C', 'D'])\n    >>> s\n    A    1.0\n    B    NaN\n    C    4.0\n    D    1.0\n    dtype: float64\n\n    >>> s.idxmin()\n    'A'\n\n    If `skipna` is False and there is an NA value in the data,\n    the function returns ``nan``.\n\n    >>> s.idxmin(skipna=False)\n    nan\n    \"\"\"\n    skipna = nv.validate_argmin_with_skipna(skipna, args, kwargs)\n    i = nanops.nanargmin(com.values_from_object(self), skipna=skipna)\n    if i == -1:\n        return np.nan\n    return self.index[i]",
                            "def idxmax(self, axis=0, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the row label of the maximum value.\n\n    If multiple values equal the maximum, the first row label with that\n    value is returned.\n\n    Parameters\n    ----------\n    axis : int, default 0\n        For compatibility with DataFrame.idxmax. Redundant for application\n        on Series.\n    skipna : bool, default True\n        Exclude NA/null values. If the entire Series is NA, the result\n        will be NA.\n    *args, **kwargs\n        Additional arguments and keywords have no effect but might be\n        accepted for compatibility with NumPy.\n\n    Returns\n    -------\n    Index\n        Label of the maximum value.\n\n    Raises\n    ------\n    ValueError\n        If the Series is empty.\n\n    See Also\n    --------\n    numpy.argmax : Return indices of the maximum values\n        along the given axis.\n    DataFrame.idxmax : Return index of first occurrence of maximum\n        over requested axis.\n    Series.idxmin : Return index *label* of the first occurrence\n        of minimum of values.\n\n    Notes\n    -----\n    This method is the Series version of ``ndarray.argmax``. This method\n    returns the label of the maximum, while ``ndarray.argmax`` returns\n    the position. To get the position, use ``series.values.argmax()``.\n\n    Examples\n    --------\n    >>> s = pd.Series(data=[1, None, 4, 3, 4],\n    ...               index=['A', 'B', 'C', 'D', 'E'])\n    >>> s\n    A    1.0\n    B    NaN\n    C    4.0\n    D    3.0\n    E    4.0\n    dtype: float64\n\n    >>> s.idxmax()\n    'C'\n\n    If `skipna` is False and there is an NA value in the data,\n    the function returns ``nan``.\n\n    >>> s.idxmax(skipna=False)\n    nan\n    \"\"\"\n    skipna = nv.validate_argmax_with_skipna(skipna, args, kwargs)\n    i = nanops.nanargmax(com.values_from_object(self), skipna=skipna)\n    if i == -1:\n        return np.nan\n    return self.index[i]",
                            "def round(self, decimals=0, *args, **kwargs) -> 'Series':\n    \"\"\"\n    Round each value in a Series to the given number of decimals.\n\n    Parameters\n    ----------\n    decimals : int, default 0\n        Number of decimal places to round to. If decimals is negative,\n        it specifies the number of positions to the left of the decimal point.\n\n    Returns\n    -------\n    Series\n        Rounded values of the Series.\n\n    See Also\n    --------\n    numpy.around : Round values of an np.array.\n    DataFrame.round : Round values of a DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series([0.1, 1.3, 2.7])\n    >>> s.round()\n    0    0.0\n    1    1.0\n    2    3.0\n    dtype: float64\n    \"\"\"\n    nv.validate_round(args, kwargs)\n    result = com.values_from_object(self).round(decimals)\n    result = self._constructor(result, index=self.index).__finalize__(self)\n    return result",
                            "def quantile(self, q=0.5, interpolation='linear'):\n    \"\"\"\n    Return value at the given quantile.\n\n    Parameters\n    ----------\n    q : float or array-like, default 0.5 (50% quantile)\n        The quantile(s) to compute, which can lie in range: 0 <= q <= 1.\n    interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}\n        This optional parameter specifies the interpolation method to use,\n        when the desired quantile lies between two data points `i` and `j`:\n\n            * linear: `i + (j - i) * fraction`, where `fraction` is the\n              fractional part of the index surrounded by `i` and `j`.\n            * lower: `i`.\n            * higher: `j`.\n            * nearest: `i` or `j` whichever is nearest.\n            * midpoint: (`i` + `j`) / 2.\n\n    Returns\n    -------\n    float or Series\n        If ``q`` is an array, a Series will be returned where the\n        index is ``q`` and the values are the quantiles, otherwise\n        a float will be returned.\n\n    See Also\n    --------\n    core.window.Rolling.quantile\n    numpy.percentile\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4])\n    >>> s.quantile(.5)\n    2.5\n    >>> s.quantile([.25, .5, .75])\n    0.25    1.75\n    0.50    2.50\n    0.75    3.25\n    dtype: float64\n    \"\"\"\n    validate_percentile(q)\n    df = self.to_frame()\n    result = df.quantile(q=q, interpolation=interpolation, numeric_only=False)\n    if result.ndim == 2:\n        result = result.iloc[:, 0]\n    if is_list_like(q):\n        result.name = self.name\n        return self._constructor(result, index=Float64Index(q), name=self.name)\n    else:\n        return result.iloc[0]",
                            "def corr(self, other, method='pearson', min_periods=None) -> float:\n    \"\"\"\n    Compute correlation with `other` Series, excluding missing values.\n\n    Parameters\n    ----------\n    other : Series\n        Series with which to compute the correlation.\n    method : {'pearson', 'kendall', 'spearman'} or callable\n        Method used to compute correlation:\n\n        - pearson : Standard correlation coefficient\n        - kendall : Kendall Tau correlation coefficient\n        - spearman : Spearman rank correlation\n        - callable: Callable with input two 1d ndarrays and returning a float.\n\n        .. versionadded:: 0.24.0\n            Note that the returned matrix from corr will have 1 along the\n            diagonals and will be symmetric regardless of the callable's\n            behavior.\n    min_periods : int, optional\n        Minimum number of observations needed to have a valid result.\n\n    Returns\n    -------\n    float\n        Correlation with other.\n\n    Examples\n    --------\n    >>> def histogram_intersection(a, b):\n    ...     v = np.minimum(a, b).sum().round(decimals=1)\n    ...     return v\n    >>> s1 = pd.Series([.2, .0, .6, .2])\n    >>> s2 = pd.Series([.3, .6, .0, .1])\n    >>> s1.corr(s2, method=histogram_intersection)\n    0.3\n    \"\"\"\n    (this, other) = self.align(other, join='inner', copy=False)\n    if len(this) == 0:\n        return np.nan\n    if method in ['pearson', 'spearman', 'kendall'] or callable(method):\n        return nanops.nancorr(this.values, other.values, method=method, min_periods=min_periods)\n    raise ValueError(f\"method must be either 'pearson', 'spearman', 'kendall', or a callable, '{method}' was supplied\")",
                            "def cov(self, other, min_periods=None) -> float:\n    \"\"\"\n    Compute covariance with Series, excluding missing values.\n\n    Parameters\n    ----------\n    other : Series\n        Series with which to compute the covariance.\n    min_periods : int, optional\n        Minimum number of observations needed to have a valid result.\n\n    Returns\n    -------\n    float\n        Covariance between Series and other normalized by N-1\n        (unbiased estimator).\n\n    Examples\n    --------\n    >>> s1 = pd.Series([0.90010907, 0.13484424, 0.62036035])\n    >>> s2 = pd.Series([0.12528585, 0.26962463, 0.51111198])\n    >>> s1.cov(s2)\n    -0.01685762652715874\n    \"\"\"\n    (this, other) = self.align(other, join='inner', copy=False)\n    if len(this) == 0:\n        return np.nan\n    return nanops.nancov(this.values, other.values, min_periods=min_periods)",
                            "def diff(self, periods=1) -> 'Series':\n    \"\"\"\n    First discrete difference of element.\n\n    Calculates the difference of a Series element compared with another\n    element in the Series (default is element in previous row).\n\n    Parameters\n    ----------\n    periods : int, default 1\n        Periods to shift for calculating difference, accepts negative\n        values.\n\n    Returns\n    -------\n    Series\n        First differences of the Series.\n\n    See Also\n    --------\n    Series.pct_change: Percent change over given number of periods.\n    Series.shift: Shift index by desired number of periods with an\n        optional time freq.\n    DataFrame.diff: First discrete difference of object.\n\n    Notes\n    -----\n    For boolean dtypes, this uses :meth:`operator.xor` rather than\n    :meth:`operator.sub`.\n\n    Examples\n    --------\n    Difference with previous row\n\n    >>> s = pd.Series([1, 1, 2, 3, 5, 8])\n    >>> s.diff()\n    0    NaN\n    1    0.0\n    2    1.0\n    3    1.0\n    4    2.0\n    5    3.0\n    dtype: float64\n\n    Difference with 3rd previous row\n\n    >>> s.diff(periods=3)\n    0    NaN\n    1    NaN\n    2    NaN\n    3    2.0\n    4    4.0\n    5    6.0\n    dtype: float64\n\n    Difference with following row\n\n    >>> s.diff(periods=-1)\n    0    0.0\n    1   -1.0\n    2   -1.0\n    3   -2.0\n    4   -3.0\n    5    NaN\n    dtype: float64\n    \"\"\"\n    result = algorithms.diff(self.array, periods)\n    return self._constructor(result, index=self.index).__finalize__(self)",
                            "def autocorr(self, lag=1) -> float:\n    \"\"\"\n    Compute the lag-N autocorrelation.\n\n    This method computes the Pearson correlation between\n    the Series and its shifted self.\n\n    Parameters\n    ----------\n    lag : int, default 1\n        Number of lags to apply before performing autocorrelation.\n\n    Returns\n    -------\n    float\n        The Pearson correlation between self and self.shift(lag).\n\n    See Also\n    --------\n    Series.corr : Compute the correlation between two Series.\n    Series.shift : Shift index by desired number of periods.\n    DataFrame.corr : Compute pairwise correlation of columns.\n    DataFrame.corrwith : Compute pairwise correlation between rows or\n        columns of two DataFrame objects.\n\n    Notes\n    -----\n    If the Pearson correlation is not well defined return 'NaN'.\n\n    Examples\n    --------\n    >>> s = pd.Series([0.25, 0.5, 0.2, -0.05])\n    >>> s.autocorr()  # doctest: +ELLIPSIS\n    0.10355...\n    >>> s.autocorr(lag=2)  # doctest: +ELLIPSIS\n    -0.99999...\n\n    If the Pearson correlation is not well defined, then 'NaN' is returned.\n\n    >>> s = pd.Series([1, 0, 0, 0])\n    >>> s.autocorr()\n    nan\n    \"\"\"\n    return self.corr(self.shift(lag))",
                            "def dot(self, other):\n    \"\"\"\n    Compute the dot product between the Series and the columns of other.\n\n    This method computes the dot product between the Series and another\n    one, or the Series and each columns of a DataFrame, or the Series and\n    each columns of an array.\n\n    It can also be called using `self @ other` in Python >= 3.5.\n\n    Parameters\n    ----------\n    other : Series, DataFrame or array-like\n        The other object to compute the dot product with its columns.\n\n    Returns\n    -------\n    scalar, Series or numpy.ndarray\n        Return the dot product of the Series and other if other is a\n        Series, the Series of the dot product of Series and each rows of\n        other if other is a DataFrame or a numpy.ndarray between the Series\n        and each columns of the numpy array.\n\n    See Also\n    --------\n    DataFrame.dot: Compute the matrix product with the DataFrame.\n    Series.mul: Multiplication of series and other, element-wise.\n\n    Notes\n    -----\n    The Series and other has to share the same index if other is a Series\n    or a DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series([0, 1, 2, 3])\n    >>> other = pd.Series([-1, 2, -3, 4])\n    >>> s.dot(other)\n    8\n    >>> s @ other\n    8\n    >>> df = pd.DataFrame([[0, 1], [-2, 3], [4, -5], [6, 7]])\n    >>> s.dot(df)\n    0    24\n    1    14\n    dtype: int64\n    >>> arr = np.array([[0, 1], [-2, 3], [4, -5], [6, 7]])\n    >>> s.dot(arr)\n    array([24, 14])\n    \"\"\"\n    if isinstance(other, (Series, ABCDataFrame)):\n        common = self.index.union(other.index)\n        if len(common) > len(self.index) or len(common) > len(other.index):\n            raise ValueError('matrices are not aligned')\n        left = self.reindex(index=common, copy=False)\n        right = other.reindex(index=common, copy=False)\n        lvals = left.values\n        rvals = right.values\n    else:\n        lvals = self.values\n        rvals = np.asarray(other)\n        if lvals.shape[0] != rvals.shape[0]:\n            raise Exception(f'Dot product shape mismatch, {lvals.shape} vs {rvals.shape}')\n    if isinstance(other, ABCDataFrame):\n        return self._constructor(np.dot(lvals, rvals), index=other.columns).__finalize__(self)\n    elif isinstance(other, Series):\n        return np.dot(lvals, rvals)\n    elif isinstance(rvals, np.ndarray):\n        return np.dot(lvals, rvals)\n    else:\n        raise TypeError(f'unsupported type: {type(other)}')",
                            "def __matmul__(self, other):\n    \"\"\"\n    Matrix multiplication using binary `@` operator in Python>=3.5.\n    \"\"\"\n    return self.dot(other)",
                            "def __rmatmul__(self, other):\n    \"\"\"\n    Matrix multiplication using binary `@` operator in Python>=3.5.\n    \"\"\"\n    return self.dot(np.transpose(other))",
                            "@Substitution(klass='Series')\n@Appender(base._shared_docs['searchsorted'])\ndef searchsorted(self, value, side='left', sorter=None):\n    return algorithms.searchsorted(self._values, value, side=side, sorter=sorter)",
                            "def append(self, to_append, ignore_index=False, verify_integrity=False):\n    \"\"\"\n    Concatenate two or more Series.\n\n    Parameters\n    ----------\n    to_append : Series or list/tuple of Series\n        Series to append with self.\n    ignore_index : bool, default False\n        If True, do not use the index labels.\n    verify_integrity : bool, default False\n        If True, raise Exception on creating index with duplicates.\n\n    Returns\n    -------\n    Series\n        Concatenated Series.\n\n    See Also\n    --------\n    concat : General function to concatenate DataFrame or Series objects.\n\n    Notes\n    -----\n    Iteratively appending to a Series can be more computationally intensive\n    than a single concatenate. A better solution is to append values to a\n    list and then concatenate the list with the original Series all at\n    once.\n\n    Examples\n    --------\n    >>> s1 = pd.Series([1, 2, 3])\n    >>> s2 = pd.Series([4, 5, 6])\n    >>> s3 = pd.Series([4, 5, 6], index=[3, 4, 5])\n    >>> s1.append(s2)\n    0    1\n    1    2\n    2    3\n    0    4\n    1    5\n    2    6\n    dtype: int64\n\n    >>> s1.append(s3)\n    0    1\n    1    2\n    2    3\n    3    4\n    4    5\n    5    6\n    dtype: int64\n\n    With `ignore_index` set to True:\n\n    >>> s1.append(s2, ignore_index=True)\n    0    1\n    1    2\n    2    3\n    3    4\n    4    5\n    5    6\n    dtype: int64\n\n    With `verify_integrity` set to True:\n\n    >>> s1.append(s2, verify_integrity=True)\n    Traceback (most recent call last):\n    ...\n    ValueError: Indexes have overlapping values: [0, 1, 2]\n    \"\"\"\n    from pandas.core.reshape.concat import concat\n    if isinstance(to_append, (list, tuple)):\n        to_concat = [self]\n        to_concat.extend(to_append)\n    else:\n        to_concat = [self, to_append]\n    return concat(to_concat, ignore_index=ignore_index, verify_integrity=verify_integrity)",
                            "def _binop(self, other, func, level=None, fill_value=None):\n    \"\"\"\n    Perform generic binary operation with optional fill value.\n\n    Parameters\n    ----------\n    other : Series\n    func : binary operator\n    fill_value : float or object\n        Value to substitute for NA/null values. If both Series are NA in a\n        location, the result will be NA regardless of the passed fill value.\n    level : int or level name, default None\n        Broadcast across a level, matching Index values on the\n        passed MultiIndex level.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    if not isinstance(other, Series):\n        raise AssertionError('Other operand must be Series')\n    new_index = self.index\n    this = self\n    if not self.index.equals(other.index):\n        (this, other) = self.align(other, level=level, join='outer', copy=False)\n        new_index = this.index\n    (this_vals, other_vals) = ops.fill_binop(this.values, other.values, fill_value)\n    with np.errstate(all='ignore'):\n        result = func(this_vals, other_vals)\n    name = ops.get_op_result_name(self, other)\n    ret = ops._construct_result(self, result, new_index, name)\n    return ret",
                            "def combine(self, other, func, fill_value=None) -> 'Series':\n    \"\"\"\n    Combine the Series with a Series or scalar according to `func`.\n\n    Combine the Series and `other` using `func` to perform elementwise\n    selection for combined Series.\n    `fill_value` is assumed when value is missing at some index\n    from one of the two objects being combined.\n\n    Parameters\n    ----------\n    other : Series or scalar\n        The value(s) to be combined with the `Series`.\n    func : function\n        Function that takes two scalars as inputs and returns an element.\n    fill_value : scalar, optional\n        The value to assume when an index is missing from\n        one Series or the other. The default specifies to use the\n        appropriate NaN value for the underlying dtype of the Series.\n\n    Returns\n    -------\n    Series\n        The result of combining the Series with the other object.\n\n    See Also\n    --------\n    Series.combine_first : Combine Series values, choosing the calling\n        Series' values first.\n\n    Examples\n    --------\n    Consider 2 Datasets ``s1`` and ``s2`` containing\n    highest clocked speeds of different birds.\n\n    >>> s1 = pd.Series({'falcon': 330.0, 'eagle': 160.0})\n    >>> s1\n    falcon    330.0\n    eagle     160.0\n    dtype: float64\n    >>> s2 = pd.Series({'falcon': 345.0, 'eagle': 200.0, 'duck': 30.0})\n    >>> s2\n    falcon    345.0\n    eagle     200.0\n    duck       30.0\n    dtype: float64\n\n    Now, to combine the two datasets and view the highest speeds\n    of the birds across the two datasets\n\n    >>> s1.combine(s2, max)\n    duck        NaN\n    eagle     200.0\n    falcon    345.0\n    dtype: float64\n\n    In the previous example, the resulting value for duck is missing,\n    because the maximum of a NaN and a float is a NaN.\n    So, in the example, we set ``fill_value=0``,\n    so the maximum value returned will be the value from some dataset.\n\n    >>> s1.combine(s2, max, fill_value=0)\n    duck       30.0\n    eagle     200.0\n    falcon    345.0\n    dtype: float64\n    \"\"\"\n    if fill_value is None:\n        fill_value = na_value_for_dtype(self.dtype, compat=False)\n    if isinstance(other, Series):\n        new_index = self.index.union(other.index)\n        new_name = ops.get_op_result_name(self, other)\n        new_values = []\n        for idx in new_index:\n            lv = self.get(idx, fill_value)\n            rv = other.get(idx, fill_value)\n            with np.errstate(all='ignore'):\n                new_values.append(func(lv, rv))\n    else:\n        new_index = self.index\n        with np.errstate(all='ignore'):\n            new_values = [func(lv, other) for lv in self._values]\n        new_name = self.name\n    if is_categorical_dtype(self.values):\n        pass\n    elif is_extension_array_dtype(self.values):\n        new_values = try_cast_to_ea(self._values, new_values)\n    return self._constructor(new_values, index=new_index, name=new_name)",
                            "def combine_first(self, other) -> 'Series':\n    \"\"\"\n    Combine Series values, choosing the calling Series's values first.\n\n    Parameters\n    ----------\n    other : Series\n        The value(s) to be combined with the `Series`.\n\n    Returns\n    -------\n    Series\n        The result of combining the Series with the other object.\n\n    See Also\n    --------\n    Series.combine : Perform elementwise operation on two Series\n        using a given function.\n\n    Notes\n    -----\n    Result index will be the union of the two indexes.\n\n    Examples\n    --------\n    >>> s1 = pd.Series([1, np.nan])\n    >>> s2 = pd.Series([3, 4])\n    >>> s1.combine_first(s2)\n    0    1.0\n    1    4.0\n    dtype: float64\n    \"\"\"\n    new_index = self.index.union(other.index)\n    this = self.reindex(new_index, copy=False)\n    other = other.reindex(new_index, copy=False)\n    if this.dtype.kind == 'M' and other.dtype.kind != 'M':\n        other = to_datetime(other)\n    return this.where(notna(this), other)",
                            "def update(self, other) -> None:\n    \"\"\"\n    Modify Series in place using non-NA values from passed\n    Series. Aligns on index.\n\n    Parameters\n    ----------\n    other : Series\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update(pd.Series([4, 5, 6]))\n    >>> s\n    0    4\n    1    5\n    2    6\n    dtype: int64\n\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s.update(pd.Series(['d', 'e'], index=[0, 2]))\n    >>> s\n    0    d\n    1    b\n    2    e\n    dtype: object\n\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update(pd.Series([4, 5, 6, 7, 8]))\n    >>> s\n    0    4\n    1    5\n    2    6\n    dtype: int64\n\n    If ``other`` contains NaNs the corresponding values are not updated\n    in the original Series.\n\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update(pd.Series([4, np.nan, 6]))\n    >>> s\n    0    4\n    1    2\n    2    6\n    dtype: int64\n    \"\"\"\n    other = other.reindex_like(self)\n    mask = notna(other)\n    self._data = self._data.putmask(mask=mask, new=other, inplace=True)\n    self._maybe_update_cacher()",
                            "def sort_values(self, axis=0, ascending=True, inplace: bool=False, kind: str='quicksort', na_position: str='last', ignore_index: bool=False):\n    \"\"\"\n    Sort by the values.\n\n    Sort a Series in ascending or descending order by some\n    criterion.\n\n    Parameters\n    ----------\n    axis : {0 or 'index'}, default 0\n        Axis to direct sorting. The value 'index' is accepted for\n        compatibility with DataFrame.sort_values.\n    ascending : bool, default True\n        If True, sort values in ascending order, otherwise descending.\n    inplace : bool, default False\n        If True, perform operation in-place.\n    kind : {'quicksort', 'mergesort' or 'heapsort'}, default 'quicksort'\n        Choice of sorting algorithm. See also :func:`numpy.sort` for more\n        information. 'mergesort' is the only stable  algorithm.\n    na_position : {'first' or 'last'}, default 'last'\n        Argument 'first' puts NaNs at the beginning, 'last' puts NaNs at\n        the end.\n    ignore_index : bool, default False\n         If True, the resulting axis will be labeled 0, 1, \u2026, n - 1.\n\n         .. versionadded:: 1.0.0\n\n    Returns\n    -------\n    Series\n        Series ordered by values.\n\n    See Also\n    --------\n    Series.sort_index : Sort by the Series indices.\n    DataFrame.sort_values : Sort DataFrame by the values along either axis.\n    DataFrame.sort_index : Sort DataFrame by indices.\n\n    Examples\n    --------\n    >>> s = pd.Series([np.nan, 1, 3, 10, 5])\n    >>> s\n    0     NaN\n    1     1.0\n    2     3.0\n    3     10.0\n    4     5.0\n    dtype: float64\n\n    Sort values ascending order (default behaviour)\n\n    >>> s.sort_values(ascending=True)\n    1     1.0\n    2     3.0\n    4     5.0\n    3    10.0\n    0     NaN\n    dtype: float64\n\n    Sort values descending order\n\n    >>> s.sort_values(ascending=False)\n    3    10.0\n    4     5.0\n    2     3.0\n    1     1.0\n    0     NaN\n    dtype: float64\n\n    Sort values inplace\n\n    >>> s.sort_values(ascending=False, inplace=True)\n    >>> s\n    3    10.0\n    4     5.0\n    2     3.0\n    1     1.0\n    0     NaN\n    dtype: float64\n\n    Sort values putting NAs first\n\n    >>> s.sort_values(na_position='first')\n    0     NaN\n    1     1.0\n    2     3.0\n    4     5.0\n    3    10.0\n    dtype: float64\n\n    Sort a series of strings\n\n    >>> s = pd.Series(['z', 'b', 'd', 'a', 'c'])\n    >>> s\n    0    z\n    1    b\n    2    d\n    3    a\n    4    c\n    dtype: object\n\n    >>> s.sort_values()\n    3    a\n    1    b\n    4    c\n    2    d\n    0    z\n    dtype: object\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    self._get_axis_number(axis)\n    if inplace and self._is_cached:\n        raise ValueError('This Series is a view of some other array, to sort in-place you must create a copy')\n\n    def _try_kind_sort(arr):\n        try:\n            return arr.argsort(kind=kind)\n        except TypeError:\n            return arr.argsort(kind='quicksort')\n    arr = self._values\n    sorted_index = np.empty(len(self), dtype=np.int32)\n    bad = isna(arr)\n    good = ~bad\n    idx = ibase.default_index(len(self))\n    argsorted = _try_kind_sort(arr[good])\n    if is_list_like(ascending):\n        if len(ascending) != 1:\n            raise ValueError(f'Length of ascending ({len(ascending)}) must be 1 for Series')\n        ascending = ascending[0]\n    if not is_bool(ascending):\n        raise ValueError('ascending must be boolean')\n    if not ascending:\n        argsorted = argsorted[::-1]\n    if na_position == 'last':\n        n = good.sum()\n        sorted_index[:n] = idx[good][argsorted]\n        sorted_index[n:] = idx[bad]\n    elif na_position == 'first':\n        n = bad.sum()\n        sorted_index[n:] = idx[good][argsorted]\n        sorted_index[:n] = idx[bad]\n    else:\n        raise ValueError(f'invalid na_position: {na_position}')\n    result = self._constructor(arr[sorted_index], index=self.index[sorted_index])\n    if ignore_index:\n        result.index = ibase.default_index(len(sorted_index))\n    if inplace:\n        self._update_inplace(result)\n    else:\n        return result.__finalize__(self)",
                            "def sort_index(self, axis=0, level=None, ascending=True, inplace=False, kind='quicksort', na_position='last', sort_remaining=True, ignore_index: bool=False):\n    \"\"\"\n    Sort Series by index labels.\n\n    Returns a new Series sorted by label if `inplace` argument is\n    ``False``, otherwise updates the original series and returns None.\n\n    Parameters\n    ----------\n    axis : int, default 0\n        Axis to direct sorting. This can only be 0 for Series.\n    level : int, optional\n        If not None, sort on values in specified index level(s).\n    ascending : bool, default true\n        Sort ascending vs. descending.\n    inplace : bool, default False\n        If True, perform operation in-place.\n    kind : {'quicksort', 'mergesort', 'heapsort'}, default 'quicksort'\n        Choice of sorting algorithm. See also :func:`numpy.sort` for more\n        information.  'mergesort' is the only stable algorithm. For\n        DataFrames, this option is only applied when sorting on a single\n        column or label.\n    na_position : {'first', 'last'}, default 'last'\n        If 'first' puts NaNs at the beginning, 'last' puts NaNs at the end.\n        Not implemented for MultiIndex.\n    sort_remaining : bool, default True\n        If True and sorting by level and index is multilevel, sort by other\n        levels too (in order) after sorting by specified level.\n    ignore_index : bool, default False\n        If True, the resulting axis will be labeled 0, 1, \u2026, n - 1.\n\n        .. versionadded:: 1.0.0\n\n    Returns\n    -------\n    Series\n        The original Series sorted by the labels.\n\n    See Also\n    --------\n    DataFrame.sort_index: Sort DataFrame by the index.\n    DataFrame.sort_values: Sort DataFrame by the value.\n    Series.sort_values : Sort Series by the value.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c', 'd'], index=[3, 2, 1, 4])\n    >>> s.sort_index()\n    1    c\n    2    b\n    3    a\n    4    d\n    dtype: object\n\n    Sort Descending\n\n    >>> s.sort_index(ascending=False)\n    4    d\n    3    a\n    2    b\n    1    c\n    dtype: object\n\n    Sort Inplace\n\n    >>> s.sort_index(inplace=True)\n    >>> s\n    1    c\n    2    b\n    3    a\n    4    d\n    dtype: object\n\n    By default NaNs are put at the end, but use `na_position` to place\n    them at the beginning\n\n    >>> s = pd.Series(['a', 'b', 'c', 'd'], index=[3, 2, 1, np.nan])\n    >>> s.sort_index(na_position='first')\n    NaN     d\n     1.0    c\n     2.0    b\n     3.0    a\n    dtype: object\n\n    Specify index level to sort\n\n    >>> arrays = [np.array(['qux', 'qux', 'foo', 'foo',\n    ...                     'baz', 'baz', 'bar', 'bar']),\n    ...           np.array(['two', 'one', 'two', 'one',\n    ...                     'two', 'one', 'two', 'one'])]\n    >>> s = pd.Series([1, 2, 3, 4, 5, 6, 7, 8], index=arrays)\n    >>> s.sort_index(level=1)\n    bar  one    8\n    baz  one    6\n    foo  one    4\n    qux  one    2\n    bar  two    7\n    baz  two    5\n    foo  two    3\n    qux  two    1\n    dtype: int64\n\n    Does not sort by remaining levels when sorting by levels\n\n    >>> s.sort_index(level=1, sort_remaining=False)\n    qux  one    2\n    foo  one    4\n    baz  one    6\n    bar  one    8\n    qux  two    1\n    foo  two    3\n    baz  two    5\n    bar  two    7\n    dtype: int64\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    self._get_axis_number(axis)\n    index = self.index\n    if level is not None:\n        (new_index, indexer) = index.sortlevel(level, ascending=ascending, sort_remaining=sort_remaining)\n    elif isinstance(index, MultiIndex):\n        from pandas.core.sorting import lexsort_indexer\n        labels = index._sort_levels_monotonic()\n        indexer = lexsort_indexer(labels._get_codes_for_sorting(), orders=ascending, na_position=na_position)\n    else:\n        from pandas.core.sorting import nargsort\n        if ascending and index.is_monotonic_increasing or (not ascending and index.is_monotonic_decreasing):\n            if inplace:\n                return\n            else:\n                return self.copy()\n        indexer = nargsort(index, kind=kind, ascending=ascending, na_position=na_position)\n    indexer = ensure_platform_int(indexer)\n    new_index = index.take(indexer)\n    new_index = new_index._sort_levels_monotonic()\n    new_values = self._values.take(indexer)\n    result = self._constructor(new_values, index=new_index)\n    if ignore_index:\n        result.index = ibase.default_index(len(result))\n    if inplace:\n        self._update_inplace(result)\n    else:\n        return result.__finalize__(self)",
                            "def argsort(self, axis=0, kind='quicksort', order=None) -> 'Series':\n    \"\"\"\n    Override ndarray.argsort. Argsorts the value, omitting NA/null values,\n    and places the result in the same locations as the non-NA values.\n\n    Parameters\n    ----------\n    axis : {0 or \"index\"}\n        Has no effect but is accepted for compatibility with numpy.\n    kind : {'mergesort', 'quicksort', 'heapsort'}, default 'quicksort'\n        Choice of sorting algorithm. See np.sort for more\n        information. 'mergesort' is the only stable algorithm.\n    order : None\n        Has no effect but is accepted for compatibility with numpy.\n\n    Returns\n    -------\n    Series\n        Positions of values within the sort order with -1 indicating\n        nan values.\n\n    See Also\n    --------\n    numpy.ndarray.argsort\n    \"\"\"\n    values = self._values\n    mask = isna(values)\n    if mask.any():\n        result = Series(-1, index=self.index, name=self.name, dtype='int64')\n        notmask = ~mask\n        result[notmask] = np.argsort(values[notmask], kind=kind)\n        return self._constructor(result, index=self.index).__finalize__(self)\n    else:\n        return self._constructor(np.argsort(values, kind=kind), index=self.index, dtype='int64').__finalize__(self)",
                            "def nlargest(self, n=5, keep='first') -> 'Series':\n    \"\"\"\n    Return the largest `n` elements.\n\n    Parameters\n    ----------\n    n : int, default 5\n        Return this many descending sorted values.\n    keep : {'first', 'last', 'all'}, default 'first'\n        When there are duplicate values that cannot all fit in a\n        Series of `n` elements:\n\n        - ``first`` : return the first `n` occurrences in order\n            of appearance.\n        - ``last`` : return the last `n` occurrences in reverse\n            order of appearance.\n        - ``all`` : keep all occurrences. This can result in a Series of\n            size larger than `n`.\n\n    Returns\n    -------\n    Series\n        The `n` largest values in the Series, sorted in decreasing order.\n\n    See Also\n    --------\n    Series.nsmallest: Get the `n` smallest elements.\n    Series.sort_values: Sort Series by values.\n    Series.head: Return the first `n` rows.\n\n    Notes\n    -----\n    Faster than ``.sort_values(ascending=False).head(n)`` for small `n`\n    relative to the size of the ``Series`` object.\n\n    Examples\n    --------\n    >>> countries_population = {\"Italy\": 59000000, \"France\": 65000000,\n    ...                         \"Malta\": 434000, \"Maldives\": 434000,\n    ...                         \"Brunei\": 434000, \"Iceland\": 337000,\n    ...                         \"Nauru\": 11300, \"Tuvalu\": 11300,\n    ...                         \"Anguilla\": 11300, \"Monserat\": 5200}\n    >>> s = pd.Series(countries_population)\n    >>> s\n    Italy       59000000\n    France      65000000\n    Malta         434000\n    Maldives      434000\n    Brunei        434000\n    Iceland       337000\n    Nauru          11300\n    Tuvalu         11300\n    Anguilla       11300\n    Monserat        5200\n    dtype: int64\n\n    The `n` largest elements where ``n=5`` by default.\n\n    >>> s.nlargest()\n    France      65000000\n    Italy       59000000\n    Malta         434000\n    Maldives      434000\n    Brunei        434000\n    dtype: int64\n\n    The `n` largest elements where ``n=3``. Default `keep` value is 'first'\n    so Malta will be kept.\n\n    >>> s.nlargest(3)\n    France    65000000\n    Italy     59000000\n    Malta       434000\n    dtype: int64\n\n    The `n` largest elements where ``n=3`` and keeping the last duplicates.\n    Brunei will be kept since it is the last with value 434000 based on\n    the index order.\n\n    >>> s.nlargest(3, keep='last')\n    France      65000000\n    Italy       59000000\n    Brunei        434000\n    dtype: int64\n\n    The `n` largest elements where ``n=3`` with all duplicates kept. Note\n    that the returned Series has five elements due to the three duplicates.\n\n    >>> s.nlargest(3, keep='all')\n    France      65000000\n    Italy       59000000\n    Malta         434000\n    Maldives      434000\n    Brunei        434000\n    dtype: int64\n    \"\"\"\n    return algorithms.SelectNSeries(self, n=n, keep=keep).nlargest()",
                            "def nsmallest(self, n=5, keep='first') -> 'Series':\n    \"\"\"\n    Return the smallest `n` elements.\n\n    Parameters\n    ----------\n    n : int, default 5\n        Return this many ascending sorted values.\n    keep : {'first', 'last', 'all'}, default 'first'\n        When there are duplicate values that cannot all fit in a\n        Series of `n` elements:\n\n        - ``first`` : return the first `n` occurrences in order\n            of appearance.\n        - ``last`` : return the last `n` occurrences in reverse\n            order of appearance.\n        - ``all`` : keep all occurrences. This can result in a Series of\n            size larger than `n`.\n\n    Returns\n    -------\n    Series\n        The `n` smallest values in the Series, sorted in increasing order.\n\n    See Also\n    --------\n    Series.nlargest: Get the `n` largest elements.\n    Series.sort_values: Sort Series by values.\n    Series.head: Return the first `n` rows.\n\n    Notes\n    -----\n    Faster than ``.sort_values().head(n)`` for small `n` relative to\n    the size of the ``Series`` object.\n\n    Examples\n    --------\n    >>> countries_population = {\"Italy\": 59000000, \"France\": 65000000,\n    ...                         \"Brunei\": 434000, \"Malta\": 434000,\n    ...                         \"Maldives\": 434000, \"Iceland\": 337000,\n    ...                         \"Nauru\": 11300, \"Tuvalu\": 11300,\n    ...                         \"Anguilla\": 11300, \"Monserat\": 5200}\n    >>> s = pd.Series(countries_population)\n    >>> s\n    Italy       59000000\n    France      65000000\n    Brunei        434000\n    Malta         434000\n    Maldives      434000\n    Iceland       337000\n    Nauru          11300\n    Tuvalu         11300\n    Anguilla       11300\n    Monserat        5200\n    dtype: int64\n\n    The `n` smallest elements where ``n=5`` by default.\n\n    >>> s.nsmallest()\n    Monserat      5200\n    Nauru        11300\n    Tuvalu       11300\n    Anguilla     11300\n    Iceland     337000\n    dtype: int64\n\n    The `n` smallest elements where ``n=3``. Default `keep` value is\n    'first' so Nauru and Tuvalu will be kept.\n\n    >>> s.nsmallest(3)\n    Monserat     5200\n    Nauru       11300\n    Tuvalu      11300\n    dtype: int64\n\n    The `n` smallest elements where ``n=3`` and keeping the last\n    duplicates. Anguilla and Tuvalu will be kept since they are the last\n    with value 11300 based on the index order.\n\n    >>> s.nsmallest(3, keep='last')\n    Monserat     5200\n    Anguilla    11300\n    Tuvalu      11300\n    dtype: int64\n\n    The `n` smallest elements where ``n=3`` with all duplicates kept. Note\n    that the returned Series has four elements due to the three duplicates.\n\n    >>> s.nsmallest(3, keep='all')\n    Monserat     5200\n    Nauru       11300\n    Tuvalu      11300\n    Anguilla    11300\n    dtype: int64\n    \"\"\"\n    return algorithms.SelectNSeries(self, n=n, keep=keep).nsmallest()",
                            "def swaplevel(self, i=-2, j=-1, copy=True) -> 'Series':\n    \"\"\"\n    Swap levels i and j in a :class:`MultiIndex`.\n\n    Default is to swap the two innermost levels of the index.\n\n    Parameters\n    ----------\n    i, j : int, str\n        Level of the indices to be swapped. Can pass level name as string.\n    copy : bool, default True\n        Whether to copy underlying data.\n\n    Returns\n    -------\n    Series\n        Series with levels swapped in MultiIndex.\n    \"\"\"\n    assert isinstance(self.index, ABCMultiIndex)\n    new_index = self.index.swaplevel(i, j)\n    return self._constructor(self._values, index=new_index, copy=copy).__finalize__(self)",
                            "def reorder_levels(self, order) -> 'Series':\n    \"\"\"\n    Rearrange index levels using input order.\n\n    May not drop or duplicate levels.\n\n    Parameters\n    ----------\n    order : list of int representing new level order\n        Reference level by number or key.\n\n    Returns\n    -------\n    type of caller (new object)\n    \"\"\"\n    if not isinstance(self.index, MultiIndex):\n        raise Exception('Can only reorder levels on a hierarchical axis.')\n    result = self.copy()\n    assert isinstance(result.index, ABCMultiIndex)\n    result.index = result.index.reorder_levels(order)\n    return result",
                            "def explode(self) -> 'Series':\n    \"\"\"\n    Transform each element of a list-like to a row, replicating the\n    index values.\n\n    .. versionadded:: 0.25.0\n\n    Returns\n    -------\n    Series\n        Exploded lists to rows; index will be duplicated for these rows.\n\n    See Also\n    --------\n    Series.str.split : Split string values on specified separator.\n    Series.unstack : Unstack, a.k.a. pivot, Series with MultiIndex\n        to produce DataFrame.\n    DataFrame.melt : Unpivot a DataFrame from wide format to long format.\n    DataFrame.explode : Explode a DataFrame from list-like\n        columns to long format.\n\n    Notes\n    -----\n    This routine will explode list-likes including lists, tuples,\n    Series, and np.ndarray. The result dtype of the subset rows will\n    be object. Scalars will be returned unchanged. Empty list-likes will\n    result in a np.nan for that row.\n\n    Examples\n    --------\n    >>> s = pd.Series([[1, 2, 3], 'foo', [], [3, 4]])\n    >>> s\n    0    [1, 2, 3]\n    1          foo\n    2           []\n    3       [3, 4]\n    dtype: object\n\n    >>> s.explode()\n    0      1\n    0      2\n    0      3\n    1    foo\n    2    NaN\n    3      3\n    3      4\n    dtype: object\n    \"\"\"\n    if not len(self) or not is_object_dtype(self):\n        return self.copy()\n    (values, counts) = reshape.explode(np.asarray(self.array))\n    result = Series(values, index=self.index.repeat(counts), name=self.name)\n    return result",
                            "def unstack(self, level=-1, fill_value=None):\n    \"\"\"\n    Unstack, also known as pivot, Series with MultiIndex to produce DataFrame.\n    The level involved will automatically get sorted.\n\n    Parameters\n    ----------\n    level : int, str, or list of these, default last level\n        Level(s) to unstack, can pass level name.\n    fill_value : scalar value, default None\n        Value to use when replacing NaN values.\n\n    Returns\n    -------\n    DataFrame\n        Unstacked Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4],\n    ...               index=pd.MultiIndex.from_product([['one', 'two'],\n    ...                                                 ['a', 'b']]))\n    >>> s\n    one  a    1\n         b    2\n    two  a    3\n         b    4\n    dtype: int64\n\n    >>> s.unstack(level=-1)\n         a  b\n    one  1  2\n    two  3  4\n\n    >>> s.unstack(level=0)\n       one  two\n    a    1    3\n    b    2    4\n    \"\"\"\n    from pandas.core.reshape.reshape import unstack\n    return unstack(self, level, fill_value)",
                            "def map(self, arg, na_action=None) -> 'Series':\n    \"\"\"\n    Map values of Series according to input correspondence.\n\n    Used for substituting each value in a Series with another value,\n    that may be derived from a function, a ``dict`` or\n    a :class:`Series`.\n\n    Parameters\n    ----------\n    arg : function, collections.abc.Mapping subclass or Series\n        Mapping correspondence.\n    na_action : {None, 'ignore'}, default None\n        If 'ignore', propagate NaN values, without passing them to the\n        mapping correspondence.\n\n    Returns\n    -------\n    Series\n        Same index as caller.\n\n    See Also\n    --------\n    Series.apply : For applying more complex functions on a Series.\n    DataFrame.apply : Apply a function row-/column-wise.\n    DataFrame.applymap : Apply a function elementwise on a whole DataFrame.\n\n    Notes\n    -----\n    When ``arg`` is a dictionary, values in Series that are not in the\n    dictionary (as keys) are converted to ``NaN``. However, if the\n    dictionary is a ``dict`` subclass that defines ``__missing__`` (i.e.\n    provides a method for default values), then this default is used\n    rather than ``NaN``.\n\n    Examples\n    --------\n    >>> s = pd.Series(['cat', 'dog', np.nan, 'rabbit'])\n    >>> s\n    0      cat\n    1      dog\n    2      NaN\n    3   rabbit\n    dtype: object\n\n    ``map`` accepts a ``dict`` or a ``Series``. Values that are not found\n    in the ``dict`` are converted to ``NaN``, unless the dict has a default\n    value (e.g. ``defaultdict``):\n\n    >>> s.map({'cat': 'kitten', 'dog': 'puppy'})\n    0   kitten\n    1    puppy\n    2      NaN\n    3      NaN\n    dtype: object\n\n    It also accepts a function:\n\n    >>> s.map('I am a {}'.format)\n    0       I am a cat\n    1       I am a dog\n    2       I am a nan\n    3    I am a rabbit\n    dtype: object\n\n    To avoid applying the function to missing values (and keep them as\n    ``NaN``) ``na_action='ignore'`` can be used:\n\n    >>> s.map('I am a {}'.format, na_action='ignore')\n    0     I am a cat\n    1     I am a dog\n    2            NaN\n    3  I am a rabbit\n    dtype: object\n    \"\"\"\n    new_values = super()._map_values(arg, na_action=na_action)\n    return self._constructor(new_values, index=self.index).__finalize__(self)",
                            "def _gotitem(self, key, ndim, subset=None) -> 'Series':\n    \"\"\"\n    Sub-classes to define. Return a sliced object.\n\n    Parameters\n    ----------\n    key : string / list of selections\n    ndim : 1,2\n        Requested ndim of result.\n    subset : object, default None\n        Subset to act on.\n    \"\"\"\n    return self",
                            "@Substitution(see_also=_agg_see_also_doc, examples=_agg_examples_doc, versionadded='\\n.. versionadded:: 0.20.0\\n', **_shared_doc_kwargs)\n@Appender(generic._shared_docs['aggregate'])\ndef aggregate(self, func, axis=0, *args, **kwargs):\n    self._get_axis_number(axis)\n    (result, how) = self._aggregate(func, *args, **kwargs)\n    if result is None:\n        kwargs.pop('_axis', None)\n        kwargs.pop('_level', None)\n        try:\n            result = self.apply(func, *args, **kwargs)\n        except (ValueError, AttributeError, TypeError):\n            result = func(self, *args, **kwargs)\n    return result",
                            "@Appender(generic._shared_docs['transform'] % _shared_doc_kwargs)\ndef transform(self, func, axis=0, *args, **kwargs):\n    self._get_axis_number(axis)\n    return super().transform(func, *args, **kwargs)",
                            "def apply(self, func, convert_dtype=True, args=(), **kwds):\n    \"\"\"\n    Invoke function on values of Series.\n\n    Can be ufunc (a NumPy function that applies to the entire Series)\n    or a Python function that only works on single values.\n\n    Parameters\n    ----------\n    func : function\n        Python function or NumPy ufunc to apply.\n    convert_dtype : bool, default True\n        Try to find better dtype for elementwise function results. If\n        False, leave as dtype=object.\n    args : tuple\n        Positional arguments passed to func after the series value.\n    **kwds\n        Additional keyword arguments passed to func.\n\n    Returns\n    -------\n    Series or DataFrame\n        If func returns a Series object the result will be a DataFrame.\n\n    See Also\n    --------\n    Series.map: For element-wise operations.\n    Series.agg: Only perform aggregating type operations.\n    Series.transform: Only perform transforming type operations.\n\n    Examples\n    --------\n    Create a series with typical summer temperatures for each city.\n\n    >>> s = pd.Series([20, 21, 12],\n    ...               index=['London', 'New York', 'Helsinki'])\n    >>> s\n    London      20\n    New York    21\n    Helsinki    12\n    dtype: int64\n\n    Square the values by defining a function and passing it as an\n    argument to ``apply()``.\n\n    >>> def square(x):\n    ...     return x ** 2\n    >>> s.apply(square)\n    London      400\n    New York    441\n    Helsinki    144\n    dtype: int64\n\n    Square the values by passing an anonymous function as an\n    argument to ``apply()``.\n\n    >>> s.apply(lambda x: x ** 2)\n    London      400\n    New York    441\n    Helsinki    144\n    dtype: int64\n\n    Define a custom function that needs additional positional\n    arguments and pass these additional arguments using the\n    ``args`` keyword.\n\n    >>> def subtract_custom_value(x, custom_value):\n    ...     return x - custom_value\n\n    >>> s.apply(subtract_custom_value, args=(5,))\n    London      15\n    New York    16\n    Helsinki     7\n    dtype: int64\n\n    Define a custom function that takes keyword arguments\n    and pass these arguments to ``apply``.\n\n    >>> def add_custom_values(x, **kwargs):\n    ...     for month in kwargs:\n    ...         x += kwargs[month]\n    ...     return x\n\n    >>> s.apply(add_custom_values, june=30, july=20, august=25)\n    London      95\n    New York    96\n    Helsinki    87\n    dtype: int64\n\n    Use a function from the Numpy library.\n\n    >>> s.apply(np.log)\n    London      2.995732\n    New York    3.044522\n    Helsinki    2.484907\n    dtype: float64\n    \"\"\"\n    if len(self) == 0:\n        return self._constructor(dtype=self.dtype, index=self.index).__finalize__(self)\n    if isinstance(func, (list, dict)):\n        return self.aggregate(func, *args, **kwds)\n    if isinstance(func, str):\n        return self._try_aggregate_string_function(func, *args, **kwds)\n    if kwds or (args and (not isinstance(func, np.ufunc))):\n\n        def f(x):\n            return func(x, *args, **kwds)\n    else:\n        f = func\n    with np.errstate(all='ignore'):\n        if isinstance(f, np.ufunc):\n            return f(self)\n        if is_extension_array_dtype(self.dtype) and hasattr(self._values, 'map'):\n            mapped = self._values.map(f)\n        else:\n            values = self.astype(object).values\n            mapped = lib.map_infer(values, f, convert=convert_dtype)\n    if len(mapped) and isinstance(mapped[0], Series):\n        return self._constructor_expanddim(pd.array(mapped), index=self.index)\n    else:\n        return self._constructor(mapped, index=self.index).__finalize__(self)",
                            "def _reduce(self, op, name, axis=0, skipna=True, numeric_only=None, filter_type=None, **kwds):\n    \"\"\"\n    Perform a reduction operation.\n\n    If we have an ndarray as a value, then simply perform the operation,\n    otherwise delegate to the object.\n    \"\"\"\n    delegate = self._values\n    if axis is not None:\n        self._get_axis_number(axis)\n    if isinstance(delegate, Categorical):\n        return delegate._reduce(name, skipna=skipna, **kwds)\n    elif isinstance(delegate, ExtensionArray):\n        return delegate._reduce(name, skipna=skipna, **kwds)\n    elif is_datetime64_dtype(delegate):\n        delegate = DatetimeIndex(delegate)\n    elif is_timedelta64_dtype(delegate) and hasattr(TimedeltaIndex, name):\n        delegate = TimedeltaIndex(delegate)\n    elif isinstance(delegate, np.ndarray):\n        if numeric_only:\n            raise NotImplementedError(f'Series.{name} does not implement numeric_only.')\n        with np.errstate(all='ignore'):\n            return op(delegate, skipna=skipna, **kwds)\n    return delegate._reduce(op=op, name=name, axis=axis, skipna=skipna, numeric_only=numeric_only, filter_type=filter_type, **kwds)",
                            "def _reindex_indexer(self, new_index, indexer, copy):\n    if indexer is None:\n        if copy:\n            return self.copy()\n        return self\n    new_values = algorithms.take_1d(self._values, indexer, allow_fill=True, fill_value=None)\n    return self._constructor(new_values, index=new_index)",
                            "def _needs_reindex_multi(self, axes, method, level):\n    \"\"\"\n    Check if we do need a multi reindex; this is for compat with\n    higher dims.\n    \"\"\"\n    return False",
                            "@Appender(generic._shared_docs['align'] % _shared_doc_kwargs)\ndef align(self, other, join='outer', axis=None, level=None, copy=True, fill_value=None, method=None, limit=None, fill_axis=0, broadcast_axis=None):\n    return super().align(other, join=join, axis=axis, level=level, copy=copy, fill_value=fill_value, method=method, limit=limit, fill_axis=fill_axis, broadcast_axis=broadcast_axis)",
                            "def rename(self, index=None, *, axis=None, copy=True, inplace=False, level=None, errors='ignore'):\n    \"\"\"\n    Alter Series index labels or name.\n\n    Function / dict values must be unique (1-to-1). Labels not contained in\n    a dict / Series will be left as-is. Extra labels listed don't throw an\n    error.\n\n    Alternatively, change ``Series.name`` with a scalar value.\n\n    See the :ref:`user guide <basics.rename>` for more.\n\n    Parameters\n    ----------\n    axis : {0 or \"index\"}\n        Unused. Accepted for compatability with DataFrame method only.\n    index : scalar, hashable sequence, dict-like or function, optional\n        Functions or dict-like are transformations to apply to\n        the index.\n        Scalar or hashable sequence-like will alter the ``Series.name``\n        attribute.\n\n    **kwargs\n        Additional keyword arguments passed to the function. Only the\n        \"inplace\" keyword is used.\n\n    Returns\n    -------\n    Series\n        Series with index labels or name altered.\n\n    See Also\n    --------\n    DataFrame.rename : Corresponding DataFrame method.\n    Series.rename_axis : Set the name of the axis.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3])\n    >>> s\n    0    1\n    1    2\n    2    3\n    dtype: int64\n    >>> s.rename(\"my_name\")  # scalar, changes Series.name\n    0    1\n    1    2\n    2    3\n    Name: my_name, dtype: int64\n    >>> s.rename(lambda x: x ** 2)  # function, changes labels\n    0    1\n    1    2\n    4    3\n    dtype: int64\n    >>> s.rename({1: 3, 2: 5})  # mapping, changes labels\n    0    1\n    3    2\n    5    3\n    dtype: int64\n    \"\"\"\n    if callable(index) or is_dict_like(index):\n        return super().rename(index, copy=copy, inplace=inplace, level=level, errors=errors)\n    else:\n        return self._set_name(index, inplace=inplace)",
                            "@Appender(\"\\n        >>> s = pd.Series([1, 2, 3])\\n        >>> s\\n        0    1\\n        1    2\\n        2    3\\n        dtype: int64\\n\\n        >>> s.set_axis(['a', 'b', 'c'], axis=0)\\n        a    1\\n        b    2\\n        c    3\\n        dtype: int64\\n    \")\n@Substitution(**_shared_doc_kwargs, extended_summary_sub='', axis_description_sub='', see_also_sub='')\n@Appender(generic.NDFrame.set_axis.__doc__)\ndef set_axis(self, labels, axis=0, inplace=False):\n    return super().set_axis(labels, axis=axis, inplace=inplace)",
                            "@Substitution(**_shared_doc_kwargs)\n@Appender(generic.NDFrame.reindex.__doc__)\ndef reindex(self, index=None, **kwargs):\n    return super().reindex(index=index, **kwargs)",
                            "def drop(self, labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors='raise') -> 'Series':\n    \"\"\"\n    Return Series with specified index labels removed.\n\n    Remove elements of a Series based on specifying the index labels.\n    When using a multi-index, labels on different levels can be removed\n    by specifying the level.\n\n    Parameters\n    ----------\n    labels : single label or list-like\n        Index labels to drop.\n    axis : 0, default 0\n        Redundant for application on Series.\n    index : single label or list-like\n        Redundant for application on Series, but 'index' can be used instead\n        of 'labels'.\n\n        .. versionadded:: 0.21.0\n    columns : single label or list-like\n        No change is made to the Series; use 'index' or 'labels' instead.\n\n        .. versionadded:: 0.21.0\n    level : int or level name, optional\n        For MultiIndex, level for which the labels will be removed.\n    inplace : bool, default False\n        If True, do operation inplace and return None.\n    errors : {'ignore', 'raise'}, default 'raise'\n        If 'ignore', suppress error and only existing labels are dropped.\n\n    Returns\n    -------\n    Series\n        Series with specified index labels removed.\n\n    Raises\n    ------\n    KeyError\n        If none of the labels are found in the index.\n\n    See Also\n    --------\n    Series.reindex : Return only specified index labels of Series.\n    Series.dropna : Return series without null values.\n    Series.drop_duplicates : Return Series with duplicate values removed.\n    DataFrame.drop : Drop specified labels from rows or columns.\n\n    Examples\n    --------\n    >>> s = pd.Series(data=np.arange(3), index=['A', 'B', 'C'])\n    >>> s\n    A  0\n    B  1\n    C  2\n    dtype: int64\n\n    Drop labels B en C\n\n    >>> s.drop(labels=['B', 'C'])\n    A  0\n    dtype: int64\n\n    Drop 2nd level label in MultiIndex Series\n\n    >>> midx = pd.MultiIndex(levels=[['lama', 'cow', 'falcon'],\n    ...                              ['speed', 'weight', 'length']],\n    ...                      codes=[[0, 0, 0, 1, 1, 1, 2, 2, 2],\n    ...                             [0, 1, 2, 0, 1, 2, 0, 1, 2]])\n    >>> s = pd.Series([45, 200, 1.2, 30, 250, 1.5, 320, 1, 0.3],\n    ...               index=midx)\n    >>> s\n    lama    speed      45.0\n            weight    200.0\n            length      1.2\n    cow     speed      30.0\n            weight    250.0\n            length      1.5\n    falcon  speed     320.0\n            weight      1.0\n            length      0.3\n    dtype: float64\n\n    >>> s.drop(labels='weight', level=1)\n    lama    speed      45.0\n            length      1.2\n    cow     speed      30.0\n            length      1.5\n    falcon  speed     320.0\n            length      0.3\n    dtype: float64\n    \"\"\"\n    return super().drop(labels=labels, axis=axis, index=index, columns=columns, level=level, inplace=inplace, errors=errors)",
                            "@Substitution(**_shared_doc_kwargs)\n@Appender(generic.NDFrame.fillna.__doc__)\ndef fillna(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None) -> Optional['Series']:\n    return super().fillna(value=value, method=method, axis=axis, inplace=inplace, limit=limit, downcast=downcast)",
                            "@Appender(generic._shared_docs['replace'] % _shared_doc_kwargs)\ndef replace(self, to_replace=None, value=None, inplace=False, limit=None, regex=False, method='pad'):\n    return super().replace(to_replace=to_replace, value=value, inplace=inplace, limit=limit, regex=regex, method=method)",
                            "@Appender(generic._shared_docs['shift'] % _shared_doc_kwargs)\ndef shift(self, periods=1, freq=None, axis=0, fill_value=None) -> 'Series':\n    return super().shift(periods=periods, freq=freq, axis=axis, fill_value=fill_value)",
                            "def memory_usage(self, index=True, deep=False):\n    \"\"\"\n    Return the memory usage of the Series.\n\n    The memory usage can optionally include the contribution of\n    the index and of elements of `object` dtype.\n\n    Parameters\n    ----------\n    index : bool, default True\n        Specifies whether to include the memory usage of the Series index.\n    deep : bool, default False\n        If True, introspect the data deeply by interrogating\n        `object` dtypes for system-level memory consumption, and include\n        it in the returned value.\n\n    Returns\n    -------\n    int\n        Bytes of memory consumed.\n\n    See Also\n    --------\n    numpy.ndarray.nbytes : Total bytes consumed by the elements of the\n        array.\n    DataFrame.memory_usage : Bytes consumed by a DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series(range(3))\n    >>> s.memory_usage()\n    152\n\n    Not including the index gives the size of the rest of the data, which\n    is necessarily smaller:\n\n    >>> s.memory_usage(index=False)\n    24\n\n    The memory footprint of `object` values is ignored by default:\n\n    >>> s = pd.Series([\"a\", \"b\"])\n    >>> s.values\n    array(['a', 'b'], dtype=object)\n    >>> s.memory_usage()\n    144\n    >>> s.memory_usage(deep=True)\n    260\n    \"\"\"\n    v = super().memory_usage(deep=deep)\n    if index:\n        v += self.index.memory_usage(deep=deep)\n    return v",
                            "def isin(self, values) -> 'Series':\n    \"\"\"\n    Check whether `values` are contained in Series.\n\n    Return a boolean Series showing whether each element in the Series\n    matches an element in the passed sequence of `values` exactly.\n\n    Parameters\n    ----------\n    values : set or list-like\n        The sequence of values to test. Passing in a single string will\n        raise a ``TypeError``. Instead, turn a single string into a\n        list of one element.\n\n    Returns\n    -------\n    Series\n        Series of booleans indicating if each element is in values.\n\n    Raises\n    ------\n    TypeError\n      * If `values` is a string\n\n    See Also\n    --------\n    DataFrame.isin : Equivalent method on DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama',\n    ...                'hippo'], name='animal')\n    >>> s.isin(['cow', 'lama'])\n    0     True\n    1     True\n    2     True\n    3    False\n    4     True\n    5    False\n    Name: animal, dtype: bool\n\n    Passing a single string as ``s.isin('lama')`` will raise an error. Use\n    a list of one element instead:\n\n    >>> s.isin(['lama'])\n    0     True\n    1    False\n    2     True\n    3    False\n    4     True\n    5    False\n    Name: animal, dtype: bool\n    \"\"\"\n    result = algorithms.isin(self, values)\n    return self._constructor(result, index=self.index).__finalize__(self)",
                            "def between(self, left, right, inclusive=True) -> 'Series':\n    \"\"\"\n    Return boolean Series equivalent to left <= series <= right.\n\n    This function returns a boolean vector containing `True` wherever the\n    corresponding Series element is between the boundary values `left` and\n    `right`. NA values are treated as `False`.\n\n    Parameters\n    ----------\n    left : scalar or list-like\n        Left boundary.\n    right : scalar or list-like\n        Right boundary.\n    inclusive : bool, default True\n        Include boundaries.\n\n    Returns\n    -------\n    Series\n        Series representing whether each element is between left and\n        right (inclusive).\n\n    See Also\n    --------\n    Series.gt : Greater than of series and other.\n    Series.lt : Less than of series and other.\n\n    Notes\n    -----\n    This function is equivalent to ``(left <= ser) & (ser <= right)``\n\n    Examples\n    --------\n    >>> s = pd.Series([2, 0, 4, 8, np.nan])\n\n    Boundary values are included by default:\n\n    >>> s.between(1, 4)\n    0     True\n    1    False\n    2     True\n    3    False\n    4    False\n    dtype: bool\n\n    With `inclusive` set to ``False`` boundary values are excluded:\n\n    >>> s.between(1, 4, inclusive=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    4    False\n    dtype: bool\n\n    `left` and `right` can be any scalar value:\n\n    >>> s = pd.Series(['Alice', 'Bob', 'Carol', 'Eve'])\n    >>> s.between('Anna', 'Daniel')\n    0    False\n    1     True\n    2     True\n    3    False\n    dtype: bool\n    \"\"\"\n    if inclusive:\n        lmask = self >= left\n        rmask = self <= right\n    else:\n        lmask = self > left\n        rmask = self < right\n    return lmask & rmask",
                            "def _convert_dtypes(self: ABCSeries, infer_objects: bool=True, convert_string: bool=True, convert_integer: bool=True, convert_boolean: bool=True) -> 'Series':\n    input_series = self\n    if infer_objects:\n        input_series = input_series.infer_objects()\n        if is_object_dtype(input_series):\n            input_series = input_series.copy()\n    if convert_string or convert_integer or convert_boolean:\n        inferred_dtype = convert_dtypes(input_series._values, convert_string, convert_integer, convert_boolean)\n        try:\n            result = input_series.astype(inferred_dtype)\n        except TypeError:\n            result = input_series.copy()\n    else:\n        result = input_series.copy()\n    return result",
                            "@Appender(generic._shared_docs['isna'] % _shared_doc_kwargs)\ndef isna(self) -> 'Series':\n    return super().isna()",
                            "@Appender(generic._shared_docs['isna'] % _shared_doc_kwargs)\ndef isnull(self) -> 'Series':\n    return super().isnull()",
                            "@Appender(generic._shared_docs['notna'] % _shared_doc_kwargs)\ndef notna(self) -> 'Series':\n    return super().notna()",
                            "@Appender(generic._shared_docs['notna'] % _shared_doc_kwargs)\ndef notnull(self) -> 'Series':\n    return super().notnull()",
                            "def dropna(self, axis=0, inplace=False, how=None):\n    \"\"\"\n    Return a new Series with missing values removed.\n\n    See the :ref:`User Guide <missing_data>` for more on which values are\n    considered missing, and how to work with missing data.\n\n    Parameters\n    ----------\n    axis : {0 or 'index'}, default 0\n        There is only one axis to drop values from.\n    inplace : bool, default False\n        If True, do operation inplace and return None.\n    how : str, optional\n        Not in use. Kept for compatibility.\n\n    Returns\n    -------\n    Series\n        Series with NA entries dropped from it.\n\n    See Also\n    --------\n    Series.isna: Indicate missing values.\n    Series.notna : Indicate existing (non-missing) values.\n    Series.fillna : Replace missing values.\n    DataFrame.dropna : Drop rows or columns which contain NA values.\n    Index.dropna : Drop missing indices.\n\n    Examples\n    --------\n    >>> ser = pd.Series([1., 2., np.nan])\n    >>> ser\n    0    1.0\n    1    2.0\n    2    NaN\n    dtype: float64\n\n    Drop NA values from a Series.\n\n    >>> ser.dropna()\n    0    1.0\n    1    2.0\n    dtype: float64\n\n    Keep the Series with valid entries in the same variable.\n\n    >>> ser.dropna(inplace=True)\n    >>> ser\n    0    1.0\n    1    2.0\n    dtype: float64\n\n    Empty strings are not considered NA values. ``None`` is considered an\n    NA value.\n\n    >>> ser = pd.Series([np.NaN, 2, pd.NaT, '', None, 'I stay'])\n    >>> ser\n    0       NaN\n    1         2\n    2       NaT\n    3\n    4      None\n    5    I stay\n    dtype: object\n    >>> ser.dropna()\n    1         2\n    3\n    5    I stay\n    dtype: object\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    self._get_axis_number(axis or 0)\n    if self._can_hold_na:\n        result = remove_na_arraylike(self)\n        if inplace:\n            self._update_inplace(result)\n        else:\n            return result\n    elif inplace:\n        pass\n    else:\n        return self.copy()",
                            "def to_timestamp(self, freq=None, how='start', copy=True) -> 'Series':\n    \"\"\"\n    Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n\n    Parameters\n    ----------\n    freq : str, default frequency of PeriodIndex\n        Desired frequency.\n    how : {'s', 'e', 'start', 'end'}\n        Convention for converting period to timestamp; start of period\n        vs. end.\n    copy : bool, default True\n        Whether or not to return a copy.\n\n    Returns\n    -------\n    Series with DatetimeIndex\n    \"\"\"\n    new_values = self._values\n    if copy:\n        new_values = new_values.copy()\n    assert isinstance(self.index, (ABCDatetimeIndex, ABCPeriodIndex))\n    new_index = self.index.to_timestamp(freq=freq, how=how)\n    return self._constructor(new_values, index=new_index).__finalize__(self)",
                            "def to_period(self, freq=None, copy=True) -> 'Series':\n    \"\"\"\n    Convert Series from DatetimeIndex to PeriodIndex with desired\n    frequency (inferred from index if not passed).\n\n    Parameters\n    ----------\n    freq : str, default None\n        Frequency associated with the PeriodIndex.\n    copy : bool, default True\n        Whether or not to return a copy.\n\n    Returns\n    -------\n    Series\n        Series with index converted to PeriodIndex.\n    \"\"\"\n    new_values = self._values\n    if copy:\n        new_values = new_values.copy()\n    assert isinstance(self.index, ABCDatetimeIndex)\n    new_index = self.index.to_period(freq=freq)\n    return self._constructor(new_values, index=new_index).__finalize__(self)",
                            "def f(x):\n    return func(x, *args, **kwds)"
                        ],
                        "constructor_variables": [
                            "self.name = name"
                        ],
                        "class_level_variables": [
                            "_typ = 'series'",
                            "_name: Optional[Hashable]",
                            "_metadata: List[str] = ['name']",
                            "_internal_names_set = {'index'} | generic.NDFrame._internal_names_set",
                            "_accessors = {'dt', 'cat', 'str', 'sparse'}",
                            "_deprecations = base.IndexOpsMixin._deprecations | generic.NDFrame._deprecations | frozenset(['compress', 'ptp'])",
                            "hasnans = property(base.IndexOpsMixin.hasnans.func, doc=base.IndexOpsMixin.hasnans.__doc__)",
                            "_data: SingleBlockManager",
                            "div: Callable[['Series', Any], 'Series']",
                            "rdiv: Callable[['Series', Any], 'Series']",
                            "_index = None",
                            "_HANDLED_TYPES = (Index, ExtensionArray, np.ndarray)",
                            "__float__ = _coerce_method(float)",
                            "__long__ = _coerce_method(int)",
                            "__int__ = _coerce_method(int)",
                            "_agg_see_also_doc = dedent('\\n    See Also\\n    --------\\n    Series.apply : Invoke function on a Series.\\n    Series.transform : Transform function producing a Series with like indexes.\\n    ')",
                            "_agg_examples_doc = dedent(\"\\n    Examples\\n    --------\\n    >>> s = pd.Series([1, 2, 3, 4])\\n    >>> s\\n    0    1\\n    1    2\\n    2    3\\n    3    4\\n    dtype: int64\\n\\n    >>> s.agg('min')\\n    1\\n\\n    >>> s.agg(['min', 'max'])\\n    min   1\\n    max   4\\n    dtype: int64\\n    \")",
                            "agg = aggregate",
                            "index: 'Index' = properties.AxisProperty(axis=0, doc='The index (axis labels) of the Series.')",
                            "str = CachedAccessor('str', StringMethods)",
                            "dt = CachedAccessor('dt', CombinedDatetimelikeProperties)",
                            "cat = CachedAccessor('cat', CategoricalAccessor)",
                            "plot = CachedAccessor('plot', pandas.plotting.PlotAccessor)",
                            "sparse = CachedAccessor('sparse', SparseAccessor)",
                            "hist = pandas.plotting.hist_series"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "__init__(self, data=None, index=None, dtype=None, name=None, copy=False, fastpath=False)",
                            "_init_dict(self, data, index=None, dtype=None)",
                            "_constructor(self) -> Type['Series']",
                            "_constructor_expanddim(self) -> Type['DataFrame']",
                            "_can_hold_na(self)",
                            "_set_axis(self, axis, labels, fastpath: bool=False) -> None",
                            "_update_inplace(self, result, **kwargs)",
                            "dtype(self)",
                            "dtypes(self)",
                            "name(self) -> Optional[Hashable]",
                            "name(self, value: Optional[Hashable]) -> None",
                            "values(self)",
                            "_values(self)",
                            "array(self) -> ExtensionArray",
                            "_internal_get_values(self)",
                            "ravel(self, order='C')",
                            "__len__(self) -> int",
                            "view(self, dtype=None) -> 'Series'",
                            "__array_ufunc__(self, ufunc: Callable, method: str, *inputs: Any, **kwargs: Any)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "axes(self) -> List[Index]",
                            "take(self, indices, axis=0, is_copy=None, **kwargs) -> 'Series'",
                            "_take_with_is_copy(self, indices, axis=0, **kwargs)",
                            "_ixs(self, i: int, axis: int=0)",
                            "_slice(self, slobj: slice, axis: int=0, kind: str='getitem') -> 'Series'",
                            "__getitem__(self, key)",
                            "_get_with(self, key)",
                            "_get_values_tuple(self, key)",
                            "_get_values(self, indexer)",
                            "_get_value(self, label, takeable: bool=False)",
                            "__setitem__(self, key, value)",
                            "_set_with_engine(self, key, value)",
                            "_set_with(self, key, value)",
                            "_set_labels(self, key, value)",
                            "_set_values(self, key, value)",
                            "_set_value(self, label, value, takeable: bool=False)",
                            "_is_mixed_type(self)",
                            "repeat(self, repeats, axis=None) -> 'Series'",
                            "reset_index(self, level=None, drop=False, name=None, inplace=False)",
                            "__repr__(self) -> str",
                            "to_string(self, buf=None, na_rep='NaN', float_format=None, header=True, index=True, length=False, dtype=False, name=False, max_rows=None, min_rows=None)",
                            "to_markdown(self, buf: Optional[IO[str]]=None, mode: Optional[str]=None, **kwargs) -> Optional[str]",
                            "items(self) -> Iterable[Tuple[Label, Any]]",
                            "iteritems(self) -> Iterable[Tuple[Label, Any]]",
                            "keys(self) -> Index",
                            "to_dict(self, into=dict)",
                            "to_frame(self, name=None) -> 'DataFrame'",
                            "_set_name(self, name, inplace=False) -> 'Series'",
                            "groupby(self, by=None, axis=0, level=None, as_index: bool=True, sort: bool=True, group_keys: bool=True, squeeze: bool=False, observed: bool=False) -> 'SeriesGroupBy'",
                            "count(self, level=None)",
                            "mode(self, dropna=True) -> 'Series'",
                            "unique(self)",
                            "drop_duplicates(self, keep='first', inplace=False) -> 'Series'",
                            "duplicated(self, keep='first') -> 'Series'",
                            "idxmin(self, axis=0, skipna=True, *args, **kwargs)",
                            "idxmax(self, axis=0, skipna=True, *args, **kwargs)",
                            "round(self, decimals=0, *args, **kwargs) -> 'Series'",
                            "quantile(self, q=0.5, interpolation='linear')",
                            "corr(self, other, method='pearson', min_periods=None) -> float",
                            "cov(self, other, min_periods=None) -> float",
                            "diff(self, periods=1) -> 'Series'",
                            "autocorr(self, lag=1) -> float",
                            "dot(self, other)",
                            "__matmul__(self, other)",
                            "__rmatmul__(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "append(self, to_append, ignore_index=False, verify_integrity=False)",
                            "_binop(self, other, func, level=None, fill_value=None)",
                            "combine(self, other, func, fill_value=None) -> 'Series'",
                            "combine_first(self, other) -> 'Series'",
                            "update(self, other) -> None",
                            "sort_values(self, axis=0, ascending=True, inplace: bool=False, kind: str='quicksort', na_position: str='last', ignore_index: bool=False)",
                            "sort_index(self, axis=0, level=None, ascending=True, inplace=False, kind='quicksort', na_position='last', sort_remaining=True, ignore_index: bool=False)",
                            "argsort(self, axis=0, kind='quicksort', order=None) -> 'Series'",
                            "nlargest(self, n=5, keep='first') -> 'Series'",
                            "nsmallest(self, n=5, keep='first') -> 'Series'",
                            "swaplevel(self, i=-2, j=-1, copy=True) -> 'Series'",
                            "reorder_levels(self, order) -> 'Series'",
                            "explode(self) -> 'Series'",
                            "unstack(self, level=-1, fill_value=None)",
                            "map(self, arg, na_action=None) -> 'Series'",
                            "_gotitem(self, key, ndim, subset=None) -> 'Series'",
                            "aggregate(self, func, axis=0, *args, **kwargs)",
                            "transform(self, func, axis=0, *args, **kwargs)",
                            "apply(self, func, convert_dtype=True, args=(), **kwds)",
                            "_reduce(self, op, name, axis=0, skipna=True, numeric_only=None, filter_type=None, **kwds)",
                            "_reindex_indexer(self, new_index, indexer, copy)",
                            "_needs_reindex_multi(self, axes, method, level)",
                            "align(self, other, join='outer', axis=None, level=None, copy=True, fill_value=None, method=None, limit=None, fill_axis=0, broadcast_axis=None)",
                            "rename(self, index=None)",
                            "set_axis(self, labels, axis=0, inplace=False)",
                            "reindex(self, index=None, **kwargs)",
                            "drop(self, labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors='raise') -> 'Series'",
                            "fillna(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None) -> Optional['Series']",
                            "replace(self, to_replace=None, value=None, inplace=False, limit=None, regex=False, method='pad')",
                            "shift(self, periods=1, freq=None, axis=0, fill_value=None) -> 'Series'",
                            "memory_usage(self, index=True, deep=False)",
                            "isin(self, values) -> 'Series'",
                            "between(self, left, right, inclusive=True) -> 'Series'",
                            "_convert_dtypes(self: ABCSeries, infer_objects: bool=True, convert_string: bool=True, convert_integer: bool=True, convert_boolean: bool=True) -> 'Series'",
                            "isna(self) -> 'Series'",
                            "isnull(self) -> 'Series'",
                            "notna(self) -> 'Series'",
                            "notnull(self) -> 'Series'",
                            "dropna(self, axis=0, inplace=False, how=None)",
                            "to_timestamp(self, freq=None, how='start', copy=True) -> 'Series'",
                            "to_period(self, freq=None, copy=True) -> 'Series'",
                            "f(x)"
                        ],
                        "class_level_variable_names": [
                            "_typ",
                            "_name",
                            "_metadata",
                            "_internal_names_set",
                            "_accessors",
                            "_deprecations",
                            "hasnans",
                            "_data",
                            "div",
                            "rdiv",
                            "_index",
                            "_HANDLED_TYPES",
                            "__float__",
                            "__long__",
                            "__int__",
                            "_agg_see_also_doc",
                            "_agg_examples_doc",
                            "agg",
                            "index",
                            "str",
                            "dt",
                            "cat",
                            "plot",
                            "sparse",
                            "hist"
                        ],
                        "constructor_variable_names": [
                            "copy",
                            "name",
                            "dtype",
                            "data",
                            "index"
                        ]
                    },
                    "used_imports": [
                        "import numpy as np",
                        "from pandas._libs import lib, properties, reshape, tslibs",
                        "from pandas.core.dtypes.generic import ABCDataFrame, ABCDatetimeIndex, ABCMultiIndex, ABCPeriodIndex, ABCSeries, ABCSparseArray",
                        "from pandas.core.indexes.api import Float64Index, Index, IntervalIndex, InvalidIndexError, MultiIndex, ensure_index"
                    ],
                    "variable_values": [
                        [
                            {
                                "key": {
                                    "variable_value": "array([[[2, 0],\n        [2, 2]],\n\n       [[0, 0],\n        [2, 2]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Int64Index([0, 1, 2, 3, 4], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f502274b680>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f502274b680>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "key": {
                                    "variable_value": "array([[[2, 0],\n        [2, 2]],\n\n       [[0, 0],\n        [2, 2]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": "'integer'",
                                    "variable_type": "str",
                                    "variable_shape": "7"
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Int64Index([0, 1, 2, 3, 4], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f502274b6d0>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f502274b6d0>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "key": {
                                    "variable_value": "array([[[4, 4],\n        [1, 0]],\n\n       [[2, 0],\n        [3, 2]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of -364186.078004    0\n-228750.058181    1\n-85715.528700     2\n-80499.698854     3\n 95633.356022     4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "-364186.078004    0\n-228750.058181    1\n-85715.528700     2\n-80499.698854     3\n 95633.356022     4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of -364186.078004    0\n-228750.058181    1\n-85715.528700     2\n-80499.698854     3\n 95633.356022     4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of -364186.078004    0\n-228750.058181    1\n-85715.528700     2\n-80499.698854     3\n 95633.356022     4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Float64Index([ -364186.0780037346, -228750.05818088824,  -85715.52870009924,\n               -80499.69885351516,   95633.35602178646],\n             dtype='float64')",
                                    "variable_type": "Float64Index",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f502274bb30>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f502274bb30>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of -364186.078004    0\n-228750.058181    1\n-85715.528700     2\n-80499.698854     3\n 95633.356022     4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "key": {
                                    "variable_value": "array([[[4, 4],\n        [1, 0]],\n\n       [[2, 0],\n        [3, 2]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of -364186.078004    0\n-228750.058181    1\n-85715.528700     2\n-80499.698854     3\n 95633.356022     4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "-364186.078004    0\n-228750.058181    1\n-85715.528700     2\n-80499.698854     3\n 95633.356022     4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of -364186.078004    0\n-228750.058181    1\n-85715.528700     2\n-80499.698854     3\n 95633.356022     4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of -364186.078004    0\n-228750.058181    1\n-85715.528700     2\n-80499.698854     3\n 95633.356022     4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": "'integer'",
                                    "variable_type": "str",
                                    "variable_shape": "7"
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Float64Index([ -364186.0780037346, -228750.05818088824,  -85715.52870009924,\n               -80499.69885351516,   95633.35602178646],\n             dtype='float64')",
                                    "variable_type": "Float64Index",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f502274b630>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f502274b630>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of -364186.078004    0\n-228750.058181    1\n-85715.528700     2\n-80499.698854     3\n 95633.356022     4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "key": {
                                    "variable_value": "array([[[0, 2],\n        [2, 2]],\n\n       [[3, 3],\n        [3, 4]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of l1LhtIu9zz    0\nWes3NLDQK7    1\nrQB4IX6cgD    2\nwSbtFB8shh    3\nBhIz6Xwzyb    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "l1LhtIu9zz    0\nWes3NLDQK7    1\nrQB4IX6cgD    2\nwSbtFB8shh    3\nBhIz6Xwzyb    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of l1LhtIu9zz    0\nWes3NLDQK7    1\nrQB4IX6cgD    2\nwSbtFB8shh    3\nBhIz6Xwzyb    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of l1LhtIu9zz    0\nWes3NLDQK7    1\nrQB4IX6cgD    2\nwSbtFB8shh    3\nBhIz6Xwzyb    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Index(['l1LhtIu9zz', 'Wes3NLDQK7', 'rQB4IX6cgD', 'wSbtFB8shh', 'BhIz6Xwzyb'], dtype='object')",
                                    "variable_type": "Index",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f502274bef0>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f502274bef0>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of l1LhtIu9zz    0\nWes3NLDQK7    1\nrQB4IX6cgD    2\nwSbtFB8shh    3\nBhIz6Xwzyb    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "key": {
                                    "variable_value": "array([[[0, 2],\n        [2, 2]],\n\n       [[3, 3],\n        [3, 4]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of l1LhtIu9zz    0\nWes3NLDQK7    1\nrQB4IX6cgD    2\nwSbtFB8shh    3\nBhIz6Xwzyb    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "l1LhtIu9zz    0\nWes3NLDQK7    1\nrQB4IX6cgD    2\nwSbtFB8shh    3\nBhIz6Xwzyb    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of l1LhtIu9zz    0\nWes3NLDQK7    1\nrQB4IX6cgD    2\nwSbtFB8shh    3\nBhIz6Xwzyb    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of l1LhtIu9zz    0\nWes3NLDQK7    1\nrQB4IX6cgD    2\nwSbtFB8shh    3\nBhIz6Xwzyb    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": "'integer'",
                                    "variable_type": "str",
                                    "variable_shape": "7"
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Index(['l1LhtIu9zz', 'Wes3NLDQK7', 'rQB4IX6cgD', 'wSbtFB8shh', 'BhIz6Xwzyb'], dtype='object')",
                                    "variable_type": "Index",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f502274b900>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f502274b900>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of l1LhtIu9zz    0\nWes3NLDQK7    1\nrQB4IX6cgD    2\nwSbtFB8shh    3\nBhIz6Xwzyb    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "key": {
                                    "variable_value": "array([[[2, 4],\n        [0, 0]],\n\n       [[0, 1],\n        [3, 3]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of \u05d2\u05e0\u05e2\u05d2\u05d3\u05de\u05d3\u05d3\u05dc\u05da    0\n\u05d6\u05d0\u05e7\u05d9\u05e2\u05d13\u05e0\u05e54    1\n\u05d7\u05e56\u05d01\u05e5\u05e9\u05e8\u05e2\u05d4    2\n4\u05d7\u05dd\u05e23\u05d8\u05dc8\u05d6\u05d0    3\n\u05d822\u05e2\u05d9\u05de\u05d9\u05e7\u05d0\u05e4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "\u05d2\u05e0\u05e2\u05d2\u05d3\u05de\u05d3\u05d3\u05dc\u05da    0\n\u05d6\u05d0\u05e7\u05d9\u05e2\u05d13\u05e0\u05e54    1\n\u05d7\u05e56\u05d01\u05e5\u05e9\u05e8\u05e2\u05d4    2\n4\u05d7\u05dd\u05e23\u05d8\u05dc8\u05d6\u05d0    3\n\u05d822\u05e2\u05d9\u05de\u05d9\u05e7\u05d0\u05e4    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of \u05d2\u05e0\u05e2\u05d2\u05d3\u05de\u05d3\u05d3\u05dc\u05da    0\n\u05d6\u05d0\u05e7\u05d9\u05e2\u05d13\u05e0\u05e54    1\n\u05d7\u05e56\u05d01\u05e5\u05e9\u05e8\u05e2\u05d4    2\n4\u05d7\u05dd\u05e23\u05d8\u05dc8\u05d6\u05d0    3\n\u05d822\u05e2\u05d9\u05de\u05d9\u05e7\u05d0\u05e4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of \u05d2\u05e0\u05e2\u05d2\u05d3\u05de\u05d3\u05d3\u05dc\u05da    0\n\u05d6\u05d0\u05e7\u05d9\u05e2\u05d13\u05e0\u05e54    1\n\u05d7\u05e56\u05d01\u05e5\u05e9\u05e8\u05e2\u05d4    2\n4\u05d7\u05dd\u05e23\u05d8\u05dc8\u05d6\u05d0    3\n\u05d822\u05e2\u05d9\u05de\u05d9\u05e7\u05d0\u05e4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Index(['\u05d2\u05e0\u05e2\u05d2\u05d3\u05de\u05d3\u05d3\u05dc\u05da', '\u05d6\u05d0\u05e7\u05d9\u05e2\u05d13\u05e0\u05e54', '\u05d7\u05e56\u05d01\u05e5\u05e9\u05e8\u05e2\u05d4', '4\u05d7\u05dd\u05e23\u05d8\u05dc8\u05d6\u05d0', '\u05d822\u05e2\u05d9\u05de\u05d9\u05e7\u05d0\u05e4'], dtype='object')",
                                    "variable_type": "Index",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f50227a29a0>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f50227a29a0>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of \u05d2\u05e0\u05e2\u05d2\u05d3\u05de\u05d3\u05d3\u05dc\u05da    0\n\u05d6\u05d0\u05e7\u05d9\u05e2\u05d13\u05e0\u05e54    1\n\u05d7\u05e56\u05d01\u05e5\u05e9\u05e8\u05e2\u05d4    2\n4\u05d7\u05dd\u05e23\u05d8\u05dc8\u05d6\u05d0    3\n\u05d822\u05e2\u05d9\u05de\u05d9\u05e7\u05d0\u05e4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "key": {
                                    "variable_value": "array([[[2, 4],\n        [0, 0]],\n\n       [[0, 1],\n        [3, 3]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of \u05d2\u05e0\u05e2\u05d2\u05d3\u05de\u05d3\u05d3\u05dc\u05da    0\n\u05d6\u05d0\u05e7\u05d9\u05e2\u05d13\u05e0\u05e54    1\n\u05d7\u05e56\u05d01\u05e5\u05e9\u05e8\u05e2\u05d4    2\n4\u05d7\u05dd\u05e23\u05d8\u05dc8\u05d6\u05d0    3\n\u05d822\u05e2\u05d9\u05de\u05d9\u05e7\u05d0\u05e4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "\u05d2\u05e0\u05e2\u05d2\u05d3\u05de\u05d3\u05d3\u05dc\u05da    0\n\u05d6\u05d0\u05e7\u05d9\u05e2\u05d13\u05e0\u05e54    1\n\u05d7\u05e56\u05d01\u05e5\u05e9\u05e8\u05e2\u05d4    2\n4\u05d7\u05dd\u05e23\u05d8\u05dc8\u05d6\u05d0    3\n\u05d822\u05e2\u05d9\u05de\u05d9\u05e7\u05d0\u05e4    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of \u05d2\u05e0\u05e2\u05d2\u05d3\u05de\u05d3\u05d3\u05dc\u05da    0\n\u05d6\u05d0\u05e7\u05d9\u05e2\u05d13\u05e0\u05e54    1\n\u05d7\u05e56\u05d01\u05e5\u05e9\u05e8\u05e2\u05d4    2\n4\u05d7\u05dd\u05e23\u05d8\u05dc8\u05d6\u05d0    3\n\u05d822\u05e2\u05d9\u05de\u05d9\u05e7\u05d0\u05e4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of \u05d2\u05e0\u05e2\u05d2\u05d3\u05de\u05d3\u05d3\u05dc\u05da    0\n\u05d6\u05d0\u05e7\u05d9\u05e2\u05d13\u05e0\u05e54    1\n\u05d7\u05e56\u05d01\u05e5\u05e9\u05e8\u05e2\u05d4    2\n4\u05d7\u05dd\u05e23\u05d8\u05dc8\u05d6\u05d0    3\n\u05d822\u05e2\u05d9\u05de\u05d9\u05e7\u05d0\u05e4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": "'integer'",
                                    "variable_type": "str",
                                    "variable_shape": "7"
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Index(['\u05d2\u05e0\u05e2\u05d2\u05d3\u05de\u05d3\u05d3\u05dc\u05da', '\u05d6\u05d0\u05e7\u05d9\u05e2\u05d13\u05e0\u05e54', '\u05d7\u05e56\u05d01\u05e5\u05e9\u05e8\u05e2\u05d4', '4\u05d7\u05dd\u05e23\u05d8\u05dc8\u05d6\u05d0', '\u05d822\u05e2\u05d9\u05de\u05d9\u05e7\u05d0\u05e4'], dtype='object')",
                                    "variable_type": "Index",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f50227ae130>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f50227ae130>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of \u05d2\u05e0\u05e2\u05d2\u05d3\u05de\u05d3\u05d3\u05dc\u05da    0\n\u05d6\u05d0\u05e7\u05d9\u05e2\u05d13\u05e0\u05e54    1\n\u05d7\u05e56\u05d01\u05e5\u05e9\u05e8\u05e2\u05d4    2\n4\u05d7\u05dd\u05e23\u05d8\u05dc8\u05d6\u05d0    3\n\u05d822\u05e2\u05d9\u05de\u05d9\u05e7\u05d0\u05e4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "key": {
                                    "variable_value": "array([[[1, 1],\n        [2, 2]],\n\n       [[2, 3],\n        [0, 2]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "DatetimeIndex(['2000-01-03', '2000-01-04', '2000-01-05', '2000-01-06',\n               '2000-01-07'],\n              dtype='datetime64[ns]', freq='B')",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f502283b0e0>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f502283b0e0>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "key": {
                                    "variable_value": "array([[[1, 1],\n        [2, 2]],\n\n       [[2, 3],\n        [0, 2]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": "'integer'",
                                    "variable_type": "str",
                                    "variable_shape": "7"
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "DatetimeIndex(['2000-01-03', '2000-01-04', '2000-01-05', '2000-01-06',\n               '2000-01-07'],\n              dtype='datetime64[ns]', freq='B')",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f50227d3b30>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f50227d3b30>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "key": {
                                    "variable_value": "array([[[3, 3],\n        [0, 1]],\n\n       [[3, 0],\n        [3, 0]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "PeriodIndex(['2000-01-03', '2000-01-04', '2000-01-05', '2000-01-06',\n             '2000-01-07'],\n            dtype='period[B]', freq='B')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f5022672400>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f5022672400>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "key": {
                                    "variable_value": "array([[[3, 3],\n        [0, 1]],\n\n       [[3, 0],\n        [3, 0]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": "'integer'",
                                    "variable_type": "str",
                                    "variable_shape": "7"
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "PeriodIndex(['2000-01-03', '2000-01-04', '2000-01-05', '2000-01-06',\n             '2000-01-07'],\n            dtype='period[B]', freq='B')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f5022871540>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f5022871540>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "key": {
                                    "variable_value": "array([[[4, 0],\n        [3, 4]],\n\n       [[4, 0],\n        [4, 0]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of 1 days    0\n2 days    1\n3 days    2\n4 days    3\n5 days    4\nFreq: D, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "1 days    0\n2 days    1\n3 days    2\n4 days    3\n5 days    4\nFreq: D, dtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of 1 days    0\n2 days    1\n3 days    2\n4 days    3\n5 days    4\nFreq: D, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of 1 days    0\n2 days    1\n3 days    2\n4 days    3\n5 days    4\nFreq: D, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "TimedeltaIndex(['1 days', '2 days', '3 days', '4 days', '5 days'], dtype='timedelta64[ns]', freq='D')",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f5022471cc0>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f5022471cc0>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of 1 days    0\n2 days    1\n3 days    2\n4 days    3\n5 days    4\nFreq: D, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "key": {
                                    "variable_value": "array([[[4, 0],\n        [3, 4]],\n\n       [[4, 0],\n        [4, 0]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of 1 days    0\n2 days    1\n3 days    2\n4 days    3\n5 days    4\nFreq: D, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "1 days    0\n2 days    1\n3 days    2\n4 days    3\n5 days    4\nFreq: D, dtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of 1 days    0\n2 days    1\n3 days    2\n4 days    3\n5 days    4\nFreq: D, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of 1 days    0\n2 days    1\n3 days    2\n4 days    3\n5 days    4\nFreq: D, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": "'integer'",
                                    "variable_type": "str",
                                    "variable_shape": "7"
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "TimedeltaIndex(['1 days', '2 days', '3 days', '4 days', '5 days'], dtype='timedelta64[ns]', freq='D')",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f50227d3b30>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f50227d3b30>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of 1 days    0\n2 days    1\n3 days    2\n4 days    3\n5 days    4\nFreq: D, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "key": {
                                    "variable_value": "array([[[3, 2],\n        [4, 1]],\n\n       [[0, 0],\n        [1, 0]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of False    0\nTrue     1\nFalse    2\nFalse    3\nFalse    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "False    0\nTrue     1\nFalse    2\nFalse    3\nFalse    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of False    0\nTrue     1\nFalse    2\nFalse    3\nFalse    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of False    0\nTrue     1\nFalse    2\nFalse    3\nFalse    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Index([False, True, False, False, False], dtype='object')",
                                    "variable_type": "Index",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f5022471a90>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f5022471a90>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of False    0\nTrue     1\nFalse    2\nFalse    3\nFalse    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "key": {
                                    "variable_value": "array([[[3, 2],\n        [4, 1]],\n\n       [[0, 0],\n        [1, 0]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of False    0\nTrue     1\nFalse    2\nFalse    3\nFalse    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "False    0\nTrue     1\nFalse    2\nFalse    3\nFalse    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of False    0\nTrue     1\nFalse    2\nFalse    3\nFalse    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of False    0\nTrue     1\nFalse    2\nFalse    3\nFalse    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": "'integer'",
                                    "variable_type": "str",
                                    "variable_shape": "7"
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Index([False, True, False, False, False], dtype='object')",
                                    "variable_type": "Index",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f5022471590>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f5022471590>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of False    0\nTrue     1\nFalse    2\nFalse    3\nFalse    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "key": {
                                    "variable_value": "array([[[4, 2],\n        [1, 1]],\n\n       [[2, 1],\n        [3, 3]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "RangeIndex(start=0, stop=5, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f50224719f0>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f50224719f0>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "key": {
                                    "variable_value": "array([[[4, 2],\n        [1, 1]],\n\n       [[2, 1],\n        [3, 3]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": "'integer'",
                                    "variable_type": "str",
                                    "variable_shape": "7"
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "RangeIndex(start=0, stop=5, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f5022471a90>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f5022471a90>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "key": {
                                    "variable_value": "array([[[3, 2],\n        [1, 0]],\n\n       [[2, 4],\n        [3, 0]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of GML1    0\n4Q90    1\nLLwN    2\nGML1    3\n4Q90    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "GML1    0\n4Q90    1\nLLwN    2\nGML1    3\n4Q90    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of GML1    0\n4Q90    1\nLLwN    2\nGML1    3\n4Q90    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of GML1    0\n4Q90    1\nLLwN    2\nGML1    3\n4Q90    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "CategoricalIndex(['GML1', '4Q90', 'LLwN', 'GML1', '4Q90'], categories=['GML1', '4Q90', 'LLwN'], ordered=False, dtype='category')",
                                    "variable_type": "CategoricalIndex",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f5022790cc0>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f5022790cc0>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of GML1    0\n4Q90    1\nLLwN    2\nGML1    3\n4Q90    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "key": {
                                    "variable_value": "array([[[3, 2],\n        [1, 0]],\n\n       [[2, 4],\n        [3, 0]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of GML1    0\n4Q90    1\nLLwN    2\nGML1    3\n4Q90    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "GML1    0\n4Q90    1\nLLwN    2\nGML1    3\n4Q90    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of GML1    0\n4Q90    1\nLLwN    2\nGML1    3\n4Q90    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of GML1    0\n4Q90    1\nLLwN    2\nGML1    3\n4Q90    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": "'integer'",
                                    "variable_type": "str",
                                    "variable_shape": "7"
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "CategoricalIndex(['GML1', '4Q90', 'LLwN', 'GML1', '4Q90'], categories=['GML1', '4Q90', 'LLwN'], ordered=False, dtype='category')",
                                    "variable_type": "CategoricalIndex",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f50227ae180>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f50227ae180>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of GML1    0\n4Q90    1\nLLwN    2\nGML1    3\n4Q90    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "key": {
                                    "variable_value": "array([[[3, 0],\n        [2, 0]],\n\n       [[1, 3],\n        [1, 3]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Int64Index([0, 1, 2, 3, 4], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f6c03303e50>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f6c03303e50>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "key": {
                                    "variable_value": "array([[[3, 0],\n        [2, 0]],\n\n       [[1, 3],\n        [1, 3]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": "'integer'",
                                    "variable_type": "str",
                                    "variable_shape": "7"
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Int64Index([0, 1, 2, 3, 4], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f6c03170360>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f6c03170360>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "key": {
                                    "variable_value": "array([[[3, 3],\n        [2, 2]],\n\n       [[4, 1],\n        [3, 2]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of -2047.902406    0\n-1772.602965    1\n-1007.452414    2\n 4095.993715    3\n 5084.125019    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "-2047.902406    0\n-1772.602965    1\n-1007.452414    2\n 4095.993715    3\n 5084.125019    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of -2047.902406    0\n-1772.602965    1\n-1007.452414    2\n 4095.993715    3\n 5084.125019    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of -2047.902406    0\n-1772.602965    1\n-1007.452414    2\n 4095.993715    3\n 5084.125019    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Float64Index([ -2047.902406219898, -1772.6029654597041, -1007.4524138909225,\n                4095.993714666638,   5084.125019438894],\n             dtype='float64')",
                                    "variable_type": "Float64Index",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f6c03379540>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f6c03379540>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of -2047.902406    0\n-1772.602965    1\n-1007.452414    2\n 4095.993715    3\n 5084.125019    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "key": {
                                    "variable_value": "array([[[3, 3],\n        [2, 2]],\n\n       [[4, 1],\n        [3, 2]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of -2047.902406    0\n-1772.602965    1\n-1007.452414    2\n 4095.993715    3\n 5084.125019    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "-2047.902406    0\n-1772.602965    1\n-1007.452414    2\n 4095.993715    3\n 5084.125019    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of -2047.902406    0\n-1772.602965    1\n-1007.452414    2\n 4095.993715    3\n 5084.125019    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of -2047.902406    0\n-1772.602965    1\n-1007.452414    2\n 4095.993715    3\n 5084.125019    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": "'integer'",
                                    "variable_type": "str",
                                    "variable_shape": "7"
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Float64Index([ -2047.902406219898, -1772.6029654597041, -1007.4524138909225,\n                4095.993714666638,   5084.125019438894],\n             dtype='float64')",
                                    "variable_type": "Float64Index",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f6c031709f0>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f6c031709f0>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of -2047.902406    0\n-1772.602965    1\n-1007.452414    2\n 4095.993715    3\n 5084.125019    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "key": {
                                    "variable_value": "array([[[3, 4],\n        [4, 3]],\n\n       [[4, 4],\n        [2, 4]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of ZMzZqSEKOC    0\nWo8cxWL5T5    1\n6jlqxwloQO    2\nUqtIDnICXu    3\nbCTPNzSFAt    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "ZMzZqSEKOC    0\nWo8cxWL5T5    1\n6jlqxwloQO    2\nUqtIDnICXu    3\nbCTPNzSFAt    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of ZMzZqSEKOC    0\nWo8cxWL5T5    1\n6jlqxwloQO    2\nUqtIDnICXu    3\nbCTPNzSFAt    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of ZMzZqSEKOC    0\nWo8cxWL5T5    1\n6jlqxwloQO    2\nUqtIDnICXu    3\nbCTPNzSFAt    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Index(['ZMzZqSEKOC', 'Wo8cxWL5T5', '6jlqxwloQO', 'UqtIDnICXu', 'bCTPNzSFAt'], dtype='object')",
                                    "variable_type": "Index",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f6c03379d60>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f6c03379d60>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of ZMzZqSEKOC    0\nWo8cxWL5T5    1\n6jlqxwloQO    2\nUqtIDnICXu    3\nbCTPNzSFAt    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "key": {
                                    "variable_value": "array([[[3, 4],\n        [4, 3]],\n\n       [[4, 4],\n        [2, 4]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of ZMzZqSEKOC    0\nWo8cxWL5T5    1\n6jlqxwloQO    2\nUqtIDnICXu    3\nbCTPNzSFAt    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "ZMzZqSEKOC    0\nWo8cxWL5T5    1\n6jlqxwloQO    2\nUqtIDnICXu    3\nbCTPNzSFAt    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of ZMzZqSEKOC    0\nWo8cxWL5T5    1\n6jlqxwloQO    2\nUqtIDnICXu    3\nbCTPNzSFAt    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of ZMzZqSEKOC    0\nWo8cxWL5T5    1\n6jlqxwloQO    2\nUqtIDnICXu    3\nbCTPNzSFAt    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": "'integer'",
                                    "variable_type": "str",
                                    "variable_shape": "7"
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Index(['ZMzZqSEKOC', 'Wo8cxWL5T5', '6jlqxwloQO', 'UqtIDnICXu', 'bCTPNzSFAt'], dtype='object')",
                                    "variable_type": "Index",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f6c03170720>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f6c03170720>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of ZMzZqSEKOC    0\nWo8cxWL5T5    1\n6jlqxwloQO    2\nUqtIDnICXu    3\nbCTPNzSFAt    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "key": {
                                    "variable_value": "array([[[2, 1],\n        [0, 1]],\n\n       [[4, 2],\n        [1, 1]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of \u05e2\u05d37\u05d6\u05d9\u05d5\u05e6\u05e9\u05e7\u05df    0\n\u05da17\u05e052\u05e5\u05d5\u05d58    1\n553\u05d48\u05de\u05d358\u05d6    2\n\u05dc\u05d0\u05d8\u05e1\u05d37\u05df\u05d57\u05e2    3\n\u05d29\u05dc\u05e3\u05db7\u05d9\u05e9\u05e9\u05da    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "\u05e2\u05d37\u05d6\u05d9\u05d5\u05e6\u05e9\u05e7\u05df    0\n\u05da17\u05e052\u05e5\u05d5\u05d58    1\n553\u05d48\u05de\u05d358\u05d6    2\n\u05dc\u05d0\u05d8\u05e1\u05d37\u05df\u05d57\u05e2    3\n\u05d29\u05dc\u05e3\u05db7\u05d9\u05e9\u05e9\u05da    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of \u05e2\u05d37\u05d6\u05d9\u05d5\u05e6\u05e9\u05e7\u05df    0\n\u05da17\u05e052\u05e5\u05d5\u05d58    1\n553\u05d48\u05de\u05d358\u05d6    2\n\u05dc\u05d0\u05d8\u05e1\u05d37\u05df\u05d57\u05e2    3\n\u05d29\u05dc\u05e3\u05db7\u05d9\u05e9\u05e9\u05da    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of \u05e2\u05d37\u05d6\u05d9\u05d5\u05e6\u05e9\u05e7\u05df    0\n\u05da17\u05e052\u05e5\u05d5\u05d58    1\n553\u05d48\u05de\u05d358\u05d6    2\n\u05dc\u05d0\u05d8\u05e1\u05d37\u05df\u05d57\u05e2    3\n\u05d29\u05dc\u05e3\u05db7\u05d9\u05e9\u05e9\u05da    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Index(['\u05e2\u05d37\u05d6\u05d9\u05d5\u05e6\u05e9\u05e7\u05df', '\u05da17\u05e052\u05e5\u05d5\u05d58', '553\u05d48\u05de\u05d358\u05d6', '\u05dc\u05d0\u05d8\u05e1\u05d37\u05df\u05d57\u05e2', '\u05d29\u05dc\u05e3\u05db7\u05d9\u05e9\u05e9\u05da'], dtype='object')",
                                    "variable_type": "Index",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f6c03379540>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f6c03379540>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of \u05e2\u05d37\u05d6\u05d9\u05d5\u05e6\u05e9\u05e7\u05df    0\n\u05da17\u05e052\u05e5\u05d5\u05d58    1\n553\u05d48\u05de\u05d358\u05d6    2\n\u05dc\u05d0\u05d8\u05e1\u05d37\u05df\u05d57\u05e2    3\n\u05d29\u05dc\u05e3\u05db7\u05d9\u05e9\u05e9\u05da    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "key": {
                                    "variable_value": "array([[[2, 1],\n        [0, 1]],\n\n       [[4, 2],\n        [1, 1]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of \u05e2\u05d37\u05d6\u05d9\u05d5\u05e6\u05e9\u05e7\u05df    0\n\u05da17\u05e052\u05e5\u05d5\u05d58    1\n553\u05d48\u05de\u05d358\u05d6    2\n\u05dc\u05d0\u05d8\u05e1\u05d37\u05df\u05d57\u05e2    3\n\u05d29\u05dc\u05e3\u05db7\u05d9\u05e9\u05e9\u05da    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "\u05e2\u05d37\u05d6\u05d9\u05d5\u05e6\u05e9\u05e7\u05df    0\n\u05da17\u05e052\u05e5\u05d5\u05d58    1\n553\u05d48\u05de\u05d358\u05d6    2\n\u05dc\u05d0\u05d8\u05e1\u05d37\u05df\u05d57\u05e2    3\n\u05d29\u05dc\u05e3\u05db7\u05d9\u05e9\u05e9\u05da    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of \u05e2\u05d37\u05d6\u05d9\u05d5\u05e6\u05e9\u05e7\u05df    0\n\u05da17\u05e052\u05e5\u05d5\u05d58    1\n553\u05d48\u05de\u05d358\u05d6    2\n\u05dc\u05d0\u05d8\u05e1\u05d37\u05df\u05d57\u05e2    3\n\u05d29\u05dc\u05e3\u05db7\u05d9\u05e9\u05e9\u05da    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of \u05e2\u05d37\u05d6\u05d9\u05d5\u05e6\u05e9\u05e7\u05df    0\n\u05da17\u05e052\u05e5\u05d5\u05d58    1\n553\u05d48\u05de\u05d358\u05d6    2\n\u05dc\u05d0\u05d8\u05e1\u05d37\u05df\u05d57\u05e2    3\n\u05d29\u05dc\u05e3\u05db7\u05d9\u05e9\u05e9\u05da    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": "'integer'",
                                    "variable_type": "str",
                                    "variable_shape": "7"
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Index(['\u05e2\u05d37\u05d6\u05d9\u05d5\u05e6\u05e9\u05e7\u05df', '\u05da17\u05e052\u05e5\u05d5\u05d58', '553\u05d48\u05de\u05d358\u05d6', '\u05dc\u05d0\u05d8\u05e1\u05d37\u05df\u05d57\u05e2', '\u05d29\u05dc\u05e3\u05db7\u05d9\u05e9\u05e9\u05da'], dtype='object')",
                                    "variable_type": "Index",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f6c03379220>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f6c03379220>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of \u05e2\u05d37\u05d6\u05d9\u05d5\u05e6\u05e9\u05e7\u05df    0\n\u05da17\u05e052\u05e5\u05d5\u05d58    1\n553\u05d48\u05de\u05d358\u05d6    2\n\u05dc\u05d0\u05d8\u05e1\u05d37\u05df\u05d57\u05e2    3\n\u05d29\u05dc\u05e3\u05db7\u05d9\u05e9\u05e9\u05da    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "key": {
                                    "variable_value": "array([[[0, 3],\n        [4, 2]],\n\n       [[4, 0],\n        [3, 2]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "DatetimeIndex(['2000-01-03', '2000-01-04', '2000-01-05', '2000-01-06',\n               '2000-01-07'],\n              dtype='datetime64[ns]', freq='B')",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f6c03379900>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f6c03379900>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "key": {
                                    "variable_value": "array([[[0, 3],\n        [4, 2]],\n\n       [[4, 0],\n        [3, 2]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": "'integer'",
                                    "variable_type": "str",
                                    "variable_shape": "7"
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "DatetimeIndex(['2000-01-03', '2000-01-04', '2000-01-05', '2000-01-06',\n               '2000-01-07'],\n              dtype='datetime64[ns]', freq='B')",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f6c03379680>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f6c03379680>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "key": {
                                    "variable_value": "array([[[0, 3],\n        [0, 3]],\n\n       [[2, 1],\n        [1, 0]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "PeriodIndex(['2000-01-03', '2000-01-04', '2000-01-05', '2000-01-06',\n             '2000-01-07'],\n            dtype='period[B]', freq='B')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f6c0311a1d0>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f6c0311a1d0>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "key": {
                                    "variable_value": "array([[[0, 3],\n        [0, 3]],\n\n       [[2, 1],\n        [1, 0]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": "'integer'",
                                    "variable_type": "str",
                                    "variable_shape": "7"
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "PeriodIndex(['2000-01-03', '2000-01-04', '2000-01-05', '2000-01-06',\n             '2000-01-07'],\n            dtype='period[B]', freq='B')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f6c033792c0>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f6c033792c0>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "key": {
                                    "variable_value": "array([[[0, 0],\n        [2, 2]],\n\n       [[3, 3],\n        [3, 2]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of 1 days    0\n2 days    1\n3 days    2\n4 days    3\n5 days    4\nFreq: D, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "1 days    0\n2 days    1\n3 days    2\n4 days    3\n5 days    4\nFreq: D, dtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of 1 days    0\n2 days    1\n3 days    2\n4 days    3\n5 days    4\nFreq: D, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of 1 days    0\n2 days    1\n3 days    2\n4 days    3\n5 days    4\nFreq: D, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "TimedeltaIndex(['1 days', '2 days', '3 days', '4 days', '5 days'], dtype='timedelta64[ns]', freq='D')",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f6c0311a8b0>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f6c0311a8b0>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of 1 days    0\n2 days    1\n3 days    2\n4 days    3\n5 days    4\nFreq: D, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "key": {
                                    "variable_value": "array([[[0, 0],\n        [2, 2]],\n\n       [[3, 3],\n        [3, 2]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of 1 days    0\n2 days    1\n3 days    2\n4 days    3\n5 days    4\nFreq: D, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "1 days    0\n2 days    1\n3 days    2\n4 days    3\n5 days    4\nFreq: D, dtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of 1 days    0\n2 days    1\n3 days    2\n4 days    3\n5 days    4\nFreq: D, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of 1 days    0\n2 days    1\n3 days    2\n4 days    3\n5 days    4\nFreq: D, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": "'integer'",
                                    "variable_type": "str",
                                    "variable_shape": "7"
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "TimedeltaIndex(['1 days', '2 days', '3 days', '4 days', '5 days'], dtype='timedelta64[ns]', freq='D')",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f6c0311a2c0>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f6c0311a2c0>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of 1 days    0\n2 days    1\n3 days    2\n4 days    3\n5 days    4\nFreq: D, dtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "key": {
                                    "variable_value": "array([[[1, 0],\n        [4, 3]],\n\n       [[2, 2],\n        [0, 1]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of False    0\nTrue     1\nFalse    2\nFalse    3\nFalse    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "False    0\nTrue     1\nFalse    2\nFalse    3\nFalse    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of False    0\nTrue     1\nFalse    2\nFalse    3\nFalse    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of False    0\nTrue     1\nFalse    2\nFalse    3\nFalse    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Index([False, True, False, False, False], dtype='object')",
                                    "variable_type": "Index",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f6c0311aef0>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f6c0311aef0>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of False    0\nTrue     1\nFalse    2\nFalse    3\nFalse    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "key": {
                                    "variable_value": "array([[[1, 0],\n        [4, 3]],\n\n       [[2, 2],\n        [0, 1]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of False    0\nTrue     1\nFalse    2\nFalse    3\nFalse    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "False    0\nTrue     1\nFalse    2\nFalse    3\nFalse    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of False    0\nTrue     1\nFalse    2\nFalse    3\nFalse    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of False    0\nTrue     1\nFalse    2\nFalse    3\nFalse    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": "'integer'",
                                    "variable_type": "str",
                                    "variable_shape": "7"
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Index([False, True, False, False, False], dtype='object')",
                                    "variable_type": "Index",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f6c0311a590>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f6c0311a590>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of False    0\nTrue     1\nFalse    2\nFalse    3\nFalse    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "key": {
                                    "variable_value": "array([[[3, 0],\n        [4, 3]],\n\n       [[0, 3],\n        [1, 3]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "RangeIndex(start=0, stop=5, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f6c0311ae00>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f6c0311ae00>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "key": {
                                    "variable_value": "array([[[3, 0],\n        [4, 3]],\n\n       [[0, 3],\n        [1, 3]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": "'integer'",
                                    "variable_type": "str",
                                    "variable_shape": "7"
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "RangeIndex(start=0, stop=5, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f6c0311a3b0>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f6c0311a3b0>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of 0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "key": {
                                    "variable_value": "array([[[0, 2],\n        [0, 1]],\n\n       [[4, 1],\n        [2, 3]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of foD2    0\nlkwo    1\ndUCX    2\nfoD2    3\nlkwo    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "foD2    0\nlkwo    1\ndUCX    2\nfoD2    3\nlkwo    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of foD2    0\nlkwo    1\ndUCX    2\nfoD2    3\nlkwo    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of foD2    0\nlkwo    1\ndUCX    2\nfoD2    3\nlkwo    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "CategoricalIndex(['foD2', 'lkwo', 'dUCX', 'foD2', 'lkwo'], categories=['foD2', 'lkwo', 'dUCX'], ordered=False, dtype='category')",
                                    "variable_type": "CategoricalIndex",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f6c03109c20>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f6c03109c20>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of foD2    0\nlkwo    1\ndUCX    2\nfoD2    3\nlkwo    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "key": {
                                    "variable_value": "array([[[0, 2],\n        [0, 1]],\n\n       [[4, 1],\n        [2, 3]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2, 2)"
                                },
                                "self._slice": {
                                    "variable_value": "<bound method Series._slice of foD2    0\nlkwo    1\ndUCX    2\nfoD2    3\nlkwo    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "foD2    0\nlkwo    1\ndUCX    2\nfoD2    3\nlkwo    4\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(5,)"
                                },
                                "ABCDataFrame": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_values_tuple": {
                                    "variable_value": "<bound method Series._get_values_tuple of foD2    0\nlkwo    1\ndUCX    2\nfoD2    3\nlkwo    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._get_values": {
                                    "variable_value": "<bound method Series._get_values of foD2    0\nlkwo    1\ndUCX    2\nfoD2    3\nlkwo    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key_type": {
                                    "variable_value": "'integer'",
                                    "variable_type": "str",
                                    "variable_shape": "7"
                                },
                                "key.inferred_type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.infer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.is_integer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "CategoricalIndex(['foD2', 'lkwo', 'dUCX', 'foD2', 'lkwo'], categories=['foD2', 'lkwo', 'dUCX'], ordered=False, dtype='category')",
                                    "variable_type": "CategoricalIndex",
                                    "variable_shape": "(5,)"
                                },
                                "self.index.is_floating": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.loc": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x7f6c0311f770>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.get_indexer_for": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x7f6c0311f770>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "self.reindex": {
                                    "variable_value": "<bound method Series.reindex of foD2    0\nlkwo    1\ndUCX    2\nfoD2    3\nlkwo    4\ndtype: int64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                }
            ],
            "inscope_functions": {
                "file_scope_functions": [
                    {
                        "code": "def _coerce_method(converter):\n    \"\"\"\n    Install the scalar coercion methods.\n    \"\"\"\n\n    def wrapper(self):\n        if len(self) == 1:\n            return converter(self.iloc[0])\n        raise TypeError(f\"cannot convert the series to {converter}\")\n\n    wrapper.__name__ = f\"__{converter.__name__}__\"\n    return wrapper",
                        "signature": "_coerce_method(converter)"
                    },
                    {
                        "code": "def f(x):\n    return func(x, *args, **kwds)",
                        "signature": "f(x)"
                    }
                ],
                "file_scope_classes": [
                    {
                        "class_declaration": "class Series:",
                        "functions": [
                            {
                                "code": "def __init__(\n    self, data=None, index=None, dtype=None, name=None, copy=False, fastpath=False\n):\n\n    # we are called internally, so short-circuit\n    if fastpath:\n\n        # data is an ndarray, index is defined\n        if not isinstance(data, SingleBlockManager):\n            data = SingleBlockManager(data, index, fastpath=True)\n        if copy:\n            data = data.copy()\n        if index is None:\n            index = data.index\n\n    else:\n\n        name = ibase.maybe_extract_name(name, data, type(self))\n\n        if is_empty_data(data) and dtype is None:\n            # gh-17261\n            warnings.warn(\n                \"The default dtype for empty Series will be 'object' instead \"\n                \"of 'float64' in a future version. Specify a dtype explicitly \"\n                \"to silence this warning.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            # uncomment the line below when removing the DeprecationWarning\n            # dtype = np.dtype(object)\n\n        if index is not None:\n            index = ensure_index(index)\n\n        if data is None:\n            data = {}\n        if dtype is not None:\n            dtype = self._validate_dtype(dtype)\n\n        if isinstance(data, MultiIndex):\n            raise NotImplementedError(\n                \"initializing a Series from a MultiIndex is not supported\"\n            )\n        elif isinstance(data, Index):\n\n            if dtype is not None:\n                # astype copies\n                data = data.astype(dtype)\n            else:\n                # need to copy to avoid aliasing issues\n                data = data._values.copy()\n                if isinstance(data, ABCDatetimeIndex) and data.tz is not None:\n                    # GH#24096 need copy to be deep for datetime64tz case\n                    # TODO: See if we can avoid these copies\n                    data = data._values.copy(deep=True)\n            copy = False\n\n        elif isinstance(data, np.ndarray):\n            if len(data.dtype):\n                # GH#13296 we are dealing with a compound dtype, which\n                #  should be treated as 2D\n                raise ValueError(\n                    \"Cannot construct a Series from an ndarray with \"\n                    \"compound dtype.  Use DataFrame instead.\"\n                )\n            pass\n        elif isinstance(data, ABCSeries):\n            if index is None:\n                index = data.index\n            else:\n                data = data.reindex(index, copy=copy)\n            data = data._data\n        elif is_dict_like(data):\n            data, index = self._init_dict(data, index, dtype)\n            dtype = None\n            copy = False\n        elif isinstance(data, SingleBlockManager):\n            if index is None:\n                index = data.index\n            elif not data.index.equals(index) or copy:\n                # GH#19275 SingleBlockManager input should only be called\n                # internally\n                raise AssertionError(\n                    \"Cannot pass both SingleBlockManager \"\n                    \"`data` argument and a different \"\n                    \"`index` argument. `copy` must be False.\"\n                )\n\n        elif is_extension_array_dtype(data):\n            pass\n        elif isinstance(data, (set, frozenset)):\n            raise TypeError(f\"'{type(data).__name__}' type is unordered\")\n        elif isinstance(data, ABCSparseArray):\n            # handle sparse passed here (and force conversion)\n            data = data.to_dense()\n        else:\n            data = com.maybe_iterable_to_list(data)\n\n        if index is None:\n            if not is_list_like(data):\n                data = [data]\n            index = ibase.default_index(len(data))\n        elif is_list_like(data):\n\n            # a scalar numpy array is list-like but doesn't\n            # have a proper length\n            try:\n                if len(index) != len(data):\n                    raise ValueError(\n                        f\"Length of passed values is {len(data)}, \"\n                        f\"index implies {len(index)}.\"\n                    )\n            except TypeError:\n                pass\n\n        # create/copy the manager\n        if isinstance(data, SingleBlockManager):\n            if dtype is not None:\n                data = data.astype(dtype=dtype, errors=\"ignore\", copy=copy)\n            elif copy:\n                data = data.copy()\n        else:\n            data = sanitize_array(data, index, dtype, copy, raise_cast_failure=True)\n\n            data = SingleBlockManager(data, index, fastpath=True)\n\n    generic.NDFrame.__init__(self, data, fastpath=True)\n    self.name = name\n    self._set_axis(0, index, fastpath=True)",
                                "signature": "__init__(self, data=None, index=None, dtype=None, name=None, copy=False, fastpath=False)"
                            },
                            {
                                "code": "def _init_dict(self, data, index=None, dtype=None):\n    \"\"\"\n    Derive the \"_data\" and \"index\" attributes of a new Series from a\n    dictionary input.\n\n    Parameters\n    ----------\n    data : dict or dict-like\n        Data used to populate the new Series.\n    index : Index or index-like, default None\n        Index for the new Series: if None, use dict keys.\n    dtype : dtype, default None\n        The dtype for the new Series: if None, infer from data.\n\n    Returns\n    -------\n    _data : BlockManager for the new Series\n    index : index for the new Series\n    \"\"\"\n    # Looking for NaN in dict doesn't work ({np.nan : 1}[float('nan')]\n    # raises KeyError), so we iterate the entire dict, and align\n    if data:\n        keys, values = zip(*data.items())\n        values = list(values)\n    elif index is not None:\n        # fastpath for Series(data=None). Just use broadcasting a scalar\n        # instead of reindexing.\n        values = na_value_for_dtype(dtype)\n        keys = index\n    else:\n        keys, values = [], []\n\n    # Input is now list-like, so rely on \"standard\" construction:\n\n    # TODO: passing np.float64 to not break anything yet. See GH-17261\n    s = create_series_with_explicit_dtype(\n        values, index=keys, dtype=dtype, dtype_if_empty=np.float64\n    )\n\n    # Now we just make sure the order is respected, if any\n    if data and index is not None:\n        s = s.reindex(index, copy=False)\n    return s._data, s.index",
                                "signature": "_init_dict(self, data, index=None, dtype=None)"
                            },
                            {
                                "code": "@property\ndef _constructor(self) -> Type[\"Series\"]:\n    return Series",
                                "signature": "_constructor(self) -> Type['Series']"
                            },
                            {
                                "code": "@property\ndef _constructor_expanddim(self) -> Type[\"DataFrame\"]:\n    from pandas.core.frame import DataFrame\n\n    return DataFrame",
                                "signature": "_constructor_expanddim(self) -> Type['DataFrame']"
                            },
                            {
                                "code": "@property\ndef _can_hold_na(self):\n    return self._data._can_hold_na",
                                "signature": "_can_hold_na(self)"
                            },
                            {
                                "code": "def _set_axis(self, axis, labels, fastpath: bool = False) -> None:\n    \"\"\"\n    Override generic, we want to set the _typ here.\n    \"\"\"\n\n    if not fastpath:\n        labels = ensure_index(labels)\n\n    is_all_dates = labels.is_all_dates\n    if is_all_dates:\n        if not isinstance(labels, (DatetimeIndex, PeriodIndex, TimedeltaIndex)):\n            try:\n                labels = DatetimeIndex(labels)\n                # need to set here because we changed the index\n                if fastpath:\n                    self._data.set_axis(axis, labels)\n            except (tslibs.OutOfBoundsDatetime, ValueError):\n                # labels may exceeds datetime bounds,\n                # or not be a DatetimeIndex\n                pass\n\n    object.__setattr__(self, \"_index\", labels)\n    if not fastpath:\n        self._data.set_axis(axis, labels)",
                                "signature": "_set_axis(self, axis, labels, fastpath: bool=False) -> None"
                            },
                            {
                                "code": "def _update_inplace(self, result, **kwargs):\n    # we want to call the generic version and not the IndexOpsMixin\n    return generic.NDFrame._update_inplace(self, result, **kwargs)",
                                "signature": "_update_inplace(self, result, **kwargs)"
                            },
                            {
                                "code": "@property\ndef dtype(self):\n    \"\"\"\n    Return the dtype object of the underlying data.\n    \"\"\"\n    return self._data.dtype",
                                "signature": "dtype(self)"
                            },
                            {
                                "code": "@property\ndef dtypes(self):\n    \"\"\"\n    Return the dtype object of the underlying data.\n    \"\"\"\n    return self._data.dtype",
                                "signature": "dtypes(self)"
                            },
                            {
                                "code": "@property\ndef name(self) -> Optional[Hashable]:\n    return self._name",
                                "signature": "name(self) -> Optional[Hashable]"
                            },
                            {
                                "code": "@name.setter\ndef name(self, value: Optional[Hashable]) -> None:\n    if not is_hashable(value):\n        raise TypeError(\"Series.name must be a hashable type\")\n    object.__setattr__(self, \"_name\", value)",
                                "signature": "name(self, value: Optional[Hashable]) -> None"
                            },
                            {
                                "code": "@property\ndef values(self):\n    \"\"\"\n    Return Series as ndarray or ndarray-like depending on the dtype.\n\n    .. warning::\n\n       We recommend using :attr:`Series.array` or\n       :meth:`Series.to_numpy`, depending on whether you need\n       a reference to the underlying data or a NumPy array.\n\n    Returns\n    -------\n    numpy.ndarray or ndarray-like\n\n    See Also\n    --------\n    Series.array : Reference to the underlying data.\n    Series.to_numpy : A NumPy array representing the underlying data.\n\n    Examples\n    --------\n    >>> pd.Series([1, 2, 3]).values\n    array([1, 2, 3])\n\n    >>> pd.Series(list('aabc')).values\n    array(['a', 'a', 'b', 'c'], dtype=object)\n\n    >>> pd.Series(list('aabc')).astype('category').values\n    [a, a, b, c]\n    Categories (3, object): [a, b, c]\n\n    Timezone aware datetime data is converted to UTC:\n\n    >>> pd.Series(pd.date_range('20130101', periods=3,\n    ...                         tz='US/Eastern')).values\n    array(['2013-01-01T05:00:00.000000000',\n           '2013-01-02T05:00:00.000000000',\n           '2013-01-03T05:00:00.000000000'], dtype='datetime64[ns]')\n    \"\"\"\n    return self._data.external_values()",
                                "signature": "values(self)"
                            },
                            {
                                "code": "@property\ndef _values(self):\n    \"\"\"\n    Return the internal repr of this data (defined by Block.interval_values).\n    This are the values as stored in the Block (ndarray or ExtensionArray\n    depending on the Block class), with datetime64[ns] and timedelta64[ns]\n    wrapped in ExtensionArrays to match Index._values behavior.\n\n    Differs from the public ``.values`` for certain data types, because of\n    historical backwards compatibility of the public attribute (e.g. period\n    returns object ndarray and datetimetz a datetime64[ns] ndarray for\n    ``.values`` while it returns an ExtensionArray for ``._values`` in those\n    cases).\n\n    Differs from ``.array`` in that this still returns the numpy array if\n    the Block is backed by a numpy array (except for datetime64 and\n    timedelta64 dtypes), while ``.array`` ensures to always return an\n    ExtensionArray.\n\n    Differs from ``._ndarray_values``, as that ensures to always return a\n    numpy array (it will call ``_ndarray_values`` on the ExtensionArray, if\n    the Series was backed by an ExtensionArray).\n\n    Overview:\n\n    dtype       | values        | _values       | array         | _ndarray_values |\n    ----------- | ------------- | ------------- | ------------- | --------------- |\n    Numeric     | ndarray       | ndarray       | PandasArray   | ndarray         |\n    Category    | Categorical   | Categorical   | Categorical   | ndarray[int]    |\n    dt64[ns]    | ndarray[M8ns] | DatetimeArray | DatetimeArray | ndarray[M8ns]   |\n    dt64[ns tz] | ndarray[M8ns] | DatetimeArray | DatetimeArray | ndarray[M8ns]   |\n    td64[ns]    | ndarray[m8ns] | TimedeltaArray| ndarray[m8ns] | ndarray[m8ns]   |\n    Period      | ndarray[obj]  | PeriodArray   | PeriodArray   | ndarray[int]    |\n    Nullable    | EA            | EA            | EA            | ndarray         |\n\n    \"\"\"\n    return self._data.internal_values()",
                                "signature": "_values(self)"
                            },
                            {
                                "code": "@Appender(base.IndexOpsMixin.array.__doc__)  # type: ignore\n@property\ndef array(self) -> ExtensionArray:\n    return self._data._block.array_values()",
                                "signature": "array(self) -> ExtensionArray"
                            },
                            {
                                "code": "def _internal_get_values(self):\n    \"\"\"\n    Same as values (but handles sparseness conversions); is a view.\n\n    Returns\n    -------\n    numpy.ndarray\n        Data of the Series.\n    \"\"\"\n\n    return self._data.get_values()",
                                "signature": "_internal_get_values(self)"
                            },
                            {
                                "code": "def ravel(self, order=\"C\"):\n    \"\"\"\n    Return the flattened underlying data as an ndarray.\n\n    Returns\n    -------\n    numpy.ndarray or ndarray-like\n        Flattened data of the Series.\n\n    See Also\n    --------\n    numpy.ndarray.ravel\n    \"\"\"\n    return self._values.ravel(order=order)",
                                "signature": "ravel(self, order='C')"
                            },
                            {
                                "code": "def __len__(self) -> int:\n    \"\"\"\n    Return the length of the Series.\n    \"\"\"\n    return len(self._data)",
                                "signature": "__len__(self) -> int"
                            },
                            {
                                "code": "def view(self, dtype=None) -> \"Series\":\n    \"\"\"\n    Create a new view of the Series.\n\n    This function will return a new Series with a view of the same\n    underlying values in memory, optionally reinterpreted with a new data\n    type. The new data type must preserve the same size in bytes as to not\n    cause index misalignment.\n\n    Parameters\n    ----------\n    dtype : data type\n        Data type object or one of their string representations.\n\n    Returns\n    -------\n    Series\n        A new Series object as a view of the same data in memory.\n\n    See Also\n    --------\n    numpy.ndarray.view : Equivalent numpy function to create a new view of\n        the same data in memory.\n\n    Notes\n    -----\n    Series are instantiated with ``dtype=float64`` by default. While\n    ``numpy.ndarray.view()`` will return a view with the same data type as\n    the original array, ``Series.view()`` (without specified dtype)\n    will try using ``float64`` and may fail if the original data type size\n    in bytes is not the same.\n\n    Examples\n    --------\n    >>> s = pd.Series([-2, -1, 0, 1, 2], dtype='int8')\n    >>> s\n    0   -2\n    1   -1\n    2    0\n    3    1\n    4    2\n    dtype: int8\n\n    The 8 bit signed integer representation of `-1` is `0b11111111`, but\n    the same bytes represent 255 if read as an 8 bit unsigned integer:\n\n    >>> us = s.view('uint8')\n    >>> us\n    0    254\n    1    255\n    2      0\n    3      1\n    4      2\n    dtype: uint8\n\n    The views share the same underlying values:\n\n    >>> us[0] = 128\n    >>> s\n    0   -128\n    1     -1\n    2      0\n    3      1\n    4      2\n    dtype: int8\n    \"\"\"\n    return self._constructor(\n        self._values.view(dtype), index=self.index\n    ).__finalize__(self)",
                                "signature": "view(self, dtype=None) -> 'Series'"
                            },
                            {
                                "code": "def __array_ufunc__(\n    self, ufunc: Callable, method: str, *inputs: Any, **kwargs: Any\n):\n    # TODO: handle DataFrame\n    cls = type(self)\n\n    # for binary ops, use our custom dunder methods\n    result = ops.maybe_dispatch_ufunc_to_dunder_op(\n        self, ufunc, method, *inputs, **kwargs\n    )\n    if result is not NotImplemented:\n        return result\n\n    # Determine if we should defer.\n    no_defer = (np.ndarray.__array_ufunc__, cls.__array_ufunc__)\n\n    for item in inputs:\n        higher_priority = (\n            hasattr(item, \"__array_priority__\")\n            and item.__array_priority__ > self.__array_priority__\n        )\n        has_array_ufunc = (\n            hasattr(item, \"__array_ufunc__\")\n            and type(item).__array_ufunc__ not in no_defer\n            and not isinstance(item, self._HANDLED_TYPES)\n        )\n        if higher_priority or has_array_ufunc:\n            return NotImplemented\n\n    # align all the inputs.\n    names = [getattr(x, \"name\") for x in inputs if hasattr(x, \"name\")]\n    types = tuple(type(x) for x in inputs)\n    # TODO: dataframe\n    alignable = [x for x, t in zip(inputs, types) if issubclass(t, Series)]\n\n    if len(alignable) > 1:\n        # This triggers alignment.\n        # At the moment, there aren't any ufuncs with more than two inputs\n        # so this ends up just being x1.index | x2.index, but we write\n        # it to handle *args.\n        index = alignable[0].index\n        for s in alignable[1:]:\n            index |= s.index\n        inputs = tuple(\n            x.reindex(index) if issubclass(t, Series) else x\n            for x, t in zip(inputs, types)\n        )\n    else:\n        index = self.index\n\n    inputs = tuple(extract_array(x, extract_numpy=True) for x in inputs)\n    result = getattr(ufunc, method)(*inputs, **kwargs)\n\n    name: Optional[Hashable]\n    if len(set(names)) == 1:\n        name = names[0]\n    else:\n        name = None\n\n    def construct_return(result):\n        if lib.is_scalar(result):\n            return result\n        elif result.ndim > 1:\n            # e.g. np.subtract.outer\n            if method == \"outer\":\n                # GH#27198\n                raise NotImplementedError\n            return result\n        return self._constructor(result, index=index, name=name, copy=False)\n\n    if type(result) is tuple:\n        # multiple return values\n        return tuple(construct_return(x) for x in result)\n    elif method == \"at\":\n        # no return value\n        return None\n    else:\n        return construct_return(result)",
                                "signature": "__array_ufunc__(self, ufunc: Callable, method: str, *inputs: Any, **kwargs: Any)"
                            },
                            {
                                "code": "def __array__(self, dtype=None) -> np.ndarray:\n    \"\"\"\n    Return the values as a NumPy array.\n\n    Users should not call this directly. Rather, it is invoked by\n    :func:`numpy.array` and :func:`numpy.asarray`.\n\n    Parameters\n    ----------\n    dtype : str or numpy.dtype, optional\n        The dtype to use for the resulting NumPy array. By default,\n        the dtype is inferred from the data.\n\n    Returns\n    -------\n    numpy.ndarray\n        The values in the series converted to a :class:`numpy.ndarray`\n        with the specified `dtype`.\n\n    See Also\n    --------\n    array : Create a new array from data.\n    Series.array : Zero-copy view to the array backing the Series.\n    Series.to_numpy : Series method for similar behavior.\n\n    Examples\n    --------\n    >>> ser = pd.Series([1, 2, 3])\n    >>> np.asarray(ser)\n    array([1, 2, 3])\n\n    For timezone-aware data, the timezones may be retained with\n    ``dtype='object'``\n\n    >>> tzser = pd.Series(pd.date_range('2000', periods=2, tz=\"CET\"))\n    >>> np.asarray(tzser, dtype=\"object\")\n    array([Timestamp('2000-01-01 00:00:00+0100', tz='CET', freq='D'),\n           Timestamp('2000-01-02 00:00:00+0100', tz='CET', freq='D')],\n          dtype=object)\n\n    Or the values may be localized to UTC and the tzinfo discarded with\n    ``dtype='datetime64[ns]'``\n\n    >>> np.asarray(tzser, dtype=\"datetime64[ns]\")  # doctest: +ELLIPSIS\n    array(['1999-12-31T23:00:00.000000000', ...],\n          dtype='datetime64[ns]')\n    \"\"\"\n    return np.asarray(self.array, dtype)",
                                "signature": "__array__(self, dtype=None) -> np.ndarray"
                            },
                            {
                                "code": "@property\ndef axes(self) -> List[Index]:\n    \"\"\"\n    Return a list of the row axis labels.\n    \"\"\"\n    return [self.index]",
                                "signature": "axes(self) -> List[Index]"
                            },
                            {
                                "code": "@Appender(generic.NDFrame.take.__doc__)\ndef take(self, indices, axis=0, is_copy=None, **kwargs) -> \"Series\":\n    if is_copy is not None:\n        warnings.warn(\n            \"is_copy is deprecated and will be removed in a future version. \"\n            \"'take' always returns a copy, so there is no need to specify this.\",\n            FutureWarning,\n            stacklevel=2,\n        )\n    nv.validate_take(tuple(), kwargs)\n\n    indices = ensure_platform_int(indices)\n    new_index = self.index.take(indices)\n\n    if is_categorical_dtype(self):\n        # https://github.com/pandas-dev/pandas/issues/20664\n        # TODO: remove when the default Categorical.take behavior changes\n        indices = maybe_convert_indices(indices, len(self._get_axis(axis)))\n        kwargs = {\"allow_fill\": False}\n    else:\n        kwargs = {}\n    new_values = self._values.take(indices, **kwargs)\n\n    return self._constructor(\n        new_values, index=new_index, fastpath=True\n    ).__finalize__(self)",
                                "signature": "take(self, indices, axis=0, is_copy=None, **kwargs) -> 'Series'"
                            },
                            {
                                "code": "def _take_with_is_copy(self, indices, axis=0, **kwargs):\n    \"\"\"\n    Internal version of the `take` method that sets the `_is_copy`\n    attribute to keep track of the parent dataframe (using in indexing\n    for the SettingWithCopyWarning). For Series this does the same\n    as the public take (it never sets `_is_copy`).\n\n    See the docstring of `take` for full explanation of the parameters.\n    \"\"\"\n    return self.take(indices=indices, axis=axis, **kwargs)",
                                "signature": "_take_with_is_copy(self, indices, axis=0, **kwargs)"
                            },
                            {
                                "code": "def _ixs(self, i: int, axis: int = 0):\n    \"\"\"\n    Return the i-th value or values in the Series by location.\n\n    Parameters\n    ----------\n    i : int\n\n    Returns\n    -------\n    scalar (int) or Series (slice, sequence)\n    \"\"\"\n    return self._values[i]",
                                "signature": "_ixs(self, i: int, axis: int=0)"
                            },
                            {
                                "code": "def _slice(self, slobj: slice, axis: int = 0, kind: str = \"getitem\") -> \"Series\":\n    assert kind in [\"getitem\", \"iloc\"]\n    slobj = self.index._convert_slice_indexer(slobj, kind=kind)\n    return self._get_values(slobj)",
                                "signature": "_slice(self, slobj: slice, axis: int=0, kind: str='getitem') -> 'Series'"
                            },
                            {
                                "code": "def __getitem__(self, key):\n    key = com.apply_if_callable(key, self)\n\n    if key is Ellipsis:\n        return self\n\n    key_is_scalar = is_scalar(key)\n    if key_is_scalar:\n        key = self.index._convert_scalar_indexer(key, kind=\"getitem\")\n\n    if key_is_scalar or isinstance(self.index, MultiIndex):\n        # Otherwise index.get_value will raise InvalidIndexError\n        try:\n            result = self.index.get_value(self, key)\n\n            return result\n        except InvalidIndexError:\n            pass\n        except (KeyError, ValueError):\n            if isinstance(key, tuple) and isinstance(self.index, MultiIndex):\n                # kludge\n                pass\n            else:\n                raise\n\n    if not key_is_scalar:\n        # avoid expensive checks if we know we have a scalar\n        if is_iterator(key):\n            key = list(key)\n\n        if com.is_bool_indexer(key):\n            key = check_bool_indexer(self.index, key)\n            return self._get_values(key)\n\n    return self._get_with(key)",
                                "signature": "__getitem__(self, key)"
                            },
                            {
                                "code": "def _get_with(self, key):\n    # other: fancy integer or otherwise\n    if isinstance(key, slice):\n        return self._slice(key)\n    elif isinstance(key, ABCDataFrame):\n        raise TypeError(\n            \"Indexing a Series with DataFrame is not \"\n            \"supported, use the appropriate DataFrame column\"\n        )\n    elif isinstance(key, tuple):\n        try:\n            return self._get_values_tuple(key)\n        except ValueError:\n            # if we don't have a MultiIndex, we may still be able to handle\n            #  a 1-tuple.  see test_1tuple_without_multiindex\n            if len(key) == 1:\n                key = key[0]\n                if isinstance(key, slice):\n                    return self._get_values(key)\n            raise\n\n    if not isinstance(key, (list, np.ndarray, Series, Index)):\n        key = list(key)\n\n    if isinstance(key, Index):\n        key_type = key.inferred_type\n    else:\n        key_type = lib.infer_dtype(key, skipna=False)\n\n    # Note: The key_type == \"boolean\" case should be caught by the\n    #  com.is_bool_indexer check in __getitem__\n    if key_type == \"integer\":\n        if self.index.is_integer() or self.index.is_floating():\n            return self.loc[key]\n        elif isinstance(self.index, IntervalIndex):\n            indexer = self.index.get_indexer_for(key)\n            return self.iloc[indexer]\n        else:\n            return self._get_values(key)\n\n    if isinstance(key, (list, tuple)):\n        # TODO: de-dup with tuple case handled above?\n        # handle the dup indexing case GH#4246\n        if len(key) == 1 and isinstance(key[0], slice):\n            # [slice(0, 5, None)] will break if you convert to ndarray,\n            # e.g. as requested by np.median\n            # FIXME: hack\n            return self._get_values(key)\n\n        return self.loc[key]\n\n    return self.reindex(key)",
                                "signature": "_get_with(self, key)"
                            },
                            {
                                "code": "def _get_values_tuple(self, key):\n    # mpl hackaround\n    if com.any_none(*key):\n        # suppress warning from slicing the index with a 2d indexer.\n        # eventually we'll want Series itself to warn.\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\n                \"ignore\", \"Support for multi-dim\", DeprecationWarning\n            )\n            return self._get_values(key)\n\n    if not isinstance(self.index, MultiIndex):\n        raise ValueError(\"Can only tuple-index with a MultiIndex\")\n\n    # If key is contained, would have returned by now\n    indexer, new_index = self.index.get_loc_level(key)\n    return self._constructor(self._values[indexer], index=new_index).__finalize__(\n        self\n    )",
                                "signature": "_get_values_tuple(self, key)"
                            },
                            {
                                "code": "def _get_values(self, indexer):\n    try:\n        return self._constructor(\n            self._data.get_slice(indexer), fastpath=True\n        ).__finalize__(self)\n    except ValueError:\n        # mpl compat if we look up e.g. ser[:, np.newaxis];\n        #  see tests.series.timeseries.test_mpl_compat_hack\n        return self._values[indexer]",
                                "signature": "_get_values(self, indexer)"
                            },
                            {
                                "code": "def _get_value(self, label, takeable: bool = False):\n    \"\"\"\n    Quickly retrieve single value at passed index label.\n\n    Parameters\n    ----------\n    label : object\n    takeable : interpret the index as indexers, default False\n\n    Returns\n    -------\n    scalar value\n    \"\"\"\n    if takeable:\n        return self._values[label]\n\n    # We assume that _convert_scalar_indexer has already been called,\n    #  with kind=\"loc\", if necessary, by the time we get here\n    return self.index.get_value(self, label)",
                                "signature": "_get_value(self, label, takeable: bool=False)"
                            },
                            {
                                "code": "def __setitem__(self, key, value):\n    key = com.apply_if_callable(key, self)\n    cacher_needs_updating = self._check_is_chained_assignment_possible()\n\n    try:\n        self._set_with_engine(key, value)\n    except com.SettingWithCopyError:\n        raise\n    except (KeyError, ValueError):\n        values = self._values\n        if is_integer(key) and not self.index.inferred_type == \"integer\":\n            values[key] = value\n        elif key is Ellipsis:\n            self[:] = value\n        else:\n            self.loc[key] = value\n    except InvalidIndexError:\n        # e.g. slice\n        self._set_with(key, value)\n\n    except TypeError as e:\n        if isinstance(key, tuple) and not isinstance(self.index, MultiIndex):\n            raise ValueError(\"Can only tuple-index with a MultiIndex\")\n\n        # python 3 type errors should be raised\n        if _is_unorderable_exception(e):\n            raise IndexError(key)\n\n        if com.is_bool_indexer(key):\n            key = check_bool_indexer(self.index, key)\n            try:\n                self._where(~key, value, inplace=True)\n                return\n            except InvalidIndexError:\n                pass\n\n        self._set_with(key, value)\n\n    if cacher_needs_updating:\n        self._maybe_update_cacher()",
                                "signature": "__setitem__(self, key, value)"
                            },
                            {
                                "code": "def _set_with_engine(self, key, value):\n    # fails with AttributeError for IntervalIndex\n    loc = self.index._engine.get_loc(key)\n    validate_numeric_casting(self.dtype, value)\n    self._values[loc] = value",
                                "signature": "_set_with_engine(self, key, value)"
                            },
                            {
                                "code": "def _set_with(self, key, value):\n    # other: fancy integer or otherwise\n    if isinstance(key, slice):\n        indexer = self.index._convert_slice_indexer(key, kind=\"getitem\")\n        return self._set_values(indexer, value)\n\n    elif is_scalar(key) and not is_integer(key) and key not in self.index:\n        # GH#12862 adding an new key to the Series\n        # Note: have to exclude integers because that is ambiguously\n        #  position-based\n        self.loc[key] = value\n        return\n\n    else:\n        if isinstance(key, tuple):\n            try:\n                # TODO: no test cases that get here\n                self._set_values(key, value)\n            except Exception:\n                pass\n\n        if is_scalar(key):\n            key = [key]\n\n        if isinstance(key, Index):\n            key_type = key.inferred_type\n            key = key._values\n        else:\n            key_type = lib.infer_dtype(key, skipna=False)\n\n        if key_type == \"integer\":\n            if self.index.inferred_type == \"integer\":\n                self._set_labels(key, value)\n            else:\n                return self._set_values(key, value)\n        elif key_type == \"boolean\":\n            self._set_values(key.astype(np.bool_), value)\n        else:\n            self._set_labels(key, value)",
                                "signature": "_set_with(self, key, value)"
                            },
                            {
                                "code": "def _set_labels(self, key, value):\n    key = com.asarray_tuplesafe(key)\n    indexer = self.index.get_indexer(key)\n    mask = indexer == -1\n    if mask.any():\n        raise ValueError(f\"{key[mask]} not contained in the index\")\n    self._set_values(indexer, value)",
                                "signature": "_set_labels(self, key, value)"
                            },
                            {
                                "code": "def _set_values(self, key, value):\n    if isinstance(key, Series):\n        key = key._values\n    self._data = self._data.setitem(indexer=key, value=value)\n    self._maybe_update_cacher()",
                                "signature": "_set_values(self, key, value)"
                            },
                            {
                                "code": "def _set_value(self, label, value, takeable: bool = False):\n    \"\"\"\n    Quickly set single value at passed label.\n\n    If label is not contained, a new object is created with the label\n    placed at the end of the result index.\n\n    Parameters\n    ----------\n    label : object\n        Partial indexing with MultiIndex not allowed.\n    value : object\n        Scalar value.\n    takeable : interpret the index as indexers, default False\n\n    Returns\n    -------\n    Series\n        If label is contained, will be reference to calling Series,\n        otherwise a new object.\n    \"\"\"\n    try:\n        if takeable:\n            self._values[label] = value\n        else:\n            loc = self.index.get_loc(label)\n            validate_numeric_casting(self.dtype, value)\n            self._values[loc] = value\n    except KeyError:\n\n        # set using a non-recursive method\n        self.loc[label] = value\n\n    return self",
                                "signature": "_set_value(self, label, value, takeable: bool=False)"
                            },
                            {
                                "code": "@property\ndef _is_mixed_type(self):\n    return False",
                                "signature": "_is_mixed_type(self)"
                            },
                            {
                                "code": "def repeat(self, repeats, axis=None) -> \"Series\":\n    \"\"\"\n    Repeat elements of a Series.\n\n    Returns a new Series where each element of the current Series\n    is repeated consecutively a given number of times.\n\n    Parameters\n    ----------\n    repeats : int or array of ints\n        The number of repetitions for each element. This should be a\n        non-negative integer. Repeating 0 times will return an empty\n        Series.\n    axis : None\n        Must be ``None``. Has no effect but is accepted for compatibility\n        with numpy.\n\n    Returns\n    -------\n    Series\n        Newly created Series with repeated elements.\n\n    See Also\n    --------\n    Index.repeat : Equivalent function for Index.\n    numpy.repeat : Similar method for :class:`numpy.ndarray`.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s\n    0    a\n    1    b\n    2    c\n    dtype: object\n    >>> s.repeat(2)\n    0    a\n    0    a\n    1    b\n    1    b\n    2    c\n    2    c\n    dtype: object\n    >>> s.repeat([1, 2, 3])\n    0    a\n    1    b\n    1    b\n    2    c\n    2    c\n    2    c\n    dtype: object\n    \"\"\"\n    nv.validate_repeat(tuple(), dict(axis=axis))\n    new_index = self.index.repeat(repeats)\n    new_values = self._values.repeat(repeats)\n    return self._constructor(new_values, index=new_index).__finalize__(self)",
                                "signature": "repeat(self, repeats, axis=None) -> 'Series'"
                            },
                            {
                                "code": "def reset_index(self, level=None, drop=False, name=None, inplace=False):\n    \"\"\"\n    Generate a new DataFrame or Series with the index reset.\n\n    This is useful when the index needs to be treated as a column, or\n    when the index is meaningless and needs to be reset to the default\n    before another operation.\n\n    Parameters\n    ----------\n    level : int, str, tuple, or list, default optional\n        For a Series with a MultiIndex, only remove the specified levels\n        from the index. Removes all levels by default.\n    drop : bool, default False\n        Just reset the index, without inserting it as a column in\n        the new DataFrame.\n    name : object, optional\n        The name to use for the column containing the original Series\n        values. Uses ``self.name`` by default. This argument is ignored\n        when `drop` is True.\n    inplace : bool, default False\n        Modify the Series in place (do not create a new object).\n\n    Returns\n    -------\n    Series or DataFrame\n        When `drop` is False (the default), a DataFrame is returned.\n        The newly created columns will come first in the DataFrame,\n        followed by the original Series values.\n        When `drop` is True, a `Series` is returned.\n        In either case, if ``inplace=True``, no value is returned.\n\n    See Also\n    --------\n    DataFrame.reset_index: Analogous function for DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4], name='foo',\n    ...               index=pd.Index(['a', 'b', 'c', 'd'], name='idx'))\n\n    Generate a DataFrame with default index.\n\n    >>> s.reset_index()\n      idx  foo\n    0   a    1\n    1   b    2\n    2   c    3\n    3   d    4\n\n    To specify the name of the new column use `name`.\n\n    >>> s.reset_index(name='values')\n      idx  values\n    0   a       1\n    1   b       2\n    2   c       3\n    3   d       4\n\n    To generate a new Series with the default set `drop` to True.\n\n    >>> s.reset_index(drop=True)\n    0    1\n    1    2\n    2    3\n    3    4\n    Name: foo, dtype: int64\n\n    To update the Series in place, without generating a new one\n    set `inplace` to True. Note that it also requires ``drop=True``.\n\n    >>> s.reset_index(inplace=True, drop=True)\n    >>> s\n    0    1\n    1    2\n    2    3\n    3    4\n    Name: foo, dtype: int64\n\n    The `level` parameter is interesting for Series with a multi-level\n    index.\n\n    >>> arrays = [np.array(['bar', 'bar', 'baz', 'baz']),\n    ...           np.array(['one', 'two', 'one', 'two'])]\n    >>> s2 = pd.Series(\n    ...     range(4), name='foo',\n    ...     index=pd.MultiIndex.from_arrays(arrays,\n    ...                                     names=['a', 'b']))\n\n    To remove a specific level from the Index, use `level`.\n\n    >>> s2.reset_index(level='a')\n           a  foo\n    b\n    one  bar    0\n    two  bar    1\n    one  baz    2\n    two  baz    3\n\n    If `level` is not set, all levels are removed from the Index.\n\n    >>> s2.reset_index()\n         a    b  foo\n    0  bar  one    0\n    1  bar  two    1\n    2  baz  one    2\n    3  baz  two    3\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    if drop:\n        new_index = ibase.default_index(len(self))\n        if level is not None:\n            if not isinstance(level, (tuple, list)):\n                level = [level]\n            level = [self.index._get_level_number(lev) for lev in level]\n            if len(level) < self.index.nlevels:\n                new_index = self.index.droplevel(level)\n\n        if inplace:\n            self.index = new_index\n            # set name if it was passed, otherwise, keep the previous name\n            self.name = name or self.name\n        else:\n            return self._constructor(\n                self._values.copy(), index=new_index\n            ).__finalize__(self)\n    elif inplace:\n        raise TypeError(\n            \"Cannot reset_index inplace on a Series to create a DataFrame\"\n        )\n    else:\n        df = self.to_frame(name)\n        return df.reset_index(level=level, drop=drop)",
                                "signature": "reset_index(self, level=None, drop=False, name=None, inplace=False)"
                            },
                            {
                                "code": "def __repr__(self) -> str:\n    \"\"\"\n    Return a string representation for a particular Series.\n    \"\"\"\n    buf = StringIO(\"\")\n    width, height = get_terminal_size()\n    max_rows = (\n        height\n        if get_option(\"display.max_rows\") == 0\n        else get_option(\"display.max_rows\")\n    )\n    min_rows = (\n        height\n        if get_option(\"display.max_rows\") == 0\n        else get_option(\"display.min_rows\")\n    )\n    show_dimensions = get_option(\"display.show_dimensions\")\n\n    self.to_string(\n        buf=buf,\n        name=self.name,\n        dtype=self.dtype,\n        min_rows=min_rows,\n        max_rows=max_rows,\n        length=show_dimensions,\n    )\n    result = buf.getvalue()\n\n    return result",
                                "signature": "__repr__(self) -> str"
                            },
                            {
                                "code": "def to_string(\n    self,\n    buf=None,\n    na_rep=\"NaN\",\n    float_format=None,\n    header=True,\n    index=True,\n    length=False,\n    dtype=False,\n    name=False,\n    max_rows=None,\n    min_rows=None,\n):\n    \"\"\"\n    Render a string representation of the Series.\n\n    Parameters\n    ----------\n    buf : StringIO-like, optional\n        Buffer to write to.\n    na_rep : str, optional\n        String representation of NaN to use, default 'NaN'.\n    float_format : one-parameter function, optional\n        Formatter function to apply to columns' elements if they are\n        floats, default None.\n    header : bool, default True\n        Add the Series header (index name).\n    index : bool, optional\n        Add index (row) labels, default True.\n    length : bool, default False\n        Add the Series length.\n    dtype : bool, default False\n        Add the Series dtype.\n    name : bool, default False\n        Add the Series name if not None.\n    max_rows : int, optional\n        Maximum number of rows to show before truncating. If None, show\n        all.\n    min_rows : int, optional\n        The number of rows to display in a truncated repr (when number\n        of rows is above `max_rows`).\n\n    Returns\n    -------\n    str or None\n        String representation of Series if ``buf=None``, otherwise None.\n    \"\"\"\n\n    formatter = fmt.SeriesFormatter(\n        self,\n        name=name,\n        length=length,\n        header=header,\n        index=index,\n        dtype=dtype,\n        na_rep=na_rep,\n        float_format=float_format,\n        min_rows=min_rows,\n        max_rows=max_rows,\n    )\n    result = formatter.to_string()\n\n    # catch contract violations\n    if not isinstance(result, str):\n        raise AssertionError(\n            \"result must be of type str, type \"\n            f\"of result is {repr(type(result).__name__)}\"\n        )\n\n    if buf is None:\n        return result\n    else:\n        try:\n            buf.write(result)\n        except AttributeError:\n            with open(buf, \"w\") as f:\n                f.write(result)",
                                "signature": "to_string(self, buf=None, na_rep='NaN', float_format=None, header=True, index=True, length=False, dtype=False, name=False, max_rows=None, min_rows=None)"
                            },
                            {
                                "code": "@Appender(\n    \"\"\"\n    Examples\n    --------\n    >>> s = pd.Series([\"elk\", \"pig\", \"dog\", \"quetzal\"], name=\"animal\")\n    >>> print(s.to_markdown())\n    |    | animal   |\n    |---:|:---------|\n    |  0 | elk      |\n    |  1 | pig      |\n    |  2 | dog      |\n    |  3 | quetzal  |\n    \"\"\"\n)\n@Substitution(klass=\"Series\")\n@Appender(generic._shared_docs[\"to_markdown\"])\ndef to_markdown(\n    self, buf: Optional[IO[str]] = None, mode: Optional[str] = None, **kwargs\n) -> Optional[str]:\n    return self.to_frame().to_markdown(buf, mode, **kwargs)",
                                "signature": "to_markdown(self, buf: Optional[IO[str]]=None, mode: Optional[str]=None, **kwargs) -> Optional[str]"
                            },
                            {
                                "code": "def items(self) -> Iterable[Tuple[Label, Any]]:\n    \"\"\"\n    Lazily iterate over (index, value) tuples.\n\n    This method returns an iterable tuple (index, value). This is\n    convenient if you want to create a lazy iterator.\n\n    Returns\n    -------\n    iterable\n        Iterable of tuples containing the (index, value) pairs from a\n        Series.\n\n    See Also\n    --------\n    DataFrame.items : Iterate over (column name, Series) pairs.\n    DataFrame.iterrows : Iterate over DataFrame rows as (index, Series) pairs.\n\n    Examples\n    --------\n    >>> s = pd.Series(['A', 'B', 'C'])\n    >>> for index, value in s.items():\n    ...     print(f\"Index : {index}, Value : {value}\")\n    Index : 0, Value : A\n    Index : 1, Value : B\n    Index : 2, Value : C\n    \"\"\"\n    return zip(iter(self.index), iter(self))",
                                "signature": "items(self) -> Iterable[Tuple[Label, Any]]"
                            },
                            {
                                "code": "@Appender(items.__doc__)\ndef iteritems(self) -> Iterable[Tuple[Label, Any]]:\n    return self.items()",
                                "signature": "iteritems(self) -> Iterable[Tuple[Label, Any]]"
                            },
                            {
                                "code": "def keys(self) -> Index:\n    \"\"\"\n    Return alias for index.\n\n    Returns\n    -------\n    Index\n        Index of the Series.\n    \"\"\"\n    return self.index",
                                "signature": "keys(self) -> Index"
                            },
                            {
                                "code": "def to_dict(self, into=dict):\n    \"\"\"\n    Convert Series to {label -> value} dict or dict-like object.\n\n    Parameters\n    ----------\n    into : class, default dict\n        The collections.abc.Mapping subclass to use as the return\n        object. Can be the actual class or an empty\n        instance of the mapping type you want.  If you want a\n        collections.defaultdict, you must pass it initialized.\n\n        .. versionadded:: 0.21.0\n\n    Returns\n    -------\n    collections.abc.Mapping\n        Key-value representation of Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4])\n    >>> s.to_dict()\n    {0: 1, 1: 2, 2: 3, 3: 4}\n    >>> from collections import OrderedDict, defaultdict\n    >>> s.to_dict(OrderedDict)\n    OrderedDict([(0, 1), (1, 2), (2, 3), (3, 4)])\n    >>> dd = defaultdict(list)\n    >>> s.to_dict(dd)\n    defaultdict(<class 'list'>, {0: 1, 1: 2, 2: 3, 3: 4})\n    \"\"\"\n    # GH16122\n    into_c = com.standardize_mapping(into)\n    return into_c(self.items())",
                                "signature": "to_dict(self, into=dict)"
                            },
                            {
                                "code": "def to_frame(self, name=None) -> \"DataFrame\":\n    \"\"\"\n    Convert Series to DataFrame.\n\n    Parameters\n    ----------\n    name : object, default None\n        The passed name should substitute for the series name (if it has\n        one).\n\n    Returns\n    -------\n    DataFrame\n        DataFrame representation of Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"a\", \"b\", \"c\"],\n    ...               name=\"vals\")\n    >>> s.to_frame()\n      vals\n    0    a\n    1    b\n    2    c\n    \"\"\"\n    if name is None:\n        df = self._constructor_expanddim(self)\n    else:\n        df = self._constructor_expanddim({name: self})\n\n    return df",
                                "signature": "to_frame(self, name=None) -> 'DataFrame'"
                            },
                            {
                                "code": "def _set_name(self, name, inplace=False) -> \"Series\":\n    \"\"\"\n    Set the Series name.\n\n    Parameters\n    ----------\n    name : str\n    inplace : bool\n        Whether to modify `self` directly or return a copy.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    ser = self if inplace else self.copy()\n    ser.name = name\n    return ser",
                                "signature": "_set_name(self, name, inplace=False) -> 'Series'"
                            },
                            {
                                "code": "    @Appender(\n        \"\"\"\nExamples\n--------\n>>> ser = pd.Series([390., 350., 30., 20.],\n...                 index=['Falcon', 'Falcon', 'Parrot', 'Parrot'], name=\"Max Speed\")\n>>> ser\nFalcon    390.0\nFalcon    350.0\nParrot     30.0\nParrot     20.0\nName: Max Speed, dtype: float64\n>>> ser.groupby([\"a\", \"b\", \"a\", \"b\"]).mean()\na    210.0\nb    185.0\nName: Max Speed, dtype: float64\n>>> ser.groupby(level=0).mean()\nFalcon    370.0\nParrot     25.0\nName: Max Speed, dtype: float64\n>>> ser.groupby(ser > 100).mean()\nMax Speed\nFalse     25.0\nTrue     370.0\nName: Max Speed, dtype: float64\n\n**Grouping by Indexes**\n\nWe can groupby different levels of a hierarchical index\nusing the `level` parameter:\n\n>>> arrays = [['Falcon', 'Falcon', 'Parrot', 'Parrot'],\n...           ['Captive', 'Wild', 'Captive', 'Wild']]\n>>> index = pd.MultiIndex.from_arrays(arrays, names=('Animal', 'Type'))\n>>> ser = pd.Series([390., 350., 30., 20.], index=index, name=\"Max Speed\")\n>>> ser\nAnimal  Type\nFalcon  Captive    390.0\n        Wild       350.0\nParrot  Captive     30.0\n        Wild        20.0\nName: Max Speed, dtype: float64\n>>> ser.groupby(level=0).mean()\nAnimal\nFalcon    370.0\nParrot     25.0\nName: Max Speed, dtype: float64\n>>> ser.groupby(level=\"Type\").mean()\nType\nCaptive    210.0\nWild       185.0\nName: Max Speed, dtype: float64\n\"\"\"\n    )\n    @Appender(generic._shared_docs[\"groupby\"] % _shared_doc_kwargs)\n    def groupby(\n        self,\n        by=None,\n        axis=0,\n        level=None,\n        as_index: bool = True,\n        sort: bool = True,\n        group_keys: bool = True,\n        squeeze: bool = False,\n        observed: bool = False,\n    ) -> \"SeriesGroupBy\":\n        from pandas.core.groupby.generic import SeriesGroupBy\n\n        if level is None and by is None:\n            raise TypeError(\"You have to supply one of 'by' and 'level'\")\n        axis = self._get_axis_number(axis)\n\n        return SeriesGroupBy(\n            obj=self,\n            keys=by,\n            axis=axis,\n            level=level,\n            as_index=as_index,\n            sort=sort,\n            group_keys=group_keys,\n            squeeze=squeeze,\n            observed=observed,\n        )",
                                "signature": "groupby(self, by=None, axis=0, level=None, as_index: bool=True, sort: bool=True, group_keys: bool=True, squeeze: bool=False, observed: bool=False) -> 'SeriesGroupBy'"
                            },
                            {
                                "code": "def count(self, level=None):\n    \"\"\"\n    Return number of non-NA/null observations in the Series.\n\n    Parameters\n    ----------\n    level : int or level name, default None\n        If the axis is a MultiIndex (hierarchical), count along a\n        particular level, collapsing into a smaller Series.\n\n    Returns\n    -------\n    int or Series (if level specified)\n        Number of non-null values in the Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([0.0, 1.0, np.nan])\n    >>> s.count()\n    2\n    \"\"\"\n    if level is None:\n        return notna(self.array).sum()\n\n    if isinstance(level, str):\n        level = self.index._get_level_number(level)\n\n    lev = self.index.levels[level]\n    level_codes = np.array(self.index.codes[level], subok=False, copy=True)\n\n    mask = level_codes == -1\n    if mask.any():\n        level_codes[mask] = cnt = len(lev)\n        lev = lev.insert(cnt, lev._na_value)\n\n    obs = level_codes[notna(self.values)]\n    out = np.bincount(obs, minlength=len(lev) or None)\n    return self._constructor(out, index=lev, dtype=\"int64\").__finalize__(self)",
                                "signature": "count(self, level=None)"
                            },
                            {
                                "code": "def mode(self, dropna=True) -> \"Series\":\n    \"\"\"\n    Return the mode(s) of the dataset.\n\n    Always returns Series even if only one value is returned.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't consider counts of NaN/NaT.\n\n        .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    Series\n        Modes of the Series in sorted order.\n    \"\"\"\n    # TODO: Add option for bins like value_counts()\n    return algorithms.mode(self, dropna=dropna)",
                                "signature": "mode(self, dropna=True) -> 'Series'"
                            },
                            {
                                "code": "def unique(self):\n    \"\"\"\n    Return unique values of Series object.\n\n    Uniques are returned in order of appearance. Hash table-based unique,\n    therefore does NOT sort.\n\n    Returns\n    -------\n    ndarray or ExtensionArray\n        The unique values returned as a NumPy array. See Notes.\n\n    See Also\n    --------\n    unique : Top-level unique method for any 1-d array-like object.\n    Index.unique : Return Index with unique values from an Index object.\n\n    Notes\n    -----\n    Returns the unique values as a NumPy array. In case of an\n    extension-array backed Series, a new\n    :class:`~api.extensions.ExtensionArray` of that type with just\n    the unique values is returned. This includes\n\n        * Categorical\n        * Period\n        * Datetime with Timezone\n        * Interval\n        * Sparse\n        * IntegerNA\n\n    See Examples section.\n\n    Examples\n    --------\n    >>> pd.Series([2, 1, 3, 3], name='A').unique()\n    array([2, 1, 3])\n\n    >>> pd.Series([pd.Timestamp('2016-01-01') for _ in range(3)]).unique()\n    array(['2016-01-01T00:00:00.000000000'], dtype='datetime64[ns]')\n\n    >>> pd.Series([pd.Timestamp('2016-01-01', tz='US/Eastern')\n    ...            for _ in range(3)]).unique()\n    <DatetimeArray>\n    ['2016-01-01 00:00:00-05:00']\n    Length: 1, dtype: datetime64[ns, US/Eastern]\n\n    An unordered Categorical will return categories in the order of\n    appearance.\n\n    >>> pd.Series(pd.Categorical(list('baabc'))).unique()\n    [b, a, c]\n    Categories (3, object): [b, a, c]\n\n    An ordered Categorical preserves the category ordering.\n\n    >>> pd.Series(pd.Categorical(list('baabc'), categories=list('abc'),\n    ...                          ordered=True)).unique()\n    [b, a, c]\n    Categories (3, object): [a < b < c]\n    \"\"\"\n    result = super().unique()\n    return result",
                                "signature": "unique(self)"
                            },
                            {
                                "code": "def drop_duplicates(self, keep=\"first\", inplace=False) -> \"Series\":\n    \"\"\"\n    Return Series with duplicate values removed.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', ``False``}, default 'first'\n        Method to handle dropping duplicates:\n\n        - 'first' : Drop duplicates except for the first occurrence.\n        - 'last' : Drop duplicates except for the last occurrence.\n        - ``False`` : Drop all duplicates.\n\n    inplace : bool, default ``False``\n        If ``True``, performs operation inplace and returns None.\n\n    Returns\n    -------\n    Series\n        Series with duplicates dropped.\n\n    See Also\n    --------\n    Index.drop_duplicates : Equivalent method on Index.\n    DataFrame.drop_duplicates : Equivalent method on DataFrame.\n    Series.duplicated : Related method on Series, indicating duplicate\n        Series values.\n\n    Examples\n    --------\n    Generate a Series with duplicated entries.\n\n    >>> s = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama', 'hippo'],\n    ...               name='animal')\n    >>> s\n    0      lama\n    1       cow\n    2      lama\n    3    beetle\n    4      lama\n    5     hippo\n    Name: animal, dtype: object\n\n    With the 'keep' parameter, the selection behaviour of duplicated values\n    can be changed. The value 'first' keeps the first occurrence for each\n    set of duplicated entries. The default value of keep is 'first'.\n\n    >>> s.drop_duplicates()\n    0      lama\n    1       cow\n    3    beetle\n    5     hippo\n    Name: animal, dtype: object\n\n    The value 'last' for parameter 'keep' keeps the last occurrence for\n    each set of duplicated entries.\n\n    >>> s.drop_duplicates(keep='last')\n    1       cow\n    3    beetle\n    4      lama\n    5     hippo\n    Name: animal, dtype: object\n\n    The value ``False`` for parameter 'keep' discards all sets of\n    duplicated entries. Setting the value of 'inplace' to ``True`` performs\n    the operation inplace and returns ``None``.\n\n    >>> s.drop_duplicates(keep=False, inplace=True)\n    >>> s\n    1       cow\n    3    beetle\n    5     hippo\n    Name: animal, dtype: object\n    \"\"\"\n    return super().drop_duplicates(keep=keep, inplace=inplace)",
                                "signature": "drop_duplicates(self, keep='first', inplace=False) -> 'Series'"
                            },
                            {
                                "code": "def duplicated(self, keep=\"first\") -> \"Series\":\n    \"\"\"\n    Indicate duplicate Series values.\n\n    Duplicated values are indicated as ``True`` values in the resulting\n    Series. Either all duplicates, all except the first or all except the\n    last occurrence of duplicates can be indicated.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', False}, default 'first'\n        Method to handle dropping duplicates:\n\n        - 'first' : Mark duplicates as ``True`` except for the first\n          occurrence.\n        - 'last' : Mark duplicates as ``True`` except for the last\n          occurrence.\n        - ``False`` : Mark all duplicates as ``True``.\n\n    Returns\n    -------\n    Series\n        Series indicating whether each value has occurred in the\n        preceding values.\n\n    See Also\n    --------\n    Index.duplicated : Equivalent method on pandas.Index.\n    DataFrame.duplicated : Equivalent method on pandas.DataFrame.\n    Series.drop_duplicates : Remove duplicate values from Series.\n\n    Examples\n    --------\n    By default, for each set of duplicated values, the first occurrence is\n    set on False and all others on True:\n\n    >>> animals = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama'])\n    >>> animals.duplicated()\n    0    False\n    1    False\n    2     True\n    3    False\n    4     True\n    dtype: bool\n\n    which is equivalent to\n\n    >>> animals.duplicated(keep='first')\n    0    False\n    1    False\n    2     True\n    3    False\n    4     True\n    dtype: bool\n\n    By using 'last', the last occurrence of each set of duplicated values\n    is set on False and all others on True:\n\n    >>> animals.duplicated(keep='last')\n    0     True\n    1    False\n    2     True\n    3    False\n    4    False\n    dtype: bool\n\n    By setting keep on ``False``, all duplicates are True:\n\n    >>> animals.duplicated(keep=False)\n    0     True\n    1    False\n    2     True\n    3    False\n    4     True\n    dtype: bool\n    \"\"\"\n    return super().duplicated(keep=keep)",
                                "signature": "duplicated(self, keep='first') -> 'Series'"
                            },
                            {
                                "code": "def idxmin(self, axis=0, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the row label of the minimum value.\n\n    If multiple values equal the minimum, the first row label with that\n    value is returned.\n\n    Parameters\n    ----------\n    axis : int, default 0\n        For compatibility with DataFrame.idxmin. Redundant for application\n        on Series.\n    skipna : bool, default True\n        Exclude NA/null values. If the entire Series is NA, the result\n        will be NA.\n    *args, **kwargs\n        Additional arguments and keywords have no effect but might be\n        accepted for compatibility with NumPy.\n\n    Returns\n    -------\n    Index\n        Label of the minimum value.\n\n    Raises\n    ------\n    ValueError\n        If the Series is empty.\n\n    See Also\n    --------\n    numpy.argmin : Return indices of the minimum values\n        along the given axis.\n    DataFrame.idxmin : Return index of first occurrence of minimum\n        over requested axis.\n    Series.idxmax : Return index *label* of the first occurrence\n        of maximum of values.\n\n    Notes\n    -----\n    This method is the Series version of ``ndarray.argmin``. This method\n    returns the label of the minimum, while ``ndarray.argmin`` returns\n    the position. To get the position, use ``series.values.argmin()``.\n\n    Examples\n    --------\n    >>> s = pd.Series(data=[1, None, 4, 1],\n    ...               index=['A', 'B', 'C', 'D'])\n    >>> s\n    A    1.0\n    B    NaN\n    C    4.0\n    D    1.0\n    dtype: float64\n\n    >>> s.idxmin()\n    'A'\n\n    If `skipna` is False and there is an NA value in the data,\n    the function returns ``nan``.\n\n    >>> s.idxmin(skipna=False)\n    nan\n    \"\"\"\n    skipna = nv.validate_argmin_with_skipna(skipna, args, kwargs)\n    i = nanops.nanargmin(com.values_from_object(self), skipna=skipna)\n    if i == -1:\n        return np.nan\n    return self.index[i]",
                                "signature": "idxmin(self, axis=0, skipna=True, *args, **kwargs)"
                            },
                            {
                                "code": "def idxmax(self, axis=0, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the row label of the maximum value.\n\n    If multiple values equal the maximum, the first row label with that\n    value is returned.\n\n    Parameters\n    ----------\n    axis : int, default 0\n        For compatibility with DataFrame.idxmax. Redundant for application\n        on Series.\n    skipna : bool, default True\n        Exclude NA/null values. If the entire Series is NA, the result\n        will be NA.\n    *args, **kwargs\n        Additional arguments and keywords have no effect but might be\n        accepted for compatibility with NumPy.\n\n    Returns\n    -------\n    Index\n        Label of the maximum value.\n\n    Raises\n    ------\n    ValueError\n        If the Series is empty.\n\n    See Also\n    --------\n    numpy.argmax : Return indices of the maximum values\n        along the given axis.\n    DataFrame.idxmax : Return index of first occurrence of maximum\n        over requested axis.\n    Series.idxmin : Return index *label* of the first occurrence\n        of minimum of values.\n\n    Notes\n    -----\n    This method is the Series version of ``ndarray.argmax``. This method\n    returns the label of the maximum, while ``ndarray.argmax`` returns\n    the position. To get the position, use ``series.values.argmax()``.\n\n    Examples\n    --------\n    >>> s = pd.Series(data=[1, None, 4, 3, 4],\n    ...               index=['A', 'B', 'C', 'D', 'E'])\n    >>> s\n    A    1.0\n    B    NaN\n    C    4.0\n    D    3.0\n    E    4.0\n    dtype: float64\n\n    >>> s.idxmax()\n    'C'\n\n    If `skipna` is False and there is an NA value in the data,\n    the function returns ``nan``.\n\n    >>> s.idxmax(skipna=False)\n    nan\n    \"\"\"\n    skipna = nv.validate_argmax_with_skipna(skipna, args, kwargs)\n    i = nanops.nanargmax(com.values_from_object(self), skipna=skipna)\n    if i == -1:\n        return np.nan\n    return self.index[i]",
                                "signature": "idxmax(self, axis=0, skipna=True, *args, **kwargs)"
                            },
                            {
                                "code": "def round(self, decimals=0, *args, **kwargs) -> \"Series\":\n    \"\"\"\n    Round each value in a Series to the given number of decimals.\n\n    Parameters\n    ----------\n    decimals : int, default 0\n        Number of decimal places to round to. If decimals is negative,\n        it specifies the number of positions to the left of the decimal point.\n\n    Returns\n    -------\n    Series\n        Rounded values of the Series.\n\n    See Also\n    --------\n    numpy.around : Round values of an np.array.\n    DataFrame.round : Round values of a DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series([0.1, 1.3, 2.7])\n    >>> s.round()\n    0    0.0\n    1    1.0\n    2    3.0\n    dtype: float64\n    \"\"\"\n    nv.validate_round(args, kwargs)\n    result = com.values_from_object(self).round(decimals)\n    result = self._constructor(result, index=self.index).__finalize__(self)\n\n    return result",
                                "signature": "round(self, decimals=0, *args, **kwargs) -> 'Series'"
                            },
                            {
                                "code": "def quantile(self, q=0.5, interpolation=\"linear\"):\n    \"\"\"\n    Return value at the given quantile.\n\n    Parameters\n    ----------\n    q : float or array-like, default 0.5 (50% quantile)\n        The quantile(s) to compute, which can lie in range: 0 <= q <= 1.\n    interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}\n        This optional parameter specifies the interpolation method to use,\n        when the desired quantile lies between two data points `i` and `j`:\n\n            * linear: `i + (j - i) * fraction`, where `fraction` is the\n              fractional part of the index surrounded by `i` and `j`.\n            * lower: `i`.\n            * higher: `j`.\n            * nearest: `i` or `j` whichever is nearest.\n            * midpoint: (`i` + `j`) / 2.\n\n    Returns\n    -------\n    float or Series\n        If ``q`` is an array, a Series will be returned where the\n        index is ``q`` and the values are the quantiles, otherwise\n        a float will be returned.\n\n    See Also\n    --------\n    core.window.Rolling.quantile\n    numpy.percentile\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4])\n    >>> s.quantile(.5)\n    2.5\n    >>> s.quantile([.25, .5, .75])\n    0.25    1.75\n    0.50    2.50\n    0.75    3.25\n    dtype: float64\n    \"\"\"\n\n    validate_percentile(q)\n\n    # We dispatch to DataFrame so that core.internals only has to worry\n    #  about 2D cases.\n    df = self.to_frame()\n\n    result = df.quantile(q=q, interpolation=interpolation, numeric_only=False)\n    if result.ndim == 2:\n        result = result.iloc[:, 0]\n\n    if is_list_like(q):\n        result.name = self.name\n        return self._constructor(result, index=Float64Index(q), name=self.name)\n    else:\n        # scalar\n        return result.iloc[0]",
                                "signature": "quantile(self, q=0.5, interpolation='linear')"
                            },
                            {
                                "code": "def corr(self, other, method=\"pearson\", min_periods=None) -> float:\n    \"\"\"\n    Compute correlation with `other` Series, excluding missing values.\n\n    Parameters\n    ----------\n    other : Series\n        Series with which to compute the correlation.\n    method : {'pearson', 'kendall', 'spearman'} or callable\n        Method used to compute correlation:\n\n        - pearson : Standard correlation coefficient\n        - kendall : Kendall Tau correlation coefficient\n        - spearman : Spearman rank correlation\n        - callable: Callable with input two 1d ndarrays and returning a float.\n\n        .. versionadded:: 0.24.0\n            Note that the returned matrix from corr will have 1 along the\n            diagonals and will be symmetric regardless of the callable's\n            behavior.\n    min_periods : int, optional\n        Minimum number of observations needed to have a valid result.\n\n    Returns\n    -------\n    float\n        Correlation with other.\n\n    Examples\n    --------\n    >>> def histogram_intersection(a, b):\n    ...     v = np.minimum(a, b).sum().round(decimals=1)\n    ...     return v\n    >>> s1 = pd.Series([.2, .0, .6, .2])\n    >>> s2 = pd.Series([.3, .6, .0, .1])\n    >>> s1.corr(s2, method=histogram_intersection)\n    0.3\n    \"\"\"\n    this, other = self.align(other, join=\"inner\", copy=False)\n    if len(this) == 0:\n        return np.nan\n\n    if method in [\"pearson\", \"spearman\", \"kendall\"] or callable(method):\n        return nanops.nancorr(\n            this.values, other.values, method=method, min_periods=min_periods\n        )\n\n    raise ValueError(\n        \"method must be either 'pearson', \"\n        \"'spearman', 'kendall', or a callable, \"\n        f\"'{method}' was supplied\"\n    )",
                                "signature": "corr(self, other, method='pearson', min_periods=None) -> float"
                            },
                            {
                                "code": "def cov(self, other, min_periods=None) -> float:\n    \"\"\"\n    Compute covariance with Series, excluding missing values.\n\n    Parameters\n    ----------\n    other : Series\n        Series with which to compute the covariance.\n    min_periods : int, optional\n        Minimum number of observations needed to have a valid result.\n\n    Returns\n    -------\n    float\n        Covariance between Series and other normalized by N-1\n        (unbiased estimator).\n\n    Examples\n    --------\n    >>> s1 = pd.Series([0.90010907, 0.13484424, 0.62036035])\n    >>> s2 = pd.Series([0.12528585, 0.26962463, 0.51111198])\n    >>> s1.cov(s2)\n    -0.01685762652715874\n    \"\"\"\n    this, other = self.align(other, join=\"inner\", copy=False)\n    if len(this) == 0:\n        return np.nan\n    return nanops.nancov(this.values, other.values, min_periods=min_periods)",
                                "signature": "cov(self, other, min_periods=None) -> float"
                            },
                            {
                                "code": "def diff(self, periods=1) -> \"Series\":\n    \"\"\"\n    First discrete difference of element.\n\n    Calculates the difference of a Series element compared with another\n    element in the Series (default is element in previous row).\n\n    Parameters\n    ----------\n    periods : int, default 1\n        Periods to shift for calculating difference, accepts negative\n        values.\n\n    Returns\n    -------\n    Series\n        First differences of the Series.\n\n    See Also\n    --------\n    Series.pct_change: Percent change over given number of periods.\n    Series.shift: Shift index by desired number of periods with an\n        optional time freq.\n    DataFrame.diff: First discrete difference of object.\n\n    Notes\n    -----\n    For boolean dtypes, this uses :meth:`operator.xor` rather than\n    :meth:`operator.sub`.\n\n    Examples\n    --------\n    Difference with previous row\n\n    >>> s = pd.Series([1, 1, 2, 3, 5, 8])\n    >>> s.diff()\n    0    NaN\n    1    0.0\n    2    1.0\n    3    1.0\n    4    2.0\n    5    3.0\n    dtype: float64\n\n    Difference with 3rd previous row\n\n    >>> s.diff(periods=3)\n    0    NaN\n    1    NaN\n    2    NaN\n    3    2.0\n    4    4.0\n    5    6.0\n    dtype: float64\n\n    Difference with following row\n\n    >>> s.diff(periods=-1)\n    0    0.0\n    1   -1.0\n    2   -1.0\n    3   -2.0\n    4   -3.0\n    5    NaN\n    dtype: float64\n    \"\"\"\n    result = algorithms.diff(self.array, periods)\n    return self._constructor(result, index=self.index).__finalize__(self)",
                                "signature": "diff(self, periods=1) -> 'Series'"
                            },
                            {
                                "code": "def autocorr(self, lag=1) -> float:\n    \"\"\"\n    Compute the lag-N autocorrelation.\n\n    This method computes the Pearson correlation between\n    the Series and its shifted self.\n\n    Parameters\n    ----------\n    lag : int, default 1\n        Number of lags to apply before performing autocorrelation.\n\n    Returns\n    -------\n    float\n        The Pearson correlation between self and self.shift(lag).\n\n    See Also\n    --------\n    Series.corr : Compute the correlation between two Series.\n    Series.shift : Shift index by desired number of periods.\n    DataFrame.corr : Compute pairwise correlation of columns.\n    DataFrame.corrwith : Compute pairwise correlation between rows or\n        columns of two DataFrame objects.\n\n    Notes\n    -----\n    If the Pearson correlation is not well defined return 'NaN'.\n\n    Examples\n    --------\n    >>> s = pd.Series([0.25, 0.5, 0.2, -0.05])\n    >>> s.autocorr()  # doctest: +ELLIPSIS\n    0.10355...\n    >>> s.autocorr(lag=2)  # doctest: +ELLIPSIS\n    -0.99999...\n\n    If the Pearson correlation is not well defined, then 'NaN' is returned.\n\n    >>> s = pd.Series([1, 0, 0, 0])\n    >>> s.autocorr()\n    nan\n    \"\"\"\n    return self.corr(self.shift(lag))",
                                "signature": "autocorr(self, lag=1) -> float"
                            },
                            {
                                "code": "def dot(self, other):\n    \"\"\"\n    Compute the dot product between the Series and the columns of other.\n\n    This method computes the dot product between the Series and another\n    one, or the Series and each columns of a DataFrame, or the Series and\n    each columns of an array.\n\n    It can also be called using `self @ other` in Python >= 3.5.\n\n    Parameters\n    ----------\n    other : Series, DataFrame or array-like\n        The other object to compute the dot product with its columns.\n\n    Returns\n    -------\n    scalar, Series or numpy.ndarray\n        Return the dot product of the Series and other if other is a\n        Series, the Series of the dot product of Series and each rows of\n        other if other is a DataFrame or a numpy.ndarray between the Series\n        and each columns of the numpy array.\n\n    See Also\n    --------\n    DataFrame.dot: Compute the matrix product with the DataFrame.\n    Series.mul: Multiplication of series and other, element-wise.\n\n    Notes\n    -----\n    The Series and other has to share the same index if other is a Series\n    or a DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series([0, 1, 2, 3])\n    >>> other = pd.Series([-1, 2, -3, 4])\n    >>> s.dot(other)\n    8\n    >>> s @ other\n    8\n    >>> df = pd.DataFrame([[0, 1], [-2, 3], [4, -5], [6, 7]])\n    >>> s.dot(df)\n    0    24\n    1    14\n    dtype: int64\n    >>> arr = np.array([[0, 1], [-2, 3], [4, -5], [6, 7]])\n    >>> s.dot(arr)\n    array([24, 14])\n    \"\"\"\n    if isinstance(other, (Series, ABCDataFrame)):\n        common = self.index.union(other.index)\n        if len(common) > len(self.index) or len(common) > len(other.index):\n            raise ValueError(\"matrices are not aligned\")\n\n        left = self.reindex(index=common, copy=False)\n        right = other.reindex(index=common, copy=False)\n        lvals = left.values\n        rvals = right.values\n    else:\n        lvals = self.values\n        rvals = np.asarray(other)\n        if lvals.shape[0] != rvals.shape[0]:\n            raise Exception(\n                f\"Dot product shape mismatch, {lvals.shape} vs {rvals.shape}\"\n            )\n\n    if isinstance(other, ABCDataFrame):\n        return self._constructor(\n            np.dot(lvals, rvals), index=other.columns\n        ).__finalize__(self)\n    elif isinstance(other, Series):\n        return np.dot(lvals, rvals)\n    elif isinstance(rvals, np.ndarray):\n        return np.dot(lvals, rvals)\n    else:  # pragma: no cover\n        raise TypeError(f\"unsupported type: {type(other)}\")",
                                "signature": "dot(self, other)"
                            },
                            {
                                "code": "def __matmul__(self, other):\n    \"\"\"\n    Matrix multiplication using binary `@` operator in Python>=3.5.\n    \"\"\"\n    return self.dot(other)",
                                "signature": "__matmul__(self, other)"
                            },
                            {
                                "code": "def __rmatmul__(self, other):\n    \"\"\"\n    Matrix multiplication using binary `@` operator in Python>=3.5.\n    \"\"\"\n    return self.dot(np.transpose(other))",
                                "signature": "__rmatmul__(self, other)"
                            },
                            {
                                "code": "@Substitution(klass=\"Series\")\n@Appender(base._shared_docs[\"searchsorted\"])\ndef searchsorted(self, value, side=\"left\", sorter=None):\n    return algorithms.searchsorted(self._values, value, side=side, sorter=sorter)",
                                "signature": "searchsorted(self, value, side='left', sorter=None)"
                            },
                            {
                                "code": "def append(self, to_append, ignore_index=False, verify_integrity=False):\n    \"\"\"\n    Concatenate two or more Series.\n\n    Parameters\n    ----------\n    to_append : Series or list/tuple of Series\n        Series to append with self.\n    ignore_index : bool, default False\n        If True, do not use the index labels.\n    verify_integrity : bool, default False\n        If True, raise Exception on creating index with duplicates.\n\n    Returns\n    -------\n    Series\n        Concatenated Series.\n\n    See Also\n    --------\n    concat : General function to concatenate DataFrame or Series objects.\n\n    Notes\n    -----\n    Iteratively appending to a Series can be more computationally intensive\n    than a single concatenate. A better solution is to append values to a\n    list and then concatenate the list with the original Series all at\n    once.\n\n    Examples\n    --------\n    >>> s1 = pd.Series([1, 2, 3])\n    >>> s2 = pd.Series([4, 5, 6])\n    >>> s3 = pd.Series([4, 5, 6], index=[3, 4, 5])\n    >>> s1.append(s2)\n    0    1\n    1    2\n    2    3\n    0    4\n    1    5\n    2    6\n    dtype: int64\n\n    >>> s1.append(s3)\n    0    1\n    1    2\n    2    3\n    3    4\n    4    5\n    5    6\n    dtype: int64\n\n    With `ignore_index` set to True:\n\n    >>> s1.append(s2, ignore_index=True)\n    0    1\n    1    2\n    2    3\n    3    4\n    4    5\n    5    6\n    dtype: int64\n\n    With `verify_integrity` set to True:\n\n    >>> s1.append(s2, verify_integrity=True)\n    Traceback (most recent call last):\n    ...\n    ValueError: Indexes have overlapping values: [0, 1, 2]\n    \"\"\"\n    from pandas.core.reshape.concat import concat\n\n    if isinstance(to_append, (list, tuple)):\n        to_concat = [self]\n        to_concat.extend(to_append)\n    else:\n        to_concat = [self, to_append]\n    return concat(\n        to_concat, ignore_index=ignore_index, verify_integrity=verify_integrity\n    )",
                                "signature": "append(self, to_append, ignore_index=False, verify_integrity=False)"
                            },
                            {
                                "code": "def _binop(self, other, func, level=None, fill_value=None):\n    \"\"\"\n    Perform generic binary operation with optional fill value.\n\n    Parameters\n    ----------\n    other : Series\n    func : binary operator\n    fill_value : float or object\n        Value to substitute for NA/null values. If both Series are NA in a\n        location, the result will be NA regardless of the passed fill value.\n    level : int or level name, default None\n        Broadcast across a level, matching Index values on the\n        passed MultiIndex level.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n\n    if not isinstance(other, Series):\n        raise AssertionError(\"Other operand must be Series\")\n\n    new_index = self.index\n    this = self\n\n    if not self.index.equals(other.index):\n        this, other = self.align(other, level=level, join=\"outer\", copy=False)\n        new_index = this.index\n\n    this_vals, other_vals = ops.fill_binop(this.values, other.values, fill_value)\n\n    with np.errstate(all=\"ignore\"):\n        result = func(this_vals, other_vals)\n\n    name = ops.get_op_result_name(self, other)\n    ret = ops._construct_result(self, result, new_index, name)\n    return ret",
                                "signature": "_binop(self, other, func, level=None, fill_value=None)"
                            },
                            {
                                "code": "def combine(self, other, func, fill_value=None) -> \"Series\":\n    \"\"\"\n    Combine the Series with a Series or scalar according to `func`.\n\n    Combine the Series and `other` using `func` to perform elementwise\n    selection for combined Series.\n    `fill_value` is assumed when value is missing at some index\n    from one of the two objects being combined.\n\n    Parameters\n    ----------\n    other : Series or scalar\n        The value(s) to be combined with the `Series`.\n    func : function\n        Function that takes two scalars as inputs and returns an element.\n    fill_value : scalar, optional\n        The value to assume when an index is missing from\n        one Series or the other. The default specifies to use the\n        appropriate NaN value for the underlying dtype of the Series.\n\n    Returns\n    -------\n    Series\n        The result of combining the Series with the other object.\n\n    See Also\n    --------\n    Series.combine_first : Combine Series values, choosing the calling\n        Series' values first.\n\n    Examples\n    --------\n    Consider 2 Datasets ``s1`` and ``s2`` containing\n    highest clocked speeds of different birds.\n\n    >>> s1 = pd.Series({'falcon': 330.0, 'eagle': 160.0})\n    >>> s1\n    falcon    330.0\n    eagle     160.0\n    dtype: float64\n    >>> s2 = pd.Series({'falcon': 345.0, 'eagle': 200.0, 'duck': 30.0})\n    >>> s2\n    falcon    345.0\n    eagle     200.0\n    duck       30.0\n    dtype: float64\n\n    Now, to combine the two datasets and view the highest speeds\n    of the birds across the two datasets\n\n    >>> s1.combine(s2, max)\n    duck        NaN\n    eagle     200.0\n    falcon    345.0\n    dtype: float64\n\n    In the previous example, the resulting value for duck is missing,\n    because the maximum of a NaN and a float is a NaN.\n    So, in the example, we set ``fill_value=0``,\n    so the maximum value returned will be the value from some dataset.\n\n    >>> s1.combine(s2, max, fill_value=0)\n    duck       30.0\n    eagle     200.0\n    falcon    345.0\n    dtype: float64\n    \"\"\"\n    if fill_value is None:\n        fill_value = na_value_for_dtype(self.dtype, compat=False)\n\n    if isinstance(other, Series):\n        # If other is a Series, result is based on union of Series,\n        # so do this element by element\n        new_index = self.index.union(other.index)\n        new_name = ops.get_op_result_name(self, other)\n        new_values = []\n        for idx in new_index:\n            lv = self.get(idx, fill_value)\n            rv = other.get(idx, fill_value)\n            with np.errstate(all=\"ignore\"):\n                new_values.append(func(lv, rv))\n    else:\n        # Assume that other is a scalar, so apply the function for\n        # each element in the Series\n        new_index = self.index\n        with np.errstate(all=\"ignore\"):\n            new_values = [func(lv, other) for lv in self._values]\n        new_name = self.name\n\n    if is_categorical_dtype(self.values):\n        pass\n    elif is_extension_array_dtype(self.values):\n        # The function can return something of any type, so check\n        # if the type is compatible with the calling EA.\n        new_values = try_cast_to_ea(self._values, new_values)\n    return self._constructor(new_values, index=new_index, name=new_name)",
                                "signature": "combine(self, other, func, fill_value=None) -> 'Series'"
                            },
                            {
                                "code": "def combine_first(self, other) -> \"Series\":\n    \"\"\"\n    Combine Series values, choosing the calling Series's values first.\n\n    Parameters\n    ----------\n    other : Series\n        The value(s) to be combined with the `Series`.\n\n    Returns\n    -------\n    Series\n        The result of combining the Series with the other object.\n\n    See Also\n    --------\n    Series.combine : Perform elementwise operation on two Series\n        using a given function.\n\n    Notes\n    -----\n    Result index will be the union of the two indexes.\n\n    Examples\n    --------\n    >>> s1 = pd.Series([1, np.nan])\n    >>> s2 = pd.Series([3, 4])\n    >>> s1.combine_first(s2)\n    0    1.0\n    1    4.0\n    dtype: float64\n    \"\"\"\n    new_index = self.index.union(other.index)\n    this = self.reindex(new_index, copy=False)\n    other = other.reindex(new_index, copy=False)\n    if this.dtype.kind == \"M\" and other.dtype.kind != \"M\":\n        other = to_datetime(other)\n\n    return this.where(notna(this), other)",
                                "signature": "combine_first(self, other) -> 'Series'"
                            },
                            {
                                "code": "def update(self, other) -> None:\n    \"\"\"\n    Modify Series in place using non-NA values from passed\n    Series. Aligns on index.\n\n    Parameters\n    ----------\n    other : Series\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update(pd.Series([4, 5, 6]))\n    >>> s\n    0    4\n    1    5\n    2    6\n    dtype: int64\n\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s.update(pd.Series(['d', 'e'], index=[0, 2]))\n    >>> s\n    0    d\n    1    b\n    2    e\n    dtype: object\n\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update(pd.Series([4, 5, 6, 7, 8]))\n    >>> s\n    0    4\n    1    5\n    2    6\n    dtype: int64\n\n    If ``other`` contains NaNs the corresponding values are not updated\n    in the original Series.\n\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update(pd.Series([4, np.nan, 6]))\n    >>> s\n    0    4\n    1    2\n    2    6\n    dtype: int64\n    \"\"\"\n    other = other.reindex_like(self)\n    mask = notna(other)\n\n    self._data = self._data.putmask(mask=mask, new=other, inplace=True)\n    self._maybe_update_cacher()",
                                "signature": "update(self, other) -> None"
                            },
                            {
                                "code": "def sort_values(\n    self,\n    axis=0,\n    ascending=True,\n    inplace: bool = False,\n    kind: str = \"quicksort\",\n    na_position: str = \"last\",\n    ignore_index: bool = False,\n):\n    \"\"\"\n    Sort by the values.\n\n    Sort a Series in ascending or descending order by some\n    criterion.\n\n    Parameters\n    ----------\n    axis : {0 or 'index'}, default 0\n        Axis to direct sorting. The value 'index' is accepted for\n        compatibility with DataFrame.sort_values.\n    ascending : bool, default True\n        If True, sort values in ascending order, otherwise descending.\n    inplace : bool, default False\n        If True, perform operation in-place.\n    kind : {'quicksort', 'mergesort' or 'heapsort'}, default 'quicksort'\n        Choice of sorting algorithm. See also :func:`numpy.sort` for more\n        information. 'mergesort' is the only stable  algorithm.\n    na_position : {'first' or 'last'}, default 'last'\n        Argument 'first' puts NaNs at the beginning, 'last' puts NaNs at\n        the end.\n    ignore_index : bool, default False\n         If True, the resulting axis will be labeled 0, 1, \u2026, n - 1.\n\n         .. versionadded:: 1.0.0\n\n    Returns\n    -------\n    Series\n        Series ordered by values.\n\n    See Also\n    --------\n    Series.sort_index : Sort by the Series indices.\n    DataFrame.sort_values : Sort DataFrame by the values along either axis.\n    DataFrame.sort_index : Sort DataFrame by indices.\n\n    Examples\n    --------\n    >>> s = pd.Series([np.nan, 1, 3, 10, 5])\n    >>> s\n    0     NaN\n    1     1.0\n    2     3.0\n    3     10.0\n    4     5.0\n    dtype: float64\n\n    Sort values ascending order (default behaviour)\n\n    >>> s.sort_values(ascending=True)\n    1     1.0\n    2     3.0\n    4     5.0\n    3    10.0\n    0     NaN\n    dtype: float64\n\n    Sort values descending order\n\n    >>> s.sort_values(ascending=False)\n    3    10.0\n    4     5.0\n    2     3.0\n    1     1.0\n    0     NaN\n    dtype: float64\n\n    Sort values inplace\n\n    >>> s.sort_values(ascending=False, inplace=True)\n    >>> s\n    3    10.0\n    4     5.0\n    2     3.0\n    1     1.0\n    0     NaN\n    dtype: float64\n\n    Sort values putting NAs first\n\n    >>> s.sort_values(na_position='first')\n    0     NaN\n    1     1.0\n    2     3.0\n    4     5.0\n    3    10.0\n    dtype: float64\n\n    Sort a series of strings\n\n    >>> s = pd.Series(['z', 'b', 'd', 'a', 'c'])\n    >>> s\n    0    z\n    1    b\n    2    d\n    3    a\n    4    c\n    dtype: object\n\n    >>> s.sort_values()\n    3    a\n    1    b\n    4    c\n    2    d\n    0    z\n    dtype: object\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    # Validate the axis parameter\n    self._get_axis_number(axis)\n\n    # GH 5856/5853\n    if inplace and self._is_cached:\n        raise ValueError(\n            \"This Series is a view of some other array, to \"\n            \"sort in-place you must create a copy\"\n        )\n\n    def _try_kind_sort(arr):\n        # easier to ask forgiveness than permission\n        try:\n            # if kind==mergesort, it can fail for object dtype\n            return arr.argsort(kind=kind)\n        except TypeError:\n            # stable sort not available for object dtype\n            # uses the argsort default quicksort\n            return arr.argsort(kind=\"quicksort\")\n\n    arr = self._values\n    sorted_index = np.empty(len(self), dtype=np.int32)\n\n    bad = isna(arr)\n\n    good = ~bad\n    idx = ibase.default_index(len(self))\n\n    argsorted = _try_kind_sort(arr[good])\n\n    if is_list_like(ascending):\n        if len(ascending) != 1:\n            raise ValueError(\n                f\"Length of ascending ({len(ascending)}) must be 1 for Series\"\n            )\n        ascending = ascending[0]\n\n    if not is_bool(ascending):\n        raise ValueError(\"ascending must be boolean\")\n\n    if not ascending:\n        argsorted = argsorted[::-1]\n\n    if na_position == \"last\":\n        n = good.sum()\n        sorted_index[:n] = idx[good][argsorted]\n        sorted_index[n:] = idx[bad]\n    elif na_position == \"first\":\n        n = bad.sum()\n        sorted_index[n:] = idx[good][argsorted]\n        sorted_index[:n] = idx[bad]\n    else:\n        raise ValueError(f\"invalid na_position: {na_position}\")\n\n    result = self._constructor(arr[sorted_index], index=self.index[sorted_index])\n\n    if ignore_index:\n        result.index = ibase.default_index(len(sorted_index))\n\n    if inplace:\n        self._update_inplace(result)\n    else:\n        return result.__finalize__(self)",
                                "signature": "sort_values(self, axis=0, ascending=True, inplace: bool=False, kind: str='quicksort', na_position: str='last', ignore_index: bool=False)"
                            },
                            {
                                "code": "def sort_index(\n    self,\n    axis=0,\n    level=None,\n    ascending=True,\n    inplace=False,\n    kind=\"quicksort\",\n    na_position=\"last\",\n    sort_remaining=True,\n    ignore_index: bool = False,\n):\n    \"\"\"\n    Sort Series by index labels.\n\n    Returns a new Series sorted by label if `inplace` argument is\n    ``False``, otherwise updates the original series and returns None.\n\n    Parameters\n    ----------\n    axis : int, default 0\n        Axis to direct sorting. This can only be 0 for Series.\n    level : int, optional\n        If not None, sort on values in specified index level(s).\n    ascending : bool, default true\n        Sort ascending vs. descending.\n    inplace : bool, default False\n        If True, perform operation in-place.\n    kind : {'quicksort', 'mergesort', 'heapsort'}, default 'quicksort'\n        Choice of sorting algorithm. See also :func:`numpy.sort` for more\n        information.  'mergesort' is the only stable algorithm. For\n        DataFrames, this option is only applied when sorting on a single\n        column or label.\n    na_position : {'first', 'last'}, default 'last'\n        If 'first' puts NaNs at the beginning, 'last' puts NaNs at the end.\n        Not implemented for MultiIndex.\n    sort_remaining : bool, default True\n        If True and sorting by level and index is multilevel, sort by other\n        levels too (in order) after sorting by specified level.\n    ignore_index : bool, default False\n        If True, the resulting axis will be labeled 0, 1, \u2026, n - 1.\n\n        .. versionadded:: 1.0.0\n\n    Returns\n    -------\n    Series\n        The original Series sorted by the labels.\n\n    See Also\n    --------\n    DataFrame.sort_index: Sort DataFrame by the index.\n    DataFrame.sort_values: Sort DataFrame by the value.\n    Series.sort_values : Sort Series by the value.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c', 'd'], index=[3, 2, 1, 4])\n    >>> s.sort_index()\n    1    c\n    2    b\n    3    a\n    4    d\n    dtype: object\n\n    Sort Descending\n\n    >>> s.sort_index(ascending=False)\n    4    d\n    3    a\n    2    b\n    1    c\n    dtype: object\n\n    Sort Inplace\n\n    >>> s.sort_index(inplace=True)\n    >>> s\n    1    c\n    2    b\n    3    a\n    4    d\n    dtype: object\n\n    By default NaNs are put at the end, but use `na_position` to place\n    them at the beginning\n\n    >>> s = pd.Series(['a', 'b', 'c', 'd'], index=[3, 2, 1, np.nan])\n    >>> s.sort_index(na_position='first')\n    NaN     d\n     1.0    c\n     2.0    b\n     3.0    a\n    dtype: object\n\n    Specify index level to sort\n\n    >>> arrays = [np.array(['qux', 'qux', 'foo', 'foo',\n    ...                     'baz', 'baz', 'bar', 'bar']),\n    ...           np.array(['two', 'one', 'two', 'one',\n    ...                     'two', 'one', 'two', 'one'])]\n    >>> s = pd.Series([1, 2, 3, 4, 5, 6, 7, 8], index=arrays)\n    >>> s.sort_index(level=1)\n    bar  one    8\n    baz  one    6\n    foo  one    4\n    qux  one    2\n    bar  two    7\n    baz  two    5\n    foo  two    3\n    qux  two    1\n    dtype: int64\n\n    Does not sort by remaining levels when sorting by levels\n\n    >>> s.sort_index(level=1, sort_remaining=False)\n    qux  one    2\n    foo  one    4\n    baz  one    6\n    bar  one    8\n    qux  two    1\n    foo  two    3\n    baz  two    5\n    bar  two    7\n    dtype: int64\n    \"\"\"\n    # TODO: this can be combined with DataFrame.sort_index impl as\n    # almost identical\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    # Validate the axis parameter\n    self._get_axis_number(axis)\n    index = self.index\n\n    if level is not None:\n        new_index, indexer = index.sortlevel(\n            level, ascending=ascending, sort_remaining=sort_remaining\n        )\n    elif isinstance(index, MultiIndex):\n        from pandas.core.sorting import lexsort_indexer\n\n        labels = index._sort_levels_monotonic()\n        indexer = lexsort_indexer(\n            labels._get_codes_for_sorting(),\n            orders=ascending,\n            na_position=na_position,\n        )\n    else:\n        from pandas.core.sorting import nargsort\n\n        # Check monotonic-ness before sort an index\n        # GH11080\n        if (ascending and index.is_monotonic_increasing) or (\n            not ascending and index.is_monotonic_decreasing\n        ):\n            if inplace:\n                return\n            else:\n                return self.copy()\n\n        indexer = nargsort(\n            index, kind=kind, ascending=ascending, na_position=na_position\n        )\n\n    indexer = ensure_platform_int(indexer)\n    new_index = index.take(indexer)\n    new_index = new_index._sort_levels_monotonic()\n\n    new_values = self._values.take(indexer)\n    result = self._constructor(new_values, index=new_index)\n\n    if ignore_index:\n        result.index = ibase.default_index(len(result))\n\n    if inplace:\n        self._update_inplace(result)\n    else:\n        return result.__finalize__(self)",
                                "signature": "sort_index(self, axis=0, level=None, ascending=True, inplace=False, kind='quicksort', na_position='last', sort_remaining=True, ignore_index: bool=False)"
                            },
                            {
                                "code": "def argsort(self, axis=0, kind=\"quicksort\", order=None) -> \"Series\":\n    \"\"\"\n    Override ndarray.argsort. Argsorts the value, omitting NA/null values,\n    and places the result in the same locations as the non-NA values.\n\n    Parameters\n    ----------\n    axis : {0 or \"index\"}\n        Has no effect but is accepted for compatibility with numpy.\n    kind : {'mergesort', 'quicksort', 'heapsort'}, default 'quicksort'\n        Choice of sorting algorithm. See np.sort for more\n        information. 'mergesort' is the only stable algorithm.\n    order : None\n        Has no effect but is accepted for compatibility with numpy.\n\n    Returns\n    -------\n    Series\n        Positions of values within the sort order with -1 indicating\n        nan values.\n\n    See Also\n    --------\n    numpy.ndarray.argsort\n    \"\"\"\n    values = self._values\n    mask = isna(values)\n\n    if mask.any():\n        result = Series(-1, index=self.index, name=self.name, dtype=\"int64\")\n        notmask = ~mask\n        result[notmask] = np.argsort(values[notmask], kind=kind)\n        return self._constructor(result, index=self.index).__finalize__(self)\n    else:\n        return self._constructor(\n            np.argsort(values, kind=kind), index=self.index, dtype=\"int64\"\n        ).__finalize__(self)",
                                "signature": "argsort(self, axis=0, kind='quicksort', order=None) -> 'Series'"
                            },
                            {
                                "code": "def nlargest(self, n=5, keep=\"first\") -> \"Series\":\n    \"\"\"\n    Return the largest `n` elements.\n\n    Parameters\n    ----------\n    n : int, default 5\n        Return this many descending sorted values.\n    keep : {'first', 'last', 'all'}, default 'first'\n        When there are duplicate values that cannot all fit in a\n        Series of `n` elements:\n\n        - ``first`` : return the first `n` occurrences in order\n            of appearance.\n        - ``last`` : return the last `n` occurrences in reverse\n            order of appearance.\n        - ``all`` : keep all occurrences. This can result in a Series of\n            size larger than `n`.\n\n    Returns\n    -------\n    Series\n        The `n` largest values in the Series, sorted in decreasing order.\n\n    See Also\n    --------\n    Series.nsmallest: Get the `n` smallest elements.\n    Series.sort_values: Sort Series by values.\n    Series.head: Return the first `n` rows.\n\n    Notes\n    -----\n    Faster than ``.sort_values(ascending=False).head(n)`` for small `n`\n    relative to the size of the ``Series`` object.\n\n    Examples\n    --------\n    >>> countries_population = {\"Italy\": 59000000, \"France\": 65000000,\n    ...                         \"Malta\": 434000, \"Maldives\": 434000,\n    ...                         \"Brunei\": 434000, \"Iceland\": 337000,\n    ...                         \"Nauru\": 11300, \"Tuvalu\": 11300,\n    ...                         \"Anguilla\": 11300, \"Monserat\": 5200}\n    >>> s = pd.Series(countries_population)\n    >>> s\n    Italy       59000000\n    France      65000000\n    Malta         434000\n    Maldives      434000\n    Brunei        434000\n    Iceland       337000\n    Nauru          11300\n    Tuvalu         11300\n    Anguilla       11300\n    Monserat        5200\n    dtype: int64\n\n    The `n` largest elements where ``n=5`` by default.\n\n    >>> s.nlargest()\n    France      65000000\n    Italy       59000000\n    Malta         434000\n    Maldives      434000\n    Brunei        434000\n    dtype: int64\n\n    The `n` largest elements where ``n=3``. Default `keep` value is 'first'\n    so Malta will be kept.\n\n    >>> s.nlargest(3)\n    France    65000000\n    Italy     59000000\n    Malta       434000\n    dtype: int64\n\n    The `n` largest elements where ``n=3`` and keeping the last duplicates.\n    Brunei will be kept since it is the last with value 434000 based on\n    the index order.\n\n    >>> s.nlargest(3, keep='last')\n    France      65000000\n    Italy       59000000\n    Brunei        434000\n    dtype: int64\n\n    The `n` largest elements where ``n=3`` with all duplicates kept. Note\n    that the returned Series has five elements due to the three duplicates.\n\n    >>> s.nlargest(3, keep='all')\n    France      65000000\n    Italy       59000000\n    Malta         434000\n    Maldives      434000\n    Brunei        434000\n    dtype: int64\n    \"\"\"\n    return algorithms.SelectNSeries(self, n=n, keep=keep).nlargest()",
                                "signature": "nlargest(self, n=5, keep='first') -> 'Series'"
                            },
                            {
                                "code": "def nsmallest(self, n=5, keep=\"first\") -> \"Series\":\n    \"\"\"\n    Return the smallest `n` elements.\n\n    Parameters\n    ----------\n    n : int, default 5\n        Return this many ascending sorted values.\n    keep : {'first', 'last', 'all'}, default 'first'\n        When there are duplicate values that cannot all fit in a\n        Series of `n` elements:\n\n        - ``first`` : return the first `n` occurrences in order\n            of appearance.\n        - ``last`` : return the last `n` occurrences in reverse\n            order of appearance.\n        - ``all`` : keep all occurrences. This can result in a Series of\n            size larger than `n`.\n\n    Returns\n    -------\n    Series\n        The `n` smallest values in the Series, sorted in increasing order.\n\n    See Also\n    --------\n    Series.nlargest: Get the `n` largest elements.\n    Series.sort_values: Sort Series by values.\n    Series.head: Return the first `n` rows.\n\n    Notes\n    -----\n    Faster than ``.sort_values().head(n)`` for small `n` relative to\n    the size of the ``Series`` object.\n\n    Examples\n    --------\n    >>> countries_population = {\"Italy\": 59000000, \"France\": 65000000,\n    ...                         \"Brunei\": 434000, \"Malta\": 434000,\n    ...                         \"Maldives\": 434000, \"Iceland\": 337000,\n    ...                         \"Nauru\": 11300, \"Tuvalu\": 11300,\n    ...                         \"Anguilla\": 11300, \"Monserat\": 5200}\n    >>> s = pd.Series(countries_population)\n    >>> s\n    Italy       59000000\n    France      65000000\n    Brunei        434000\n    Malta         434000\n    Maldives      434000\n    Iceland       337000\n    Nauru          11300\n    Tuvalu         11300\n    Anguilla       11300\n    Monserat        5200\n    dtype: int64\n\n    The `n` smallest elements where ``n=5`` by default.\n\n    >>> s.nsmallest()\n    Monserat      5200\n    Nauru        11300\n    Tuvalu       11300\n    Anguilla     11300\n    Iceland     337000\n    dtype: int64\n\n    The `n` smallest elements where ``n=3``. Default `keep` value is\n    'first' so Nauru and Tuvalu will be kept.\n\n    >>> s.nsmallest(3)\n    Monserat     5200\n    Nauru       11300\n    Tuvalu      11300\n    dtype: int64\n\n    The `n` smallest elements where ``n=3`` and keeping the last\n    duplicates. Anguilla and Tuvalu will be kept since they are the last\n    with value 11300 based on the index order.\n\n    >>> s.nsmallest(3, keep='last')\n    Monserat     5200\n    Anguilla    11300\n    Tuvalu      11300\n    dtype: int64\n\n    The `n` smallest elements where ``n=3`` with all duplicates kept. Note\n    that the returned Series has four elements due to the three duplicates.\n\n    >>> s.nsmallest(3, keep='all')\n    Monserat     5200\n    Nauru       11300\n    Tuvalu      11300\n    Anguilla    11300\n    dtype: int64\n    \"\"\"\n    return algorithms.SelectNSeries(self, n=n, keep=keep).nsmallest()",
                                "signature": "nsmallest(self, n=5, keep='first') -> 'Series'"
                            },
                            {
                                "code": "def swaplevel(self, i=-2, j=-1, copy=True) -> \"Series\":\n    \"\"\"\n    Swap levels i and j in a :class:`MultiIndex`.\n\n    Default is to swap the two innermost levels of the index.\n\n    Parameters\n    ----------\n    i, j : int, str\n        Level of the indices to be swapped. Can pass level name as string.\n    copy : bool, default True\n        Whether to copy underlying data.\n\n    Returns\n    -------\n    Series\n        Series with levels swapped in MultiIndex.\n    \"\"\"\n    assert isinstance(self.index, ABCMultiIndex)\n    new_index = self.index.swaplevel(i, j)\n    return self._constructor(self._values, index=new_index, copy=copy).__finalize__(\n        self\n    )",
                                "signature": "swaplevel(self, i=-2, j=-1, copy=True) -> 'Series'"
                            },
                            {
                                "code": "def reorder_levels(self, order) -> \"Series\":\n    \"\"\"\n    Rearrange index levels using input order.\n\n    May not drop or duplicate levels.\n\n    Parameters\n    ----------\n    order : list of int representing new level order\n        Reference level by number or key.\n\n    Returns\n    -------\n    type of caller (new object)\n    \"\"\"\n    if not isinstance(self.index, MultiIndex):  # pragma: no cover\n        raise Exception(\"Can only reorder levels on a hierarchical axis.\")\n\n    result = self.copy()\n    assert isinstance(result.index, ABCMultiIndex)\n    result.index = result.index.reorder_levels(order)\n    return result",
                                "signature": "reorder_levels(self, order) -> 'Series'"
                            },
                            {
                                "code": "def explode(self) -> \"Series\":\n    \"\"\"\n    Transform each element of a list-like to a row, replicating the\n    index values.\n\n    .. versionadded:: 0.25.0\n\n    Returns\n    -------\n    Series\n        Exploded lists to rows; index will be duplicated for these rows.\n\n    See Also\n    --------\n    Series.str.split : Split string values on specified separator.\n    Series.unstack : Unstack, a.k.a. pivot, Series with MultiIndex\n        to produce DataFrame.\n    DataFrame.melt : Unpivot a DataFrame from wide format to long format.\n    DataFrame.explode : Explode a DataFrame from list-like\n        columns to long format.\n\n    Notes\n    -----\n    This routine will explode list-likes including lists, tuples,\n    Series, and np.ndarray. The result dtype of the subset rows will\n    be object. Scalars will be returned unchanged. Empty list-likes will\n    result in a np.nan for that row.\n\n    Examples\n    --------\n    >>> s = pd.Series([[1, 2, 3], 'foo', [], [3, 4]])\n    >>> s\n    0    [1, 2, 3]\n    1          foo\n    2           []\n    3       [3, 4]\n    dtype: object\n\n    >>> s.explode()\n    0      1\n    0      2\n    0      3\n    1    foo\n    2    NaN\n    3      3\n    3      4\n    dtype: object\n    \"\"\"\n    if not len(self) or not is_object_dtype(self):\n        return self.copy()\n\n    values, counts = reshape.explode(np.asarray(self.array))\n\n    result = Series(values, index=self.index.repeat(counts), name=self.name)\n    return result",
                                "signature": "explode(self) -> 'Series'"
                            },
                            {
                                "code": "def unstack(self, level=-1, fill_value=None):\n    \"\"\"\n    Unstack, also known as pivot, Series with MultiIndex to produce DataFrame.\n    The level involved will automatically get sorted.\n\n    Parameters\n    ----------\n    level : int, str, or list of these, default last level\n        Level(s) to unstack, can pass level name.\n    fill_value : scalar value, default None\n        Value to use when replacing NaN values.\n\n    Returns\n    -------\n    DataFrame\n        Unstacked Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4],\n    ...               index=pd.MultiIndex.from_product([['one', 'two'],\n    ...                                                 ['a', 'b']]))\n    >>> s\n    one  a    1\n         b    2\n    two  a    3\n         b    4\n    dtype: int64\n\n    >>> s.unstack(level=-1)\n         a  b\n    one  1  2\n    two  3  4\n\n    >>> s.unstack(level=0)\n       one  two\n    a    1    3\n    b    2    4\n    \"\"\"\n    from pandas.core.reshape.reshape import unstack\n\n    return unstack(self, level, fill_value)",
                                "signature": "unstack(self, level=-1, fill_value=None)"
                            },
                            {
                                "code": "def map(self, arg, na_action=None) -> \"Series\":\n    \"\"\"\n    Map values of Series according to input correspondence.\n\n    Used for substituting each value in a Series with another value,\n    that may be derived from a function, a ``dict`` or\n    a :class:`Series`.\n\n    Parameters\n    ----------\n    arg : function, collections.abc.Mapping subclass or Series\n        Mapping correspondence.\n    na_action : {None, 'ignore'}, default None\n        If 'ignore', propagate NaN values, without passing them to the\n        mapping correspondence.\n\n    Returns\n    -------\n    Series\n        Same index as caller.\n\n    See Also\n    --------\n    Series.apply : For applying more complex functions on a Series.\n    DataFrame.apply : Apply a function row-/column-wise.\n    DataFrame.applymap : Apply a function elementwise on a whole DataFrame.\n\n    Notes\n    -----\n    When ``arg`` is a dictionary, values in Series that are not in the\n    dictionary (as keys) are converted to ``NaN``. However, if the\n    dictionary is a ``dict`` subclass that defines ``__missing__`` (i.e.\n    provides a method for default values), then this default is used\n    rather than ``NaN``.\n\n    Examples\n    --------\n    >>> s = pd.Series(['cat', 'dog', np.nan, 'rabbit'])\n    >>> s\n    0      cat\n    1      dog\n    2      NaN\n    3   rabbit\n    dtype: object\n\n    ``map`` accepts a ``dict`` or a ``Series``. Values that are not found\n    in the ``dict`` are converted to ``NaN``, unless the dict has a default\n    value (e.g. ``defaultdict``):\n\n    >>> s.map({'cat': 'kitten', 'dog': 'puppy'})\n    0   kitten\n    1    puppy\n    2      NaN\n    3      NaN\n    dtype: object\n\n    It also accepts a function:\n\n    >>> s.map('I am a {}'.format)\n    0       I am a cat\n    1       I am a dog\n    2       I am a nan\n    3    I am a rabbit\n    dtype: object\n\n    To avoid applying the function to missing values (and keep them as\n    ``NaN``) ``na_action='ignore'`` can be used:\n\n    >>> s.map('I am a {}'.format, na_action='ignore')\n    0     I am a cat\n    1     I am a dog\n    2            NaN\n    3  I am a rabbit\n    dtype: object\n    \"\"\"\n    new_values = super()._map_values(arg, na_action=na_action)\n    return self._constructor(new_values, index=self.index).__finalize__(self)",
                                "signature": "map(self, arg, na_action=None) -> 'Series'"
                            },
                            {
                                "code": "def _gotitem(self, key, ndim, subset=None) -> \"Series\":\n    \"\"\"\n    Sub-classes to define. Return a sliced object.\n\n    Parameters\n    ----------\n    key : string / list of selections\n    ndim : 1,2\n        Requested ndim of result.\n    subset : object, default None\n        Subset to act on.\n    \"\"\"\n    return self",
                                "signature": "_gotitem(self, key, ndim, subset=None) -> 'Series'"
                            },
                            {
                                "code": "@Substitution(\n    see_also=_agg_see_also_doc,\n    examples=_agg_examples_doc,\n    versionadded=\"\\n.. versionadded:: 0.20.0\\n\",\n    **_shared_doc_kwargs,\n)\n@Appender(generic._shared_docs[\"aggregate\"])\ndef aggregate(self, func, axis=0, *args, **kwargs):\n    # Validate the axis parameter\n    self._get_axis_number(axis)\n    result, how = self._aggregate(func, *args, **kwargs)\n    if result is None:\n\n        # we can be called from an inner function which\n        # passes this meta-data\n        kwargs.pop(\"_axis\", None)\n        kwargs.pop(\"_level\", None)\n\n        # try a regular apply, this evaluates lambdas\n        # row-by-row; however if the lambda is expected a Series\n        # expression, e.g.: lambda x: x-x.quantile(0.25)\n        # this will fail, so we can try a vectorized evaluation\n\n        # we cannot FIRST try the vectorized evaluation, because\n        # then .agg and .apply would have different semantics if the\n        # operation is actually defined on the Series, e.g. str\n        try:\n            result = self.apply(func, *args, **kwargs)\n        except (ValueError, AttributeError, TypeError):\n            result = func(self, *args, **kwargs)\n\n    return result",
                                "signature": "aggregate(self, func, axis=0, *args, **kwargs)"
                            },
                            {
                                "code": "@Appender(generic._shared_docs[\"transform\"] % _shared_doc_kwargs)\ndef transform(self, func, axis=0, *args, **kwargs):\n    # Validate the axis parameter\n    self._get_axis_number(axis)\n    return super().transform(func, *args, **kwargs)",
                                "signature": "transform(self, func, axis=0, *args, **kwargs)"
                            },
                            {
                                "code": "def apply(self, func, convert_dtype=True, args=(), **kwds):\n    \"\"\"\n    Invoke function on values of Series.\n\n    Can be ufunc (a NumPy function that applies to the entire Series)\n    or a Python function that only works on single values.\n\n    Parameters\n    ----------\n    func : function\n        Python function or NumPy ufunc to apply.\n    convert_dtype : bool, default True\n        Try to find better dtype for elementwise function results. If\n        False, leave as dtype=object.\n    args : tuple\n        Positional arguments passed to func after the series value.\n    **kwds\n        Additional keyword arguments passed to func.\n\n    Returns\n    -------\n    Series or DataFrame\n        If func returns a Series object the result will be a DataFrame.\n\n    See Also\n    --------\n    Series.map: For element-wise operations.\n    Series.agg: Only perform aggregating type operations.\n    Series.transform: Only perform transforming type operations.\n\n    Examples\n    --------\n    Create a series with typical summer temperatures for each city.\n\n    >>> s = pd.Series([20, 21, 12],\n    ...               index=['London', 'New York', 'Helsinki'])\n    >>> s\n    London      20\n    New York    21\n    Helsinki    12\n    dtype: int64\n\n    Square the values by defining a function and passing it as an\n    argument to ``apply()``.\n\n    >>> def square(x):\n    ...     return x ** 2\n    >>> s.apply(square)\n    London      400\n    New York    441\n    Helsinki    144\n    dtype: int64\n\n    Square the values by passing an anonymous function as an\n    argument to ``apply()``.\n\n    >>> s.apply(lambda x: x ** 2)\n    London      400\n    New York    441\n    Helsinki    144\n    dtype: int64\n\n    Define a custom function that needs additional positional\n    arguments and pass these additional arguments using the\n    ``args`` keyword.\n\n    >>> def subtract_custom_value(x, custom_value):\n    ...     return x - custom_value\n\n    >>> s.apply(subtract_custom_value, args=(5,))\n    London      15\n    New York    16\n    Helsinki     7\n    dtype: int64\n\n    Define a custom function that takes keyword arguments\n    and pass these arguments to ``apply``.\n\n    >>> def add_custom_values(x, **kwargs):\n    ...     for month in kwargs:\n    ...         x += kwargs[month]\n    ...     return x\n\n    >>> s.apply(add_custom_values, june=30, july=20, august=25)\n    London      95\n    New York    96\n    Helsinki    87\n    dtype: int64\n\n    Use a function from the Numpy library.\n\n    >>> s.apply(np.log)\n    London      2.995732\n    New York    3.044522\n    Helsinki    2.484907\n    dtype: float64\n    \"\"\"\n    if len(self) == 0:\n        return self._constructor(dtype=self.dtype, index=self.index).__finalize__(\n            self\n        )\n\n    # dispatch to agg\n    if isinstance(func, (list, dict)):\n        return self.aggregate(func, *args, **kwds)\n\n    # if we are a string, try to dispatch\n    if isinstance(func, str):\n        return self._try_aggregate_string_function(func, *args, **kwds)\n\n    # handle ufuncs and lambdas\n    if kwds or args and not isinstance(func, np.ufunc):\n\n        def f(x):\n            return func(x, *args, **kwds)\n\n    else:\n        f = func\n\n    with np.errstate(all=\"ignore\"):\n        if isinstance(f, np.ufunc):\n            return f(self)\n\n        # row-wise access\n        if is_extension_array_dtype(self.dtype) and hasattr(self._values, \"map\"):\n            # GH#23179 some EAs do not have `map`\n            mapped = self._values.map(f)\n        else:\n            values = self.astype(object).values\n            mapped = lib.map_infer(values, f, convert=convert_dtype)\n\n    if len(mapped) and isinstance(mapped[0], Series):\n        # GH 25959 use pd.array instead of tolist\n        # so extension arrays can be used\n        return self._constructor_expanddim(pd.array(mapped), index=self.index)\n    else:\n        return self._constructor(mapped, index=self.index).__finalize__(self)",
                                "signature": "apply(self, func, convert_dtype=True, args=(), **kwds)"
                            },
                            {
                                "code": "def _reduce(\n    self, op, name, axis=0, skipna=True, numeric_only=None, filter_type=None, **kwds\n):\n    \"\"\"\n    Perform a reduction operation.\n\n    If we have an ndarray as a value, then simply perform the operation,\n    otherwise delegate to the object.\n    \"\"\"\n    delegate = self._values\n\n    if axis is not None:\n        self._get_axis_number(axis)\n\n    if isinstance(delegate, Categorical):\n        return delegate._reduce(name, skipna=skipna, **kwds)\n    elif isinstance(delegate, ExtensionArray):\n        # dispatch to ExtensionArray interface\n        return delegate._reduce(name, skipna=skipna, **kwds)\n    elif is_datetime64_dtype(delegate):\n        # use DatetimeIndex implementation to handle skipna correctly\n        delegate = DatetimeIndex(delegate)\n    elif is_timedelta64_dtype(delegate) and hasattr(TimedeltaIndex, name):\n        # use TimedeltaIndex to handle skipna correctly\n        # TODO: remove hasattr check after TimedeltaIndex has `std` method\n        delegate = TimedeltaIndex(delegate)\n\n    # dispatch to numpy arrays\n    elif isinstance(delegate, np.ndarray):\n        if numeric_only:\n            raise NotImplementedError(\n                f\"Series.{name} does not implement numeric_only.\"\n            )\n        with np.errstate(all=\"ignore\"):\n            return op(delegate, skipna=skipna, **kwds)\n\n    # TODO(EA) dispatch to Index\n    # remove once all internals extension types are\n    # moved to ExtensionArrays\n    return delegate._reduce(\n        op=op,\n        name=name,\n        axis=axis,\n        skipna=skipna,\n        numeric_only=numeric_only,\n        filter_type=filter_type,\n        **kwds,\n    )",
                                "signature": "_reduce(self, op, name, axis=0, skipna=True, numeric_only=None, filter_type=None, **kwds)"
                            },
                            {
                                "code": "def _reindex_indexer(self, new_index, indexer, copy):\n    if indexer is None:\n        if copy:\n            return self.copy()\n        return self\n\n    new_values = algorithms.take_1d(\n        self._values, indexer, allow_fill=True, fill_value=None\n    )\n    return self._constructor(new_values, index=new_index)",
                                "signature": "_reindex_indexer(self, new_index, indexer, copy)"
                            },
                            {
                                "code": "def _needs_reindex_multi(self, axes, method, level):\n    \"\"\"\n    Check if we do need a multi reindex; this is for compat with\n    higher dims.\n    \"\"\"\n    return False",
                                "signature": "_needs_reindex_multi(self, axes, method, level)"
                            },
                            {
                                "code": "@Appender(generic._shared_docs[\"align\"] % _shared_doc_kwargs)\ndef align(\n    self,\n    other,\n    join=\"outer\",\n    axis=None,\n    level=None,\n    copy=True,\n    fill_value=None,\n    method=None,\n    limit=None,\n    fill_axis=0,\n    broadcast_axis=None,\n):\n    return super().align(\n        other,\n        join=join,\n        axis=axis,\n        level=level,\n        copy=copy,\n        fill_value=fill_value,\n        method=method,\n        limit=limit,\n        fill_axis=fill_axis,\n        broadcast_axis=broadcast_axis,\n    )",
                                "signature": "align(self, other, join='outer', axis=None, level=None, copy=True, fill_value=None, method=None, limit=None, fill_axis=0, broadcast_axis=None)"
                            },
                            {
                                "code": "def rename(\n    self,\n    index=None,\n    *,\n    axis=None,\n    copy=True,\n    inplace=False,\n    level=None,\n    errors=\"ignore\",\n):\n    \"\"\"\n    Alter Series index labels or name.\n\n    Function / dict values must be unique (1-to-1). Labels not contained in\n    a dict / Series will be left as-is. Extra labels listed don't throw an\n    error.\n\n    Alternatively, change ``Series.name`` with a scalar value.\n\n    See the :ref:`user guide <basics.rename>` for more.\n\n    Parameters\n    ----------\n    axis : {0 or \"index\"}\n        Unused. Accepted for compatability with DataFrame method only.\n    index : scalar, hashable sequence, dict-like or function, optional\n        Functions or dict-like are transformations to apply to\n        the index.\n        Scalar or hashable sequence-like will alter the ``Series.name``\n        attribute.\n\n    **kwargs\n        Additional keyword arguments passed to the function. Only the\n        \"inplace\" keyword is used.\n\n    Returns\n    -------\n    Series\n        Series with index labels or name altered.\n\n    See Also\n    --------\n    DataFrame.rename : Corresponding DataFrame method.\n    Series.rename_axis : Set the name of the axis.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3])\n    >>> s\n    0    1\n    1    2\n    2    3\n    dtype: int64\n    >>> s.rename(\"my_name\")  # scalar, changes Series.name\n    0    1\n    1    2\n    2    3\n    Name: my_name, dtype: int64\n    >>> s.rename(lambda x: x ** 2)  # function, changes labels\n    0    1\n    1    2\n    4    3\n    dtype: int64\n    >>> s.rename({1: 3, 2: 5})  # mapping, changes labels\n    0    1\n    3    2\n    5    3\n    dtype: int64\n    \"\"\"\n    if callable(index) or is_dict_like(index):\n        return super().rename(\n            index, copy=copy, inplace=inplace, level=level, errors=errors\n        )\n    else:\n        return self._set_name(index, inplace=inplace)",
                                "signature": "rename(self, index=None)"
                            },
                            {
                                "code": "@Appender(\n    \"\"\"\n    >>> s = pd.Series([1, 2, 3])\n    >>> s\n    0    1\n    1    2\n    2    3\n    dtype: int64\n\n    >>> s.set_axis(['a', 'b', 'c'], axis=0)\n    a    1\n    b    2\n    c    3\n    dtype: int64\n\"\"\"\n)\n@Substitution(\n    **_shared_doc_kwargs,\n    extended_summary_sub=\"\",\n    axis_description_sub=\"\",\n    see_also_sub=\"\",\n)\n@Appender(generic.NDFrame.set_axis.__doc__)\ndef set_axis(self, labels, axis=0, inplace=False):\n    return super().set_axis(labels, axis=axis, inplace=inplace)",
                                "signature": "set_axis(self, labels, axis=0, inplace=False)"
                            },
                            {
                                "code": "@Substitution(**_shared_doc_kwargs)\n@Appender(generic.NDFrame.reindex.__doc__)\ndef reindex(self, index=None, **kwargs):\n    return super().reindex(index=index, **kwargs)",
                                "signature": "reindex(self, index=None, **kwargs)"
                            },
                            {
                                "code": "def drop(\n    self,\n    labels=None,\n    axis=0,\n    index=None,\n    columns=None,\n    level=None,\n    inplace=False,\n    errors=\"raise\",\n) -> \"Series\":\n    \"\"\"\n    Return Series with specified index labels removed.\n\n    Remove elements of a Series based on specifying the index labels.\n    When using a multi-index, labels on different levels can be removed\n    by specifying the level.\n\n    Parameters\n    ----------\n    labels : single label or list-like\n        Index labels to drop.\n    axis : 0, default 0\n        Redundant for application on Series.\n    index : single label or list-like\n        Redundant for application on Series, but 'index' can be used instead\n        of 'labels'.\n\n        .. versionadded:: 0.21.0\n    columns : single label or list-like\n        No change is made to the Series; use 'index' or 'labels' instead.\n\n        .. versionadded:: 0.21.0\n    level : int or level name, optional\n        For MultiIndex, level for which the labels will be removed.\n    inplace : bool, default False\n        If True, do operation inplace and return None.\n    errors : {'ignore', 'raise'}, default 'raise'\n        If 'ignore', suppress error and only existing labels are dropped.\n\n    Returns\n    -------\n    Series\n        Series with specified index labels removed.\n\n    Raises\n    ------\n    KeyError\n        If none of the labels are found in the index.\n\n    See Also\n    --------\n    Series.reindex : Return only specified index labels of Series.\n    Series.dropna : Return series without null values.\n    Series.drop_duplicates : Return Series with duplicate values removed.\n    DataFrame.drop : Drop specified labels from rows or columns.\n\n    Examples\n    --------\n    >>> s = pd.Series(data=np.arange(3), index=['A', 'B', 'C'])\n    >>> s\n    A  0\n    B  1\n    C  2\n    dtype: int64\n\n    Drop labels B en C\n\n    >>> s.drop(labels=['B', 'C'])\n    A  0\n    dtype: int64\n\n    Drop 2nd level label in MultiIndex Series\n\n    >>> midx = pd.MultiIndex(levels=[['lama', 'cow', 'falcon'],\n    ...                              ['speed', 'weight', 'length']],\n    ...                      codes=[[0, 0, 0, 1, 1, 1, 2, 2, 2],\n    ...                             [0, 1, 2, 0, 1, 2, 0, 1, 2]])\n    >>> s = pd.Series([45, 200, 1.2, 30, 250, 1.5, 320, 1, 0.3],\n    ...               index=midx)\n    >>> s\n    lama    speed      45.0\n            weight    200.0\n            length      1.2\n    cow     speed      30.0\n            weight    250.0\n            length      1.5\n    falcon  speed     320.0\n            weight      1.0\n            length      0.3\n    dtype: float64\n\n    >>> s.drop(labels='weight', level=1)\n    lama    speed      45.0\n            length      1.2\n    cow     speed      30.0\n            length      1.5\n    falcon  speed     320.0\n            length      0.3\n    dtype: float64\n    \"\"\"\n    return super().drop(\n        labels=labels,\n        axis=axis,\n        index=index,\n        columns=columns,\n        level=level,\n        inplace=inplace,\n        errors=errors,\n    )",
                                "signature": "drop(self, labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors='raise') -> 'Series'"
                            },
                            {
                                "code": "@Substitution(**_shared_doc_kwargs)\n@Appender(generic.NDFrame.fillna.__doc__)\ndef fillna(\n    self,\n    value=None,\n    method=None,\n    axis=None,\n    inplace=False,\n    limit=None,\n    downcast=None,\n) -> Optional[\"Series\"]:\n    return super().fillna(\n        value=value,\n        method=method,\n        axis=axis,\n        inplace=inplace,\n        limit=limit,\n        downcast=downcast,\n    )",
                                "signature": "fillna(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None) -> Optional['Series']"
                            },
                            {
                                "code": "@Appender(generic._shared_docs[\"replace\"] % _shared_doc_kwargs)\ndef replace(\n    self,\n    to_replace=None,\n    value=None,\n    inplace=False,\n    limit=None,\n    regex=False,\n    method=\"pad\",\n):\n    return super().replace(\n        to_replace=to_replace,\n        value=value,\n        inplace=inplace,\n        limit=limit,\n        regex=regex,\n        method=method,\n    )",
                                "signature": "replace(self, to_replace=None, value=None, inplace=False, limit=None, regex=False, method='pad')"
                            },
                            {
                                "code": "@Appender(generic._shared_docs[\"shift\"] % _shared_doc_kwargs)\ndef shift(self, periods=1, freq=None, axis=0, fill_value=None) -> \"Series\":\n    return super().shift(\n        periods=periods, freq=freq, axis=axis, fill_value=fill_value\n    )",
                                "signature": "shift(self, periods=1, freq=None, axis=0, fill_value=None) -> 'Series'"
                            },
                            {
                                "code": "def memory_usage(self, index=True, deep=False):\n    \"\"\"\n    Return the memory usage of the Series.\n\n    The memory usage can optionally include the contribution of\n    the index and of elements of `object` dtype.\n\n    Parameters\n    ----------\n    index : bool, default True\n        Specifies whether to include the memory usage of the Series index.\n    deep : bool, default False\n        If True, introspect the data deeply by interrogating\n        `object` dtypes for system-level memory consumption, and include\n        it in the returned value.\n\n    Returns\n    -------\n    int\n        Bytes of memory consumed.\n\n    See Also\n    --------\n    numpy.ndarray.nbytes : Total bytes consumed by the elements of the\n        array.\n    DataFrame.memory_usage : Bytes consumed by a DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series(range(3))\n    >>> s.memory_usage()\n    152\n\n    Not including the index gives the size of the rest of the data, which\n    is necessarily smaller:\n\n    >>> s.memory_usage(index=False)\n    24\n\n    The memory footprint of `object` values is ignored by default:\n\n    >>> s = pd.Series([\"a\", \"b\"])\n    >>> s.values\n    array(['a', 'b'], dtype=object)\n    >>> s.memory_usage()\n    144\n    >>> s.memory_usage(deep=True)\n    260\n    \"\"\"\n    v = super().memory_usage(deep=deep)\n    if index:\n        v += self.index.memory_usage(deep=deep)\n    return v",
                                "signature": "memory_usage(self, index=True, deep=False)"
                            },
                            {
                                "code": "def isin(self, values) -> \"Series\":\n    \"\"\"\n    Check whether `values` are contained in Series.\n\n    Return a boolean Series showing whether each element in the Series\n    matches an element in the passed sequence of `values` exactly.\n\n    Parameters\n    ----------\n    values : set or list-like\n        The sequence of values to test. Passing in a single string will\n        raise a ``TypeError``. Instead, turn a single string into a\n        list of one element.\n\n    Returns\n    -------\n    Series\n        Series of booleans indicating if each element is in values.\n\n    Raises\n    ------\n    TypeError\n      * If `values` is a string\n\n    See Also\n    --------\n    DataFrame.isin : Equivalent method on DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama',\n    ...                'hippo'], name='animal')\n    >>> s.isin(['cow', 'lama'])\n    0     True\n    1     True\n    2     True\n    3    False\n    4     True\n    5    False\n    Name: animal, dtype: bool\n\n    Passing a single string as ``s.isin('lama')`` will raise an error. Use\n    a list of one element instead:\n\n    >>> s.isin(['lama'])\n    0     True\n    1    False\n    2     True\n    3    False\n    4     True\n    5    False\n    Name: animal, dtype: bool\n    \"\"\"\n    result = algorithms.isin(self, values)\n    return self._constructor(result, index=self.index).__finalize__(self)",
                                "signature": "isin(self, values) -> 'Series'"
                            },
                            {
                                "code": "def between(self, left, right, inclusive=True) -> \"Series\":\n    \"\"\"\n    Return boolean Series equivalent to left <= series <= right.\n\n    This function returns a boolean vector containing `True` wherever the\n    corresponding Series element is between the boundary values `left` and\n    `right`. NA values are treated as `False`.\n\n    Parameters\n    ----------\n    left : scalar or list-like\n        Left boundary.\n    right : scalar or list-like\n        Right boundary.\n    inclusive : bool, default True\n        Include boundaries.\n\n    Returns\n    -------\n    Series\n        Series representing whether each element is between left and\n        right (inclusive).\n\n    See Also\n    --------\n    Series.gt : Greater than of series and other.\n    Series.lt : Less than of series and other.\n\n    Notes\n    -----\n    This function is equivalent to ``(left <= ser) & (ser <= right)``\n\n    Examples\n    --------\n    >>> s = pd.Series([2, 0, 4, 8, np.nan])\n\n    Boundary values are included by default:\n\n    >>> s.between(1, 4)\n    0     True\n    1    False\n    2     True\n    3    False\n    4    False\n    dtype: bool\n\n    With `inclusive` set to ``False`` boundary values are excluded:\n\n    >>> s.between(1, 4, inclusive=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    4    False\n    dtype: bool\n\n    `left` and `right` can be any scalar value:\n\n    >>> s = pd.Series(['Alice', 'Bob', 'Carol', 'Eve'])\n    >>> s.between('Anna', 'Daniel')\n    0    False\n    1     True\n    2     True\n    3    False\n    dtype: bool\n    \"\"\"\n    if inclusive:\n        lmask = self >= left\n        rmask = self <= right\n    else:\n        lmask = self > left\n        rmask = self < right\n\n    return lmask & rmask",
                                "signature": "between(self, left, right, inclusive=True) -> 'Series'"
                            },
                            {
                                "code": "def _convert_dtypes(\n    self: ABCSeries,\n    infer_objects: bool = True,\n    convert_string: bool = True,\n    convert_integer: bool = True,\n    convert_boolean: bool = True,\n) -> \"Series\":\n    input_series = self\n    if infer_objects:\n        input_series = input_series.infer_objects()\n        if is_object_dtype(input_series):\n            input_series = input_series.copy()\n\n    if convert_string or convert_integer or convert_boolean:\n        inferred_dtype = convert_dtypes(\n            input_series._values, convert_string, convert_integer, convert_boolean\n        )\n        try:\n            result = input_series.astype(inferred_dtype)\n        except TypeError:\n            result = input_series.copy()\n    else:\n        result = input_series.copy()\n    return result",
                                "signature": "_convert_dtypes(self: ABCSeries, infer_objects: bool=True, convert_string: bool=True, convert_integer: bool=True, convert_boolean: bool=True) -> 'Series'"
                            },
                            {
                                "code": "@Appender(generic._shared_docs[\"isna\"] % _shared_doc_kwargs)\ndef isna(self) -> \"Series\":\n    return super().isna()",
                                "signature": "isna(self) -> 'Series'"
                            },
                            {
                                "code": "@Appender(generic._shared_docs[\"isna\"] % _shared_doc_kwargs)\ndef isnull(self) -> \"Series\":\n    return super().isnull()",
                                "signature": "isnull(self) -> 'Series'"
                            },
                            {
                                "code": "@Appender(generic._shared_docs[\"notna\"] % _shared_doc_kwargs)\ndef notna(self) -> \"Series\":\n    return super().notna()",
                                "signature": "notna(self) -> 'Series'"
                            },
                            {
                                "code": "@Appender(generic._shared_docs[\"notna\"] % _shared_doc_kwargs)\ndef notnull(self) -> \"Series\":\n    return super().notnull()",
                                "signature": "notnull(self) -> 'Series'"
                            },
                            {
                                "code": "def dropna(self, axis=0, inplace=False, how=None):\n    \"\"\"\n    Return a new Series with missing values removed.\n\n    See the :ref:`User Guide <missing_data>` for more on which values are\n    considered missing, and how to work with missing data.\n\n    Parameters\n    ----------\n    axis : {0 or 'index'}, default 0\n        There is only one axis to drop values from.\n    inplace : bool, default False\n        If True, do operation inplace and return None.\n    how : str, optional\n        Not in use. Kept for compatibility.\n\n    Returns\n    -------\n    Series\n        Series with NA entries dropped from it.\n\n    See Also\n    --------\n    Series.isna: Indicate missing values.\n    Series.notna : Indicate existing (non-missing) values.\n    Series.fillna : Replace missing values.\n    DataFrame.dropna : Drop rows or columns which contain NA values.\n    Index.dropna : Drop missing indices.\n\n    Examples\n    --------\n    >>> ser = pd.Series([1., 2., np.nan])\n    >>> ser\n    0    1.0\n    1    2.0\n    2    NaN\n    dtype: float64\n\n    Drop NA values from a Series.\n\n    >>> ser.dropna()\n    0    1.0\n    1    2.0\n    dtype: float64\n\n    Keep the Series with valid entries in the same variable.\n\n    >>> ser.dropna(inplace=True)\n    >>> ser\n    0    1.0\n    1    2.0\n    dtype: float64\n\n    Empty strings are not considered NA values. ``None`` is considered an\n    NA value.\n\n    >>> ser = pd.Series([np.NaN, 2, pd.NaT, '', None, 'I stay'])\n    >>> ser\n    0       NaN\n    1         2\n    2       NaT\n    3\n    4      None\n    5    I stay\n    dtype: object\n    >>> ser.dropna()\n    1         2\n    3\n    5    I stay\n    dtype: object\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    # Validate the axis parameter\n    self._get_axis_number(axis or 0)\n\n    if self._can_hold_na:\n        result = remove_na_arraylike(self)\n        if inplace:\n            self._update_inplace(result)\n        else:\n            return result\n    else:\n        if inplace:\n            # do nothing\n            pass\n        else:\n            return self.copy()",
                                "signature": "dropna(self, axis=0, inplace=False, how=None)"
                            },
                            {
                                "code": "def to_timestamp(self, freq=None, how=\"start\", copy=True) -> \"Series\":\n    \"\"\"\n    Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n\n    Parameters\n    ----------\n    freq : str, default frequency of PeriodIndex\n        Desired frequency.\n    how : {'s', 'e', 'start', 'end'}\n        Convention for converting period to timestamp; start of period\n        vs. end.\n    copy : bool, default True\n        Whether or not to return a copy.\n\n    Returns\n    -------\n    Series with DatetimeIndex\n    \"\"\"\n    new_values = self._values\n    if copy:\n        new_values = new_values.copy()\n\n    assert isinstance(self.index, (ABCDatetimeIndex, ABCPeriodIndex))\n    new_index = self.index.to_timestamp(freq=freq, how=how)\n    return self._constructor(new_values, index=new_index).__finalize__(self)",
                                "signature": "to_timestamp(self, freq=None, how='start', copy=True) -> 'Series'"
                            },
                            {
                                "code": "def to_period(self, freq=None, copy=True) -> \"Series\":\n    \"\"\"\n    Convert Series from DatetimeIndex to PeriodIndex with desired\n    frequency (inferred from index if not passed).\n\n    Parameters\n    ----------\n    freq : str, default None\n        Frequency associated with the PeriodIndex.\n    copy : bool, default True\n        Whether or not to return a copy.\n\n    Returns\n    -------\n    Series\n        Series with index converted to PeriodIndex.\n    \"\"\"\n    new_values = self._values\n    if copy:\n        new_values = new_values.copy()\n\n    assert isinstance(self.index, ABCDatetimeIndex)\n    new_index = self.index.to_period(freq=freq)\n    return self._constructor(new_values, index=new_index).__finalize__(self)",
                                "signature": "to_period(self, freq=None, copy=True) -> 'Series'"
                            }
                        ]
                    }
                ]
            },
            "variables_in_file": {
                "TYPE_CHECKING": [
                    98
                ],
                "__all__": [
                    102
                ],
                "_shared_doc_kwargs": [
                    3904,
                    4033,
                    4418,
                    1638,
                    104,
                    4168,
                    3693,
                    3662,
                    4148,
                    4406,
                    4024,
                    4410,
                    4187,
                    4414
                ],
                "dict": [
                    104,
                    3802,
                    1502,
                    1182
                ],
                "len": [
                    128,
                    2945,
                    899,
                    260,
                    2436,
                    1297,
                    1302,
                    2969,
                    3481,
                    927,
                    677,
                    808,
                    1705,
                    1709,
                    303,
                    2227,
                    309,
                    566,
                    311,
                    696,
                    312,
                    3146,
                    3796,
                    2266,
                    2933,
                    3830,
                    2938,
                    2943
                ],
                "self": [
                    1026,
                    1030,
                    1031,
                    1032,
                    1037,
                    1038,
                    527,
                    1040,
                    532,
                    1044,
                    2586,
                    1051,
                    1563,
                    1565,
                    2587,
                    2589,
                    544,
                    2590,
                    3105,
                    3106,
                    3611,
                    2598,
                    2599,
                    2088,
                    1065,
                    1066,
                    1535,
                    1068,
                    1580,
                    1070,
                    2091,
                    560,
                    1072,
                    3625,
                    1076,
                    566,
                    1080,
                    4500,
                    3132,
                    1085,
                    1086,
                    3142,
                    3143,
                    2123,
                    2124,
                    3149,
                    3151,
                    3667,
                    3668,
                    1111,
                    1113,
                    1114,
                    1115,
                    1119,
                    1121,
                    3484,
                    3685,
                    3687,
                    3178,
                    2670,
                    3182,
                    3482,
                    3185,
                    3696,
                    2675,
                    2676,
                    3187,
                    1654,
                    2679,
                    3188,
                    1657,
                    634,
                    635,
                    636,
                    3189,
                    2686,
                    2175,
                    128,
                    129,
                    2688,
                    2689,
                    2691,
                    2693,
                    646,
                    2182,
                    2183,
                    2696,
                    650,
                    2697,
                    3486,
                    4244,
                    661,
                    4508,
                    666,
                    1183,
                    1184,
                    1185,
                    1695,
                    1698,
                    1700,
                    1701,
                    2731,
                    1708,
                    2732,
                    1710,
                    690,
                    2226,
                    1731,
                    710,
                    4300,
                    4301,
                    3796,
                    3797,
                    3798,
                    3287,
                    2265,
                    219,
                    3803,
                    3807,
                    2785,
                    2788,
                    2789,
                    3820,
                    239,
                    3823,
                    3825,
                    3827,
                    3833,
                    3835,
                    768,
                    3846,
                    3849,
                    1297,
                    786,
                    275,
                    4370,
                    1301,
                    1302,
                    1303,
                    4371,
                    4373,
                    1306,
                    4374,
                    1308,
                    1310,
                    1311,
                    1312,
                    2336,
                    2337,
                    803,
                    4388,
                    805,
                    1318,
                    808,
                    812,
                    814,
                    816,
                    3889,
                    3890,
                    3893,
                    3895,
                    3384,
                    827,
                    1342,
                    1344,
                    1345,
                    328,
                    329,
                    330,
                    841,
                    3404,
                    845,
                    846,
                    2382,
                    3405,
                    849,
                    3406,
                    3407,
                    852,
                    856,
                    858,
                    861,
                    2913,
                    3425,
                    867,
                    2916,
                    3428,
                    879,
                    880,
                    882,
                    2932,
                    2933,
                    887,
                    2938,
                    1403,
                    895,
                    2435,
                    2436,
                    902,
                    391,
                    2439,
                    2444,
                    4495,
                    4497,
                    4498,
                    916,
                    917,
                    918,
                    919,
                    920,
                    2452,
                    410,
                    922,
                    2454,
                    2966,
                    2972,
                    2974,
                    416,
                    3481,
                    418,
                    931,
                    2466,
                    933,
                    422,
                    935,
                    2472,
                    4005,
                    1451,
                    2477,
                    430,
                    946,
                    4531,
                    948,
                    437,
                    4535,
                    952,
                    441,
                    953,
                    954,
                    4536,
                    4537,
                    447,
                    959,
                    960,
                    961,
                    965,
                    1482,
                    3530,
                    4556,
                    1486,
                    4560,
                    4561,
                    4562,
                    981,
                    985,
                    988,
                    989,
                    1500,
                    992,
                    2017,
                    996,
                    997,
                    2020,
                    1000,
                    489,
                    1002,
                    1005,
                    1008,
                    1016,
                    1018,
                    2555,
                    2558,
                    1023
                ],
                "converter": [
                    129,
                    130,
                    132
                ],
                "self.iloc": [
                    920,
                    129
                ],
                "TypeError": [
                    130,
                    1314,
                    293,
                    3686,
                    1007,
                    2927,
                    4400,
                    1653,
                    889,
                    314,
                    2460,
                    446
                ],
                "wrapper.__name__": [
                    132
                ],
                "wrapper": [
                    132,
                    133
                ],
                "converter.__name__": [
                    132
                ],
                "base.IndexOpsMixin": [
                    193,
                    186,
                    140,
                    529
                ],
                "base": [
                    193,
                    2475,
                    140,
                    529,
                    186
                ],
                "generic.NDFrame": [
                    4034,
                    422,
                    328,
                    140,
                    791,
                    4149,
                    183,
                    187,
                    4029
                ],
                "generic": [
                    140,
                    791,
                    422,
                    1447,
                    4149,
                    4406,
                    183,
                    4410,
                    187,
                    4029,
                    4414,
                    3904,
                    4034,
                    4418,
                    328,
                    4168,
                    3664,
                    4187,
                    1638,
                    3693
                ],
                "_typ": [
                    179
                ],
                "_name": [
                    181
                ],
                "Optional": [
                    1449,
                    1450,
                    181,
                    695,
                    440,
                    444,
                    4158
                ],
                "Hashable": [
                    440,
                    444,
                    181,
                    695
                ],
                "_metadata": [
                    182
                ],
                "List": [
                    182,
                    782
                ],
                "str": [
                    1697,
                    643,
                    1417,
                    1449,
                    843,
                    1324,
                    1450,
                    2799,
                    2800,
                    182,
                    4573,
                    3806
                ],
                "_internal_names_set": [
                    183
                ],
                "generic.NDFrame._internal_names_set": [
                    183
                ],
                "_accessors": [
                    184
                ],
                "_deprecations": [
                    185
                ],
                "base.IndexOpsMixin._deprecations": [
                    186
                ],
                "generic.NDFrame._deprecations": [
                    187
                ],
                "frozenset": [
                    188,
                    292
                ],
                "hasnans": [
                    192
                ],
                "property": [
                    192,
                    449,
                    389,
                    1126,
                    425,
                    491,
                    781,
                    432,
                    530,
                    439,
                    378,
                    382
                ],
                "base.IndexOpsMixin.hasnans.func": [
                    193
                ],
                "base.IndexOpsMixin.hasnans": [
                    193
                ],
                "base.IndexOpsMixin.hasnans.__doc__": [
                    193
                ],
                "_data": [
                    195
                ],
                "SingleBlockManager": [
                    195,
                    326,
                    210,
                    211,
                    278,
                    318
                ],
                "div": [
                    196
                ],
                "Callable": [
                    643,
                    196,
                    197
                ],
                "Any": [
                    643,
                    196,
                    197,
                    1485,
                    1455
                ],
                "rdiv": [
                    197
                ],
                "fastpath": [
                    400,
                    409,
                    417,
                    207
                ],
                "isinstance": [
                    2434,
                    259,
                    901,
                    905,
                    1417,
                    3851,
                    268,
                    908,
                    1036,
                    3853,
                    1299,
                    2451,
                    405,
                    278,
                    918,
                    1048,
                    2455,
                    666,
                    2457,
                    924,
                    2583,
                    3865,
                    927,
                    1697,
                    1058,
                    292,
                    294,
                    3112,
                    948,
                    4535,
                    1083,
                    318,
                    3404,
                    4560,
                    210,
                    858,
                    3802,
                    3806,
                    3425,
                    3810,
                    867,
                    3429,
                    3819,
                    1008,
                    241,
                    2672,
                    245,
                    886,
                    3830,
                    888,
                    253,
                    2554,
                    893
                ],
                "data": [
                    256,
                    259,
                    260,
                    268,
                    270,
                    272,
                    273,
                    274,
                    275,
                    278,
                    280,
                    281,
                    290,
                    292,
                    293,
                    294,
                    296,
                    298,
                    301,
                    302,
                    303,
                    304,
                    309,
                    311,
                    318,
                    320,
                    322,
                    324,
                    326,
                    328,
                    210,
                    211,
                    213,
                    215,
                    219,
                    221,
                    353,
                    354,
                    236,
                    237,
                    241,
                    372,
                    245,
                    249,
                    252,
                    253
                ],
                "index": [
                    269,
                    270,
                    272,
                    275,
                    4243,
                    279,
                    280,
                    281,
                    4000,
                    3106,
                    4002,
                    3109,
                    4005,
                    3112,
                    682,
                    3115,
                    300,
                    684,
                    686,
                    303,
                    4141,
                    690,
                    309,
                    3126,
                    3127,
                    312,
                    3135,
                    3139,
                    324,
                    4036,
                    326,
                    710,
                    330,
                    211,
                    214,
                    215,
                    4566,
                    356,
                    360,
                    233,
                    234,
                    372,
                    373,
                    1407
                ],
                "copy": [
                    320,
                    257,
                    321,
                    4002,
                    324,
                    4557,
                    3406,
                    272,
                    3888,
                    3923,
                    212,
                    277,
                    4532,
                    281
                ],
                "data.copy": [
                    322,
                    213
                ],
                "data.index": [
                    280,
                    281,
                    270,
                    215
                ],
                "name": [
                    3852,
                    3855,
                    3859,
                    1562,
                    3868,
                    1565,
                    1308,
                    1318,
                    2598,
                    2599,
                    3878,
                    1581,
                    695,
                    697,
                    443,
                    699,
                    710,
                    329,
                    219,
                    1404
                ],
                "ibase.maybe_extract_name": [
                    219
                ],
                "ibase": [
                    3146,
                    303,
                    1297,
                    2969,
                    2938,
                    219
                ],
                "type": [
                    673,
                    293,
                    646,
                    712,
                    1420,
                    665,
                    219,
                    2460
                ],
                "is_empty_data": [
                    221
                ],
                "dtype": [
                    320,
                    768,
                    1408,
                    324,
                    359,
                    238,
                    239,
                    368,
                    275,
                    276,
                    247,
                    249,
                    635,
                    221,
                    319
                ],
                "warnings.warn": [
                    794,
                    223
                ],
                "warnings": [
                    943,
                    794,
                    942,
                    223
                ],
                "DeprecationWarning": [
                    944,
                    227
                ],
                "ensure_index": [
                    401,
                    234
                ],
                "self._validate_dtype": [
                    239
                ],
                "MultiIndex": [
                    3425,
                    867,
                    3112,
                    1008,
                    241,
                    948,
                    858
                ],
                "NotImplementedError": [
                    242,
                    3867,
                    708
                ],
                "Index": [
                    640,
                    1058,
                    905,
                    908,
                    782,
                    1491,
                    245
                ],
                "data.astype": [
                    320,
                    249
                ],
                "data._values.copy": [
                    256,
                    252
                ],
                "data._values": [
                    256,
                    252
                ],
                "ABCDatetimeIndex": [
                    4560,
                    253,
                    4535
                ],
                "data.tz": [
                    253
                ],
                "np.ndarray": [
                    640,
                    259,
                    905,
                    656,
                    721,
                    3865,
                    2457
                ],
                "np": [
                    768,
                    640,
                    259,
                    905,
                    2445,
                    656,
                    2453,
                    2456,
                    2457,
                    2458,
                    3865,
                    3484,
                    3870,
                    2595,
                    1701,
                    2472,
                    2090,
                    1709,
                    1070,
                    2228,
                    721,
                    2267,
                    3810,
                    2019,
                    3818,
                    3819,
                    368,
                    3184,
                    3188,
                    2933,
                    2681,
                    2687
                ],
                "data.dtype": [
                    260
                ],
                "ValueError": [
                    896,
                    2944,
                    866,
                    962,
                    995,
                    2437,
                    2917,
                    263,
                    2950,
                    3686,
                    2235,
                    1009,
                    2964,
                    949,
                    310,
                    1079,
                    411
                ],
                "ABCSeries": [
                    268,
                    4382
                ],
                "data.reindex": [
                    272
                ],
                "data._data": [
                    273
                ],
                "is_dict_like": [
                    4000,
                    274
                ],
                "self._init_dict": [
                    275
                ],
                "data.index.equals": [
                    281
                ],
                "AssertionError": [
                    2584,
                    1418,
                    284
                ],
                "is_extension_array_dtype": [
                    290,
                    2693,
                    3823
                ],
                "set": [
                    696,
                    292
                ],
                "__name__": [
                    1420,
                    293
                ],
                "ABCSparseArray": [
                    294
                ],
                "data.to_dense": [
                    296
                ],
                "com.maybe_iterable_to_list": [
                    298
                ],
                "com": [
                    993,
                    2017,
                    2088,
                    298,
                    939,
                    2123,
                    878,
                    849,
                    1075,
                    1015,
                    988,
                    1534
                ],
                "is_list_like": [
                    304,
                    2942,
                    301,
                    2181
                ],
                "ibase.default_index": [
                    3146,
                    303,
                    1297,
                    2969,
                    2938
                ],
                "sanitize_array": [
                    324
                ],
                "generic.NDFrame.__init__": [
                    328
                ],
                "self.name": [
                    1344,
                    2689,
                    2182,
                    2183,
                    329,
                    3182,
                    1308,
                    3486
                ],
                "self._set_axis": [
                    330
                ],
                "keys": [
                    360,
                    354,
                    368,
                    362
                ],
                "values": [
                    354,
                    355,
                    996,
                    998,
                    359,
                    362,
                    3178,
                    3179,
                    4300,
                    368,
                    3184,
                    3827,
                    3188,
                    3828,
                    3484,
                    3486
                ],
                "zip": [
                    1482,
                    354,
                    675,
                    687
                ],
                "data.items": [
                    354
                ],
                "list": [
                    355,
                    905,
                    906,
                    876,
                    1299,
                    3802,
                    2554,
                    924
                ],
                "na_value_for_dtype": [
                    2670,
                    359
                ],
                "s": [
                    683,
                    684,
                    367,
                    373,
                    374
                ],
                "create_series_with_explicit_dtype": [
                    367
                ],
                "np.float64": [
                    368
                ],
                "s.reindex": [
                    373
                ],
                "s._data": [
                    374
                ],
                "s.index": [
                    684,
                    374
                ],
                "Series": [
                    2434,
                    675,
                    2583,
                    4584,
                    905,
                    4585,
                    4586,
                    4589,
                    686,
                    3182,
                    2672,
                    4590,
                    3830,
                    2455,
                    1083,
                    380,
                    3486
                ],
                "Type": [
                    379,
                    383
                ],
                "DataFrame": [
                    386
                ],
                "self._data._can_hold_na": [
                    391
                ],
                "self._data": [
                    544,
                    960,
                    418,
                    2788,
                    391,
                    489,
                    430,
                    527,
                    532,
                    437,
                    566,
                    410,
                    1085
                ],
                "_index": [
                    393
                ],
                "bool": [
                    1088,
                    4384,
                    4385,
                    4386,
                    967,
                    2985,
                    395,
                    1644,
                    1645,
                    1646,
                    1647,
                    1648,
                    2798,
                    2801,
                    4383
                ],
                "labels": [
                    416,
                    418,
                    3115,
                    4139,
                    3117,
                    401,
                    403,
                    405,
                    407,
                    410,
                    4031
                ],
                "is_all_dates": [
                    403,
                    404
                ],
                "labels.is_all_dates": [
                    403
                ],
                "DatetimeIndex": [
                    3858,
                    405,
                    407
                ],
                "PeriodIndex": [
                    405
                ],
                "TimedeltaIndex": [
                    3859,
                    405,
                    3862
                ],
                "self._data.set_axis": [
                    418,
                    410
                ],
                "axis": [
                    3848,
                    3849,
                    4495,
                    410,
                    1182,
                    3105,
                    418,
                    3879,
                    808,
                    4140,
                    827,
                    4031,
                    4162,
                    3921,
                    3667,
                    4190,
                    2913,
                    3696,
                    1654,
                    1659
                ],
                "tslibs.OutOfBoundsDatetime": [
                    411
                ],
                "tslibs": [
                    411
                ],
                "object.__setattr__": [
                    416,
                    447
                ],
                "object": [
                    416,
                    3827,
                    447
                ],
                "generic.NDFrame._update_inplace": [
                    422
                ],
                "result": [
                    2177,
                    1794,
                    1795,
                    2178,
                    2179,
                    1414,
                    2182,
                    2183,
                    649,
                    1417,
                    2186,
                    652,
                    653,
                    1420,
                    1424,
                    4498,
                    1427,
                    4500,
                    1430,
                    2966,
                    4502,
                    2969,
                    2972,
                    2974,
                    3486,
                    2336,
                    2337,
                    3487,
                    2596,
                    422,
                    2599,
                    4399,
                    4401,
                    4403,
                    4404,
                    693,
                    702,
                    703,
                    704,
                    709,
                    710,
                    1350,
                    712,
                    1352,
                    714,
                    2123,
                    2124,
                    3143,
                    2126,
                    719,
                    3146,
                    3149,
                    3151,
                    4300,
                    3668,
                    3669,
                    4301,
                    861,
                    863,
                    3428,
                    3429,
                    3430,
                    3431,
                    3685,
                    3687,
                    3689,
                    3182,
                    3184,
                    3185
                ],
                "kwargs": [
                    650,
                    800,
                    422,
                    2087,
                    809,
                    811,
                    812,
                    1451,
                    693,
                    827,
                    4036,
                    2122,
                    3668,
                    3673,
                    3674,
                    2016,
                    3685,
                    3687,
                    3697
                ],
                "self._data.dtype": [
                    437,
                    430
                ],
                "self._name": [
                    441
                ],
                "is_hashable": [
                    445
                ],
                "value": [
                    1031,
                    1032,
                    1038,
                    1044,
                    1051,
                    1066,
                    1068,
                    2477,
                    1070,
                    1072,
                    1080,
                    445,
                    1085,
                    447,
                    4160,
                    4180,
                    1111,
                    1114,
                    1115,
                    1119,
                    992,
                    998,
                    1000,
                    1002,
                    1005,
                    1018,
                    1023
                ],
                "name.setter": [
                    443
                ],
                "self._data.external_values": [
                    489
                ],
                "self._data.internal_values": [
                    527
                ],
                "self._data._block.array_values": [
                    532
                ],
                "self._data._block": [
                    532
                ],
                "Appender": [
                    529,
                    791,
                    1432,
                    1447,
                    4007,
                    2475,
                    1584,
                    4149,
                    4406,
                    4410,
                    4029,
                    4414,
                    3904,
                    4034,
                    4418,
                    4168,
                    1484,
                    3664,
                    4187,
                    1638,
                    3693
                ],
                "base.IndexOpsMixin.array.__doc__": [
                    529
                ],
                "base.IndexOpsMixin.array": [
                    529
                ],
                "ExtensionArray": [
                    640,
                    531,
                    3853
                ],
                "self._data.get_values": [
                    544
                ],
                "self._values.ravel": [
                    560
                ],
                "self._values": [
                    2688,
                    3846,
                    1032,
                    2696,
                    1311,
                    1184,
                    812,
                    2477,
                    560,
                    4531,
                    3893,
                    953,
                    965,
                    3142,
                    841,
                    4556,
                    3406,
                    981,
                    1111,
                    1115,
                    996,
                    3178,
                    3823,
                    3825,
                    2932,
                    635
                ],
                "order": [
                    560,
                    3430
                ],
                "int": [
                    775,
                    776,
                    843,
                    562,
                    829
                ],
                "__finalize__": [
                    2452,
                    3611,
                    1310,
                    1185,
                    2337,
                    814,
                    1710,
                    4537,
                    953,
                    959,
                    2124,
                    4301,
                    3406,
                    4562,
                    3797,
                    3185,
                    3187,
                    634,
                    3835
                ],
                "self._constructor": [
                    2183,
                    2697,
                    2452,
                    2966,
                    3611,
                    1310,
                    1185,
                    2337,
                    814,
                    1710,
                    3895,
                    953,
                    4537,
                    959,
                    710,
                    3143,
                    2124,
                    4301,
                    3406,
                    4562,
                    3797,
                    3185,
                    3187,
                    634,
                    3835
                ],
                "self._values.view": [
                    635
                ],
                "self.index": [
                    2435,
                    2436,
                    1030,
                    1037,
                    1040,
                    786,
                    916,
                    1301,
                    918,
                    919,
                    1302,
                    1303,
                    1306,
                    2586,
                    2966,
                    2589,
                    3486,
                    1183,
                    3611,
                    2337,
                    1698,
                    803,
                    1700,
                    1701,
                    3106,
                    1065,
                    2091,
                    2731,
                    690,
                    948,
                    1076,
                    4535,
                    952,
                    4536,
                    1482,
                    2124,
                    845,
                    3404,
                    3405,
                    4301,
                    4560,
                    4561,
                    3797,
                    856,
                    985,
                    858,
                    1113,
                    1500,
                    861,
                    3835,
                    3425,
                    867,
                    2020,
                    997,
                    4244,
                    3182,
                    879,
                    1008,
                    3185,
                    2675,
                    3188,
                    1016,
                    3833,
                    635,
                    2686
                ],
                "_HANDLED_TYPES": [
                    640
                ],
                "cls": [
                    656,
                    646
                ],
                "ops.maybe_dispatch_ufunc_to_dunder_op": [
                    649
                ],
                "ops": [
                    2593,
                    2598,
                    2599,
                    649,
                    4589,
                    4590,
                    2676
                ],
                "ufunc": [
                    650,
                    693
                ],
                "method": [
                    4161,
                    706,
                    650,
                    715,
                    693,
                    2230,
                    3925,
                    2232,
                    4184,
                    2238
                ],
                "inputs": [
                    672,
                    673,
                    675,
                    650,
                    685,
                    687,
                    658,
                    692,
                    693
                ],
                "NotImplemented": [
                    652,
                    669
                ],
                "no_defer": [
                    656,
                    665
                ],
                "np.ndarray.__array_ufunc__": [
                    656
                ],
                "cls.__array_ufunc__": [
                    656
                ],
                "item": [
                    658,
                    660,
                    661,
                    664,
                    665,
                    666
                ],
                "higher_priority": [
                    659,
                    668
                ],
                "hasattr": [
                    672,
                    3823,
                    3859,
                    660,
                    664
                ],
                "item.__array_priority__": [
                    661
                ],
                "self.__array_priority__": [
                    661
                ],
                "has_array_ufunc": [
                    668,
                    663
                ],
                "__array_ufunc__": [
                    665
                ],
                "self._HANDLED_TYPES": [
                    666
                ],
                "names": [
                    672,
                    697,
                    696
                ],
                "getattr": [
                    672,
                    693
                ],
                "x": [
                    672,
                    673,
                    675,
                    3813,
                    714,
                    686,
                    687,
                    692
                ],
                "types": [
                    673,
                    675,
                    687
                ],
                "tuple": [
                    800,
                    673,
                    867,
                    712,
                    714,
                    685,
                    1008,
                    1299,
                    692,
                    1048,
                    2554,
                    924,
                    893,
                    1182
                ],
                "alignable": [
                    683,
                    682,
                    675,
                    677
                ],
                "t": [
                    675,
                    686,
                    687
                ],
                "issubclass": [
                    675,
                    686
                ],
                "x.reindex": [
                    686
                ],
                "extract_array": [
                    692
                ],
                "lib.is_scalar": [
                    702
                ],
                "lib": [
                    1062,
                    3828,
                    702,
                    911
                ],
                "result.ndim": [
                    704,
                    2178
                ],
                "construct_return": [
                    714,
                    719
                ],
                "np.asarray": [
                    768,
                    3484,
                    2445
                ],
                "self.array": [
                    768,
                    2336,
                    3484,
                    1695
                ],
                "__float__": [
                    774
                ],
                "_coerce_method": [
                    776,
                    774,
                    775
                ],
                "float": [
                    2241,
                    2339,
                    2188,
                    774
                ],
                "__long__": [
                    775
                ],
                "__int__": [
                    776
                ],
                "is_copy": [
                    793
                ],
                "FutureWarning": [
                    797
                ],
                "nv.validate_take": [
                    800
                ],
                "nv": [
                    800,
                    2016,
                    2087,
                    2122,
                    1182
                ],
                "indices": [
                    802,
                    803,
                    808,
                    812,
                    827
                ],
                "ensure_platform_int": [
                    802,
                    3138
                ],
                "new_index": [
                    2697,
                    1297,
                    1303,
                    2586,
                    1306,
                    1311,
                    2591,
                    1185,
                    1183,
                    803,
                    3109,
                    2599,
                    2731,
                    2732,
                    2733,
                    815,
                    3895,
                    952,
                    953,
                    4536,
                    4537,
                    3139,
                    3140,
                    3143,
                    3405,
                    3406,
                    4561,
                    4562,
                    2675,
                    2678,
                    2686
                ],
                "self.index.take": [
                    803
                ],
                "is_categorical_dtype": [
                    2691,
                    805
                ],
                "maybe_convert_indices": [
                    808
                ],
                "self._get_axis": [
                    808
                ],
                "new_values": [
                    2688,
                    2696,
                    2697,
                    3610,
                    3611,
                    1184,
                    1185,
                    812,
                    815,
                    4531,
                    3892,
                    4533,
                    3895,
                    4537,
                    3142,
                    3143,
                    4556,
                    4558,
                    4562,
                    2677,
                    2682
                ],
                "self._values.take": [
                    812,
                    3142
                ],
                "generic.NDFrame.take.__doc__": [
                    791
                ],
                "generic.NDFrame.take": [
                    791
                ],
                "self.take": [
                    827
                ],
                "i": [
                    2017,
                    2018,
                    2020,
                    2088,
                    841,
                    2089,
                    2091,
                    3405
                ],
                "slice": [
                    901,
                    843,
                    1036,
                    886,
                    927
                ],
                "kind": [
                    844,
                    845,
                    2926,
                    3184,
                    3188,
                    3135
                ],
                "slobj": [
                    845,
                    846
                ],
                "self.index._convert_slice_indexer": [
                    1037,
                    845
                ],
                "self._get_values": [
                    931,
                    902,
                    846,
                    880,
                    946,
                    922
                ],
                "key": [
                    899,
                    900,
                    901,
                    902,
                    1030,
                    905,
                    906,
                    908,
                    909,
                    1036,
                    911,
                    1037,
                    1040,
                    1044,
                    917,
                    919,
                    1048,
                    922,
                    1023,
                    924,
                    1051,
                    927,
                    1055,
                    1056,
                    1058,
                    931,
                    1059,
                    933,
                    1060,
                    935,
                    1062,
                    1066,
                    939,
                    1068,
                    1070,
                    1072,
                    946,
                    1075,
                    1076,
                    1079,
                    952,
                    1083,
                    1084,
                    1085,
                    849,
                    851,
                    854,
                    856,
                    1016,
                    988,
                    861,
                    992,
                    867,
                    997,
                    998,
                    999,
                    1002,
                    875,
                    876,
                    1005,
                    878,
                    879,
                    880,
                    1008,
                    882,
                    1015,
                    1013,
                    886,
                    887,
                    888,
                    1018,
                    893,
                    895
                ],
                "com.apply_if_callable": [
                    849,
                    988
                ],
                "Ellipsis": [
                    851,
                    999
                ],
                "key_is_scalar": [
                    873,
                    858,
                    854,
                    855
                ],
                "is_scalar": [
                    1040,
                    854,
                    1055
                ],
                "self.index._convert_scalar_indexer": [
                    856
                ],
                "self.index.get_value": [
                    985,
                    861
                ],
                "InvalidIndexError": [
                    864,
                    1003,
                    1020
                ],
                "KeyError": [
                    866,
                    995,
                    1116
                ],
                "is_iterator": [
                    875
                ],
                "com.is_bool_indexer": [
                    878,
                    1015
                ],
                "check_bool_indexer": [
                    1016,
                    879
                ],
                "self._get_with": [
                    882
                ],
                "self._slice": [
                    887
                ],
                "ABCDataFrame": [
                    888,
                    2434,
                    2451
                ],
                "self._get_values_tuple": [
                    895
                ],
                "key_type": [
                    1059,
                    1062,
                    1064,
                    909,
                    1069,
                    911,
                    915
                ],
                "key.inferred_type": [
                    1059,
                    909
                ],
                "lib.infer_dtype": [
                    1062,
                    911
                ],
                "self.index.is_integer": [
                    916
                ],
                "self.index.is_floating": [
                    916
                ],
                "self.loc": [
                    933,
                    1002,
                    1044,
                    917,
                    1119
                ],
                "IntervalIndex": [
                    918
                ],
                "indexer": [
                    1037,
                    1038,
                    919,
                    920,
                    3109,
                    3116,
                    3887,
                    1076,
                    1077,
                    3893,
                    952,
                    953,
                    1080,
                    3134,
                    960,
                    3138,
                    3139,
                    965,
                    3142
                ],
                "self.index.get_indexer_for": [
                    919
                ],
                "self.reindex": [
                    2439,
                    2732,
                    935
                ],
                "com.any_none": [
                    939
                ],
                "warnings.catch_warnings": [
                    942
                ],
                "warnings.filterwarnings": [
                    943
                ],
                "self.index.get_loc_level": [
                    952
                ],
                "self._data.get_slice": [
                    960
                ],
                "takeable": [
                    980,
                    1110
                ],
                "label": [
                    981,
                    1111,
                    1113,
                    985,
                    1119
                ],
                "cacher_needs_updating": [
                    1025,
                    989
                ],
                "self._check_is_chained_assignment_possible": [
                    989
                ],
                "self._set_with_engine": [
                    992
                ],
                "com.SettingWithCopyError": [
                    993
                ],
                "is_integer": [
                    1040,
                    997
                ],
                "self.index.inferred_type": [
                    1065,
                    997
                ],
                "self._set_with": [
                    1005,
                    1023
                ],
                "_is_unorderable_exception": [
                    1012
                ],
                "e": [
                    1012
                ],
                "IndexError": [
                    1013
                ],
                "self._where": [
                    1018
                ],
                "self._maybe_update_cacher": [
                    1026,
                    2789,
                    1086
                ],
                "loc": [
                    1032,
                    1113,
                    1115,
                    1030
                ],
                "self.index._engine.get_loc": [
                    1030
                ],
                "self.index._engine": [
                    1030
                ],
                "validate_numeric_casting": [
                    1114,
                    1031
                ],
                "self.dtype": [
                    1345,
                    1031,
                    2670,
                    3823,
                    3797,
                    1114
                ],
                "self._set_values": [
                    1068,
                    1070,
                    1038,
                    1080,
                    1051
                ],
                "Exception": [
                    3426,
                    1052,
                    2447
                ],
                "key._values": [
                    1060,
                    1084
                ],
                "self._set_labels": [
                    1072,
                    1066
                ],
                "key.astype": [
                    1070
                ],
                "np.bool_": [
                    1070
                ],
                "com.asarray_tuplesafe": [
                    1075
                ],
                "self.index.get_indexer": [
                    1076
                ],
                "mask": [
                    2786,
                    2788,
                    1703,
                    1704,
                    1705,
                    3179,
                    3181,
                    3183,
                    1077,
                    1078,
                    1079
                ],
                "mask.any": [
                    1704,
                    3181,
                    1078
                ],
                "self._data.setitem": [
                    1085
                ],
                "self.index.get_loc": [
                    1113
                ],
                "nv.validate_repeat": [
                    1182
                ],
                "self.index.repeat": [
                    3486,
                    1183
                ],
                "repeats": [
                    1184,
                    1183
                ],
                "self._values.repeat": [
                    1184
                ],
                "inplace": [
                    4493,
                    1295,
                    4499,
                    4504,
                    1305,
                    2971,
                    3103,
                    1313,
                    4002,
                    4005,
                    1579,
                    1580,
                    4144,
                    3129,
                    4031,
                    4163,
                    3148,
                    1872,
                    4181,
                    2911,
                    2916
                ],
                "validate_bool_kwarg": [
                    1579,
                    4493,
                    1295,
                    2911,
                    3103
                ],
                "drop": [
                    1296,
                    4138,
                    1319
                ],
                "level": [
                    1298,
                    1299,
                    1300,
                    1301,
                    1302,
                    1303,
                    2590,
                    1694,
                    1697,
                    1698,
                    4002,
                    1700,
                    1701,
                    3108,
                    1319,
                    3110,
                    4143,
                    3530,
                    3922,
                    1652,
                    1660
                ],
                "self.index._get_level_number": [
                    1698,
                    1301
                ],
                "lev": [
                    1700,
                    1705,
                    1706,
                    1709,
                    1710,
                    1301
                ],
                "self.index.nlevels": [
                    1302
                ],
                "self.index.droplevel": [
                    1303
                ],
                "self._values.copy": [
                    1311
                ],
                "df": [
                    2177,
                    1318,
                    1319,
                    1563,
                    1565,
                    2175,
                    1567
                ],
                "self.to_frame": [
                    1451,
                    1318,
                    2175
                ],
                "df.reset_index": [
                    1319
                ],
                "buf": [
                    1350,
                    1451,
                    1423,
                    1328,
                    1427,
                    1429,
                    1343
                ],
                "StringIO": [
                    1328
                ],
                "width": [
                    1329
                ],
                "height": [
                    1336,
                    1329,
                    1331
                ],
                "get_terminal_size": [
                    1329
                ],
                "max_rows": [
                    1330,
                    1347,
                    1412
                ],
                "get_option": [
                    1332,
                    1333,
                    1337,
                    1338,
                    1340
                ],
                "min_rows": [
                    1346,
                    1411,
                    1335
                ],
                "show_dimensions": [
                    1340,
                    1348
                ],
                "self.to_string": [
                    1342
                ],
                "buf.getvalue": [
                    1350
                ],
                "formatter": [
                    1402,
                    1414
                ],
                "fmt.SeriesFormatter": [
                    1402
                ],
                "fmt": [
                    1402
                ],
                "length": [
                    1405
                ],
                "header": [
                    1406
                ],
                "na_rep": [
                    1409
                ],
                "float_format": [
                    1410
                ],
                "formatter.to_string": [
                    1414
                ],
                "repr": [
                    1420
                ],
                "buf.write": [
                    1427
                ],
                "AttributeError": [
                    1428,
                    3686
                ],
                "open": [
                    1429
                ],
                "f": [
                    3816,
                    3819,
                    3820,
                    3825,
                    3828,
                    1429,
                    1430
                ],
                "f.write": [
                    1430
                ],
                "IO": [
                    1449
                ],
                "to_markdown": [
                    1451
                ],
                "mode": [
                    1451
                ],
                "Substitution": [
                    4033,
                    1446,
                    2474,
                    3658,
                    4148,
                    4023
                ],
                "generic._shared_docs": [
                    3904,
                    4418,
                    1638,
                    1447,
                    4168,
                    3693,
                    3664,
                    4406,
                    4410,
                    4187,
                    4414
                ],
                "iter": [
                    1482
                ],
                "Iterable": [
                    1485,
                    1455
                ],
                "Tuple": [
                    1485,
                    1455
                ],
                "Label": [
                    1485,
                    1455
                ],
                "self.items": [
                    1486,
                    1535
                ],
                "items.__doc__": [
                    1484
                ],
                "items": [
                    1484
                ],
                "into_c": [
                    1534,
                    1535
                ],
                "com.standardize_mapping": [
                    1534
                ],
                "into": [
                    1534
                ],
                "self._constructor_expanddim": [
                    3833,
                    1563,
                    1565
                ],
                "ser": [
                    1580,
                    1581,
                    1582
                ],
                "self.copy": [
                    3428,
                    1580,
                    3889,
                    4508,
                    3482,
                    3132
                ],
                "ser.name": [
                    1581
                ],
                "by": [
                    1658,
                    1652
                ],
                "self._get_axis_number": [
                    2913,
                    3105,
                    3849,
                    4495,
                    3696,
                    3667,
                    1654
                ],
                "SeriesGroupBy": [
                    1656
                ],
                "as_index": [
                    1661
                ],
                "sort": [
                    1662
                ],
                "group_keys": [
                    1663
                ],
                "squeeze": [
                    1664
                ],
                "observed": [
                    1665
                ],
                "sum": [
                    1695
                ],
                "notna": [
                    4416,
                    2786,
                    1708,
                    2737,
                    1695
                ],
                "self.index.levels": [
                    1700
                ],
                "level_codes": [
                    1705,
                    1708,
                    1701,
                    1703
                ],
                "np.array": [
                    1701
                ],
                "self.index.codes": [
                    1701
                ],
                "cnt": [
                    1705,
                    1706
                ],
                "lev.insert": [
                    1706
                ],
                "lev._na_value": [
                    1706
                ],
                "obs": [
                    1708,
                    1709
                ],
                "self.values": [
                    2444,
                    2691,
                    1708,
                    2693
                ],
                "out": [
                    1709,
                    1710
                ],
                "np.bincount": [
                    1709
                ],
                "algorithms.mode": [
                    1731
                ],
                "algorithms": [
                    2336,
                    1731,
                    4300,
                    2477,
                    3892,
                    3287,
                    3384
                ],
                "dropna": [
                    1731
                ],
                "unique": [
                    1794
                ],
                "super": [
                    4416,
                    4001,
                    1794,
                    4036,
                    4420,
                    4138,
                    3918,
                    1872,
                    3697,
                    4178,
                    4242,
                    4189,
                    4408,
                    3610,
                    4412,
                    4159,
                    1950,
                    4031
                ],
                "drop_duplicates": [
                    1872
                ],
                "keep": [
                    1872,
                    3384,
                    1950,
                    3287
                ],
                "duplicated": [
                    1950
                ],
                "skipna": [
                    2016,
                    2017,
                    2087,
                    2088,
                    3880,
                    3852,
                    3855,
                    3871
                ],
                "nv.validate_argmin_with_skipna": [
                    2016
                ],
                "args": [
                    2016,
                    3810,
                    3685,
                    3813,
                    2087,
                    3687,
                    2122,
                    3697,
                    3668,
                    3803,
                    3807
                ],
                "nanops.nanargmin": [
                    2017
                ],
                "nanops": [
                    2088,
                    2017,
                    2268,
                    2231
                ],
                "com.values_from_object": [
                    2088,
                    2017,
                    2123
                ],
                "np.nan": [
                    2090,
                    2019,
                    2228,
                    2267
                ],
                "nv.validate_argmax_with_skipna": [
                    2087
                ],
                "nanops.nanargmax": [
                    2088
                ],
                "nv.validate_round": [
                    2122
                ],
                "round": [
                    2123
                ],
                "decimals": [
                    2123
                ],
                "validate_percentile": [
                    2171
                ],
                "q": [
                    2177,
                    2171,
                    2181,
                    2183
                ],
                "df.quantile": [
                    2177
                ],
                "interpolation": [
                    2177
                ],
                "result.iloc": [
                    2186,
                    2179
                ],
                "result.name": [
                    2182
                ],
                "Float64Index": [
                    2183
                ],
                "this": [
                    2593,
                    2732,
                    2734,
                    2737,
                    2226,
                    2227,
                    2232,
                    2265,
                    2266,
                    2587,
                    2268,
                    2590,
                    2591
                ],
                "other": [
                    2688,
                    2434,
                    2435,
                    2436,
                    2440,
                    2445,
                    2451,
                    2453,
                    2583,
                    2455,
                    2460,
                    2589,
                    2590,
                    2593,
                    2466,
                    2598,
                    2472,
                    2731,
                    2733,
                    2734,
                    2735,
                    2737,
                    2226,
                    2232,
                    3919,
                    2265,
                    2268,
                    2785,
                    2786,
                    2788,
                    2672,
                    2675,
                    2676,
                    2680
                ],
                "self.align": [
                    2265,
                    2226,
                    2590
                ],
                "callable": [
                    4000,
                    2230
                ],
                "nanops.nancorr": [
                    2231
                ],
                "this.values": [
                    2232,
                    2593,
                    2268
                ],
                "other.values": [
                    2232,
                    2593,
                    2268
                ],
                "min_periods": [
                    2232,
                    2268
                ],
                "nanops.nancov": [
                    2268
                ],
                "algorithms.diff": [
                    2336
                ],
                "periods": [
                    2336,
                    4190
                ],
                "self.corr": [
                    2382
                ],
                "self.shift": [
                    2382
                ],
                "lag": [
                    2382
                ],
                "common": [
                    2440,
                    2435,
                    2436,
                    2439
                ],
                "self.index.union": [
                    2675,
                    2435,
                    2731
                ],
                "other.index": [
                    2435,
                    2436,
                    2731,
                    2675,
                    2589
                ],
                "left": [
                    2441,
                    4370,
                    4373,
                    2439
                ],
                "right": [
                    2440,
                    2442,
                    4371,
                    4374
                ],
                "other.reindex": [
                    2440,
                    2733
                ],
                "lvals": [
                    2441,
                    2444,
                    2446,
                    2448,
                    2453,
                    2456,
                    2458
                ],
                "left.values": [
                    2441
                ],
                "rvals": [
                    2442,
                    2445,
                    2446,
                    2448,
                    2453,
                    2456,
                    2457,
                    2458
                ],
                "right.values": [
                    2442
                ],
                "lvals.shape": [
                    2448,
                    2446
                ],
                "rvals.shape": [
                    2448,
                    2446
                ],
                "np.dot": [
                    2456,
                    2458,
                    2453
                ],
                "other.columns": [
                    2453
                ],
                "self.dot": [
                    2472,
                    2466
                ],
                "np.transpose": [
                    2472
                ],
                "algorithms.searchsorted": [
                    2477
                ],
                "side": [
                    2477
                ],
                "sorter": [
                    2477
                ],
                "base._shared_docs": [
                    2475
                ],
                "to_append": [
                    2554,
                    2556,
                    2558
                ],
                "to_concat": [
                    2560,
                    2555,
                    2556,
                    2558
                ],
                "to_concat.extend": [
                    2556
                ],
                "concat": [
                    2559
                ],
                "ignore_index": [
                    2560,
                    3145,
                    2968
                ],
                "verify_integrity": [
                    2560
                ],
                "self.index.equals": [
                    2589
                ],
                "this.index": [
                    2591
                ],
                "this_vals": [
                    2593,
                    2596
                ],
                "other_vals": [
                    2593,
                    2596
                ],
                "ops.fill_binop": [
                    2593
                ],
                "fill_value": [
                    2593,
                    3530,
                    2669,
                    2670,
                    3924,
                    2679,
                    2680,
                    4190
                ],
                "np.errstate": [
                    2595,
                    3818,
                    2681,
                    3870,
                    2687
                ],
                "func": [
                    2688,
                    3810,
                    2596,
                    3685,
                    3813,
                    3687,
                    3816,
                    3697,
                    3668,
                    3802,
                    2682,
                    3803,
                    3806,
                    3807
                ],
                "ops.get_op_result_name": [
                    2676,
                    2598
                ],
                "ret": [
                    2600,
                    2599
                ],
                "ops._construct_result": [
                    2599
                ],
                "new_name": [
                    2689,
                    2697,
                    2676
                ],
                "idx": [
                    2957,
                    2958,
                    2961,
                    2962,
                    2678,
                    2679,
                    2680,
                    2938
                ],
                "lv": [
                    2688,
                    2682,
                    2679
                ],
                "self.get": [
                    2679
                ],
                "rv": [
                    2680,
                    2682
                ],
                "other.get": [
                    2680
                ],
                "new_values.append": [
                    2682
                ],
                "try_cast_to_ea": [
                    2696
                ],
                "this.dtype.kind": [
                    2734
                ],
                "this.dtype": [
                    2734
                ],
                "other.dtype.kind": [
                    2734
                ],
                "other.dtype": [
                    2734
                ],
                "to_datetime": [
                    2735
                ],
                "this.where": [
                    2737
                ],
                "other.reindex_like": [
                    2785
                ],
                "self._data.putmask": [
                    2788
                ],
                "self._is_cached": [
                    2916
                ],
                "arr.argsort": [
                    2930,
                    2926
                ],
                "arr": [
                    2926,
                    2930,
                    2932,
                    2966,
                    2935,
                    2940
                ],
                "sorted_index": [
                    2957,
                    2958,
                    2961,
                    2962,
                    2933,
                    2966,
                    2969
                ],
                "np.empty": [
                    2933
                ],
                "np.int32": [
                    2933
                ],
                "bad": [
                    2958,
                    2960,
                    2962,
                    2935,
                    2937
                ],
                "isna": [
                    4408,
                    3179,
                    2935
                ],
                "good": [
                    2956,
                    2957,
                    2961,
                    2937,
                    2940
                ],
                "argsorted": [
                    2953,
                    2961,
                    2940,
                    2957
                ],
                "_try_kind_sort": [
                    2940
                ],
                "ascending": [
                    2945,
                    2947,
                    2949,
                    3110,
                    2952,
                    3118,
                    3126,
                    3127,
                    3135,
                    2942,
                    2943
                ],
                "is_bool": [
                    2949
                ],
                "na_position": [
                    2955,
                    3119,
                    2959,
                    2964,
                    3135
                ],
                "n": [
                    2956,
                    2957,
                    2958,
                    2960,
                    2961,
                    2962,
                    3287,
                    3384
                ],
                "good.sum": [
                    2956
                ],
                "bad.sum": [
                    2960
                ],
                "result.index": [
                    2969,
                    3146,
                    3429,
                    3430
                ],
                "self._update_inplace": [
                    4500,
                    2972,
                    3149
                ],
                "result.__finalize__": [
                    2974,
                    3151
                ],
                "index.sortlevel": [
                    3109
                ],
                "sort_remaining": [
                    3110
                ],
                "index._sort_levels_monotonic": [
                    3115
                ],
                "lexsort_indexer": [
                    3116
                ],
                "labels._get_codes_for_sorting": [
                    3117
                ],
                "index.is_monotonic_increasing": [
                    3126
                ],
                "index.is_monotonic_decreasing": [
                    3127
                ],
                "nargsort": [
                    3134
                ],
                "index.take": [
                    3139
                ],
                "new_index._sort_levels_monotonic": [
                    3140
                ],
                "notmask": [
                    3184,
                    3183
                ],
                "np.argsort": [
                    3184,
                    3188
                ],
                "nlargest": [
                    3287
                ],
                "algorithms.SelectNSeries": [
                    3384,
                    3287
                ],
                "nsmallest": [
                    3384
                ],
                "ABCMultiIndex": [
                    3404,
                    3429
                ],
                "self.index.swaplevel": [
                    3405
                ],
                "j": [
                    3405
                ],
                "result.index.reorder_levels": [
                    3430
                ],
                "is_object_dtype": [
                    3481,
                    4391
                ],
                "counts": [
                    3484,
                    3486
                ],
                "reshape.explode": [
                    3484
                ],
                "reshape": [
                    3484
                ],
                "unstack": [
                    3530
                ],
                "_map_values": [
                    3610
                ],
                "arg": [
                    3610
                ],
                "na_action": [
                    3610
                ],
                "_agg_see_also_doc": [
                    3659,
                    3627
                ],
                "dedent": [
                    3627,
                    3636
                ],
                "_agg_examples_doc": [
                    3636,
                    3660
                ],
                "how": [
                    4536,
                    3668
                ],
                "self._aggregate": [
                    3668
                ],
                "kwargs.pop": [
                    3673,
                    3674
                ],
                "self.apply": [
                    3685
                ],
                "agg": [
                    3691
                ],
                "aggregate": [
                    3691
                ],
                "transform": [
                    3697
                ],
                "self.aggregate": [
                    3803
                ],
                "kwds": [
                    3810,
                    3813,
                    3883,
                    3852,
                    3855,
                    3871,
                    3803,
                    3807
                ],
                "self._try_aggregate_string_function": [
                    3807
                ],
                "np.ufunc": [
                    3810,
                    3819
                ],
                "mapped": [
                    3825,
                    3828,
                    3830,
                    3833,
                    3835
                ],
                "self._values.map": [
                    3825
                ],
                "self.astype": [
                    3827
                ],
                "lib.map_infer": [
                    3828
                ],
                "convert_dtype": [
                    3828
                ],
                "pd.array": [
                    3833
                ],
                "pd": [
                    3833
                ],
                "delegate": [
                    3876,
                    3846,
                    3851,
                    3852,
                    3853,
                    3855,
                    3856,
                    3858,
                    3859,
                    3862,
                    3865,
                    3871
                ],
                "Categorical": [
                    3851
                ],
                "delegate._reduce": [
                    3852,
                    3876,
                    3855
                ],
                "is_datetime64_dtype": [
                    3856
                ],
                "is_timedelta64_dtype": [
                    3859
                ],
                "numeric_only": [
                    3881,
                    3866
                ],
                "op": [
                    3877,
                    3871
                ],
                "filter_type": [
                    3882
                ],
                "algorithms.take_1d": [
                    3892
                ],
                "align": [
                    3918
                ],
                "join": [
                    3920
                ],
                "limit": [
                    4182,
                    4164,
                    3926
                ],
                "fill_axis": [
                    3927
                ],
                "broadcast_axis": [
                    3928
                ],
                "rename": [
                    4001
                ],
                "errors": [
                    4145,
                    4002
                ],
                "self._set_name": [
                    4005
                ],
                "set_axis": [
                    4031
                ],
                "generic.NDFrame.set_axis.__doc__": [
                    4029
                ],
                "generic.NDFrame.set_axis": [
                    4029
                ],
                "reindex": [
                    4036
                ],
                "generic.NDFrame.reindex.__doc__": [
                    4034
                ],
                "generic.NDFrame.reindex": [
                    4034
                ],
                "columns": [
                    4142
                ],
                "fillna": [
                    4159
                ],
                "downcast": [
                    4165
                ],
                "generic.NDFrame.fillna.__doc__": [
                    4149
                ],
                "generic.NDFrame.fillna": [
                    4149
                ],
                "replace": [
                    4178
                ],
                "to_replace": [
                    4179
                ],
                "regex": [
                    4183
                ],
                "shift": [
                    4189
                ],
                "freq": [
                    4536,
                    4561,
                    4190
                ],
                "v": [
                    4242,
                    4244,
                    4245
                ],
                "memory_usage": [
                    4242
                ],
                "deep": [
                    4242,
                    4244
                ],
                "self.index.memory_usage": [
                    4244
                ],
                "algorithms.isin": [
                    4300
                ],
                "inclusive": [
                    4369
                ],
                "lmask": [
                    4376,
                    4370,
                    4373
                ],
                "rmask": [
                    4376,
                    4371,
                    4374
                ],
                "input_series": [
                    4388,
                    4390,
                    4391,
                    4392,
                    4396,
                    4399,
                    4401,
                    4403
                ],
                "infer_objects": [
                    4389
                ],
                "input_series.infer_objects": [
                    4390
                ],
                "input_series.copy": [
                    4392,
                    4401,
                    4403
                ],
                "convert_string": [
                    4394,
                    4396
                ],
                "convert_integer": [
                    4394,
                    4396
                ],
                "convert_boolean": [
                    4394,
                    4396
                ],
                "inferred_dtype": [
                    4395,
                    4399
                ],
                "convert_dtypes": [
                    4395
                ],
                "input_series._values": [
                    4396
                ],
                "input_series.astype": [
                    4399
                ],
                "isnull": [
                    4412
                ],
                "notnull": [
                    4420
                ],
                "self._can_hold_na": [
                    4497
                ],
                "remove_na_arraylike": [
                    4498
                ],
                "new_values.copy": [
                    4533,
                    4558
                ],
                "ABCPeriodIndex": [
                    4535
                ],
                "self.index.to_timestamp": [
                    4536
                ],
                "self.index.to_period": [
                    4561
                ],
                "properties.AxisProperty": [
                    4566
                ],
                "properties": [
                    4566
                ],
                "CachedAccessor": [
                    4576,
                    4577,
                    4573,
                    4574,
                    4575
                ],
                "StringMethods": [
                    4573
                ],
                "dt": [
                    4574
                ],
                "CombinedDatetimelikeProperties": [
                    4574
                ],
                "cat": [
                    4575
                ],
                "CategoricalAccessor": [
                    4575
                ],
                "plot": [
                    4576
                ],
                "pandas.plotting.PlotAccessor": [
                    4576
                ],
                "pandas.plotting": [
                    4576,
                    4581
                ],
                "pandas": [
                    4576,
                    4581
                ],
                "sparse": [
                    4577
                ],
                "SparseAccessor": [
                    4577
                ],
                "hist": [
                    4581
                ],
                "pandas.plotting.hist_series": [
                    4581
                ],
                "Series._setup_axes": [
                    4584
                ],
                "Series._add_numeric_operations": [
                    4585
                ],
                "Series._add_series_or_dataframe_operations": [
                    4586
                ],
                "ops.add_flex_arithmetic_methods": [
                    4589
                ],
                "ops.add_special_arithmetic_methods": [
                    4590
                ]
            },
            "filtered_variables_in_file": {
                "TYPE_CHECKING": [
                    98
                ],
                "__all__": [
                    102
                ],
                "_shared_doc_kwargs": [
                    3904,
                    4033,
                    4418,
                    1638,
                    104,
                    4168,
                    3693,
                    3662,
                    4148,
                    4406,
                    4024,
                    4410,
                    4187,
                    4414
                ],
                "self": [
                    1026,
                    1030,
                    1031,
                    1032,
                    1037,
                    1038,
                    527,
                    1040,
                    532,
                    1044,
                    2586,
                    1051,
                    1563,
                    1565,
                    2587,
                    2589,
                    544,
                    2590,
                    3105,
                    3106,
                    3611,
                    2598,
                    2599,
                    2088,
                    1065,
                    1066,
                    1535,
                    1068,
                    1580,
                    1070,
                    2091,
                    560,
                    1072,
                    3625,
                    1076,
                    566,
                    1080,
                    4500,
                    3132,
                    1085,
                    1086,
                    3142,
                    3143,
                    2123,
                    2124,
                    3149,
                    3151,
                    3667,
                    3668,
                    1111,
                    1113,
                    1114,
                    1115,
                    1119,
                    1121,
                    3484,
                    3685,
                    3687,
                    3178,
                    2670,
                    3182,
                    3482,
                    3185,
                    3696,
                    2675,
                    2676,
                    3187,
                    1654,
                    2679,
                    3188,
                    1657,
                    634,
                    635,
                    636,
                    3189,
                    2686,
                    2175,
                    128,
                    129,
                    2688,
                    2689,
                    2691,
                    2693,
                    646,
                    2182,
                    2183,
                    2696,
                    650,
                    2697,
                    3486,
                    4244,
                    661,
                    4508,
                    666,
                    1183,
                    1184,
                    1185,
                    1695,
                    1698,
                    1700,
                    1701,
                    2731,
                    1708,
                    2732,
                    1710,
                    690,
                    2226,
                    1731,
                    710,
                    4300,
                    4301,
                    3796,
                    3797,
                    3798,
                    3287,
                    2265,
                    219,
                    3803,
                    3807,
                    2785,
                    2788,
                    2789,
                    3820,
                    239,
                    3823,
                    3825,
                    3827,
                    3833,
                    3835,
                    768,
                    3846,
                    3849,
                    1297,
                    786,
                    275,
                    4370,
                    1301,
                    1302,
                    1303,
                    4371,
                    4373,
                    1306,
                    4374,
                    1308,
                    1310,
                    1311,
                    1312,
                    2336,
                    2337,
                    803,
                    4388,
                    805,
                    1318,
                    808,
                    812,
                    814,
                    816,
                    3889,
                    3890,
                    3893,
                    3895,
                    3384,
                    827,
                    1342,
                    1344,
                    1345,
                    328,
                    329,
                    330,
                    841,
                    3404,
                    845,
                    846,
                    2382,
                    3405,
                    849,
                    3406,
                    3407,
                    852,
                    856,
                    858,
                    861,
                    2913,
                    3425,
                    867,
                    2916,
                    3428,
                    879,
                    880,
                    882,
                    2932,
                    2933,
                    887,
                    2938,
                    1403,
                    895,
                    2435,
                    2436,
                    902,
                    391,
                    2439,
                    2444,
                    4495,
                    4497,
                    4498,
                    916,
                    917,
                    918,
                    919,
                    920,
                    2452,
                    410,
                    922,
                    2454,
                    2966,
                    2972,
                    2974,
                    416,
                    3481,
                    418,
                    931,
                    2466,
                    933,
                    422,
                    935,
                    2472,
                    4005,
                    1451,
                    2477,
                    430,
                    946,
                    4531,
                    948,
                    437,
                    4535,
                    952,
                    441,
                    953,
                    954,
                    4536,
                    4537,
                    447,
                    959,
                    960,
                    961,
                    965,
                    1482,
                    3530,
                    4556,
                    1486,
                    4560,
                    4561,
                    4562,
                    981,
                    985,
                    988,
                    989,
                    1500,
                    992,
                    2017,
                    996,
                    997,
                    2020,
                    1000,
                    489,
                    1002,
                    1005,
                    1008,
                    1016,
                    1018,
                    2555,
                    2558,
                    1023
                ],
                "converter": [
                    129,
                    130,
                    132
                ],
                "self.iloc": [
                    920,
                    129
                ],
                "wrapper.__name__": [
                    132
                ],
                "wrapper": [
                    132,
                    133
                ],
                "converter.__name__": [
                    132
                ],
                "base.IndexOpsMixin": [
                    193,
                    186,
                    140,
                    529
                ],
                "base": [
                    193,
                    2475,
                    140,
                    529,
                    186
                ],
                "generic.NDFrame": [
                    4034,
                    422,
                    328,
                    140,
                    791,
                    4149,
                    183,
                    187,
                    4029
                ],
                "generic": [
                    140,
                    791,
                    422,
                    1447,
                    4149,
                    4406,
                    183,
                    4410,
                    187,
                    4029,
                    4414,
                    3904,
                    4034,
                    4418,
                    328,
                    4168,
                    3664,
                    4187,
                    1638,
                    3693
                ],
                "_typ": [
                    179
                ],
                "_name": [
                    181
                ],
                "Optional": [
                    1449,
                    1450,
                    181,
                    695,
                    440,
                    444,
                    4158
                ],
                "Hashable": [
                    440,
                    444,
                    181,
                    695
                ],
                "_metadata": [
                    182
                ],
                "List": [
                    182,
                    782
                ],
                "_internal_names_set": [
                    183
                ],
                "generic.NDFrame._internal_names_set": [
                    183
                ],
                "_accessors": [
                    184
                ],
                "_deprecations": [
                    185
                ],
                "base.IndexOpsMixin._deprecations": [
                    186
                ],
                "generic.NDFrame._deprecations": [
                    187
                ],
                "hasnans": [
                    192
                ],
                "base.IndexOpsMixin.hasnans.func": [
                    193
                ],
                "base.IndexOpsMixin.hasnans": [
                    193
                ],
                "base.IndexOpsMixin.hasnans.__doc__": [
                    193
                ],
                "_data": [
                    195
                ],
                "SingleBlockManager": [
                    195,
                    326,
                    210,
                    211,
                    278,
                    318
                ],
                "div": [
                    196
                ],
                "Callable": [
                    643,
                    196,
                    197
                ],
                "Any": [
                    643,
                    196,
                    197,
                    1485,
                    1455
                ],
                "rdiv": [
                    197
                ],
                "fastpath": [
                    400,
                    409,
                    417,
                    207
                ],
                "data": [
                    256,
                    259,
                    260,
                    268,
                    270,
                    272,
                    273,
                    274,
                    275,
                    278,
                    280,
                    281,
                    290,
                    292,
                    293,
                    294,
                    296,
                    298,
                    301,
                    302,
                    303,
                    304,
                    309,
                    311,
                    318,
                    320,
                    322,
                    324,
                    326,
                    328,
                    210,
                    211,
                    213,
                    215,
                    219,
                    221,
                    353,
                    354,
                    236,
                    237,
                    241,
                    372,
                    245,
                    249,
                    252,
                    253
                ],
                "index": [
                    269,
                    270,
                    272,
                    275,
                    4243,
                    279,
                    280,
                    281,
                    4000,
                    3106,
                    4002,
                    3109,
                    4005,
                    3112,
                    682,
                    3115,
                    300,
                    684,
                    686,
                    303,
                    4141,
                    690,
                    309,
                    3126,
                    3127,
                    312,
                    3135,
                    3139,
                    324,
                    4036,
                    326,
                    710,
                    330,
                    211,
                    214,
                    215,
                    4566,
                    356,
                    360,
                    233,
                    234,
                    372,
                    373,
                    1407
                ],
                "copy": [
                    320,
                    257,
                    321,
                    4002,
                    324,
                    4557,
                    3406,
                    272,
                    3888,
                    3923,
                    212,
                    277,
                    4532,
                    281
                ],
                "data.copy": [
                    322,
                    213
                ],
                "data.index": [
                    280,
                    281,
                    270,
                    215
                ],
                "name": [
                    3852,
                    3855,
                    3859,
                    1562,
                    3868,
                    1565,
                    1308,
                    1318,
                    2598,
                    2599,
                    3878,
                    1581,
                    695,
                    697,
                    443,
                    699,
                    710,
                    329,
                    219,
                    1404
                ],
                "ibase.maybe_extract_name": [
                    219
                ],
                "ibase": [
                    3146,
                    303,
                    1297,
                    2969,
                    2938,
                    219
                ],
                "is_empty_data": [
                    221
                ],
                "dtype": [
                    320,
                    768,
                    1408,
                    324,
                    359,
                    238,
                    239,
                    368,
                    275,
                    276,
                    247,
                    249,
                    635,
                    221,
                    319
                ],
                "warnings.warn": [
                    794,
                    223
                ],
                "warnings": [
                    943,
                    794,
                    942,
                    223
                ],
                "ensure_index": [
                    401,
                    234
                ],
                "self._validate_dtype": [
                    239
                ],
                "MultiIndex": [
                    3425,
                    867,
                    3112,
                    1008,
                    241,
                    948,
                    858
                ],
                "Index": [
                    640,
                    1058,
                    905,
                    908,
                    782,
                    1491,
                    245
                ],
                "data.astype": [
                    320,
                    249
                ],
                "data._values.copy": [
                    256,
                    252
                ],
                "data._values": [
                    256,
                    252
                ],
                "ABCDatetimeIndex": [
                    4560,
                    253,
                    4535
                ],
                "data.tz": [
                    253
                ],
                "np.ndarray": [
                    640,
                    259,
                    905,
                    656,
                    721,
                    3865,
                    2457
                ],
                "np": [
                    768,
                    640,
                    259,
                    905,
                    2445,
                    656,
                    2453,
                    2456,
                    2457,
                    2458,
                    3865,
                    3484,
                    3870,
                    2595,
                    1701,
                    2472,
                    2090,
                    1709,
                    1070,
                    2228,
                    721,
                    2267,
                    3810,
                    2019,
                    3818,
                    3819,
                    368,
                    3184,
                    3188,
                    2933,
                    2681,
                    2687
                ],
                "data.dtype": [
                    260
                ],
                "ABCSeries": [
                    268,
                    4382
                ],
                "data.reindex": [
                    272
                ],
                "data._data": [
                    273
                ],
                "is_dict_like": [
                    4000,
                    274
                ],
                "self._init_dict": [
                    275
                ],
                "data.index.equals": [
                    281
                ],
                "is_extension_array_dtype": [
                    290,
                    2693,
                    3823
                ],
                "ABCSparseArray": [
                    294
                ],
                "data.to_dense": [
                    296
                ],
                "com.maybe_iterable_to_list": [
                    298
                ],
                "com": [
                    993,
                    2017,
                    2088,
                    298,
                    939,
                    2123,
                    878,
                    849,
                    1075,
                    1015,
                    988,
                    1534
                ],
                "is_list_like": [
                    304,
                    2942,
                    301,
                    2181
                ],
                "ibase.default_index": [
                    3146,
                    303,
                    1297,
                    2969,
                    2938
                ],
                "sanitize_array": [
                    324
                ],
                "generic.NDFrame.__init__": [
                    328
                ],
                "self.name": [
                    1344,
                    2689,
                    2182,
                    2183,
                    329,
                    3182,
                    1308,
                    3486
                ],
                "self._set_axis": [
                    330
                ],
                "keys": [
                    360,
                    354,
                    368,
                    362
                ],
                "values": [
                    354,
                    355,
                    996,
                    998,
                    359,
                    362,
                    3178,
                    3179,
                    4300,
                    368,
                    3184,
                    3827,
                    3188,
                    3828,
                    3484,
                    3486
                ],
                "data.items": [
                    354
                ],
                "na_value_for_dtype": [
                    2670,
                    359
                ],
                "s": [
                    683,
                    684,
                    367,
                    373,
                    374
                ],
                "create_series_with_explicit_dtype": [
                    367
                ],
                "np.float64": [
                    368
                ],
                "s.reindex": [
                    373
                ],
                "s._data": [
                    374
                ],
                "s.index": [
                    684,
                    374
                ],
                "Series": [
                    2434,
                    675,
                    2583,
                    4584,
                    905,
                    4585,
                    4586,
                    4589,
                    686,
                    3182,
                    2672,
                    4590,
                    3830,
                    2455,
                    1083,
                    380,
                    3486
                ],
                "Type": [
                    379,
                    383
                ],
                "DataFrame": [
                    386
                ],
                "self._data._can_hold_na": [
                    391
                ],
                "self._data": [
                    544,
                    960,
                    418,
                    2788,
                    391,
                    489,
                    430,
                    527,
                    532,
                    437,
                    566,
                    410,
                    1085
                ],
                "_index": [
                    393
                ],
                "labels": [
                    416,
                    418,
                    3115,
                    4139,
                    3117,
                    401,
                    403,
                    405,
                    407,
                    410,
                    4031
                ],
                "is_all_dates": [
                    403,
                    404
                ],
                "labels.is_all_dates": [
                    403
                ],
                "DatetimeIndex": [
                    3858,
                    405,
                    407
                ],
                "PeriodIndex": [
                    405
                ],
                "TimedeltaIndex": [
                    3859,
                    405,
                    3862
                ],
                "self._data.set_axis": [
                    418,
                    410
                ],
                "axis": [
                    3848,
                    3849,
                    4495,
                    410,
                    1182,
                    3105,
                    418,
                    3879,
                    808,
                    4140,
                    827,
                    4031,
                    4162,
                    3921,
                    3667,
                    4190,
                    2913,
                    3696,
                    1654,
                    1659
                ],
                "tslibs.OutOfBoundsDatetime": [
                    411
                ],
                "tslibs": [
                    411
                ],
                "object.__setattr__": [
                    416,
                    447
                ],
                "generic.NDFrame._update_inplace": [
                    422
                ],
                "result": [
                    2177,
                    1794,
                    1795,
                    2178,
                    2179,
                    1414,
                    2182,
                    2183,
                    649,
                    1417,
                    2186,
                    652,
                    653,
                    1420,
                    1424,
                    4498,
                    1427,
                    4500,
                    1430,
                    2966,
                    4502,
                    2969,
                    2972,
                    2974,
                    3486,
                    2336,
                    2337,
                    3487,
                    2596,
                    422,
                    2599,
                    4399,
                    4401,
                    4403,
                    4404,
                    693,
                    702,
                    703,
                    704,
                    709,
                    710,
                    1350,
                    712,
                    1352,
                    714,
                    2123,
                    2124,
                    3143,
                    2126,
                    719,
                    3146,
                    3149,
                    3151,
                    4300,
                    3668,
                    3669,
                    4301,
                    861,
                    863,
                    3428,
                    3429,
                    3430,
                    3431,
                    3685,
                    3687,
                    3689,
                    3182,
                    3184,
                    3185
                ],
                "kwargs": [
                    650,
                    800,
                    422,
                    2087,
                    809,
                    811,
                    812,
                    1451,
                    693,
                    827,
                    4036,
                    2122,
                    3668,
                    3673,
                    3674,
                    2016,
                    3685,
                    3687,
                    3697
                ],
                "self._data.dtype": [
                    437,
                    430
                ],
                "self._name": [
                    441
                ],
                "is_hashable": [
                    445
                ],
                "value": [
                    1031,
                    1032,
                    1038,
                    1044,
                    1051,
                    1066,
                    1068,
                    2477,
                    1070,
                    1072,
                    1080,
                    445,
                    1085,
                    447,
                    4160,
                    4180,
                    1111,
                    1114,
                    1115,
                    1119,
                    992,
                    998,
                    1000,
                    1002,
                    1005,
                    1018,
                    1023
                ],
                "name.setter": [
                    443
                ],
                "self._data.external_values": [
                    489
                ],
                "self._data.internal_values": [
                    527
                ],
                "self._data._block.array_values": [
                    532
                ],
                "self._data._block": [
                    532
                ],
                "Appender": [
                    529,
                    791,
                    1432,
                    1447,
                    4007,
                    2475,
                    1584,
                    4149,
                    4406,
                    4410,
                    4029,
                    4414,
                    3904,
                    4034,
                    4418,
                    4168,
                    1484,
                    3664,
                    4187,
                    1638,
                    3693
                ],
                "base.IndexOpsMixin.array.__doc__": [
                    529
                ],
                "base.IndexOpsMixin.array": [
                    529
                ],
                "ExtensionArray": [
                    640,
                    531,
                    3853
                ],
                "self._data.get_values": [
                    544
                ],
                "self._values.ravel": [
                    560
                ],
                "self._values": [
                    2688,
                    3846,
                    1032,
                    2696,
                    1311,
                    1184,
                    812,
                    2477,
                    560,
                    4531,
                    3893,
                    953,
                    965,
                    3142,
                    841,
                    4556,
                    3406,
                    981,
                    1111,
                    1115,
                    996,
                    3178,
                    3823,
                    3825,
                    2932,
                    635
                ],
                "order": [
                    560,
                    3430
                ],
                "__finalize__": [
                    2452,
                    3611,
                    1310,
                    1185,
                    2337,
                    814,
                    1710,
                    4537,
                    953,
                    959,
                    2124,
                    4301,
                    3406,
                    4562,
                    3797,
                    3185,
                    3187,
                    634,
                    3835
                ],
                "self._constructor": [
                    2183,
                    2697,
                    2452,
                    2966,
                    3611,
                    1310,
                    1185,
                    2337,
                    814,
                    1710,
                    3895,
                    953,
                    4537,
                    959,
                    710,
                    3143,
                    2124,
                    4301,
                    3406,
                    4562,
                    3797,
                    3185,
                    3187,
                    634,
                    3835
                ],
                "self._values.view": [
                    635
                ],
                "self.index": [
                    2435,
                    2436,
                    1030,
                    1037,
                    1040,
                    786,
                    916,
                    1301,
                    918,
                    919,
                    1302,
                    1303,
                    1306,
                    2586,
                    2966,
                    2589,
                    3486,
                    1183,
                    3611,
                    2337,
                    1698,
                    803,
                    1700,
                    1701,
                    3106,
                    1065,
                    2091,
                    2731,
                    690,
                    948,
                    1076,
                    4535,
                    952,
                    4536,
                    1482,
                    2124,
                    845,
                    3404,
                    3405,
                    4301,
                    4560,
                    4561,
                    3797,
                    856,
                    985,
                    858,
                    1113,
                    1500,
                    861,
                    3835,
                    3425,
                    867,
                    2020,
                    997,
                    4244,
                    3182,
                    879,
                    1008,
                    3185,
                    2675,
                    3188,
                    1016,
                    3833,
                    635,
                    2686
                ],
                "_HANDLED_TYPES": [
                    640
                ],
                "cls": [
                    656,
                    646
                ],
                "ops.maybe_dispatch_ufunc_to_dunder_op": [
                    649
                ],
                "ops": [
                    2593,
                    2598,
                    2599,
                    649,
                    4589,
                    4590,
                    2676
                ],
                "ufunc": [
                    650,
                    693
                ],
                "method": [
                    4161,
                    706,
                    650,
                    715,
                    693,
                    2230,
                    3925,
                    2232,
                    4184,
                    2238
                ],
                "inputs": [
                    672,
                    673,
                    675,
                    650,
                    685,
                    687,
                    658,
                    692,
                    693
                ],
                "no_defer": [
                    656,
                    665
                ],
                "np.ndarray.__array_ufunc__": [
                    656
                ],
                "cls.__array_ufunc__": [
                    656
                ],
                "item": [
                    658,
                    660,
                    661,
                    664,
                    665,
                    666
                ],
                "higher_priority": [
                    659,
                    668
                ],
                "item.__array_priority__": [
                    661
                ],
                "self.__array_priority__": [
                    661
                ],
                "has_array_ufunc": [
                    668,
                    663
                ],
                "__array_ufunc__": [
                    665
                ],
                "self._HANDLED_TYPES": [
                    666
                ],
                "names": [
                    672,
                    697,
                    696
                ],
                "x": [
                    672,
                    673,
                    675,
                    3813,
                    714,
                    686,
                    687,
                    692
                ],
                "types": [
                    673,
                    675,
                    687
                ],
                "alignable": [
                    683,
                    682,
                    675,
                    677
                ],
                "t": [
                    675,
                    686,
                    687
                ],
                "x.reindex": [
                    686
                ],
                "extract_array": [
                    692
                ],
                "lib.is_scalar": [
                    702
                ],
                "lib": [
                    1062,
                    3828,
                    702,
                    911
                ],
                "result.ndim": [
                    704,
                    2178
                ],
                "construct_return": [
                    714,
                    719
                ],
                "np.asarray": [
                    768,
                    3484,
                    2445
                ],
                "self.array": [
                    768,
                    2336,
                    3484,
                    1695
                ],
                "__float__": [
                    774
                ],
                "_coerce_method": [
                    776,
                    774,
                    775
                ],
                "__long__": [
                    775
                ],
                "__int__": [
                    776
                ],
                "is_copy": [
                    793
                ],
                "nv.validate_take": [
                    800
                ],
                "nv": [
                    800,
                    2016,
                    2087,
                    2122,
                    1182
                ],
                "indices": [
                    802,
                    803,
                    808,
                    812,
                    827
                ],
                "ensure_platform_int": [
                    802,
                    3138
                ],
                "new_index": [
                    2697,
                    1297,
                    1303,
                    2586,
                    1306,
                    1311,
                    2591,
                    1185,
                    1183,
                    803,
                    3109,
                    2599,
                    2731,
                    2732,
                    2733,
                    815,
                    3895,
                    952,
                    953,
                    4536,
                    4537,
                    3139,
                    3140,
                    3143,
                    3405,
                    3406,
                    4561,
                    4562,
                    2675,
                    2678,
                    2686
                ],
                "self.index.take": [
                    803
                ],
                "is_categorical_dtype": [
                    2691,
                    805
                ],
                "maybe_convert_indices": [
                    808
                ],
                "self._get_axis": [
                    808
                ],
                "new_values": [
                    2688,
                    2696,
                    2697,
                    3610,
                    3611,
                    1184,
                    1185,
                    812,
                    815,
                    4531,
                    3892,
                    4533,
                    3895,
                    4537,
                    3142,
                    3143,
                    4556,
                    4558,
                    4562,
                    2677,
                    2682
                ],
                "self._values.take": [
                    812,
                    3142
                ],
                "generic.NDFrame.take.__doc__": [
                    791
                ],
                "generic.NDFrame.take": [
                    791
                ],
                "self.take": [
                    827
                ],
                "i": [
                    2017,
                    2018,
                    2020,
                    2088,
                    841,
                    2089,
                    2091,
                    3405
                ],
                "kind": [
                    844,
                    845,
                    2926,
                    3184,
                    3188,
                    3135
                ],
                "slobj": [
                    845,
                    846
                ],
                "self.index._convert_slice_indexer": [
                    1037,
                    845
                ],
                "self._get_values": [
                    931,
                    902,
                    846,
                    880,
                    946,
                    922
                ],
                "key": [
                    899,
                    900,
                    901,
                    902,
                    1030,
                    905,
                    906,
                    908,
                    909,
                    1036,
                    911,
                    1037,
                    1040,
                    1044,
                    917,
                    919,
                    1048,
                    922,
                    1023,
                    924,
                    1051,
                    927,
                    1055,
                    1056,
                    1058,
                    931,
                    1059,
                    933,
                    1060,
                    935,
                    1062,
                    1066,
                    939,
                    1068,
                    1070,
                    1072,
                    946,
                    1075,
                    1076,
                    1079,
                    952,
                    1083,
                    1084,
                    1085,
                    849,
                    851,
                    854,
                    856,
                    1016,
                    988,
                    861,
                    992,
                    867,
                    997,
                    998,
                    999,
                    1002,
                    875,
                    876,
                    1005,
                    878,
                    879,
                    880,
                    1008,
                    882,
                    1015,
                    1013,
                    886,
                    887,
                    888,
                    1018,
                    893,
                    895
                ],
                "com.apply_if_callable": [
                    849,
                    988
                ],
                "key_is_scalar": [
                    873,
                    858,
                    854,
                    855
                ],
                "is_scalar": [
                    1040,
                    854,
                    1055
                ],
                "self.index._convert_scalar_indexer": [
                    856
                ],
                "self.index.get_value": [
                    985,
                    861
                ],
                "InvalidIndexError": [
                    864,
                    1003,
                    1020
                ],
                "is_iterator": [
                    875
                ],
                "com.is_bool_indexer": [
                    878,
                    1015
                ],
                "check_bool_indexer": [
                    1016,
                    879
                ],
                "self._get_with": [
                    882
                ],
                "self._slice": [
                    887
                ],
                "ABCDataFrame": [
                    888,
                    2434,
                    2451
                ],
                "self._get_values_tuple": [
                    895
                ],
                "key_type": [
                    1059,
                    1062,
                    1064,
                    909,
                    1069,
                    911,
                    915
                ],
                "key.inferred_type": [
                    1059,
                    909
                ],
                "lib.infer_dtype": [
                    1062,
                    911
                ],
                "self.index.is_integer": [
                    916
                ],
                "self.index.is_floating": [
                    916
                ],
                "self.loc": [
                    933,
                    1002,
                    1044,
                    917,
                    1119
                ],
                "IntervalIndex": [
                    918
                ],
                "indexer": [
                    1037,
                    1038,
                    919,
                    920,
                    3109,
                    3116,
                    3887,
                    1076,
                    1077,
                    3893,
                    952,
                    953,
                    1080,
                    3134,
                    960,
                    3138,
                    3139,
                    965,
                    3142
                ],
                "self.index.get_indexer_for": [
                    919
                ],
                "self.reindex": [
                    2439,
                    2732,
                    935
                ],
                "com.any_none": [
                    939
                ],
                "warnings.catch_warnings": [
                    942
                ],
                "warnings.filterwarnings": [
                    943
                ],
                "self.index.get_loc_level": [
                    952
                ],
                "self._data.get_slice": [
                    960
                ],
                "takeable": [
                    980,
                    1110
                ],
                "label": [
                    981,
                    1111,
                    1113,
                    985,
                    1119
                ],
                "cacher_needs_updating": [
                    1025,
                    989
                ],
                "self._check_is_chained_assignment_possible": [
                    989
                ],
                "self._set_with_engine": [
                    992
                ],
                "com.SettingWithCopyError": [
                    993
                ],
                "is_integer": [
                    1040,
                    997
                ],
                "self.index.inferred_type": [
                    1065,
                    997
                ],
                "self._set_with": [
                    1005,
                    1023
                ],
                "_is_unorderable_exception": [
                    1012
                ],
                "e": [
                    1012
                ],
                "self._where": [
                    1018
                ],
                "self._maybe_update_cacher": [
                    1026,
                    2789,
                    1086
                ],
                "loc": [
                    1032,
                    1113,
                    1115,
                    1030
                ],
                "self.index._engine.get_loc": [
                    1030
                ],
                "self.index._engine": [
                    1030
                ],
                "validate_numeric_casting": [
                    1114,
                    1031
                ],
                "self.dtype": [
                    1345,
                    1031,
                    2670,
                    3823,
                    3797,
                    1114
                ],
                "self._set_values": [
                    1068,
                    1070,
                    1038,
                    1080,
                    1051
                ],
                "key._values": [
                    1060,
                    1084
                ],
                "self._set_labels": [
                    1072,
                    1066
                ],
                "key.astype": [
                    1070
                ],
                "np.bool_": [
                    1070
                ],
                "com.asarray_tuplesafe": [
                    1075
                ],
                "self.index.get_indexer": [
                    1076
                ],
                "mask": [
                    2786,
                    2788,
                    1703,
                    1704,
                    1705,
                    3179,
                    3181,
                    3183,
                    1077,
                    1078,
                    1079
                ],
                "mask.any": [
                    1704,
                    3181,
                    1078
                ],
                "self._data.setitem": [
                    1085
                ],
                "self.index.get_loc": [
                    1113
                ],
                "nv.validate_repeat": [
                    1182
                ],
                "self.index.repeat": [
                    3486,
                    1183
                ],
                "repeats": [
                    1184,
                    1183
                ],
                "self._values.repeat": [
                    1184
                ],
                "inplace": [
                    4493,
                    1295,
                    4499,
                    4504,
                    1305,
                    2971,
                    3103,
                    1313,
                    4002,
                    4005,
                    1579,
                    1580,
                    4144,
                    3129,
                    4031,
                    4163,
                    3148,
                    1872,
                    4181,
                    2911,
                    2916
                ],
                "validate_bool_kwarg": [
                    1579,
                    4493,
                    1295,
                    2911,
                    3103
                ],
                "drop": [
                    1296,
                    4138,
                    1319
                ],
                "level": [
                    1298,
                    1299,
                    1300,
                    1301,
                    1302,
                    1303,
                    2590,
                    1694,
                    1697,
                    1698,
                    4002,
                    1700,
                    1701,
                    3108,
                    1319,
                    3110,
                    4143,
                    3530,
                    3922,
                    1652,
                    1660
                ],
                "self.index._get_level_number": [
                    1698,
                    1301
                ],
                "lev": [
                    1700,
                    1705,
                    1706,
                    1709,
                    1710,
                    1301
                ],
                "self.index.nlevels": [
                    1302
                ],
                "self.index.droplevel": [
                    1303
                ],
                "self._values.copy": [
                    1311
                ],
                "df": [
                    2177,
                    1318,
                    1319,
                    1563,
                    1565,
                    2175,
                    1567
                ],
                "self.to_frame": [
                    1451,
                    1318,
                    2175
                ],
                "df.reset_index": [
                    1319
                ],
                "buf": [
                    1350,
                    1451,
                    1423,
                    1328,
                    1427,
                    1429,
                    1343
                ],
                "StringIO": [
                    1328
                ],
                "width": [
                    1329
                ],
                "height": [
                    1336,
                    1329,
                    1331
                ],
                "get_terminal_size": [
                    1329
                ],
                "max_rows": [
                    1330,
                    1347,
                    1412
                ],
                "get_option": [
                    1332,
                    1333,
                    1337,
                    1338,
                    1340
                ],
                "min_rows": [
                    1346,
                    1411,
                    1335
                ],
                "show_dimensions": [
                    1340,
                    1348
                ],
                "self.to_string": [
                    1342
                ],
                "buf.getvalue": [
                    1350
                ],
                "formatter": [
                    1402,
                    1414
                ],
                "fmt.SeriesFormatter": [
                    1402
                ],
                "fmt": [
                    1402
                ],
                "length": [
                    1405
                ],
                "header": [
                    1406
                ],
                "na_rep": [
                    1409
                ],
                "float_format": [
                    1410
                ],
                "formatter.to_string": [
                    1414
                ],
                "buf.write": [
                    1427
                ],
                "f": [
                    3816,
                    3819,
                    3820,
                    3825,
                    3828,
                    1429,
                    1430
                ],
                "f.write": [
                    1430
                ],
                "IO": [
                    1449
                ],
                "to_markdown": [
                    1451
                ],
                "mode": [
                    1451
                ],
                "Substitution": [
                    4033,
                    1446,
                    2474,
                    3658,
                    4148,
                    4023
                ],
                "generic._shared_docs": [
                    3904,
                    4418,
                    1638,
                    1447,
                    4168,
                    3693,
                    3664,
                    4406,
                    4410,
                    4187,
                    4414
                ],
                "Iterable": [
                    1485,
                    1455
                ],
                "Tuple": [
                    1485,
                    1455
                ],
                "Label": [
                    1485,
                    1455
                ],
                "self.items": [
                    1486,
                    1535
                ],
                "items.__doc__": [
                    1484
                ],
                "items": [
                    1484
                ],
                "into_c": [
                    1534,
                    1535
                ],
                "com.standardize_mapping": [
                    1534
                ],
                "into": [
                    1534
                ],
                "self._constructor_expanddim": [
                    3833,
                    1563,
                    1565
                ],
                "ser": [
                    1580,
                    1581,
                    1582
                ],
                "self.copy": [
                    3428,
                    1580,
                    3889,
                    4508,
                    3482,
                    3132
                ],
                "ser.name": [
                    1581
                ],
                "by": [
                    1658,
                    1652
                ],
                "self._get_axis_number": [
                    2913,
                    3105,
                    3849,
                    4495,
                    3696,
                    3667,
                    1654
                ],
                "SeriesGroupBy": [
                    1656
                ],
                "as_index": [
                    1661
                ],
                "sort": [
                    1662
                ],
                "group_keys": [
                    1663
                ],
                "squeeze": [
                    1664
                ],
                "observed": [
                    1665
                ],
                "notna": [
                    4416,
                    2786,
                    1708,
                    2737,
                    1695
                ],
                "self.index.levels": [
                    1700
                ],
                "level_codes": [
                    1705,
                    1708,
                    1701,
                    1703
                ],
                "np.array": [
                    1701
                ],
                "self.index.codes": [
                    1701
                ],
                "cnt": [
                    1705,
                    1706
                ],
                "lev.insert": [
                    1706
                ],
                "lev._na_value": [
                    1706
                ],
                "obs": [
                    1708,
                    1709
                ],
                "self.values": [
                    2444,
                    2691,
                    1708,
                    2693
                ],
                "out": [
                    1709,
                    1710
                ],
                "np.bincount": [
                    1709
                ],
                "algorithms.mode": [
                    1731
                ],
                "algorithms": [
                    2336,
                    1731,
                    4300,
                    2477,
                    3892,
                    3287,
                    3384
                ],
                "dropna": [
                    1731
                ],
                "unique": [
                    1794
                ],
                "drop_duplicates": [
                    1872
                ],
                "keep": [
                    1872,
                    3384,
                    1950,
                    3287
                ],
                "duplicated": [
                    1950
                ],
                "skipna": [
                    2016,
                    2017,
                    2087,
                    2088,
                    3880,
                    3852,
                    3855,
                    3871
                ],
                "nv.validate_argmin_with_skipna": [
                    2016
                ],
                "args": [
                    2016,
                    3810,
                    3685,
                    3813,
                    2087,
                    3687,
                    2122,
                    3697,
                    3668,
                    3803,
                    3807
                ],
                "nanops.nanargmin": [
                    2017
                ],
                "nanops": [
                    2088,
                    2017,
                    2268,
                    2231
                ],
                "com.values_from_object": [
                    2088,
                    2017,
                    2123
                ],
                "np.nan": [
                    2090,
                    2019,
                    2228,
                    2267
                ],
                "nv.validate_argmax_with_skipna": [
                    2087
                ],
                "nanops.nanargmax": [
                    2088
                ],
                "nv.validate_round": [
                    2122
                ],
                "decimals": [
                    2123
                ],
                "validate_percentile": [
                    2171
                ],
                "q": [
                    2177,
                    2171,
                    2181,
                    2183
                ],
                "df.quantile": [
                    2177
                ],
                "interpolation": [
                    2177
                ],
                "result.iloc": [
                    2186,
                    2179
                ],
                "result.name": [
                    2182
                ],
                "Float64Index": [
                    2183
                ],
                "this": [
                    2593,
                    2732,
                    2734,
                    2737,
                    2226,
                    2227,
                    2232,
                    2265,
                    2266,
                    2587,
                    2268,
                    2590,
                    2591
                ],
                "other": [
                    2688,
                    2434,
                    2435,
                    2436,
                    2440,
                    2445,
                    2451,
                    2453,
                    2583,
                    2455,
                    2460,
                    2589,
                    2590,
                    2593,
                    2466,
                    2598,
                    2472,
                    2731,
                    2733,
                    2734,
                    2735,
                    2737,
                    2226,
                    2232,
                    3919,
                    2265,
                    2268,
                    2785,
                    2786,
                    2788,
                    2672,
                    2675,
                    2676,
                    2680
                ],
                "self.align": [
                    2265,
                    2226,
                    2590
                ],
                "nanops.nancorr": [
                    2231
                ],
                "this.values": [
                    2232,
                    2593,
                    2268
                ],
                "other.values": [
                    2232,
                    2593,
                    2268
                ],
                "min_periods": [
                    2232,
                    2268
                ],
                "nanops.nancov": [
                    2268
                ],
                "algorithms.diff": [
                    2336
                ],
                "periods": [
                    2336,
                    4190
                ],
                "self.corr": [
                    2382
                ],
                "self.shift": [
                    2382
                ],
                "lag": [
                    2382
                ],
                "common": [
                    2440,
                    2435,
                    2436,
                    2439
                ],
                "self.index.union": [
                    2675,
                    2435,
                    2731
                ],
                "other.index": [
                    2435,
                    2436,
                    2731,
                    2675,
                    2589
                ],
                "left": [
                    2441,
                    4370,
                    4373,
                    2439
                ],
                "right": [
                    2440,
                    2442,
                    4371,
                    4374
                ],
                "other.reindex": [
                    2440,
                    2733
                ],
                "lvals": [
                    2441,
                    2444,
                    2446,
                    2448,
                    2453,
                    2456,
                    2458
                ],
                "left.values": [
                    2441
                ],
                "rvals": [
                    2442,
                    2445,
                    2446,
                    2448,
                    2453,
                    2456,
                    2457,
                    2458
                ],
                "right.values": [
                    2442
                ],
                "lvals.shape": [
                    2448,
                    2446
                ],
                "rvals.shape": [
                    2448,
                    2446
                ],
                "np.dot": [
                    2456,
                    2458,
                    2453
                ],
                "other.columns": [
                    2453
                ],
                "self.dot": [
                    2472,
                    2466
                ],
                "np.transpose": [
                    2472
                ],
                "algorithms.searchsorted": [
                    2477
                ],
                "side": [
                    2477
                ],
                "sorter": [
                    2477
                ],
                "base._shared_docs": [
                    2475
                ],
                "to_append": [
                    2554,
                    2556,
                    2558
                ],
                "to_concat": [
                    2560,
                    2555,
                    2556,
                    2558
                ],
                "to_concat.extend": [
                    2556
                ],
                "concat": [
                    2559
                ],
                "ignore_index": [
                    2560,
                    3145,
                    2968
                ],
                "verify_integrity": [
                    2560
                ],
                "self.index.equals": [
                    2589
                ],
                "this.index": [
                    2591
                ],
                "this_vals": [
                    2593,
                    2596
                ],
                "other_vals": [
                    2593,
                    2596
                ],
                "ops.fill_binop": [
                    2593
                ],
                "fill_value": [
                    2593,
                    3530,
                    2669,
                    2670,
                    3924,
                    2679,
                    2680,
                    4190
                ],
                "np.errstate": [
                    2595,
                    3818,
                    2681,
                    3870,
                    2687
                ],
                "func": [
                    2688,
                    3810,
                    2596,
                    3685,
                    3813,
                    3687,
                    3816,
                    3697,
                    3668,
                    3802,
                    2682,
                    3803,
                    3806,
                    3807
                ],
                "ops.get_op_result_name": [
                    2676,
                    2598
                ],
                "ret": [
                    2600,
                    2599
                ],
                "ops._construct_result": [
                    2599
                ],
                "new_name": [
                    2689,
                    2697,
                    2676
                ],
                "idx": [
                    2957,
                    2958,
                    2961,
                    2962,
                    2678,
                    2679,
                    2680,
                    2938
                ],
                "lv": [
                    2688,
                    2682,
                    2679
                ],
                "self.get": [
                    2679
                ],
                "rv": [
                    2680,
                    2682
                ],
                "other.get": [
                    2680
                ],
                "new_values.append": [
                    2682
                ],
                "try_cast_to_ea": [
                    2696
                ],
                "this.dtype.kind": [
                    2734
                ],
                "this.dtype": [
                    2734
                ],
                "other.dtype.kind": [
                    2734
                ],
                "other.dtype": [
                    2734
                ],
                "to_datetime": [
                    2735
                ],
                "this.where": [
                    2737
                ],
                "other.reindex_like": [
                    2785
                ],
                "self._data.putmask": [
                    2788
                ],
                "self._is_cached": [
                    2916
                ],
                "arr.argsort": [
                    2930,
                    2926
                ],
                "arr": [
                    2926,
                    2930,
                    2932,
                    2966,
                    2935,
                    2940
                ],
                "sorted_index": [
                    2957,
                    2958,
                    2961,
                    2962,
                    2933,
                    2966,
                    2969
                ],
                "np.empty": [
                    2933
                ],
                "np.int32": [
                    2933
                ],
                "bad": [
                    2958,
                    2960,
                    2962,
                    2935,
                    2937
                ],
                "isna": [
                    4408,
                    3179,
                    2935
                ],
                "good": [
                    2956,
                    2957,
                    2961,
                    2937,
                    2940
                ],
                "argsorted": [
                    2953,
                    2961,
                    2940,
                    2957
                ],
                "_try_kind_sort": [
                    2940
                ],
                "ascending": [
                    2945,
                    2947,
                    2949,
                    3110,
                    2952,
                    3118,
                    3126,
                    3127,
                    3135,
                    2942,
                    2943
                ],
                "is_bool": [
                    2949
                ],
                "na_position": [
                    2955,
                    3119,
                    2959,
                    2964,
                    3135
                ],
                "n": [
                    2956,
                    2957,
                    2958,
                    2960,
                    2961,
                    2962,
                    3287,
                    3384
                ],
                "good.sum": [
                    2956
                ],
                "bad.sum": [
                    2960
                ],
                "result.index": [
                    2969,
                    3146,
                    3429,
                    3430
                ],
                "self._update_inplace": [
                    4500,
                    2972,
                    3149
                ],
                "result.__finalize__": [
                    2974,
                    3151
                ],
                "index.sortlevel": [
                    3109
                ],
                "sort_remaining": [
                    3110
                ],
                "index._sort_levels_monotonic": [
                    3115
                ],
                "lexsort_indexer": [
                    3116
                ],
                "labels._get_codes_for_sorting": [
                    3117
                ],
                "index.is_monotonic_increasing": [
                    3126
                ],
                "index.is_monotonic_decreasing": [
                    3127
                ],
                "nargsort": [
                    3134
                ],
                "index.take": [
                    3139
                ],
                "new_index._sort_levels_monotonic": [
                    3140
                ],
                "notmask": [
                    3184,
                    3183
                ],
                "np.argsort": [
                    3184,
                    3188
                ],
                "nlargest": [
                    3287
                ],
                "algorithms.SelectNSeries": [
                    3384,
                    3287
                ],
                "nsmallest": [
                    3384
                ],
                "ABCMultiIndex": [
                    3404,
                    3429
                ],
                "self.index.swaplevel": [
                    3405
                ],
                "j": [
                    3405
                ],
                "result.index.reorder_levels": [
                    3430
                ],
                "is_object_dtype": [
                    3481,
                    4391
                ],
                "counts": [
                    3484,
                    3486
                ],
                "reshape.explode": [
                    3484
                ],
                "reshape": [
                    3484
                ],
                "unstack": [
                    3530
                ],
                "_map_values": [
                    3610
                ],
                "arg": [
                    3610
                ],
                "na_action": [
                    3610
                ],
                "_agg_see_also_doc": [
                    3659,
                    3627
                ],
                "dedent": [
                    3627,
                    3636
                ],
                "_agg_examples_doc": [
                    3636,
                    3660
                ],
                "how": [
                    4536,
                    3668
                ],
                "self._aggregate": [
                    3668
                ],
                "kwargs.pop": [
                    3673,
                    3674
                ],
                "self.apply": [
                    3685
                ],
                "agg": [
                    3691
                ],
                "aggregate": [
                    3691
                ],
                "transform": [
                    3697
                ],
                "self.aggregate": [
                    3803
                ],
                "kwds": [
                    3810,
                    3813,
                    3883,
                    3852,
                    3855,
                    3871,
                    3803,
                    3807
                ],
                "self._try_aggregate_string_function": [
                    3807
                ],
                "np.ufunc": [
                    3810,
                    3819
                ],
                "mapped": [
                    3825,
                    3828,
                    3830,
                    3833,
                    3835
                ],
                "self._values.map": [
                    3825
                ],
                "self.astype": [
                    3827
                ],
                "lib.map_infer": [
                    3828
                ],
                "convert_dtype": [
                    3828
                ],
                "pd.array": [
                    3833
                ],
                "pd": [
                    3833
                ],
                "delegate": [
                    3876,
                    3846,
                    3851,
                    3852,
                    3853,
                    3855,
                    3856,
                    3858,
                    3859,
                    3862,
                    3865,
                    3871
                ],
                "Categorical": [
                    3851
                ],
                "delegate._reduce": [
                    3852,
                    3876,
                    3855
                ],
                "is_datetime64_dtype": [
                    3856
                ],
                "is_timedelta64_dtype": [
                    3859
                ],
                "numeric_only": [
                    3881,
                    3866
                ],
                "op": [
                    3877,
                    3871
                ],
                "filter_type": [
                    3882
                ],
                "algorithms.take_1d": [
                    3892
                ],
                "align": [
                    3918
                ],
                "join": [
                    3920
                ],
                "limit": [
                    4182,
                    4164,
                    3926
                ],
                "fill_axis": [
                    3927
                ],
                "broadcast_axis": [
                    3928
                ],
                "rename": [
                    4001
                ],
                "errors": [
                    4145,
                    4002
                ],
                "self._set_name": [
                    4005
                ],
                "set_axis": [
                    4031
                ],
                "generic.NDFrame.set_axis.__doc__": [
                    4029
                ],
                "generic.NDFrame.set_axis": [
                    4029
                ],
                "reindex": [
                    4036
                ],
                "generic.NDFrame.reindex.__doc__": [
                    4034
                ],
                "generic.NDFrame.reindex": [
                    4034
                ],
                "columns": [
                    4142
                ],
                "fillna": [
                    4159
                ],
                "downcast": [
                    4165
                ],
                "generic.NDFrame.fillna.__doc__": [
                    4149
                ],
                "generic.NDFrame.fillna": [
                    4149
                ],
                "replace": [
                    4178
                ],
                "to_replace": [
                    4179
                ],
                "regex": [
                    4183
                ],
                "shift": [
                    4189
                ],
                "freq": [
                    4536,
                    4561,
                    4190
                ],
                "v": [
                    4242,
                    4244,
                    4245
                ],
                "memory_usage": [
                    4242
                ],
                "deep": [
                    4242,
                    4244
                ],
                "self.index.memory_usage": [
                    4244
                ],
                "algorithms.isin": [
                    4300
                ],
                "inclusive": [
                    4369
                ],
                "lmask": [
                    4376,
                    4370,
                    4373
                ],
                "rmask": [
                    4376,
                    4371,
                    4374
                ],
                "input_series": [
                    4388,
                    4390,
                    4391,
                    4392,
                    4396,
                    4399,
                    4401,
                    4403
                ],
                "infer_objects": [
                    4389
                ],
                "input_series.infer_objects": [
                    4390
                ],
                "input_series.copy": [
                    4392,
                    4401,
                    4403
                ],
                "convert_string": [
                    4394,
                    4396
                ],
                "convert_integer": [
                    4394,
                    4396
                ],
                "convert_boolean": [
                    4394,
                    4396
                ],
                "inferred_dtype": [
                    4395,
                    4399
                ],
                "convert_dtypes": [
                    4395
                ],
                "input_series._values": [
                    4396
                ],
                "input_series.astype": [
                    4399
                ],
                "isnull": [
                    4412
                ],
                "notnull": [
                    4420
                ],
                "self._can_hold_na": [
                    4497
                ],
                "remove_na_arraylike": [
                    4498
                ],
                "new_values.copy": [
                    4533,
                    4558
                ],
                "ABCPeriodIndex": [
                    4535
                ],
                "self.index.to_timestamp": [
                    4536
                ],
                "self.index.to_period": [
                    4561
                ],
                "properties.AxisProperty": [
                    4566
                ],
                "properties": [
                    4566
                ],
                "CachedAccessor": [
                    4576,
                    4577,
                    4573,
                    4574,
                    4575
                ],
                "StringMethods": [
                    4573
                ],
                "dt": [
                    4574
                ],
                "CombinedDatetimelikeProperties": [
                    4574
                ],
                "cat": [
                    4575
                ],
                "CategoricalAccessor": [
                    4575
                ],
                "plot": [
                    4576
                ],
                "pandas.plotting.PlotAccessor": [
                    4576
                ],
                "pandas.plotting": [
                    4576,
                    4581
                ],
                "pandas": [
                    4576,
                    4581
                ],
                "sparse": [
                    4577
                ],
                "SparseAccessor": [
                    4577
                ],
                "hist": [
                    4581
                ],
                "pandas.plotting.hist_series": [
                    4581
                ],
                "Series._setup_axes": [
                    4584
                ],
                "Series._add_numeric_operations": [
                    4585
                ],
                "Series._add_series_or_dataframe_operations": [
                    4586
                ],
                "ops.add_flex_arithmetic_methods": [
                    4589
                ],
                "ops.add_special_arithmetic_methods": [
                    4590
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/home/ubuntu/Desktop/bgp_envs_local/repos/pandas_61/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_getitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"getitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_getitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        msg = \"|\".join(\n            [\n                r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)\",\n                \"Cannot index with multidimensional key\",\n                r\"Wrong number of dimensions. values.ndim != ndim \\[3 != 1\\]\",\n                \"Index data must be 1-dimensional\",\n            ]\n        )\n\n        with pytest.raises(ValueError, match=msg):\n            with tm.assert_produces_warning(DeprecationWarning, check_stacklevel=False):\n                idxr[nd3]",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x7ff756f65b50>\nindex = Index(['P88qpWCSpW', 'EcdlEpkZEz', 'MQ0bC3nTc7', 'n6hid94wNl', 'qVynXX6N42'], dtype='object')\nobj = P88qpWCSpW    0\nEcdlEpkZEz    1\nMQ0bC3nTc7    2\nn6hid94wNl    3\nqVynXX6N42    4\ndtype: int64\nidxr = P88qpWCSpW    0\nEcdlEpkZEz    1\nMQ0bC3nTc7    2\nn6hid94wNl    3\nqVynXX6N42    4\ndtype: int64\nidxr_id = 'getitem'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"getitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_getitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        msg = \"|\".join(\n            [\n                r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)\",\n                \"Cannot index with multidimensional key\",\n                r\"Wrong number of dimensions. values.ndim != ndim \\[3 != 1\\]\",\n                \"Index data must be 1-dimensional\",\n            ]\n        )\n    \n        with pytest.raises(ValueError, match=msg):\n            with tm.assert_produces_warning(DeprecationWarning, check_stacklevel=False):\n>               idxr[nd3]\nE               Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:94: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'getitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/home/ubuntu/Desktop/bgp_envs_local/repos/pandas_61/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_getitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"getitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_getitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        msg = \"|\".join(\n            [\n                r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)\",\n                \"Cannot index with multidimensional key\",\n                r\"Wrong number of dimensions. values.ndim != ndim \\[3 != 1\\]\",\n                \"Index data must be 1-dimensional\",\n            ]\n        )\n\n        with pytest.raises(ValueError, match=msg):\n            with tm.assert_produces_warning(DeprecationWarning, check_stacklevel=False):\n                idxr[nd3]",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x7ff757159460>\nindex = Index(['021\u05d1\u05dc6\u05e3\u05e6\u05de\u05d9', '\u05de\u05e6\u05d54\u05e7\u05de8\u05e361', '\u05dc0\u05e38\u05d0\u05d1\u05da8\u05d86', '4\u05e2\u05e5\u05db\u05d6\u05d7\u05e0\u05dd\u05d3\u05e1', '31\u05e6\u05e5\u05d4\u05db32\u05e0\u05d3'], dtype='object')\nobj = 021\u05d1\u05dc6\u05e3\u05e6\u05de\u05d9    0\n\u05de\u05e6\u05d54\u05e7\u05de8\u05e361    1\n\u05dc0\u05e38\u05d0\u05d1\u05da8\u05d86    2\n4\u05e2\u05e5\u05db\u05d6\u05d7\u05e0\u05dd\u05d3\u05e1    3\n31\u05e6\u05e5\u05d4\u05db32\u05e0\u05d3    4\ndtype: int64\nidxr = 021\u05d1\u05dc6\u05e3\u05e6\u05de\u05d9    0\n\u05de\u05e6\u05d54\u05e7\u05de8\u05e361    1\n\u05dc0\u05e38\u05d0\u05d1\u05da8\u05d86    2\n4\u05e2\u05e5\u05db\u05d6\u05d7\u05e0\u05dd\u05d3\u05e1    3\n31\u05e6\u05e5\u05d4\u05db32\u05e0\u05d3    4\ndtype: int64\nidxr_id = 'getitem'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"getitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_getitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        msg = \"|\".join(\n            [\n                r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)\",\n                \"Cannot index with multidimensional key\",\n                r\"Wrong number of dimensions. values.ndim != ndim \\[3 != 1\\]\",\n                \"Index data must be 1-dimensional\",\n            ]\n        )\n    \n        with pytest.raises(ValueError, match=msg):\n            with tm.assert_produces_warning(DeprecationWarning, check_stacklevel=False):\n>               idxr[nd3]\nE               Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:94: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'getitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/home/ubuntu/Desktop/bgp_envs_local/repos/pandas_61/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_getitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"getitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_getitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        msg = \"|\".join(\n            [\n                r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)\",\n                \"Cannot index with multidimensional key\",\n                r\"Wrong number of dimensions. values.ndim != ndim \\[3 != 1\\]\",\n                \"Index data must be 1-dimensional\",\n            ]\n        )\n\n        with pytest.raises(ValueError, match=msg):\n            with tm.assert_produces_warning(DeprecationWarning, check_stacklevel=False):\n                idxr[nd3]",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x7ff756f65d90>\nindex = DatetimeIndex(['2000-01-03', '2000-01-04', '2000-01-05', '2000-01-06',\n               '2000-01-07'],\n              dtype='datetime64[ns]', freq='B')\nobj = 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64\nidxr = 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64\nidxr_id = 'getitem'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"getitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_getitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        msg = \"|\".join(\n            [\n                r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)\",\n                \"Cannot index with multidimensional key\",\n                r\"Wrong number of dimensions. values.ndim != ndim \\[3 != 1\\]\",\n                \"Index data must be 1-dimensional\",\n            ]\n        )\n    \n        with pytest.raises(ValueError, match=msg):\n            with tm.assert_produces_warning(DeprecationWarning, check_stacklevel=False):\n>               idxr[nd3]\nE               Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:94: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'getitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/home/ubuntu/Desktop/bgp_envs_local/repos/pandas_61/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_getitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"getitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_getitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        msg = \"|\".join(\n            [\n                r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)\",\n                \"Cannot index with multidimensional key\",\n                r\"Wrong number of dimensions. values.ndim != ndim \\[3 != 1\\]\",\n                \"Index data must be 1-dimensional\",\n            ]\n        )\n\n        with pytest.raises(ValueError, match=msg):\n            with tm.assert_produces_warning(DeprecationWarning, check_stacklevel=False):\n                idxr[nd3]",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x7ff7570cc4f0>\nindex = PeriodIndex(['2000-01-03', '2000-01-04', '2000-01-05', '2000-01-06',\n             '2000-01-07'],\n            dtype='period[B]', freq='B')\nobj = 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64\nidxr = 2000-01-03    0\n2000-01-04    1\n2000-01-05    2\n2000-01-06    3\n2000-01-07    4\nFreq: B, dtype: int64\nidxr_id = 'getitem'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"getitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_getitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        msg = \"|\".join(\n            [\n                r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)\",\n                \"Cannot index with multidimensional key\",\n                r\"Wrong number of dimensions. values.ndim != ndim \\[3 != 1\\]\",\n                \"Index data must be 1-dimensional\",\n            ]\n        )\n    \n        with pytest.raises(ValueError, match=msg):\n            with tm.assert_produces_warning(DeprecationWarning, check_stacklevel=False):\n>               idxr[nd3]\nE               Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:94: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'getitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/home/ubuntu/Desktop/bgp_envs_local/repos/pandas_61/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_getitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"getitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_getitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        msg = \"|\".join(\n            [\n                r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)\",\n                \"Cannot index with multidimensional key\",\n                r\"Wrong number of dimensions. values.ndim != ndim \\[3 != 1\\]\",\n                \"Index data must be 1-dimensional\",\n            ]\n        )\n\n        with pytest.raises(ValueError, match=msg):\n            with tm.assert_produces_warning(DeprecationWarning, check_stacklevel=False):\n                idxr[nd3]",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x7ff7571af130>\nindex = TimedeltaIndex(['1 days', '2 days', '3 days', '4 days', '5 days'], dtype='timedelta64[ns]', freq='D')\nobj = 1 days    0\n2 days    1\n3 days    2\n4 days    3\n5 days    4\nFreq: D, dtype: int64\nidxr = 1 days    0\n2 days    1\n3 days    2\n4 days    3\n5 days    4\nFreq: D, dtype: int64\nidxr_id = 'getitem'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"getitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_getitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        msg = \"|\".join(\n            [\n                r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)\",\n                \"Cannot index with multidimensional key\",\n                r\"Wrong number of dimensions. values.ndim != ndim \\[3 != 1\\]\",\n                \"Index data must be 1-dimensional\",\n            ]\n        )\n    \n        with pytest.raises(ValueError, match=msg):\n            with tm.assert_produces_warning(DeprecationWarning, check_stacklevel=False):\n>               idxr[nd3]\nE               Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:94: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'getitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/home/ubuntu/Desktop/bgp_envs_local/repos/pandas_61/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_getitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"getitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_getitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        msg = \"|\".join(\n            [\n                r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)\",\n                \"Cannot index with multidimensional key\",\n                r\"Wrong number of dimensions. values.ndim != ndim \\[3 != 1\\]\",\n                \"Index data must be 1-dimensional\",\n            ]\n        )\n\n        with pytest.raises(ValueError, match=msg):\n            with tm.assert_produces_warning(DeprecationWarning, check_stacklevel=False):\n                idxr[nd3]",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x7ff757137070>\nindex = Index([False, True, False, False, False], dtype='object')\nobj = False    0\nTrue     1\nFalse    2\nFalse    3\nFalse    4\ndtype: int64\nidxr = False    0\nTrue     1\nFalse    2\nFalse    3\nFalse    4\ndtype: int64\nidxr_id = 'getitem'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"getitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_getitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        msg = \"|\".join(\n            [\n                r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)\",\n                \"Cannot index with multidimensional key\",\n                r\"Wrong number of dimensions. values.ndim != ndim \\[3 != 1\\]\",\n                \"Index data must be 1-dimensional\",\n            ]\n        )\n    \n        with pytest.raises(ValueError, match=msg):\n            with tm.assert_produces_warning(DeprecationWarning, check_stacklevel=False):\n>               idxr[nd3]\nE               Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:94: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'getitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/home/ubuntu/Desktop/bgp_envs_local/repos/pandas_61/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_getitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"getitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_getitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        msg = \"|\".join(\n            [\n                r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)\",\n                \"Cannot index with multidimensional key\",\n                r\"Wrong number of dimensions. values.ndim != ndim \\[3 != 1\\]\",\n                \"Index data must be 1-dimensional\",\n            ]\n        )\n\n        with pytest.raises(ValueError, match=msg):\n            with tm.assert_produces_warning(DeprecationWarning, check_stacklevel=False):\n                idxr[nd3]",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x7ff757187550>\nindex = CategoricalIndex(['xo6H', '0Upa', 'Hmsu', 'xo6H', '0Upa'], categories=['xo6H', '0Upa', 'Hmsu'], ordered=False, dtype='category')\nobj = xo6H    0\n0Upa    1\nHmsu    2\nxo6H    3\n0Upa    4\ndtype: int64\nidxr = xo6H    0\n0Upa    1\nHmsu    2\nxo6H    3\n0Upa    4\ndtype: int64\nidxr_id = 'getitem'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"getitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_getitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        msg = \"|\".join(\n            [\n                r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)\",\n                \"Cannot index with multidimensional key\",\n                r\"Wrong number of dimensions. values.ndim != ndim \\[3 != 1\\]\",\n                \"Index data must be 1-dimensional\",\n            ]\n        )\n    \n        with pytest.raises(ValueError, match=msg):\n            with tm.assert_produces_warning(DeprecationWarning, check_stacklevel=False):\n>               idxr[nd3]\nE               Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:94: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'getitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            }
        ]
    }
}