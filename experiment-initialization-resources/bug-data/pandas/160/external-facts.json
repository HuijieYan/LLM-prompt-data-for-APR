{
    "pandas:160": {
        "github_issue_title": [
            "Operators between DataFrame and Series fail on large dataframes\n"
        ],
        "github_issue_description": [
            "Code Sample\nimport pandas as pd\n\nind = list(range(0, 100))\ncols = list(range(0, 300))\ndf = pd.DataFrame(index=ind, columns=cols, data=1.0)\nseries = pd.Series(index=cols, data=cols)\nprint(df.multiply(series, axis=1).head())  # Works fine\nind = list(range(0, 100000))\ncols = list(range(0, 300))\ndf = pd.DataFrame(index=ind, columns=cols, data=1.0)\nseries = pd.Series(index=cols, data=cols)\nprint(df.add(series,axis=1).head()) \nCode Output:\n   0    1    2    3    4    5    ...    294    295    296    297    298    299\n0  0.0  1.0  2.0  3.0  4.0  5.0  ...  294.0  295.0  296.0  297.0  298.0  299.0\n1  0.0  1.0  2.0  3.0  4.0  5.0  ...  294.0  295.0  296.0  297.0  298.0  299.0\n2  0.0  1.0  2.0  3.0  4.0  5.0  ...  294.0  295.0  296.0  297.0  298.0  299.0\n3  0.0  1.0  2.0  3.0  4.0  5.0  ...  294.0  295.0  296.0  297.0  298.0  299.0\n4  0.0  1.0  2.0  3.0  4.0  5.0  ...  294.0  295.0  296.0  297.0  298.0  299.0\n[5 rows x 300 columns]\nTraceback (most recent call last):\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\IPython\\core\\interactiveshell.py\", line 2963, in run_code\n    exec(code_obj, self.user_global_ns, self.user_ns)\n  File \"<ipython-input-25-4d9165e5df4a>\", line 15, in <module>\n    print(df.add(series,axis=1).head())\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\ops\\__init__.py\", line 1499, in f\n    self, other, pass_op, fill_value=fill_value, axis=axis, level=level\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\ops\\__init__.py\", line 1388, in _combine_series_frame\n    return self._combine_match_columns(other, func, level=level)\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\frame.py\", line 5392, in _combine_match_columns\n    return ops.dispatch_to_series(left, right, func, axis=\"columns\")\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\ops\\__init__.py\", line 596, in dispatch_to_series\n    new_data = expressions.evaluate(column_op, str_rep, left, right)\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\computation\\expressions.py\", line 220, in evaluate\n    return _evaluate(op, op_str, a, b, **eval_kwargs)\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\computation\\expressions.py\", line 126, in _evaluate_numexpr\n    result = _evaluate_standard(op, op_str, a, b)\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\computation\\expressions.py\", line 70, in _evaluate_standard\n    return op(a, b)\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\ops\\__init__.py\", line 584, in column_op\n    return {i: func(a.iloc[:, i], b.iloc[i]) for i in range(len(a.columns))}\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\ops\\__init__.py\", line 584, in <dictcomp>\n    return {i: func(a.iloc[:, i], b.iloc[i]) for i in range(len(a.columns))}\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\ops\\__init__.py\", line 1473, in na_op\n    result = expressions.evaluate(op, str_rep, x, y, **eval_kwargs)\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\computation\\expressions.py\", line 220, in evaluate\n    return _evaluate(op, op_str, a, b, **eval_kwargs)\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\computation\\expressions.py\", line 101, in _evaluate_numexpr\n    if _can_use_numexpr(op, op_str, a, b, \"evaluate\"):\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\computation\\expressions.py\", line 84, in _can_use_numexpr\n    s = o.dtypes.value_counts()\nAttributeError: 'numpy.dtype' object has no attribute 'value_counts'\nProblem description\nI think this is a regression somewhere between pandas 0.19.2 and 0.25. If you multiply or use any other operator function such as add/divide on a DataFrame by a Series where axis=1 pandas will crash in the _can_use_numexpr functon when the DataFrame/Series becomes very large. This is presumably down to check of the size of the objects being operated on not passing for small datasets but for larger ones it gets to the failing line.\n\n#pandas/core/computation/expressions.py : 73\ndef _can_use_numexpr(op, op_str, a, b, dtype_check):\n    \"\"\" return a boolean if we WILL be using numexpr \"\"\"\n    if op_str is not None:\n\n        # required min elements (otherwise we are adding overhead)\n        if np.prod(a.shape) > _MIN_ELEMENTS:\n\n            # check for dtype compatibility\n            dtypes = set()\n            for o in [a, b]:\n                if hasattr(o, \"dtypes\"):\n                    s = o.dtypes.value_counts()  # Fails here\nIn pandas 0.19.2 the function uses the get_dtype_counts() method instead to inspect if the dtype is uniform in the object:\n\ndef _can_use_numexpr(op, op_str, a, b, dtype_check):\n    \"\"\" return a boolean if we WILL be using numexpr \"\"\"\n    if op_str is not None:\n\n        # required min elements (otherwise we are adding overhead)\n        if np.prod(a.shape) > _MIN_ELEMENTS:\n\n            # check for dtype compatiblity\n            dtypes = set()\n            for o in [a, b]:\n                if hasattr(o, 'get_dtype_counts'):\n                    s = o.get_dtype_counts()\nI have a workaround which is to transpose the dataframe and use axis=0:\n\ndf.T.add(series,axis=0).T.head()\nI noticed get_dtype_counts() is deprecated ( #27145 ) which appears to be the PR that has caused this regression as a Series only returns a single numpy dtype which does not have a value_counts() method.\n"
        ]
    }
}