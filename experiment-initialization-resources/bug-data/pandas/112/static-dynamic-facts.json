{
    "pandas:112": {
        "/home/ubuntu/Desktop/bgp_envs_local/repos/pandas_112/pandas/core/indexes/interval.py": {
            "buggy_functions": [
                {
                    "function_name": "get_indexer",
                    "function_code": "@Substitution(\n    **dict(\n        _index_doc_kwargs,\n        **{\n            \"raises_section\": textwrap.dedent(\n                \"\"\"\n    Raises\n    ------\n    NotImplementedError\n        If any method argument other than the default of\n        None is specified as these are not yet implemented.\n    \"\"\"\n            )\n        },\n    )\n)\n@Appender(_index_shared_docs[\"get_indexer\"])\ndef get_indexer(\n    self,\n    target: AnyArrayLike,\n    method: Optional[str] = None,\n    limit: Optional[int] = None,\n    tolerance: Optional[Any] = None,\n) -> np.ndarray:\n\n    self._check_method(method)\n\n    if self.is_overlapping:\n        msg = (\n            \"cannot handle overlapping indices; use \"\n            \"IntervalIndex.get_indexer_non_unique\"\n        )\n        raise InvalidIndexError(msg)\n\n    target_as_index = ensure_index(target)\n\n    if isinstance(target_as_index, IntervalIndex):\n        # equal indexes -> 1:1 positional match\n        if self.equals(target_as_index):\n            return np.arange(len(self), dtype=\"intp\")\n\n        # different closed or incompatible subtype -> no matches\n        common_subtype = find_common_type(\n            [self.dtype.subtype, target_as_index.dtype.subtype]\n        )\n        if self.closed != target_as_index.closed or is_object_dtype(common_subtype):\n            return np.repeat(np.intp(-1), len(target_as_index))\n\n        # non-overlapping -> at most one match per interval in target_as_index\n        # want exact matches -> need both left/right to match, so defer to\n        # left/right get_indexer, compare elementwise, equality -> match\n        left_indexer = self.left.get_indexer(target_as_index.left)\n        right_indexer = self.right.get_indexer(target_as_index.right)\n        indexer = np.where(left_indexer == right_indexer, left_indexer, -1)\n    elif not is_object_dtype(target_as_index):\n        # homogeneous scalar index: use IntervalTree\n        target_as_index = self._maybe_convert_i8(target_as_index)\n        indexer = self._engine.get_indexer(target_as_index.values)\n    else:\n        # heterogeneous scalar index: defer elementwise to get_loc\n        # (non-overlapping so get_loc guarantees scalar of KeyError)\n        indexer = []\n        for key in target_as_index:\n            try:\n                loc = self.get_loc(key)\n            except KeyError:\n                loc = -1\n            indexer.append(loc)\n\n    return ensure_platform_int(indexer)\n",
                    "decorators": [
                        "Substitution(**dict(_index_doc_kwargs, **{'raises_section': textwrap.dedent('\\n        Raises\\n        ------\\n        NotImplementedError\\n            If any method argument other than the default of\\n            None is specified as these are not yet implemented.\\n        ')}))",
                        "Appender(_index_shared_docs['get_indexer'])"
                    ],
                    "docstring": null,
                    "start_line": 907,
                    "end_line": 976,
                    "variables": {
                        "AnyArrayLike": [
                            926
                        ],
                        "Optional": [
                            928,
                            929,
                            927
                        ],
                        "str": [
                            927
                        ],
                        "int": [
                            928
                        ],
                        "Any": [
                            929
                        ],
                        "self._check_method": [
                            932
                        ],
                        "self": [
                            963,
                            932,
                            964,
                            934,
                            971,
                            945,
                            946,
                            950,
                            952,
                            958,
                            959
                        ],
                        "method": [
                            932
                        ],
                        "self.is_overlapping": [
                            934
                        ],
                        "msg": [
                            939,
                            935
                        ],
                        "InvalidIndexError": [
                            939
                        ],
                        "target_as_index": [
                            961,
                            963,
                            964,
                            969,
                            941,
                            943,
                            945,
                            950,
                            952,
                            953,
                            958,
                            959
                        ],
                        "ensure_index": [
                            941
                        ],
                        "target": [
                            941
                        ],
                        "isinstance": [
                            943
                        ],
                        "IntervalIndex": [
                            943
                        ],
                        "self.equals": [
                            945
                        ],
                        "np.arange": [
                            946
                        ],
                        "np": [
                            960,
                            953,
                            946,
                            930
                        ],
                        "len": [
                            953,
                            946
                        ],
                        "common_subtype": [
                            952,
                            949
                        ],
                        "find_common_type": [
                            949
                        ],
                        "self.dtype.subtype": [
                            950
                        ],
                        "self.dtype": [
                            950
                        ],
                        "target_as_index.dtype.subtype": [
                            950
                        ],
                        "target_as_index.dtype": [
                            950
                        ],
                        "self.closed": [
                            952
                        ],
                        "target_as_index.closed": [
                            952
                        ],
                        "is_object_dtype": [
                            952,
                            961
                        ],
                        "np.repeat": [
                            953
                        ],
                        "np.intp": [
                            953
                        ],
                        "left_indexer": [
                            960,
                            958
                        ],
                        "self.left.get_indexer": [
                            958
                        ],
                        "self.left": [
                            958
                        ],
                        "target_as_index.left": [
                            958
                        ],
                        "right_indexer": [
                            960,
                            959
                        ],
                        "self.right.get_indexer": [
                            959
                        ],
                        "self.right": [
                            959
                        ],
                        "target_as_index.right": [
                            959
                        ],
                        "indexer": [
                            960,
                            964,
                            968,
                            974,
                            976
                        ],
                        "np.where": [
                            960
                        ],
                        "self._maybe_convert_i8": [
                            963
                        ],
                        "self._engine.get_indexer": [
                            964
                        ],
                        "self._engine": [
                            964
                        ],
                        "target_as_index.values": [
                            964
                        ],
                        "key": [
                            969,
                            971
                        ],
                        "loc": [
                            971,
                            973,
                            974
                        ],
                        "self.get_loc": [
                            971
                        ],
                        "KeyError": [
                            972
                        ],
                        "indexer.append": [
                            974
                        ],
                        "ensure_platform_int": [
                            976
                        ],
                        "Substitution": [
                            907
                        ],
                        "dict": [
                            908
                        ],
                        "_index_doc_kwargs": [
                            909
                        ],
                        "textwrap.dedent": [
                            911
                        ],
                        "textwrap": [
                            911
                        ],
                        "Appender": [
                            923
                        ],
                        "_index_shared_docs": [
                            923
                        ],
                        "np.ndarray": [
                            930
                        ]
                    },
                    "filtered_variables": {
                        "AnyArrayLike": [
                            926
                        ],
                        "Optional": [
                            928,
                            929,
                            927
                        ],
                        "Any": [
                            929
                        ],
                        "self._check_method": [
                            932
                        ],
                        "self": [
                            963,
                            932,
                            964,
                            934,
                            971,
                            945,
                            946,
                            950,
                            952,
                            958,
                            959
                        ],
                        "method": [
                            932
                        ],
                        "self.is_overlapping": [
                            934
                        ],
                        "msg": [
                            939,
                            935
                        ],
                        "InvalidIndexError": [
                            939
                        ],
                        "target_as_index": [
                            961,
                            963,
                            964,
                            969,
                            941,
                            943,
                            945,
                            950,
                            952,
                            953,
                            958,
                            959
                        ],
                        "ensure_index": [
                            941
                        ],
                        "target": [
                            941
                        ],
                        "IntervalIndex": [
                            943
                        ],
                        "self.equals": [
                            945
                        ],
                        "np.arange": [
                            946
                        ],
                        "np": [
                            960,
                            953,
                            946,
                            930
                        ],
                        "common_subtype": [
                            952,
                            949
                        ],
                        "find_common_type": [
                            949
                        ],
                        "self.dtype.subtype": [
                            950
                        ],
                        "self.dtype": [
                            950
                        ],
                        "target_as_index.dtype.subtype": [
                            950
                        ],
                        "target_as_index.dtype": [
                            950
                        ],
                        "self.closed": [
                            952
                        ],
                        "target_as_index.closed": [
                            952
                        ],
                        "is_object_dtype": [
                            952,
                            961
                        ],
                        "np.repeat": [
                            953
                        ],
                        "np.intp": [
                            953
                        ],
                        "left_indexer": [
                            960,
                            958
                        ],
                        "self.left.get_indexer": [
                            958
                        ],
                        "self.left": [
                            958
                        ],
                        "target_as_index.left": [
                            958
                        ],
                        "right_indexer": [
                            960,
                            959
                        ],
                        "self.right.get_indexer": [
                            959
                        ],
                        "self.right": [
                            959
                        ],
                        "target_as_index.right": [
                            959
                        ],
                        "indexer": [
                            960,
                            964,
                            968,
                            974,
                            976
                        ],
                        "np.where": [
                            960
                        ],
                        "self._maybe_convert_i8": [
                            963
                        ],
                        "self._engine.get_indexer": [
                            964
                        ],
                        "self._engine": [
                            964
                        ],
                        "target_as_index.values": [
                            964
                        ],
                        "key": [
                            969,
                            971
                        ],
                        "loc": [
                            971,
                            973,
                            974
                        ],
                        "self.get_loc": [
                            971
                        ],
                        "indexer.append": [
                            974
                        ],
                        "ensure_platform_int": [
                            976
                        ],
                        "Substitution": [
                            907
                        ],
                        "_index_doc_kwargs": [
                            909
                        ],
                        "textwrap.dedent": [
                            911
                        ],
                        "textwrap": [
                            911
                        ],
                        "Appender": [
                            923
                        ],
                        "_index_shared_docs": [
                            923
                        ],
                        "np.ndarray": [
                            930
                        ]
                    },
                    "diff_line_number": 960,
                    "class_data": {
                        "signature": "class IntervalIndex(IntervalMixin, Index)",
                        "docstring": null,
                        "constructor_docstring": null,
                        "functions": [
                            "def __new__(cls, data, closed=None, dtype=None, copy=False, name=None, verify_integrity=True):\n    if name is None and hasattr(data, 'name'):\n        name = data.name\n    with rewrite_exception('IntervalArray', cls.__name__):\n        array = IntervalArray(data, closed=closed, copy=copy, dtype=dtype, verify_integrity=verify_integrity)\n    return cls._simple_new(array, name)",
                            "@classmethod\ndef _simple_new(cls, array, name, closed=None):\n    \"\"\"\n    Construct from an IntervalArray\n\n    Parameters\n    ----------\n    array : IntervalArray\n    name : str\n        Attached as result.name\n    closed : Any\n        Ignored.\n    \"\"\"\n    result = IntervalMixin.__new__(cls)\n    result._data = array\n    result.name = name\n    result._reset_identity()\n    return result",
                            "@classmethod\n@Appender(_interval_shared_docs['from_breaks'] % dict(klass='IntervalIndex', examples=textwrap.dedent(\"        Examples\\n        --------\\n        >>> pd.IntervalIndex.from_breaks([0, 1, 2, 3])\\n        IntervalIndex([(0, 1], (1, 2], (2, 3]],\\n                      closed='right',\\n                      dtype='interval[int64]')\\n        \")))\ndef from_breaks(cls, breaks, closed='right', name=None, copy=False, dtype=None):\n    with rewrite_exception('IntervalArray', cls.__name__):\n        array = IntervalArray.from_breaks(breaks, closed=closed, copy=copy, dtype=dtype)\n    return cls._simple_new(array, name=name)",
                            "@classmethod\n@Appender(_interval_shared_docs['from_arrays'] % dict(klass='IntervalIndex', examples=textwrap.dedent(\"        Examples\\n        --------\\n        >>> pd.IntervalIndex.from_arrays([0, 1, 2], [1, 2, 3])\\n        IntervalIndex([(0, 1], (1, 2], (2, 3]],\\n                      closed='right',\\n                      dtype='interval[int64]')\\n        \")))\ndef from_arrays(cls, left, right, closed='right', name=None, copy=False, dtype=None):\n    with rewrite_exception('IntervalArray', cls.__name__):\n        array = IntervalArray.from_arrays(left, right, closed, copy=copy, dtype=dtype)\n    return cls._simple_new(array, name=name)",
                            "@classmethod\n@Appender(_interval_shared_docs['from_tuples'] % dict(klass='IntervalIndex', examples=textwrap.dedent(\"        Examples\\n        --------\\n        >>> pd.IntervalIndex.from_tuples([(0, 1), (1, 2)])\\n        IntervalIndex([(0, 1], (1, 2]],\\n                       closed='right',\\n                       dtype='interval[int64]')\\n        \")))\ndef from_tuples(cls, data, closed='right', name=None, copy=False, dtype=None):\n    with rewrite_exception('IntervalArray', cls.__name__):\n        arr = IntervalArray.from_tuples(data, closed=closed, copy=copy, dtype=dtype)\n    return cls._simple_new(arr, name=name)",
                            "@Appender(_index_shared_docs['_shallow_copy'])\ndef _shallow_copy(self, left=None, right=None, **kwargs):\n    result = self._data._shallow_copy(left=left, right=right)\n    attributes = self._get_attributes_dict()\n    attributes.update(kwargs)\n    return self._simple_new(result, **attributes)",
                            "@cache_readonly\ndef _isnan(self):\n    \"\"\"Return a mask indicating if each value is NA\"\"\"\n    if self._mask is None:\n        self._mask = isna(self.left)\n    return self._mask",
                            "@cache_readonly\ndef _engine(self):\n    left = self._maybe_convert_i8(self.left)\n    right = self._maybe_convert_i8(self.right)\n    return IntervalTree(left, right, closed=self.closed)",
                            "def __contains__(self, key) -> bool:\n    \"\"\"\n    return a boolean if this key is IN the index\n    We *only* accept an Interval\n\n    Parameters\n    ----------\n    key : Interval\n\n    Returns\n    -------\n    boolean\n    \"\"\"\n    if not isinstance(key, Interval):\n        return False\n    try:\n        self.get_loc(key)\n        return True\n    except KeyError:\n        return False",
                            "@Appender(_interval_shared_docs['to_tuples'] % dict(return_type='Index', examples=\"\\n        Examples\\n        --------\\n        >>> idx = pd.IntervalIndex.from_arrays([0, np.nan, 2], [1, np.nan, 3])\\n        >>> idx.to_tuples()\\n        Index([(0.0, 1.0), (nan, nan), (2.0, 3.0)], dtype='object')\\n        >>> idx.to_tuples(na_tuple=False)\\n        Index([(0.0, 1.0), nan, (2.0, 3.0)], dtype='object')\\n        \"))\ndef to_tuples(self, na_tuple=True):\n    tuples = self._data.to_tuples(na_tuple=na_tuple)\n    return Index(tuples)",
                            "@cache_readonly\ndef _multiindex(self):\n    return MultiIndex.from_arrays([self.left, self.right], names=['left', 'right'])",
                            "@property\ndef left(self):\n    \"\"\"\n    Return the left endpoints of each Interval in the IntervalIndex as\n    an Index.\n    \"\"\"\n    return self._data._left",
                            "@property\ndef right(self):\n    \"\"\"\n    Return the right endpoints of each Interval in the IntervalIndex as\n    an Index.\n    \"\"\"\n    return self._data._right",
                            "@property\ndef closed(self):\n    \"\"\"\n    Whether the intervals are closed on the left-side, right-side, both or\n    neither.\n    \"\"\"\n    return self._data._closed",
                            "@Appender(_interval_shared_docs['set_closed'] % dict(klass='IntervalIndex', examples=textwrap.dedent(\"        Examples\\n        --------\\n        >>> index = pd.interval_range(0, 3)\\n        >>> index\\n        IntervalIndex([(0, 1], (1, 2], (2, 3]],\\n                      closed='right',\\n                      dtype='interval[int64]')\\n        >>> index.set_closed('both')\\n        IntervalIndex([[0, 1], [1, 2], [2, 3]],\\n                      closed='both',\\n                      dtype='interval[int64]')\\n        \")))\ndef set_closed(self, closed):\n    if closed not in _VALID_CLOSED:\n        msg = \"invalid option for 'closed': {closed}\"\n        raise ValueError(msg.format(closed=closed))\n    array = self._data.set_closed(closed)\n    return self._simple_new(array, self.name)",
                            "@property\ndef length(self):\n    \"\"\"\n    Return an Index with entries denoting the length of each Interval in\n    the IntervalIndex.\n    \"\"\"\n    return self._data.length",
                            "@property\ndef size(self):\n    return self._data.size",
                            "def __len__(self) -> int:\n    return len(self.left)",
                            "@cache_readonly\ndef values(self):\n    \"\"\"\n    Return the IntervalIndex's data as an IntervalArray.\n    \"\"\"\n    return self._data",
                            "@cache_readonly\ndef _values(self):\n    return self._data",
                            "@cache_readonly\ndef _ndarray_values(self) -> np.ndarray:\n    return np.array(self._data)",
                            "def __array__(self, result=None):\n    \"\"\" the array interface, return my values \"\"\"\n    return self._ndarray_values",
                            "def __array_wrap__(self, result, context=None):\n    return result",
                            "def __reduce__(self):\n    d = dict(left=self.left, right=self.right)\n    d.update(self._get_attributes_dict())\n    return (_new_IntervalIndex, (type(self), d), None)",
                            "@Appender(_index_shared_docs['copy'])\ndef copy(self, deep=False, name=None):\n    array = self._data\n    if deep:\n        array = array.copy()\n    attributes = self._get_attributes_dict()\n    if name is not None:\n        attributes.update(name=name)\n    return self._simple_new(array, **attributes)",
                            "@Appender(_index_shared_docs['astype'])\ndef astype(self, dtype, copy=True):\n    with rewrite_exception('IntervalArray', type(self).__name__):\n        new_values = self.values.astype(dtype, copy=copy)\n    if is_interval_dtype(new_values):\n        return self._shallow_copy(new_values.left, new_values.right)\n    return super().astype(dtype, copy=copy)",
                            "@cache_readonly\ndef dtype(self):\n    \"\"\"Return the dtype object of the underlying data\"\"\"\n    return self._data.dtype",
                            "@property\ndef inferred_type(self) -> str:\n    \"\"\"Return a string of the type inferred from the values\"\"\"\n    return 'interval'",
                            "@Appender(Index.memory_usage.__doc__)\ndef memory_usage(self, deep: bool=False) -> int:\n    return self.left.memory_usage(deep=deep) + self.right.memory_usage(deep=deep)",
                            "@cache_readonly\ndef mid(self):\n    \"\"\"\n    Return the midpoint of each Interval in the IntervalIndex as an Index.\n    \"\"\"\n    return self._data.mid",
                            "@cache_readonly\ndef is_monotonic(self) -> bool:\n    \"\"\"\n    Return True if the IntervalIndex is monotonic increasing (only equal or\n    increasing values), else False\n    \"\"\"\n    return self.is_monotonic_increasing",
                            "@cache_readonly\ndef is_monotonic_increasing(self) -> bool:\n    \"\"\"\n    Return True if the IntervalIndex is monotonic increasing (only equal or\n    increasing values), else False\n    \"\"\"\n    return self._engine.is_monotonic_increasing",
                            "@cache_readonly\ndef is_monotonic_decreasing(self) -> bool:\n    \"\"\"\n    Return True if the IntervalIndex is monotonic decreasing (only equal or\n    decreasing values), else False\n    \"\"\"\n    return self[::-1].is_monotonic_increasing",
                            "@cache_readonly\ndef is_unique(self):\n    \"\"\"\n    Return True if the IntervalIndex contains unique elements, else False\n    \"\"\"\n    left = self.left\n    right = self.right\n    if self.isna().sum() > 1:\n        return False\n    if left.is_unique or right.is_unique:\n        return True\n    seen_pairs = set()\n    check_idx = np.where(left.duplicated(keep=False))[0]\n    for idx in check_idx:\n        pair = (left[idx], right[idx])\n        if pair in seen_pairs:\n            return False\n        seen_pairs.add(pair)\n    return True",
                            "@cache_readonly\n@Appender(_interval_shared_docs['is_non_overlapping_monotonic'] % _index_doc_kwargs)\ndef is_non_overlapping_monotonic(self):\n    return self._data.is_non_overlapping_monotonic",
                            "@property\ndef is_overlapping(self):\n    \"\"\"\n    Return True if the IntervalIndex has overlapping intervals, else False.\n\n    Two intervals overlap if they share a common point, including closed\n    endpoints. Intervals that only have an open endpoint in common do not\n    overlap.\n\n    .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    bool\n        Boolean indicating if the IntervalIndex has overlapping intervals.\n\n    See Also\n    --------\n    Interval.overlaps : Check whether two Interval objects overlap.\n    IntervalIndex.overlaps : Check an IntervalIndex elementwise for\n        overlaps.\n\n    Examples\n    --------\n    >>> index = pd.IntervalIndex.from_tuples([(0, 2), (1, 3), (4, 5)])\n    >>> index\n    IntervalIndex([(0, 2], (1, 3], (4, 5]],\n          closed='right',\n          dtype='interval[int64]')\n    >>> index.is_overlapping\n    True\n\n    Intervals that share closed endpoints overlap:\n\n    >>> index = pd.interval_range(0, 3, closed='both')\n    >>> index\n    IntervalIndex([[0, 1], [1, 2], [2, 3]],\n          closed='both',\n          dtype='interval[int64]')\n    >>> index.is_overlapping\n    True\n\n    Intervals that only have an open endpoint in common do not overlap:\n\n    >>> index = pd.interval_range(0, 3, closed='left')\n    >>> index\n    IntervalIndex([[0, 1), [1, 2), [2, 3)],\n          closed='left',\n          dtype='interval[int64]')\n    >>> index.is_overlapping\n    False\n    \"\"\"\n    return self._engine.is_overlapping",
                            "@Appender(_index_shared_docs['_convert_scalar_indexer'])\ndef _convert_scalar_indexer(self, key, kind=None):\n    if kind == 'iloc':\n        return super()._convert_scalar_indexer(key, kind=kind)\n    return key",
                            "def _maybe_cast_slice_bound(self, label, side, kind):\n    return getattr(self, side)._maybe_cast_slice_bound(label, side, kind)",
                            "@Appender(_index_shared_docs['_convert_list_indexer'])\ndef _convert_list_indexer(self, keyarr, kind=None):\n    \"\"\"\n    we are passed a list-like indexer. Return the\n    indexer for matching intervals.\n    \"\"\"\n    locs = self.get_indexer_for(keyarr)\n    if (locs == -1).any():\n        raise KeyError\n    return locs",
                            "def _maybe_cast_indexed(self, key):\n    \"\"\"\n    we need to cast the key, which could be a scalar\n    or an array-like to the type of our subtype\n    \"\"\"\n    if isinstance(key, IntervalIndex):\n        return key\n    subtype = self.dtype.subtype\n    if is_float_dtype(subtype):\n        if is_integer(key):\n            key = float(key)\n        elif isinstance(key, (np.ndarray, Index)):\n            key = key.astype('float64')\n    elif is_integer_dtype(subtype):\n        if is_integer(key):\n            key = int(key)\n    return key",
                            "def _can_reindex(self, indexer: np.ndarray) -> None:\n    \"\"\"\n    Check if we are allowing reindexing with this particular indexer.\n\n    Parameters\n    ----------\n    indexer : an integer indexer\n\n    Raises\n    ------\n    ValueError if its a duplicate axis\n    \"\"\"\n    if self.is_overlapping and len(indexer):\n        raise ValueError('cannot reindex from an overlapping axis')",
                            "def _needs_i8_conversion(self, key):\n    \"\"\"\n    Check if a given key needs i8 conversion. Conversion is necessary for\n    Timestamp, Timedelta, DatetimeIndex, and TimedeltaIndex keys. An\n    Interval-like requires conversion if it's endpoints are one of the\n    aforementioned types.\n\n    Assumes that any list-like data has already been cast to an Index.\n\n    Parameters\n    ----------\n    key : scalar or Index-like\n        The key that should be checked for i8 conversion\n\n    Returns\n    -------\n    boolean\n    \"\"\"\n    if is_interval_dtype(key) or isinstance(key, Interval):\n        return self._needs_i8_conversion(key.left)\n    i8_types = (Timestamp, Timedelta, DatetimeIndex, TimedeltaIndex)\n    return isinstance(key, i8_types)",
                            "def _maybe_convert_i8(self, key):\n    \"\"\"\n    Maybe convert a given key to it's equivalent i8 value(s). Used as a\n    preprocessing step prior to IntervalTree queries (self._engine), which\n    expects numeric data.\n\n    Parameters\n    ----------\n    key : scalar or list-like\n        The key that should maybe be converted to i8.\n\n    Returns\n    -------\n    key: scalar or list-like\n        The original key if no conversion occurred, int if converted scalar,\n        Int64Index if converted list-like.\n    \"\"\"\n    original = key\n    if is_list_like(key):\n        key = ensure_index(key)\n    if not self._needs_i8_conversion(key):\n        return original\n    scalar = is_scalar(key)\n    if is_interval_dtype(key) or isinstance(key, Interval):\n        left = self._maybe_convert_i8(key.left)\n        right = self._maybe_convert_i8(key.right)\n        constructor = Interval if scalar else IntervalIndex.from_arrays\n        return constructor(left, right, closed=self.closed)\n    if scalar:\n        (key_dtype, key_i8) = infer_dtype_from_scalar(key, pandas_dtype=True)\n    else:\n        (key_dtype, key_i8) = (key.dtype, Index(key.asi8))\n        if key.hasnans:\n            key_i8 = key_i8.where(~key._isnan)\n    subtype = self.dtype.subtype\n    msg = 'Cannot index an IntervalIndex of subtype {subtype} with values of dtype {other}'\n    if not is_dtype_equal(subtype, key_dtype):\n        raise ValueError(msg.format(subtype=subtype, other=key_dtype))\n    return key_i8",
                            "def _check_method(self, method):\n    if method is None:\n        return\n    if method in ['bfill', 'backfill', 'pad', 'ffill', 'nearest']:\n        msg = 'method {method} not yet implemented for IntervalIndex'\n        raise NotImplementedError(msg.format(method=method))\n    raise ValueError('Invalid fill method')",
                            "def _searchsorted_monotonic(self, label, side, exclude_label=False):\n    if not self.is_non_overlapping_monotonic:\n        raise KeyError('can only get slices from an IntervalIndex if bounds are non-overlapping and all monotonic increasing or decreasing')\n    if isinstance(label, IntervalMixin):\n        msg = 'Interval objects are not currently supported'\n        raise NotImplementedError(msg)\n    if side == 'left' and self.left.is_monotonic_increasing or (side == 'right' and (not self.left.is_monotonic_increasing)):\n        sub_idx = self.right\n        if self.open_right or exclude_label:\n            label = _get_next_label(label)\n    else:\n        sub_idx = self.left\n        if self.open_left or exclude_label:\n            label = _get_prev_label(label)\n    return sub_idx._searchsorted_monotonic(label, side)",
                            "def _find_non_overlapping_monotonic_bounds(self, key):\n    if isinstance(key, IntervalMixin):\n        start = self._searchsorted_monotonic(key.left, 'left', exclude_label=key.open_left)\n        stop = self._searchsorted_monotonic(key.right, 'right', exclude_label=key.open_right)\n    elif isinstance(key, slice):\n        (start, stop) = (key.start, key.stop)\n        if (key.step or 1) != 1:\n            raise NotImplementedError('cannot slice with a slice step')\n        if start is None:\n            start = 0\n        else:\n            start = self._searchsorted_monotonic(start, 'left')\n        if stop is None:\n            stop = len(self)\n        else:\n            stop = self._searchsorted_monotonic(stop, 'right')\n    else:\n        start = self._searchsorted_monotonic(key, 'left')\n        stop = self._searchsorted_monotonic(key, 'right')\n    return (start, stop)",
                            "def get_loc(self, key: Any, method: Optional[str]=None, tolerance=None) -> Union[int, slice, np.ndarray]:\n    \"\"\"\n    Get integer location, slice or boolean mask for requested label.\n\n    Parameters\n    ----------\n    key : label\n    method : {None}, optional\n        * default: matches where the label is within an interval only.\n\n    Returns\n    -------\n    loc : int if unique index, slice if monotonic index, else mask\n\n    Examples\n    --------\n    >>> i1, i2 = pd.Interval(0, 1), pd.Interval(1, 2)\n    >>> index = pd.IntervalIndex([i1, i2])\n    >>> index.get_loc(1)\n    0\n\n    You can also supply a point inside an interval.\n\n    >>> index.get_loc(1.5)\n    1\n\n    If a label is in several intervals, you get the locations of all the\n    relevant intervals.\n\n    >>> i3 = pd.Interval(0, 2)\n    >>> overlapping_index = pd.IntervalIndex([i1, i2, i3])\n    >>> overlapping_index.get_loc(0.5)\n    array([ True, False,  True])\n\n    Only exact matches will be returned if an interval is provided.\n\n    >>> index.get_loc(pd.Interval(0, 1))\n    0\n    \"\"\"\n    self._check_method(method)\n    if is_list_like(key):\n        raise KeyError(key)\n    if isinstance(key, Interval):\n        if self.closed != key.closed:\n            raise KeyError(key)\n        mask = (self.left == key.left) & (self.right == key.right)\n    else:\n        op_left = le if self.closed_left else lt\n        op_right = le if self.closed_right else lt\n        try:\n            mask = op_left(self.left, key) & op_right(key, self.right)\n        except TypeError:\n            raise KeyError(key)\n    matches = mask.sum()\n    if matches == 0:\n        raise KeyError(key)\n    elif matches == 1:\n        return mask.argmax()\n    return lib.maybe_booleans_to_slice(mask.view('u1'))",
                            "@Substitution(**dict(_index_doc_kwargs, **{'raises_section': textwrap.dedent('\\n        Raises\\n        ------\\n        NotImplementedError\\n            If any method argument other than the default of\\n            None is specified as these are not yet implemented.\\n        ')}))\n@Appender(_index_shared_docs['get_indexer'])\ndef get_indexer(self, target: AnyArrayLike, method: Optional[str]=None, limit: Optional[int]=None, tolerance: Optional[Any]=None) -> np.ndarray:\n    self._check_method(method)\n    if self.is_overlapping:\n        msg = 'cannot handle overlapping indices; use IntervalIndex.get_indexer_non_unique'\n        raise InvalidIndexError(msg)\n    target_as_index = ensure_index(target)\n    if isinstance(target_as_index, IntervalIndex):\n        if self.equals(target_as_index):\n            return np.arange(len(self), dtype='intp')\n        common_subtype = find_common_type([self.dtype.subtype, target_as_index.dtype.subtype])\n        if self.closed != target_as_index.closed or is_object_dtype(common_subtype):\n            return np.repeat(np.intp(-1), len(target_as_index))\n        left_indexer = self.left.get_indexer(target_as_index.left)\n        right_indexer = self.right.get_indexer(target_as_index.right)\n        indexer = np.where(left_indexer == right_indexer, left_indexer, -1)\n    elif not is_object_dtype(target_as_index):\n        target_as_index = self._maybe_convert_i8(target_as_index)\n        indexer = self._engine.get_indexer(target_as_index.values)\n    else:\n        indexer = []\n        for key in target_as_index:\n            try:\n                loc = self.get_loc(key)\n            except KeyError:\n                loc = -1\n            indexer.append(loc)\n    return ensure_platform_int(indexer)",
                            "@Appender(_index_shared_docs['get_indexer_non_unique'] % _index_doc_kwargs)\ndef get_indexer_non_unique(self, target: AnyArrayLike) -> Tuple[np.ndarray, np.ndarray]:\n    target_as_index = ensure_index(target)\n    if isinstance(target_as_index, IntervalIndex):\n        common_subtype = find_common_type([self.dtype.subtype, target_as_index.dtype.subtype])\n        if self.closed != target_as_index.closed or is_object_dtype(common_subtype):\n            return (np.repeat(-1, len(target_as_index)), np.arange(len(target_as_index)))\n    if is_object_dtype(target_as_index) or isinstance(target_as_index, IntervalIndex):\n        (indexer, missing) = ([], [])\n        for (i, key) in enumerate(target_as_index):\n            try:\n                locs = self.get_loc(key)\n                if isinstance(locs, slice):\n                    locs = np.arange(locs.start, locs.stop, locs.step, dtype='intp')\n                locs = np.array(locs, ndmin=1)\n            except KeyError:\n                missing.append(i)\n                locs = np.array([-1])\n            indexer.append(locs)\n        indexer = np.concatenate(indexer)\n    else:\n        target_as_index = self._maybe_convert_i8(target_as_index)\n        (indexer, missing) = self._engine.get_indexer_non_unique(target_as_index.values)\n    return (ensure_platform_int(indexer), ensure_platform_int(missing))",
                            "def get_indexer_for(self, target: AnyArrayLike, **kwargs) -> np.ndarray:\n    \"\"\"\n    Guaranteed return of an indexer even when overlapping.\n\n    This dispatches to get_indexer or get_indexer_non_unique\n    as appropriate.\n\n    Returns\n    -------\n    numpy.ndarray\n        List of indices.\n    \"\"\"\n    if self.is_overlapping:\n        return self.get_indexer_non_unique(target)[0]\n    return self.get_indexer(target, **kwargs)",
                            "@Appender(_index_shared_docs['get_value'] % _index_doc_kwargs)\ndef get_value(self, series: ABCSeries, key: Any) -> Any:\n    if com.is_bool_indexer(key):\n        loc = key\n    elif is_list_like(key):\n        if self.is_overlapping:\n            (loc, missing) = self.get_indexer_non_unique(key)\n            if len(missing):\n                raise KeyError\n        else:\n            loc = self.get_indexer(key)\n    elif isinstance(key, slice):\n        if not (key.step is None or key.step == 1):\n            raise ValueError('cannot support not-default step in a slice')\n        loc = self._convert_slice_indexer(key, kind='getitem')\n    else:\n        loc = self.get_loc(key)\n    return series.iloc[loc]",
                            "@Appender(_index_shared_docs['where'])\ndef where(self, cond, other=None):\n    if other is None:\n        other = self._na_value\n    values = np.where(cond, self.values, other)\n    return self._shallow_copy(values)",
                            "def delete(self, loc):\n    \"\"\"\n    Return a new IntervalIndex with passed location(-s) deleted\n\n    Returns\n    -------\n    new_index : IntervalIndex\n    \"\"\"\n    new_left = self.left.delete(loc)\n    new_right = self.right.delete(loc)\n    return self._shallow_copy(new_left, new_right)",
                            "def insert(self, loc, item):\n    \"\"\"\n    Return a new IntervalIndex inserting new item at location. Follows\n    Python list.append semantics for negative values.  Only Interval\n    objects and NA can be inserted into an IntervalIndex\n\n    Parameters\n    ----------\n    loc : int\n    item : object\n\n    Returns\n    -------\n    new_index : IntervalIndex\n    \"\"\"\n    if isinstance(item, Interval):\n        if item.closed != self.closed:\n            raise ValueError('inserted item must be closed on the same side as the index')\n        left_insert = item.left\n        right_insert = item.right\n    elif is_scalar(item) and isna(item):\n        left_insert = right_insert = item\n    else:\n        raise ValueError('can only insert Interval objects and NA into an IntervalIndex')\n    new_left = self.left.insert(loc, left_insert)\n    new_right = self.right.insert(loc, right_insert)\n    return self._shallow_copy(new_left, new_right)",
                            "def _concat_same_dtype(self, to_concat, name):\n    \"\"\"\n    assert that we all have the same .closed\n    we allow a 0-len index here as well\n    \"\"\"\n    if not len({i.closed for i in to_concat if len(i)}) == 1:\n        msg = 'can only append two IntervalIndex objects that are closed on the same side'\n        raise ValueError(msg)\n    return super()._concat_same_dtype(to_concat, name)",
                            "@Appender(_index_shared_docs['take'] % _index_doc_kwargs)\ndef take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs):\n    result = self._data.take(indices, axis=axis, allow_fill=allow_fill, fill_value=fill_value, **kwargs)\n    attributes = self._get_attributes_dict()\n    return self._simple_new(result, **attributes)",
                            "def __getitem__(self, value):\n    result = self._data[value]\n    if isinstance(result, IntervalArray):\n        return self._shallow_copy(result)\n    else:\n        return result",
                            "def _format_with_header(self, header, **kwargs):\n    return header + list(self._format_native_types(**kwargs))",
                            "def _format_native_types(self, na_rep='NaN', quoting=None, **kwargs):\n    return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)",
                            "def _format_data(self, name=None):\n    n = len(self)\n    max_seq_items = min((get_option('display.max_seq_items') or n) // 10, 10)\n    formatter = str\n    if n == 0:\n        summary = '[]'\n    elif n == 1:\n        first = formatter(self[0])\n        summary = '[{first}]'.format(first=first)\n    elif n == 2:\n        first = formatter(self[0])\n        last = formatter(self[-1])\n        summary = '[{first}, {last}]'.format(first=first, last=last)\n    elif n > max_seq_items:\n        n = min(max_seq_items // 2, 10)\n        head = [formatter(x) for x in self[:n]]\n        tail = [formatter(x) for x in self[-n:]]\n        summary = '[{head} ... {tail}]'.format(head=', '.join(head), tail=', '.join(tail))\n    else:\n        tail = [formatter(x) for x in self]\n        summary = '[{tail}]'.format(tail=', '.join(tail))\n    return summary + ',' + self._format_space()",
                            "def _format_attrs(self):\n    attrs = [('closed', repr(self.closed))]\n    if self.name is not None:\n        attrs.append(('name', default_pprint(self.name)))\n    attrs.append(('dtype', \"'{dtype}'\".format(dtype=self.dtype)))\n    return attrs",
                            "def _format_space(self):\n    space = ' ' * (len(type(self).__name__) + 1)\n    return '\\n{space}'.format(space=space)",
                            "def argsort(self, *args, **kwargs):\n    return np.lexsort((self.right, self.left))",
                            "def equals(self, other) -> bool:\n    \"\"\"\n    Determines if two IntervalIndex objects contain the same elements\n    \"\"\"\n    if self.is_(other):\n        return True\n    if not isinstance(other, IntervalIndex):\n        if not is_interval_dtype(other):\n            return False\n        other = Index(getattr(other, '.values', other))\n    return self.left.equals(other.left) and self.right.equals(other.right) and (self.closed == other.closed)",
                            "@Appender(_interval_shared_docs['contains'] % dict(klass='IntervalIndex', examples=textwrap.dedent(\"        >>> intervals = pd.IntervalIndex.from_tuples([(0, 1), (1, 3), (2, 4)])\\n        >>> intervals\\n        IntervalIndex([(0, 1], (1, 3], (2, 4]],\\n                  closed='right',\\n                  dtype='interval[int64]')\\n        >>> intervals.contains(0.5)\\n        array([ True, False, False])\\n        \")))\ndef contains(self, other):\n    return self._data.contains(other)",
                            "@Appender(_interval_shared_docs['overlaps'] % dict(klass='IntervalIndex', examples=textwrap.dedent(\"        >>> intervals = pd.IntervalIndex.from_tuples([(0, 1), (1, 3), (2, 4)])\\n        >>> intervals\\n        IntervalIndex([(0, 1], (1, 3], (2, 4]],\\n              closed='right',\\n              dtype='interval[int64]')\\n        \")))\ndef overlaps(self, other):\n    return self._data.overlaps(other)",
                            "@Appender(_index_shared_docs['intersection'])\n@SetopCheck(op_name='intersection')\ndef intersection(self, other: 'IntervalIndex', sort: bool=False) -> 'IntervalIndex':\n    if self.left.is_unique and self.right.is_unique:\n        taken = self._intersection_unique(other)\n    elif other.left.is_unique and other.right.is_unique and (self.isna().sum() <= 1):\n        taken = other._intersection_unique(self)\n    else:\n        taken = self._intersection_non_unique(other)\n    if sort is None:\n        taken = taken.sort_values()\n    return taken",
                            "def _intersection_unique(self, other: 'IntervalIndex') -> 'IntervalIndex':\n    \"\"\"\n    Used when the IntervalIndex does not have any common endpoint,\n    no mater left or right.\n    Return the intersection with another IntervalIndex.\n\n    Parameters\n    ----------\n    other : IntervalIndex\n\n    Returns\n    -------\n    taken : IntervalIndex\n    \"\"\"\n    lindexer = self.left.get_indexer(other.left)\n    rindexer = self.right.get_indexer(other.right)\n    match = (lindexer == rindexer) & (lindexer != -1)\n    indexer = lindexer.take(match.nonzero()[0])\n    return self.take(indexer)",
                            "def _intersection_non_unique(self, other: 'IntervalIndex') -> 'IntervalIndex':\n    \"\"\"\n    Used when the IntervalIndex does have some common endpoints,\n    on either sides.\n    Return the intersection with another IntervalIndex.\n\n    Parameters\n    ----------\n    other : IntervalIndex\n\n    Returns\n    -------\n    taken : IntervalIndex\n    \"\"\"\n    mask = np.zeros(len(self), dtype=bool)\n    if self.hasnans and other.hasnans:\n        first_nan_loc = np.arange(len(self))[self.isna()][0]\n        mask[first_nan_loc] = True\n    other_tups = set(zip(other.left, other.right))\n    for (i, tup) in enumerate(zip(self.left, self.right)):\n        if tup in other_tups:\n            mask[i] = True\n    return self[mask]",
                            "def _setop(op_name: str, sort=None):\n\n    @SetopCheck(op_name=op_name)\n    def func(self, other, sort=sort):\n        result = getattr(self._multiindex, op_name)(other._multiindex, sort=sort)\n        result_name = get_op_result_name(self, other)\n        if result.empty:\n            result = result.values.astype(self.dtype.subtype)\n        else:\n            result = result.values\n        return type(self).from_tuples(result, closed=self.closed, name=result_name)\n    return func",
                            "@property\ndef is_all_dates(self) -> bool:\n    \"\"\"\n    This is False even when left/right contain datetime-like objects,\n    as the check is done on the Interval itself\n    \"\"\"\n    return False"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_typ = 'intervalindex'",
                            "_comparables = ['name']",
                            "_attributes = ['name', 'closed']",
                            "_defer_to_indexing = True",
                            "_mask = None",
                            "union = _setop('union')",
                            "difference = _setop('difference')",
                            "symmetric_difference = _setop('symmetric_difference')"
                        ],
                        "class_decorators": [
                            "Appender(_interval_shared_docs['class'] % dict(klass='IntervalIndex', summary='Immutable index of intervals that are closed on the same side.', name=_index_doc_kwargs['name'], versionadded='0.20.0', extra_attributes='is_overlapping\\nvalues\\n', extra_methods='', examples=textwrap.dedent(\"    Examples\\n    --------\\n    A new ``IntervalIndex`` is typically constructed using\\n    :func:`interval_range`:\\n\\n    >>> pd.interval_range(start=0, end=5)\\n    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\\n                  closed='right',\\n                  dtype='interval[int64]')\\n\\n    It may also be constructed using one of the constructor\\n    methods: :meth:`IntervalIndex.from_arrays`,\\n    :meth:`IntervalIndex.from_breaks`, and :meth:`IntervalIndex.from_tuples`.\\n\\n    See further examples in the doc strings of ``interval_range`` and the\\n    mentioned constructor methods.\\n    \")))"
                        ],
                        "function_signatures": [
                            "__new__(cls, data, closed=None, dtype=None, copy=False, name=None, verify_integrity=True)",
                            "_simple_new(cls, array, name, closed=None)",
                            "from_breaks(cls, breaks, closed='right', name=None, copy=False, dtype=None)",
                            "from_arrays(cls, left, right, closed='right', name=None, copy=False, dtype=None)",
                            "from_tuples(cls, data, closed='right', name=None, copy=False, dtype=None)",
                            "_shallow_copy(self, left=None, right=None, **kwargs)",
                            "_isnan(self)",
                            "_engine(self)",
                            "__contains__(self, key) -> bool",
                            "to_tuples(self, na_tuple=True)",
                            "_multiindex(self)",
                            "left(self)",
                            "right(self)",
                            "closed(self)",
                            "set_closed(self, closed)",
                            "length(self)",
                            "size(self)",
                            "__len__(self) -> int",
                            "values(self)",
                            "_values(self)",
                            "_ndarray_values(self) -> np.ndarray",
                            "__array__(self, result=None)",
                            "__array_wrap__(self, result, context=None)",
                            "__reduce__(self)",
                            "copy(self, deep=False, name=None)",
                            "astype(self, dtype, copy=True)",
                            "dtype(self)",
                            "inferred_type(self) -> str",
                            "memory_usage(self, deep: bool=False) -> int",
                            "mid(self)",
                            "is_monotonic(self) -> bool",
                            "is_monotonic_increasing(self) -> bool",
                            "is_monotonic_decreasing(self) -> bool",
                            "is_unique(self)",
                            "is_non_overlapping_monotonic(self)",
                            "is_overlapping(self)",
                            "_convert_scalar_indexer(self, key, kind=None)",
                            "_maybe_cast_slice_bound(self, label, side, kind)",
                            "_convert_list_indexer(self, keyarr, kind=None)",
                            "_maybe_cast_indexed(self, key)",
                            "_can_reindex(self, indexer: np.ndarray) -> None",
                            "_needs_i8_conversion(self, key)",
                            "_maybe_convert_i8(self, key)",
                            "_check_method(self, method)",
                            "_searchsorted_monotonic(self, label, side, exclude_label=False)",
                            "_find_non_overlapping_monotonic_bounds(self, key)",
                            "get_loc(self, key: Any, method: Optional[str]=None, tolerance=None) -> Union[int, slice, np.ndarray]",
                            "get_indexer(self, target: AnyArrayLike, method: Optional[str]=None, limit: Optional[int]=None, tolerance: Optional[Any]=None) -> np.ndarray",
                            "get_indexer_non_unique(self, target: AnyArrayLike) -> Tuple[np.ndarray, np.ndarray]",
                            "get_indexer_for(self, target: AnyArrayLike, **kwargs) -> np.ndarray",
                            "get_value(self, series: ABCSeries, key: Any) -> Any",
                            "where(self, cond, other=None)",
                            "delete(self, loc)",
                            "insert(self, loc, item)",
                            "_concat_same_dtype(self, to_concat, name)",
                            "take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs)",
                            "__getitem__(self, value)",
                            "_format_with_header(self, header, **kwargs)",
                            "_format_native_types(self, na_rep='NaN', quoting=None, **kwargs)",
                            "_format_data(self, name=None)",
                            "_format_attrs(self)",
                            "_format_space(self)",
                            "argsort(self, *args, **kwargs)",
                            "equals(self, other) -> bool",
                            "contains(self, other)",
                            "overlaps(self, other)",
                            "intersection(self, other: 'IntervalIndex', sort: bool=False) -> 'IntervalIndex'",
                            "_intersection_unique(self, other: 'IntervalIndex') -> 'IntervalIndex'",
                            "_intersection_non_unique(self, other: 'IntervalIndex') -> 'IntervalIndex'",
                            "_setop(op_name: str, sort=None)",
                            "is_all_dates(self) -> bool"
                        ],
                        "class_level_variable_names": [
                            "_typ",
                            "_comparables",
                            "_attributes",
                            "_defer_to_indexing",
                            "_mask",
                            "union",
                            "difference",
                            "symmetric_difference"
                        ],
                        "constructor_variable_names": []
                    },
                    "used_imports": [
                        "import textwrap",
                        "from typing import Any, Optional, Tuple, Union",
                        "import numpy as np",
                        "from pandas.util._decorators import Appender, Substitution, cache_readonly",
                        "from pandas.core.dtypes.cast import find_common_type, infer_dtype_from_scalar, maybe_downcast_to_dtype",
                        "from pandas.core.dtypes.common import ensure_platform_int, is_datetime64tz_dtype, is_datetime_or_timedelta_dtype, is_dtype_equal, is_float, is_float_dtype, is_integer, is_integer_dtype, is_interval_dtype, is_list_like, is_number, is_object_dtype, is_scalar",
                        "from pandas._typing import AnyArrayLike",
                        "from pandas.core.indexes.base import Index, InvalidIndexError, _index_shared_docs, default_pprint, ensure_index"
                    ],
                    "variable_values": [
                        [
                            {
                                "AnyArrayLike": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_method": {
                                    "variable_value": "<bound method IntervalIndex._check_method of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')",
                                    "variable_type": "IntervalIndex",
                                    "variable_shape": "(2,)"
                                },
                                "method": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.is_overlapping": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "msg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidIndexError": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target_as_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target": {
                                    "variable_value": "CategoricalIndex([(0, 1], (1, 2]], categories=[(0, 1], (1, 2]], ordered=False, dtype='category')",
                                    "variable_type": "CategoricalIndex",
                                    "variable_shape": "(2,)"
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.equals": {
                                    "variable_value": "<bound method IntervalIndex.equals of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.arange": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "common_subtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "find_common_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype.subtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "interval[int64]",
                                    "variable_type": "IntervalDtype",
                                    "variable_shape": "()"
                                },
                                "target_as_index.dtype.subtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target_as_index.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.closed": {
                                    "variable_value": "'right'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "target_as_index.closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.repeat": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.left.get_indexer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.left": {
                                    "variable_value": "Int64Index([0, 1], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "target_as_index.left": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.right.get_indexer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.right": {
                                    "variable_value": "Int64Index([1, 2], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "target_as_index.right": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.where": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_convert_i8": {
                                    "variable_value": "<bound method IntervalIndex._maybe_convert_i8 of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._engine.get_indexer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<IntervalTree[int64,right]: 2 elements>",
                                    "variable_type": "IntervalTree",
                                    "variable_shape": null
                                },
                                "target_as_index.values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "loc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.get_loc": {
                                    "variable_value": "<bound method IntervalIndex.get_loc of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer.append": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Substitution": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "textwrap.dedent": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "textwrap": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "AnyArrayLike": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_method": {
                                    "variable_value": "<bound method IntervalIndex._check_method of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')",
                                    "variable_type": "IntervalIndex",
                                    "variable_shape": "(2,)"
                                },
                                "method": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.is_overlapping": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "msg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidIndexError": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target_as_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target": {
                                    "variable_value": "IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')",
                                    "variable_type": "IntervalIndex",
                                    "variable_shape": "(2,)"
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.equals": {
                                    "variable_value": "<bound method IntervalIndex.equals of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.arange": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "common_subtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "find_common_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype.subtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "interval[int64]",
                                    "variable_type": "IntervalDtype",
                                    "variable_shape": "()"
                                },
                                "target_as_index.dtype.subtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target_as_index.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.closed": {
                                    "variable_value": "'right'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "target_as_index.closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.repeat": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.left.get_indexer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.left": {
                                    "variable_value": "Int64Index([0, 1], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "target_as_index.left": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.right.get_indexer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.right": {
                                    "variable_value": "Int64Index([1, 2], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "target_as_index.right": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.where": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.get_indexer": {
                                    "variable_value": "<bound method IntervalIndex.get_indexer of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "target_as_index.categories": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "take_1d": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target_as_index.codes": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_convert_i8": {
                                    "variable_value": "<bound method IntervalIndex._maybe_convert_i8 of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._engine.get_indexer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<IntervalTree[int64,right]: 2 elements>",
                                    "variable_type": "IntervalTree",
                                    "variable_shape": null
                                },
                                "target_as_index.values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "loc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.get_loc": {
                                    "variable_value": "<bound method IntervalIndex.get_loc of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer.append": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Substitution": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "textwrap.dedent": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "textwrap": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "AnyArrayLike": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_method": {
                                    "variable_value": "<bound method IntervalIndex._check_method of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')",
                                    "variable_type": "IntervalIndex",
                                    "variable_shape": "(2,)"
                                },
                                "method": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.is_overlapping": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "msg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidIndexError": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target_as_index": {
                                    "variable_value": "IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')",
                                    "variable_type": "IntervalIndex",
                                    "variable_shape": "(2,)"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target": {
                                    "variable_value": "IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')",
                                    "variable_type": "IntervalIndex",
                                    "variable_shape": "(2,)"
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.equals": {
                                    "variable_value": "<bound method IntervalIndex.equals of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.arange": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "common_subtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "find_common_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype.subtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "interval[int64]",
                                    "variable_type": "IntervalDtype",
                                    "variable_shape": "()"
                                },
                                "target_as_index.dtype.subtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "target_as_index.dtype": {
                                    "variable_value": "interval[int64]",
                                    "variable_type": "IntervalDtype",
                                    "variable_shape": "()"
                                },
                                "self.closed": {
                                    "variable_value": "'right'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "target_as_index.closed": {
                                    "variable_value": "'right'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.repeat": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.left.get_indexer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.left": {
                                    "variable_value": "Int64Index([0, 1], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "target_as_index.left": {
                                    "variable_value": "Int64Index([0, 1], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "right_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.right.get_indexer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.right": {
                                    "variable_value": "Int64Index([1, 2], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "target_as_index.right": {
                                    "variable_value": "Int64Index([1, 2], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.where": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.get_indexer": {
                                    "variable_value": "<bound method IntervalIndex.get_indexer of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "target_as_index.categories": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "take_1d": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target_as_index.codes": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._maybe_convert_i8": {
                                    "variable_value": "<bound method IntervalIndex._maybe_convert_i8 of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._engine.get_indexer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<IntervalTree[int64,right]: 2 elements>",
                                    "variable_type": "IntervalTree",
                                    "variable_shape": null
                                },
                                "target_as_index.values": {
                                    "variable_value": "<IntervalArray>\n[(0, 1], (1, 2]]\nLength: 2, closed: right, dtype: interval[int64]",
                                    "variable_type": "IntervalArray",
                                    "variable_shape": "(2,)"
                                },
                                "key": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "loc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.get_loc": {
                                    "variable_value": "<bound method IntervalIndex.get_loc of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer.append": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Substitution": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "textwrap.dedent": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "textwrap": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "AnyArrayLike": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_method": {
                                    "variable_value": "<bound method IntervalIndex._check_method of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')",
                                    "variable_type": "IntervalIndex",
                                    "variable_shape": "(2,)"
                                },
                                "method": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.is_overlapping": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "msg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidIndexError": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target_as_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target": {
                                    "variable_value": "IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')",
                                    "variable_type": "IntervalIndex",
                                    "variable_shape": "(2,)"
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.equals": {
                                    "variable_value": "<bound method IntervalIndex.equals of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.arange": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "common_subtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "find_common_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype.subtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "interval[int64]",
                                    "variable_type": "IntervalDtype",
                                    "variable_shape": "()"
                                },
                                "target_as_index.dtype.subtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target_as_index.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.closed": {
                                    "variable_value": "'right'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "target_as_index.closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.repeat": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.left.get_indexer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.left": {
                                    "variable_value": "Int64Index([0, 1], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "target_as_index.left": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.right.get_indexer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.right": {
                                    "variable_value": "Int64Index([1, 2], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "target_as_index.right": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.where": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.get_indexer": {
                                    "variable_value": "<bound method IntervalIndex.get_indexer of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "target_as_index.categories": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "take_1d": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target_as_index.codes": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_convert_i8": {
                                    "variable_value": "<bound method IntervalIndex._maybe_convert_i8 of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._engine.get_indexer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<IntervalTree[int64,right]: 2 elements>",
                                    "variable_type": "IntervalTree",
                                    "variable_shape": null
                                },
                                "target_as_index.values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "loc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.get_loc": {
                                    "variable_value": "<bound method IntervalIndex.get_loc of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer.append": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Substitution": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "textwrap.dedent": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "textwrap": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "AnyArrayLike": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_method": {
                                    "variable_value": "<bound method IntervalIndex._check_method of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')",
                                    "variable_type": "IntervalIndex",
                                    "variable_shape": "(2,)"
                                },
                                "method": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.is_overlapping": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "msg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidIndexError": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target_as_index": {
                                    "variable_value": "CategoricalIndex([(0, 1], (1, 2]], categories=[(0, 1], (1, 2]], ordered=False, dtype='category')",
                                    "variable_type": "CategoricalIndex",
                                    "variable_shape": "(2,)"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target": {
                                    "variable_value": "CategoricalIndex([(0, 1], (1, 2]], categories=[(0, 1], (1, 2]], ordered=False, dtype='category')",
                                    "variable_type": "CategoricalIndex",
                                    "variable_shape": "(2,)"
                                },
                                "IntervalIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.equals": {
                                    "variable_value": "<bound method IntervalIndex.equals of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.arange": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "common_subtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "find_common_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype.subtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "interval[int64]",
                                    "variable_type": "IntervalDtype",
                                    "variable_shape": "()"
                                },
                                "target_as_index.dtype.subtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "target_as_index.dtype": {
                                    "variable_value": "CategoricalDtype(categories=[(0, 1], (1, 2]],\n              ordered=False)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "self.closed": {
                                    "variable_value": "'right'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "target_as_index.closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.repeat": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.left.get_indexer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.left": {
                                    "variable_value": "Int64Index([0, 1], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "target_as_index.left": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "right_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.right.get_indexer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.right": {
                                    "variable_value": "Int64Index([1, 2], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "target_as_index.right": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": "array([0, 1])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2,)"
                                },
                                "np.where": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories_indexer": {
                                    "variable_value": "array([0, 1])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2,)"
                                },
                                "self.get_indexer": {
                                    "variable_value": "<bound method IntervalIndex.get_indexer of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "target_as_index.categories": {
                                    "variable_value": "IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')",
                                    "variable_type": "IntervalIndex",
                                    "variable_shape": "(2,)"
                                },
                                "take_1d": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target_as_index.codes": {
                                    "variable_value": "array([0, 1], dtype=int8)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2,)"
                                },
                                "self._maybe_convert_i8": {
                                    "variable_value": "<bound method IntervalIndex._maybe_convert_i8 of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self._engine.get_indexer": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<IntervalTree[int64,right]: 2 elements>",
                                    "variable_type": "IntervalTree",
                                    "variable_shape": null
                                },
                                "target_as_index.values": {
                                    "variable_value": "[(0, 1], (1, 2]]\nCategories (2, interval[int64]): [(0, 1], (1, 2]]",
                                    "variable_type": "Categorical",
                                    "variable_shape": "(2,)"
                                },
                                "key": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "loc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.get_loc": {
                                    "variable_value": "<bound method IntervalIndex.get_loc of IntervalIndex([(0, 1], (1, 2]],\n              closed='right',\n              dtype='interval[int64]')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer.append": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Substitution": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "textwrap.dedent": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "textwrap": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                }
            ],
            "snippets": [
                {
                    "snippet_code": "from pandas.core.dtypes.common import (\n    ensure_platform_int,\n    is_datetime64tz_dtype,\n    is_datetime_or_timedelta_dtype,\n    is_dtype_equal,\n    is_float,\n    is_float_dtype,\n    is_integer,\n    is_integer_dtype,\n    is_interval_dtype,\n    is_list_like,\n    is_number,\n    is_object_dtype,\n    is_scalar,\n)\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.missing import isna\n\nfrom pandas._typing import AnyArrayLike\nfrom pandas.core.arrays.interval import IntervalArray, _interval_shared_docs",
                    "start_line": 20,
                    "end_line": 39
                }
            ],
            "inscope_functions": {
                "file_scope_functions": [
                    {
                        "code": "def _get_next_label(label):\n    dtype = getattr(label, \"dtype\", type(label))\n    if isinstance(label, (Timestamp, Timedelta)):\n        dtype = \"datetime64\"\n    if is_datetime_or_timedelta_dtype(dtype) or is_datetime64tz_dtype(dtype):\n        return label + np.timedelta64(1, \"ns\")\n    elif is_integer_dtype(dtype):\n        return label + 1\n    elif is_float_dtype(dtype):\n        return np.nextafter(label, np.infty)\n    else:\n        raise TypeError(f\"cannot determine next label for type {repr(type(label))}\")",
                        "signature": "_get_next_label(label)"
                    },
                    {
                        "code": "def _get_prev_label(label):\n    dtype = getattr(label, \"dtype\", type(label))\n    if isinstance(label, (Timestamp, Timedelta)):\n        dtype = \"datetime64\"\n    if is_datetime_or_timedelta_dtype(dtype) or is_datetime64tz_dtype(dtype):\n        return label - np.timedelta64(1, \"ns\")\n    elif is_integer_dtype(dtype):\n        return label - 1\n    elif is_float_dtype(dtype):\n        return np.nextafter(label, -np.infty)\n    else:\n        raise TypeError(f\"cannot determine next label for type {repr(type(label))}\")",
                        "signature": "_get_prev_label(label)"
                    },
                    {
                        "code": "def _get_interval_closed_bounds(interval):\n    \"\"\"\n    Given an Interval or IntervalIndex, return the corresponding interval with\n    closed bounds.\n    \"\"\"\n    left, right = interval.left, interval.right\n    if interval.open_left:\n        left = _get_next_label(left)\n    if interval.open_right:\n        right = _get_prev_label(right)\n    return left, right",
                        "signature": "_get_interval_closed_bounds(interval)"
                    },
                    {
                        "code": "def _new_IntervalIndex(cls, d):\n    \"\"\"\n    This is called upon unpickling, rather than the default which doesn't have\n    arguments and breaks __new__.\n    \"\"\"\n    return cls.from_arrays(**d)",
                        "signature": "_new_IntervalIndex(cls, d)"
                    },
                    {
                        "code": "def _is_valid_endpoint(endpoint) -> bool:\n    \"\"\"helper for interval_range to check if start/end are valid types\"\"\"\n    return any(\n        [\n            is_number(endpoint),\n            isinstance(endpoint, Timestamp),\n            isinstance(endpoint, Timedelta),\n            endpoint is None,\n        ]\n    )",
                        "signature": "_is_valid_endpoint(endpoint) -> bool"
                    },
                    {
                        "code": "def _is_type_compatible(a, b) -> bool:\n    \"\"\"helper for interval_range to check type compat of start/end/freq\"\"\"\n    is_ts_compat = lambda x: isinstance(x, (Timestamp, DateOffset))\n    is_td_compat = lambda x: isinstance(x, (Timedelta, DateOffset))\n    return (\n        (is_number(a) and is_number(b))\n        or (is_ts_compat(a) and is_ts_compat(b))\n        or (is_td_compat(a) and is_td_compat(b))\n        or com.any_none(a, b)\n    )",
                        "signature": "_is_type_compatible(a, b) -> bool"
                    },
                    {
                        "code": "def interval_range(\n    start=None, end=None, periods=None, freq=None, name=None, closed=\"right\"\n):\n    \"\"\"\n    Return a fixed frequency IntervalIndex.\n\n    Parameters\n    ----------\n    start : numeric or datetime-like, default None\n        Left bound for generating intervals.\n    end : numeric or datetime-like, default None\n        Right bound for generating intervals.\n    periods : int, default None\n        Number of periods to generate.\n    freq : numeric, str, or DateOffset, default None\n        The length of each interval. Must be consistent with the type of start\n        and end, e.g. 2 for numeric, or '5H' for datetime-like.  Default is 1\n        for numeric and 'D' for datetime-like.\n    name : str, default None\n        Name of the resulting IntervalIndex.\n    closed : {'left', 'right', 'both', 'neither'}, default 'right'\n        Whether the intervals are closed on the left-side, right-side, both\n        or neither.\n\n    Returns\n    -------\n    IntervalIndex\n\n    See Also\n    --------\n    IntervalIndex : An Index of intervals that are all closed on the same side.\n\n    Notes\n    -----\n    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\n    exactly three must be specified. If ``freq`` is omitted, the resulting\n    ``IntervalIndex`` will have ``periods`` linearly spaced elements between\n    ``start`` and ``end``, inclusively.\n\n    To learn more about datetime-like frequency strings, please see `this link\n    <http://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\n\n    Examples\n    --------\n    Numeric ``start`` and  ``end`` is supported.\n\n    >>> pd.interval_range(start=0, end=5)\n    IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\n                  closed='right', dtype='interval[int64]')\n\n    Additionally, datetime-like input is also supported.\n\n    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\n    ...                   end=pd.Timestamp('2017-01-04'))\n    IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03],\n                   (2017-01-03, 2017-01-04]],\n                  closed='right', dtype='interval[datetime64[ns]]')\n\n    The ``freq`` parameter specifies the frequency between the left and right.\n    endpoints of the individual intervals within the ``IntervalIndex``.  For\n    numeric ``start`` and ``end``, the frequency must also be numeric.\n\n    >>> pd.interval_range(start=0, periods=4, freq=1.5)\n    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\n                  closed='right', dtype='interval[float64]')\n\n    Similarly, for datetime-like ``start`` and ``end``, the frequency must be\n    convertible to a DateOffset.\n\n    >>> pd.interval_range(start=pd.Timestamp('2017-01-01'),\n    ...                   periods=3, freq='MS')\n    IntervalIndex([(2017-01-01, 2017-02-01], (2017-02-01, 2017-03-01],\n                   (2017-03-01, 2017-04-01]],\n                  closed='right', dtype='interval[datetime64[ns]]')\n\n    Specify ``start``, ``end``, and ``periods``; the frequency is generated\n    automatically (linearly spaced).\n\n    >>> pd.interval_range(start=0, end=6, periods=4)\n    IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],\n              closed='right',\n              dtype='interval[float64]')\n\n    The ``closed`` parameter specifies which endpoints of the individual\n    intervals within the ``IntervalIndex`` are closed.\n\n    >>> pd.interval_range(end=5, periods=4, closed='both')\n    IntervalIndex([[1, 2], [2, 3], [3, 4], [4, 5]],\n                  closed='both', dtype='interval[int64]')\n    \"\"\"\n    start = com.maybe_box_datetimelike(start)\n    end = com.maybe_box_datetimelike(end)\n    endpoint = start if start is not None else end\n\n    if freq is None and com.any_none(periods, start, end):\n        freq = 1 if is_number(endpoint) else \"D\"\n\n    if com.count_not_none(start, end, periods, freq) != 3:\n        raise ValueError(\n            \"Of the four parameters: start, end, periods, and \"\n            \"freq, exactly three must be specified\"\n        )\n\n    if not _is_valid_endpoint(start):\n        msg = \"start must be numeric or datetime-like, got {start}\"\n        raise ValueError(msg.format(start=start))\n    elif not _is_valid_endpoint(end):\n        msg = \"end must be numeric or datetime-like, got {end}\"\n        raise ValueError(msg.format(end=end))\n\n    if is_float(periods):\n        periods = int(periods)\n    elif not is_integer(periods) and periods is not None:\n        msg = \"periods must be a number, got {periods}\"\n        raise TypeError(msg.format(periods=periods))\n\n    if freq is not None and not is_number(freq):\n        try:\n            freq = to_offset(freq)\n        except ValueError:\n            raise ValueError(\n                \"freq must be numeric or convertible to \"\n                \"DateOffset, got {freq}\".format(freq=freq)\n            )\n\n    # verify type compatibility\n    if not all(\n        [\n            _is_type_compatible(start, end),\n            _is_type_compatible(start, freq),\n            _is_type_compatible(end, freq),\n        ]\n    ):\n        raise TypeError(\"start, end, freq need to be type compatible\")\n\n    # +1 to convert interval count to breaks count (n breaks = n-1 intervals)\n    if periods is not None:\n        periods += 1\n\n    if is_number(endpoint):\n        # force consistency between start/end/freq (lower end if freq skips it)\n        if com.all_not_none(start, end, freq):\n            end -= (end - start) % freq\n\n        # compute the period/start/end if unspecified (at most one)\n        if periods is None:\n            periods = int((end - start) // freq) + 1\n        elif start is None:\n            start = end - (periods - 1) * freq\n        elif end is None:\n            end = start + (periods - 1) * freq\n\n        breaks = np.linspace(start, end, periods)\n        if all(is_integer(x) for x in com.not_none(start, end, freq)):\n            # np.linspace always produces float output\n            breaks = maybe_downcast_to_dtype(breaks, \"int64\")\n    else:\n        # delegate to the appropriate range function\n        if isinstance(endpoint, Timestamp):\n            range_func = date_range\n        else:\n            range_func = timedelta_range\n\n        breaks = range_func(start=start, end=end, periods=periods, freq=freq)\n\n    return IntervalIndex.from_breaks(breaks, name=name, closed=closed)",
                        "signature": "interval_range(start=None, end=None, periods=None, freq=None, name=None, closed='right')"
                    }
                ],
                "file_scope_classes": [
                    {
                        "class_declaration": "class SetopCheck:",
                        "functions": [
                            {
                                "code": "def __init__(self, op_name):\n    self.op_name = op_name",
                                "signature": "__init__(self, op_name)"
                            },
                            {
                                "code": "def __call__(self, setop):\n    def func(intvidx_self, other, sort=False):\n        intvidx_self._assert_can_do_setop(other)\n        other = ensure_index(other)\n\n        if not isinstance(other, IntervalIndex):\n            result = getattr(intvidx_self.astype(object), self.op_name)(other)\n            if self.op_name in (\"difference\",):\n                result = result.astype(intvidx_self.dtype)\n            return result\n        elif intvidx_self.closed != other.closed:\n            msg = (\n                \"can only do set operations between two IntervalIndex \"\n                \"objects that are closed on the same side\"\n            )\n            raise ValueError(msg)\n\n        # GH 19016: ensure set op will not return a prohibited dtype\n        subtypes = [intvidx_self.dtype.subtype, other.dtype.subtype]\n        common_subtype = find_common_type(subtypes)\n        if is_object_dtype(common_subtype):\n            msg = (\n                \"can only do {op} between two IntervalIndex \"\n                \"objects that have compatible dtypes\"\n            )\n            raise TypeError(msg.format(op=self.op_name))\n\n        return setop(intvidx_self, other, sort)\n\n    return func",
                                "signature": "__call__(self, setop)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class IntervalIndex:",
                        "functions": [
                            {
                                "code": "def __new__(\n    cls, data, closed=None, dtype=None, copy=False, name=None, verify_integrity=True\n):\n\n    if name is None and hasattr(data, \"name\"):\n        name = data.name\n\n    with rewrite_exception(\"IntervalArray\", cls.__name__):\n        array = IntervalArray(\n            data,\n            closed=closed,\n            copy=copy,\n            dtype=dtype,\n            verify_integrity=verify_integrity,\n        )\n\n    return cls._simple_new(array, name)",
                                "signature": "__new__(cls, data, closed=None, dtype=None, copy=False, name=None, verify_integrity=True)"
                            },
                            {
                                "code": "@classmethod\ndef _simple_new(cls, array, name, closed=None):\n    \"\"\"\n    Construct from an IntervalArray\n\n    Parameters\n    ----------\n    array : IntervalArray\n    name : str\n        Attached as result.name\n    closed : Any\n        Ignored.\n    \"\"\"\n    result = IntervalMixin.__new__(cls)\n    result._data = array\n    result.name = name\n    result._reset_identity()\n    return result",
                                "signature": "_simple_new(cls, array, name, closed=None)"
                            },
                            {
                                "code": "@classmethod\n@Appender(\n    _interval_shared_docs[\"from_breaks\"]\n    % dict(\n        klass=\"IntervalIndex\",\n        examples=textwrap.dedent(\n            \"\"\"\\\n    Examples\n    --------\n    >>> pd.IntervalIndex.from_breaks([0, 1, 2, 3])\n    IntervalIndex([(0, 1], (1, 2], (2, 3]],\n                  closed='right',\n                  dtype='interval[int64]')\n    \"\"\"\n        ),\n    )\n)\ndef from_breaks(cls, breaks, closed=\"right\", name=None, copy=False, dtype=None):\n    with rewrite_exception(\"IntervalArray\", cls.__name__):\n        array = IntervalArray.from_breaks(\n            breaks, closed=closed, copy=copy, dtype=dtype\n        )\n    return cls._simple_new(array, name=name)",
                                "signature": "from_breaks(cls, breaks, closed='right', name=None, copy=False, dtype=None)"
                            },
                            {
                                "code": "@classmethod\n@Appender(\n    _interval_shared_docs[\"from_arrays\"]\n    % dict(\n        klass=\"IntervalIndex\",\n        examples=textwrap.dedent(\n            \"\"\"\\\n    Examples\n    --------\n    >>> pd.IntervalIndex.from_arrays([0, 1, 2], [1, 2, 3])\n    IntervalIndex([(0, 1], (1, 2], (2, 3]],\n                  closed='right',\n                  dtype='interval[int64]')\n    \"\"\"\n        ),\n    )\n)\ndef from_arrays(\n    cls, left, right, closed=\"right\", name=None, copy=False, dtype=None\n):\n    with rewrite_exception(\"IntervalArray\", cls.__name__):\n        array = IntervalArray.from_arrays(\n            left, right, closed, copy=copy, dtype=dtype\n        )\n    return cls._simple_new(array, name=name)",
                                "signature": "from_arrays(cls, left, right, closed='right', name=None, copy=False, dtype=None)"
                            },
                            {
                                "code": "@classmethod\n@Appender(\n    _interval_shared_docs[\"from_tuples\"]\n    % dict(\n        klass=\"IntervalIndex\",\n        examples=textwrap.dedent(\n            \"\"\"\\\n    Examples\n    --------\n    >>> pd.IntervalIndex.from_tuples([(0, 1), (1, 2)])\n    IntervalIndex([(0, 1], (1, 2]],\n                   closed='right',\n                   dtype='interval[int64]')\n    \"\"\"\n        ),\n    )\n)\ndef from_tuples(cls, data, closed=\"right\", name=None, copy=False, dtype=None):\n    with rewrite_exception(\"IntervalArray\", cls.__name__):\n        arr = IntervalArray.from_tuples(data, closed=closed, copy=copy, dtype=dtype)\n    return cls._simple_new(arr, name=name)",
                                "signature": "from_tuples(cls, data, closed='right', name=None, copy=False, dtype=None)"
                            },
                            {
                                "code": "@Appender(_index_shared_docs[\"_shallow_copy\"])\ndef _shallow_copy(self, left=None, right=None, **kwargs):\n    result = self._data._shallow_copy(left=left, right=right)\n    attributes = self._get_attributes_dict()\n    attributes.update(kwargs)\n    return self._simple_new(result, **attributes)",
                                "signature": "_shallow_copy(self, left=None, right=None, **kwargs)"
                            },
                            {
                                "code": "@cache_readonly\ndef _isnan(self):\n    \"\"\"Return a mask indicating if each value is NA\"\"\"\n    if self._mask is None:\n        self._mask = isna(self.left)\n    return self._mask",
                                "signature": "_isnan(self)"
                            },
                            {
                                "code": "@cache_readonly\ndef _engine(self):\n    left = self._maybe_convert_i8(self.left)\n    right = self._maybe_convert_i8(self.right)\n    return IntervalTree(left, right, closed=self.closed)",
                                "signature": "_engine(self)"
                            },
                            {
                                "code": "def __contains__(self, key) -> bool:\n    \"\"\"\n    return a boolean if this key is IN the index\n    We *only* accept an Interval\n\n    Parameters\n    ----------\n    key : Interval\n\n    Returns\n    -------\n    boolean\n    \"\"\"\n    if not isinstance(key, Interval):\n        return False\n\n    try:\n        self.get_loc(key)\n        return True\n    except KeyError:\n        return False",
                                "signature": "__contains__(self, key) -> bool"
                            },
                            {
                                "code": "@Appender(\n    _interval_shared_docs[\"to_tuples\"]\n    % dict(\n        return_type=\"Index\",\n        examples=\"\"\"\n    Examples\n    --------\n    >>> idx = pd.IntervalIndex.from_arrays([0, np.nan, 2], [1, np.nan, 3])\n    >>> idx.to_tuples()\n    Index([(0.0, 1.0), (nan, nan), (2.0, 3.0)], dtype='object')\n    >>> idx.to_tuples(na_tuple=False)\n    Index([(0.0, 1.0), nan, (2.0, 3.0)], dtype='object')\n    \"\"\",\n    )\n)\ndef to_tuples(self, na_tuple=True):\n    tuples = self._data.to_tuples(na_tuple=na_tuple)\n    return Index(tuples)",
                                "signature": "to_tuples(self, na_tuple=True)"
                            },
                            {
                                "code": "@cache_readonly\ndef _multiindex(self):\n    return MultiIndex.from_arrays([self.left, self.right], names=[\"left\", \"right\"])",
                                "signature": "_multiindex(self)"
                            },
                            {
                                "code": "@property\ndef left(self):\n    \"\"\"\n    Return the left endpoints of each Interval in the IntervalIndex as\n    an Index.\n    \"\"\"\n    return self._data._left",
                                "signature": "left(self)"
                            },
                            {
                                "code": "@property\ndef right(self):\n    \"\"\"\n    Return the right endpoints of each Interval in the IntervalIndex as\n    an Index.\n    \"\"\"\n    return self._data._right",
                                "signature": "right(self)"
                            },
                            {
                                "code": "@property\ndef closed(self):\n    \"\"\"\n    Whether the intervals are closed on the left-side, right-side, both or\n    neither.\n    \"\"\"\n    return self._data._closed",
                                "signature": "closed(self)"
                            },
                            {
                                "code": "@Appender(\n    _interval_shared_docs[\"set_closed\"]\n    % dict(\n        klass=\"IntervalIndex\",\n        examples=textwrap.dedent(\n            \"\"\"\\\n    Examples\n    --------\n    >>> index = pd.interval_range(0, 3)\n    >>> index\n    IntervalIndex([(0, 1], (1, 2], (2, 3]],\n                  closed='right',\n                  dtype='interval[int64]')\n    >>> index.set_closed('both')\n    IntervalIndex([[0, 1], [1, 2], [2, 3]],\n                  closed='both',\n                  dtype='interval[int64]')\n    \"\"\"\n        ),\n    )\n)\ndef set_closed(self, closed):\n    if closed not in _VALID_CLOSED:\n        msg = \"invalid option for 'closed': {closed}\"\n        raise ValueError(msg.format(closed=closed))\n\n    # return self._shallow_copy(closed=closed)\n    array = self._data.set_closed(closed)\n    return self._simple_new(array, self.name)",
                                "signature": "set_closed(self, closed)"
                            },
                            {
                                "code": "@property\ndef length(self):\n    \"\"\"\n    Return an Index with entries denoting the length of each Interval in\n    the IntervalIndex.\n    \"\"\"\n    return self._data.length",
                                "signature": "length(self)"
                            },
                            {
                                "code": "@property\ndef size(self):\n    # Avoid materializing ndarray[Interval]\n    return self._data.size",
                                "signature": "size(self)"
                            },
                            {
                                "code": "def __len__(self) -> int:\n    return len(self.left)",
                                "signature": "__len__(self) -> int"
                            },
                            {
                                "code": "@cache_readonly\ndef values(self):\n    \"\"\"\n    Return the IntervalIndex's data as an IntervalArray.\n    \"\"\"\n    return self._data",
                                "signature": "values(self)"
                            },
                            {
                                "code": "@cache_readonly\ndef _values(self):\n    return self._data",
                                "signature": "_values(self)"
                            },
                            {
                                "code": "@cache_readonly\ndef _ndarray_values(self) -> np.ndarray:\n    return np.array(self._data)",
                                "signature": "_ndarray_values(self) -> np.ndarray"
                            },
                            {
                                "code": "def __array__(self, result=None):\n    \"\"\" the array interface, return my values \"\"\"\n    return self._ndarray_values",
                                "signature": "__array__(self, result=None)"
                            },
                            {
                                "code": "def __array_wrap__(self, result, context=None):\n    # we don't want the superclass implementation\n    return result",
                                "signature": "__array_wrap__(self, result, context=None)"
                            },
                            {
                                "code": "def __reduce__(self):\n    d = dict(left=self.left, right=self.right)\n    d.update(self._get_attributes_dict())\n    return _new_IntervalIndex, (type(self), d), None",
                                "signature": "__reduce__(self)"
                            },
                            {
                                "code": "@Appender(_index_shared_docs[\"copy\"])\ndef copy(self, deep=False, name=None):\n    array = self._data\n    if deep:\n        array = array.copy()\n    attributes = self._get_attributes_dict()\n    if name is not None:\n        attributes.update(name=name)\n\n    return self._simple_new(array, **attributes)",
                                "signature": "copy(self, deep=False, name=None)"
                            },
                            {
                                "code": "@Appender(_index_shared_docs[\"astype\"])\ndef astype(self, dtype, copy=True):\n    with rewrite_exception(\"IntervalArray\", type(self).__name__):\n        new_values = self.values.astype(dtype, copy=copy)\n    if is_interval_dtype(new_values):\n        return self._shallow_copy(new_values.left, new_values.right)\n    return super().astype(dtype, copy=copy)",
                                "signature": "astype(self, dtype, copy=True)"
                            },
                            {
                                "code": "@cache_readonly\ndef dtype(self):\n    \"\"\"Return the dtype object of the underlying data\"\"\"\n    return self._data.dtype",
                                "signature": "dtype(self)"
                            },
                            {
                                "code": "@property\ndef inferred_type(self) -> str:\n    \"\"\"Return a string of the type inferred from the values\"\"\"\n    return \"interval\"",
                                "signature": "inferred_type(self) -> str"
                            },
                            {
                                "code": "@Appender(Index.memory_usage.__doc__)\ndef memory_usage(self, deep: bool = False) -> int:\n    # we don't use an explicit engine\n    # so return the bytes here\n    return self.left.memory_usage(deep=deep) + self.right.memory_usage(deep=deep)",
                                "signature": "memory_usage(self, deep: bool=False) -> int"
                            },
                            {
                                "code": "@cache_readonly\ndef mid(self):\n    \"\"\"\n    Return the midpoint of each Interval in the IntervalIndex as an Index.\n    \"\"\"\n    return self._data.mid",
                                "signature": "mid(self)"
                            },
                            {
                                "code": "@cache_readonly\ndef is_monotonic(self) -> bool:\n    \"\"\"\n    Return True if the IntervalIndex is monotonic increasing (only equal or\n    increasing values), else False\n    \"\"\"\n    return self.is_monotonic_increasing",
                                "signature": "is_monotonic(self) -> bool"
                            },
                            {
                                "code": "@cache_readonly\ndef is_monotonic_increasing(self) -> bool:\n    \"\"\"\n    Return True if the IntervalIndex is monotonic increasing (only equal or\n    increasing values), else False\n    \"\"\"\n    return self._engine.is_monotonic_increasing",
                                "signature": "is_monotonic_increasing(self) -> bool"
                            },
                            {
                                "code": "@cache_readonly\ndef is_monotonic_decreasing(self) -> bool:\n    \"\"\"\n    Return True if the IntervalIndex is monotonic decreasing (only equal or\n    decreasing values), else False\n    \"\"\"\n    return self[::-1].is_monotonic_increasing",
                                "signature": "is_monotonic_decreasing(self) -> bool"
                            },
                            {
                                "code": "@cache_readonly\ndef is_unique(self):\n    \"\"\"\n    Return True if the IntervalIndex contains unique elements, else False\n    \"\"\"\n    left = self.left\n    right = self.right\n\n    if self.isna().sum() > 1:\n        return False\n\n    if left.is_unique or right.is_unique:\n        return True\n\n    seen_pairs = set()\n    check_idx = np.where(left.duplicated(keep=False))[0]\n    for idx in check_idx:\n        pair = (left[idx], right[idx])\n        if pair in seen_pairs:\n            return False\n        seen_pairs.add(pair)\n\n    return True",
                                "signature": "is_unique(self)"
                            },
                            {
                                "code": "@cache_readonly\n@Appender(_interval_shared_docs[\"is_non_overlapping_monotonic\"] % _index_doc_kwargs)\ndef is_non_overlapping_monotonic(self):\n    return self._data.is_non_overlapping_monotonic",
                                "signature": "is_non_overlapping_monotonic(self)"
                            },
                            {
                                "code": "@property\ndef is_overlapping(self):\n    \"\"\"\n    Return True if the IntervalIndex has overlapping intervals, else False.\n\n    Two intervals overlap if they share a common point, including closed\n    endpoints. Intervals that only have an open endpoint in common do not\n    overlap.\n\n    .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    bool\n        Boolean indicating if the IntervalIndex has overlapping intervals.\n\n    See Also\n    --------\n    Interval.overlaps : Check whether two Interval objects overlap.\n    IntervalIndex.overlaps : Check an IntervalIndex elementwise for\n        overlaps.\n\n    Examples\n    --------\n    >>> index = pd.IntervalIndex.from_tuples([(0, 2), (1, 3), (4, 5)])\n    >>> index\n    IntervalIndex([(0, 2], (1, 3], (4, 5]],\n          closed='right',\n          dtype='interval[int64]')\n    >>> index.is_overlapping\n    True\n\n    Intervals that share closed endpoints overlap:\n\n    >>> index = pd.interval_range(0, 3, closed='both')\n    >>> index\n    IntervalIndex([[0, 1], [1, 2], [2, 3]],\n          closed='both',\n          dtype='interval[int64]')\n    >>> index.is_overlapping\n    True\n\n    Intervals that only have an open endpoint in common do not overlap:\n\n    >>> index = pd.interval_range(0, 3, closed='left')\n    >>> index\n    IntervalIndex([[0, 1), [1, 2), [2, 3)],\n          closed='left',\n          dtype='interval[int64]')\n    >>> index.is_overlapping\n    False\n    \"\"\"\n    # GH 23309\n    return self._engine.is_overlapping",
                                "signature": "is_overlapping(self)"
                            },
                            {
                                "code": "@Appender(_index_shared_docs[\"_convert_scalar_indexer\"])\ndef _convert_scalar_indexer(self, key, kind=None):\n    if kind == \"iloc\":\n        return super()._convert_scalar_indexer(key, kind=kind)\n    return key",
                                "signature": "_convert_scalar_indexer(self, key, kind=None)"
                            },
                            {
                                "code": "def _maybe_cast_slice_bound(self, label, side, kind):\n    return getattr(self, side)._maybe_cast_slice_bound(label, side, kind)",
                                "signature": "_maybe_cast_slice_bound(self, label, side, kind)"
                            },
                            {
                                "code": "@Appender(_index_shared_docs[\"_convert_list_indexer\"])\ndef _convert_list_indexer(self, keyarr, kind=None):\n    \"\"\"\n    we are passed a list-like indexer. Return the\n    indexer for matching intervals.\n    \"\"\"\n    locs = self.get_indexer_for(keyarr)\n\n    # we have missing values\n    if (locs == -1).any():\n        raise KeyError\n\n    return locs",
                                "signature": "_convert_list_indexer(self, keyarr, kind=None)"
                            },
                            {
                                "code": "def _maybe_cast_indexed(self, key):\n    \"\"\"\n    we need to cast the key, which could be a scalar\n    or an array-like to the type of our subtype\n    \"\"\"\n    if isinstance(key, IntervalIndex):\n        return key\n\n    subtype = self.dtype.subtype\n    if is_float_dtype(subtype):\n        if is_integer(key):\n            key = float(key)\n        elif isinstance(key, (np.ndarray, Index)):\n            key = key.astype(\"float64\")\n    elif is_integer_dtype(subtype):\n        if is_integer(key):\n            key = int(key)\n\n    return key",
                                "signature": "_maybe_cast_indexed(self, key)"
                            },
                            {
                                "code": "def _can_reindex(self, indexer: np.ndarray) -> None:\n    \"\"\"\n    Check if we are allowing reindexing with this particular indexer.\n\n    Parameters\n    ----------\n    indexer : an integer indexer\n\n    Raises\n    ------\n    ValueError if its a duplicate axis\n    \"\"\"\n\n    # trying to reindex on an axis with duplicates\n    if self.is_overlapping and len(indexer):\n        raise ValueError(\"cannot reindex from an overlapping axis\")",
                                "signature": "_can_reindex(self, indexer: np.ndarray) -> None"
                            },
                            {
                                "code": "def _needs_i8_conversion(self, key):\n    \"\"\"\n    Check if a given key needs i8 conversion. Conversion is necessary for\n    Timestamp, Timedelta, DatetimeIndex, and TimedeltaIndex keys. An\n    Interval-like requires conversion if it's endpoints are one of the\n    aforementioned types.\n\n    Assumes that any list-like data has already been cast to an Index.\n\n    Parameters\n    ----------\n    key : scalar or Index-like\n        The key that should be checked for i8 conversion\n\n    Returns\n    -------\n    boolean\n    \"\"\"\n    if is_interval_dtype(key) or isinstance(key, Interval):\n        return self._needs_i8_conversion(key.left)\n\n    i8_types = (Timestamp, Timedelta, DatetimeIndex, TimedeltaIndex)\n    return isinstance(key, i8_types)",
                                "signature": "_needs_i8_conversion(self, key)"
                            },
                            {
                                "code": "def _maybe_convert_i8(self, key):\n    \"\"\"\n    Maybe convert a given key to it's equivalent i8 value(s). Used as a\n    preprocessing step prior to IntervalTree queries (self._engine), which\n    expects numeric data.\n\n    Parameters\n    ----------\n    key : scalar or list-like\n        The key that should maybe be converted to i8.\n\n    Returns\n    -------\n    key: scalar or list-like\n        The original key if no conversion occurred, int if converted scalar,\n        Int64Index if converted list-like.\n    \"\"\"\n    original = key\n    if is_list_like(key):\n        key = ensure_index(key)\n\n    if not self._needs_i8_conversion(key):\n        return original\n\n    scalar = is_scalar(key)\n    if is_interval_dtype(key) or isinstance(key, Interval):\n        # convert left/right and reconstruct\n        left = self._maybe_convert_i8(key.left)\n        right = self._maybe_convert_i8(key.right)\n        constructor = Interval if scalar else IntervalIndex.from_arrays\n        return constructor(left, right, closed=self.closed)\n\n    if scalar:\n        # Timestamp/Timedelta\n        key_dtype, key_i8 = infer_dtype_from_scalar(key, pandas_dtype=True)\n    else:\n        # DatetimeIndex/TimedeltaIndex\n        key_dtype, key_i8 = key.dtype, Index(key.asi8)\n        if key.hasnans:\n            # convert NaT from it's i8 value to np.nan so it's not viewed\n            # as a valid value, maybe causing errors (e.g. is_overlapping)\n            key_i8 = key_i8.where(~key._isnan)\n\n    # ensure consistency with IntervalIndex subtype\n    subtype = self.dtype.subtype\n    msg = (\n        \"Cannot index an IntervalIndex of subtype {subtype} with \"\n        \"values of dtype {other}\"\n    )\n    if not is_dtype_equal(subtype, key_dtype):\n        raise ValueError(msg.format(subtype=subtype, other=key_dtype))\n\n    return key_i8",
                                "signature": "_maybe_convert_i8(self, key)"
                            },
                            {
                                "code": "def _check_method(self, method):\n    if method is None:\n        return\n\n    if method in [\"bfill\", \"backfill\", \"pad\", \"ffill\", \"nearest\"]:\n        msg = \"method {method} not yet implemented for IntervalIndex\"\n        raise NotImplementedError(msg.format(method=method))\n\n    raise ValueError(\"Invalid fill method\")",
                                "signature": "_check_method(self, method)"
                            },
                            {
                                "code": "def _searchsorted_monotonic(self, label, side, exclude_label=False):\n    if not self.is_non_overlapping_monotonic:\n        raise KeyError(\n            \"can only get slices from an IntervalIndex if \"\n            \"bounds are non-overlapping and all monotonic \"\n            \"increasing or decreasing\"\n        )\n\n    if isinstance(label, IntervalMixin):\n        msg = \"Interval objects are not currently supported\"\n        raise NotImplementedError(msg)\n\n    # GH 20921: \"not is_monotonic_increasing\" for the second condition\n    # instead of \"is_monotonic_decreasing\" to account for single element\n    # indexes being both increasing and decreasing\n    if (side == \"left\" and self.left.is_monotonic_increasing) or (\n        side == \"right\" and not self.left.is_monotonic_increasing\n    ):\n        sub_idx = self.right\n        if self.open_right or exclude_label:\n            label = _get_next_label(label)\n    else:\n        sub_idx = self.left\n        if self.open_left or exclude_label:\n            label = _get_prev_label(label)\n\n    return sub_idx._searchsorted_monotonic(label, side)",
                                "signature": "_searchsorted_monotonic(self, label, side, exclude_label=False)"
                            },
                            {
                                "code": "def _find_non_overlapping_monotonic_bounds(self, key):\n    if isinstance(key, IntervalMixin):\n        start = self._searchsorted_monotonic(\n            key.left, \"left\", exclude_label=key.open_left\n        )\n        stop = self._searchsorted_monotonic(\n            key.right, \"right\", exclude_label=key.open_right\n        )\n    elif isinstance(key, slice):\n        # slice\n        start, stop = key.start, key.stop\n        if (key.step or 1) != 1:\n            raise NotImplementedError(\"cannot slice with a slice step\")\n        if start is None:\n            start = 0\n        else:\n            start = self._searchsorted_monotonic(start, \"left\")\n        if stop is None:\n            stop = len(self)\n        else:\n            stop = self._searchsorted_monotonic(stop, \"right\")\n    else:\n        # scalar or index-like\n\n        start = self._searchsorted_monotonic(key, \"left\")\n        stop = self._searchsorted_monotonic(key, \"right\")\n    return start, stop",
                                "signature": "_find_non_overlapping_monotonic_bounds(self, key)"
                            },
                            {
                                "code": "def get_loc(\n    self, key: Any, method: Optional[str] = None, tolerance=None\n) -> Union[int, slice, np.ndarray]:\n    \"\"\"\n    Get integer location, slice or boolean mask for requested label.\n\n    Parameters\n    ----------\n    key : label\n    method : {None}, optional\n        * default: matches where the label is within an interval only.\n\n    Returns\n    -------\n    loc : int if unique index, slice if monotonic index, else mask\n\n    Examples\n    --------\n    >>> i1, i2 = pd.Interval(0, 1), pd.Interval(1, 2)\n    >>> index = pd.IntervalIndex([i1, i2])\n    >>> index.get_loc(1)\n    0\n\n    You can also supply a point inside an interval.\n\n    >>> index.get_loc(1.5)\n    1\n\n    If a label is in several intervals, you get the locations of all the\n    relevant intervals.\n\n    >>> i3 = pd.Interval(0, 2)\n    >>> overlapping_index = pd.IntervalIndex([i1, i2, i3])\n    >>> overlapping_index.get_loc(0.5)\n    array([ True, False,  True])\n\n    Only exact matches will be returned if an interval is provided.\n\n    >>> index.get_loc(pd.Interval(0, 1))\n    0\n    \"\"\"\n    self._check_method(method)\n\n    # list-like are invalid labels for II but in some cases may work, e.g\n    # single element array of comparable type, so guard against them early\n    if is_list_like(key):\n        raise KeyError(key)\n\n    if isinstance(key, Interval):\n        if self.closed != key.closed:\n            raise KeyError(key)\n        mask = (self.left == key.left) & (self.right == key.right)\n    else:\n        # assume scalar\n        op_left = le if self.closed_left else lt\n        op_right = le if self.closed_right else lt\n        try:\n            mask = op_left(self.left, key) & op_right(key, self.right)\n        except TypeError:\n            # scalar is not comparable to II subtype --> invalid label\n            raise KeyError(key)\n\n    matches = mask.sum()\n    if matches == 0:\n        raise KeyError(key)\n    elif matches == 1:\n        return mask.argmax()\n    return lib.maybe_booleans_to_slice(mask.view(\"u1\"))",
                                "signature": "get_loc(self, key: Any, method: Optional[str]=None, tolerance=None) -> Union[int, slice, np.ndarray]"
                            },
                            {
                                "code": "@Substitution(\n    **dict(\n        _index_doc_kwargs,\n        **{\n            \"raises_section\": textwrap.dedent(\n                \"\"\"\n    Raises\n    ------\n    NotImplementedError\n        If any method argument other than the default of\n        None is specified as these are not yet implemented.\n    \"\"\"\n            )\n        },\n    )\n)\n@Appender(_index_shared_docs[\"get_indexer\"])\ndef get_indexer(\n    self,\n    target: AnyArrayLike,\n    method: Optional[str] = None,\n    limit: Optional[int] = None,\n    tolerance: Optional[Any] = None,\n) -> np.ndarray:\n\n    self._check_method(method)\n\n    if self.is_overlapping:\n        msg = (\n            \"cannot handle overlapping indices; use \"\n            \"IntervalIndex.get_indexer_non_unique\"\n        )\n        raise InvalidIndexError(msg)\n\n    target_as_index = ensure_index(target)\n\n    if isinstance(target_as_index, IntervalIndex):\n        # equal indexes -> 1:1 positional match\n        if self.equals(target_as_index):\n            return np.arange(len(self), dtype=\"intp\")\n\n        # different closed or incompatible subtype -> no matches\n        common_subtype = find_common_type(\n            [self.dtype.subtype, target_as_index.dtype.subtype]\n        )\n        if self.closed != target_as_index.closed or is_object_dtype(common_subtype):\n            return np.repeat(np.intp(-1), len(target_as_index))\n\n        # non-overlapping -> at most one match per interval in target_as_index\n        # want exact matches -> need both left/right to match, so defer to\n        # left/right get_indexer, compare elementwise, equality -> match\n        left_indexer = self.left.get_indexer(target_as_index.left)\n        right_indexer = self.right.get_indexer(target_as_index.right)\n        indexer = np.where(left_indexer == right_indexer, left_indexer, -1)\n    elif not is_object_dtype(target_as_index):\n        # homogeneous scalar index: use IntervalTree\n        target_as_index = self._maybe_convert_i8(target_as_index)\n        indexer = self._engine.get_indexer(target_as_index.values)\n    else:\n        # heterogeneous scalar index: defer elementwise to get_loc\n        # (non-overlapping so get_loc guarantees scalar of KeyError)\n        indexer = []\n        for key in target_as_index:\n            try:\n                loc = self.get_loc(key)\n            except KeyError:\n                loc = -1\n            indexer.append(loc)\n\n    return ensure_platform_int(indexer)",
                                "signature": "get_indexer(self, target: AnyArrayLike, method: Optional[str]=None, limit: Optional[int]=None, tolerance: Optional[Any]=None) -> np.ndarray"
                            },
                            {
                                "code": "@Appender(_index_shared_docs[\"get_indexer_non_unique\"] % _index_doc_kwargs)\ndef get_indexer_non_unique(\n    self, target: AnyArrayLike\n) -> Tuple[np.ndarray, np.ndarray]:\n    target_as_index = ensure_index(target)\n\n    # check that target_as_index IntervalIndex is compatible\n    if isinstance(target_as_index, IntervalIndex):\n        common_subtype = find_common_type(\n            [self.dtype.subtype, target_as_index.dtype.subtype]\n        )\n        if self.closed != target_as_index.closed or is_object_dtype(common_subtype):\n            # different closed or incompatible subtype -> no matches\n            return (\n                np.repeat(-1, len(target_as_index)),\n                np.arange(len(target_as_index)),\n            )\n\n    if is_object_dtype(target_as_index) or isinstance(\n        target_as_index, IntervalIndex\n    ):\n        # target_as_index might contain intervals: defer elementwise to get_loc\n        indexer, missing = [], []\n        for i, key in enumerate(target_as_index):\n            try:\n                locs = self.get_loc(key)\n                if isinstance(locs, slice):\n                    locs = np.arange(locs.start, locs.stop, locs.step, dtype=\"intp\")\n                locs = np.array(locs, ndmin=1)\n            except KeyError:\n                missing.append(i)\n                locs = np.array([-1])\n            indexer.append(locs)\n        indexer = np.concatenate(indexer)\n    else:\n        target_as_index = self._maybe_convert_i8(target_as_index)\n        indexer, missing = self._engine.get_indexer_non_unique(\n            target_as_index.values\n        )\n\n    return ensure_platform_int(indexer), ensure_platform_int(missing)",
                                "signature": "get_indexer_non_unique(self, target: AnyArrayLike) -> Tuple[np.ndarray, np.ndarray]"
                            },
                            {
                                "code": "def get_indexer_for(self, target: AnyArrayLike, **kwargs) -> np.ndarray:\n    \"\"\"\n    Guaranteed return of an indexer even when overlapping.\n\n    This dispatches to get_indexer or get_indexer_non_unique\n    as appropriate.\n\n    Returns\n    -------\n    numpy.ndarray\n        List of indices.\n    \"\"\"\n    if self.is_overlapping:\n        return self.get_indexer_non_unique(target)[0]\n    return self.get_indexer(target, **kwargs)",
                                "signature": "get_indexer_for(self, target: AnyArrayLike, **kwargs) -> np.ndarray"
                            },
                            {
                                "code": "@Appender(_index_shared_docs[\"get_value\"] % _index_doc_kwargs)\ndef get_value(self, series: ABCSeries, key: Any) -> Any:\n\n    if com.is_bool_indexer(key):\n        loc = key\n    elif is_list_like(key):\n        if self.is_overlapping:\n            loc, missing = self.get_indexer_non_unique(key)\n            if len(missing):\n                raise KeyError\n        else:\n            loc = self.get_indexer(key)\n    elif isinstance(key, slice):\n        if not (key.step is None or key.step == 1):\n            raise ValueError(\"cannot support not-default step in a slice\")\n        loc = self._convert_slice_indexer(key, kind=\"getitem\")\n    else:\n        loc = self.get_loc(key)\n    return series.iloc[loc]",
                                "signature": "get_value(self, series: ABCSeries, key: Any) -> Any"
                            },
                            {
                                "code": "@Appender(_index_shared_docs[\"where\"])\ndef where(self, cond, other=None):\n    if other is None:\n        other = self._na_value\n    values = np.where(cond, self.values, other)\n    return self._shallow_copy(values)",
                                "signature": "where(self, cond, other=None)"
                            },
                            {
                                "code": "def delete(self, loc):\n    \"\"\"\n    Return a new IntervalIndex with passed location(-s) deleted\n\n    Returns\n    -------\n    new_index : IntervalIndex\n    \"\"\"\n    new_left = self.left.delete(loc)\n    new_right = self.right.delete(loc)\n    return self._shallow_copy(new_left, new_right)",
                                "signature": "delete(self, loc)"
                            },
                            {
                                "code": "def insert(self, loc, item):\n    \"\"\"\n    Return a new IntervalIndex inserting new item at location. Follows\n    Python list.append semantics for negative values.  Only Interval\n    objects and NA can be inserted into an IntervalIndex\n\n    Parameters\n    ----------\n    loc : int\n    item : object\n\n    Returns\n    -------\n    new_index : IntervalIndex\n    \"\"\"\n    if isinstance(item, Interval):\n        if item.closed != self.closed:\n            raise ValueError(\n                \"inserted item must be closed on the same side as the index\"\n            )\n        left_insert = item.left\n        right_insert = item.right\n    elif is_scalar(item) and isna(item):\n        # GH 18295\n        left_insert = right_insert = item\n    else:\n        raise ValueError(\n            \"can only insert Interval objects and NA into an IntervalIndex\"\n        )\n\n    new_left = self.left.insert(loc, left_insert)\n    new_right = self.right.insert(loc, right_insert)\n    return self._shallow_copy(new_left, new_right)",
                                "signature": "insert(self, loc, item)"
                            },
                            {
                                "code": "def _concat_same_dtype(self, to_concat, name):\n    \"\"\"\n    assert that we all have the same .closed\n    we allow a 0-len index here as well\n    \"\"\"\n    if not len({i.closed for i in to_concat if len(i)}) == 1:\n        msg = (\n            \"can only append two IntervalIndex objects \"\n            \"that are closed on the same side\"\n        )\n        raise ValueError(msg)\n    return super()._concat_same_dtype(to_concat, name)",
                                "signature": "_concat_same_dtype(self, to_concat, name)"
                            },
                            {
                                "code": "@Appender(_index_shared_docs[\"take\"] % _index_doc_kwargs)\ndef take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs):\n    result = self._data.take(\n        indices, axis=axis, allow_fill=allow_fill, fill_value=fill_value, **kwargs\n    )\n    attributes = self._get_attributes_dict()\n    return self._simple_new(result, **attributes)",
                                "signature": "take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs)"
                            },
                            {
                                "code": "def __getitem__(self, value):\n    result = self._data[value]\n    if isinstance(result, IntervalArray):\n        return self._shallow_copy(result)\n    else:\n        # scalar\n        return result",
                                "signature": "__getitem__(self, value)"
                            },
                            {
                                "code": "def _format_with_header(self, header, **kwargs):\n    return header + list(self._format_native_types(**kwargs))",
                                "signature": "_format_with_header(self, header, **kwargs)"
                            },
                            {
                                "code": "def _format_native_types(self, na_rep=\"NaN\", quoting=None, **kwargs):\n    # GH 28210: use base method but with different default na_rep\n    return super()._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)",
                                "signature": "_format_native_types(self, na_rep='NaN', quoting=None, **kwargs)"
                            },
                            {
                                "code": "def _format_data(self, name=None):\n\n    # TODO: integrate with categorical and make generic\n    # name argument is unused here; just for compat with base / categorical\n    n = len(self)\n    max_seq_items = min((get_option(\"display.max_seq_items\") or n) // 10, 10)\n\n    formatter = str\n\n    if n == 0:\n        summary = \"[]\"\n    elif n == 1:\n        first = formatter(self[0])\n        summary = \"[{first}]\".format(first=first)\n    elif n == 2:\n        first = formatter(self[0])\n        last = formatter(self[-1])\n        summary = \"[{first}, {last}]\".format(first=first, last=last)\n    else:\n\n        if n > max_seq_items:\n            n = min(max_seq_items // 2, 10)\n            head = [formatter(x) for x in self[:n]]\n            tail = [formatter(x) for x in self[-n:]]\n            summary = \"[{head} ... {tail}]\".format(\n                head=\", \".join(head), tail=\", \".join(tail)\n            )\n        else:\n            tail = [formatter(x) for x in self]\n            summary = \"[{tail}]\".format(tail=\", \".join(tail))\n\n    return summary + \",\" + self._format_space()",
                                "signature": "_format_data(self, name=None)"
                            },
                            {
                                "code": "def _format_attrs(self):\n    attrs = [(\"closed\", repr(self.closed))]\n    if self.name is not None:\n        attrs.append((\"name\", default_pprint(self.name)))\n    attrs.append((\"dtype\", \"'{dtype}'\".format(dtype=self.dtype)))\n    return attrs",
                                "signature": "_format_attrs(self)"
                            },
                            {
                                "code": "def _format_space(self):\n    space = \" \" * (len(type(self).__name__) + 1)\n    return \"\\n{space}\".format(space=space)",
                                "signature": "_format_space(self)"
                            },
                            {
                                "code": "def argsort(self, *args, **kwargs):\n    return np.lexsort((self.right, self.left))",
                                "signature": "argsort(self, *args, **kwargs)"
                            },
                            {
                                "code": "def equals(self, other) -> bool:\n    \"\"\"\n    Determines if two IntervalIndex objects contain the same elements\n    \"\"\"\n    if self.is_(other):\n        return True\n\n    # if we can coerce to an II\n    # then we can compare\n    if not isinstance(other, IntervalIndex):\n        if not is_interval_dtype(other):\n            return False\n        other = Index(getattr(other, \".values\", other))\n\n    return (\n        self.left.equals(other.left)\n        and self.right.equals(other.right)\n        and self.closed == other.closed\n    )",
                                "signature": "equals(self, other) -> bool"
                            },
                            {
                                "code": "@Appender(\n    _interval_shared_docs[\"contains\"]\n    % dict(\n        klass=\"IntervalIndex\",\n        examples=textwrap.dedent(\n            \"\"\"\\\n    >>> intervals = pd.IntervalIndex.from_tuples([(0, 1), (1, 3), (2, 4)])\n    >>> intervals\n    IntervalIndex([(0, 1], (1, 3], (2, 4]],\n              closed='right',\n              dtype='interval[int64]')\n    >>> intervals.contains(0.5)\n    array([ True, False, False])\n    \"\"\"\n        ),\n    )\n)\ndef contains(self, other):\n    return self._data.contains(other)",
                                "signature": "contains(self, other)"
                            },
                            {
                                "code": "@Appender(\n    _interval_shared_docs[\"overlaps\"]\n    % dict(\n        klass=\"IntervalIndex\",\n        examples=textwrap.dedent(\n            \"\"\"\\\n    >>> intervals = pd.IntervalIndex.from_tuples([(0, 1), (1, 3), (2, 4)])\n    >>> intervals\n    IntervalIndex([(0, 1], (1, 3], (2, 4]],\n          closed='right',\n          dtype='interval[int64]')\n    \"\"\"\n        ),\n    )\n)\ndef overlaps(self, other):\n    return self._data.overlaps(other)",
                                "signature": "overlaps(self, other)"
                            },
                            {
                                "code": "@Appender(_index_shared_docs[\"intersection\"])\n@SetopCheck(op_name=\"intersection\")\ndef intersection(\n    self, other: \"IntervalIndex\", sort: bool = False\n) -> \"IntervalIndex\":\n    if self.left.is_unique and self.right.is_unique:\n        taken = self._intersection_unique(other)\n    elif other.left.is_unique and other.right.is_unique and self.isna().sum() <= 1:\n        # Swap other/self if other is unique and self does not have\n        # multiple NaNs\n        taken = other._intersection_unique(self)\n    else:\n        # duplicates\n        taken = self._intersection_non_unique(other)\n\n    if sort is None:\n        taken = taken.sort_values()\n\n    return taken",
                                "signature": "intersection(self, other: 'IntervalIndex', sort: bool=False) -> 'IntervalIndex'"
                            },
                            {
                                "code": "def _intersection_unique(self, other: \"IntervalIndex\") -> \"IntervalIndex\":\n    \"\"\"\n    Used when the IntervalIndex does not have any common endpoint,\n    no mater left or right.\n    Return the intersection with another IntervalIndex.\n\n    Parameters\n    ----------\n    other : IntervalIndex\n\n    Returns\n    -------\n    taken : IntervalIndex\n    \"\"\"\n    lindexer = self.left.get_indexer(other.left)\n    rindexer = self.right.get_indexer(other.right)\n\n    match = (lindexer == rindexer) & (lindexer != -1)\n    indexer = lindexer.take(match.nonzero()[0])\n\n    return self.take(indexer)",
                                "signature": "_intersection_unique(self, other: 'IntervalIndex') -> 'IntervalIndex'"
                            },
                            {
                                "code": "def _intersection_non_unique(self, other: \"IntervalIndex\") -> \"IntervalIndex\":\n    \"\"\"\n    Used when the IntervalIndex does have some common endpoints,\n    on either sides.\n    Return the intersection with another IntervalIndex.\n\n    Parameters\n    ----------\n    other : IntervalIndex\n\n    Returns\n    -------\n    taken : IntervalIndex\n    \"\"\"\n    mask = np.zeros(len(self), dtype=bool)\n\n    if self.hasnans and other.hasnans:\n        first_nan_loc = np.arange(len(self))[self.isna()][0]\n        mask[first_nan_loc] = True\n\n    other_tups = set(zip(other.left, other.right))\n    for i, tup in enumerate(zip(self.left, self.right)):\n        if tup in other_tups:\n            mask[i] = True\n\n    return self[mask]",
                                "signature": "_intersection_non_unique(self, other: 'IntervalIndex') -> 'IntervalIndex'"
                            },
                            {
                                "code": "def _setop(op_name: str, sort=None):\n    @SetopCheck(op_name=op_name)\n    def func(self, other, sort=sort):\n        result = getattr(self._multiindex, op_name)(other._multiindex, sort=sort)\n        result_name = get_op_result_name(self, other)\n\n        # GH 19101: ensure empty results have correct dtype\n        if result.empty:\n            result = result.values.astype(self.dtype.subtype)\n        else:\n            result = result.values\n\n        return type(self).from_tuples(result, closed=self.closed, name=result_name)\n\n    return func",
                                "signature": "_setop(op_name: str, sort=None)"
                            },
                            {
                                "code": "@property\ndef is_all_dates(self) -> bool:\n    \"\"\"\n    This is False even when left/right contain datetime-like objects,\n    as the check is done on the Interval itself\n    \"\"\"\n    return False",
                                "signature": "is_all_dates(self) -> bool"
                            }
                        ]
                    }
                ]
            },
            "variables_in_file": {
                "_VALID_CLOSED": [
                    432,
                    57
                ],
                "_index_doc_kwargs": [
                    1122,
                    170,
                    1036,
                    909,
                    978,
                    58,
                    60,
                    575
                ],
                "dict": [
                    480,
                    1220,
                    167,
                    250,
                    300,
                    365,
                    908,
                    274,
                    1240,
                    58,
                    412,
                    61
                ],
                "ibase._index_doc_kwargs": [
                    58
                ],
                "ibase": [
                    58
                ],
                "_index_doc_kwargs.update": [
                    60
                ],
                "textwrap.dedent": [
                    65,
                    1222,
                    302,
                    911,
                    174,
                    276,
                    1242,
                    252,
                    414
                ],
                "textwrap": [
                    65,
                    1222,
                    302,
                    911,
                    174,
                    276,
                    1242,
                    252,
                    414
                ],
                "dtype": [
                    97,
                    293,
                    267,
                    76,
                    78,
                    79,
                    81,
                    498,
                    83,
                    501,
                    316,
                    90,
                    92,
                    93,
                    222,
                    95
                ],
                "getattr": [
                    641,
                    90,
                    139,
                    76,
                    1328,
                    1210
                ],
                "label": [
                    96,
                    641,
                    98,
                    802,
                    100,
                    806,
                    808,
                    76,
                    77,
                    80,
                    82,
                    84,
                    86,
                    790,
                    90,
                    91,
                    94
                ],
                "type": [
                    482,
                    100,
                    1190,
                    76,
                    497,
                    86,
                    1337,
                    90
                ],
                "isinstance": [
                    1541,
                    138,
                    662,
                    790,
                    1048,
                    669,
                    811,
                    943,
                    818,
                    1207,
                    1090,
                    712,
                    716,
                    77,
                    1364,
                    1365,
                    985,
                    91,
                    1373,
                    1374,
                    354,
                    996,
                    743,
                    1004,
                    1132,
                    886
                ],
                "Timestamp": [
                    1541,
                    715,
                    77,
                    1364,
                    91,
                    1373
                ],
                "Timedelta": [
                    715,
                    77,
                    1365,
                    91,
                    1374
                ],
                "is_datetime_or_timedelta_dtype": [
                    93,
                    79
                ],
                "is_datetime64tz_dtype": [
                    93,
                    79
                ],
                "np.timedelta64": [
                    80,
                    94
                ],
                "np": [
                    669,
                    1312,
                    930,
                    1315,
                    1060,
                    677,
                    1196,
                    946,
                    565,
                    953,
                    960,
                    840,
                    80,
                    84,
                    469,
                    468,
                    981,
                    94,
                    992,
                    993,
                    98,
                    1005,
                    1006,
                    1009,
                    1011,
                    1020,
                    1535
                ],
                "is_integer_dtype": [
                    671,
                    81,
                    95
                ],
                "is_float_dtype": [
                    97,
                    666,
                    83
                ],
                "np.nextafter": [
                    98,
                    84
                ],
                "np.infty": [
                    98,
                    84
                ],
                "TypeError": [
                    896,
                    100,
                    1516,
                    86,
                    1497,
                    158
                ],
                "repr": [
                    100,
                    86,
                    1183
                ],
                "left": [
                    323,
                    293,
                    745,
                    555,
                    108,
                    748,
                    110,
                    113,
                    337,
                    339,
                    561,
                    565,
                    567
                ],
                "right": [
                    323,
                    293,
                    746,
                    108,
                    556,
                    748,
                    112,
                    113,
                    338,
                    339,
                    561,
                    567
                ],
                "interval.left": [
                    108
                ],
                "interval": [
                    108,
                    109,
                    111
                ],
                "interval.right": [
                    108
                ],
                "interval.open_left": [
                    109
                ],
                "_get_next_label": [
                    802,
                    110
                ],
                "interval.open_right": [
                    111
                ],
                "_get_prev_label": [
                    112,
                    806
                ],
                "cls.from_arrays": [
                    121
                ],
                "cls": [
                    226,
                    291,
                    217,
                    295,
                    265,
                    269,
                    241,
                    121,
                    315,
                    317
                ],
                "d": [
                    480,
                    121,
                    482,
                    481
                ],
                "self.op_name": [
                    140,
                    131,
                    139,
                    158
                ],
                "self": [
                    517,
                    1032,
                    1033,
                    1034,
                    524,
                    1042,
                    1043,
                    532,
                    1047,
                    1051,
                    540,
                    1053,
                    1059,
                    548,
                    1060,
                    1061,
                    555,
                    556,
                    558,
                    1071,
                    1072,
                    1073,
                    577,
                    1091,
                    1105,
                    1106,
                    1107,
                    1124,
                    1127,
                    1128,
                    1131,
                    1133,
                    1143,
                    632,
                    641,
                    1153,
                    131,
                    649,
                    1161,
                    139,
                    140,
                    1164,
                    1165,
                    1171,
                    1172,
                    665,
                    1177,
                    1180,
                    158,
                    1183,
                    1184,
                    1185,
                    1186,
                    1190,
                    1196,
                    1202,
                    691,
                    1213,
                    1214,
                    1215,
                    713,
                    1236,
                    739,
                    1254,
                    745,
                    746,
                    748,
                    1261,
                    1262,
                    1263,
                    1266,
                    1269,
                    762,
                    1290,
                    1291,
                    783,
                    1296,
                    797,
                    798,
                    800,
                    801,
                    1312,
                    1314,
                    804,
                    805,
                    1315,
                    1319,
                    1323,
                    812,
                    815,
                    1328,
                    1329,
                    1333,
                    1337,
                    826,
                    828,
                    830,
                    834,
                    323,
                    324,
                    835,
                    326,
                    331,
                    332,
                    333,
                    337,
                    338,
                    339,
                    358,
                    879,
                    887,
                    889,
                    379,
                    892,
                    893,
                    895,
                    384,
                    392,
                    400,
                    408,
                    932,
                    934,
                    945,
                    946,
                    437,
                    438,
                    950,
                    952,
                    446,
                    958,
                    959,
                    451,
                    963,
                    964,
                    454,
                    971,
                    461,
                    465,
                    469,
                    473,
                    987,
                    989,
                    480,
                    481,
                    482,
                    486,
                    489,
                    1003,
                    493,
                    497,
                    498,
                    500,
                    1013,
                    1014,
                    506
                ],
                "op_name": [
                    1328,
                    131,
                    1326
                ],
                "intvidx_self._assert_can_do_setop": [
                    135
                ],
                "intvidx_self": [
                    160,
                    135,
                    139,
                    141,
                    143,
                    151
                ],
                "other": [
                    135,
                    136,
                    138,
                    139,
                    1290,
                    1291,
                    143,
                    151,
                    160,
                    1058,
                    1059,
                    1060,
                    1314,
                    1318,
                    1328,
                    1329,
                    1202,
                    1207,
                    1208,
                    1210,
                    1213,
                    1214,
                    1215,
                    1236,
                    1254,
                    1262,
                    1263,
                    1266,
                    1269
                ],
                "ensure_index": [
                    136,
                    737,
                    941,
                    982
                ],
                "IntervalIndex": [
                    997,
                    138,
                    747,
                    1356,
                    1548,
                    943,
                    662,
                    1207,
                    985
                ],
                "result": [
                    139,
                    141,
                    142,
                    1328,
                    1332,
                    1333,
                    1335,
                    1337,
                    323,
                    326,
                    477,
                    1124,
                    1128,
                    1131,
                    1132,
                    1133,
                    1136,
                    241,
                    242,
                    243,
                    244,
                    245
                ],
                "intvidx_self.astype": [
                    139
                ],
                "object": [
                    139
                ],
                "result.astype": [
                    141
                ],
                "intvidx_self.dtype": [
                    141,
                    151
                ],
                "intvidx_self.closed": [
                    143
                ],
                "other.closed": [
                    1215,
                    143
                ],
                "msg": [
                    768,
                    777,
                    778,
                    144,
                    148,
                    791,
                    792,
                    154,
                    158,
                    935,
                    939,
                    433,
                    434,
                    1487,
                    1488,
                    1490,
                    1491,
                    1496,
                    1497,
                    1115,
                    1119,
                    763
                ],
                "ValueError": [
                    768,
                    1092,
                    1481,
                    1503,
                    780,
                    1101,
                    1488,
                    434,
                    1491,
                    692,
                    148,
                    1050,
                    1502,
                    1119
                ],
                "subtypes": [
                    152,
                    151
                ],
                "intvidx_self.dtype.subtype": [
                    151
                ],
                "other.dtype.subtype": [
                    151
                ],
                "other.dtype": [
                    151
                ],
                "common_subtype": [
                    949,
                    952,
                    152,
                    153,
                    986,
                    989
                ],
                "find_common_type": [
                    152,
                    986,
                    949
                ],
                "is_object_dtype": [
                    961,
                    996,
                    952,
                    153,
                    989
                ],
                "msg.format": [
                    768,
                    778,
                    1488,
                    434,
                    1491,
                    1497,
                    158
                ],
                "setop": [
                    160
                ],
                "sort": [
                    160,
                    1328,
                    1327,
                    1271
                ],
                "func": [
                    162,
                    1339
                ],
                "IntervalMixin": [
                    241,
                    811,
                    196,
                    790
                ],
                "Index": [
                    513,
                    196,
                    755,
                    1210,
                    380,
                    669
                ],
                "_typ": [
                    197
                ],
                "_comparables": [
                    198
                ],
                "_attributes": [
                    199
                ],
                "_defer_to_indexing": [
                    202
                ],
                "_mask": [
                    205
                ],
                "name": [
                    1120,
                    226,
                    295,
                    490,
                    491,
                    1548,
                    269,
                    243,
                    214,
                    215,
                    317
                ],
                "hasattr": [
                    214
                ],
                "data": [
                    219,
                    316,
                    214,
                    215
                ],
                "data.name": [
                    215
                ],
                "rewrite_exception": [
                    291,
                    265,
                    497,
                    217,
                    315
                ],
                "cls.__name__": [
                    217,
                    291,
                    265,
                    315
                ],
                "array": [
                    226,
                    292,
                    486,
                    295,
                    488,
                    266,
                    269,
                    493,
                    242,
                    437,
                    438,
                    218
                ],
                "IntervalArray": [
                    292,
                    266,
                    1132,
                    218,
                    316
                ],
                "closed": [
                    293,
                    267,
                    1548,
                    432,
                    434,
                    437,
                    316,
                    220
                ],
                "copy": [
                    293,
                    267,
                    498,
                    501,
                    316,
                    221
                ],
                "verify_integrity": [
                    223
                ],
                "cls._simple_new": [
                    226,
                    317,
                    269,
                    295
                ],
                "IntervalMixin.__new__": [
                    241
                ],
                "result._data": [
                    242
                ],
                "result.name": [
                    243
                ],
                "result._reset_identity": [
                    244
                ],
                "classmethod": [
                    297,
                    228,
                    271,
                    247
                ],
                "IntervalArray.from_breaks": [
                    266
                ],
                "breaks": [
                    1538,
                    1546,
                    267,
                    1548,
                    1535
                ],
                "Appender": [
                    513,
                    643,
                    1036,
                    272,
                    410,
                    923,
                    1056,
                    165,
                    298,
                    575,
                    321,
                    1218,
                    978,
                    1238,
                    1122,
                    484,
                    1256,
                    363,
                    495,
                    248,
                    634
                ],
                "_interval_shared_docs": [
                    1219,
                    166,
                    299,
                    364,
                    273,
                    1239,
                    249,
                    411,
                    575
                ],
                "IntervalArray.from_arrays": [
                    292
                ],
                "arr": [
                    316,
                    317
                ],
                "IntervalArray.from_tuples": [
                    316
                ],
                "self._data._shallow_copy": [
                    323
                ],
                "self._data": [
                    392,
                    524,
                    400,
                    408,
                    437,
                    446,
                    577,
                    323,
                    451,
                    461,
                    465,
                    1236,
                    469,
                    1124,
                    486,
                    1254,
                    1131,
                    506,
                    379
                ],
                "attributes": [
                    324,
                    325,
                    326,
                    1127,
                    1128,
                    489,
                    491,
                    493
                ],
                "self._get_attributes_dict": [
                    481,
                    324,
                    489,
                    1127
                ],
                "attributes.update": [
                    491,
                    325
                ],
                "kwargs": [
                    1125,
                    325,
                    1034,
                    1143,
                    1147
                ],
                "self._simple_new": [
                    1128,
                    438,
                    493,
                    326
                ],
                "_index_shared_docs": [
                    1056,
                    321,
                    1122,
                    643,
                    484,
                    1256,
                    1036,
                    495,
                    978,
                    634,
                    923
                ],
                "self._mask": [
                    331,
                    332,
                    333
                ],
                "isna": [
                    1097,
                    332
                ],
                "self.left": [
                    384,
                    517,
                    1290,
                    797,
                    798,
                    804,
                    1319,
                    555,
                    1196,
                    1071,
                    1213,
                    958,
                    454,
                    332,
                    337,
                    1105,
                    480,
                    1261,
                    889,
                    895
                ],
                "cache_readonly": [
                    550,
                    519,
                    328,
                    456,
                    542,
                    574,
                    526,
                    463,
                    335,
                    467,
                    534,
                    503,
                    382
                ],
                "self._maybe_convert_i8": [
                    963,
                    745,
                    746,
                    337,
                    338,
                    1013
                ],
                "self.right": [
                    384,
                    480,
                    800,
                    517,
                    1319,
                    1291,
                    556,
                    1196,
                    1261,
                    1072,
                    338,
                    1106,
                    889,
                    1214,
                    959,
                    895
                ],
                "IntervalTree": [
                    339
                ],
                "self.closed": [
                    1215,
                    1091,
                    748,
                    339,
                    887,
                    952,
                    1337,
                    989,
                    1183
                ],
                "key": [
                    898,
                    902,
                    1039,
                    1040,
                    1041,
                    1043,
                    662,
                    663,
                    1047,
                    1048,
                    1049,
                    667,
                    668,
                    669,
                    670,
                    1051,
                    672,
                    673,
                    1053,
                    675,
                    811,
                    813,
                    816,
                    818,
                    820,
                    821,
                    834,
                    835,
                    712,
                    713,
                    969,
                    971,
                    716,
                    889,
                    735,
                    736,
                    737,
                    354,
                    739,
                    358,
                    742,
                    743,
                    745,
                    746,
                    1001,
                    1003,
                    887,
                    752,
                    755,
                    756,
                    883,
                    884,
                    759,
                    886,
                    888,
                    637,
                    638,
                    895
                ],
                "Interval": [
                    354,
                    1090,
                    743,
                    712,
                    747,
                    886
                ],
                "self.get_loc": [
                    971,
                    1053,
                    358,
                    1003
                ],
                "KeyError": [
                    898,
                    902,
                    360,
                    972,
                    653,
                    1007,
                    784,
                    884,
                    1045,
                    888
                ],
                "bool": [
                    1312,
                    514,
                    1259,
                    1198,
                    527,
                    1359,
                    341,
                    535,
                    1371,
                    1342,
                    543
                ],
                "tuples": [
                    379,
                    380
                ],
                "self._data.to_tuples": [
                    379
                ],
                "na_tuple": [
                    379
                ],
                "MultiIndex.from_arrays": [
                    384
                ],
                "MultiIndex": [
                    384
                ],
                "self._data._left": [
                    392
                ],
                "property": [
                    448,
                    386,
                    579,
                    394,
                    402,
                    440,
                    508,
                    1341
                ],
                "self._data._right": [
                    400
                ],
                "self._data._closed": [
                    408
                ],
                "self._data.set_closed": [
                    437
                ],
                "self.name": [
                    1184,
                    1185,
                    438
                ],
                "self._data.length": [
                    446
                ],
                "self._data.size": [
                    451
                ],
                "len": [
                    992,
                    993,
                    1153,
                    1312,
                    1315,
                    454,
                    1190,
                    946,
                    691,
                    1044,
                    953,
                    1114,
                    828
                ],
                "int": [
                    928,
                    673,
                    514,
                    453,
                    840,
                    1494,
                    1529
                ],
                "np.array": [
                    1009,
                    469,
                    1006
                ],
                "np.ndarray": [
                    930,
                    677,
                    840,
                    468,
                    981,
                    1020,
                    669
                ],
                "self._ndarray_values": [
                    473
                ],
                "d.update": [
                    481
                ],
                "_new_IntervalIndex": [
                    482
                ],
                "deep": [
                    517,
                    487
                ],
                "array.copy": [
                    488
                ],
                "__name__": [
                    497,
                    1190
                ],
                "new_values": [
                    498,
                    499,
                    500
                ],
                "self.values.astype": [
                    498
                ],
                "self.values": [
                    498,
                    1060
                ],
                "is_interval_dtype": [
                    712,
                    499,
                    1208,
                    743
                ],
                "self._shallow_copy": [
                    1061,
                    1133,
                    1073,
                    1107,
                    500
                ],
                "new_values.left": [
                    500
                ],
                "new_values.right": [
                    500
                ],
                "astype": [
                    501
                ],
                "super": [
                    1120,
                    637,
                    1147,
                    501
                ],
                "self._data.dtype": [
                    506
                ],
                "str": [
                    1156,
                    839,
                    1325,
                    509,
                    927
                ],
                "self.left.memory_usage": [
                    517
                ],
                "self.right.memory_usage": [
                    517
                ],
                "Index.memory_usage.__doc__": [
                    513
                ],
                "Index.memory_usage": [
                    513
                ],
                "self._data.mid": [
                    524
                ],
                "self.is_monotonic_increasing": [
                    532
                ],
                "self._engine.is_monotonic_increasing": [
                    540
                ],
                "self._engine": [
                    632,
                    964,
                    540,
                    1014
                ],
                "is_monotonic_increasing": [
                    548
                ],
                "sum": [
                    558,
                    1263
                ],
                "self.isna": [
                    1315,
                    558,
                    1263
                ],
                "left.is_unique": [
                    561
                ],
                "right.is_unique": [
                    561
                ],
                "seen_pairs": [
                    568,
                    570,
                    564
                ],
                "set": [
                    564,
                    1318
                ],
                "check_idx": [
                    565,
                    566
                ],
                "np.where": [
                    960,
                    1060,
                    565
                ],
                "left.duplicated": [
                    565
                ],
                "idx": [
                    566,
                    567
                ],
                "pair": [
                    568,
                    570,
                    567
                ],
                "seen_pairs.add": [
                    570
                ],
                "self._data.is_non_overlapping_monotonic": [
                    577
                ],
                "self._engine.is_overlapping": [
                    632
                ],
                "kind": [
                    641,
                    636,
                    637
                ],
                "_convert_scalar_indexer": [
                    637
                ],
                "_maybe_cast_slice_bound": [
                    641
                ],
                "side": [
                    808,
                    641,
                    797,
                    798
                ],
                "locs": [
                    649,
                    1003,
                    652,
                    1004,
                    1005,
                    655,
                    1006,
                    1009,
                    1010
                ],
                "self.get_indexer_for": [
                    649
                ],
                "keyarr": [
                    649
                ],
                "any": [
                    1361,
                    652
                ],
                "subtype": [
                    768,
                    762,
                    671,
                    665,
                    666,
                    767
                ],
                "self.dtype.subtype": [
                    1333,
                    950,
                    665,
                    762,
                    987
                ],
                "self.dtype": [
                    1186,
                    1333,
                    950,
                    665,
                    762,
                    987
                ],
                "is_integer": [
                    672,
                    1536,
                    667,
                    1495
                ],
                "float": [
                    668
                ],
                "key.astype": [
                    670
                ],
                "self.is_overlapping": [
                    1032,
                    1042,
                    691,
                    934
                ],
                "indexer": [
                    960,
                    964,
                    968,
                    1000,
                    974,
                    1294,
                    976,
                    1296,
                    1010,
                    691,
                    1011,
                    1014,
                    1018
                ],
                "self._needs_i8_conversion": [
                    713,
                    739
                ],
                "key.left": [
                    713,
                    813,
                    745,
                    889
                ],
                "i8_types": [
                    715,
                    716
                ],
                "DatetimeIndex": [
                    715
                ],
                "TimedeltaIndex": [
                    715
                ],
                "original": [
                    740,
                    735
                ],
                "is_list_like": [
                    736,
                    1041,
                    883
                ],
                "scalar": [
                    747,
                    742,
                    750
                ],
                "is_scalar": [
                    1097,
                    742
                ],
                "key.right": [
                    816,
                    889,
                    746
                ],
                "constructor": [
                    747,
                    748
                ],
                "IntervalIndex.from_arrays": [
                    747
                ],
                "key_dtype": [
                    752,
                    768,
                    755,
                    767
                ],
                "key_i8": [
                    752,
                    770,
                    755,
                    759
                ],
                "infer_dtype_from_scalar": [
                    752
                ],
                "key.dtype": [
                    755
                ],
                "key.asi8": [
                    755
                ],
                "key.hasnans": [
                    756
                ],
                "key_i8.where": [
                    759
                ],
                "key._isnan": [
                    759
                ],
                "is_dtype_equal": [
                    767
                ],
                "method": [
                    932,
                    773,
                    776,
                    778,
                    879
                ],
                "NotImplementedError": [
                    792,
                    778,
                    822
                ],
                "self.is_non_overlapping_monotonic": [
                    783
                ],
                "self.left.is_monotonic_increasing": [
                    797,
                    798
                ],
                "sub_idx": [
                    800,
                    808,
                    804
                ],
                "self.open_right": [
                    801
                ],
                "exclude_label": [
                    801,
                    805
                ],
                "self.open_left": [
                    805
                ],
                "sub_idx._searchsorted_monotonic": [
                    808
                ],
                "start": [
                    1536,
                    1546,
                    812,
                    820,
                    823,
                    824,
                    826,
                    1473,
                    834,
                    1475,
                    836,
                    1477,
                    1480,
                    1486,
                    1488,
                    1511,
                    1512,
                    1524,
                    1525,
                    1529,
                    1530,
                    1531,
                    1533,
                    1535
                ],
                "self._searchsorted_monotonic": [
                    834,
                    835,
                    812,
                    815,
                    826,
                    830
                ],
                "key.open_left": [
                    813
                ],
                "stop": [
                    835,
                    836,
                    815,
                    820,
                    827,
                    828,
                    830
                ],
                "key.open_right": [
                    816
                ],
                "slice": [
                    840,
                    1048,
                    818,
                    1004
                ],
                "key.start": [
                    820
                ],
                "key.stop": [
                    820
                ],
                "key.step": [
                    1049,
                    821
                ],
                "Any": [
                    929,
                    1037,
                    839
                ],
                "Optional": [
                    927,
                    929,
                    928,
                    839
                ],
                "self._check_method": [
                    932,
                    879
                ],
                "key.closed": [
                    887
                ],
                "mask": [
                    1312,
                    900,
                    1316,
                    904,
                    905,
                    1321,
                    1323,
                    889,
                    895
                ],
                "op_left": [
                    892,
                    895
                ],
                "self.closed_left": [
                    892
                ],
                "le": [
                    892,
                    893
                ],
                "lt": [
                    892,
                    893
                ],
                "op_right": [
                    893,
                    895
                ],
                "self.closed_right": [
                    893
                ],
                "matches": [
                    900,
                    901,
                    903
                ],
                "mask.sum": [
                    900
                ],
                "mask.argmax": [
                    904
                ],
                "lib.maybe_booleans_to_slice": [
                    905
                ],
                "lib": [
                    905
                ],
                "mask.view": [
                    905
                ],
                "Union": [
                    840
                ],
                "AnyArrayLike": [
                    980,
                    1020,
                    926
                ],
                "InvalidIndexError": [
                    939
                ],
                "target_as_index": [
                    941,
                    943,
                    945,
                    950,
                    952,
                    953,
                    958,
                    959,
                    961,
                    963,
                    964,
                    969,
                    982,
                    985,
                    987,
                    989,
                    992,
                    993,
                    996,
                    997,
                    1001,
                    1013,
                    1015
                ],
                "target": [
                    1033,
                    1034,
                    941,
                    982
                ],
                "self.equals": [
                    945
                ],
                "np.arange": [
                    993,
                    946,
                    1315,
                    1005
                ],
                "target_as_index.dtype.subtype": [
                    987,
                    950
                ],
                "target_as_index.dtype": [
                    987,
                    950
                ],
                "target_as_index.closed": [
                    952,
                    989
                ],
                "np.repeat": [
                    992,
                    953
                ],
                "np.intp": [
                    953
                ],
                "left_indexer": [
                    960,
                    958
                ],
                "self.left.get_indexer": [
                    1290,
                    958
                ],
                "target_as_index.left": [
                    958
                ],
                "right_indexer": [
                    960,
                    959
                ],
                "self.right.get_indexer": [
                    1291,
                    959
                ],
                "target_as_index.right": [
                    959
                ],
                "self._engine.get_indexer": [
                    964
                ],
                "target_as_index.values": [
                    964,
                    1015
                ],
                "loc": [
                    971,
                    973,
                    974,
                    1071,
                    1040,
                    1072,
                    1105,
                    1043,
                    1106,
                    1047,
                    1051,
                    1053,
                    1054
                ],
                "indexer.append": [
                    1010,
                    974
                ],
                "ensure_platform_int": [
                    976,
                    1018
                ],
                "Substitution": [
                    907
                ],
                "missing": [
                    1000,
                    1008,
                    1043,
                    1044,
                    1014,
                    1018
                ],
                "i": [
                    1319,
                    1001,
                    1321,
                    1008,
                    1114
                ],
                "enumerate": [
                    1001,
                    1319
                ],
                "locs.start": [
                    1005
                ],
                "locs.stop": [
                    1005
                ],
                "locs.step": [
                    1005
                ],
                "missing.append": [
                    1008
                ],
                "np.concatenate": [
                    1011
                ],
                "self._engine.get_indexer_non_unique": [
                    1014
                ],
                "Tuple": [
                    981
                ],
                "self.get_indexer_non_unique": [
                    1033,
                    1043
                ],
                "self.get_indexer": [
                    1034,
                    1047
                ],
                "ABCSeries": [
                    1037
                ],
                "com.is_bool_indexer": [
                    1039
                ],
                "com": [
                    1536,
                    1473,
                    1474,
                    1379,
                    1477,
                    1480,
                    1039,
                    1524
                ],
                "self._convert_slice_indexer": [
                    1051
                ],
                "series.iloc": [
                    1054
                ],
                "series": [
                    1054
                ],
                "self._na_value": [
                    1059
                ],
                "values": [
                    1060,
                    1061
                ],
                "cond": [
                    1060
                ],
                "new_left": [
                    1105,
                    1073,
                    1107,
                    1071
                ],
                "self.left.delete": [
                    1071
                ],
                "new_right": [
                    1072,
                    1073,
                    1106,
                    1107
                ],
                "self.right.delete": [
                    1072
                ],
                "item": [
                    1090,
                    1091,
                    1095,
                    1096,
                    1097,
                    1099
                ],
                "item.closed": [
                    1091
                ],
                "left_insert": [
                    1105,
                    1099,
                    1095
                ],
                "item.left": [
                    1095
                ],
                "right_insert": [
                    1096,
                    1106,
                    1099
                ],
                "item.right": [
                    1096
                ],
                "self.left.insert": [
                    1105
                ],
                "self.right.insert": [
                    1106
                ],
                "i.closed": [
                    1114
                ],
                "to_concat": [
                    1120,
                    1114
                ],
                "_concat_same_dtype": [
                    1120
                ],
                "self._data.take": [
                    1124
                ],
                "indices": [
                    1125
                ],
                "axis": [
                    1125
                ],
                "allow_fill": [
                    1125
                ],
                "fill_value": [
                    1125
                ],
                "value": [
                    1131
                ],
                "header": [
                    1143
                ],
                "list": [
                    1143
                ],
                "self._format_native_types": [
                    1143
                ],
                "_format_native_types": [
                    1147
                ],
                "na_rep": [
                    1147
                ],
                "quoting": [
                    1147
                ],
                "n": [
                    1153,
                    1154,
                    1158,
                    1160,
                    1163,
                    1169,
                    1170,
                    1171,
                    1172
                ],
                "max_seq_items": [
                    1169,
                    1154,
                    1170
                ],
                "min": [
                    1154,
                    1170
                ],
                "get_option": [
                    1154
                ],
                "formatter": [
                    1156,
                    1161,
                    1164,
                    1165,
                    1171,
                    1172,
                    1177
                ],
                "summary": [
                    1159,
                    1162,
                    1166,
                    1173,
                    1178,
                    1180
                ],
                "first": [
                    1161,
                    1162,
                    1164,
                    1166
                ],
                "format": [
                    1504,
                    1186,
                    1191,
                    1162,
                    1166,
                    1173,
                    1178
                ],
                "last": [
                    1165,
                    1166
                ],
                "head": [
                    1171,
                    1174
                ],
                "x": [
                    1536,
                    1171,
                    1172,
                    1177,
                    1373,
                    1374
                ],
                "tail": [
                    1177,
                    1178,
                    1172,
                    1174
                ],
                "join": [
                    1178,
                    1174
                ],
                "self._format_space": [
                    1180
                ],
                "attrs": [
                    1185,
                    1186,
                    1187,
                    1183
                ],
                "attrs.append": [
                    1185,
                    1186
                ],
                "default_pprint": [
                    1185
                ],
                "space": [
                    1190,
                    1191
                ],
                "np.lexsort": [
                    1196
                ],
                "self.is_": [
                    1202
                ],
                "self.left.equals": [
                    1213
                ],
                "other.left": [
                    1290,
                    1213,
                    1318,
                    1263
                ],
                "self.right.equals": [
                    1214
                ],
                "other.right": [
                    1318,
                    1291,
                    1214,
                    1263
                ],
                "self._data.contains": [
                    1236
                ],
                "self._data.overlaps": [
                    1254
                ],
                "self.left.is_unique": [
                    1261
                ],
                "self.right.is_unique": [
                    1261
                ],
                "taken": [
                    1262,
                    1266,
                    1269,
                    1272,
                    1274
                ],
                "self._intersection_unique": [
                    1262
                ],
                "other.left.is_unique": [
                    1263
                ],
                "other.right.is_unique": [
                    1263
                ],
                "other._intersection_unique": [
                    1266
                ],
                "self._intersection_non_unique": [
                    1269
                ],
                "taken.sort_values": [
                    1272
                ],
                "SetopCheck": [
                    1257,
                    1326
                ],
                "lindexer": [
                    1290,
                    1293,
                    1294
                ],
                "rindexer": [
                    1291,
                    1293
                ],
                "match": [
                    1293,
                    1294
                ],
                "lindexer.take": [
                    1294
                ],
                "match.nonzero": [
                    1294
                ],
                "self.take": [
                    1296
                ],
                "np.zeros": [
                    1312
                ],
                "self.hasnans": [
                    1314
                ],
                "other.hasnans": [
                    1314
                ],
                "first_nan_loc": [
                    1315,
                    1316
                ],
                "other_tups": [
                    1320,
                    1318
                ],
                "zip": [
                    1318,
                    1319
                ],
                "tup": [
                    1320,
                    1319
                ],
                "self._multiindex": [
                    1328
                ],
                "other._multiindex": [
                    1328
                ],
                "result_name": [
                    1329,
                    1337
                ],
                "get_op_result_name": [
                    1329
                ],
                "result.empty": [
                    1332
                ],
                "result.values.astype": [
                    1333
                ],
                "result.values": [
                    1333,
                    1335
                ],
                "from_tuples": [
                    1337
                ],
                "union": [
                    1349
                ],
                "_setop": [
                    1349,
                    1350,
                    1351
                ],
                "difference": [
                    1350
                ],
                "symmetric_difference": [
                    1351
                ],
                "IntervalIndex._add_logical_methods_disabled": [
                    1356
                ],
                "is_number": [
                    1376,
                    1478,
                    1522,
                    1363,
                    1499
                ],
                "endpoint": [
                    1475,
                    1541,
                    1478,
                    1522,
                    1363,
                    1364,
                    1365,
                    1366
                ],
                "is_ts_compat": [
                    1377,
                    1373
                ],
                "DateOffset": [
                    1373,
                    1374
                ],
                "is_td_compat": [
                    1378,
                    1374
                ],
                "a": [
                    1376,
                    1377,
                    1378,
                    1379
                ],
                "b": [
                    1376,
                    1377,
                    1378,
                    1379
                ],
                "com.any_none": [
                    1379,
                    1477
                ],
                "com.maybe_box_datetimelike": [
                    1473,
                    1474
                ],
                "end": [
                    1536,
                    1474,
                    1475,
                    1477,
                    1511,
                    1480,
                    1513,
                    1546,
                    1489,
                    1491,
                    1524,
                    1525,
                    1529,
                    1531,
                    1532,
                    1533,
                    1535
                ],
                "freq": [
                    1536,
                    1505,
                    1533,
                    1477,
                    1478,
                    1480,
                    1512,
                    1513,
                    1546,
                    1524,
                    1525,
                    1531,
                    1529,
                    1499,
                    1501
                ],
                "periods": [
                    1477,
                    1480,
                    1546,
                    1529,
                    1519,
                    1520,
                    1493,
                    1494,
                    1495,
                    1528,
                    1497,
                    1531,
                    1533,
                    1535
                ],
                "com.count_not_none": [
                    1480
                ],
                "_is_valid_endpoint": [
                    1489,
                    1486
                ],
                "is_float": [
                    1493
                ],
                "to_offset": [
                    1501
                ],
                "all": [
                    1536,
                    1509
                ],
                "_is_type_compatible": [
                    1512,
                    1513,
                    1511
                ],
                "com.all_not_none": [
                    1524
                ],
                "np.linspace": [
                    1535
                ],
                "com.not_none": [
                    1536
                ],
                "maybe_downcast_to_dtype": [
                    1538
                ],
                "range_func": [
                    1544,
                    1546,
                    1542
                ],
                "date_range": [
                    1542
                ],
                "timedelta_range": [
                    1544
                ],
                "IntervalIndex.from_breaks": [
                    1548
                ]
            },
            "filtered_variables_in_file": {
                "_VALID_CLOSED": [
                    432,
                    57
                ],
                "_index_doc_kwargs": [
                    1122,
                    170,
                    1036,
                    909,
                    978,
                    58,
                    60,
                    575
                ],
                "ibase._index_doc_kwargs": [
                    58
                ],
                "ibase": [
                    58
                ],
                "_index_doc_kwargs.update": [
                    60
                ],
                "textwrap.dedent": [
                    65,
                    1222,
                    302,
                    911,
                    174,
                    276,
                    1242,
                    252,
                    414
                ],
                "textwrap": [
                    65,
                    1222,
                    302,
                    911,
                    174,
                    276,
                    1242,
                    252,
                    414
                ],
                "dtype": [
                    97,
                    293,
                    267,
                    76,
                    78,
                    79,
                    81,
                    498,
                    83,
                    501,
                    316,
                    90,
                    92,
                    93,
                    222,
                    95
                ],
                "label": [
                    96,
                    641,
                    98,
                    802,
                    100,
                    806,
                    808,
                    76,
                    77,
                    80,
                    82,
                    84,
                    86,
                    790,
                    90,
                    91,
                    94
                ],
                "Timestamp": [
                    1541,
                    715,
                    77,
                    1364,
                    91,
                    1373
                ],
                "Timedelta": [
                    715,
                    77,
                    1365,
                    91,
                    1374
                ],
                "is_datetime_or_timedelta_dtype": [
                    93,
                    79
                ],
                "is_datetime64tz_dtype": [
                    93,
                    79
                ],
                "np.timedelta64": [
                    80,
                    94
                ],
                "np": [
                    669,
                    1312,
                    930,
                    1315,
                    1060,
                    677,
                    1196,
                    946,
                    565,
                    953,
                    960,
                    840,
                    80,
                    84,
                    469,
                    468,
                    981,
                    94,
                    992,
                    993,
                    98,
                    1005,
                    1006,
                    1009,
                    1011,
                    1020,
                    1535
                ],
                "is_integer_dtype": [
                    671,
                    81,
                    95
                ],
                "is_float_dtype": [
                    97,
                    666,
                    83
                ],
                "np.nextafter": [
                    98,
                    84
                ],
                "np.infty": [
                    98,
                    84
                ],
                "left": [
                    323,
                    293,
                    745,
                    555,
                    108,
                    748,
                    110,
                    113,
                    337,
                    339,
                    561,
                    565,
                    567
                ],
                "right": [
                    323,
                    293,
                    746,
                    108,
                    556,
                    748,
                    112,
                    113,
                    338,
                    339,
                    561,
                    567
                ],
                "interval.left": [
                    108
                ],
                "interval": [
                    108,
                    109,
                    111
                ],
                "interval.right": [
                    108
                ],
                "interval.open_left": [
                    109
                ],
                "_get_next_label": [
                    802,
                    110
                ],
                "interval.open_right": [
                    111
                ],
                "_get_prev_label": [
                    112,
                    806
                ],
                "cls.from_arrays": [
                    121
                ],
                "cls": [
                    226,
                    291,
                    217,
                    295,
                    265,
                    269,
                    241,
                    121,
                    315,
                    317
                ],
                "d": [
                    480,
                    121,
                    482,
                    481
                ],
                "self.op_name": [
                    140,
                    131,
                    139,
                    158
                ],
                "self": [
                    517,
                    1032,
                    1033,
                    1034,
                    524,
                    1042,
                    1043,
                    532,
                    1047,
                    1051,
                    540,
                    1053,
                    1059,
                    548,
                    1060,
                    1061,
                    555,
                    556,
                    558,
                    1071,
                    1072,
                    1073,
                    577,
                    1091,
                    1105,
                    1106,
                    1107,
                    1124,
                    1127,
                    1128,
                    1131,
                    1133,
                    1143,
                    632,
                    641,
                    1153,
                    131,
                    649,
                    1161,
                    139,
                    140,
                    1164,
                    1165,
                    1171,
                    1172,
                    665,
                    1177,
                    1180,
                    158,
                    1183,
                    1184,
                    1185,
                    1186,
                    1190,
                    1196,
                    1202,
                    691,
                    1213,
                    1214,
                    1215,
                    713,
                    1236,
                    739,
                    1254,
                    745,
                    746,
                    748,
                    1261,
                    1262,
                    1263,
                    1266,
                    1269,
                    762,
                    1290,
                    1291,
                    783,
                    1296,
                    797,
                    798,
                    800,
                    801,
                    1312,
                    1314,
                    804,
                    805,
                    1315,
                    1319,
                    1323,
                    812,
                    815,
                    1328,
                    1329,
                    1333,
                    1337,
                    826,
                    828,
                    830,
                    834,
                    323,
                    324,
                    835,
                    326,
                    331,
                    332,
                    333,
                    337,
                    338,
                    339,
                    358,
                    879,
                    887,
                    889,
                    379,
                    892,
                    893,
                    895,
                    384,
                    392,
                    400,
                    408,
                    932,
                    934,
                    945,
                    946,
                    437,
                    438,
                    950,
                    952,
                    446,
                    958,
                    959,
                    451,
                    963,
                    964,
                    454,
                    971,
                    461,
                    465,
                    469,
                    473,
                    987,
                    989,
                    480,
                    481,
                    482,
                    486,
                    489,
                    1003,
                    493,
                    497,
                    498,
                    500,
                    1013,
                    1014,
                    506
                ],
                "op_name": [
                    1328,
                    131,
                    1326
                ],
                "intvidx_self._assert_can_do_setop": [
                    135
                ],
                "intvidx_self": [
                    160,
                    135,
                    139,
                    141,
                    143,
                    151
                ],
                "other": [
                    135,
                    136,
                    138,
                    139,
                    1290,
                    1291,
                    143,
                    151,
                    160,
                    1058,
                    1059,
                    1060,
                    1314,
                    1318,
                    1328,
                    1329,
                    1202,
                    1207,
                    1208,
                    1210,
                    1213,
                    1214,
                    1215,
                    1236,
                    1254,
                    1262,
                    1263,
                    1266,
                    1269
                ],
                "ensure_index": [
                    136,
                    737,
                    941,
                    982
                ],
                "IntervalIndex": [
                    997,
                    138,
                    747,
                    1356,
                    1548,
                    943,
                    662,
                    1207,
                    985
                ],
                "result": [
                    139,
                    141,
                    142,
                    1328,
                    1332,
                    1333,
                    1335,
                    1337,
                    323,
                    326,
                    477,
                    1124,
                    1128,
                    1131,
                    1132,
                    1133,
                    1136,
                    241,
                    242,
                    243,
                    244,
                    245
                ],
                "intvidx_self.astype": [
                    139
                ],
                "result.astype": [
                    141
                ],
                "intvidx_self.dtype": [
                    141,
                    151
                ],
                "intvidx_self.closed": [
                    143
                ],
                "other.closed": [
                    1215,
                    143
                ],
                "msg": [
                    768,
                    777,
                    778,
                    144,
                    148,
                    791,
                    792,
                    154,
                    158,
                    935,
                    939,
                    433,
                    434,
                    1487,
                    1488,
                    1490,
                    1491,
                    1496,
                    1497,
                    1115,
                    1119,
                    763
                ],
                "subtypes": [
                    152,
                    151
                ],
                "intvidx_self.dtype.subtype": [
                    151
                ],
                "other.dtype.subtype": [
                    151
                ],
                "other.dtype": [
                    151
                ],
                "common_subtype": [
                    949,
                    952,
                    152,
                    153,
                    986,
                    989
                ],
                "find_common_type": [
                    152,
                    986,
                    949
                ],
                "is_object_dtype": [
                    961,
                    996,
                    952,
                    153,
                    989
                ],
                "msg.format": [
                    768,
                    778,
                    1488,
                    434,
                    1491,
                    1497,
                    158
                ],
                "setop": [
                    160
                ],
                "sort": [
                    160,
                    1328,
                    1327,
                    1271
                ],
                "func": [
                    162,
                    1339
                ],
                "IntervalMixin": [
                    241,
                    811,
                    196,
                    790
                ],
                "Index": [
                    513,
                    196,
                    755,
                    1210,
                    380,
                    669
                ],
                "_typ": [
                    197
                ],
                "_comparables": [
                    198
                ],
                "_attributes": [
                    199
                ],
                "_defer_to_indexing": [
                    202
                ],
                "_mask": [
                    205
                ],
                "name": [
                    1120,
                    226,
                    295,
                    490,
                    491,
                    1548,
                    269,
                    243,
                    214,
                    215,
                    317
                ],
                "data": [
                    219,
                    316,
                    214,
                    215
                ],
                "data.name": [
                    215
                ],
                "rewrite_exception": [
                    291,
                    265,
                    497,
                    217,
                    315
                ],
                "cls.__name__": [
                    217,
                    291,
                    265,
                    315
                ],
                "array": [
                    226,
                    292,
                    486,
                    295,
                    488,
                    266,
                    269,
                    493,
                    242,
                    437,
                    438,
                    218
                ],
                "IntervalArray": [
                    292,
                    266,
                    1132,
                    218,
                    316
                ],
                "closed": [
                    293,
                    267,
                    1548,
                    432,
                    434,
                    437,
                    316,
                    220
                ],
                "copy": [
                    293,
                    267,
                    498,
                    501,
                    316,
                    221
                ],
                "verify_integrity": [
                    223
                ],
                "cls._simple_new": [
                    226,
                    317,
                    269,
                    295
                ],
                "IntervalMixin.__new__": [
                    241
                ],
                "result._data": [
                    242
                ],
                "result.name": [
                    243
                ],
                "result._reset_identity": [
                    244
                ],
                "IntervalArray.from_breaks": [
                    266
                ],
                "breaks": [
                    1538,
                    1546,
                    267,
                    1548,
                    1535
                ],
                "Appender": [
                    513,
                    643,
                    1036,
                    272,
                    410,
                    923,
                    1056,
                    165,
                    298,
                    575,
                    321,
                    1218,
                    978,
                    1238,
                    1122,
                    484,
                    1256,
                    363,
                    495,
                    248,
                    634
                ],
                "_interval_shared_docs": [
                    1219,
                    166,
                    299,
                    364,
                    273,
                    1239,
                    249,
                    411,
                    575
                ],
                "IntervalArray.from_arrays": [
                    292
                ],
                "arr": [
                    316,
                    317
                ],
                "IntervalArray.from_tuples": [
                    316
                ],
                "self._data._shallow_copy": [
                    323
                ],
                "self._data": [
                    392,
                    524,
                    400,
                    408,
                    437,
                    446,
                    577,
                    323,
                    451,
                    461,
                    465,
                    1236,
                    469,
                    1124,
                    486,
                    1254,
                    1131,
                    506,
                    379
                ],
                "attributes": [
                    324,
                    325,
                    326,
                    1127,
                    1128,
                    489,
                    491,
                    493
                ],
                "self._get_attributes_dict": [
                    481,
                    324,
                    489,
                    1127
                ],
                "attributes.update": [
                    491,
                    325
                ],
                "kwargs": [
                    1125,
                    325,
                    1034,
                    1143,
                    1147
                ],
                "self._simple_new": [
                    1128,
                    438,
                    493,
                    326
                ],
                "_index_shared_docs": [
                    1056,
                    321,
                    1122,
                    643,
                    484,
                    1256,
                    1036,
                    495,
                    978,
                    634,
                    923
                ],
                "self._mask": [
                    331,
                    332,
                    333
                ],
                "isna": [
                    1097,
                    332
                ],
                "self.left": [
                    384,
                    517,
                    1290,
                    797,
                    798,
                    804,
                    1319,
                    555,
                    1196,
                    1071,
                    1213,
                    958,
                    454,
                    332,
                    337,
                    1105,
                    480,
                    1261,
                    889,
                    895
                ],
                "cache_readonly": [
                    550,
                    519,
                    328,
                    456,
                    542,
                    574,
                    526,
                    463,
                    335,
                    467,
                    534,
                    503,
                    382
                ],
                "self._maybe_convert_i8": [
                    963,
                    745,
                    746,
                    337,
                    338,
                    1013
                ],
                "self.right": [
                    384,
                    480,
                    800,
                    517,
                    1319,
                    1291,
                    556,
                    1196,
                    1261,
                    1072,
                    338,
                    1106,
                    889,
                    1214,
                    959,
                    895
                ],
                "IntervalTree": [
                    339
                ],
                "self.closed": [
                    1215,
                    1091,
                    748,
                    339,
                    887,
                    952,
                    1337,
                    989,
                    1183
                ],
                "key": [
                    898,
                    902,
                    1039,
                    1040,
                    1041,
                    1043,
                    662,
                    663,
                    1047,
                    1048,
                    1049,
                    667,
                    668,
                    669,
                    670,
                    1051,
                    672,
                    673,
                    1053,
                    675,
                    811,
                    813,
                    816,
                    818,
                    820,
                    821,
                    834,
                    835,
                    712,
                    713,
                    969,
                    971,
                    716,
                    889,
                    735,
                    736,
                    737,
                    354,
                    739,
                    358,
                    742,
                    743,
                    745,
                    746,
                    1001,
                    1003,
                    887,
                    752,
                    755,
                    756,
                    883,
                    884,
                    759,
                    886,
                    888,
                    637,
                    638,
                    895
                ],
                "Interval": [
                    354,
                    1090,
                    743,
                    712,
                    747,
                    886
                ],
                "self.get_loc": [
                    971,
                    1053,
                    358,
                    1003
                ],
                "tuples": [
                    379,
                    380
                ],
                "self._data.to_tuples": [
                    379
                ],
                "na_tuple": [
                    379
                ],
                "MultiIndex.from_arrays": [
                    384
                ],
                "MultiIndex": [
                    384
                ],
                "self._data._left": [
                    392
                ],
                "self._data._right": [
                    400
                ],
                "self._data._closed": [
                    408
                ],
                "self._data.set_closed": [
                    437
                ],
                "self.name": [
                    1184,
                    1185,
                    438
                ],
                "self._data.length": [
                    446
                ],
                "self._data.size": [
                    451
                ],
                "np.array": [
                    1009,
                    469,
                    1006
                ],
                "np.ndarray": [
                    930,
                    677,
                    840,
                    468,
                    981,
                    1020,
                    669
                ],
                "self._ndarray_values": [
                    473
                ],
                "d.update": [
                    481
                ],
                "_new_IntervalIndex": [
                    482
                ],
                "deep": [
                    517,
                    487
                ],
                "array.copy": [
                    488
                ],
                "new_values": [
                    498,
                    499,
                    500
                ],
                "self.values.astype": [
                    498
                ],
                "self.values": [
                    498,
                    1060
                ],
                "is_interval_dtype": [
                    712,
                    499,
                    1208,
                    743
                ],
                "self._shallow_copy": [
                    1061,
                    1133,
                    1073,
                    1107,
                    500
                ],
                "new_values.left": [
                    500
                ],
                "new_values.right": [
                    500
                ],
                "astype": [
                    501
                ],
                "self._data.dtype": [
                    506
                ],
                "self.left.memory_usage": [
                    517
                ],
                "self.right.memory_usage": [
                    517
                ],
                "Index.memory_usage.__doc__": [
                    513
                ],
                "Index.memory_usage": [
                    513
                ],
                "self._data.mid": [
                    524
                ],
                "self.is_monotonic_increasing": [
                    532
                ],
                "self._engine.is_monotonic_increasing": [
                    540
                ],
                "self._engine": [
                    632,
                    964,
                    540,
                    1014
                ],
                "is_monotonic_increasing": [
                    548
                ],
                "self.isna": [
                    1315,
                    558,
                    1263
                ],
                "left.is_unique": [
                    561
                ],
                "right.is_unique": [
                    561
                ],
                "seen_pairs": [
                    568,
                    570,
                    564
                ],
                "check_idx": [
                    565,
                    566
                ],
                "np.where": [
                    960,
                    1060,
                    565
                ],
                "left.duplicated": [
                    565
                ],
                "idx": [
                    566,
                    567
                ],
                "pair": [
                    568,
                    570,
                    567
                ],
                "seen_pairs.add": [
                    570
                ],
                "self._data.is_non_overlapping_monotonic": [
                    577
                ],
                "self._engine.is_overlapping": [
                    632
                ],
                "kind": [
                    641,
                    636,
                    637
                ],
                "_convert_scalar_indexer": [
                    637
                ],
                "_maybe_cast_slice_bound": [
                    641
                ],
                "side": [
                    808,
                    641,
                    797,
                    798
                ],
                "locs": [
                    649,
                    1003,
                    652,
                    1004,
                    1005,
                    655,
                    1006,
                    1009,
                    1010
                ],
                "self.get_indexer_for": [
                    649
                ],
                "keyarr": [
                    649
                ],
                "subtype": [
                    768,
                    762,
                    671,
                    665,
                    666,
                    767
                ],
                "self.dtype.subtype": [
                    1333,
                    950,
                    665,
                    762,
                    987
                ],
                "self.dtype": [
                    1186,
                    1333,
                    950,
                    665,
                    762,
                    987
                ],
                "is_integer": [
                    672,
                    1536,
                    667,
                    1495
                ],
                "key.astype": [
                    670
                ],
                "self.is_overlapping": [
                    1032,
                    1042,
                    691,
                    934
                ],
                "indexer": [
                    960,
                    964,
                    968,
                    1000,
                    974,
                    1294,
                    976,
                    1296,
                    1010,
                    691,
                    1011,
                    1014,
                    1018
                ],
                "self._needs_i8_conversion": [
                    713,
                    739
                ],
                "key.left": [
                    713,
                    813,
                    745,
                    889
                ],
                "i8_types": [
                    715,
                    716
                ],
                "DatetimeIndex": [
                    715
                ],
                "TimedeltaIndex": [
                    715
                ],
                "original": [
                    740,
                    735
                ],
                "is_list_like": [
                    736,
                    1041,
                    883
                ],
                "scalar": [
                    747,
                    742,
                    750
                ],
                "is_scalar": [
                    1097,
                    742
                ],
                "key.right": [
                    816,
                    889,
                    746
                ],
                "constructor": [
                    747,
                    748
                ],
                "IntervalIndex.from_arrays": [
                    747
                ],
                "key_dtype": [
                    752,
                    768,
                    755,
                    767
                ],
                "key_i8": [
                    752,
                    770,
                    755,
                    759
                ],
                "infer_dtype_from_scalar": [
                    752
                ],
                "key.dtype": [
                    755
                ],
                "key.asi8": [
                    755
                ],
                "key.hasnans": [
                    756
                ],
                "key_i8.where": [
                    759
                ],
                "key._isnan": [
                    759
                ],
                "is_dtype_equal": [
                    767
                ],
                "method": [
                    932,
                    773,
                    776,
                    778,
                    879
                ],
                "self.is_non_overlapping_monotonic": [
                    783
                ],
                "self.left.is_monotonic_increasing": [
                    797,
                    798
                ],
                "sub_idx": [
                    800,
                    808,
                    804
                ],
                "self.open_right": [
                    801
                ],
                "exclude_label": [
                    801,
                    805
                ],
                "self.open_left": [
                    805
                ],
                "sub_idx._searchsorted_monotonic": [
                    808
                ],
                "start": [
                    1536,
                    1546,
                    812,
                    820,
                    823,
                    824,
                    826,
                    1473,
                    834,
                    1475,
                    836,
                    1477,
                    1480,
                    1486,
                    1488,
                    1511,
                    1512,
                    1524,
                    1525,
                    1529,
                    1530,
                    1531,
                    1533,
                    1535
                ],
                "self._searchsorted_monotonic": [
                    834,
                    835,
                    812,
                    815,
                    826,
                    830
                ],
                "key.open_left": [
                    813
                ],
                "stop": [
                    835,
                    836,
                    815,
                    820,
                    827,
                    828,
                    830
                ],
                "key.open_right": [
                    816
                ],
                "key.start": [
                    820
                ],
                "key.stop": [
                    820
                ],
                "key.step": [
                    1049,
                    821
                ],
                "Any": [
                    929,
                    1037,
                    839
                ],
                "Optional": [
                    927,
                    929,
                    928,
                    839
                ],
                "self._check_method": [
                    932,
                    879
                ],
                "key.closed": [
                    887
                ],
                "mask": [
                    1312,
                    900,
                    1316,
                    904,
                    905,
                    1321,
                    1323,
                    889,
                    895
                ],
                "op_left": [
                    892,
                    895
                ],
                "self.closed_left": [
                    892
                ],
                "le": [
                    892,
                    893
                ],
                "lt": [
                    892,
                    893
                ],
                "op_right": [
                    893,
                    895
                ],
                "self.closed_right": [
                    893
                ],
                "matches": [
                    900,
                    901,
                    903
                ],
                "mask.sum": [
                    900
                ],
                "mask.argmax": [
                    904
                ],
                "lib.maybe_booleans_to_slice": [
                    905
                ],
                "lib": [
                    905
                ],
                "mask.view": [
                    905
                ],
                "Union": [
                    840
                ],
                "AnyArrayLike": [
                    980,
                    1020,
                    926
                ],
                "InvalidIndexError": [
                    939
                ],
                "target_as_index": [
                    941,
                    943,
                    945,
                    950,
                    952,
                    953,
                    958,
                    959,
                    961,
                    963,
                    964,
                    969,
                    982,
                    985,
                    987,
                    989,
                    992,
                    993,
                    996,
                    997,
                    1001,
                    1013,
                    1015
                ],
                "target": [
                    1033,
                    1034,
                    941,
                    982
                ],
                "self.equals": [
                    945
                ],
                "np.arange": [
                    993,
                    946,
                    1315,
                    1005
                ],
                "target_as_index.dtype.subtype": [
                    987,
                    950
                ],
                "target_as_index.dtype": [
                    987,
                    950
                ],
                "target_as_index.closed": [
                    952,
                    989
                ],
                "np.repeat": [
                    992,
                    953
                ],
                "np.intp": [
                    953
                ],
                "left_indexer": [
                    960,
                    958
                ],
                "self.left.get_indexer": [
                    1290,
                    958
                ],
                "target_as_index.left": [
                    958
                ],
                "right_indexer": [
                    960,
                    959
                ],
                "self.right.get_indexer": [
                    1291,
                    959
                ],
                "target_as_index.right": [
                    959
                ],
                "self._engine.get_indexer": [
                    964
                ],
                "target_as_index.values": [
                    964,
                    1015
                ],
                "loc": [
                    971,
                    973,
                    974,
                    1071,
                    1040,
                    1072,
                    1105,
                    1043,
                    1106,
                    1047,
                    1051,
                    1053,
                    1054
                ],
                "indexer.append": [
                    1010,
                    974
                ],
                "ensure_platform_int": [
                    976,
                    1018
                ],
                "Substitution": [
                    907
                ],
                "missing": [
                    1000,
                    1008,
                    1043,
                    1044,
                    1014,
                    1018
                ],
                "i": [
                    1319,
                    1001,
                    1321,
                    1008,
                    1114
                ],
                "locs.start": [
                    1005
                ],
                "locs.stop": [
                    1005
                ],
                "locs.step": [
                    1005
                ],
                "missing.append": [
                    1008
                ],
                "np.concatenate": [
                    1011
                ],
                "self._engine.get_indexer_non_unique": [
                    1014
                ],
                "Tuple": [
                    981
                ],
                "self.get_indexer_non_unique": [
                    1033,
                    1043
                ],
                "self.get_indexer": [
                    1034,
                    1047
                ],
                "ABCSeries": [
                    1037
                ],
                "com.is_bool_indexer": [
                    1039
                ],
                "com": [
                    1536,
                    1473,
                    1474,
                    1379,
                    1477,
                    1480,
                    1039,
                    1524
                ],
                "self._convert_slice_indexer": [
                    1051
                ],
                "series.iloc": [
                    1054
                ],
                "series": [
                    1054
                ],
                "self._na_value": [
                    1059
                ],
                "values": [
                    1060,
                    1061
                ],
                "cond": [
                    1060
                ],
                "new_left": [
                    1105,
                    1073,
                    1107,
                    1071
                ],
                "self.left.delete": [
                    1071
                ],
                "new_right": [
                    1072,
                    1073,
                    1106,
                    1107
                ],
                "self.right.delete": [
                    1072
                ],
                "item": [
                    1090,
                    1091,
                    1095,
                    1096,
                    1097,
                    1099
                ],
                "item.closed": [
                    1091
                ],
                "left_insert": [
                    1105,
                    1099,
                    1095
                ],
                "item.left": [
                    1095
                ],
                "right_insert": [
                    1096,
                    1106,
                    1099
                ],
                "item.right": [
                    1096
                ],
                "self.left.insert": [
                    1105
                ],
                "self.right.insert": [
                    1106
                ],
                "i.closed": [
                    1114
                ],
                "to_concat": [
                    1120,
                    1114
                ],
                "_concat_same_dtype": [
                    1120
                ],
                "self._data.take": [
                    1124
                ],
                "indices": [
                    1125
                ],
                "axis": [
                    1125
                ],
                "allow_fill": [
                    1125
                ],
                "fill_value": [
                    1125
                ],
                "value": [
                    1131
                ],
                "header": [
                    1143
                ],
                "self._format_native_types": [
                    1143
                ],
                "_format_native_types": [
                    1147
                ],
                "na_rep": [
                    1147
                ],
                "quoting": [
                    1147
                ],
                "n": [
                    1153,
                    1154,
                    1158,
                    1160,
                    1163,
                    1169,
                    1170,
                    1171,
                    1172
                ],
                "max_seq_items": [
                    1169,
                    1154,
                    1170
                ],
                "get_option": [
                    1154
                ],
                "formatter": [
                    1156,
                    1161,
                    1164,
                    1165,
                    1171,
                    1172,
                    1177
                ],
                "summary": [
                    1159,
                    1162,
                    1166,
                    1173,
                    1178,
                    1180
                ],
                "first": [
                    1161,
                    1162,
                    1164,
                    1166
                ],
                "last": [
                    1165,
                    1166
                ],
                "head": [
                    1171,
                    1174
                ],
                "x": [
                    1536,
                    1171,
                    1172,
                    1177,
                    1373,
                    1374
                ],
                "tail": [
                    1177,
                    1178,
                    1172,
                    1174
                ],
                "join": [
                    1178,
                    1174
                ],
                "self._format_space": [
                    1180
                ],
                "attrs": [
                    1185,
                    1186,
                    1187,
                    1183
                ],
                "attrs.append": [
                    1185,
                    1186
                ],
                "default_pprint": [
                    1185
                ],
                "space": [
                    1190,
                    1191
                ],
                "np.lexsort": [
                    1196
                ],
                "self.is_": [
                    1202
                ],
                "self.left.equals": [
                    1213
                ],
                "other.left": [
                    1290,
                    1213,
                    1318,
                    1263
                ],
                "self.right.equals": [
                    1214
                ],
                "other.right": [
                    1318,
                    1291,
                    1214,
                    1263
                ],
                "self._data.contains": [
                    1236
                ],
                "self._data.overlaps": [
                    1254
                ],
                "self.left.is_unique": [
                    1261
                ],
                "self.right.is_unique": [
                    1261
                ],
                "taken": [
                    1262,
                    1266,
                    1269,
                    1272,
                    1274
                ],
                "self._intersection_unique": [
                    1262
                ],
                "other.left.is_unique": [
                    1263
                ],
                "other.right.is_unique": [
                    1263
                ],
                "other._intersection_unique": [
                    1266
                ],
                "self._intersection_non_unique": [
                    1269
                ],
                "taken.sort_values": [
                    1272
                ],
                "SetopCheck": [
                    1257,
                    1326
                ],
                "lindexer": [
                    1290,
                    1293,
                    1294
                ],
                "rindexer": [
                    1291,
                    1293
                ],
                "match": [
                    1293,
                    1294
                ],
                "lindexer.take": [
                    1294
                ],
                "match.nonzero": [
                    1294
                ],
                "self.take": [
                    1296
                ],
                "np.zeros": [
                    1312
                ],
                "self.hasnans": [
                    1314
                ],
                "other.hasnans": [
                    1314
                ],
                "first_nan_loc": [
                    1315,
                    1316
                ],
                "other_tups": [
                    1320,
                    1318
                ],
                "tup": [
                    1320,
                    1319
                ],
                "self._multiindex": [
                    1328
                ],
                "other._multiindex": [
                    1328
                ],
                "result_name": [
                    1329,
                    1337
                ],
                "get_op_result_name": [
                    1329
                ],
                "result.empty": [
                    1332
                ],
                "result.values.astype": [
                    1333
                ],
                "result.values": [
                    1333,
                    1335
                ],
                "from_tuples": [
                    1337
                ],
                "union": [
                    1349
                ],
                "_setop": [
                    1349,
                    1350,
                    1351
                ],
                "difference": [
                    1350
                ],
                "symmetric_difference": [
                    1351
                ],
                "IntervalIndex._add_logical_methods_disabled": [
                    1356
                ],
                "is_number": [
                    1376,
                    1478,
                    1522,
                    1363,
                    1499
                ],
                "endpoint": [
                    1475,
                    1541,
                    1478,
                    1522,
                    1363,
                    1364,
                    1365,
                    1366
                ],
                "is_ts_compat": [
                    1377,
                    1373
                ],
                "DateOffset": [
                    1373,
                    1374
                ],
                "is_td_compat": [
                    1378,
                    1374
                ],
                "a": [
                    1376,
                    1377,
                    1378,
                    1379
                ],
                "b": [
                    1376,
                    1377,
                    1378,
                    1379
                ],
                "com.any_none": [
                    1379,
                    1477
                ],
                "com.maybe_box_datetimelike": [
                    1473,
                    1474
                ],
                "end": [
                    1536,
                    1474,
                    1475,
                    1477,
                    1511,
                    1480,
                    1513,
                    1546,
                    1489,
                    1491,
                    1524,
                    1525,
                    1529,
                    1531,
                    1532,
                    1533,
                    1535
                ],
                "freq": [
                    1536,
                    1505,
                    1533,
                    1477,
                    1478,
                    1480,
                    1512,
                    1513,
                    1546,
                    1524,
                    1525,
                    1531,
                    1529,
                    1499,
                    1501
                ],
                "periods": [
                    1477,
                    1480,
                    1546,
                    1529,
                    1519,
                    1520,
                    1493,
                    1494,
                    1495,
                    1528,
                    1497,
                    1531,
                    1533,
                    1535
                ],
                "com.count_not_none": [
                    1480
                ],
                "_is_valid_endpoint": [
                    1489,
                    1486
                ],
                "is_float": [
                    1493
                ],
                "to_offset": [
                    1501
                ],
                "_is_type_compatible": [
                    1512,
                    1513,
                    1511
                ],
                "com.all_not_none": [
                    1524
                ],
                "np.linspace": [
                    1535
                ],
                "com.not_none": [
                    1536
                ],
                "maybe_downcast_to_dtype": [
                    1538
                ],
                "range_func": [
                    1544,
                    1546,
                    1542
                ],
                "date_range": [
                    1542
                ],
                "timedelta_range": [
                    1544
                ],
                "IntervalIndex.from_breaks": [
                    1548
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/home/ubuntu/Desktop/bgp_envs_local/repos/pandas_112/pandas/tests/frame/test_analytics.py",
                "test_function": "test_round_interval_category_columns",
                "test_function_code": "    def test_round_interval_category_columns(self):\n        # GH 30063\n        columns = pd.CategoricalIndex(pd.interval_range(0, 2))\n        df = DataFrame([[0.66, 1.1], [0.3, 0.25]], columns=columns)\n\n        result = df.round()\n        expected = DataFrame([[1.0, 1.0], [0.0, 0.0]], columns=columns)\n        tm.assert_frame_equal(result, expected)",
                "test_error": "TypeError: No matching signature found",
                "full_test_error": "self = <pandas.tests.frame.test_analytics.TestDataFrameAnalytics object at 0x7f47a7880df0>\n\n    def test_round_interval_category_columns(self):\n        # GH 30063\n        columns = pd.CategoricalIndex(pd.interval_range(0, 2))\n        df = DataFrame([[0.66, 1.1], [0.3, 0.25]], columns=columns)\n    \n>       result = df.round()\n\npandas/tests/frame/test_analytics.py:2280: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/frame.py:7127: in round\n    return self._constructor(\npandas/core/frame.py:416: in __init__\n    mgr = self._init_mgr(\npandas/core/generic.py:219: in _init_mgr\n    mgr = mgr.reindex_axis(\npandas/core/internals/managers.py:1186: in reindex_axis\n    new_index, indexer = self.axes[axis].reindex(\npandas/core/indexes/base.py:3200: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/interval.py:964: in get_indexer\n    indexer = self._engine.get_indexer(target_as_index.values)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>   def get_indexer(self, scalar_t[:] target):\nE   TypeError: No matching signature found\n\npandas/_libs/intervaltree.pxi:154: TypeError",
                "traceback": "pandas/core/frame.py:7127: in round\n    return self._constructor(\npandas/core/frame.py:416: in __init__\n    mgr = self._init_mgr(\npandas/core/generic.py:219: in _init_mgr\n    mgr = mgr.reindex_axis(\npandas/core/internals/managers.py:1186: in reindex_axis\n    new_index, indexer = self.axes[axis].reindex(\npandas/core/indexes/base.py:3200: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/interval.py:964: in get_indexer\n    indexer = self._engine.get_indexer(target_as_index.values)",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>   def get_indexer(self, scalar_t[:] target):\nE   TypeError: No matching signature found\n\npandas/_libs/intervaltree.pxi:154: TypeError",
                "test_function_decorators": []
            }
        ]
    }
}