{
    "pandas:24": {
        "/home/ubuntu/Desktop/bgp_envs_local/repos/pandas_24/pandas/core/arrays/datetimes.py": {
            "buggy_functions": [
                {
                    "function_name": "tz_localize",
                    "function_code": "def tz_localize(self, tz, ambiguous=\"raise\", nonexistent=\"raise\"):\n    \"\"\"\n    Localize tz-naive Datetime Array/Index to tz-aware\n    Datetime Array/Index.\n\n    This method takes a time zone (tz) naive Datetime Array/Index object\n    and makes this time zone aware. It does not move the time to another\n    time zone.\n    Time zone localization helps to switch from time zone aware to time\n    zone unaware objects.\n\n    Parameters\n    ----------\n    tz : str, pytz.timezone, dateutil.tz.tzfile or None\n        Time zone to convert timestamps to. Passing ``None`` will\n        remove the time zone information preserving local time.\n    ambiguous : 'infer', 'NaT', bool array, default 'raise'\n        When clocks moved backward due to DST, ambiguous times may arise.\n        For example in Central European Time (UTC+01), when going from\n        03:00 DST to 02:00 non-DST, 02:30:00 local time occurs both at\n        00:30:00 UTC and at 01:30:00 UTC. In such a situation, the\n        `ambiguous` parameter dictates how ambiguous times should be\n        handled.\n\n        - 'infer' will attempt to infer fall dst-transition hours based on\n          order\n        - bool-ndarray where True signifies a DST time, False signifies a\n          non-DST time (note that this flag is only applicable for\n          ambiguous times)\n        - 'NaT' will return NaT where there are ambiguous times\n        - 'raise' will raise an AmbiguousTimeError if there are ambiguous\n          times.\n\n    nonexistent : 'shift_forward', 'shift_backward, 'NaT', timedelta, \\\nult 'raise'\n        A nonexistent time does not exist in a particular timezone\n        where clocks moved forward due to DST.\n\n        - 'shift_forward' will shift the nonexistent time forward to the\n          closest existing time\n        - 'shift_backward' will shift the nonexistent time backward to the\n          closest existing time\n        - 'NaT' will return NaT where there are nonexistent times\n        - timedelta objects will shift nonexistent times by the timedelta\n        - 'raise' will raise an NonExistentTimeError if there are\n          nonexistent times.\n\n        .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    Same type as self\n        Array/Index converted to the specified time zone.\n\n    Raises\n    ------\n    TypeError\n        If the Datetime Array/Index is tz-aware and tz is not None.\n\n    See Also\n    --------\n    DatetimeIndex.tz_convert : Convert tz-aware DatetimeIndex from\n        one time zone to another.\n\n    Examples\n    --------\n    >>> tz_naive = pd.date_range('2018-03-01 09:00', periods=3)\n    >>> tz_naive\n    DatetimeIndex(['2018-03-01 09:00:00', '2018-03-02 09:00:00',\n                   '2018-03-03 09:00:00'],\n                  dtype='datetime64[ns]', freq='D')\n\n    Localize DatetimeIndex in US/Eastern time zone:\n\n    >>> tz_aware = tz_naive.tz_localize(tz='US/Eastern')\n    >>> tz_aware\n    DatetimeIndex(['2018-03-01 09:00:00-05:00',\n                   '2018-03-02 09:00:00-05:00',\n                   '2018-03-03 09:00:00-05:00'],\n                  dtype='datetime64[ns, US/Eastern]', freq='D')\n\n    With the ``tz=None``, we can remove the time zone information\n    while keeping the local time (not converted to UTC):\n\n    >>> tz_aware.tz_localize(None)\n    DatetimeIndex(['2018-03-01 09:00:00', '2018-03-02 09:00:00',\n                   '2018-03-03 09:00:00'],\n                  dtype='datetime64[ns]', freq='D')\n\n    Be careful with DST changes. When there is sequential data, pandas can\n    infer the DST time:\n\n    >>> s = pd.to_datetime(pd.Series(['2018-10-28 01:30:00',\n    ...                               '2018-10-28 02:00:00',\n    ...                               '2018-10-28 02:30:00',\n    ...                               '2018-10-28 02:00:00',\n    ...                               '2018-10-28 02:30:00',\n    ...                               '2018-10-28 03:00:00',\n    ...                               '2018-10-28 03:30:00']))\n    >>> s.dt.tz_localize('CET', ambiguous='infer')\n    0   2018-10-28 01:30:00+02:00\n    1   2018-10-28 02:00:00+02:00\n    2   2018-10-28 02:30:00+02:00\n    3   2018-10-28 02:00:00+01:00\n    4   2018-10-28 02:30:00+01:00\n    5   2018-10-28 03:00:00+01:00\n    6   2018-10-28 03:30:00+01:00\n    dtype: datetime64[ns, CET]\n\n    In some cases, inferring the DST is impossible. In such cases, you can\n    pass an ndarray to the ambiguous parameter to set the DST explicitly\n\n    >>> s = pd.to_datetime(pd.Series(['2018-10-28 01:20:00',\n    ...                               '2018-10-28 02:36:00',\n    ...                               '2018-10-28 03:46:00']))\n    >>> s.dt.tz_localize('CET', ambiguous=np.array([True, True, False]))\n    0   2018-10-28 01:20:00+02:00\n    1   2018-10-28 02:36:00+02:00\n    2   2018-10-28 03:46:00+01:00\n    dtype: datetime64[ns, CET]\n\n    If the DST transition causes nonexistent times, you can shift these\n    dates forward or backwards with a timedelta object or `'shift_forward'`\n    or `'shift_backwards'`.\n\n    >>> s = pd.to_datetime(pd.Series(['2015-03-29 02:30:00',\n    ...                               '2015-03-29 03:30:00']))\n    >>> s.dt.tz_localize('Europe/Warsaw', nonexistent='shift_forward')\n    0   2015-03-29 03:00:00+02:00\n    1   2015-03-29 03:30:00+02:00\n    dtype: datetime64[ns, Europe/Warsaw]\n\n    >>> s.dt.tz_localize('Europe/Warsaw', nonexistent='shift_backward')\n    0   2015-03-29 01:59:59.999999999+01:00\n    1   2015-03-29 03:30:00+02:00\n    dtype: datetime64[ns, Europe/Warsaw]\n\n    >>> s.dt.tz_localize('Europe/Warsaw', nonexistent=pd.Timedelta('1H'))\n    0   2015-03-29 03:30:00+02:00\n    1   2015-03-29 03:30:00+02:00\n    dtype: datetime64[ns, Europe/Warsaw]\n    \"\"\"\n    nonexistent_options = (\"raise\", \"NaT\", \"shift_forward\", \"shift_backward\")\n    if nonexistent not in nonexistent_options and not isinstance(\n        nonexistent, timedelta\n    ):\n        raise ValueError(\n            \"The nonexistent argument must be one of 'raise', \"\n            \"'NaT', 'shift_forward', 'shift_backward' or \"\n            \"a timedelta object\"\n        )\n\n    if self.tz is not None:\n        if tz is None:\n            new_dates = tzconversion.tz_convert(self.asi8, timezones.UTC, self.tz)\n        else:\n            raise TypeError(\"Already tz-aware, use tz_convert to convert.\")\n    else:\n        tz = timezones.maybe_get_tz(tz)\n        # Convert to UTC\n\n        new_dates = conversion.tz_localize_to_utc(\n            self.asi8, tz, ambiguous=ambiguous, nonexistent=nonexistent\n        )\n    new_dates = new_dates.view(DT64NS_DTYPE)\n    dtype = tz_to_dtype(tz)\n    return self._simple_new(new_dates, dtype=dtype, freq=self.freq)\n",
                    "decorators": [],
                    "docstring": "Localize tz-naive Datetime Array/Index to tz-aware\nDatetime Array/Index.\n\nThis method takes a time zone (tz) naive Datetime Array/Index object\nand makes this time zone aware. It does not move the time to another\ntime zone.\nTime zone localization helps to switch from time zone aware to time\nzone unaware objects.\n\nParameters\n----------\ntz : str, pytz.timezone, dateutil.tz.tzfile or None\n    Time zone to convert timestamps to. Passing ``None`` will\n    remove the time zone information preserving local time.\nambiguous : 'infer', 'NaT', bool array, default 'raise'\n    When clocks moved backward due to DST, ambiguous times may arise.\n    For example in Central European Time (UTC+01), when going from\n    03:00 DST to 02:00 non-DST, 02:30:00 local time occurs both at\n    00:30:00 UTC and at 01:30:00 UTC. In such a situation, the\n    `ambiguous` parameter dictates how ambiguous times should be\n    handled.\n\n    - 'infer' will attempt to infer fall dst-transition hours based on\n      order\n    - bool-ndarray where True signifies a DST time, False signifies a\n      non-DST time (note that this flag is only applicable for\n      ambiguous times)\n    - 'NaT' will return NaT where there are ambiguous times\n    - 'raise' will raise an AmbiguousTimeError if there are ambiguous\n      times.\n\nnonexistent : 'shift_forward', 'shift_backward, 'NaT', timedelta, default 'raise'\n    A nonexistent time does not exist in a particular timezone\n    where clocks moved forward due to DST.\n\n    - 'shift_forward' will shift the nonexistent time forward to the\n      closest existing time\n    - 'shift_backward' will shift the nonexistent time backward to the\n      closest existing time\n    - 'NaT' will return NaT where there are nonexistent times\n    - timedelta objects will shift nonexistent times by the timedelta\n    - 'raise' will raise an NonExistentTimeError if there are\n      nonexistent times.\n\n    .. versionadded:: 0.24.0\n\nReturns\n-------\nSame type as self\n    Array/Index converted to the specified time zone.\n\nRaises\n------\nTypeError\n    If the Datetime Array/Index is tz-aware and tz is not None.\n\nSee Also\n--------\nDatetimeIndex.tz_convert : Convert tz-aware DatetimeIndex from\n    one time zone to another.\n\nExamples\n--------\n>>> tz_naive = pd.date_range('2018-03-01 09:00', periods=3)\n>>> tz_naive\nDatetimeIndex(['2018-03-01 09:00:00', '2018-03-02 09:00:00',\n               '2018-03-03 09:00:00'],\n              dtype='datetime64[ns]', freq='D')\n\nLocalize DatetimeIndex in US/Eastern time zone:\n\n>>> tz_aware = tz_naive.tz_localize(tz='US/Eastern')\n>>> tz_aware\nDatetimeIndex(['2018-03-01 09:00:00-05:00',\n               '2018-03-02 09:00:00-05:00',\n               '2018-03-03 09:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='D')\n\nWith the ``tz=None``, we can remove the time zone information\nwhile keeping the local time (not converted to UTC):\n\n>>> tz_aware.tz_localize(None)\nDatetimeIndex(['2018-03-01 09:00:00', '2018-03-02 09:00:00',\n               '2018-03-03 09:00:00'],\n              dtype='datetime64[ns]', freq='D')\n\nBe careful with DST changes. When there is sequential data, pandas can\ninfer the DST time:\n\n>>> s = pd.to_datetime(pd.Series(['2018-10-28 01:30:00',\n...                               '2018-10-28 02:00:00',\n...                               '2018-10-28 02:30:00',\n...                               '2018-10-28 02:00:00',\n...                               '2018-10-28 02:30:00',\n...                               '2018-10-28 03:00:00',\n...                               '2018-10-28 03:30:00']))\n>>> s.dt.tz_localize('CET', ambiguous='infer')\n0   2018-10-28 01:30:00+02:00\n1   2018-10-28 02:00:00+02:00\n2   2018-10-28 02:30:00+02:00\n3   2018-10-28 02:00:00+01:00\n4   2018-10-28 02:30:00+01:00\n5   2018-10-28 03:00:00+01:00\n6   2018-10-28 03:30:00+01:00\ndtype: datetime64[ns, CET]\n\nIn some cases, inferring the DST is impossible. In such cases, you can\npass an ndarray to the ambiguous parameter to set the DST explicitly\n\n>>> s = pd.to_datetime(pd.Series(['2018-10-28 01:20:00',\n...                               '2018-10-28 02:36:00',\n...                               '2018-10-28 03:46:00']))\n>>> s.dt.tz_localize('CET', ambiguous=np.array([True, True, False]))\n0   2018-10-28 01:20:00+02:00\n1   2018-10-28 02:36:00+02:00\n2   2018-10-28 03:46:00+01:00\ndtype: datetime64[ns, CET]\n\nIf the DST transition causes nonexistent times, you can shift these\ndates forward or backwards with a timedelta object or `'shift_forward'`\nor `'shift_backwards'`.\n\n>>> s = pd.to_datetime(pd.Series(['2015-03-29 02:30:00',\n...                               '2015-03-29 03:30:00']))\n>>> s.dt.tz_localize('Europe/Warsaw', nonexistent='shift_forward')\n0   2015-03-29 03:00:00+02:00\n1   2015-03-29 03:30:00+02:00\ndtype: datetime64[ns, Europe/Warsaw]\n\n>>> s.dt.tz_localize('Europe/Warsaw', nonexistent='shift_backward')\n0   2015-03-29 01:59:59.999999999+01:00\n1   2015-03-29 03:30:00+02:00\ndtype: datetime64[ns, Europe/Warsaw]\n\n>>> s.dt.tz_localize('Europe/Warsaw', nonexistent=pd.Timedelta('1H'))\n0   2015-03-29 03:30:00+02:00\n1   2015-03-29 03:30:00+02:00\ndtype: datetime64[ns, Europe/Warsaw]",
                    "start_line": 810,
                    "end_line": 976,
                    "variables": {
                        "nonexistent_options": [
                            952,
                            953
                        ],
                        "nonexistent": [
                            953,
                            954,
                            972
                        ],
                        "isinstance": [
                            953
                        ],
                        "timedelta": [
                            954
                        ],
                        "ValueError": [
                            956
                        ],
                        "self.tz": [
                            962,
                            964
                        ],
                        "self": [
                            976,
                            962,
                            972,
                            964
                        ],
                        "tz": [
                            968,
                            963,
                            972,
                            975
                        ],
                        "new_dates": [
                            976,
                            971,
                            964,
                            974
                        ],
                        "tzconversion.tz_convert": [
                            964
                        ],
                        "tzconversion": [
                            964
                        ],
                        "self.asi8": [
                            972,
                            964
                        ],
                        "timezones.UTC": [
                            964
                        ],
                        "timezones": [
                            968,
                            964
                        ],
                        "TypeError": [
                            966
                        ],
                        "timezones.maybe_get_tz": [
                            968
                        ],
                        "conversion.tz_localize_to_utc": [
                            971
                        ],
                        "conversion": [
                            971
                        ],
                        "ambiguous": [
                            972
                        ],
                        "new_dates.view": [
                            974
                        ],
                        "DT64NS_DTYPE": [
                            974
                        ],
                        "dtype": [
                            976,
                            975
                        ],
                        "tz_to_dtype": [
                            975
                        ],
                        "self._simple_new": [
                            976
                        ],
                        "self.freq": [
                            976
                        ]
                    },
                    "filtered_variables": {
                        "nonexistent_options": [
                            952,
                            953
                        ],
                        "nonexistent": [
                            953,
                            954,
                            972
                        ],
                        "timedelta": [
                            954
                        ],
                        "self.tz": [
                            962,
                            964
                        ],
                        "self": [
                            976,
                            962,
                            972,
                            964
                        ],
                        "tz": [
                            968,
                            963,
                            972,
                            975
                        ],
                        "new_dates": [
                            976,
                            971,
                            964,
                            974
                        ],
                        "tzconversion.tz_convert": [
                            964
                        ],
                        "tzconversion": [
                            964
                        ],
                        "self.asi8": [
                            972,
                            964
                        ],
                        "timezones.UTC": [
                            964
                        ],
                        "timezones": [
                            968,
                            964
                        ],
                        "timezones.maybe_get_tz": [
                            968
                        ],
                        "conversion.tz_localize_to_utc": [
                            971
                        ],
                        "conversion": [
                            971
                        ],
                        "ambiguous": [
                            972
                        ],
                        "new_dates.view": [
                            974
                        ],
                        "DT64NS_DTYPE": [
                            974
                        ],
                        "dtype": [
                            976,
                            975
                        ],
                        "tz_to_dtype": [
                            975
                        ],
                        "self._simple_new": [
                            976
                        ],
                        "self.freq": [
                            976
                        ]
                    },
                    "diff_line_number": 889,
                    "class_data": {
                        "signature": "class DatetimeArray(dtl.DatetimeLikeArrayMixin, dtl.TimelikeOps, dtl.DatelikeOps)",
                        "docstring": "Pandas ExtensionArray for tz-naive or tz-aware datetime data.\n\n.. versionadded:: 0.24.0\n\n.. warning::\n\n   DatetimeArray is currently experimental, and its API may change\n   without warning. In particular, :attr:`DatetimeArray.dtype` is\n   expected to change to always be an instance of an ``ExtensionDtype``\n   subclass.\n\nParameters\n----------\nvalues : Series, Index, DatetimeArray, ndarray\n    The datetime data.\n\n    For DatetimeArray `values` (or a Series or Index boxing one),\n    `dtype` and `freq` will be extracted from `values`.\n\ndtype : numpy.dtype or DatetimeTZDtype\n    Note that the only NumPy dtype allowed is 'datetime64[ns]'.\nfreq : str or Offset, optional\n    The frequency.\ncopy : bool, default False\n    Whether to copy the underlying array of values.\n\nAttributes\n----------\nNone\n\nMethods\n-------\nNone",
                        "constructor_docstring": null,
                        "functions": [
                            "def __init__(self, values, dtype=DT64NS_DTYPE, freq=None, copy=False):\n    if isinstance(values, (ABCSeries, ABCIndexClass)):\n        values = values._values\n    inferred_freq = getattr(values, '_freq', None)\n    if isinstance(values, type(self)):\n        dtz = getattr(dtype, 'tz', None)\n        if dtz and values.tz is None:\n            dtype = DatetimeTZDtype(tz=dtype.tz)\n        elif dtz and values.tz:\n            if not timezones.tz_compare(dtz, values.tz):\n                msg = f\"Timezone of the array and 'dtype' do not match. '{dtz}' != '{values.tz}'\"\n                raise TypeError(msg)\n        elif values.tz:\n            dtype = values.dtype\n        if freq is None:\n            freq = values.freq\n        values = values._data\n    if not isinstance(values, np.ndarray):\n        raise ValueError(f\"Unexpected type '{type(values).__name__}'. 'values' must be a DatetimeArray ndarray, or Series or Index containing one of those.\")\n    if values.ndim not in [1, 2]:\n        raise ValueError('Only 1-dimensional input arrays are supported.')\n    if values.dtype == 'i8':\n        values = values.view(DT64NS_DTYPE)\n    if values.dtype != DT64NS_DTYPE:\n        raise ValueError(f\"The dtype of 'values' is incorrect. Must be 'datetime64[ns]'. Got {values.dtype} instead.\")\n    dtype = _validate_dt64_dtype(dtype)\n    if freq == 'infer':\n        raise ValueError(\"Frequency inference not allowed in DatetimeArray.__init__. Use 'pd.array()' instead.\")\n    if copy:\n        values = values.copy()\n    if freq:\n        freq = to_offset(freq)\n    if getattr(dtype, 'tz', None):\n        dtype = DatetimeTZDtype(tz=timezones.tz_standardize(dtype.tz))\n    self._data = values\n    self._dtype = dtype\n    self._freq = freq\n    if inferred_freq is None and freq is not None:\n        type(self)._validate_frequency(self, freq)",
                            "@classmethod\ndef _simple_new(cls, values, freq=None, dtype=DT64NS_DTYPE):\n    assert isinstance(values, np.ndarray)\n    if values.dtype != DT64NS_DTYPE:\n        assert values.dtype == 'i8'\n        values = values.view(DT64NS_DTYPE)\n    result = object.__new__(cls)\n    result._data = values\n    result._freq = freq\n    result._dtype = dtype\n    return result",
                            "@classmethod\ndef _from_sequence(cls, data, dtype=None, copy=False, tz=None, freq=None, dayfirst=False, yearfirst=False, ambiguous='raise'):\n    (freq, freq_infer) = dtl.maybe_infer_freq(freq)\n    (subarr, tz, inferred_freq) = sequence_to_dt64ns(data, dtype=dtype, copy=copy, tz=tz, dayfirst=dayfirst, yearfirst=yearfirst, ambiguous=ambiguous)\n    (freq, freq_infer) = dtl.validate_inferred_freq(freq, inferred_freq, freq_infer)\n    dtype = tz_to_dtype(tz)\n    result = cls._simple_new(subarr, freq=freq, dtype=dtype)\n    if inferred_freq is None and freq is not None:\n        cls._validate_frequency(result, freq, ambiguous=ambiguous)\n    elif freq_infer:\n        result._freq = to_offset(result.inferred_freq)\n    return result",
                            "@classmethod\ndef _generate_range(cls, start, end, periods, freq, tz=None, normalize=False, ambiguous='raise', nonexistent='raise', closed=None):\n    periods = dtl.validate_periods(periods)\n    if freq is None and any((x is None for x in [periods, start, end])):\n        raise ValueError('Must provide freq argument if no data is supplied')\n    if com.count_not_none(start, end, periods, freq) != 3:\n        raise ValueError('Of the four parameters: start, end, periods, and freq, exactly three must be specified')\n    freq = to_offset(freq)\n    if start is not None:\n        start = Timestamp(start)\n    if end is not None:\n        end = Timestamp(end)\n    if start is None and end is None:\n        if closed is not None:\n            raise ValueError('Closed has to be None if not both of start and end are defined')\n    if start is NaT or end is NaT:\n        raise ValueError('Neither `start` nor `end` can be NaT')\n    (left_closed, right_closed) = dtl.validate_endpoints(closed)\n    (start, end, _normalized) = _maybe_normalize_endpoints(start, end, normalize)\n    tz = _infer_tz_from_endpoints(start, end, tz)\n    if tz is not None:\n        start = _maybe_localize_point(start, getattr(start, 'tz', None), start, freq, tz, ambiguous, nonexistent)\n        end = _maybe_localize_point(end, getattr(end, 'tz', None), end, freq, tz, ambiguous, nonexistent)\n    if freq is not None:\n        if isinstance(freq, Day):\n            if start is not None:\n                start = start.tz_localize(None)\n            if end is not None:\n                end = end.tz_localize(None)\n        (values, _tz) = generate_regular_range(start, end, periods, freq)\n        index = cls._simple_new(values, freq=freq, dtype=tz_to_dtype(_tz))\n        if tz is not None and index.tz is None:\n            arr = conversion.tz_localize_to_utc(index.asi8, tz, ambiguous=ambiguous, nonexistent=nonexistent)\n            index = cls(arr)\n            if start is not None:\n                start = start.tz_localize(tz).asm8\n            if end is not None:\n                end = end.tz_localize(tz).asm8\n    else:\n        arr = np.linspace(0, end.value - start.value, periods, dtype='int64') + start.value\n        dtype = tz_to_dtype(tz)\n        index = cls._simple_new(arr.astype('M8[ns]', copy=False), freq=None, dtype=dtype)\n    if not left_closed and len(index) and (index[0] == start):\n        index = index[1:]\n    if not right_closed and len(index) and (index[-1] == end):\n        index = index[:-1]\n    dtype = tz_to_dtype(tz)\n    return cls._simple_new(index.asi8, freq=freq, dtype=dtype)",
                            "def _unbox_scalar(self, value):\n    if not isinstance(value, self._scalar_type) and value is not NaT:\n        raise ValueError(\"'value' should be a Timestamp.\")\n    if not isna(value):\n        self._check_compatible_with(value)\n    return value.value",
                            "def _scalar_from_string(self, value):\n    return Timestamp(value, tz=self.tz)",
                            "def _check_compatible_with(self, other, setitem: bool=False):\n    if other is NaT:\n        return\n    self._assert_tzawareness_compat(other)\n    if setitem:\n        if not timezones.tz_compare(self.tz, other.tz):\n            raise ValueError(f\"Timezones don't match. '{self.tz} != {other.tz}'\")",
                            "def _maybe_clear_freq(self):\n    self._freq = None",
                            "@property\ndef _box_func(self):\n    return lambda x: Timestamp(x, freq=self.freq, tz=self.tz)",
                            "@property\ndef dtype(self) -> Union[np.dtype, DatetimeTZDtype]:\n    \"\"\"\n    The dtype for the DatetimeArray.\n\n    .. warning::\n\n       A future version of pandas will change dtype to never be a\n       ``numpy.dtype``. Instead, :attr:`DatetimeArray.dtype` will\n       always be an instance of an ``ExtensionDtype`` subclass.\n\n    Returns\n    -------\n    numpy.dtype or DatetimeTZDtype\n        If the values are tz-naive, then ``np.dtype('datetime64[ns]')``\n        is returned.\n\n        If the values are tz-aware, then the ``DatetimeTZDtype``\n        is returned.\n    \"\"\"\n    return self._dtype",
                            "@property\ndef tz(self):\n    \"\"\"\n    Return timezone, if any.\n\n    Returns\n    -------\n    datetime.tzinfo, pytz.tzinfo.BaseTZInfo, dateutil.tz.tz.tzfile, or None\n        Returns None when the array is tz-naive.\n    \"\"\"\n    return getattr(self.dtype, 'tz', None)",
                            "@tz.setter\ndef tz(self, value):\n    raise AttributeError('Cannot directly set timezone. Use tz_localize() or tz_convert() as appropriate')",
                            "@property\ndef tzinfo(self):\n    \"\"\"\n    Alias for tz attribute\n    \"\"\"\n    return self.tz",
                            "@property\ndef _timezone(self):\n    \"\"\"\n    Comparable timezone both for pytz / dateutil\n    \"\"\"\n    return timezones.get_timezone(self.tzinfo)",
                            "@property\ndef is_normalized(self):\n    \"\"\"\n    Returns True if all of the dates are at midnight (\"no time\")\n    \"\"\"\n    return conversion.is_date_array_normalized(self.asi8, self.tz)",
                            "@property\ndef _resolution(self):\n    return libresolution.resolution(self.asi8, self.tz)",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if dtype is None and self.tz:\n        dtype = object\n    return super().__array__(dtype=dtype)",
                            "def __iter__(self):\n    \"\"\"\n    Return an iterator over the boxed values\n\n    Yields\n    ------\n    tstamp : Timestamp\n    \"\"\"\n    data = self.asi8\n    length = len(self)\n    chunksize = 10000\n    chunks = int(length / chunksize) + 1\n    for i in range(chunks):\n        start_i = i * chunksize\n        end_i = min((i + 1) * chunksize, length)\n        converted = tslib.ints_to_pydatetime(data[start_i:end_i], tz=self.tz, freq=self.freq, box='timestamp')\n        for v in converted:\n            yield v",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_datetime64_ns_dtype(dtype) and (not is_dtype_equal(dtype, self.dtype)):\n        new_tz = getattr(dtype, 'tz', None)\n        if getattr(self.dtype, 'tz', None) is None:\n            return self.tz_localize(new_tz)\n        result = self.tz_convert(new_tz)\n        if copy:\n            result = result.copy()\n        if new_tz is None:\n            result = result._data\n        return result\n    elif is_datetime64tz_dtype(self.dtype) and is_dtype_equal(self.dtype, dtype):\n        if copy:\n            return self.copy()\n        return self\n    elif is_period_dtype(dtype):\n        return self.to_period(freq=dtype.freq)\n    return dtl.DatetimeLikeArrayMixin.astype(self, dtype, copy)",
                            "def _format_native_types(self, na_rep='NaT', date_format=None, **kwargs):\n    from pandas.io.formats.format import _get_format_datetime64_from_values\n    fmt = _get_format_datetime64_from_values(self, date_format)\n    return tslib.format_array_from_datetime(self.asi8.ravel(), tz=self.tz, format=fmt, na_rep=na_rep).reshape(self.shape)",
                            "def _has_same_tz(self, other):\n    zzone = self._timezone\n    if isinstance(other, np.datetime64):\n        other = Timestamp(other)\n    vzone = timezones.get_timezone(getattr(other, 'tzinfo', '__no_tz__'))\n    return zzone == vzone",
                            "def _assert_tzawareness_compat(self, other):\n    other_tz = getattr(other, 'tzinfo', None)\n    if is_datetime64tz_dtype(other):\n        other_tz = other.dtype.tz\n    if other is NaT:\n        pass\n    elif self.tz is None:\n        if other_tz is not None:\n            raise TypeError('Cannot compare tz-naive and tz-aware datetime-like objects.')\n    elif other_tz is None:\n        raise TypeError('Cannot compare tz-naive and tz-aware datetime-like objects')",
                            "def _sub_datetime_arraylike(self, other):\n    \"\"\"subtract DatetimeArray/Index or ndarray[datetime64]\"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        assert is_datetime64_dtype(other)\n        other = type(self)(other)\n    if not self._has_same_tz(other):\n        raise TypeError(f'{type(self).__name__} subtraction must have the same timezones or no timezones')\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    arr_mask = self._isnan | other._isnan\n    new_values = checked_add_with_arr(self_i8, -other_i8, arr_mask=arr_mask)\n    if self._hasnans or other._hasnans:\n        new_values[arr_mask] = iNaT\n    return new_values.view('timedelta64[ns]')",
                            "def _add_offset(self, offset):\n    if self.ndim == 2:\n        return self.ravel()._add_offset(offset).reshape(self.shape)\n    assert not isinstance(offset, Tick)\n    try:\n        if self.tz is not None:\n            values = self.tz_localize(None)\n        else:\n            values = self\n        result = offset.apply_index(values).tz_localize(self.tz)\n    except NotImplementedError:\n        warnings.warn('Non-vectorized DateOffset being applied to Series or DatetimeIndex', PerformanceWarning)\n        result = self.astype('O') + offset\n        if not len(self):\n            return type(self)._from_sequence(result).tz_localize(self.tz)\n    return type(self)._from_sequence(result)._with_freq('infer')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert isinstance(other, (datetime, np.datetime64))\n    assert other is not NaT\n    other = Timestamp(other)\n    if other is NaT:\n        return self - NaT\n    if not self._has_same_tz(other):\n        raise TypeError('Timestamp subtraction must have the same timezones or no timezones')\n    i8 = self.asi8\n    result = checked_add_with_arr(i8, -other.value, arr_mask=self._isnan)\n    result = self._maybe_mask_results(result)\n    return result.view('timedelta64[ns]')",
                            "def _local_timestamps(self):\n    \"\"\"\n    Convert to an i8 (unix-like nanosecond timestamp) representation\n    while keeping the local timezone and not using UTC.\n    This is used to calculate time-of-day information as if the timestamps\n    were timezone-naive.\n    \"\"\"\n    return tzconversion.tz_convert(self.asi8, utc, self.tz)",
                            "def tz_convert(self, tz):\n    \"\"\"\n    Convert tz-aware Datetime Array/Index from one time zone to another.\n\n    Parameters\n    ----------\n    tz : str, pytz.timezone, dateutil.tz.tzfile or None\n        Time zone for time. Corresponding timestamps would be converted\n        to this time zone of the Datetime Array/Index. A `tz` of None will\n        convert to UTC and remove the timezone information.\n\n    Returns\n    -------\n    Array or Index\n\n    Raises\n    ------\n    TypeError\n        If Datetime Array/Index is tz-naive.\n\n    See Also\n    --------\n    DatetimeIndex.tz : A timezone that has a variable offset from UTC.\n    DatetimeIndex.tz_localize : Localize tz-naive DatetimeIndex to a\n        given time zone, or remove timezone from a tz-aware DatetimeIndex.\n\n    Examples\n    --------\n    With the `tz` parameter, we can change the DatetimeIndex\n    to other time zones:\n\n    >>> dti = pd.date_range(start='2014-08-01 09:00',\n    ...                     freq='H', periods=3, tz='Europe/Berlin')\n\n    >>> dti\n    DatetimeIndex(['2014-08-01 09:00:00+02:00',\n                   '2014-08-01 10:00:00+02:00',\n                   '2014-08-01 11:00:00+02:00'],\n                  dtype='datetime64[ns, Europe/Berlin]', freq='H')\n\n    >>> dti.tz_convert('US/Central')\n    DatetimeIndex(['2014-08-01 02:00:00-05:00',\n                   '2014-08-01 03:00:00-05:00',\n                   '2014-08-01 04:00:00-05:00'],\n                  dtype='datetime64[ns, US/Central]', freq='H')\n\n    With the ``tz=None``, we can remove the timezone (after converting\n    to UTC if necessary):\n\n    >>> dti = pd.date_range(start='2014-08-01 09:00', freq='H',\n    ...                     periods=3, tz='Europe/Berlin')\n\n    >>> dti\n    DatetimeIndex(['2014-08-01 09:00:00+02:00',\n                   '2014-08-01 10:00:00+02:00',\n                   '2014-08-01 11:00:00+02:00'],\n                    dtype='datetime64[ns, Europe/Berlin]', freq='H')\n\n    >>> dti.tz_convert(None)\n    DatetimeIndex(['2014-08-01 07:00:00',\n                   '2014-08-01 08:00:00',\n                   '2014-08-01 09:00:00'],\n                    dtype='datetime64[ns]', freq='H')\n    \"\"\"\n    tz = timezones.maybe_get_tz(tz)\n    if self.tz is None:\n        raise TypeError('Cannot convert tz-naive timestamps, use tz_localize to localize')\n    dtype = tz_to_dtype(tz)\n    return self._simple_new(self.asi8, dtype=dtype, freq=self.freq)",
                            "def tz_localize(self, tz, ambiguous='raise', nonexistent='raise'):\n    \"\"\"\n    Localize tz-naive Datetime Array/Index to tz-aware\n    Datetime Array/Index.\n\n    This method takes a time zone (tz) naive Datetime Array/Index object\n    and makes this time zone aware. It does not move the time to another\n    time zone.\n    Time zone localization helps to switch from time zone aware to time\n    zone unaware objects.\n\n    Parameters\n    ----------\n    tz : str, pytz.timezone, dateutil.tz.tzfile or None\n        Time zone to convert timestamps to. Passing ``None`` will\n        remove the time zone information preserving local time.\n    ambiguous : 'infer', 'NaT', bool array, default 'raise'\n        When clocks moved backward due to DST, ambiguous times may arise.\n        For example in Central European Time (UTC+01), when going from\n        03:00 DST to 02:00 non-DST, 02:30:00 local time occurs both at\n        00:30:00 UTC and at 01:30:00 UTC. In such a situation, the\n        `ambiguous` parameter dictates how ambiguous times should be\n        handled.\n\n        - 'infer' will attempt to infer fall dst-transition hours based on\n          order\n        - bool-ndarray where True signifies a DST time, False signifies a\n          non-DST time (note that this flag is only applicable for\n          ambiguous times)\n        - 'NaT' will return NaT where there are ambiguous times\n        - 'raise' will raise an AmbiguousTimeError if there are ambiguous\n          times.\n\n    nonexistent : 'shift_forward', 'shift_backward, 'NaT', timedelta, default 'raise'\n        A nonexistent time does not exist in a particular timezone\n        where clocks moved forward due to DST.\n\n        - 'shift_forward' will shift the nonexistent time forward to the\n          closest existing time\n        - 'shift_backward' will shift the nonexistent time backward to the\n          closest existing time\n        - 'NaT' will return NaT where there are nonexistent times\n        - timedelta objects will shift nonexistent times by the timedelta\n        - 'raise' will raise an NonExistentTimeError if there are\n          nonexistent times.\n\n        .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    Same type as self\n        Array/Index converted to the specified time zone.\n\n    Raises\n    ------\n    TypeError\n        If the Datetime Array/Index is tz-aware and tz is not None.\n\n    See Also\n    --------\n    DatetimeIndex.tz_convert : Convert tz-aware DatetimeIndex from\n        one time zone to another.\n\n    Examples\n    --------\n    >>> tz_naive = pd.date_range('2018-03-01 09:00', periods=3)\n    >>> tz_naive\n    DatetimeIndex(['2018-03-01 09:00:00', '2018-03-02 09:00:00',\n                   '2018-03-03 09:00:00'],\n                  dtype='datetime64[ns]', freq='D')\n\n    Localize DatetimeIndex in US/Eastern time zone:\n\n    >>> tz_aware = tz_naive.tz_localize(tz='US/Eastern')\n    >>> tz_aware\n    DatetimeIndex(['2018-03-01 09:00:00-05:00',\n                   '2018-03-02 09:00:00-05:00',\n                   '2018-03-03 09:00:00-05:00'],\n                  dtype='datetime64[ns, US/Eastern]', freq='D')\n\n    With the ``tz=None``, we can remove the time zone information\n    while keeping the local time (not converted to UTC):\n\n    >>> tz_aware.tz_localize(None)\n    DatetimeIndex(['2018-03-01 09:00:00', '2018-03-02 09:00:00',\n                   '2018-03-03 09:00:00'],\n                  dtype='datetime64[ns]', freq='D')\n\n    Be careful with DST changes. When there is sequential data, pandas can\n    infer the DST time:\n\n    >>> s = pd.to_datetime(pd.Series(['2018-10-28 01:30:00',\n    ...                               '2018-10-28 02:00:00',\n    ...                               '2018-10-28 02:30:00',\n    ...                               '2018-10-28 02:00:00',\n    ...                               '2018-10-28 02:30:00',\n    ...                               '2018-10-28 03:00:00',\n    ...                               '2018-10-28 03:30:00']))\n    >>> s.dt.tz_localize('CET', ambiguous='infer')\n    0   2018-10-28 01:30:00+02:00\n    1   2018-10-28 02:00:00+02:00\n    2   2018-10-28 02:30:00+02:00\n    3   2018-10-28 02:00:00+01:00\n    4   2018-10-28 02:30:00+01:00\n    5   2018-10-28 03:00:00+01:00\n    6   2018-10-28 03:30:00+01:00\n    dtype: datetime64[ns, CET]\n\n    In some cases, inferring the DST is impossible. In such cases, you can\n    pass an ndarray to the ambiguous parameter to set the DST explicitly\n\n    >>> s = pd.to_datetime(pd.Series(['2018-10-28 01:20:00',\n    ...                               '2018-10-28 02:36:00',\n    ...                               '2018-10-28 03:46:00']))\n    >>> s.dt.tz_localize('CET', ambiguous=np.array([True, True, False]))\n    0   2018-10-28 01:20:00+02:00\n    1   2018-10-28 02:36:00+02:00\n    2   2018-10-28 03:46:00+01:00\n    dtype: datetime64[ns, CET]\n\n    If the DST transition causes nonexistent times, you can shift these\n    dates forward or backwards with a timedelta object or `'shift_forward'`\n    or `'shift_backwards'`.\n\n    >>> s = pd.to_datetime(pd.Series(['2015-03-29 02:30:00',\n    ...                               '2015-03-29 03:30:00']))\n    >>> s.dt.tz_localize('Europe/Warsaw', nonexistent='shift_forward')\n    0   2015-03-29 03:00:00+02:00\n    1   2015-03-29 03:30:00+02:00\n    dtype: datetime64[ns, Europe/Warsaw]\n\n    >>> s.dt.tz_localize('Europe/Warsaw', nonexistent='shift_backward')\n    0   2015-03-29 01:59:59.999999999+01:00\n    1   2015-03-29 03:30:00+02:00\n    dtype: datetime64[ns, Europe/Warsaw]\n\n    >>> s.dt.tz_localize('Europe/Warsaw', nonexistent=pd.Timedelta('1H'))\n    0   2015-03-29 03:30:00+02:00\n    1   2015-03-29 03:30:00+02:00\n    dtype: datetime64[ns, Europe/Warsaw]\n    \"\"\"\n    nonexistent_options = ('raise', 'NaT', 'shift_forward', 'shift_backward')\n    if nonexistent not in nonexistent_options and (not isinstance(nonexistent, timedelta)):\n        raise ValueError(\"The nonexistent argument must be one of 'raise', 'NaT', 'shift_forward', 'shift_backward' or a timedelta object\")\n    if self.tz is not None:\n        if tz is None:\n            new_dates = tzconversion.tz_convert(self.asi8, timezones.UTC, self.tz)\n        else:\n            raise TypeError('Already tz-aware, use tz_convert to convert.')\n    else:\n        tz = timezones.maybe_get_tz(tz)\n        new_dates = conversion.tz_localize_to_utc(self.asi8, tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    new_dates = new_dates.view(DT64NS_DTYPE)\n    dtype = tz_to_dtype(tz)\n    return self._simple_new(new_dates, dtype=dtype, freq=self.freq)",
                            "def to_pydatetime(self) -> np.ndarray:\n    \"\"\"\n    Return Datetime Array/Index as object ndarray of datetime.datetime\n    objects.\n\n    Returns\n    -------\n    datetimes : ndarray\n    \"\"\"\n    return tslib.ints_to_pydatetime(self.asi8, tz=self.tz)",
                            "def normalize(self):\n    \"\"\"\n    Convert times to midnight.\n\n    The time component of the date-time is converted to midnight i.e.\n    00:00:00. This is useful in cases, when the time does not matter.\n    Length is unaltered. The timezones are unaffected.\n\n    This method is available on Series with datetime values under\n    the ``.dt`` accessor, and directly on Datetime Array/Index.\n\n    Returns\n    -------\n    DatetimeArray, DatetimeIndex or Series\n        The same type as the original data. Series will have the same\n        name and index. DatetimeIndex will have the same name.\n\n    See Also\n    --------\n    floor : Floor the datetimes to the specified freq.\n    ceil : Ceil the datetimes to the specified freq.\n    round : Round the datetimes to the specified freq.\n\n    Examples\n    --------\n    >>> idx = pd.date_range(start='2014-08-01 10:00', freq='H',\n    ...                     periods=3, tz='Asia/Calcutta')\n    >>> idx\n    DatetimeIndex(['2014-08-01 10:00:00+05:30',\n                   '2014-08-01 11:00:00+05:30',\n                   '2014-08-01 12:00:00+05:30'],\n                    dtype='datetime64[ns, Asia/Calcutta]', freq='H')\n    >>> idx.normalize()\n    DatetimeIndex(['2014-08-01 00:00:00+05:30',\n                   '2014-08-01 00:00:00+05:30',\n                   '2014-08-01 00:00:00+05:30'],\n                   dtype='datetime64[ns, Asia/Calcutta]', freq=None)\n    \"\"\"\n    if self.tz is None or timezones.is_utc(self.tz):\n        not_null = ~self.isna()\n        DAY_NS = ccalendar.DAY_SECONDS * 1000000000\n        new_values = self.asi8.copy()\n        adjustment = new_values[not_null] % DAY_NS\n        new_values[not_null] = new_values[not_null] - adjustment\n    else:\n        new_values = conversion.normalize_i8_timestamps(self.asi8, self.tz)\n    return type(self)(new_values)._with_freq('infer').tz_localize(self.tz)",
                            "def to_period(self, freq=None):\n    \"\"\"\n    Cast to PeriodArray/Index at a particular frequency.\n\n    Converts DatetimeArray/Index to PeriodArray/Index.\n\n    Parameters\n    ----------\n    freq : str or Offset, optional\n        One of pandas' :ref:`offset strings <timeseries.offset_aliases>`\n        or an Offset object. Will be inferred by default.\n\n    Returns\n    -------\n    PeriodArray/Index\n\n    Raises\n    ------\n    ValueError\n        When converting a DatetimeArray/Index with non-regular values,\n        so that a frequency cannot be inferred.\n\n    See Also\n    --------\n    PeriodIndex: Immutable ndarray holding ordinal values.\n    DatetimeIndex.to_pydatetime: Return DatetimeIndex as object.\n\n    Examples\n    --------\n    >>> df = pd.DataFrame({\"y\": [1, 2, 3]},\n    ...                   index=pd.to_datetime([\"2000-03-31 00:00:00\",\n    ...                                         \"2000-05-31 00:00:00\",\n    ...                                         \"2000-08-31 00:00:00\"]))\n    >>> df.index.to_period(\"M\")\n    PeriodIndex(['2000-03', '2000-05', '2000-08'],\n                dtype='period[M]', freq='M')\n\n    Infer the daily frequency\n\n    >>> idx = pd.date_range(\"2017-01-01\", periods=2)\n    >>> idx.to_period()\n    PeriodIndex(['2017-01-01', '2017-01-02'],\n                dtype='period[D]', freq='D')\n    \"\"\"\n    from pandas.core.arrays import PeriodArray\n    if self.tz is not None:\n        warnings.warn('Converting to PeriodArray/Index representation will drop timezone information.', UserWarning)\n    if freq is None:\n        freq = self.freqstr or self.inferred_freq\n        if freq is None:\n            raise ValueError('You must pass a freq argument as current index has none.')\n        res = get_period_alias(freq)\n        if res is None:\n            (base, stride) = libfrequencies._base_and_stride(freq)\n            res = f'{stride}{base}'\n        freq = res\n    return PeriodArray._from_datetime64(self._data, freq, tz=self.tz)",
                            "def to_perioddelta(self, freq):\n    \"\"\"\n    Calculate TimedeltaArray of difference between index\n    values and index converted to PeriodArray at specified\n    freq. Used for vectorized offsets.\n\n    Parameters\n    ----------\n    freq : Period frequency\n\n    Returns\n    -------\n    TimedeltaArray/Index\n    \"\"\"\n    from pandas.core.arrays.timedeltas import TimedeltaArray\n    i8delta = self.asi8 - self.to_period(freq).to_timestamp().asi8\n    m8delta = i8delta.view('m8[ns]')\n    return TimedeltaArray(m8delta)",
                            "def month_name(self, locale=None):\n    \"\"\"\n    Return the month names of the DateTimeIndex with specified locale.\n\n    .. versionadded:: 0.23.0\n\n    Parameters\n    ----------\n    locale : str, optional\n        Locale determining the language in which to return the month name.\n        Default is English locale.\n\n    Returns\n    -------\n    Index\n        Index of month names.\n\n    Examples\n    --------\n    >>> idx = pd.date_range(start='2018-01', freq='M', periods=3)\n    >>> idx\n    DatetimeIndex(['2018-01-31', '2018-02-28', '2018-03-31'],\n                  dtype='datetime64[ns]', freq='M')\n    >>> idx.month_name()\n    Index(['January', 'February', 'March'], dtype='object')\n    \"\"\"\n    if self.tz is not None and (not timezones.is_utc(self.tz)):\n        values = self._local_timestamps()\n    else:\n        values = self.asi8\n    result = fields.get_date_name_field(values, 'month_name', locale=locale)\n    result = self._maybe_mask_results(result, fill_value=None)\n    return result",
                            "def day_name(self, locale=None):\n    \"\"\"\n    Return the day names of the DateTimeIndex with specified locale.\n\n    .. versionadded:: 0.23.0\n\n    Parameters\n    ----------\n    locale : str, optional\n        Locale determining the language in which to return the day name.\n        Default is English locale.\n\n    Returns\n    -------\n    Index\n        Index of day names.\n\n    Examples\n    --------\n    >>> idx = pd.date_range(start='2018-01-01', freq='D', periods=3)\n    >>> idx\n    DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03'],\n                  dtype='datetime64[ns]', freq='D')\n    >>> idx.day_name()\n    Index(['Monday', 'Tuesday', 'Wednesday'], dtype='object')\n    \"\"\"\n    if self.tz is not None and (not timezones.is_utc(self.tz)):\n        values = self._local_timestamps()\n    else:\n        values = self.asi8\n    result = fields.get_date_name_field(values, 'day_name', locale=locale)\n    result = self._maybe_mask_results(result, fill_value=None)\n    return result",
                            "@property\ndef time(self):\n    \"\"\"\n    Returns numpy array of datetime.time. The time part of the Timestamps.\n    \"\"\"\n    if self.tz is not None and (not timezones.is_utc(self.tz)):\n        timestamps = self._local_timestamps()\n    else:\n        timestamps = self.asi8\n    return tslib.ints_to_pydatetime(timestamps, box='time')",
                            "@property\ndef timetz(self):\n    \"\"\"\n    Returns numpy array of datetime.time also containing timezone\n    information. The time part of the Timestamps.\n    \"\"\"\n    return tslib.ints_to_pydatetime(self.asi8, self.tz, box='time')",
                            "@property\ndef date(self):\n    \"\"\"\n    Returns numpy array of python datetime.date objects (namely, the date\n    part of Timestamps without timezone information).\n    \"\"\"\n    if self.tz is not None and (not timezones.is_utc(self.tz)):\n        timestamps = self._local_timestamps()\n    else:\n        timestamps = self.asi8\n    return tslib.ints_to_pydatetime(timestamps, box='date')",
                            "def isocalendar(self):\n    \"\"\"\n    Returns a DataFrame with the year, week, and day calculated according to\n    the ISO 8601 standard.\n\n    .. versionadded:: 1.1.0\n\n    Returns\n    -------\n    DataFrame\n        with columns year, week and day\n\n    See Also\n    --------\n    Timestamp.isocalendar\n    datetime.date.isocalendar\n\n    Examples\n    --------\n    >>> idx = pd.date_range(start='2019-12-29', freq='D', periods=4)\n    >>> idx.isocalendar()\n       year  week  day\n    0  2019    52    7\n    1  2020     1    1\n    2  2020     1    2\n    3  2020     1    3\n    >>> idx.isocalendar().week\n    0    52\n    1     1\n    2     1\n    3     1\n    Name: week, dtype: UInt32\n    \"\"\"\n    from pandas import DataFrame\n    if self.tz is not None and (not timezones.is_utc(self.tz)):\n        values = self._local_timestamps()\n    else:\n        values = self.asi8\n    sarray = fields.build_isocalendar_sarray(values)\n    iso_calendar_df = DataFrame(sarray, columns=['year', 'week', 'day'], dtype='UInt32')\n    if self._hasnans:\n        iso_calendar_df.iloc[self._isnan] = None\n    return iso_calendar_df",
                            "def to_julian_date(self):\n    \"\"\"\n    Convert Datetime Array to float64 ndarray of Julian Dates.\n    0 Julian date is noon January 1, 4713 BC.\n    https://en.wikipedia.org/wiki/Julian_day\n    \"\"\"\n    year = np.asarray(self.year)\n    month = np.asarray(self.month)\n    day = np.asarray(self.day)\n    testarr = month < 3\n    year[testarr] -= 1\n    month[testarr] += 12\n    return day + np.fix((153 * month - 457) / 5) + 365 * year + np.floor(year / 4) - np.floor(year / 100) + np.floor(year / 400) + 1721118.5 + (self.hour + self.minute / 60.0 + self.second / 3600.0 + self.microsecond / 3600.0 / 1000000.0 + self.nanosecond / 3600.0 / 1000000000.0) / 24.0"
                        ],
                        "constructor_variables": [
                            "self._data = values",
                            "self._dtype = dtype",
                            "self._freq = freq"
                        ],
                        "class_level_variables": [
                            "_typ = 'datetimearray'",
                            "_scalar_type = Timestamp",
                            "_recognized_scalars = (datetime, np.datetime64)",
                            "_is_recognized_dtype = is_datetime64_any_dtype",
                            "_bool_ops = ['is_month_start', 'is_month_end', 'is_quarter_start', 'is_quarter_end', 'is_year_start', 'is_year_end', 'is_leap_year']",
                            "_object_ops = ['freq', 'tz']",
                            "_field_ops = ['year', 'month', 'day', 'hour', 'minute', 'second', 'weekofyear', 'week', 'weekday', 'dayofweek', 'dayofyear', 'quarter', 'days_in_month', 'daysinmonth', 'microsecond', 'nanosecond']",
                            "_other_ops = ['date', 'time', 'timetz']",
                            "_datetimelike_ops = _field_ops + _object_ops + _bool_ops + _other_ops",
                            "_datetimelike_methods = ['to_period', 'tz_localize', 'tz_convert', 'normalize', 'strftime', 'round', 'floor', 'ceil', 'month_name', 'day_name']",
                            "__array_priority__ = 1000",
                            "_dtype: Union[np.dtype, DatetimeTZDtype]",
                            "_freq = None",
                            "year = _field_accessor('year', 'Y', '\\n        The year of the datetime.\\n\\n        Examples\\n        --------\\n        >>> datetime_series = pd.Series(\\n        ...     pd.date_range(\"2000-01-01\", periods=3, freq=\"Y\")\\n        ... )\\n        >>> datetime_series\\n        0   2000-12-31\\n        1   2001-12-31\\n        2   2002-12-31\\n        dtype: datetime64[ns]\\n        >>> datetime_series.dt.year\\n        0    2000\\n        1    2001\\n        2    2002\\n        dtype: int64\\n        ')",
                            "month = _field_accessor('month', 'M', '\\n        The month as January=1, December=12.\\n\\n        Examples\\n        --------\\n        >>> datetime_series = pd.Series(\\n        ...     pd.date_range(\"2000-01-01\", periods=3, freq=\"M\")\\n        ... )\\n        >>> datetime_series\\n        0   2000-01-31\\n        1   2000-02-29\\n        2   2000-03-31\\n        dtype: datetime64[ns]\\n        >>> datetime_series.dt.month\\n        0    1\\n        1    2\\n        2    3\\n        dtype: int64\\n        ')",
                            "day = _field_accessor('day', 'D', '\\n        The day of the datetime.\\n\\n        Examples\\n        --------\\n        >>> datetime_series = pd.Series(\\n        ...     pd.date_range(\"2000-01-01\", periods=3, freq=\"D\")\\n        ... )\\n        >>> datetime_series\\n        0   2000-01-01\\n        1   2000-01-02\\n        2   2000-01-03\\n        dtype: datetime64[ns]\\n        >>> datetime_series.dt.day\\n        0    1\\n        1    2\\n        2    3\\n        dtype: int64\\n        ')",
                            "hour = _field_accessor('hour', 'h', '\\n        The hours of the datetime.\\n\\n        Examples\\n        --------\\n        >>> datetime_series = pd.Series(\\n        ...     pd.date_range(\"2000-01-01\", periods=3, freq=\"h\")\\n        ... )\\n        >>> datetime_series\\n        0   2000-01-01 00:00:00\\n        1   2000-01-01 01:00:00\\n        2   2000-01-01 02:00:00\\n        dtype: datetime64[ns]\\n        >>> datetime_series.dt.hour\\n        0    0\\n        1    1\\n        2    2\\n        dtype: int64\\n        ')",
                            "minute = _field_accessor('minute', 'm', '\\n        The minutes of the datetime.\\n\\n        Examples\\n        --------\\n        >>> datetime_series = pd.Series(\\n        ...     pd.date_range(\"2000-01-01\", periods=3, freq=\"T\")\\n        ... )\\n        >>> datetime_series\\n        0   2000-01-01 00:00:00\\n        1   2000-01-01 00:01:00\\n        2   2000-01-01 00:02:00\\n        dtype: datetime64[ns]\\n        >>> datetime_series.dt.minute\\n        0    0\\n        1    1\\n        2    2\\n        dtype: int64\\n        ')",
                            "second = _field_accessor('second', 's', '\\n        The seconds of the datetime.\\n\\n        Examples\\n        --------\\n        >>> datetime_series = pd.Series(\\n        ...     pd.date_range(\"2000-01-01\", periods=3, freq=\"s\")\\n        ... )\\n        >>> datetime_series\\n        0   2000-01-01 00:00:00\\n        1   2000-01-01 00:00:01\\n        2   2000-01-01 00:00:02\\n        dtype: datetime64[ns]\\n        >>> datetime_series.dt.second\\n        0    0\\n        1    1\\n        2    2\\n        dtype: int64\\n        ')",
                            "microsecond = _field_accessor('microsecond', 'us', '\\n        The microseconds of the datetime.\\n\\n        Examples\\n        --------\\n        >>> datetime_series = pd.Series(\\n        ...     pd.date_range(\"2000-01-01\", periods=3, freq=\"us\")\\n        ... )\\n        >>> datetime_series\\n        0   2000-01-01 00:00:00.000000\\n        1   2000-01-01 00:00:00.000001\\n        2   2000-01-01 00:00:00.000002\\n        dtype: datetime64[ns]\\n        >>> datetime_series.dt.microsecond\\n        0       0\\n        1       1\\n        2       2\\n        dtype: int64\\n        ')",
                            "nanosecond = _field_accessor('nanosecond', 'ns', '\\n        The nanoseconds of the datetime.\\n\\n        Examples\\n        --------\\n        >>> datetime_series = pd.Series(\\n        ...     pd.date_range(\"2000-01-01\", periods=3, freq=\"ns\")\\n        ... )\\n        >>> datetime_series\\n        0   2000-01-01 00:00:00.000000000\\n        1   2000-01-01 00:00:00.000000001\\n        2   2000-01-01 00:00:00.000000002\\n        dtype: datetime64[ns]\\n        >>> datetime_series.dt.nanosecond\\n        0       0\\n        1       1\\n        2       2\\n        dtype: int64\\n        ')",
                            "weekofyear = _field_accessor('weekofyear', 'woy', '\\n        The week ordinal of the year.\\n        ')",
                            "week = weekofyear",
                            "_dayofweek_doc = \"\\n    The day of the week with Monday=0, Sunday=6.\\n\\n    Return the day of the week. It is assumed the week starts on\\n    Monday, which is denoted by 0 and ends on Sunday which is denoted\\n    by 6. This method is available on both Series with datetime\\n    values (using the `dt` accessor) or DatetimeIndex.\\n\\n    Returns\\n    -------\\n    Series or Index\\n        Containing integers indicating the day number.\\n\\n    See Also\\n    --------\\n    Series.dt.dayofweek : Alias.\\n    Series.dt.weekday : Alias.\\n    Series.dt.day_name : Returns the name of the day of the week.\\n\\n    Examples\\n    --------\\n    >>> s = pd.date_range('2016-12-31', '2017-01-08', freq='D').to_series()\\n    >>> s.dt.dayofweek\\n    2016-12-31    5\\n    2017-01-01    6\\n    2017-01-02    0\\n    2017-01-03    1\\n    2017-01-04    2\\n    2017-01-05    3\\n    2017-01-06    4\\n    2017-01-07    5\\n    2017-01-08    6\\n    Freq: D, dtype: int64\\n    \"",
                            "dayofweek = _field_accessor('dayofweek', 'dow', _dayofweek_doc)",
                            "weekday = dayofweek",
                            "dayofyear = _field_accessor('dayofyear', 'doy', '\\n        The ordinal day of the year.\\n        ')",
                            "quarter = _field_accessor('quarter', 'q', '\\n        The quarter of the date.\\n        ')",
                            "days_in_month = _field_accessor('days_in_month', 'dim', '\\n        The number of days in the month.\\n        ')",
                            "daysinmonth = days_in_month",
                            "_is_month_doc = '\\n        Indicates whether the date is the {first_or_last} day of the month.\\n\\n        Returns\\n        -------\\n        Series or array\\n            For Series, returns a Series with boolean values.\\n            For DatetimeIndex, returns a boolean array.\\n\\n        See Also\\n        --------\\n        is_month_start : Return a boolean indicating whether the date\\n            is the first day of the month.\\n        is_month_end : Return a boolean indicating whether the date\\n            is the last day of the month.\\n\\n        Examples\\n        --------\\n        This method is available on Series with datetime values under\\n        the ``.dt`` accessor, and directly on DatetimeIndex.\\n\\n        >>> s = pd.Series(pd.date_range(\"2018-02-27\", periods=3))\\n        >>> s\\n        0   2018-02-27\\n        1   2018-02-28\\n        2   2018-03-01\\n        dtype: datetime64[ns]\\n        >>> s.dt.is_month_start\\n        0    False\\n        1    False\\n        2    True\\n        dtype: bool\\n        >>> s.dt.is_month_end\\n        0    False\\n        1    True\\n        2    False\\n        dtype: bool\\n\\n        >>> idx = pd.date_range(\"2018-02-27\", periods=3)\\n        >>> idx.is_month_start\\n        array([False, False, True])\\n        >>> idx.is_month_end\\n        array([False, True, False])\\n    '",
                            "is_month_start = _field_accessor('is_month_start', 'is_month_start', _is_month_doc.format(first_or_last='first'))",
                            "is_month_end = _field_accessor('is_month_end', 'is_month_end', _is_month_doc.format(first_or_last='last'))",
                            "is_quarter_start = _field_accessor('is_quarter_start', 'is_quarter_start', '\\n        Indicator for whether the date is the first day of a quarter.\\n\\n        Returns\\n        -------\\n        is_quarter_start : Series or DatetimeIndex\\n            The same type as the original data with boolean values. Series will\\n            have the same name and index. DatetimeIndex will have the same\\n            name.\\n\\n        See Also\\n        --------\\n        quarter : Return the quarter of the date.\\n        is_quarter_end : Similar property for indicating the quarter start.\\n\\n        Examples\\n        --------\\n        This method is available on Series with datetime values under\\n        the ``.dt`` accessor, and directly on DatetimeIndex.\\n\\n        >>> df = pd.DataFrame({\\'dates\\': pd.date_range(\"2017-03-30\",\\n        ...                   periods=4)})\\n        >>> df.assign(quarter=df.dates.dt.quarter,\\n        ...           is_quarter_start=df.dates.dt.is_quarter_start)\\n               dates  quarter  is_quarter_start\\n        0 2017-03-30        1             False\\n        1 2017-03-31        1             False\\n        2 2017-04-01        2              True\\n        3 2017-04-02        2             False\\n\\n        >>> idx = pd.date_range(\\'2017-03-30\\', periods=4)\\n        >>> idx\\n        DatetimeIndex([\\'2017-03-30\\', \\'2017-03-31\\', \\'2017-04-01\\', \\'2017-04-02\\'],\\n                      dtype=\\'datetime64[ns]\\', freq=\\'D\\')\\n\\n        >>> idx.is_quarter_start\\n        array([False, False,  True, False])\\n        ')",
                            "is_quarter_end = _field_accessor('is_quarter_end', 'is_quarter_end', '\\n        Indicator for whether the date is the last day of a quarter.\\n\\n        Returns\\n        -------\\n        is_quarter_end : Series or DatetimeIndex\\n            The same type as the original data with boolean values. Series will\\n            have the same name and index. DatetimeIndex will have the same\\n            name.\\n\\n        See Also\\n        --------\\n        quarter : Return the quarter of the date.\\n        is_quarter_start : Similar property indicating the quarter start.\\n\\n        Examples\\n        --------\\n        This method is available on Series with datetime values under\\n        the ``.dt`` accessor, and directly on DatetimeIndex.\\n\\n        >>> df = pd.DataFrame({\\'dates\\': pd.date_range(\"2017-03-30\",\\n        ...                    periods=4)})\\n        >>> df.assign(quarter=df.dates.dt.quarter,\\n        ...           is_quarter_end=df.dates.dt.is_quarter_end)\\n               dates  quarter    is_quarter_end\\n        0 2017-03-30        1             False\\n        1 2017-03-31        1              True\\n        2 2017-04-01        2             False\\n        3 2017-04-02        2             False\\n\\n        >>> idx = pd.date_range(\\'2017-03-30\\', periods=4)\\n        >>> idx\\n        DatetimeIndex([\\'2017-03-30\\', \\'2017-03-31\\', \\'2017-04-01\\', \\'2017-04-02\\'],\\n                      dtype=\\'datetime64[ns]\\', freq=\\'D\\')\\n\\n        >>> idx.is_quarter_end\\n        array([False,  True, False, False])\\n        ')",
                            "is_year_start = _field_accessor('is_year_start', 'is_year_start', '\\n        Indicate whether the date is the first day of a year.\\n\\n        Returns\\n        -------\\n        Series or DatetimeIndex\\n            The same type as the original data with boolean values. Series will\\n            have the same name and index. DatetimeIndex will have the same\\n            name.\\n\\n        See Also\\n        --------\\n        is_year_end : Similar property indicating the last day of the year.\\n\\n        Examples\\n        --------\\n        This method is available on Series with datetime values under\\n        the ``.dt`` accessor, and directly on DatetimeIndex.\\n\\n        >>> dates = pd.Series(pd.date_range(\"2017-12-30\", periods=3))\\n        >>> dates\\n        0   2017-12-30\\n        1   2017-12-31\\n        2   2018-01-01\\n        dtype: datetime64[ns]\\n\\n        >>> dates.dt.is_year_start\\n        0    False\\n        1    False\\n        2    True\\n        dtype: bool\\n\\n        >>> idx = pd.date_range(\"2017-12-30\", periods=3)\\n        >>> idx\\n        DatetimeIndex([\\'2017-12-30\\', \\'2017-12-31\\', \\'2018-01-01\\'],\\n                      dtype=\\'datetime64[ns]\\', freq=\\'D\\')\\n\\n        >>> idx.is_year_start\\n        array([False, False,  True])\\n        ')",
                            "is_year_end = _field_accessor('is_year_end', 'is_year_end', '\\n        Indicate whether the date is the last day of the year.\\n\\n        Returns\\n        -------\\n        Series or DatetimeIndex\\n            The same type as the original data with boolean values. Series will\\n            have the same name and index. DatetimeIndex will have the same\\n            name.\\n\\n        See Also\\n        --------\\n        is_year_start : Similar property indicating the start of the year.\\n\\n        Examples\\n        --------\\n        This method is available on Series with datetime values under\\n        the ``.dt`` accessor, and directly on DatetimeIndex.\\n\\n        >>> dates = pd.Series(pd.date_range(\"2017-12-30\", periods=3))\\n        >>> dates\\n        0   2017-12-30\\n        1   2017-12-31\\n        2   2018-01-01\\n        dtype: datetime64[ns]\\n\\n        >>> dates.dt.is_year_end\\n        0    False\\n        1     True\\n        2    False\\n        dtype: bool\\n\\n        >>> idx = pd.date_range(\"2017-12-30\", periods=3)\\n        >>> idx\\n        DatetimeIndex([\\'2017-12-30\\', \\'2017-12-31\\', \\'2018-01-01\\'],\\n                      dtype=\\'datetime64[ns]\\', freq=\\'D\\')\\n\\n        >>> idx.is_year_end\\n        array([False,  True, False])\\n        ')",
                            "is_leap_year = _field_accessor('is_leap_year', 'is_leap_year', '\\n        Boolean indicator if the date belongs to a leap year.\\n\\n        A leap year is a year, which has 366 days (instead of 365) including\\n        29th of February as an intercalary day.\\n        Leap years are years which are multiples of four with the exception\\n        of years divisible by 100 but not by 400.\\n\\n        Returns\\n        -------\\n        Series or ndarray\\n             Booleans indicating if dates belong to a leap year.\\n\\n        Examples\\n        --------\\n        This method is available on Series with datetime values under\\n        the ``.dt`` accessor, and directly on DatetimeIndex.\\n\\n        >>> idx = pd.date_range(\"2012-01-01\", \"2015-01-01\", freq=\"Y\")\\n        >>> idx\\n        DatetimeIndex([\\'2012-12-31\\', \\'2013-12-31\\', \\'2014-12-31\\'],\\n                      dtype=\\'datetime64[ns]\\', freq=\\'A-DEC\\')\\n        >>> idx.is_leap_year\\n        array([ True, False, False])\\n\\n        >>> dates_series = pd.Series(idx)\\n        >>> dates_series\\n        0   2012-12-31\\n        1   2013-12-31\\n        2   2014-12-31\\n        dtype: datetime64[ns]\\n        >>> dates_series.dt.is_leap_year\\n        0     True\\n        1    False\\n        2    False\\n        dtype: bool\\n        ')"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "__init__(self, values, dtype=DT64NS_DTYPE, freq=None, copy=False)",
                            "_simple_new(cls, values, freq=None, dtype=DT64NS_DTYPE)",
                            "_from_sequence(cls, data, dtype=None, copy=False, tz=None, freq=None, dayfirst=False, yearfirst=False, ambiguous='raise')",
                            "_generate_range(cls, start, end, periods, freq, tz=None, normalize=False, ambiguous='raise', nonexistent='raise', closed=None)",
                            "_unbox_scalar(self, value)",
                            "_scalar_from_string(self, value)",
                            "_check_compatible_with(self, other, setitem: bool=False)",
                            "_maybe_clear_freq(self)",
                            "_box_func(self)",
                            "dtype(self) -> Union[np.dtype, DatetimeTZDtype]",
                            "tz(self)",
                            "tz(self, value)",
                            "tzinfo(self)",
                            "_timezone(self)",
                            "is_normalized(self)",
                            "_resolution(self)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__iter__(self)",
                            "astype(self, dtype, copy=True)",
                            "_format_native_types(self, na_rep='NaT', date_format=None, **kwargs)",
                            "_has_same_tz(self, other)",
                            "_assert_tzawareness_compat(self, other)",
                            "_sub_datetime_arraylike(self, other)",
                            "_add_offset(self, offset)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_local_timestamps(self)",
                            "tz_convert(self, tz)",
                            "tz_localize(self, tz, ambiguous='raise', nonexistent='raise')",
                            "to_pydatetime(self) -> np.ndarray",
                            "normalize(self)",
                            "to_period(self, freq=None)",
                            "to_perioddelta(self, freq)",
                            "month_name(self, locale=None)",
                            "day_name(self, locale=None)",
                            "time(self)",
                            "timetz(self)",
                            "date(self)",
                            "isocalendar(self)",
                            "to_julian_date(self)"
                        ],
                        "class_level_variable_names": [
                            "_typ",
                            "_scalar_type",
                            "_recognized_scalars",
                            "_is_recognized_dtype",
                            "_bool_ops",
                            "_object_ops",
                            "_field_ops",
                            "_other_ops",
                            "_datetimelike_ops",
                            "_datetimelike_methods",
                            "__array_priority__",
                            "_dtype",
                            "_freq",
                            "year",
                            "month",
                            "day",
                            "hour",
                            "minute",
                            "second",
                            "microsecond",
                            "nanosecond",
                            "weekofyear",
                            "week",
                            "_dayofweek_doc",
                            "dayofweek",
                            "weekday",
                            "dayofyear",
                            "quarter",
                            "days_in_month",
                            "daysinmonth",
                            "_is_month_doc",
                            "is_month_start",
                            "is_month_end",
                            "is_quarter_start",
                            "is_quarter_end",
                            "is_year_start",
                            "is_year_end",
                            "is_leap_year"
                        ],
                        "constructor_variable_names": [
                            "_dtype",
                            "msg",
                            "_freq",
                            "freq",
                            "values",
                            "inferred_freq",
                            "_data",
                            "dtype",
                            "dtz"
                        ]
                    },
                    "used_imports": [],
                    "variable_values": [
                        [
                            {
                                "nonexistent_options": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "nonexistent": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.tz": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2014-03-08 23:00:00', '2014-03-09 00:00:00', '2014-03-09 01:00:00',\n '2014-03-09 02:00:00', '2014-03-09 03:00:00', '2014-03-09 04:00:00',\n '2014-03-09 05:00:00', '2014-03-09 06:00:00', '2014-03-09 07:00:00',\n '2014-03-09 08:00:00', '2014-03-09 09:00:00']\nLength: 11, dtype: datetime64[ns]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "(11,)"
                                },
                                "tz": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "new_dates": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tzconversion.tz_convert": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tzconversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": "array([1394319600000000000, 1394323200000000000, 1394326800000000000,\n       1394330400000000000, 1394334000000000000, 1394337600000000000,\n       1394341200000000000, 1394344800000000000, 1394348400000000000,\n       1394352000000000000, 1394355600000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(11,)"
                                },
                                "timezones.UTC": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones.maybe_get_tz": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion.tz_localize_to_utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ambiguous": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "new_dates.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DT64NS_DTYPE": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tz_to_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._simple_new": {
                                    "variable_value": "<bound method DatetimeArray._simple_new of <class 'pandas.core.arrays.datetimes.DatetimeArray'>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Hour>",
                                    "variable_type": "Hour",
                                    "variable_shape": null
                                }
                            },
                            {
                                "nonexistent_options": {
                                    "variable_value": "('raise', 'NaT', 'shift_forward', 'shift_backward')",
                                    "variable_type": "tuple",
                                    "variable_shape": "4"
                                },
                                "nonexistent": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.tz": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2014-03-08 23:00:00', '2014-03-09 00:00:00', '2014-03-09 01:00:00',\n '2014-03-09 02:00:00', '2014-03-09 03:00:00', '2014-03-09 04:00:00',\n '2014-03-09 05:00:00', '2014-03-09 06:00:00', '2014-03-09 07:00:00',\n '2014-03-09 08:00:00', '2014-03-09 09:00:00']\nLength: 11, dtype: datetime64[ns]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "(11,)"
                                },
                                "tz": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "new_dates": {
                                    "variable_value": "array(['2014-03-08T23:00:00.000000000', '2014-03-09T00:00:00.000000000',\n       '2014-03-09T01:00:00.000000000', '2014-03-09T02:00:00.000000000',\n       '2014-03-09T03:00:00.000000000', '2014-03-09T04:00:00.000000000',\n       '2014-03-09T05:00:00.000000000', '2014-03-09T06:00:00.000000000',\n       '2014-03-09T07:00:00.000000000', '2014-03-09T08:00:00.000000000',\n       '2014-03-09T09:00:00.000000000'], dtype='datetime64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(11,)"
                                },
                                "tzconversion.tz_convert": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tzconversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": "array([1394319600000000000, 1394323200000000000, 1394326800000000000,\n       1394330400000000000, 1394334000000000000, 1394337600000000000,\n       1394341200000000000, 1394344800000000000, 1394348400000000000,\n       1394352000000000000, 1394355600000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(11,)"
                                },
                                "timezones.UTC": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones.maybe_get_tz": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion.tz_localize_to_utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ambiguous": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "new_dates.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x7fe3fef6b490>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "DT64NS_DTYPE": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "tz_to_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._simple_new": {
                                    "variable_value": "<bound method DatetimeArray._simple_new of <class 'pandas.core.arrays.datetimes.DatetimeArray'>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Hour>",
                                    "variable_type": "Hour",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "nonexistent_options": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "nonexistent": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.tz": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2014-03-08 23:00:00', '2014-03-09 00:00:00', '2014-03-09 01:00:00',\n '2014-03-09 02:00:00', '2014-03-09 03:00:00', '2014-03-09 04:00:00',\n '2014-03-09 05:00:00', '2014-03-09 06:00:00', '2014-03-09 07:00:00',\n '2014-03-09 08:00:00', '2014-03-09 09:00:00']\nLength: 11, dtype: datetime64[ns]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "(11,)"
                                },
                                "tz": {
                                    "variable_value": "'UTC'",
                                    "variable_type": "str",
                                    "variable_shape": "3"
                                },
                                "new_dates": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tzconversion.tz_convert": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tzconversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": "array([1394319600000000000, 1394323200000000000, 1394326800000000000,\n       1394330400000000000, 1394334000000000000, 1394337600000000000,\n       1394341200000000000, 1394344800000000000, 1394348400000000000,\n       1394352000000000000, 1394355600000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(11,)"
                                },
                                "timezones.UTC": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones.maybe_get_tz": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion.tz_localize_to_utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ambiguous": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "new_dates.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DT64NS_DTYPE": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tz_to_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._simple_new": {
                                    "variable_value": "<bound method DatetimeArray._simple_new of <class 'pandas.core.arrays.datetimes.DatetimeArray'>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Hour>",
                                    "variable_type": "Hour",
                                    "variable_shape": null
                                }
                            },
                            {
                                "nonexistent_options": {
                                    "variable_value": "('raise', 'NaT', 'shift_forward', 'shift_backward')",
                                    "variable_type": "tuple",
                                    "variable_shape": "4"
                                },
                                "nonexistent": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.tz": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2014-03-08 23:00:00', '2014-03-09 00:00:00', '2014-03-09 01:00:00',\n '2014-03-09 02:00:00', '2014-03-09 03:00:00', '2014-03-09 04:00:00',\n '2014-03-09 05:00:00', '2014-03-09 06:00:00', '2014-03-09 07:00:00',\n '2014-03-09 08:00:00', '2014-03-09 09:00:00']\nLength: 11, dtype: datetime64[ns]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "(11,)"
                                },
                                "tz": {
                                    "variable_value": "<UTC>",
                                    "variable_type": "UTC",
                                    "variable_shape": null
                                },
                                "new_dates": {
                                    "variable_value": "array(['2014-03-08T23:00:00.000000000', '2014-03-09T00:00:00.000000000',\n       '2014-03-09T01:00:00.000000000', '2014-03-09T02:00:00.000000000',\n       '2014-03-09T03:00:00.000000000', '2014-03-09T04:00:00.000000000',\n       '2014-03-09T05:00:00.000000000', '2014-03-09T06:00:00.000000000',\n       '2014-03-09T07:00:00.000000000', '2014-03-09T08:00:00.000000000',\n       '2014-03-09T09:00:00.000000000'], dtype='datetime64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(11,)"
                                },
                                "tzconversion.tz_convert": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tzconversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": "array([1394319600000000000, 1394323200000000000, 1394326800000000000,\n       1394330400000000000, 1394334000000000000, 1394337600000000000,\n       1394341200000000000, 1394344800000000000, 1394348400000000000,\n       1394352000000000000, 1394355600000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(11,)"
                                },
                                "timezones.UTC": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones.maybe_get_tz": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion.tz_localize_to_utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ambiguous": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "new_dates.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x7fe3fef6b8a0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "DT64NS_DTYPE": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "datetime64[ns, UTC]",
                                    "variable_type": "DatetimeTZDtype",
                                    "variable_shape": "()"
                                },
                                "tz_to_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._simple_new": {
                                    "variable_value": "<bound method DatetimeArray._simple_new of <class 'pandas.core.arrays.datetimes.DatetimeArray'>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Hour>",
                                    "variable_type": "Hour",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "nonexistent_options": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "nonexistent": {
                                    "variable_value": "'shift_forward'",
                                    "variable_type": "str",
                                    "variable_shape": "13"
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.tz": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2014-03-08 23:00:00', '2014-03-09 00:00:00', '2014-03-09 01:00:00',\n '2014-03-09 02:00:00', '2014-03-09 03:00:00', '2014-03-09 04:00:00',\n '2014-03-09 05:00:00', '2014-03-09 06:00:00', '2014-03-09 07:00:00',\n '2014-03-09 08:00:00', '2014-03-09 09:00:00']\nLength: 11, dtype: datetime64[ns]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "(11,)"
                                },
                                "tz": {
                                    "variable_value": "'US/Eastern'",
                                    "variable_type": "str",
                                    "variable_shape": "10"
                                },
                                "new_dates": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tzconversion.tz_convert": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tzconversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": "array([1394319600000000000, 1394323200000000000, 1394326800000000000,\n       1394330400000000000, 1394334000000000000, 1394337600000000000,\n       1394341200000000000, 1394344800000000000, 1394348400000000000,\n       1394352000000000000, 1394355600000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(11,)"
                                },
                                "timezones.UTC": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones.maybe_get_tz": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion.tz_localize_to_utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ambiguous": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "new_dates.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DT64NS_DTYPE": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tz_to_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._simple_new": {
                                    "variable_value": "<bound method DatetimeArray._simple_new of <class 'pandas.core.arrays.datetimes.DatetimeArray'>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Hour>",
                                    "variable_type": "Hour",
                                    "variable_shape": null
                                }
                            },
                            {
                                "nonexistent_options": {
                                    "variable_value": "('raise', 'NaT', 'shift_forward', 'shift_backward')",
                                    "variable_type": "tuple",
                                    "variable_shape": "4"
                                },
                                "nonexistent": {
                                    "variable_value": "'shift_forward'",
                                    "variable_type": "str",
                                    "variable_shape": "13"
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.tz": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2014-03-08 23:00:00', '2014-03-09 00:00:00', '2014-03-09 01:00:00',\n '2014-03-09 02:00:00', '2014-03-09 03:00:00', '2014-03-09 04:00:00',\n '2014-03-09 05:00:00', '2014-03-09 06:00:00', '2014-03-09 07:00:00',\n '2014-03-09 08:00:00', '2014-03-09 09:00:00']\nLength: 11, dtype: datetime64[ns]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "(11,)"
                                },
                                "tz": {
                                    "variable_value": "<DstTzInfo 'US/Eastern' LMT-1 day, 19:04:00 STD>",
                                    "variable_type": "US/Eastern",
                                    "variable_shape": null
                                },
                                "new_dates": {
                                    "variable_value": "array(['2014-03-09T04:00:00.000000000', '2014-03-09T05:00:00.000000000',\n       '2014-03-09T06:00:00.000000000', '2014-03-09T07:00:00.000000000',\n       '2014-03-09T07:00:00.000000000', '2014-03-09T08:00:00.000000000',\n       '2014-03-09T09:00:00.000000000', '2014-03-09T10:00:00.000000000',\n       '2014-03-09T11:00:00.000000000', '2014-03-09T12:00:00.000000000',\n       '2014-03-09T13:00:00.000000000'], dtype='datetime64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(11,)"
                                },
                                "tzconversion.tz_convert": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tzconversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": "array([1394319600000000000, 1394323200000000000, 1394326800000000000,\n       1394330400000000000, 1394334000000000000, 1394337600000000000,\n       1394341200000000000, 1394344800000000000, 1394348400000000000,\n       1394352000000000000, 1394355600000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(11,)"
                                },
                                "timezones.UTC": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones.maybe_get_tz": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion.tz_localize_to_utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ambiguous": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "new_dates.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x7fe3fef6b760>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "DT64NS_DTYPE": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeTZDtype",
                                    "variable_shape": "()"
                                },
                                "tz_to_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._simple_new": {
                                    "variable_value": "<bound method DatetimeArray._simple_new of <class 'pandas.core.arrays.datetimes.DatetimeArray'>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Hour>",
                                    "variable_type": "Hour",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "nonexistent_options": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "nonexistent": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.tz": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2014-03-08 23:00:00', '2014-03-09 00:00:00', '2014-03-09 01:00:00',\n '2014-03-09 02:00:00', '2014-03-09 03:00:00', '2014-03-09 04:00:00',\n '2014-03-09 05:00:00', '2014-03-09 06:00:00', '2014-03-09 07:00:00',\n '2014-03-09 08:00:00', '2014-03-09 09:00:00']\nLength: 11, dtype: datetime64[ns]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "(11,)"
                                },
                                "tz": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "new_dates": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tzconversion.tz_convert": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tzconversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": "array([1394319600000000000, 1394323200000000000, 1394326800000000000,\n       1394330400000000000, 1394334000000000000, 1394337600000000000,\n       1394341200000000000, 1394344800000000000, 1394348400000000000,\n       1394352000000000000, 1394355600000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(11,)"
                                },
                                "timezones.UTC": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones.maybe_get_tz": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion.tz_localize_to_utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ambiguous": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "new_dates.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DT64NS_DTYPE": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tz_to_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones.is_utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Hour>",
                                    "variable_type": "Hour",
                                    "variable_shape": null
                                },
                                "self._simple_new": {
                                    "variable_value": "<bound method DatetimeArray._simple_new of <class 'pandas.core.arrays.datetimes.DatetimeArray'>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "nonexistent_options": {
                                    "variable_value": "('raise', 'NaT', 'shift_forward', 'shift_backward')",
                                    "variable_type": "tuple",
                                    "variable_shape": "4"
                                },
                                "nonexistent": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.tz": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2014-03-08 23:00:00', '2014-03-09 00:00:00', '2014-03-09 01:00:00',\n '2014-03-09 02:00:00', '2014-03-09 03:00:00', '2014-03-09 04:00:00',\n '2014-03-09 05:00:00', '2014-03-09 06:00:00', '2014-03-09 07:00:00',\n '2014-03-09 08:00:00', '2014-03-09 09:00:00']\nLength: 11, dtype: datetime64[ns]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "(11,)"
                                },
                                "tz": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "new_dates": {
                                    "variable_value": "array(['2014-03-08T23:00:00.000000000', '2014-03-09T00:00:00.000000000',\n       '2014-03-09T01:00:00.000000000', '2014-03-09T02:00:00.000000000',\n       '2014-03-09T03:00:00.000000000', '2014-03-09T04:00:00.000000000',\n       '2014-03-09T05:00:00.000000000', '2014-03-09T06:00:00.000000000',\n       '2014-03-09T07:00:00.000000000', '2014-03-09T08:00:00.000000000',\n       '2014-03-09T09:00:00.000000000'], dtype='datetime64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(11,)"
                                },
                                "tzconversion.tz_convert": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tzconversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": "array([1394319600000000000, 1394323200000000000, 1394326800000000000,\n       1394330400000000000, 1394334000000000000, 1394337600000000000,\n       1394341200000000000, 1394344800000000000, 1394348400000000000,\n       1394352000000000000, 1394355600000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(11,)"
                                },
                                "timezones.UTC": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones.maybe_get_tz": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion.tz_localize_to_utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ambiguous": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "new_dates.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x7f67268c8d50>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "DT64NS_DTYPE": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "tz_to_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "<Hour>",
                                    "variable_type": "Hour",
                                    "variable_shape": null
                                },
                                "timezones.is_utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Hour>",
                                    "variable_type": "Hour",
                                    "variable_shape": null
                                },
                                "self._simple_new": {
                                    "variable_value": "<bound method DatetimeArray._simple_new of <class 'pandas.core.arrays.datetimes.DatetimeArray'>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "nonexistent_options": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "nonexistent": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.tz": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2014-03-08 23:00:00', '2014-03-09 00:00:00', '2014-03-09 01:00:00',\n '2014-03-09 02:00:00', '2014-03-09 03:00:00', '2014-03-09 04:00:00',\n '2014-03-09 05:00:00', '2014-03-09 06:00:00', '2014-03-09 07:00:00',\n '2014-03-09 08:00:00', '2014-03-09 09:00:00']\nLength: 11, dtype: datetime64[ns]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "(11,)"
                                },
                                "tz": {
                                    "variable_value": "'UTC'",
                                    "variable_type": "str",
                                    "variable_shape": "3"
                                },
                                "new_dates": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tzconversion.tz_convert": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tzconversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": "array([1394319600000000000, 1394323200000000000, 1394326800000000000,\n       1394330400000000000, 1394334000000000000, 1394337600000000000,\n       1394341200000000000, 1394344800000000000, 1394348400000000000,\n       1394352000000000000, 1394355600000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(11,)"
                                },
                                "timezones.UTC": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones.maybe_get_tz": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion.tz_localize_to_utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ambiguous": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "new_dates.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DT64NS_DTYPE": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tz_to_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones.is_utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Hour>",
                                    "variable_type": "Hour",
                                    "variable_shape": null
                                },
                                "self._simple_new": {
                                    "variable_value": "<bound method DatetimeArray._simple_new of <class 'pandas.core.arrays.datetimes.DatetimeArray'>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "nonexistent_options": {
                                    "variable_value": "('raise', 'NaT', 'shift_forward', 'shift_backward')",
                                    "variable_type": "tuple",
                                    "variable_shape": "4"
                                },
                                "nonexistent": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.tz": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2014-03-08 23:00:00', '2014-03-09 00:00:00', '2014-03-09 01:00:00',\n '2014-03-09 02:00:00', '2014-03-09 03:00:00', '2014-03-09 04:00:00',\n '2014-03-09 05:00:00', '2014-03-09 06:00:00', '2014-03-09 07:00:00',\n '2014-03-09 08:00:00', '2014-03-09 09:00:00']\nLength: 11, dtype: datetime64[ns]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "(11,)"
                                },
                                "tz": {
                                    "variable_value": "<UTC>",
                                    "variable_type": "UTC",
                                    "variable_shape": null
                                },
                                "new_dates": {
                                    "variable_value": "array(['2014-03-08T23:00:00.000000000', '2014-03-09T00:00:00.000000000',\n       '2014-03-09T01:00:00.000000000', '2014-03-09T02:00:00.000000000',\n       '2014-03-09T03:00:00.000000000', '2014-03-09T04:00:00.000000000',\n       '2014-03-09T05:00:00.000000000', '2014-03-09T06:00:00.000000000',\n       '2014-03-09T07:00:00.000000000', '2014-03-09T08:00:00.000000000',\n       '2014-03-09T09:00:00.000000000'], dtype='datetime64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(11,)"
                                },
                                "tzconversion.tz_convert": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tzconversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": "array([1394319600000000000, 1394323200000000000, 1394326800000000000,\n       1394330400000000000, 1394334000000000000, 1394337600000000000,\n       1394341200000000000, 1394344800000000000, 1394348400000000000,\n       1394352000000000000, 1394355600000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(11,)"
                                },
                                "timezones.UTC": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones.maybe_get_tz": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion.tz_localize_to_utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ambiguous": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "new_dates.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x7f67268c8490>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "DT64NS_DTYPE": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "datetime64[ns, UTC]",
                                    "variable_type": "DatetimeTZDtype",
                                    "variable_shape": "()"
                                },
                                "tz_to_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "<Hour>",
                                    "variable_type": "Hour",
                                    "variable_shape": null
                                },
                                "timezones.is_utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Hour>",
                                    "variable_type": "Hour",
                                    "variable_shape": null
                                },
                                "self._simple_new": {
                                    "variable_value": "<bound method DatetimeArray._simple_new of <class 'pandas.core.arrays.datetimes.DatetimeArray'>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "nonexistent_options": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "nonexistent": {
                                    "variable_value": "'shift_forward'",
                                    "variable_type": "str",
                                    "variable_shape": "13"
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.tz": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2014-03-08 23:00:00', '2014-03-09 00:00:00', '2014-03-09 01:00:00',\n '2014-03-09 02:00:00', '2014-03-09 03:00:00', '2014-03-09 04:00:00',\n '2014-03-09 05:00:00', '2014-03-09 06:00:00', '2014-03-09 07:00:00',\n '2014-03-09 08:00:00', '2014-03-09 09:00:00']\nLength: 11, dtype: datetime64[ns]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "(11,)"
                                },
                                "tz": {
                                    "variable_value": "'US/Eastern'",
                                    "variable_type": "str",
                                    "variable_shape": "10"
                                },
                                "new_dates": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tzconversion.tz_convert": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tzconversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": "array([1394319600000000000, 1394323200000000000, 1394326800000000000,\n       1394330400000000000, 1394334000000000000, 1394337600000000000,\n       1394341200000000000, 1394344800000000000, 1394348400000000000,\n       1394352000000000000, 1394355600000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(11,)"
                                },
                                "timezones.UTC": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones.maybe_get_tz": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion.tz_localize_to_utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ambiguous": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "new_dates.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DT64NS_DTYPE": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tz_to_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones.is_utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Hour>",
                                    "variable_type": "Hour",
                                    "variable_shape": null
                                },
                                "self._simple_new": {
                                    "variable_value": "<bound method DatetimeArray._simple_new of <class 'pandas.core.arrays.datetimes.DatetimeArray'>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "nonexistent_options": {
                                    "variable_value": "('raise', 'NaT', 'shift_forward', 'shift_backward')",
                                    "variable_type": "tuple",
                                    "variable_shape": "4"
                                },
                                "nonexistent": {
                                    "variable_value": "'shift_forward'",
                                    "variable_type": "str",
                                    "variable_shape": "13"
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.tz": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2014-03-08 23:00:00', '2014-03-09 00:00:00', '2014-03-09 01:00:00',\n '2014-03-09 02:00:00', '2014-03-09 03:00:00', '2014-03-09 04:00:00',\n '2014-03-09 05:00:00', '2014-03-09 06:00:00', '2014-03-09 07:00:00',\n '2014-03-09 08:00:00', '2014-03-09 09:00:00']\nLength: 11, dtype: datetime64[ns]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "(11,)"
                                },
                                "tz": {
                                    "variable_value": "<DstTzInfo 'US/Eastern' LMT-1 day, 19:04:00 STD>",
                                    "variable_type": "US/Eastern",
                                    "variable_shape": null
                                },
                                "new_dates": {
                                    "variable_value": "array(['2014-03-09T04:00:00.000000000', '2014-03-09T05:00:00.000000000',\n       '2014-03-09T06:00:00.000000000', '2014-03-09T07:00:00.000000000',\n       '2014-03-09T07:00:00.000000000', '2014-03-09T08:00:00.000000000',\n       '2014-03-09T09:00:00.000000000', '2014-03-09T10:00:00.000000000',\n       '2014-03-09T11:00:00.000000000', '2014-03-09T12:00:00.000000000',\n       '2014-03-09T13:00:00.000000000'], dtype='datetime64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(11,)"
                                },
                                "tzconversion.tz_convert": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tzconversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": "array([1394319600000000000, 1394323200000000000, 1394326800000000000,\n       1394330400000000000, 1394334000000000000, 1394337600000000000,\n       1394341200000000000, 1394344800000000000, 1394348400000000000,\n       1394352000000000000, 1394355600000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(11,)"
                                },
                                "timezones.UTC": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones.maybe_get_tz": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion.tz_localize_to_utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ambiguous": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "new_dates.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x7f67268c8f30>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "DT64NS_DTYPE": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeTZDtype",
                                    "variable_shape": "()"
                                },
                                "tz_to_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "timezones.is_utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Hour>",
                                    "variable_type": "Hour",
                                    "variable_shape": null
                                },
                                "self._simple_new": {
                                    "variable_value": "<bound method DatetimeArray._simple_new of <class 'pandas.core.arrays.datetimes.DatetimeArray'>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "nonexistent_options": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "nonexistent": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.tz": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2014-03-08 23:00:00']\nLength: 1, dtype: datetime64[ns]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "(1,)"
                                },
                                "tz": {
                                    "variable_value": "'US/Eastern'",
                                    "variable_type": "str",
                                    "variable_shape": "10"
                                },
                                "new_dates": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tzconversion.tz_convert": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tzconversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": "array([1394319600000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "timezones.UTC": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones.maybe_get_tz": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion.tz_localize_to_utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ambiguous": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "new_dates.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DT64NS_DTYPE": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tz_to_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones.is_utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Hour>",
                                    "variable_type": "Hour",
                                    "variable_shape": null
                                },
                                "self._simple_new": {
                                    "variable_value": "<bound method DatetimeArray._simple_new of <class 'pandas.core.arrays.datetimes.DatetimeArray'>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "nonexistent_options": {
                                    "variable_value": "('raise', 'NaT', 'shift_forward', 'shift_backward')",
                                    "variable_type": "tuple",
                                    "variable_shape": "4"
                                },
                                "nonexistent": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.tz": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2014-03-08 23:00:00']\nLength: 1, dtype: datetime64[ns]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "(1,)"
                                },
                                "tz": {
                                    "variable_value": "<DstTzInfo 'US/Eastern' LMT-1 day, 19:04:00 STD>",
                                    "variable_type": "US/Eastern",
                                    "variable_shape": null
                                },
                                "new_dates": {
                                    "variable_value": "array(['2014-03-09T04:00:00.000000000'], dtype='datetime64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "tzconversion.tz_convert": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tzconversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": "array([1394319600000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "timezones.UTC": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones.maybe_get_tz": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion.tz_localize_to_utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ambiguous": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "new_dates.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x7f67268c8300>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "DT64NS_DTYPE": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeTZDtype",
                                    "variable_shape": "()"
                                },
                                "tz_to_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "<Hour>",
                                    "variable_type": "Hour",
                                    "variable_shape": null
                                },
                                "timezones.is_utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Hour>",
                                    "variable_type": "Hour",
                                    "variable_shape": null
                                },
                                "self._simple_new": {
                                    "variable_value": "<bound method DatetimeArray._simple_new of <class 'pandas.core.arrays.datetimes.DatetimeArray'>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                }
            ],
            "inscope_functions": {
                "file_scope_functions": [
                    {
                        "code": "def tz_to_dtype(tz):\n    \"\"\"\n    Return a datetime64[ns] dtype appropriate for the given timezone.\n\n    Parameters\n    ----------\n    tz : tzinfo or None\n\n    Returns\n    -------\n    np.dtype or Datetime64TZDType\n    \"\"\"\n    if tz is None:\n        return DT64NS_DTYPE\n    else:\n        return DatetimeTZDtype(tz=tz)",
                        "signature": "tz_to_dtype(tz)"
                    },
                    {
                        "code": "def _field_accessor(name, field, docstring=None):\n    def f(self):\n        values = self.asi8\n        if self.tz is not None and not timezones.is_utc(self.tz):\n            values = self._local_timestamps()\n\n        if field in self._bool_ops:\n            if field.endswith((\"start\", \"end\")):\n                freq = self.freq\n                month_kw = 12\n                if freq:\n                    kwds = freq.kwds\n                    month_kw = kwds.get(\"startingMonth\", kwds.get(\"month\", 12))\n\n                result = fields.get_start_end_field(\n                    values, field, self.freqstr, month_kw\n                )\n            else:\n                result = fields.get_date_field(values, field)\n\n            # these return a boolean by-definition\n            return result\n\n        if field in self._object_ops:\n            result = fields.get_date_name_field(values, field)\n            result = self._maybe_mask_results(result, fill_value=None)\n\n        else:\n            result = fields.get_date_field(values, field)\n            result = self._maybe_mask_results(\n                result, fill_value=None, convert=\"float64\"\n            )\n\n        return result\n\n    f.__name__ = name\n    f.__doc__ = docstring\n    return property(f)",
                        "signature": "_field_accessor(name, field, docstring=None)"
                    },
                    {
                        "code": "def sequence_to_dt64ns(\n    data,\n    dtype=None,\n    copy=False,\n    tz=None,\n    dayfirst=False,\n    yearfirst=False,\n    ambiguous=\"raise\",\n):\n    \"\"\"\n    Parameters\n    ----------\n    data : list-like\n    dtype : dtype, str, or None, default None\n    copy : bool, default False\n    tz : tzinfo, str, or None, default None\n    dayfirst : bool, default False\n    yearfirst : bool, default False\n    ambiguous : str, bool, or arraylike, default 'raise'\n        See pandas._libs.tslibs.conversion.tz_localize_to_utc.\n\n    Returns\n    -------\n    result : numpy.ndarray\n        The sequence converted to a numpy array with dtype ``datetime64[ns]``.\n    tz : tzinfo or None\n        Either the user-provided tzinfo or one inferred from the data.\n    inferred_freq : Tick or None\n        The inferred frequency of the sequence.\n\n    Raises\n    ------\n    TypeError : PeriodDType data is passed\n    \"\"\"\n\n    inferred_freq = None\n\n    dtype = _validate_dt64_dtype(dtype)\n\n    if not hasattr(data, \"dtype\"):\n        # e.g. list, tuple\n        if np.ndim(data) == 0:\n            # i.e. generator\n            data = list(data)\n        data = np.asarray(data)\n        copy = False\n    elif isinstance(data, ABCSeries):\n        data = data._values\n    if isinstance(data, ABCPandasArray):\n        data = data.to_numpy()\n\n    if hasattr(data, \"freq\"):\n        # i.e. DatetimeArray/Index\n        inferred_freq = data.freq\n\n    # if dtype has an embedded tz, capture it\n    tz = validate_tz_from_dtype(dtype, tz)\n\n    if isinstance(data, ABCIndexClass):\n        if data.nlevels > 1:\n            # Without this check, data._data below is None\n            raise TypeError(\"Cannot create a DatetimeArray from a MultiIndex.\")\n        data = data._data\n\n    # By this point we are assured to have either a numpy array or Index\n    data, copy = maybe_convert_dtype(data, copy)\n\n    if is_object_dtype(data) or is_string_dtype(data):\n        # TODO: We do not have tests specific to string-dtypes,\n        #  also complex or categorical or other extension\n        copy = False\n        if lib.infer_dtype(data, skipna=False) == \"integer\":\n            data = data.astype(np.int64)\n        else:\n            # data comes back here as either i8 to denote UTC timestamps\n            #  or M8[ns] to denote wall times\n            data, inferred_tz = objects_to_datetime64ns(\n                data, dayfirst=dayfirst, yearfirst=yearfirst\n            )\n            tz = maybe_infer_tz(tz, inferred_tz)\n\n    # `data` may have originally been a Categorical[datetime64[ns, tz]],\n    # so we need to handle these types.\n    if is_datetime64tz_dtype(data):\n        # DatetimeArray -> ndarray\n        tz = maybe_infer_tz(tz, data.tz)\n        result = data._data\n\n    elif is_datetime64_dtype(data):\n        # tz-naive DatetimeArray or ndarray[datetime64]\n        data = getattr(data, \"_data\", data)\n        if data.dtype != DT64NS_DTYPE:\n            data = conversion.ensure_datetime64ns(data)\n\n        if tz is not None:\n            # Convert tz-naive to UTC\n            tz = timezones.maybe_get_tz(tz)\n            data = conversion.tz_localize_to_utc(\n                data.view(\"i8\"), tz, ambiguous=ambiguous\n            )\n            data = data.view(DT64NS_DTYPE)\n\n        assert data.dtype == DT64NS_DTYPE, data.dtype\n        result = data\n\n    else:\n        # must be integer dtype otherwise\n        # assume this data are epoch timestamps\n        if tz:\n            tz = timezones.maybe_get_tz(tz)\n\n        if data.dtype != _INT64_DTYPE:\n            data = data.astype(np.int64, copy=False)\n        result = data.view(DT64NS_DTYPE)\n\n    if copy:\n        # TODO: should this be deepcopy?\n        result = result.copy()\n\n    assert isinstance(result, np.ndarray), type(result)\n    assert result.dtype == \"M8[ns]\", result.dtype\n\n    # We have to call this again after possibly inferring a tz above\n    validate_tz_from_dtype(dtype, tz)\n\n    return result, tz, inferred_freq",
                        "signature": "sequence_to_dt64ns(data, dtype=None, copy=False, tz=None, dayfirst=False, yearfirst=False, ambiguous='raise')"
                    },
                    {
                        "code": "def objects_to_datetime64ns(\n    data,\n    dayfirst,\n    yearfirst,\n    utc=False,\n    errors=\"raise\",\n    require_iso8601=False,\n    allow_object=False,\n):\n    \"\"\"\n    Convert data to array of timestamps.\n\n    Parameters\n    ----------\n    data : np.ndarray[object]\n    dayfirst : bool\n    yearfirst : bool\n    utc : bool, default False\n        Whether to convert timezone-aware timestamps to UTC.\n    errors : {'raise', 'ignore', 'coerce'}\n    allow_object : bool\n        Whether to return an object-dtype ndarray instead of raising if the\n        data contains more than one timezone.\n\n    Returns\n    -------\n    result : ndarray\n        np.int64 dtype if returned values represent UTC timestamps\n        np.datetime64[ns] if returned values represent wall times\n        object if mixed timezones\n    inferred_tz : tzinfo or None\n\n    Raises\n    ------\n    ValueError : if data cannot be converted to datetimes\n    \"\"\"\n    assert errors in [\"raise\", \"ignore\", \"coerce\"]\n\n    # if str-dtype, convert\n    data = np.array(data, copy=False, dtype=np.object_)\n\n    try:\n        result, tz_parsed = tslib.array_to_datetime(\n            data,\n            errors=errors,\n            utc=utc,\n            dayfirst=dayfirst,\n            yearfirst=yearfirst,\n            require_iso8601=require_iso8601,\n        )\n    except ValueError as e:\n        try:\n            values, tz_parsed = conversion.datetime_to_datetime64(data)\n            # If tzaware, these values represent unix timestamps, so we\n            #  return them as i8 to distinguish from wall times\n            return values.view(\"i8\"), tz_parsed\n        except (ValueError, TypeError):\n            raise e\n\n    if tz_parsed is not None:\n        # We can take a shortcut since the datetime64 numpy array\n        #  is in UTC\n        # Return i8 values to denote unix timestamps\n        return result.view(\"i8\"), tz_parsed\n    elif is_datetime64_dtype(result):\n        # returning M8[ns] denotes wall-times; since tz is None\n        #  the distinction is a thin one\n        return result, tz_parsed\n    elif is_object_dtype(result):\n        # GH#23675 when called via `pd.to_datetime`, returning an object-dtype\n        #  array is allowed.  When called via `pd.DatetimeIndex`, we can\n        #  only accept datetime64 dtype, so raise TypeError if object-dtype\n        #  is returned, as that indicates the values can be recognized as\n        #  datetimes but they have conflicting timezones/awareness\n        if allow_object:\n            return result, tz_parsed\n        raise TypeError(result)\n    else:  # pragma: no cover\n        # GH#23675 this TypeError should never be hit, whereas the TypeError\n        #  in the object-dtype branch above is reachable.\n        raise TypeError(result)",
                        "signature": "objects_to_datetime64ns(data, dayfirst, yearfirst, utc=False, errors='raise', require_iso8601=False, allow_object=False)"
                    },
                    {
                        "code": "def maybe_convert_dtype(data, copy):\n    \"\"\"\n    Convert data based on dtype conventions, issuing deprecation warnings\n    or errors where appropriate.\n\n    Parameters\n    ----------\n    data : np.ndarray or pd.Index\n    copy : bool\n\n    Returns\n    -------\n    data : np.ndarray or pd.Index\n    copy : bool\n\n    Raises\n    ------\n    TypeError : PeriodDType data is passed\n    \"\"\"\n    if not hasattr(data, \"dtype\"):\n        # e.g. collections.deque\n        return data, copy\n\n    if is_float_dtype(data.dtype):\n        # Note: we must cast to datetime64[ns] here in order to treat these\n        #  as wall-times instead of UTC timestamps.\n        data = data.astype(DT64NS_DTYPE)\n        copy = False\n        # TODO: deprecate this behavior to instead treat symmetrically\n        #  with integer dtypes.  See discussion in GH#23675\n\n    elif is_timedelta64_dtype(data.dtype) or is_bool_dtype(data.dtype):\n        # GH#29794 enforcing deprecation introduced in GH#23539\n        raise TypeError(f\"dtype {data.dtype} cannot be converted to datetime64[ns]\")\n    elif is_period_dtype(data.dtype):\n        # Note: without explicitly raising here, PeriodIndex\n        #  test_setops.test_join_does_not_recur fails\n        raise TypeError(\n            \"Passing PeriodDtype data is invalid. Use `data.to_timestamp()` instead\"\n        )\n\n    elif is_categorical_dtype(data.dtype):\n        # GH#18664 preserve tz in going DTI->Categorical->DTI\n        # TODO: cases where we need to do another pass through this func,\n        #  e.g. the categories are timedelta64s\n        data = data.categories.take(data.codes, fill_value=NaT)._values\n        copy = False\n\n    elif is_extension_array_dtype(data.dtype) and not is_datetime64tz_dtype(data.dtype):\n        # Includes categorical\n        # TODO: We have no tests for these\n        data = np.array(data, dtype=np.object_)\n        copy = False\n\n    return data, copy",
                        "signature": "maybe_convert_dtype(data, copy)"
                    },
                    {
                        "code": "def maybe_infer_tz(tz, inferred_tz):\n    \"\"\"\n    If a timezone is inferred from data, check that it is compatible with\n    the user-provided timezone, if any.\n\n    Parameters\n    ----------\n    tz : tzinfo or None\n    inferred_tz : tzinfo or None\n\n    Returns\n    -------\n    tz : tzinfo or None\n\n    Raises\n    ------\n    TypeError : if both timezones are present but do not match\n    \"\"\"\n    if tz is None:\n        tz = inferred_tz\n    elif inferred_tz is None:\n        pass\n    elif not timezones.tz_compare(tz, inferred_tz):\n        raise TypeError(\n            f\"data is already tz-aware {inferred_tz}, unable to \"\n            f\"set specified tz: {tz}\"\n        )\n    return tz",
                        "signature": "maybe_infer_tz(tz, inferred_tz)"
                    },
                    {
                        "code": "def _validate_dt64_dtype(dtype):\n    \"\"\"\n    Check that a dtype, if passed, represents either a numpy datetime64[ns]\n    dtype or a pandas DatetimeTZDtype.\n\n    Parameters\n    ----------\n    dtype : object\n\n    Returns\n    -------\n    dtype : None, numpy.dtype, or DatetimeTZDtype\n\n    Raises\n    ------\n    ValueError : invalid dtype\n\n    Notes\n    -----\n    Unlike validate_tz_from_dtype, this does _not_ allow non-existent\n    tz errors to go through\n    \"\"\"\n    if dtype is not None:\n        dtype = pandas_dtype(dtype)\n        if is_dtype_equal(dtype, np.dtype(\"M8\")):\n            # no precision, disallowed GH#24806\n            msg = (\n                \"Passing in 'datetime64' dtype with no precision is not allowed. \"\n                \"Please pass in 'datetime64[ns]' instead.\"\n            )\n            raise ValueError(msg)\n\n        if (isinstance(dtype, np.dtype) and dtype != DT64NS_DTYPE) or not isinstance(\n            dtype, (np.dtype, DatetimeTZDtype)\n        ):\n            raise ValueError(\n                f\"Unexpected value for 'dtype': '{dtype}'. \"\n                \"Must be 'datetime64[ns]' or DatetimeTZDtype'.\"\n            )\n    return dtype",
                        "signature": "_validate_dt64_dtype(dtype)"
                    },
                    {
                        "code": "def validate_tz_from_dtype(dtype, tz):\n    \"\"\"\n    If the given dtype is a DatetimeTZDtype, extract the implied\n    tzinfo object from it and check that it does not conflict with the given\n    tz.\n\n    Parameters\n    ----------\n    dtype : dtype, str\n    tz : None, tzinfo\n\n    Returns\n    -------\n    tz : consensus tzinfo\n\n    Raises\n    ------\n    ValueError : on tzinfo mismatch\n    \"\"\"\n    if dtype is not None:\n        if isinstance(dtype, str):\n            try:\n                dtype = DatetimeTZDtype.construct_from_string(dtype)\n            except TypeError:\n                # Things like `datetime64[ns]`, which is OK for the\n                # constructors, but also nonsense, which should be validated\n                # but not by us. We *do* allow non-existent tz errors to\n                # go through\n                pass\n        dtz = getattr(dtype, \"tz\", None)\n        if dtz is not None:\n            if tz is not None and not timezones.tz_compare(tz, dtz):\n                raise ValueError(\"cannot supply both a tz and a dtype with a tz\")\n            tz = dtz\n\n        if tz is not None and is_datetime64_dtype(dtype):\n            # We also need to check for the case where the user passed a\n            #  tz-naive dtype (i.e. datetime64[ns])\n            if tz is not None and not timezones.tz_compare(tz, dtz):\n                raise ValueError(\n                    \"cannot supply both a tz and a \"\n                    \"timezone-naive dtype (i.e. datetime64[ns])\"\n                )\n\n    return tz",
                        "signature": "validate_tz_from_dtype(dtype, tz)"
                    },
                    {
                        "code": "def _infer_tz_from_endpoints(start, end, tz):\n    \"\"\"\n    If a timezone is not explicitly given via `tz`, see if one can\n    be inferred from the `start` and `end` endpoints.  If more than one\n    of these inputs provides a timezone, require that they all agree.\n\n    Parameters\n    ----------\n    start : Timestamp\n    end : Timestamp\n    tz : tzinfo or None\n\n    Returns\n    -------\n    tz : tzinfo or None\n\n    Raises\n    ------\n    TypeError : if start and end timezones do not agree\n    \"\"\"\n    try:\n        inferred_tz = timezones.infer_tzinfo(start, end)\n    except AssertionError as err:\n        # infer_tzinfo raises AssertionError if passed mismatched timezones\n        raise TypeError(\n            \"Start and end cannot both be tz-aware with different timezones\"\n        ) from err\n\n    inferred_tz = timezones.maybe_get_tz(inferred_tz)\n    tz = timezones.maybe_get_tz(tz)\n\n    if tz is not None and inferred_tz is not None:\n        if not timezones.tz_compare(inferred_tz, tz):\n            raise AssertionError(\"Inferred time zone not equal to passed time zone\")\n\n    elif inferred_tz is not None:\n        tz = inferred_tz\n\n    return tz",
                        "signature": "_infer_tz_from_endpoints(start, end, tz)"
                    },
                    {
                        "code": "def _maybe_normalize_endpoints(start, end, normalize):\n    _normalized = True\n\n    if start is not None:\n        if normalize:\n            start = normalize_date(start)\n            _normalized = True\n        else:\n            _normalized = _normalized and start.time() == _midnight\n\n    if end is not None:\n        if normalize:\n            end = normalize_date(end)\n            _normalized = True\n        else:\n            _normalized = _normalized and end.time() == _midnight\n\n    return start, end, _normalized",
                        "signature": "_maybe_normalize_endpoints(start, end, normalize)"
                    },
                    {
                        "code": "def _maybe_localize_point(ts, is_none, is_not_none, freq, tz, ambiguous, nonexistent):\n    \"\"\"\n    Localize a start or end Timestamp to the timezone of the corresponding\n    start or end Timestamp\n\n    Parameters\n    ----------\n    ts : start or end Timestamp to potentially localize\n    is_none : argument that should be None\n    is_not_none : argument that should not be None\n    freq : Tick, DateOffset, or None\n    tz : str, timezone object or None\n    ambiguous: str, localization behavior for ambiguous times\n    nonexistent: str, localization behavior for nonexistent times\n\n    Returns\n    -------\n    ts : Timestamp\n    \"\"\"\n    # Make sure start and end are timezone localized if:\n    # 1) freq = a Timedelta-like frequency (Tick)\n    # 2) freq = None i.e. generating a linspaced range\n    if is_none is None and is_not_none is not None:\n        # Note: We can't ambiguous='infer' a singular ambiguous time; however,\n        # we have historically defaulted ambiguous=False\n        ambiguous = ambiguous if ambiguous != \"infer\" else False\n        localize_args = {\"ambiguous\": ambiguous, \"nonexistent\": nonexistent, \"tz\": None}\n        if isinstance(freq, Tick) or freq is None:\n            localize_args[\"tz\"] = tz\n        ts = ts.tz_localize(**localize_args)\n    return ts",
                        "signature": "_maybe_localize_point(ts, is_none, is_not_none, freq, tz, ambiguous, nonexistent)"
                    }
                ],
                "file_scope_classes": [
                    {
                        "class_declaration": "class DatetimeArray:",
                        "functions": [
                            {
                                "code": "def __init__(self, values, dtype=DT64NS_DTYPE, freq=None, copy=False):\n    if isinstance(values, (ABCSeries, ABCIndexClass)):\n        values = values._values\n\n    inferred_freq = getattr(values, \"_freq\", None)\n\n    if isinstance(values, type(self)):\n        # validation\n        dtz = getattr(dtype, \"tz\", None)\n        if dtz and values.tz is None:\n            dtype = DatetimeTZDtype(tz=dtype.tz)\n        elif dtz and values.tz:\n            if not timezones.tz_compare(dtz, values.tz):\n                msg = (\n                    \"Timezone of the array and 'dtype' do not match. \"\n                    f\"'{dtz}' != '{values.tz}'\"\n                )\n                raise TypeError(msg)\n        elif values.tz:\n            dtype = values.dtype\n\n        if freq is None:\n            freq = values.freq\n        values = values._data\n\n    if not isinstance(values, np.ndarray):\n        raise ValueError(\n            f\"Unexpected type '{type(values).__name__}'. 'values' must be \"\n            \"a DatetimeArray ndarray, or Series or Index containing one of those.\"\n        )\n    if values.ndim not in [1, 2]:\n        raise ValueError(\"Only 1-dimensional input arrays are supported.\")\n\n    if values.dtype == \"i8\":\n        # for compat with datetime/timedelta/period shared methods,\n        #  we can sometimes get here with int64 values.  These represent\n        #  nanosecond UTC (or tz-naive) unix timestamps\n        values = values.view(DT64NS_DTYPE)\n\n    if values.dtype != DT64NS_DTYPE:\n        raise ValueError(\n            \"The dtype of 'values' is incorrect. Must be 'datetime64[ns]'. \"\n            f\"Got {values.dtype} instead.\"\n        )\n\n    dtype = _validate_dt64_dtype(dtype)\n\n    if freq == \"infer\":\n        raise ValueError(\n            \"Frequency inference not allowed in DatetimeArray.__init__. \"\n            \"Use 'pd.array()' instead.\"\n        )\n\n    if copy:\n        values = values.copy()\n    if freq:\n        freq = to_offset(freq)\n    if getattr(dtype, \"tz\", None):\n        # https://github.com/pandas-dev/pandas/issues/18595\n        # Ensure that we have a standard timezone for pytz objects.\n        # Without this, things like adding an array of timedeltas and\n        # a  tz-aware Timestamp (with a tz specific to its datetime) will\n        # be incorrect(ish?) for the array as a whole\n        dtype = DatetimeTZDtype(tz=timezones.tz_standardize(dtype.tz))\n\n    self._data = values\n    self._dtype = dtype\n    self._freq = freq\n\n    if inferred_freq is None and freq is not None:\n        type(self)._validate_frequency(self, freq)",
                                "signature": "__init__(self, values, dtype=DT64NS_DTYPE, freq=None, copy=False)"
                            },
                            {
                                "code": "@classmethod\ndef _simple_new(cls, values, freq=None, dtype=DT64NS_DTYPE):\n    assert isinstance(values, np.ndarray)\n    if values.dtype != DT64NS_DTYPE:\n        assert values.dtype == \"i8\"\n        values = values.view(DT64NS_DTYPE)\n\n    result = object.__new__(cls)\n    result._data = values\n    result._freq = freq\n    result._dtype = dtype\n    return result",
                                "signature": "_simple_new(cls, values, freq=None, dtype=DT64NS_DTYPE)"
                            },
                            {
                                "code": "@classmethod\ndef _from_sequence(\n    cls,\n    data,\n    dtype=None,\n    copy=False,\n    tz=None,\n    freq=None,\n    dayfirst=False,\n    yearfirst=False,\n    ambiguous=\"raise\",\n):\n\n    freq, freq_infer = dtl.maybe_infer_freq(freq)\n\n    subarr, tz, inferred_freq = sequence_to_dt64ns(\n        data,\n        dtype=dtype,\n        copy=copy,\n        tz=tz,\n        dayfirst=dayfirst,\n        yearfirst=yearfirst,\n        ambiguous=ambiguous,\n    )\n\n    freq, freq_infer = dtl.validate_inferred_freq(freq, inferred_freq, freq_infer)\n\n    dtype = tz_to_dtype(tz)\n    result = cls._simple_new(subarr, freq=freq, dtype=dtype)\n\n    if inferred_freq is None and freq is not None:\n        # this condition precludes `freq_infer`\n        cls._validate_frequency(result, freq, ambiguous=ambiguous)\n\n    elif freq_infer:\n        # Set _freq directly to bypass duplicative _validate_frequency\n        # check.\n        result._freq = to_offset(result.inferred_freq)\n\n    return result",
                                "signature": "_from_sequence(cls, data, dtype=None, copy=False, tz=None, freq=None, dayfirst=False, yearfirst=False, ambiguous='raise')"
                            },
                            {
                                "code": "@classmethod\ndef _generate_range(\n    cls,\n    start,\n    end,\n    periods,\n    freq,\n    tz=None,\n    normalize=False,\n    ambiguous=\"raise\",\n    nonexistent=\"raise\",\n    closed=None,\n):\n\n    periods = dtl.validate_periods(periods)\n    if freq is None and any(x is None for x in [periods, start, end]):\n        raise ValueError(\"Must provide freq argument if no data is supplied\")\n\n    if com.count_not_none(start, end, periods, freq) != 3:\n        raise ValueError(\n            \"Of the four parameters: start, end, periods, \"\n            \"and freq, exactly three must be specified\"\n        )\n    freq = to_offset(freq)\n\n    if start is not None:\n        start = Timestamp(start)\n\n    if end is not None:\n        end = Timestamp(end)\n\n    if start is None and end is None:\n        if closed is not None:\n            raise ValueError(\n                \"Closed has to be None if not both of start and end are defined\"\n            )\n    if start is NaT or end is NaT:\n        raise ValueError(\"Neither `start` nor `end` can be NaT\")\n\n    left_closed, right_closed = dtl.validate_endpoints(closed)\n\n    start, end, _normalized = _maybe_normalize_endpoints(start, end, normalize)\n\n    tz = _infer_tz_from_endpoints(start, end, tz)\n\n    if tz is not None:\n        # Localize the start and end arguments\n        start = _maybe_localize_point(\n            start,\n            getattr(start, \"tz\", None),\n            start,\n            freq,\n            tz,\n            ambiguous,\n            nonexistent,\n        )\n        end = _maybe_localize_point(\n            end, getattr(end, \"tz\", None), end, freq, tz, ambiguous, nonexistent\n        )\n    if freq is not None:\n        # We break Day arithmetic (fixed 24 hour) here and opt for\n        # Day to mean calendar day (23/24/25 hour). Therefore, strip\n        # tz info from start and day to avoid DST arithmetic\n        if isinstance(freq, Day):\n            if start is not None:\n                start = start.tz_localize(None)\n            if end is not None:\n                end = end.tz_localize(None)\n        # TODO: consider re-implementing _cached_range; GH#17914\n        values, _tz = generate_regular_range(start, end, periods, freq)\n        index = cls._simple_new(values, freq=freq, dtype=tz_to_dtype(_tz))\n\n        if tz is not None and index.tz is None:\n            arr = conversion.tz_localize_to_utc(\n                index.asi8, tz, ambiguous=ambiguous, nonexistent=nonexistent\n            )\n\n            index = cls(arr)\n\n            # index is localized datetime64 array -> have to convert\n            # start/end as well to compare\n            if start is not None:\n                start = start.tz_localize(tz).asm8\n            if end is not None:\n                end = end.tz_localize(tz).asm8\n    else:\n        # Create a linearly spaced date_range in local time\n        # Nanosecond-granularity timestamps aren't always correctly\n        # representable with doubles, so we limit the range that we\n        # pass to np.linspace as much as possible\n        arr = (\n            np.linspace(0, end.value - start.value, periods, dtype=\"int64\")\n            + start.value\n        )\n        dtype = tz_to_dtype(tz)\n        index = cls._simple_new(\n            arr.astype(\"M8[ns]\", copy=False), freq=None, dtype=dtype\n        )\n\n    if not left_closed and len(index) and index[0] == start:\n        index = index[1:]\n    if not right_closed and len(index) and index[-1] == end:\n        index = index[:-1]\n\n    dtype = tz_to_dtype(tz)\n    return cls._simple_new(index.asi8, freq=freq, dtype=dtype)",
                                "signature": "_generate_range(cls, start, end, periods, freq, tz=None, normalize=False, ambiguous='raise', nonexistent='raise', closed=None)"
                            },
                            {
                                "code": "def _unbox_scalar(self, value):\n    if not isinstance(value, self._scalar_type) and value is not NaT:\n        raise ValueError(\"'value' should be a Timestamp.\")\n    if not isna(value):\n        self._check_compatible_with(value)\n    return value.value",
                                "signature": "_unbox_scalar(self, value)"
                            },
                            {
                                "code": "def _scalar_from_string(self, value):\n    return Timestamp(value, tz=self.tz)",
                                "signature": "_scalar_from_string(self, value)"
                            },
                            {
                                "code": "def _check_compatible_with(self, other, setitem: bool = False):\n    if other is NaT:\n        return\n    self._assert_tzawareness_compat(other)\n    if setitem:\n        # Stricter check for setitem vs comparison methods\n        if not timezones.tz_compare(self.tz, other.tz):\n            raise ValueError(f\"Timezones don't match. '{self.tz} != {other.tz}'\")",
                                "signature": "_check_compatible_with(self, other, setitem: bool=False)"
                            },
                            {
                                "code": "def _maybe_clear_freq(self):\n    self._freq = None",
                                "signature": "_maybe_clear_freq(self)"
                            },
                            {
                                "code": "@property\ndef _box_func(self):\n    return lambda x: Timestamp(x, freq=self.freq, tz=self.tz)",
                                "signature": "_box_func(self)"
                            },
                            {
                                "code": "@property\ndef dtype(self) -> Union[np.dtype, DatetimeTZDtype]:\n    \"\"\"\n    The dtype for the DatetimeArray.\n\n    .. warning::\n\n       A future version of pandas will change dtype to never be a\n       ``numpy.dtype``. Instead, :attr:`DatetimeArray.dtype` will\n       always be an instance of an ``ExtensionDtype`` subclass.\n\n    Returns\n    -------\n    numpy.dtype or DatetimeTZDtype\n        If the values are tz-naive, then ``np.dtype('datetime64[ns]')``\n        is returned.\n\n        If the values are tz-aware, then the ``DatetimeTZDtype``\n        is returned.\n    \"\"\"\n    return self._dtype",
                                "signature": "dtype(self) -> Union[np.dtype, DatetimeTZDtype]"
                            },
                            {
                                "code": "@property\ndef tz(self):\n    \"\"\"\n    Return timezone, if any.\n\n    Returns\n    -------\n    datetime.tzinfo, pytz.tzinfo.BaseTZInfo, dateutil.tz.tz.tzfile, or None\n        Returns None when the array is tz-naive.\n    \"\"\"\n    # GH 18595\n    return getattr(self.dtype, \"tz\", None)",
                                "signature": "tz(self)"
                            },
                            {
                                "code": "@tz.setter\ndef tz(self, value):\n    # GH 3746: Prevent localizing or converting the index by setting tz\n    raise AttributeError(\n        \"Cannot directly set timezone. Use tz_localize() \"\n        \"or tz_convert() as appropriate\"\n    )",
                                "signature": "tz(self, value)"
                            },
                            {
                                "code": "@property\ndef tzinfo(self):\n    \"\"\"\n    Alias for tz attribute\n    \"\"\"\n    return self.tz",
                                "signature": "tzinfo(self)"
                            },
                            {
                                "code": "@property  # NB: override with cache_readonly in immutable subclasses\ndef _timezone(self):\n    \"\"\"\n    Comparable timezone both for pytz / dateutil\n    \"\"\"\n    return timezones.get_timezone(self.tzinfo)",
                                "signature": "_timezone(self)"
                            },
                            {
                                "code": "@property  # NB: override with cache_readonly in immutable subclasses\ndef is_normalized(self):\n    \"\"\"\n    Returns True if all of the dates are at midnight (\"no time\")\n    \"\"\"\n    return conversion.is_date_array_normalized(self.asi8, self.tz)",
                                "signature": "is_normalized(self)"
                            },
                            {
                                "code": "@property  # NB: override with cache_readonly in immutable subclasses\ndef _resolution(self):\n    return libresolution.resolution(self.asi8, self.tz)",
                                "signature": "_resolution(self)"
                            },
                            {
                                "code": "def __array__(self, dtype=None) -> np.ndarray:\n    if dtype is None and self.tz:\n        # The default for tz-aware is object, to preserve tz info\n        dtype = object\n\n    return super().__array__(dtype=dtype)",
                                "signature": "__array__(self, dtype=None) -> np.ndarray"
                            },
                            {
                                "code": "def __iter__(self):\n    \"\"\"\n    Return an iterator over the boxed values\n\n    Yields\n    ------\n    tstamp : Timestamp\n    \"\"\"\n\n    # convert in chunks of 10k for efficiency\n    data = self.asi8\n    length = len(self)\n    chunksize = 10000\n    chunks = int(length / chunksize) + 1\n    for i in range(chunks):\n        start_i = i * chunksize\n        end_i = min((i + 1) * chunksize, length)\n        converted = tslib.ints_to_pydatetime(\n            data[start_i:end_i], tz=self.tz, freq=self.freq, box=\"timestamp\"\n        )\n        for v in converted:\n            yield v",
                                "signature": "__iter__(self)"
                            },
                            {
                                "code": "def astype(self, dtype, copy=True):\n    # We handle\n    #   --> datetime\n    #   --> period\n    # DatetimeLikeArrayMixin Super handles the rest.\n    dtype = pandas_dtype(dtype)\n\n    if is_datetime64_ns_dtype(dtype) and not is_dtype_equal(dtype, self.dtype):\n        # GH#18951: datetime64_ns dtype but not equal means different tz\n        new_tz = getattr(dtype, \"tz\", None)\n        if getattr(self.dtype, \"tz\", None) is None:\n            return self.tz_localize(new_tz)\n        result = self.tz_convert(new_tz)\n        if copy:\n            result = result.copy()\n        if new_tz is None:\n            # Do we want .astype('datetime64[ns]') to be an ndarray.\n            # The astype in Block._astype expects this to return an\n            # ndarray, but we could maybe work around it there.\n            result = result._data\n        return result\n    elif is_datetime64tz_dtype(self.dtype) and is_dtype_equal(self.dtype, dtype):\n        if copy:\n            return self.copy()\n        return self\n    elif is_period_dtype(dtype):\n        return self.to_period(freq=dtype.freq)\n    return dtl.DatetimeLikeArrayMixin.astype(self, dtype, copy)",
                                "signature": "astype(self, dtype, copy=True)"
                            },
                            {
                                "code": "def _format_native_types(self, na_rep=\"NaT\", date_format=None, **kwargs):\n    from pandas.io.formats.format import _get_format_datetime64_from_values\n\n    fmt = _get_format_datetime64_from_values(self, date_format)\n\n    return tslib.format_array_from_datetime(\n        self.asi8.ravel(), tz=self.tz, format=fmt, na_rep=na_rep\n    ).reshape(self.shape)",
                                "signature": "_format_native_types(self, na_rep='NaT', date_format=None, **kwargs)"
                            },
                            {
                                "code": "def _has_same_tz(self, other):\n    zzone = self._timezone\n\n    # vzone shouldn't be None if value is non-datetime like\n    if isinstance(other, np.datetime64):\n        # convert to Timestamp as np.datetime64 doesn't have tz attr\n        other = Timestamp(other)\n    vzone = timezones.get_timezone(getattr(other, \"tzinfo\", \"__no_tz__\"))\n    return zzone == vzone",
                                "signature": "_has_same_tz(self, other)"
                            },
                            {
                                "code": "def _assert_tzawareness_compat(self, other):\n    # adapted from _Timestamp._assert_tzawareness_compat\n    other_tz = getattr(other, \"tzinfo\", None)\n    if is_datetime64tz_dtype(other):\n        # Get tzinfo from Series dtype\n        other_tz = other.dtype.tz\n    if other is NaT:\n        # pd.NaT quacks both aware and naive\n        pass\n    elif self.tz is None:\n        if other_tz is not None:\n            raise TypeError(\n                \"Cannot compare tz-naive and tz-aware datetime-like objects.\"\n            )\n    elif other_tz is None:\n        raise TypeError(\n            \"Cannot compare tz-naive and tz-aware datetime-like objects\"\n        )",
                                "signature": "_assert_tzawareness_compat(self, other)"
                            },
                            {
                                "code": "def _sub_datetime_arraylike(self, other):\n    \"\"\"subtract DatetimeArray/Index or ndarray[datetime64]\"\"\"\n    if len(self) != len(other):\n        raise ValueError(\"cannot add indices of unequal length\")\n\n    if isinstance(other, np.ndarray):\n        assert is_datetime64_dtype(other)\n        other = type(self)(other)\n\n    if not self._has_same_tz(other):\n        # require tz compat\n        raise TypeError(\n            f\"{type(self).__name__} subtraction must have the same \"\n            \"timezones or no timezones\"\n        )\n\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    arr_mask = self._isnan | other._isnan\n    new_values = checked_add_with_arr(self_i8, -other_i8, arr_mask=arr_mask)\n    if self._hasnans or other._hasnans:\n        new_values[arr_mask] = iNaT\n    return new_values.view(\"timedelta64[ns]\")",
                                "signature": "_sub_datetime_arraylike(self, other)"
                            },
                            {
                                "code": "def _add_offset(self, offset):\n    if self.ndim == 2:\n        return self.ravel()._add_offset(offset).reshape(self.shape)\n\n    assert not isinstance(offset, Tick)\n    try:\n        if self.tz is not None:\n            values = self.tz_localize(None)\n        else:\n            values = self\n        result = offset.apply_index(values).tz_localize(self.tz)\n\n    except NotImplementedError:\n        warnings.warn(\n            \"Non-vectorized DateOffset being applied to Series or DatetimeIndex\",\n            PerformanceWarning,\n        )\n        result = self.astype(\"O\") + offset\n        if not len(self):\n            # GH#30336 _from_sequence won't be able to infer self.tz\n            return type(self)._from_sequence(result).tz_localize(self.tz)\n\n    return type(self)._from_sequence(result)._with_freq(\"infer\")",
                                "signature": "_add_offset(self, offset)"
                            },
                            {
                                "code": "def _sub_datetimelike_scalar(self, other):\n    # subtract a datetime from myself, yielding a ndarray[timedelta64[ns]]\n    assert isinstance(other, (datetime, np.datetime64))\n    assert other is not NaT\n    other = Timestamp(other)\n    if other is NaT:\n        return self - NaT\n\n    if not self._has_same_tz(other):\n        # require tz compat\n        raise TypeError(\n            \"Timestamp subtraction must have the same timezones or no timezones\"\n        )\n\n    i8 = self.asi8\n    result = checked_add_with_arr(i8, -other.value, arr_mask=self._isnan)\n    result = self._maybe_mask_results(result)\n    return result.view(\"timedelta64[ns]\")",
                                "signature": "_sub_datetimelike_scalar(self, other)"
                            },
                            {
                                "code": "def _local_timestamps(self):\n    \"\"\"\n    Convert to an i8 (unix-like nanosecond timestamp) representation\n    while keeping the local timezone and not using UTC.\n    This is used to calculate time-of-day information as if the timestamps\n    were timezone-naive.\n    \"\"\"\n    return tzconversion.tz_convert(self.asi8, utc, self.tz)",
                                "signature": "_local_timestamps(self)"
                            },
                            {
                                "code": "def tz_convert(self, tz):\n    \"\"\"\n    Convert tz-aware Datetime Array/Index from one time zone to another.\n\n    Parameters\n    ----------\n    tz : str, pytz.timezone, dateutil.tz.tzfile or None\n        Time zone for time. Corresponding timestamps would be converted\n        to this time zone of the Datetime Array/Index. A `tz` of None will\n        convert to UTC and remove the timezone information.\n\n    Returns\n    -------\n    Array or Index\n\n    Raises\n    ------\n    TypeError\n        If Datetime Array/Index is tz-naive.\n\n    See Also\n    --------\n    DatetimeIndex.tz : A timezone that has a variable offset from UTC.\n    DatetimeIndex.tz_localize : Localize tz-naive DatetimeIndex to a\n        given time zone, or remove timezone from a tz-aware DatetimeIndex.\n\n    Examples\n    --------\n    With the `tz` parameter, we can change the DatetimeIndex\n    to other time zones:\n\n    >>> dti = pd.date_range(start='2014-08-01 09:00',\n    ...                     freq='H', periods=3, tz='Europe/Berlin')\n\n    >>> dti\n    DatetimeIndex(['2014-08-01 09:00:00+02:00',\n                   '2014-08-01 10:00:00+02:00',\n                   '2014-08-01 11:00:00+02:00'],\n                  dtype='datetime64[ns, Europe/Berlin]', freq='H')\n\n    >>> dti.tz_convert('US/Central')\n    DatetimeIndex(['2014-08-01 02:00:00-05:00',\n                   '2014-08-01 03:00:00-05:00',\n                   '2014-08-01 04:00:00-05:00'],\n                  dtype='datetime64[ns, US/Central]', freq='H')\n\n    With the ``tz=None``, we can remove the timezone (after converting\n    to UTC if necessary):\n\n    >>> dti = pd.date_range(start='2014-08-01 09:00', freq='H',\n    ...                     periods=3, tz='Europe/Berlin')\n\n    >>> dti\n    DatetimeIndex(['2014-08-01 09:00:00+02:00',\n                   '2014-08-01 10:00:00+02:00',\n                   '2014-08-01 11:00:00+02:00'],\n                    dtype='datetime64[ns, Europe/Berlin]', freq='H')\n\n    >>> dti.tz_convert(None)\n    DatetimeIndex(['2014-08-01 07:00:00',\n                   '2014-08-01 08:00:00',\n                   '2014-08-01 09:00:00'],\n                    dtype='datetime64[ns]', freq='H')\n    \"\"\"\n    tz = timezones.maybe_get_tz(tz)\n\n    if self.tz is None:\n        # tz naive, use tz_localize\n        raise TypeError(\n            \"Cannot convert tz-naive timestamps, use tz_localize to localize\"\n        )\n\n    # No conversion since timestamps are all UTC to begin with\n    dtype = tz_to_dtype(tz)\n    return self._simple_new(self.asi8, dtype=dtype, freq=self.freq)",
                                "signature": "tz_convert(self, tz)"
                            },
                            {
                                "code": "    def tz_localize(self, tz, ambiguous=\"raise\", nonexistent=\"raise\"):\n        \"\"\"\n        Localize tz-naive Datetime Array/Index to tz-aware\n        Datetime Array/Index.\n\n        This method takes a time zone (tz) naive Datetime Array/Index object\n        and makes this time zone aware. It does not move the time to another\n        time zone.\n        Time zone localization helps to switch from time zone aware to time\n        zone unaware objects.\n\n        Parameters\n        ----------\n        tz : str, pytz.timezone, dateutil.tz.tzfile or None\n            Time zone to convert timestamps to. Passing ``None`` will\n            remove the time zone information preserving local time.\n        ambiguous : 'infer', 'NaT', bool array, default 'raise'\n            When clocks moved backward due to DST, ambiguous times may arise.\n            For example in Central European Time (UTC+01), when going from\n            03:00 DST to 02:00 non-DST, 02:30:00 local time occurs both at\n            00:30:00 UTC and at 01:30:00 UTC. In such a situation, the\n            `ambiguous` parameter dictates how ambiguous times should be\n            handled.\n\n            - 'infer' will attempt to infer fall dst-transition hours based on\n              order\n            - bool-ndarray where True signifies a DST time, False signifies a\n              non-DST time (note that this flag is only applicable for\n              ambiguous times)\n            - 'NaT' will return NaT where there are ambiguous times\n            - 'raise' will raise an AmbiguousTimeError if there are ambiguous\n              times.\n\n        nonexistent : 'shift_forward', 'shift_backward, 'NaT', timedelta, \\\ndefault 'raise'\n            A nonexistent time does not exist in a particular timezone\n            where clocks moved forward due to DST.\n\n            - 'shift_forward' will shift the nonexistent time forward to the\n              closest existing time\n            - 'shift_backward' will shift the nonexistent time backward to the\n              closest existing time\n            - 'NaT' will return NaT where there are nonexistent times\n            - timedelta objects will shift nonexistent times by the timedelta\n            - 'raise' will raise an NonExistentTimeError if there are\n              nonexistent times.\n\n            .. versionadded:: 0.24.0\n\n        Returns\n        -------\n        Same type as self\n            Array/Index converted to the specified time zone.\n\n        Raises\n        ------\n        TypeError\n            If the Datetime Array/Index is tz-aware and tz is not None.\n\n        See Also\n        --------\n        DatetimeIndex.tz_convert : Convert tz-aware DatetimeIndex from\n            one time zone to another.\n\n        Examples\n        --------\n        >>> tz_naive = pd.date_range('2018-03-01 09:00', periods=3)\n        >>> tz_naive\n        DatetimeIndex(['2018-03-01 09:00:00', '2018-03-02 09:00:00',\n                       '2018-03-03 09:00:00'],\n                      dtype='datetime64[ns]', freq='D')\n\n        Localize DatetimeIndex in US/Eastern time zone:\n\n        >>> tz_aware = tz_naive.tz_localize(tz='US/Eastern')\n        >>> tz_aware\n        DatetimeIndex(['2018-03-01 09:00:00-05:00',\n                       '2018-03-02 09:00:00-05:00',\n                       '2018-03-03 09:00:00-05:00'],\n                      dtype='datetime64[ns, US/Eastern]', freq='D')\n\n        With the ``tz=None``, we can remove the time zone information\n        while keeping the local time (not converted to UTC):\n\n        >>> tz_aware.tz_localize(None)\n        DatetimeIndex(['2018-03-01 09:00:00', '2018-03-02 09:00:00',\n                       '2018-03-03 09:00:00'],\n                      dtype='datetime64[ns]', freq='D')\n\n        Be careful with DST changes. When there is sequential data, pandas can\n        infer the DST time:\n\n        >>> s = pd.to_datetime(pd.Series(['2018-10-28 01:30:00',\n        ...                               '2018-10-28 02:00:00',\n        ...                               '2018-10-28 02:30:00',\n        ...                               '2018-10-28 02:00:00',\n        ...                               '2018-10-28 02:30:00',\n        ...                               '2018-10-28 03:00:00',\n        ...                               '2018-10-28 03:30:00']))\n        >>> s.dt.tz_localize('CET', ambiguous='infer')\n        0   2018-10-28 01:30:00+02:00\n        1   2018-10-28 02:00:00+02:00\n        2   2018-10-28 02:30:00+02:00\n        3   2018-10-28 02:00:00+01:00\n        4   2018-10-28 02:30:00+01:00\n        5   2018-10-28 03:00:00+01:00\n        6   2018-10-28 03:30:00+01:00\n        dtype: datetime64[ns, CET]\n\n        In some cases, inferring the DST is impossible. In such cases, you can\n        pass an ndarray to the ambiguous parameter to set the DST explicitly\n\n        >>> s = pd.to_datetime(pd.Series(['2018-10-28 01:20:00',\n        ...                               '2018-10-28 02:36:00',\n        ...                               '2018-10-28 03:46:00']))\n        >>> s.dt.tz_localize('CET', ambiguous=np.array([True, True, False]))\n        0   2018-10-28 01:20:00+02:00\n        1   2018-10-28 02:36:00+02:00\n        2   2018-10-28 03:46:00+01:00\n        dtype: datetime64[ns, CET]\n\n        If the DST transition causes nonexistent times, you can shift these\n        dates forward or backwards with a timedelta object or `'shift_forward'`\n        or `'shift_backwards'`.\n\n        >>> s = pd.to_datetime(pd.Series(['2015-03-29 02:30:00',\n        ...                               '2015-03-29 03:30:00']))\n        >>> s.dt.tz_localize('Europe/Warsaw', nonexistent='shift_forward')\n        0   2015-03-29 03:00:00+02:00\n        1   2015-03-29 03:30:00+02:00\n        dtype: datetime64[ns, Europe/Warsaw]\n\n        >>> s.dt.tz_localize('Europe/Warsaw', nonexistent='shift_backward')\n        0   2015-03-29 01:59:59.999999999+01:00\n        1   2015-03-29 03:30:00+02:00\n        dtype: datetime64[ns, Europe/Warsaw]\n\n        >>> s.dt.tz_localize('Europe/Warsaw', nonexistent=pd.Timedelta('1H'))\n        0   2015-03-29 03:30:00+02:00\n        1   2015-03-29 03:30:00+02:00\n        dtype: datetime64[ns, Europe/Warsaw]\n        \"\"\"\n        nonexistent_options = (\"raise\", \"NaT\", \"shift_forward\", \"shift_backward\")\n        if nonexistent not in nonexistent_options and not isinstance(\n            nonexistent, timedelta\n        ):\n            raise ValueError(\n                \"The nonexistent argument must be one of 'raise', \"\n                \"'NaT', 'shift_forward', 'shift_backward' or \"\n                \"a timedelta object\"\n            )\n\n        if self.tz is not None:\n            if tz is None:\n                new_dates = tzconversion.tz_convert(self.asi8, timezones.UTC, self.tz)\n            else:\n                raise TypeError(\"Already tz-aware, use tz_convert to convert.\")\n        else:\n            tz = timezones.maybe_get_tz(tz)\n            # Convert to UTC\n\n            new_dates = conversion.tz_localize_to_utc(\n                self.asi8, tz, ambiguous=ambiguous, nonexistent=nonexistent\n            )\n        new_dates = new_dates.view(DT64NS_DTYPE)\n        dtype = tz_to_dtype(tz)\n        return self._simple_new(new_dates, dtype=dtype, freq=self.freq)",
                                "signature": "tz_localize(self, tz, ambiguous='raise', nonexistent='raise')"
                            },
                            {
                                "code": "def to_pydatetime(self) -> np.ndarray:\n    \"\"\"\n    Return Datetime Array/Index as object ndarray of datetime.datetime\n    objects.\n\n    Returns\n    -------\n    datetimes : ndarray\n    \"\"\"\n    return tslib.ints_to_pydatetime(self.asi8, tz=self.tz)",
                                "signature": "to_pydatetime(self) -> np.ndarray"
                            },
                            {
                                "code": "def normalize(self):\n    \"\"\"\n    Convert times to midnight.\n\n    The time component of the date-time is converted to midnight i.e.\n    00:00:00. This is useful in cases, when the time does not matter.\n    Length is unaltered. The timezones are unaffected.\n\n    This method is available on Series with datetime values under\n    the ``.dt`` accessor, and directly on Datetime Array/Index.\n\n    Returns\n    -------\n    DatetimeArray, DatetimeIndex or Series\n        The same type as the original data. Series will have the same\n        name and index. DatetimeIndex will have the same name.\n\n    See Also\n    --------\n    floor : Floor the datetimes to the specified freq.\n    ceil : Ceil the datetimes to the specified freq.\n    round : Round the datetimes to the specified freq.\n\n    Examples\n    --------\n    >>> idx = pd.date_range(start='2014-08-01 10:00', freq='H',\n    ...                     periods=3, tz='Asia/Calcutta')\n    >>> idx\n    DatetimeIndex(['2014-08-01 10:00:00+05:30',\n                   '2014-08-01 11:00:00+05:30',\n                   '2014-08-01 12:00:00+05:30'],\n                    dtype='datetime64[ns, Asia/Calcutta]', freq='H')\n    >>> idx.normalize()\n    DatetimeIndex(['2014-08-01 00:00:00+05:30',\n                   '2014-08-01 00:00:00+05:30',\n                   '2014-08-01 00:00:00+05:30'],\n                   dtype='datetime64[ns, Asia/Calcutta]', freq=None)\n    \"\"\"\n    if self.tz is None or timezones.is_utc(self.tz):\n        not_null = ~self.isna()\n        DAY_NS = ccalendar.DAY_SECONDS * 1_000_000_000\n        new_values = self.asi8.copy()\n        adjustment = new_values[not_null] % DAY_NS\n        new_values[not_null] = new_values[not_null] - adjustment\n    else:\n        new_values = conversion.normalize_i8_timestamps(self.asi8, self.tz)\n    return type(self)(new_values)._with_freq(\"infer\").tz_localize(self.tz)",
                                "signature": "normalize(self)"
                            },
                            {
                                "code": "def to_period(self, freq=None):\n    \"\"\"\n    Cast to PeriodArray/Index at a particular frequency.\n\n    Converts DatetimeArray/Index to PeriodArray/Index.\n\n    Parameters\n    ----------\n    freq : str or Offset, optional\n        One of pandas' :ref:`offset strings <timeseries.offset_aliases>`\n        or an Offset object. Will be inferred by default.\n\n    Returns\n    -------\n    PeriodArray/Index\n\n    Raises\n    ------\n    ValueError\n        When converting a DatetimeArray/Index with non-regular values,\n        so that a frequency cannot be inferred.\n\n    See Also\n    --------\n    PeriodIndex: Immutable ndarray holding ordinal values.\n    DatetimeIndex.to_pydatetime: Return DatetimeIndex as object.\n\n    Examples\n    --------\n    >>> df = pd.DataFrame({\"y\": [1, 2, 3]},\n    ...                   index=pd.to_datetime([\"2000-03-31 00:00:00\",\n    ...                                         \"2000-05-31 00:00:00\",\n    ...                                         \"2000-08-31 00:00:00\"]))\n    >>> df.index.to_period(\"M\")\n    PeriodIndex(['2000-03', '2000-05', '2000-08'],\n                dtype='period[M]', freq='M')\n\n    Infer the daily frequency\n\n    >>> idx = pd.date_range(\"2017-01-01\", periods=2)\n    >>> idx.to_period()\n    PeriodIndex(['2017-01-01', '2017-01-02'],\n                dtype='period[D]', freq='D')\n    \"\"\"\n    from pandas.core.arrays import PeriodArray\n\n    if self.tz is not None:\n        warnings.warn(\n            \"Converting to PeriodArray/Index representation \"\n            \"will drop timezone information.\",\n            UserWarning,\n        )\n\n    if freq is None:\n        freq = self.freqstr or self.inferred_freq\n\n        if freq is None:\n            raise ValueError(\n                \"You must pass a freq argument as current index has none.\"\n            )\n\n        res = get_period_alias(freq)\n\n        #  https://github.com/pandas-dev/pandas/issues/33358\n        if res is None:\n            base, stride = libfrequencies._base_and_stride(freq)\n            res = f\"{stride}{base}\"\n\n        freq = res\n\n    return PeriodArray._from_datetime64(self._data, freq, tz=self.tz)",
                                "signature": "to_period(self, freq=None)"
                            },
                            {
                                "code": "def to_perioddelta(self, freq):\n    \"\"\"\n    Calculate TimedeltaArray of difference between index\n    values and index converted to PeriodArray at specified\n    freq. Used for vectorized offsets.\n\n    Parameters\n    ----------\n    freq : Period frequency\n\n    Returns\n    -------\n    TimedeltaArray/Index\n    \"\"\"\n    # TODO: consider privatizing (discussion in GH#23113)\n    from pandas.core.arrays.timedeltas import TimedeltaArray\n\n    i8delta = self.asi8 - self.to_period(freq).to_timestamp().asi8\n    m8delta = i8delta.view(\"m8[ns]\")\n    return TimedeltaArray(m8delta)",
                                "signature": "to_perioddelta(self, freq)"
                            },
                            {
                                "code": "def month_name(self, locale=None):\n    \"\"\"\n    Return the month names of the DateTimeIndex with specified locale.\n\n    .. versionadded:: 0.23.0\n\n    Parameters\n    ----------\n    locale : str, optional\n        Locale determining the language in which to return the month name.\n        Default is English locale.\n\n    Returns\n    -------\n    Index\n        Index of month names.\n\n    Examples\n    --------\n    >>> idx = pd.date_range(start='2018-01', freq='M', periods=3)\n    >>> idx\n    DatetimeIndex(['2018-01-31', '2018-02-28', '2018-03-31'],\n                  dtype='datetime64[ns]', freq='M')\n    >>> idx.month_name()\n    Index(['January', 'February', 'March'], dtype='object')\n    \"\"\"\n    if self.tz is not None and not timezones.is_utc(self.tz):\n        values = self._local_timestamps()\n    else:\n        values = self.asi8\n\n    result = fields.get_date_name_field(values, \"month_name\", locale=locale)\n    result = self._maybe_mask_results(result, fill_value=None)\n    return result",
                                "signature": "month_name(self, locale=None)"
                            },
                            {
                                "code": "def day_name(self, locale=None):\n    \"\"\"\n    Return the day names of the DateTimeIndex with specified locale.\n\n    .. versionadded:: 0.23.0\n\n    Parameters\n    ----------\n    locale : str, optional\n        Locale determining the language in which to return the day name.\n        Default is English locale.\n\n    Returns\n    -------\n    Index\n        Index of day names.\n\n    Examples\n    --------\n    >>> idx = pd.date_range(start='2018-01-01', freq='D', periods=3)\n    >>> idx\n    DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03'],\n                  dtype='datetime64[ns]', freq='D')\n    >>> idx.day_name()\n    Index(['Monday', 'Tuesday', 'Wednesday'], dtype='object')\n    \"\"\"\n    if self.tz is not None and not timezones.is_utc(self.tz):\n        values = self._local_timestamps()\n    else:\n        values = self.asi8\n\n    result = fields.get_date_name_field(values, \"day_name\", locale=locale)\n    result = self._maybe_mask_results(result, fill_value=None)\n    return result",
                                "signature": "day_name(self, locale=None)"
                            },
                            {
                                "code": "@property\ndef time(self):\n    \"\"\"\n    Returns numpy array of datetime.time. The time part of the Timestamps.\n    \"\"\"\n    # If the Timestamps have a timezone that is not UTC,\n    # convert them into their i8 representation while\n    # keeping their timezone and not using UTC\n    if self.tz is not None and not timezones.is_utc(self.tz):\n        timestamps = self._local_timestamps()\n    else:\n        timestamps = self.asi8\n\n    return tslib.ints_to_pydatetime(timestamps, box=\"time\")",
                                "signature": "time(self)"
                            },
                            {
                                "code": "@property\ndef timetz(self):\n    \"\"\"\n    Returns numpy array of datetime.time also containing timezone\n    information. The time part of the Timestamps.\n    \"\"\"\n    return tslib.ints_to_pydatetime(self.asi8, self.tz, box=\"time\")",
                                "signature": "timetz(self)"
                            },
                            {
                                "code": "@property\ndef date(self):\n    \"\"\"\n    Returns numpy array of python datetime.date objects (namely, the date\n    part of Timestamps without timezone information).\n    \"\"\"\n    # If the Timestamps have a timezone that is not UTC,\n    # convert them into their i8 representation while\n    # keeping their timezone and not using UTC\n    if self.tz is not None and not timezones.is_utc(self.tz):\n        timestamps = self._local_timestamps()\n    else:\n        timestamps = self.asi8\n\n    return tslib.ints_to_pydatetime(timestamps, box=\"date\")",
                                "signature": "date(self)"
                            },
                            {
                                "code": "def isocalendar(self):\n    \"\"\"\n    Returns a DataFrame with the year, week, and day calculated according to\n    the ISO 8601 standard.\n\n    .. versionadded:: 1.1.0\n\n    Returns\n    -------\n    DataFrame\n        with columns year, week and day\n\n    See Also\n    --------\n    Timestamp.isocalendar\n    datetime.date.isocalendar\n\n    Examples\n    --------\n    >>> idx = pd.date_range(start='2019-12-29', freq='D', periods=4)\n    >>> idx.isocalendar()\n       year  week  day\n    0  2019    52    7\n    1  2020     1    1\n    2  2020     1    2\n    3  2020     1    3\n    >>> idx.isocalendar().week\n    0    52\n    1     1\n    2     1\n    3     1\n    Name: week, dtype: UInt32\n    \"\"\"\n    from pandas import DataFrame\n\n    if self.tz is not None and not timezones.is_utc(self.tz):\n        values = self._local_timestamps()\n    else:\n        values = self.asi8\n    sarray = fields.build_isocalendar_sarray(values)\n    iso_calendar_df = DataFrame(\n        sarray, columns=[\"year\", \"week\", \"day\"], dtype=\"UInt32\"\n    )\n    if self._hasnans:\n        iso_calendar_df.iloc[self._isnan] = None\n    return iso_calendar_df",
                                "signature": "isocalendar(self)"
                            },
                            {
                                "code": "def to_julian_date(self):\n    \"\"\"\n    Convert Datetime Array to float64 ndarray of Julian Dates.\n    0 Julian date is noon January 1, 4713 BC.\n    https://en.wikipedia.org/wiki/Julian_day\n    \"\"\"\n\n    # http://mysite.verizon.net/aesir_research/date/jdalg2.htm\n    year = np.asarray(self.year)\n    month = np.asarray(self.month)\n    day = np.asarray(self.day)\n    testarr = month < 3\n    year[testarr] -= 1\n    month[testarr] += 12\n    return (\n        day\n        + np.fix((153 * month - 457) / 5)\n        + 365 * year\n        + np.floor(year / 4)\n        - np.floor(year / 100)\n        + np.floor(year / 400)\n        + 1_721_118.5\n        + (\n            self.hour\n            + self.minute / 60.0\n            + self.second / 3600.0\n            + self.microsecond / 3600.0 / 1e6\n            + self.nanosecond / 3600.0 / 1e9\n        )\n        / 24.0\n    )",
                                "signature": "to_julian_date(self)"
                            }
                        ]
                    }
                ]
            },
            "variables_in_file": {
                "_midnight": [
                    2286,
                    2293,
                    54
                ],
                "time": [
                    54
                ],
                "tz": [
                    384,
                    513,
                    1925,
                    391,
                    1931,
                    396,
                    1940,
                    1942,
                    2326,
                    1944,
                    411,
                    413,
                    798,
                    1954,
                    1955,
                    421,
                    423,
                    807,
                    2221,
                    2223,
                    433,
                    1969,
                    1971,
                    2225,
                    2228,
                    313,
                    2234,
                    443,
                    317,
                    963,
                    325,
                    69,
                    72,
                    968,
                    972,
                    975,
                    2136,
                    2137,
                    2266,
                    2140,
                    2268,
                    2269,
                    2143,
                    2145,
                    2273,
                    2275,
                    1902,
                    382
                ],
                "DT64NS_DTYPE": [
                    288,
                    290,
                    2083,
                    2180,
                    70,
                    1959,
                    1948,
                    974,
                    1937,
                    213,
                    250,
                    252,
                    286,
                    1946
                ],
                "DatetimeTZDtype": [
                    223,
                    2212,
                    2181,
                    72,
                    210,
                    276,
                    479
                ],
                "values": [
                    1281,
                    1283,
                    1284,
                    267,
                    1163,
                    1165,
                    1167,
                    278,
                    408,
                    409,
                    287,
                    288,
                    289,
                    290,
                    293,
                    686,
                    1198,
                    688,
                    689,
                    1200,
                    1202,
                    77,
                    79,
                    214,
                    215,
                    217,
                    90,
                    219,
                    93,
                    222,
                    224,
                    225,
                    99,
                    228,
                    103,
                    231,
                    232,
                    2026,
                    235,
                    236,
                    2029,
                    238,
                    240,
                    243,
                    246,
                    250,
                    252,
                    255
                ],
                "self.asi8": [
                    1283,
                    1033,
                    1037,
                    1165,
                    540,
                    671,
                    544,
                    808,
                    1200,
                    566,
                    1217,
                    964,
                    1227,
                    972,
                    77,
                    717,
                    1241,
                    732,
                    990,
                    617,
                    1129
                ],
                "self": [
                    1030,
                    1031,
                    1033,
                    1037,
                    526,
                    1038,
                    533,
                    540,
                    544,
                    550,
                    566,
                    567,
                    574,
                    1086,
                    1094,
                    586,
                    77,
                    78,
                    79,
                    589,
                    81,
                    590,
                    83,
                    591,
                    1110,
                    600,
                    90,
                    602,
                    603,
                    605,
                    606,
                    98,
                    100,
                    614,
                    104,
                    617,
                    618,
                    1129,
                    624,
                    642,
                    1162,
                    1163,
                    1165,
                    1168,
                    657,
                    662,
                    664,
                    667,
                    671,
                    673,
                    675,
                    680,
                    681,
                    685,
                    686,
                    1197,
                    688,
                    689,
                    1198,
                    1200,
                    1203,
                    696,
                    697,
                    699,
                    701,
                    1214,
                    1215,
                    1217,
                    709,
                    711,
                    1227,
                    717,
                    718,
                    719,
                    1238,
                    1239,
                    1241,
                    219,
                    732,
                    1280,
                    1281,
                    1283,
                    1288,
                    1289,
                    278,
                    279,
                    280,
                    1817,
                    1818,
                    283,
                    1819,
                    800,
                    808,
                    1832,
                    1833,
                    1834,
                    1835,
                    1836,
                    450,
                    962,
                    964,
                    453,
                    457,
                    972,
                    462,
                    976,
                    465,
                    466,
                    469,
                    476,
                    990,
                    498,
                    511
                ],
                "self.tz": [
                    1280,
                    642,
                    1030,
                    1162,
                    1037,
                    526,
                    1038,
                    540,
                    544,
                    800,
                    550,
                    685,
                    1197,
                    689,
                    699,
                    574,
                    1086,
                    1214,
                    962,
                    964,
                    457,
                    1227,
                    78,
                    465,
                    466,
                    1110,
                    1238,
                    732,
                    476,
                    990,
                    617
                ],
                "timezones.is_utc": [
                    1280,
                    1030,
                    1162,
                    1197,
                    78,
                    1238,
                    1214
                ],
                "timezones": [
                    1280,
                    1030,
                    1162,
                    276,
                    533,
                    1942,
                    798,
                    1955,
                    1197,
                    2221,
                    2228,
                    1214,
                    964,
                    968,
                    78,
                    465,
                    2258,
                    1238,
                    2265,
                    2266,
                    2140,
                    2269,
                    225,
                    630
                ],
                "self._local_timestamps": [
                    1281,
                    1163,
                    1198,
                    79,
                    1239,
                    1215
                ],
                "field": [
                    98,
                    99,
                    103,
                    81,
                    82,
                    90,
                    93
                ],
                "self._bool_ops": [
                    81
                ],
                "field.endswith": [
                    82
                ],
                "freq": [
                    260,
                    390,
                    268,
                    269,
                    396,
                    398,
                    402,
                    2325,
                    280,
                    408,
                    282,
                    283,
                    409,
                    294,
                    311,
                    444,
                    323,
                    1093,
                    326,
                    1094,
                    328,
                    1096,
                    330,
                    1101,
                    1105,
                    83,
                    1108,
                    85,
                    86,
                    1110,
                    354,
                    357,
                    1129,
                    234,
                    235,
                    362
                ],
                "self.freq": [
                    808,
                    976,
                    83,
                    476,
                    574
                ],
                "month_kw": [
                    90,
                    84,
                    87
                ],
                "kwds": [
                    86,
                    87
                ],
                "freq.kwds": [
                    86
                ],
                "kwds.get": [
                    87
                ],
                "result": [
                    2049,
                    2050,
                    2054,
                    1932,
                    1167,
                    1168,
                    1169,
                    1949,
                    292,
                    293,
                    294,
                    295,
                    296,
                    1959,
                    1963,
                    1965,
                    1966,
                    689,
                    1202,
                    1203,
                    1204,
                    1971,
                    696,
                    699,
                    701,
                    326,
                    330,
                    718,
                    335,
                    591,
                    337,
                    593,
                    719,
                    720,
                    598,
                    599,
                    89,
                    93,
                    96,
                    2016,
                    99,
                    100,
                    103,
                    104,
                    105,
                    108,
                    2037,
                    2038,
                    2041,
                    2042
                ],
                "fields.get_start_end_field": [
                    89
                ],
                "fields": [
                    99,
                    1284,
                    103,
                    1167,
                    1202,
                    89,
                    93
                ],
                "self.freqstr": [
                    90,
                    1094
                ],
                "fields.get_date_field": [
                    93,
                    103
                ],
                "self._object_ops": [
                    98
                ],
                "fields.get_date_name_field": [
                    1202,
                    99,
                    1167
                ],
                "self._maybe_mask_results": [
                    100,
                    104,
                    719,
                    1168,
                    1203
                ],
                "f.__name__": [
                    110
                ],
                "f": [
                    112,
                    110,
                    111
                ],
                "name": [
                    110
                ],
                "f.__doc__": [
                    111
                ],
                "docstring": [
                    111
                ],
                "property": [
                    1221,
                    542,
                    521,
                    1229,
                    112,
                    528,
                    500,
                    1206,
                    535,
                    474,
                    478
                ],
                "dtl.DatetimeLikeArrayMixin": [
                    115,
                    606
                ],
                "dtl": [
                    353,
                    323,
                    115,
                    311,
                    378,
                    606
                ],
                "dtl.TimelikeOps": [
                    115
                ],
                "dtl.DatelikeOps": [
                    115
                ],
                "_typ": [
                    152
                ],
                "_scalar_type": [
                    153
                ],
                "Timestamp": [
                    707,
                    457,
                    365,
                    368,
                    629,
                    153,
                    476
                ],
                "_recognized_scalars": [
                    154
                ],
                "datetime": [
                    705,
                    154
                ],
                "np.datetime64": [
                    705,
                    154,
                    627
                ],
                "np": [
                    2180,
                    2181,
                    660,
                    1817,
                    154,
                    1819,
                    1818,
                    287,
                    1825,
                    1827,
                    1828,
                    549,
                    1829,
                    1958,
                    1965,
                    430,
                    2108,
                    705,
                    210,
                    981,
                    2013,
                    479,
                    1887,
                    1890,
                    238,
                    627,
                    2172,
                    1918
                ],
                "_is_recognized_dtype": [
                    155
                ],
                "is_datetime64_any_dtype": [
                    155
                ],
                "_bool_ops": [
                    187,
                    158
                ],
                "_object_ops": [
                    187,
                    167
                ],
                "_field_ops": [
                    168,
                    187
                ],
                "_other_ops": [
                    186,
                    187
                ],
                "_datetimelike_ops": [
                    187
                ],
                "_datetimelike_methods": [
                    188
                ],
                "__array_priority__": [
                    205
                ],
                "_dtype": [
                    210
                ],
                "Union": [
                    210,
                    479
                ],
                "np.dtype": [
                    2180,
                    2181,
                    210,
                    2172,
                    479
                ],
                "_freq": [
                    211
                ],
                "isinstance": [
                    705,
                    450,
                    2210,
                    1892,
                    2180,
                    1894,
                    683,
                    1965,
                    238,
                    1904,
                    402,
                    627,
                    660,
                    2325,
                    214,
                    953,
                    219,
                    287
                ],
                "ABCSeries": [
                    1892,
                    214
                ],
                "ABCIndexClass": [
                    1904,
                    214
                ],
                "values._values": [
                    215
                ],
                "inferred_freq": [
                    323,
                    313,
                    328,
                    1899,
                    1971,
                    1881,
                    217,
                    282
                ],
                "getattr": [
                    388,
                    2219,
                    396,
                    588,
                    270,
                    589,
                    1936,
                    630,
                    217,
                    635,
                    221,
                    511
                ],
                "type": [
                    701,
                    1965,
                    219,
                    1038,
                    240,
                    662,
                    283,
                    667,
                    699
                ],
                "dtz": [
                    224,
                    225,
                    228,
                    2219,
                    2220,
                    2221,
                    2223,
                    2228,
                    221,
                    222
                ],
                "dtype": [
                    258,
                    2180,
                    2181,
                    2184,
                    2187,
                    270,
                    276,
                    279,
                    2209,
                    2210,
                    2212,
                    550,
                    295,
                    552,
                    807,
                    554,
                    808,
                    2219,
                    433,
                    1969,
                    435,
                    2225,
                    443,
                    315,
                    444,
                    325,
                    326,
                    584,
                    586,
                    588,
                    975,
                    976,
                    600,
                    1883,
                    604,
                    221,
                    605,
                    223,
                    606,
                    232,
                    1902,
                    2170,
                    2171,
                    2172
                ],
                "values.tz": [
                    224,
                    225,
                    228,
                    231,
                    222
                ],
                "dtype.tz": [
                    276,
                    223
                ],
                "timezones.tz_compare": [
                    225,
                    2221,
                    465,
                    2228,
                    2140,
                    2269
                ],
                "msg": [
                    226,
                    2174,
                    230,
                    2178
                ],
                "TypeError": [
                    802,
                    2050,
                    644,
                    2213,
                    230,
                    966,
                    648,
                    713,
                    2054,
                    2090,
                    2030,
                    2094,
                    1907,
                    2261,
                    666,
                    2141
                ],
                "values.dtype": [
                    288,
                    289,
                    232,
                    246,
                    252,
                    255
                ],
                "values.freq": [
                    235
                ],
                "values._data": [
                    236
                ],
                "np.ndarray": [
                    549,
                    1965,
                    238,
                    660,
                    981,
                    287
                ],
                "ValueError": [
                    2178,
                    261,
                    2183,
                    658,
                    2222,
                    2229,
                    956,
                    451,
                    1097,
                    466,
                    355,
                    358,
                    2024,
                    2030,
                    239,
                    244,
                    372,
                    376,
                    253
                ],
                "__name__": [
                    240,
                    667
                ],
                "values.ndim": [
                    243
                ],
                "values.view": [
                    250,
                    290,
                    2029
                ],
                "_validate_dt64_dtype": [
                    258,
                    1883
                ],
                "copy": [
                    1891,
                    2084,
                    1916,
                    1961,
                    266,
                    592,
                    2103,
                    2078,
                    1911,
                    601,
                    316,
                    2109,
                    606,
                    2111
                ],
                "values.copy": [
                    267
                ],
                "to_offset": [
                    362,
                    269,
                    335
                ],
                "timezones.tz_standardize": [
                    276
                ],
                "self._data": [
                    1110,
                    278
                ],
                "self._dtype": [
                    498,
                    279
                ],
                "self._freq": [
                    280,
                    469
                ],
                "_validate_frequency": [
                    283
                ],
                "object.__new__": [
                    292
                ],
                "object": [
                    552,
                    292
                ],
                "cls": [
                    416,
                    292,
                    326,
                    330,
                    434,
                    409,
                    444
                ],
                "result._data": [
                    293,
                    598
                ],
                "result._freq": [
                    294,
                    335
                ],
                "result._dtype": [
                    295
                ],
                "classmethod": [
                    298,
                    339,
                    285
                ],
                "freq_infer": [
                    323,
                    332,
                    311
                ],
                "dtl.maybe_infer_freq": [
                    311
                ],
                "subarr": [
                    313,
                    326
                ],
                "sequence_to_dt64ns": [
                    313
                ],
                "data": [
                    1922,
                    1923,
                    1929,
                    1931,
                    1932,
                    1934,
                    1936,
                    1937,
                    1938,
                    1943,
                    1944,
                    1946,
                    1948,
                    1949,
                    2076,
                    2078,
                    2080,
                    2083,
                    1957,
                    1958,
                    1959,
                    2088,
                    2090,
                    2091,
                    2098,
                    566,
                    2102,
                    2105,
                    314,
                    2108,
                    574,
                    2111,
                    1885,
                    2013,
                    1887,
                    1889,
                    1890,
                    2017,
                    1892,
                    1893,
                    1894,
                    1895,
                    1897,
                    2026,
                    1899,
                    1904,
                    1905,
                    1908,
                    1911,
                    1913,
                    1917,
                    1918
                ],
                "dayfirst": [
                    1923,
                    2020,
                    318
                ],
                "yearfirst": [
                    1923,
                    2021,
                    319
                ],
                "ambiguous": [
                    320,
                    392,
                    330,
                    396,
                    972,
                    2323,
                    2324,
                    1944,
                    413
                ],
                "dtl.validate_inferred_freq": [
                    323
                ],
                "tz_to_dtype": [
                    325,
                    807,
                    975,
                    433,
                    409,
                    443
                ],
                "cls._simple_new": [
                    409,
                    434,
                    444,
                    326
                ],
                "cls._validate_frequency": [
                    330
                ],
                "result.inferred_freq": [
                    335
                ],
                "periods": [
                    353,
                    354,
                    357,
                    430,
                    408
                ],
                "dtl.validate_periods": [
                    353
                ],
                "any": [
                    354
                ],
                "x": [
                    354,
                    476
                ],
                "start": [
                    386,
                    387,
                    388,
                    389,
                    403,
                    404,
                    408,
                    2295,
                    420,
                    421,
                    430,
                    431,
                    438,
                    2258,
                    354,
                    357,
                    2281,
                    2283,
                    364,
                    365,
                    2286,
                    370,
                    375,
                    380,
                    382
                ],
                "end": [
                    395,
                    396,
                    405,
                    406,
                    408,
                    2295,
                    422,
                    423,
                    430,
                    440,
                    2258,
                    354,
                    357,
                    367,
                    368,
                    2288,
                    370,
                    2290,
                    2293,
                    375,
                    380,
                    382
                ],
                "com.count_not_none": [
                    357
                ],
                "com": [
                    357
                ],
                "closed": [
                    378,
                    371
                ],
                "NaT": [
                    706,
                    450,
                    708,
                    709,
                    460,
                    2102,
                    375,
                    639
                ],
                "left_closed": [
                    378,
                    438
                ],
                "right_closed": [
                    440,
                    378
                ],
                "dtl.validate_endpoints": [
                    378
                ],
                "_normalized": [
                    2279,
                    2284,
                    2286,
                    2291,
                    2293,
                    2295,
                    380
                ],
                "_maybe_normalize_endpoints": [
                    380
                ],
                "normalize": [
                    2289,
                    2282,
                    380
                ],
                "_infer_tz_from_endpoints": [
                    382
                ],
                "_maybe_localize_point": [
                    386,
                    395
                ],
                "nonexistent": [
                    393,
                    396,
                    972,
                    2324,
                    953,
                    954,
                    413
                ],
                "Day": [
                    402
                ],
                "start.tz_localize": [
                    404,
                    421
                ],
                "end.tz_localize": [
                    406,
                    423
                ],
                "_tz": [
                    408,
                    409
                ],
                "generate_regular_range": [
                    408
                ],
                "index": [
                    416,
                    441,
                    434,
                    438,
                    439,
                    440,
                    409,
                    411,
                    444,
                    413
                ],
                "index.tz": [
                    411
                ],
                "arr": [
                    416,
                    435,
                    412,
                    429
                ],
                "conversion.tz_localize_to_utc": [
                    971,
                    412,
                    1943
                ],
                "conversion": [
                    2026,
                    971,
                    1037,
                    1938,
                    1943,
                    412,
                    540
                ],
                "index.asi8": [
                    444,
                    413
                ],
                "asm8": [
                    421,
                    423
                ],
                "np.linspace": [
                    430
                ],
                "end.value": [
                    430
                ],
                "start.value": [
                    430,
                    431
                ],
                "arr.astype": [
                    435
                ],
                "len": [
                    657,
                    438,
                    567,
                    440,
                    697
                ],
                "value": [
                    450,
                    452,
                    453,
                    454,
                    457
                ],
                "self._scalar_type": [
                    450
                ],
                "isna": [
                    452
                ],
                "self._check_compatible_with": [
                    453
                ],
                "value.value": [
                    454
                ],
                "bool": [
                    459
                ],
                "other": [
                    657,
                    660,
                    661,
                    662,
                    664,
                    672,
                    673,
                    675,
                    705,
                    706,
                    707,
                    708,
                    711,
                    460,
                    462,
                    718,
                    465,
                    466,
                    627,
                    629,
                    630,
                    635,
                    636,
                    638,
                    639
                ],
                "self._assert_tzawareness_compat": [
                    462
                ],
                "setitem": [
                    463
                ],
                "other.tz": [
                    465,
                    466
                ],
                "self.dtype": [
                    600,
                    586,
                    589,
                    511
                ],
                "AttributeError": [
                    516
                ],
                "tz.setter": [
                    513
                ],
                "timezones.get_timezone": [
                    533,
                    630
                ],
                "self.tzinfo": [
                    533
                ],
                "conversion.is_date_array_normalized": [
                    540
                ],
                "libresolution.resolution": [
                    544
                ],
                "libresolution": [
                    544
                ],
                "__array__": [
                    554
                ],
                "super": [
                    554
                ],
                "length": [
                    569,
                    572,
                    567
                ],
                "chunksize": [
                    568,
                    569,
                    571,
                    572
                ],
                "chunks": [
                    569,
                    570
                ],
                "int": [
                    569
                ],
                "i": [
                    570,
                    571,
                    572
                ],
                "range": [
                    570
                ],
                "start_i": [
                    571,
                    574
                ],
                "end_i": [
                    572,
                    574
                ],
                "min": [
                    572
                ],
                "converted": [
                    576,
                    573
                ],
                "tslib.ints_to_pydatetime": [
                    1219,
                    1227,
                    1243,
                    573,
                    990
                ],
                "tslib": [
                    2016,
                    1219,
                    616,
                    1227,
                    1243,
                    573,
                    990
                ],
                "v": [
                    576,
                    577
                ],
                "pandas_dtype": [
                    584,
                    2171
                ],
                "is_datetime64_ns_dtype": [
                    586
                ],
                "is_dtype_equal": [
                    600,
                    586,
                    2172
                ],
                "new_tz": [
                    594,
                    588,
                    590,
                    591
                ],
                "self.tz_localize": [
                    686,
                    590
                ],
                "self.tz_convert": [
                    591
                ],
                "result.copy": [
                    593,
                    1963
                ],
                "is_datetime64tz_dtype": [
                    600,
                    1929,
                    636,
                    2105
                ],
                "self.copy": [
                    602
                ],
                "is_period_dtype": [
                    2091,
                    604
                ],
                "self.to_period": [
                    1129,
                    605
                ],
                "dtype.freq": [
                    605
                ],
                "dtl.DatetimeLikeArrayMixin.astype": [
                    606
                ],
                "fmt": [
                    617,
                    614
                ],
                "_get_format_datetime64_from_values": [
                    614
                ],
                "date_format": [
                    614
                ],
                "reshape": [
                    616,
                    681
                ],
                "tslib.format_array_from_datetime": [
                    616
                ],
                "self.asi8.ravel": [
                    617
                ],
                "na_rep": [
                    617
                ],
                "self.shape": [
                    681,
                    618
                ],
                "zzone": [
                    624,
                    631
                ],
                "self._timezone": [
                    624
                ],
                "vzone": [
                    630,
                    631
                ],
                "other_tz": [
                    635,
                    643,
                    638,
                    647
                ],
                "other.dtype.tz": [
                    638
                ],
                "other.dtype": [
                    638
                ],
                "is_datetime64_dtype": [
                    2038,
                    2225,
                    661,
                    1934
                ],
                "self._has_same_tz": [
                    664,
                    711
                ],
                "self_i8": [
                    674,
                    671
                ],
                "other_i8": [
                    672,
                    674
                ],
                "other.asi8": [
                    672
                ],
                "arr_mask": [
                    673,
                    674,
                    676
                ],
                "self._isnan": [
                    1289,
                    673,
                    718
                ],
                "other._isnan": [
                    673
                ],
                "new_values": [
                    674,
                    676,
                    677,
                    1033,
                    1034,
                    1035,
                    1037,
                    1038
                ],
                "checked_add_with_arr": [
                    674,
                    718
                ],
                "self._hasnans": [
                    1288,
                    675
                ],
                "other._hasnans": [
                    675
                ],
                "iNaT": [
                    676
                ],
                "new_values.view": [
                    677
                ],
                "self.ndim": [
                    680
                ],
                "_add_offset": [
                    681
                ],
                "self.ravel": [
                    681
                ],
                "offset": [
                    689,
                    681,
                    683,
                    696
                ],
                "Tick": [
                    683,
                    2325
                ],
                "tz_localize": [
                    689,
                    699,
                    1038
                ],
                "offset.apply_index": [
                    689
                ],
                "NotImplementedError": [
                    691
                ],
                "warnings.warn": [
                    692,
                    1087
                ],
                "warnings": [
                    692,
                    1087
                ],
                "PerformanceWarning": [
                    694
                ],
                "self.astype": [
                    696
                ],
                "_from_sequence": [
                    699,
                    701
                ],
                "_with_freq": [
                    701,
                    1038
                ],
                "i8": [
                    717,
                    718
                ],
                "other.value": [
                    718
                ],
                "result.view": [
                    720,
                    2037
                ],
                "tzconversion.tz_convert": [
                    964,
                    732
                ],
                "tzconversion": [
                    964,
                    732
                ],
                "utc": [
                    2019,
                    732
                ],
                "timezones.maybe_get_tz": [
                    1955,
                    968,
                    1942,
                    2265,
                    2266,
                    798
                ],
                "self._simple_new": [
                    808,
                    976
                ],
                "nonexistent_options": [
                    952,
                    953
                ],
                "timedelta": [
                    954
                ],
                "new_dates": [
                    976,
                    971,
                    964,
                    974
                ],
                "timezones.UTC": [
                    964
                ],
                "new_dates.view": [
                    974
                ],
                "not_null": [
                    1034,
                    1035,
                    1031
                ],
                "self.isna": [
                    1031
                ],
                "DAY_NS": [
                    1032,
                    1034
                ],
                "ccalendar.DAY_SECONDS": [
                    1032
                ],
                "ccalendar": [
                    1032
                ],
                "self.asi8.copy": [
                    1033
                ],
                "adjustment": [
                    1034,
                    1035
                ],
                "conversion.normalize_i8_timestamps": [
                    1037
                ],
                "UserWarning": [
                    1090
                ],
                "self.inferred_freq": [
                    1094
                ],
                "res": [
                    1104,
                    1106,
                    1108,
                    1101
                ],
                "get_period_alias": [
                    1101
                ],
                "base": [
                    1105,
                    1106
                ],
                "stride": [
                    1105,
                    1106
                ],
                "libfrequencies._base_and_stride": [
                    1105
                ],
                "libfrequencies": [
                    1105
                ],
                "PeriodArray._from_datetime64": [
                    1110
                ],
                "PeriodArray": [
                    1110
                ],
                "i8delta": [
                    1129,
                    1130
                ],
                "asi8": [
                    1129
                ],
                "to_timestamp": [
                    1129
                ],
                "m8delta": [
                    1130,
                    1131
                ],
                "i8delta.view": [
                    1130
                ],
                "TimedeltaArray": [
                    1131
                ],
                "locale": [
                    1202,
                    1167
                ],
                "timestamps": [
                    1217,
                    1219,
                    1239,
                    1241,
                    1243,
                    1215
                ],
                "sarray": [
                    1284,
                    1286
                ],
                "fields.build_isocalendar_sarray": [
                    1284
                ],
                "iso_calendar_df": [
                    1289,
                    1290,
                    1285
                ],
                "DataFrame": [
                    1285
                ],
                "iso_calendar_df.iloc": [
                    1289
                ],
                "year": [
                    1826,
                    1827,
                    1828,
                    1829,
                    1292,
                    1817,
                    1821
                ],
                "_field_accessor": [
                    1292,
                    1679,
                    1430,
                    1315,
                    1407,
                    1453,
                    1587,
                    1591,
                    1338,
                    1595,
                    1723,
                    1476,
                    1361,
                    1637,
                    1767,
                    1384,
                    1518,
                    1521,
                    1528,
                    1535
                ],
                "month": [
                    1825,
                    1315,
                    1818,
                    1820,
                    1822
                ],
                "day": [
                    1824,
                    1338,
                    1819
                ],
                "hour": [
                    1361
                ],
                "minute": [
                    1384
                ],
                "second": [
                    1407
                ],
                "microsecond": [
                    1430
                ],
                "nanosecond": [
                    1453
                ],
                "weekofyear": [
                    1483,
                    1476
                ],
                "week": [
                    1483
                ],
                "_dayofweek_doc": [
                    1484,
                    1518
                ],
                "dayofweek": [
                    1518,
                    1519
                ],
                "weekday": [
                    1519
                ],
                "dayofyear": [
                    1521
                ],
                "quarter": [
                    1528
                ],
                "days_in_month": [
                    1542,
                    1535
                ],
                "daysinmonth": [
                    1542
                ],
                "_is_month_doc": [
                    1592,
                    1588,
                    1543
                ],
                "is_month_start": [
                    1587
                ],
                "_is_month_doc.format": [
                    1592,
                    1588
                ],
                "is_month_end": [
                    1591
                ],
                "is_quarter_start": [
                    1595
                ],
                "is_quarter_end": [
                    1637
                ],
                "is_year_start": [
                    1679
                ],
                "is_year_end": [
                    1723
                ],
                "is_leap_year": [
                    1767
                ],
                "np.asarray": [
                    1817,
                    1818,
                    1819,
                    1890
                ],
                "self.year": [
                    1817
                ],
                "self.month": [
                    1818
                ],
                "self.day": [
                    1819
                ],
                "testarr": [
                    1820,
                    1821,
                    1822
                ],
                "np.fix": [
                    1825
                ],
                "np.floor": [
                    1827,
                    1828,
                    1829
                ],
                "self.hour": [
                    1832
                ],
                "self.minute": [
                    1833
                ],
                "self.second": [
                    1834
                ],
                "self.microsecond": [
                    1835
                ],
                "self.nanosecond": [
                    1836
                ],
                "hasattr": [
                    1897,
                    2076,
                    1885
                ],
                "np.ndim": [
                    1887
                ],
                "list": [
                    1889
                ],
                "data._values": [
                    1893
                ],
                "ABCPandasArray": [
                    1894
                ],
                "data.to_numpy": [
                    1895
                ],
                "data.freq": [
                    1899
                ],
                "validate_tz_from_dtype": [
                    1969,
                    1902
                ],
                "data.nlevels": [
                    1905
                ],
                "data._data": [
                    1932,
                    1908
                ],
                "maybe_convert_dtype": [
                    1911
                ],
                "is_object_dtype": [
                    1913,
                    2042
                ],
                "is_string_dtype": [
                    1913
                ],
                "lib.infer_dtype": [
                    1917
                ],
                "lib": [
                    1917
                ],
                "data.astype": [
                    2083,
                    1958,
                    1918
                ],
                "np.int64": [
                    1958,
                    1918
                ],
                "inferred_tz": [
                    2272,
                    2273,
                    1922,
                    2265,
                    1925,
                    2258,
                    2268,
                    2137,
                    2138,
                    2140,
                    2269,
                    2142
                ],
                "objects_to_datetime64ns": [
                    1922
                ],
                "maybe_infer_tz": [
                    1931,
                    1925
                ],
                "data.tz": [
                    1931
                ],
                "data.dtype": [
                    2080,
                    1957,
                    2088,
                    2090,
                    2091,
                    1937,
                    2098,
                    2105,
                    1948
                ],
                "conversion.ensure_datetime64ns": [
                    1938
                ],
                "data.view": [
                    1944,
                    1946,
                    1959
                ],
                "_INT64_DTYPE": [
                    1957
                ],
                "result.dtype": [
                    1966
                ],
                "errors": [
                    2010,
                    2018
                ],
                "np.array": [
                    2108,
                    2013
                ],
                "np.object_": [
                    2108,
                    2013
                ],
                "tz_parsed": [
                    2016,
                    2049,
                    2026,
                    2029,
                    2033,
                    2037,
                    2041
                ],
                "tslib.array_to_datetime": [
                    2016
                ],
                "require_iso8601": [
                    2022
                ],
                "conversion.datetime_to_datetime64": [
                    2026
                ],
                "e": [
                    2031
                ],
                "allow_object": [
                    2048
                ],
                "is_float_dtype": [
                    2080
                ],
                "is_timedelta64_dtype": [
                    2088
                ],
                "is_bool_dtype": [
                    2088
                ],
                "is_categorical_dtype": [
                    2098
                ],
                "_values": [
                    2102
                ],
                "data.categories.take": [
                    2102
                ],
                "data.categories": [
                    2102
                ],
                "data.codes": [
                    2102
                ],
                "is_extension_array_dtype": [
                    2105
                ],
                "str": [
                    2210
                ],
                "DatetimeTZDtype.construct_from_string": [
                    2212
                ],
                "timezones.infer_tzinfo": [
                    2258
                ],
                "AssertionError": [
                    2259,
                    2270
                ],
                "err": [
                    2263
                ],
                "normalize_date": [
                    2290,
                    2283
                ],
                "start.time": [
                    2286
                ],
                "end.time": [
                    2293
                ],
                "is_none": [
                    2320
                ],
                "is_not_none": [
                    2320
                ],
                "localize_args": [
                    2324,
                    2326,
                    2327
                ],
                "ts": [
                    2328,
                    2327
                ],
                "ts.tz_localize": [
                    2327
                ]
            },
            "filtered_variables_in_file": {
                "_midnight": [
                    2286,
                    2293,
                    54
                ],
                "time": [
                    54
                ],
                "tz": [
                    384,
                    513,
                    1925,
                    391,
                    1931,
                    396,
                    1940,
                    1942,
                    2326,
                    1944,
                    411,
                    413,
                    798,
                    1954,
                    1955,
                    421,
                    423,
                    807,
                    2221,
                    2223,
                    433,
                    1969,
                    1971,
                    2225,
                    2228,
                    313,
                    2234,
                    443,
                    317,
                    963,
                    325,
                    69,
                    72,
                    968,
                    972,
                    975,
                    2136,
                    2137,
                    2266,
                    2140,
                    2268,
                    2269,
                    2143,
                    2145,
                    2273,
                    2275,
                    1902,
                    382
                ],
                "DT64NS_DTYPE": [
                    288,
                    290,
                    2083,
                    2180,
                    70,
                    1959,
                    1948,
                    974,
                    1937,
                    213,
                    250,
                    252,
                    286,
                    1946
                ],
                "DatetimeTZDtype": [
                    223,
                    2212,
                    2181,
                    72,
                    210,
                    276,
                    479
                ],
                "values": [
                    1281,
                    1283,
                    1284,
                    267,
                    1163,
                    1165,
                    1167,
                    278,
                    408,
                    409,
                    287,
                    288,
                    289,
                    290,
                    293,
                    686,
                    1198,
                    688,
                    689,
                    1200,
                    1202,
                    77,
                    79,
                    214,
                    215,
                    217,
                    90,
                    219,
                    93,
                    222,
                    224,
                    225,
                    99,
                    228,
                    103,
                    231,
                    232,
                    2026,
                    235,
                    236,
                    2029,
                    238,
                    240,
                    243,
                    246,
                    250,
                    252,
                    255
                ],
                "self.asi8": [
                    1283,
                    1033,
                    1037,
                    1165,
                    540,
                    671,
                    544,
                    808,
                    1200,
                    566,
                    1217,
                    964,
                    1227,
                    972,
                    77,
                    717,
                    1241,
                    732,
                    990,
                    617,
                    1129
                ],
                "self": [
                    1030,
                    1031,
                    1033,
                    1037,
                    526,
                    1038,
                    533,
                    540,
                    544,
                    550,
                    566,
                    567,
                    574,
                    1086,
                    1094,
                    586,
                    77,
                    78,
                    79,
                    589,
                    81,
                    590,
                    83,
                    591,
                    1110,
                    600,
                    90,
                    602,
                    603,
                    605,
                    606,
                    98,
                    100,
                    614,
                    104,
                    617,
                    618,
                    1129,
                    624,
                    642,
                    1162,
                    1163,
                    1165,
                    1168,
                    657,
                    662,
                    664,
                    667,
                    671,
                    673,
                    675,
                    680,
                    681,
                    685,
                    686,
                    1197,
                    688,
                    689,
                    1198,
                    1200,
                    1203,
                    696,
                    697,
                    699,
                    701,
                    1214,
                    1215,
                    1217,
                    709,
                    711,
                    1227,
                    717,
                    718,
                    719,
                    1238,
                    1239,
                    1241,
                    219,
                    732,
                    1280,
                    1281,
                    1283,
                    1288,
                    1289,
                    278,
                    279,
                    280,
                    1817,
                    1818,
                    283,
                    1819,
                    800,
                    808,
                    1832,
                    1833,
                    1834,
                    1835,
                    1836,
                    450,
                    962,
                    964,
                    453,
                    457,
                    972,
                    462,
                    976,
                    465,
                    466,
                    469,
                    476,
                    990,
                    498,
                    511
                ],
                "self.tz": [
                    1280,
                    642,
                    1030,
                    1162,
                    1037,
                    526,
                    1038,
                    540,
                    544,
                    800,
                    550,
                    685,
                    1197,
                    689,
                    699,
                    574,
                    1086,
                    1214,
                    962,
                    964,
                    457,
                    1227,
                    78,
                    465,
                    466,
                    1110,
                    1238,
                    732,
                    476,
                    990,
                    617
                ],
                "timezones.is_utc": [
                    1280,
                    1030,
                    1162,
                    1197,
                    78,
                    1238,
                    1214
                ],
                "timezones": [
                    1280,
                    1030,
                    1162,
                    276,
                    533,
                    1942,
                    798,
                    1955,
                    1197,
                    2221,
                    2228,
                    1214,
                    964,
                    968,
                    78,
                    465,
                    2258,
                    1238,
                    2265,
                    2266,
                    2140,
                    2269,
                    225,
                    630
                ],
                "self._local_timestamps": [
                    1281,
                    1163,
                    1198,
                    79,
                    1239,
                    1215
                ],
                "field": [
                    98,
                    99,
                    103,
                    81,
                    82,
                    90,
                    93
                ],
                "self._bool_ops": [
                    81
                ],
                "field.endswith": [
                    82
                ],
                "freq": [
                    260,
                    390,
                    268,
                    269,
                    396,
                    398,
                    402,
                    2325,
                    280,
                    408,
                    282,
                    283,
                    409,
                    294,
                    311,
                    444,
                    323,
                    1093,
                    326,
                    1094,
                    328,
                    1096,
                    330,
                    1101,
                    1105,
                    83,
                    1108,
                    85,
                    86,
                    1110,
                    354,
                    357,
                    1129,
                    234,
                    235,
                    362
                ],
                "self.freq": [
                    808,
                    976,
                    83,
                    476,
                    574
                ],
                "month_kw": [
                    90,
                    84,
                    87
                ],
                "kwds": [
                    86,
                    87
                ],
                "freq.kwds": [
                    86
                ],
                "kwds.get": [
                    87
                ],
                "result": [
                    2049,
                    2050,
                    2054,
                    1932,
                    1167,
                    1168,
                    1169,
                    1949,
                    292,
                    293,
                    294,
                    295,
                    296,
                    1959,
                    1963,
                    1965,
                    1966,
                    689,
                    1202,
                    1203,
                    1204,
                    1971,
                    696,
                    699,
                    701,
                    326,
                    330,
                    718,
                    335,
                    591,
                    337,
                    593,
                    719,
                    720,
                    598,
                    599,
                    89,
                    93,
                    96,
                    2016,
                    99,
                    100,
                    103,
                    104,
                    105,
                    108,
                    2037,
                    2038,
                    2041,
                    2042
                ],
                "fields.get_start_end_field": [
                    89
                ],
                "fields": [
                    99,
                    1284,
                    103,
                    1167,
                    1202,
                    89,
                    93
                ],
                "self.freqstr": [
                    90,
                    1094
                ],
                "fields.get_date_field": [
                    93,
                    103
                ],
                "self._object_ops": [
                    98
                ],
                "fields.get_date_name_field": [
                    1202,
                    99,
                    1167
                ],
                "self._maybe_mask_results": [
                    100,
                    104,
                    719,
                    1168,
                    1203
                ],
                "f.__name__": [
                    110
                ],
                "f": [
                    112,
                    110,
                    111
                ],
                "name": [
                    110
                ],
                "f.__doc__": [
                    111
                ],
                "docstring": [
                    111
                ],
                "dtl.DatetimeLikeArrayMixin": [
                    115,
                    606
                ],
                "dtl": [
                    353,
                    323,
                    115,
                    311,
                    378,
                    606
                ],
                "dtl.TimelikeOps": [
                    115
                ],
                "dtl.DatelikeOps": [
                    115
                ],
                "_typ": [
                    152
                ],
                "_scalar_type": [
                    153
                ],
                "Timestamp": [
                    707,
                    457,
                    365,
                    368,
                    629,
                    153,
                    476
                ],
                "_recognized_scalars": [
                    154
                ],
                "datetime": [
                    705,
                    154
                ],
                "np.datetime64": [
                    705,
                    154,
                    627
                ],
                "np": [
                    2180,
                    2181,
                    660,
                    1817,
                    154,
                    1819,
                    1818,
                    287,
                    1825,
                    1827,
                    1828,
                    549,
                    1829,
                    1958,
                    1965,
                    430,
                    2108,
                    705,
                    210,
                    981,
                    2013,
                    479,
                    1887,
                    1890,
                    238,
                    627,
                    2172,
                    1918
                ],
                "_is_recognized_dtype": [
                    155
                ],
                "is_datetime64_any_dtype": [
                    155
                ],
                "_bool_ops": [
                    187,
                    158
                ],
                "_object_ops": [
                    187,
                    167
                ],
                "_field_ops": [
                    168,
                    187
                ],
                "_other_ops": [
                    186,
                    187
                ],
                "_datetimelike_ops": [
                    187
                ],
                "_datetimelike_methods": [
                    188
                ],
                "__array_priority__": [
                    205
                ],
                "_dtype": [
                    210
                ],
                "Union": [
                    210,
                    479
                ],
                "np.dtype": [
                    2180,
                    2181,
                    210,
                    2172,
                    479
                ],
                "_freq": [
                    211
                ],
                "ABCSeries": [
                    1892,
                    214
                ],
                "ABCIndexClass": [
                    1904,
                    214
                ],
                "values._values": [
                    215
                ],
                "inferred_freq": [
                    323,
                    313,
                    328,
                    1899,
                    1971,
                    1881,
                    217,
                    282
                ],
                "dtz": [
                    224,
                    225,
                    228,
                    2219,
                    2220,
                    2221,
                    2223,
                    2228,
                    221,
                    222
                ],
                "dtype": [
                    258,
                    2180,
                    2181,
                    2184,
                    2187,
                    270,
                    276,
                    279,
                    2209,
                    2210,
                    2212,
                    550,
                    295,
                    552,
                    807,
                    554,
                    808,
                    2219,
                    433,
                    1969,
                    435,
                    2225,
                    443,
                    315,
                    444,
                    325,
                    326,
                    584,
                    586,
                    588,
                    975,
                    976,
                    600,
                    1883,
                    604,
                    221,
                    605,
                    223,
                    606,
                    232,
                    1902,
                    2170,
                    2171,
                    2172
                ],
                "values.tz": [
                    224,
                    225,
                    228,
                    231,
                    222
                ],
                "dtype.tz": [
                    276,
                    223
                ],
                "timezones.tz_compare": [
                    225,
                    2221,
                    465,
                    2228,
                    2140,
                    2269
                ],
                "msg": [
                    226,
                    2174,
                    230,
                    2178
                ],
                "values.dtype": [
                    288,
                    289,
                    232,
                    246,
                    252,
                    255
                ],
                "values.freq": [
                    235
                ],
                "values._data": [
                    236
                ],
                "np.ndarray": [
                    549,
                    1965,
                    238,
                    660,
                    981,
                    287
                ],
                "values.ndim": [
                    243
                ],
                "values.view": [
                    250,
                    290,
                    2029
                ],
                "_validate_dt64_dtype": [
                    258,
                    1883
                ],
                "copy": [
                    1891,
                    2084,
                    1916,
                    1961,
                    266,
                    592,
                    2103,
                    2078,
                    1911,
                    601,
                    316,
                    2109,
                    606,
                    2111
                ],
                "values.copy": [
                    267
                ],
                "to_offset": [
                    362,
                    269,
                    335
                ],
                "timezones.tz_standardize": [
                    276
                ],
                "self._data": [
                    1110,
                    278
                ],
                "self._dtype": [
                    498,
                    279
                ],
                "self._freq": [
                    280,
                    469
                ],
                "_validate_frequency": [
                    283
                ],
                "object.__new__": [
                    292
                ],
                "cls": [
                    416,
                    292,
                    326,
                    330,
                    434,
                    409,
                    444
                ],
                "result._data": [
                    293,
                    598
                ],
                "result._freq": [
                    294,
                    335
                ],
                "result._dtype": [
                    295
                ],
                "freq_infer": [
                    323,
                    332,
                    311
                ],
                "dtl.maybe_infer_freq": [
                    311
                ],
                "subarr": [
                    313,
                    326
                ],
                "sequence_to_dt64ns": [
                    313
                ],
                "data": [
                    1922,
                    1923,
                    1929,
                    1931,
                    1932,
                    1934,
                    1936,
                    1937,
                    1938,
                    1943,
                    1944,
                    1946,
                    1948,
                    1949,
                    2076,
                    2078,
                    2080,
                    2083,
                    1957,
                    1958,
                    1959,
                    2088,
                    2090,
                    2091,
                    2098,
                    566,
                    2102,
                    2105,
                    314,
                    2108,
                    574,
                    2111,
                    1885,
                    2013,
                    1887,
                    1889,
                    1890,
                    2017,
                    1892,
                    1893,
                    1894,
                    1895,
                    1897,
                    2026,
                    1899,
                    1904,
                    1905,
                    1908,
                    1911,
                    1913,
                    1917,
                    1918
                ],
                "dayfirst": [
                    1923,
                    2020,
                    318
                ],
                "yearfirst": [
                    1923,
                    2021,
                    319
                ],
                "ambiguous": [
                    320,
                    392,
                    330,
                    396,
                    972,
                    2323,
                    2324,
                    1944,
                    413
                ],
                "dtl.validate_inferred_freq": [
                    323
                ],
                "tz_to_dtype": [
                    325,
                    807,
                    975,
                    433,
                    409,
                    443
                ],
                "cls._simple_new": [
                    409,
                    434,
                    444,
                    326
                ],
                "cls._validate_frequency": [
                    330
                ],
                "result.inferred_freq": [
                    335
                ],
                "periods": [
                    353,
                    354,
                    357,
                    430,
                    408
                ],
                "dtl.validate_periods": [
                    353
                ],
                "x": [
                    354,
                    476
                ],
                "start": [
                    386,
                    387,
                    388,
                    389,
                    403,
                    404,
                    408,
                    2295,
                    420,
                    421,
                    430,
                    431,
                    438,
                    2258,
                    354,
                    357,
                    2281,
                    2283,
                    364,
                    365,
                    2286,
                    370,
                    375,
                    380,
                    382
                ],
                "end": [
                    395,
                    396,
                    405,
                    406,
                    408,
                    2295,
                    422,
                    423,
                    430,
                    440,
                    2258,
                    354,
                    357,
                    367,
                    368,
                    2288,
                    370,
                    2290,
                    2293,
                    375,
                    380,
                    382
                ],
                "com.count_not_none": [
                    357
                ],
                "com": [
                    357
                ],
                "closed": [
                    378,
                    371
                ],
                "NaT": [
                    706,
                    450,
                    708,
                    709,
                    460,
                    2102,
                    375,
                    639
                ],
                "left_closed": [
                    378,
                    438
                ],
                "right_closed": [
                    440,
                    378
                ],
                "dtl.validate_endpoints": [
                    378
                ],
                "_normalized": [
                    2279,
                    2284,
                    2286,
                    2291,
                    2293,
                    2295,
                    380
                ],
                "_maybe_normalize_endpoints": [
                    380
                ],
                "normalize": [
                    2289,
                    2282,
                    380
                ],
                "_infer_tz_from_endpoints": [
                    382
                ],
                "_maybe_localize_point": [
                    386,
                    395
                ],
                "nonexistent": [
                    393,
                    396,
                    972,
                    2324,
                    953,
                    954,
                    413
                ],
                "Day": [
                    402
                ],
                "start.tz_localize": [
                    404,
                    421
                ],
                "end.tz_localize": [
                    406,
                    423
                ],
                "_tz": [
                    408,
                    409
                ],
                "generate_regular_range": [
                    408
                ],
                "index": [
                    416,
                    441,
                    434,
                    438,
                    439,
                    440,
                    409,
                    411,
                    444,
                    413
                ],
                "index.tz": [
                    411
                ],
                "arr": [
                    416,
                    435,
                    412,
                    429
                ],
                "conversion.tz_localize_to_utc": [
                    971,
                    412,
                    1943
                ],
                "conversion": [
                    2026,
                    971,
                    1037,
                    1938,
                    1943,
                    412,
                    540
                ],
                "index.asi8": [
                    444,
                    413
                ],
                "asm8": [
                    421,
                    423
                ],
                "np.linspace": [
                    430
                ],
                "end.value": [
                    430
                ],
                "start.value": [
                    430,
                    431
                ],
                "arr.astype": [
                    435
                ],
                "value": [
                    450,
                    452,
                    453,
                    454,
                    457
                ],
                "self._scalar_type": [
                    450
                ],
                "isna": [
                    452
                ],
                "self._check_compatible_with": [
                    453
                ],
                "value.value": [
                    454
                ],
                "other": [
                    657,
                    660,
                    661,
                    662,
                    664,
                    672,
                    673,
                    675,
                    705,
                    706,
                    707,
                    708,
                    711,
                    460,
                    462,
                    718,
                    465,
                    466,
                    627,
                    629,
                    630,
                    635,
                    636,
                    638,
                    639
                ],
                "self._assert_tzawareness_compat": [
                    462
                ],
                "setitem": [
                    463
                ],
                "other.tz": [
                    465,
                    466
                ],
                "self.dtype": [
                    600,
                    586,
                    589,
                    511
                ],
                "tz.setter": [
                    513
                ],
                "timezones.get_timezone": [
                    533,
                    630
                ],
                "self.tzinfo": [
                    533
                ],
                "conversion.is_date_array_normalized": [
                    540
                ],
                "libresolution.resolution": [
                    544
                ],
                "libresolution": [
                    544
                ],
                "__array__": [
                    554
                ],
                "length": [
                    569,
                    572,
                    567
                ],
                "chunksize": [
                    568,
                    569,
                    571,
                    572
                ],
                "chunks": [
                    569,
                    570
                ],
                "i": [
                    570,
                    571,
                    572
                ],
                "start_i": [
                    571,
                    574
                ],
                "end_i": [
                    572,
                    574
                ],
                "converted": [
                    576,
                    573
                ],
                "tslib.ints_to_pydatetime": [
                    1219,
                    1227,
                    1243,
                    573,
                    990
                ],
                "tslib": [
                    2016,
                    1219,
                    616,
                    1227,
                    1243,
                    573,
                    990
                ],
                "v": [
                    576,
                    577
                ],
                "pandas_dtype": [
                    584,
                    2171
                ],
                "is_datetime64_ns_dtype": [
                    586
                ],
                "is_dtype_equal": [
                    600,
                    586,
                    2172
                ],
                "new_tz": [
                    594,
                    588,
                    590,
                    591
                ],
                "self.tz_localize": [
                    686,
                    590
                ],
                "self.tz_convert": [
                    591
                ],
                "result.copy": [
                    593,
                    1963
                ],
                "is_datetime64tz_dtype": [
                    600,
                    1929,
                    636,
                    2105
                ],
                "self.copy": [
                    602
                ],
                "is_period_dtype": [
                    2091,
                    604
                ],
                "self.to_period": [
                    1129,
                    605
                ],
                "dtype.freq": [
                    605
                ],
                "dtl.DatetimeLikeArrayMixin.astype": [
                    606
                ],
                "fmt": [
                    617,
                    614
                ],
                "_get_format_datetime64_from_values": [
                    614
                ],
                "date_format": [
                    614
                ],
                "reshape": [
                    616,
                    681
                ],
                "tslib.format_array_from_datetime": [
                    616
                ],
                "self.asi8.ravel": [
                    617
                ],
                "na_rep": [
                    617
                ],
                "self.shape": [
                    681,
                    618
                ],
                "zzone": [
                    624,
                    631
                ],
                "self._timezone": [
                    624
                ],
                "vzone": [
                    630,
                    631
                ],
                "other_tz": [
                    635,
                    643,
                    638,
                    647
                ],
                "other.dtype.tz": [
                    638
                ],
                "other.dtype": [
                    638
                ],
                "is_datetime64_dtype": [
                    2038,
                    2225,
                    661,
                    1934
                ],
                "self._has_same_tz": [
                    664,
                    711
                ],
                "self_i8": [
                    674,
                    671
                ],
                "other_i8": [
                    672,
                    674
                ],
                "other.asi8": [
                    672
                ],
                "arr_mask": [
                    673,
                    674,
                    676
                ],
                "self._isnan": [
                    1289,
                    673,
                    718
                ],
                "other._isnan": [
                    673
                ],
                "new_values": [
                    674,
                    676,
                    677,
                    1033,
                    1034,
                    1035,
                    1037,
                    1038
                ],
                "checked_add_with_arr": [
                    674,
                    718
                ],
                "self._hasnans": [
                    1288,
                    675
                ],
                "other._hasnans": [
                    675
                ],
                "iNaT": [
                    676
                ],
                "new_values.view": [
                    677
                ],
                "self.ndim": [
                    680
                ],
                "_add_offset": [
                    681
                ],
                "self.ravel": [
                    681
                ],
                "offset": [
                    689,
                    681,
                    683,
                    696
                ],
                "Tick": [
                    683,
                    2325
                ],
                "tz_localize": [
                    689,
                    699,
                    1038
                ],
                "offset.apply_index": [
                    689
                ],
                "warnings.warn": [
                    692,
                    1087
                ],
                "warnings": [
                    692,
                    1087
                ],
                "PerformanceWarning": [
                    694
                ],
                "self.astype": [
                    696
                ],
                "_from_sequence": [
                    699,
                    701
                ],
                "_with_freq": [
                    701,
                    1038
                ],
                "i8": [
                    717,
                    718
                ],
                "other.value": [
                    718
                ],
                "result.view": [
                    720,
                    2037
                ],
                "tzconversion.tz_convert": [
                    964,
                    732
                ],
                "tzconversion": [
                    964,
                    732
                ],
                "utc": [
                    2019,
                    732
                ],
                "timezones.maybe_get_tz": [
                    1955,
                    968,
                    1942,
                    2265,
                    2266,
                    798
                ],
                "self._simple_new": [
                    808,
                    976
                ],
                "nonexistent_options": [
                    952,
                    953
                ],
                "timedelta": [
                    954
                ],
                "new_dates": [
                    976,
                    971,
                    964,
                    974
                ],
                "timezones.UTC": [
                    964
                ],
                "new_dates.view": [
                    974
                ],
                "not_null": [
                    1034,
                    1035,
                    1031
                ],
                "self.isna": [
                    1031
                ],
                "DAY_NS": [
                    1032,
                    1034
                ],
                "ccalendar.DAY_SECONDS": [
                    1032
                ],
                "ccalendar": [
                    1032
                ],
                "self.asi8.copy": [
                    1033
                ],
                "adjustment": [
                    1034,
                    1035
                ],
                "conversion.normalize_i8_timestamps": [
                    1037
                ],
                "self.inferred_freq": [
                    1094
                ],
                "res": [
                    1104,
                    1106,
                    1108,
                    1101
                ],
                "get_period_alias": [
                    1101
                ],
                "base": [
                    1105,
                    1106
                ],
                "stride": [
                    1105,
                    1106
                ],
                "libfrequencies._base_and_stride": [
                    1105
                ],
                "libfrequencies": [
                    1105
                ],
                "PeriodArray._from_datetime64": [
                    1110
                ],
                "PeriodArray": [
                    1110
                ],
                "i8delta": [
                    1129,
                    1130
                ],
                "asi8": [
                    1129
                ],
                "to_timestamp": [
                    1129
                ],
                "m8delta": [
                    1130,
                    1131
                ],
                "i8delta.view": [
                    1130
                ],
                "TimedeltaArray": [
                    1131
                ],
                "locale": [
                    1202,
                    1167
                ],
                "timestamps": [
                    1217,
                    1219,
                    1239,
                    1241,
                    1243,
                    1215
                ],
                "sarray": [
                    1284,
                    1286
                ],
                "fields.build_isocalendar_sarray": [
                    1284
                ],
                "iso_calendar_df": [
                    1289,
                    1290,
                    1285
                ],
                "DataFrame": [
                    1285
                ],
                "iso_calendar_df.iloc": [
                    1289
                ],
                "year": [
                    1826,
                    1827,
                    1828,
                    1829,
                    1292,
                    1817,
                    1821
                ],
                "_field_accessor": [
                    1292,
                    1679,
                    1430,
                    1315,
                    1407,
                    1453,
                    1587,
                    1591,
                    1338,
                    1595,
                    1723,
                    1476,
                    1361,
                    1637,
                    1767,
                    1384,
                    1518,
                    1521,
                    1528,
                    1535
                ],
                "month": [
                    1825,
                    1315,
                    1818,
                    1820,
                    1822
                ],
                "day": [
                    1824,
                    1338,
                    1819
                ],
                "hour": [
                    1361
                ],
                "minute": [
                    1384
                ],
                "second": [
                    1407
                ],
                "microsecond": [
                    1430
                ],
                "nanosecond": [
                    1453
                ],
                "weekofyear": [
                    1483,
                    1476
                ],
                "week": [
                    1483
                ],
                "_dayofweek_doc": [
                    1484,
                    1518
                ],
                "dayofweek": [
                    1518,
                    1519
                ],
                "weekday": [
                    1519
                ],
                "dayofyear": [
                    1521
                ],
                "quarter": [
                    1528
                ],
                "days_in_month": [
                    1542,
                    1535
                ],
                "daysinmonth": [
                    1542
                ],
                "_is_month_doc": [
                    1592,
                    1588,
                    1543
                ],
                "is_month_start": [
                    1587
                ],
                "_is_month_doc.format": [
                    1592,
                    1588
                ],
                "is_month_end": [
                    1591
                ],
                "is_quarter_start": [
                    1595
                ],
                "is_quarter_end": [
                    1637
                ],
                "is_year_start": [
                    1679
                ],
                "is_year_end": [
                    1723
                ],
                "is_leap_year": [
                    1767
                ],
                "np.asarray": [
                    1817,
                    1818,
                    1819,
                    1890
                ],
                "self.year": [
                    1817
                ],
                "self.month": [
                    1818
                ],
                "self.day": [
                    1819
                ],
                "testarr": [
                    1820,
                    1821,
                    1822
                ],
                "np.fix": [
                    1825
                ],
                "np.floor": [
                    1827,
                    1828,
                    1829
                ],
                "self.hour": [
                    1832
                ],
                "self.minute": [
                    1833
                ],
                "self.second": [
                    1834
                ],
                "self.microsecond": [
                    1835
                ],
                "self.nanosecond": [
                    1836
                ],
                "np.ndim": [
                    1887
                ],
                "data._values": [
                    1893
                ],
                "ABCPandasArray": [
                    1894
                ],
                "data.to_numpy": [
                    1895
                ],
                "data.freq": [
                    1899
                ],
                "validate_tz_from_dtype": [
                    1969,
                    1902
                ],
                "data.nlevels": [
                    1905
                ],
                "data._data": [
                    1932,
                    1908
                ],
                "maybe_convert_dtype": [
                    1911
                ],
                "is_object_dtype": [
                    1913,
                    2042
                ],
                "is_string_dtype": [
                    1913
                ],
                "lib.infer_dtype": [
                    1917
                ],
                "lib": [
                    1917
                ],
                "data.astype": [
                    2083,
                    1958,
                    1918
                ],
                "np.int64": [
                    1958,
                    1918
                ],
                "inferred_tz": [
                    2272,
                    2273,
                    1922,
                    2265,
                    1925,
                    2258,
                    2268,
                    2137,
                    2138,
                    2140,
                    2269,
                    2142
                ],
                "objects_to_datetime64ns": [
                    1922
                ],
                "maybe_infer_tz": [
                    1931,
                    1925
                ],
                "data.tz": [
                    1931
                ],
                "data.dtype": [
                    2080,
                    1957,
                    2088,
                    2090,
                    2091,
                    1937,
                    2098,
                    2105,
                    1948
                ],
                "conversion.ensure_datetime64ns": [
                    1938
                ],
                "data.view": [
                    1944,
                    1946,
                    1959
                ],
                "_INT64_DTYPE": [
                    1957
                ],
                "result.dtype": [
                    1966
                ],
                "errors": [
                    2010,
                    2018
                ],
                "np.array": [
                    2108,
                    2013
                ],
                "np.object_": [
                    2108,
                    2013
                ],
                "tz_parsed": [
                    2016,
                    2049,
                    2026,
                    2029,
                    2033,
                    2037,
                    2041
                ],
                "tslib.array_to_datetime": [
                    2016
                ],
                "require_iso8601": [
                    2022
                ],
                "conversion.datetime_to_datetime64": [
                    2026
                ],
                "e": [
                    2031
                ],
                "allow_object": [
                    2048
                ],
                "is_float_dtype": [
                    2080
                ],
                "is_timedelta64_dtype": [
                    2088
                ],
                "is_bool_dtype": [
                    2088
                ],
                "is_categorical_dtype": [
                    2098
                ],
                "_values": [
                    2102
                ],
                "data.categories.take": [
                    2102
                ],
                "data.categories": [
                    2102
                ],
                "data.codes": [
                    2102
                ],
                "is_extension_array_dtype": [
                    2105
                ],
                "DatetimeTZDtype.construct_from_string": [
                    2212
                ],
                "timezones.infer_tzinfo": [
                    2258
                ],
                "err": [
                    2263
                ],
                "normalize_date": [
                    2290,
                    2283
                ],
                "start.time": [
                    2286
                ],
                "end.time": [
                    2293
                ],
                "is_none": [
                    2320
                ],
                "is_not_none": [
                    2320
                ],
                "localize_args": [
                    2324,
                    2326,
                    2327
                ],
                "ts": [
                    2328,
                    2327
                ],
                "ts.tz_localize": [
                    2327
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/home/ubuntu/Desktop/bgp_envs_local/repos/pandas_24/pandas/tests/indexes/datetimes/test_timezones.py",
                "test_function": "test_tz_localize_invalidates_freq",
                "test_function_code": "def test_tz_localize_invalidates_freq():\n    # we only preserve freq in unambiguous cases\n\n    # if localized to US/Eastern, this crosses a DST transition\n    dti = date_range(\"2014-03-08 23:00\", \"2014-03-09 09:00\", freq=\"H\")\n    assert dti.freq == \"H\"\n\n    result = dti.tz_localize(None)  # no-op\n    assert result.freq == \"H\"\n\n    result = dti.tz_localize(\"UTC\")  # unambiguous freq preservation\n    assert result.freq == \"H\"\n\n    result = dti.tz_localize(\"US/Eastern\", nonexistent=\"shift_forward\")\n    assert result.freq is None\n    assert result.inferred_freq is None  # i.e. we are not _too_ strict here\n\n    # Case where we _can_ keep freq because we're length==1\n    dti2 = dti[:1]\n    result = dti2.tz_localize(\"US/Eastern\")\n    assert result.freq == \"H\"",
                "test_error": "AssertionError: assert <Hour> is None  +  where <Hour> = DatetimeIndex(['2014-03-08 23:00:00-05:00', '2014-03-09 00:00:00-05:00',\\n               '2014-03-09 01:00:00-05:00', '...:00:00-04:00',\\n               '2014-03-09 09:00:00-04:00'],\\n              dtype='datetime64[ns, US/Eastern]', freq='H').freq",
                "full_test_error": "def test_tz_localize_invalidates_freq():\n        # we only preserve freq in unambiguous cases\n    \n        # if localized to US/Eastern, this crosses a DST transition\n        dti = date_range(\"2014-03-08 23:00\", \"2014-03-09 09:00\", freq=\"H\")\n        assert dti.freq == \"H\"\n    \n        result = dti.tz_localize(None)  # no-op\n        assert result.freq == \"H\"\n    \n        result = dti.tz_localize(\"UTC\")  # unambiguous freq preservation\n        assert result.freq == \"H\"\n    \n        result = dti.tz_localize(\"US/Eastern\", nonexistent=\"shift_forward\")\n>       assert result.freq is None\nE       AssertionError: assert <Hour> is None\nE        +  where <Hour> = DatetimeIndex(['2014-03-08 23:00:00-05:00', '2014-03-09 00:00:00-05:00',\\n               '2014-03-09 01:00:00-05:00', '...:00:00-04:00',\\n               '2014-03-09 09:00:00-04:00'],\\n              dtype='datetime64[ns, US/Eastern]', freq='H').freq\n\npandas/tests/indexes/datetimes/test_timezones.py:1180: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            }
        ]
    }
}