{
    "pandas:42": {
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_42/pandas/_testing.py": {
            "buggy_functions": [
                {
                    "function_name": "assert_series_equal",
                    "function_code": "def assert_series_equal(\n    left,\n    right,\n    check_dtype=True,\n    check_index_type=\"equiv\",\n    check_series_type=True,\n    check_less_precise=False,\n    check_names=True,\n    check_exact=False,\n    check_datetimelike_compat=False,\n    check_categorical=True,\n    check_category_order=True,\n    obj=\"Series\",\n):\n    \"\"\"\n    Check that left and right Series are equal.\n\n    Parameters\n    ----------\n    left : Series\n    right : Series\n    check_dtype : bool, default True\n        Whether to check the Series dtype is identical.\n    check_index_type : bool or {'equiv'}, default 'equiv'\n        Whether to check the Index class, dtype and inferred_type\n        are identical.\n    check_series_type : bool, default True\n         Whether to check the Series class is identical.\n    check_less_precise : bool or int, default False\n        Specify comparison precision. Only used when check_exact is False.\n        5 digits (False) or 3 digits (True) after decimal points are compared.\n        If int, then specify the digits to compare.\n\n        When comparing two numbers, if the first number has magnitude less\n        than 1e-5, we compare the two numbers directly and check whether\n        they are equivalent within the specified precision. Otherwise, we\n        compare the **ratio** of the second number to the first number and\n        check whether it is equivalent to 1 within the specified precision.\n    check_names : bool, default True\n        Whether to check the Series and Index names attribute.\n    check_exact : bool, default False\n        Whether to compare number exactly.\n    check_datetimelike_compat : bool, default False\n        Compare datetime-like which is comparable ignoring dtype.\n    check_categorical : bool, default True\n        Whether to compare internal Categorical exactly.\n    check_category_order : bool, default True\n        Whether to compare category order of internal Categoricals.\n\n        .. versionadded:: 1.0.2\n    obj : str, default 'Series'\n        Specify object name being compared, internally used to show appropriate\n        assertion message.\n    \"\"\"\n    __tracebackhide__ = True\n\n    # instance validation\n    _check_isinstance(left, right, Series)\n\n    if check_series_type:\n        assert_class_equal(left, right, obj=obj)\n\n    # length comparison\n    if len(left) != len(right):\n        msg1 = f\"{len(left)}, {left.index}\"\n        msg2 = f\"{len(right)}, {right.index}\"\n        raise_assert_detail(obj, \"Series length are different\", msg1, msg2)\n\n    # index comparison\n    assert_index_equal(\n        left.index,\n        right.index,\n        exact=check_index_type,\n        check_names=check_names,\n        check_less_precise=check_less_precise,\n        check_exact=check_exact,\n        check_categorical=check_categorical,\n        obj=f\"{obj}.index\",\n    )\n\n    if check_dtype:\n        # We want to skip exact dtype checking when `check_categorical`\n        # is False. We'll still raise if only one is a `Categorical`,\n        # regardless of `check_categorical`\n        if (\n            is_categorical_dtype(left.dtype)\n            and is_categorical_dtype(right.dtype)\n            and not check_categorical\n        ):\n            pass\n        else:\n            assert_attr_equal(\"dtype\", left, right, obj=f\"Attributes of {obj}\")\n\n    if check_exact:\n        if not is_numeric_dtype(left.dtype):\n            raise AssertionError(\"check_exact may only be used with numeric Series\")\n\n        assert_numpy_array_equal(\n            left._values, right._values, check_dtype=check_dtype, obj=str(obj)\n        )\n    elif check_datetimelike_compat and (\n        needs_i8_conversion(left.dtype) or needs_i8_conversion(right.dtype)\n    ):\n        # we want to check only if we have compat dtypes\n        # e.g. integer and M|m are NOT compat, but we can simply check\n        # the values in that case\n\n        # datetimelike may have different objects (e.g. datetime.datetime\n        # vs Timestamp) but will compare equal\n        if not Index(left._values).equals(Index(right._values)):\n            msg = (\n                f\"[datetimelike_compat=True] {left._values} \"\n                f\"is not equal to {right._values}.\"\n            )\n            raise AssertionError(msg)\n    elif is_interval_dtype(left.dtype) or is_interval_dtype(right.dtype):\n        assert_interval_array_equal(left.array, right.array)\n    elif is_categorical_dtype(left.dtype) or is_categorical_dtype(right.dtype):\n        _testing.assert_almost_equal(\n            left._values,\n            right._values,\n            check_less_precise=check_less_precise,\n            check_dtype=check_dtype,\n            obj=str(obj),\n        )\n    elif is_extension_array_dtype(left.dtype) or is_extension_array_dtype(right.dtype):\n        assert_extension_array_equal(left._values, right._values)\n    elif needs_i8_conversion(left.dtype) or needs_i8_conversion(right.dtype):\n        # DatetimeArray or TimedeltaArray\n        assert_extension_array_equal(left._values, right._values)\n    else:\n        _testing.assert_almost_equal(\n            left._values,\n            right._values,\n            check_less_precise=check_less_precise,\n            check_dtype=check_dtype,\n            obj=str(obj),\n        )\n\n    # metadata comparison\n    if check_names:\n        assert_attr_equal(\"name\", left, right, obj=obj)\n\n    if check_categorical:\n        if is_categorical_dtype(left) or is_categorical_dtype(right):\n            assert_categorical_equal(\n                left._values,\n                right._values,\n                obj=f\"{obj} category\",\n                check_category_order=check_category_order,\n            )\n",
                    "decorators": [],
                    "docstring": "Check that left and right Series are equal.\n\nParameters\n----------\nleft : Series\nright : Series\ncheck_dtype : bool, default True\n    Whether to check the Series dtype is identical.\ncheck_index_type : bool or {'equiv'}, default 'equiv'\n    Whether to check the Index class, dtype and inferred_type\n    are identical.\ncheck_series_type : bool, default True\n     Whether to check the Series class is identical.\ncheck_less_precise : bool or int, default False\n    Specify comparison precision. Only used when check_exact is False.\n    5 digits (False) or 3 digits (True) after decimal points are compared.\n    If int, then specify the digits to compare.\n\n    When comparing two numbers, if the first number has magnitude less\n    than 1e-5, we compare the two numbers directly and check whether\n    they are equivalent within the specified precision. Otherwise, we\n    compare the **ratio** of the second number to the first number and\n    check whether it is equivalent to 1 within the specified precision.\ncheck_names : bool, default True\n    Whether to check the Series and Index names attribute.\ncheck_exact : bool, default False\n    Whether to compare number exactly.\ncheck_datetimelike_compat : bool, default False\n    Compare datetime-like which is comparable ignoring dtype.\ncheck_categorical : bool, default True\n    Whether to compare internal Categorical exactly.\ncheck_category_order : bool, default True\n    Whether to compare category order of internal Categoricals.\n\n    .. versionadded:: 1.0.2\nobj : str, default 'Series'\n    Specify object name being compared, internally used to show appropriate\n    assertion message.",
                    "start_line": 1048,
                    "end_line": 1198,
                    "variables": {
                        "__tracebackhide__": [
                            1102
                        ],
                        "_check_isinstance": [
                            1105
                        ],
                        "left": [
                            1157,
                            1159,
                            1163,
                            1164,
                            1165,
                            1167,
                            1173,
                            1174,
                            1175,
                            1177,
                            1180,
                            1189,
                            1192,
                            1194,
                            1105,
                            1108,
                            1111,
                            1112,
                            1118,
                            1133,
                            1139,
                            1142,
                            1146,
                            1149
                        ],
                        "right": [
                            1157,
                            1160,
                            1163,
                            1164,
                            1165,
                            1168,
                            1173,
                            1174,
                            1175,
                            1177,
                            1181,
                            1189,
                            1192,
                            1195,
                            1105,
                            1108,
                            1111,
                            1113,
                            1119,
                            1134,
                            1139,
                            1146,
                            1149
                        ],
                        "Series": [
                            1105
                        ],
                        "check_series_type": [
                            1107
                        ],
                        "assert_class_equal": [
                            1108
                        ],
                        "obj": [
                            1184,
                            1125,
                            1146,
                            1189,
                            1196,
                            1139,
                            1108,
                            1171,
                            1114
                        ],
                        "len": [
                            1112,
                            1113,
                            1111
                        ],
                        "msg1": [
                            1112,
                            1114
                        ],
                        "left.index": [
                            1112,
                            1118
                        ],
                        "msg2": [
                            1113,
                            1114
                        ],
                        "right.index": [
                            1113,
                            1119
                        ],
                        "raise_assert_detail": [
                            1114
                        ],
                        "assert_index_equal": [
                            1117
                        ],
                        "check_index_type": [
                            1120
                        ],
                        "check_names": [
                            1121,
                            1188
                        ],
                        "check_less_precise": [
                            1169,
                            1122,
                            1182
                        ],
                        "check_exact": [
                            1123,
                            1141
                        ],
                        "check_categorical": [
                            1191,
                            1124,
                            1135
                        ],
                        "check_dtype": [
                            1128,
                            1146,
                            1183,
                            1170
                        ],
                        "is_categorical_dtype": [
                            1165,
                            1192,
                            1133,
                            1134
                        ],
                        "left.dtype": [
                            1163,
                            1165,
                            1133,
                            1173,
                            1142,
                            1175,
                            1149
                        ],
                        "right.dtype": [
                            1163,
                            1165,
                            1134,
                            1173,
                            1175,
                            1149
                        ],
                        "assert_attr_equal": [
                            1139,
                            1189
                        ],
                        "is_numeric_dtype": [
                            1142
                        ],
                        "AssertionError": [
                            1162,
                            1143
                        ],
                        "assert_numpy_array_equal": [
                            1145
                        ],
                        "left._values": [
                            1157,
                            1159,
                            1194,
                            1167,
                            1174,
                            1177,
                            1146,
                            1180
                        ],
                        "right._values": [
                            1157,
                            1160,
                            1195,
                            1168,
                            1174,
                            1177,
                            1146,
                            1181
                        ],
                        "str": [
                            1184,
                            1146,
                            1171
                        ],
                        "check_datetimelike_compat": [
                            1148
                        ],
                        "needs_i8_conversion": [
                            1149,
                            1175
                        ],
                        "equals": [
                            1157
                        ],
                        "Index": [
                            1157
                        ],
                        "msg": [
                            1162,
                            1158
                        ],
                        "is_interval_dtype": [
                            1163
                        ],
                        "assert_interval_array_equal": [
                            1164
                        ],
                        "left.array": [
                            1164
                        ],
                        "right.array": [
                            1164
                        ],
                        "_testing.assert_almost_equal": [
                            1179,
                            1166
                        ],
                        "_testing": [
                            1179,
                            1166
                        ],
                        "is_extension_array_dtype": [
                            1173
                        ],
                        "assert_extension_array_equal": [
                            1177,
                            1174
                        ],
                        "assert_categorical_equal": [
                            1193
                        ],
                        "check_category_order": [
                            1197
                        ]
                    },
                    "filtered_variables": {
                        "__tracebackhide__": [
                            1102
                        ],
                        "_check_isinstance": [
                            1105
                        ],
                        "left": [
                            1157,
                            1159,
                            1163,
                            1164,
                            1165,
                            1167,
                            1173,
                            1174,
                            1175,
                            1177,
                            1180,
                            1189,
                            1192,
                            1194,
                            1105,
                            1108,
                            1111,
                            1112,
                            1118,
                            1133,
                            1139,
                            1142,
                            1146,
                            1149
                        ],
                        "right": [
                            1157,
                            1160,
                            1163,
                            1164,
                            1165,
                            1168,
                            1173,
                            1174,
                            1175,
                            1177,
                            1181,
                            1189,
                            1192,
                            1195,
                            1105,
                            1108,
                            1111,
                            1113,
                            1119,
                            1134,
                            1139,
                            1146,
                            1149
                        ],
                        "Series": [
                            1105
                        ],
                        "check_series_type": [
                            1107
                        ],
                        "assert_class_equal": [
                            1108
                        ],
                        "obj": [
                            1184,
                            1125,
                            1146,
                            1189,
                            1196,
                            1139,
                            1108,
                            1171,
                            1114
                        ],
                        "msg1": [
                            1112,
                            1114
                        ],
                        "left.index": [
                            1112,
                            1118
                        ],
                        "msg2": [
                            1113,
                            1114
                        ],
                        "right.index": [
                            1113,
                            1119
                        ],
                        "raise_assert_detail": [
                            1114
                        ],
                        "assert_index_equal": [
                            1117
                        ],
                        "check_index_type": [
                            1120
                        ],
                        "check_names": [
                            1121,
                            1188
                        ],
                        "check_less_precise": [
                            1169,
                            1122,
                            1182
                        ],
                        "check_exact": [
                            1123,
                            1141
                        ],
                        "check_categorical": [
                            1191,
                            1124,
                            1135
                        ],
                        "check_dtype": [
                            1128,
                            1146,
                            1183,
                            1170
                        ],
                        "is_categorical_dtype": [
                            1165,
                            1192,
                            1133,
                            1134
                        ],
                        "left.dtype": [
                            1163,
                            1165,
                            1133,
                            1173,
                            1142,
                            1175,
                            1149
                        ],
                        "right.dtype": [
                            1163,
                            1165,
                            1134,
                            1173,
                            1175,
                            1149
                        ],
                        "assert_attr_equal": [
                            1139,
                            1189
                        ],
                        "is_numeric_dtype": [
                            1142
                        ],
                        "assert_numpy_array_equal": [
                            1145
                        ],
                        "left._values": [
                            1157,
                            1159,
                            1194,
                            1167,
                            1174,
                            1177,
                            1146,
                            1180
                        ],
                        "right._values": [
                            1157,
                            1160,
                            1195,
                            1168,
                            1174,
                            1177,
                            1146,
                            1181
                        ],
                        "check_datetimelike_compat": [
                            1148
                        ],
                        "needs_i8_conversion": [
                            1149,
                            1175
                        ],
                        "equals": [
                            1157
                        ],
                        "Index": [
                            1157
                        ],
                        "msg": [
                            1162,
                            1158
                        ],
                        "is_interval_dtype": [
                            1163
                        ],
                        "assert_interval_array_equal": [
                            1164
                        ],
                        "left.array": [
                            1164
                        ],
                        "right.array": [
                            1164
                        ],
                        "_testing.assert_almost_equal": [
                            1179,
                            1166
                        ],
                        "_testing": [
                            1179,
                            1166
                        ],
                        "is_extension_array_dtype": [
                            1173
                        ],
                        "assert_extension_array_equal": [
                            1177,
                            1174
                        ],
                        "assert_categorical_equal": [
                            1193
                        ],
                        "check_category_order": [
                            1197
                        ]
                    },
                    "diff_line_number": 1163,
                    "class_data": null,
                    "variable_values": [
                        [
                            {
                                "__tracebackhide__": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_check_isinstance": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left": {
                                    "variable_value": "0    (0, 1]\ndtype: interval",
                                    "variable_type": "Series",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "0    (0, 1]\ndtype: object",
                                    "variable_type": "Series",
                                    "variable_shape": "(1,)"
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_series_type": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "assert_class_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "obj": {
                                    "variable_value": "'Series'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "msg1": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.index": {
                                    "variable_value": "RangeIndex(start=0, stop=1, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(1,)"
                                },
                                "msg2": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.index": {
                                    "variable_value": "RangeIndex(start=0, stop=1, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(1,)"
                                },
                                "raise_assert_detail": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_index_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_index_type": {
                                    "variable_value": "'equiv'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "check_names": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_less_precise": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_exact": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_categorical": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_dtype": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "is_categorical_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "interval[int64]",
                                    "variable_type": "IntervalDtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "assert_attr_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_numeric_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_numpy_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left._values": {
                                    "variable_value": "<IntervalArray>\n[(0, 1]]\nLength: 1, closed: right, dtype: interval[int64]",
                                    "variable_type": "IntervalArray",
                                    "variable_shape": "(1,)"
                                },
                                "right._values": {
                                    "variable_value": "array([Interval(0, 1, closed='right')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "check_datetimelike_compat": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "equals": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "msg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_interval_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_interval_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.array": {
                                    "variable_value": "<IntervalArray>\n[(0, 1]]\nLength: 1, closed: right, dtype: interval[int64]",
                                    "variable_type": "IntervalArray",
                                    "variable_shape": "(1,)"
                                },
                                "right.array": {
                                    "variable_value": "<PandasArray>\n[Interval(0, 1, closed='right')]\nLength: 1, dtype: object",
                                    "variable_type": "PandasArray",
                                    "variable_shape": "(1,)"
                                },
                                "_testing.assert_almost_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_testing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_extension_array_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_extension_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_categorical_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_category_order": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "__tracebackhide__": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_check_isinstance": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left": {
                                    "variable_value": "0    1\n1    2\n2    3\nName: a, dtype: Int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(3,)"
                                },
                                "right": {
                                    "variable_value": "0    1\n1    2\n2    3\nName: a, dtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(3,)"
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_series_type": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "assert_class_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "obj": {
                                    "variable_value": "'DataFrame.iloc[:, 0] (column name=\"a\")'",
                                    "variable_type": "str",
                                    "variable_shape": "38"
                                },
                                "msg1": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.index": {
                                    "variable_value": "RangeIndex(start=0, stop=3, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(3,)"
                                },
                                "msg2": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.index": {
                                    "variable_value": "RangeIndex(start=0, stop=3, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(3,)"
                                },
                                "raise_assert_detail": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_index_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_index_type": {
                                    "variable_value": "'equiv'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "check_names": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_less_precise": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_exact": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_categorical": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_dtype": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "is_categorical_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "Int64Dtype()",
                                    "variable_type": "Int64Dtype",
                                    "variable_shape": null
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('int64')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "assert_attr_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_numeric_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_numpy_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left._values": {
                                    "variable_value": "<IntegerArray>\n[1, 2, 3]\nLength: 3, dtype: Int64",
                                    "variable_type": "IntegerArray",
                                    "variable_shape": "(3,)"
                                },
                                "right._values": {
                                    "variable_value": "array([1, 2, 3])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(3,)"
                                },
                                "check_datetimelike_compat": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "equals": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "msg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_interval_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_interval_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.array": {
                                    "variable_value": "<IntegerArray>\n[1, 2, 3]\nLength: 3, dtype: Int64",
                                    "variable_type": "IntegerArray",
                                    "variable_shape": "(3,)"
                                },
                                "right.array": {
                                    "variable_value": "<PandasArray>\n[1, 2, 3]\nLength: 3, dtype: int64",
                                    "variable_type": "PandasArray",
                                    "variable_shape": "(3,)"
                                },
                                "_testing.assert_almost_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_testing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_extension_array_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_extension_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_categorical_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_category_order": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "__tracebackhide__": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "_check_isinstance": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left": {
                                    "variable_value": "0    1\n1    2\n2    3\nName: a, dtype: Int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(3,)"
                                },
                                "right": {
                                    "variable_value": "0    1\n1    2\n2    3\nName: a, dtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(3,)"
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_series_type": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "assert_class_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "obj": {
                                    "variable_value": "'DataFrame.iloc[:, 0] (column name=\"a\")'",
                                    "variable_type": "str",
                                    "variable_shape": "38"
                                },
                                "msg1": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.index": {
                                    "variable_value": "RangeIndex(start=0, stop=3, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(3,)"
                                },
                                "msg2": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.index": {
                                    "variable_value": "RangeIndex(start=0, stop=3, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(3,)"
                                },
                                "raise_assert_detail": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_index_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_index_type": {
                                    "variable_value": "'equiv'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "check_names": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_less_precise": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_exact": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_categorical": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_dtype": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "is_categorical_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "Int64Dtype()",
                                    "variable_type": "Int64Dtype",
                                    "variable_shape": null
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('int64')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "assert_attr_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_numeric_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_numpy_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left._values": {
                                    "variable_value": "<IntegerArray>\n[1, 2, 3]\nLength: 3, dtype: Int64",
                                    "variable_type": "IntegerArray",
                                    "variable_shape": "(3,)"
                                },
                                "right._values": {
                                    "variable_value": "array([1, 2, 3])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(3,)"
                                },
                                "check_datetimelike_compat": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "equals": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "msg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_interval_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_interval_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.array": {
                                    "variable_value": "<IntegerArray>\n[1, 2, 3]\nLength: 3, dtype: Int64",
                                    "variable_type": "IntegerArray",
                                    "variable_shape": "(3,)"
                                },
                                "right.array": {
                                    "variable_value": "<PandasArray>\n[1, 2, 3]\nLength: 3, dtype: int64",
                                    "variable_type": "PandasArray",
                                    "variable_shape": "(3,)"
                                },
                                "_testing.assert_almost_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_testing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_extension_array_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_extension_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_categorical_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_category_order": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "__tracebackhide__": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_check_isinstance": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left": {
                                    "variable_value": "0    (0, 1]\nName: a, dtype: interval",
                                    "variable_type": "Series",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "0    (0, 1]\nName: a, dtype: object",
                                    "variable_type": "Series",
                                    "variable_shape": "(1,)"
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_series_type": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "assert_class_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "obj": {
                                    "variable_value": "'DataFrame.iloc[:, 0] (column name=\"a\")'",
                                    "variable_type": "str",
                                    "variable_shape": "38"
                                },
                                "msg1": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.index": {
                                    "variable_value": "RangeIndex(start=0, stop=1, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(1,)"
                                },
                                "msg2": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.index": {
                                    "variable_value": "RangeIndex(start=0, stop=1, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(1,)"
                                },
                                "raise_assert_detail": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_index_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_index_type": {
                                    "variable_value": "'equiv'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "check_names": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_less_precise": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_exact": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_categorical": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_dtype": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "is_categorical_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "interval[int64]",
                                    "variable_type": "IntervalDtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "assert_attr_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_numeric_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_numpy_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left._values": {
                                    "variable_value": "<IntervalArray>\n[(0, 1]]\nLength: 1, closed: right, dtype: interval[int64]",
                                    "variable_type": "IntervalArray",
                                    "variable_shape": "(1,)"
                                },
                                "right._values": {
                                    "variable_value": "array([Interval(0, 1, closed='right')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "check_datetimelike_compat": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "equals": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "msg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_interval_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_interval_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.array": {
                                    "variable_value": "<IntervalArray>\n[(0, 1]]\nLength: 1, closed: right, dtype: interval[int64]",
                                    "variable_type": "IntervalArray",
                                    "variable_shape": "(1,)"
                                },
                                "right.array": {
                                    "variable_value": "<PandasArray>\n[Interval(0, 1, closed='right')]\nLength: 1, dtype: object",
                                    "variable_type": "PandasArray",
                                    "variable_shape": "(1,)"
                                },
                                "_testing.assert_almost_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_testing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_extension_array_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_extension_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_categorical_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_category_order": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "__tracebackhide__": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "_check_isinstance": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left": {
                                    "variable_value": "0    (0, 1]\nName: a, dtype: interval",
                                    "variable_type": "Series",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "0    (0, 1]\nName: a, dtype: object",
                                    "variable_type": "Series",
                                    "variable_shape": "(1,)"
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_series_type": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "assert_class_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "obj": {
                                    "variable_value": "'DataFrame.iloc[:, 0] (column name=\"a\")'",
                                    "variable_type": "str",
                                    "variable_shape": "38"
                                },
                                "msg1": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.index": {
                                    "variable_value": "RangeIndex(start=0, stop=1, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(1,)"
                                },
                                "msg2": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.index": {
                                    "variable_value": "RangeIndex(start=0, stop=1, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(1,)"
                                },
                                "raise_assert_detail": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_index_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_index_type": {
                                    "variable_value": "'equiv'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "check_names": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_less_precise": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_exact": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_categorical": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_dtype": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "is_categorical_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "interval[int64]",
                                    "variable_type": "IntervalDtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "assert_attr_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_numeric_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_numpy_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left._values": {
                                    "variable_value": "<IntervalArray>\n[(0, 1]]\nLength: 1, closed: right, dtype: interval[int64]",
                                    "variable_type": "IntervalArray",
                                    "variable_shape": "(1,)"
                                },
                                "right._values": {
                                    "variable_value": "array([Interval(0, 1, closed='right')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "check_datetimelike_compat": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "equals": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "msg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_interval_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_interval_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.array": {
                                    "variable_value": "<IntervalArray>\n[(0, 1]]\nLength: 1, closed: right, dtype: interval[int64]",
                                    "variable_type": "IntervalArray",
                                    "variable_shape": "(1,)"
                                },
                                "right.array": {
                                    "variable_value": "<PandasArray>\n[Interval(0, 1, closed='right')]\nLength: 1, dtype: object",
                                    "variable_type": "PandasArray",
                                    "variable_shape": "(1,)"
                                },
                                "_testing.assert_almost_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_testing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_extension_array_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_extension_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_categorical_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_category_order": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "__tracebackhide__": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_check_isinstance": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left": {
                                    "variable_value": "0    1\n1    2\n2    3\ndtype: Int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(3,)"
                                },
                                "right": {
                                    "variable_value": "0    1\n1    2\n2    3\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(3,)"
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_series_type": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "assert_class_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "obj": {
                                    "variable_value": "'Series'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "msg1": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.index": {
                                    "variable_value": "RangeIndex(start=0, stop=3, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(3,)"
                                },
                                "msg2": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.index": {
                                    "variable_value": "RangeIndex(start=0, stop=3, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(3,)"
                                },
                                "raise_assert_detail": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_index_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_index_type": {
                                    "variable_value": "'equiv'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "check_names": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_less_precise": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_exact": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_categorical": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_dtype": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "is_categorical_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "Int64Dtype()",
                                    "variable_type": "Int64Dtype",
                                    "variable_shape": null
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('int64')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "assert_attr_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_numeric_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_numpy_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left._values": {
                                    "variable_value": "<IntegerArray>\n[1, 2, 3]\nLength: 3, dtype: Int64",
                                    "variable_type": "IntegerArray",
                                    "variable_shape": "(3,)"
                                },
                                "right._values": {
                                    "variable_value": "array([1, 2, 3])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(3,)"
                                },
                                "check_datetimelike_compat": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "equals": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "msg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_interval_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_interval_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.array": {
                                    "variable_value": "<IntegerArray>\n[1, 2, 3]\nLength: 3, dtype: Int64",
                                    "variable_type": "IntegerArray",
                                    "variable_shape": "(3,)"
                                },
                                "right.array": {
                                    "variable_value": "<PandasArray>\n[1, 2, 3]\nLength: 3, dtype: int64",
                                    "variable_type": "PandasArray",
                                    "variable_shape": "(3,)"
                                },
                                "_testing.assert_almost_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_testing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_extension_array_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_extension_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_categorical_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_category_order": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "__tracebackhide__": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "_check_isinstance": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left": {
                                    "variable_value": "0    1\n1    2\n2    3\ndtype: Int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(3,)"
                                },
                                "right": {
                                    "variable_value": "0    1\n1    2\n2    3\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "(3,)"
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_series_type": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "assert_class_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "obj": {
                                    "variable_value": "'Series'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "msg1": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.index": {
                                    "variable_value": "RangeIndex(start=0, stop=3, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(3,)"
                                },
                                "msg2": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.index": {
                                    "variable_value": "RangeIndex(start=0, stop=3, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(3,)"
                                },
                                "raise_assert_detail": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_index_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_index_type": {
                                    "variable_value": "'equiv'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "check_names": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_less_precise": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_exact": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_categorical": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_dtype": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "is_categorical_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "Int64Dtype()",
                                    "variable_type": "Int64Dtype",
                                    "variable_shape": null
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('int64')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "assert_attr_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_numeric_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_numpy_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left._values": {
                                    "variable_value": "<IntegerArray>\n[1, 2, 3]\nLength: 3, dtype: Int64",
                                    "variable_type": "IntegerArray",
                                    "variable_shape": "(3,)"
                                },
                                "right._values": {
                                    "variable_value": "array([1, 2, 3])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(3,)"
                                },
                                "check_datetimelike_compat": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "equals": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "msg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_interval_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_interval_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.array": {
                                    "variable_value": "<IntegerArray>\n[1, 2, 3]\nLength: 3, dtype: Int64",
                                    "variable_type": "IntegerArray",
                                    "variable_shape": "(3,)"
                                },
                                "right.array": {
                                    "variable_value": "<PandasArray>\n[1, 2, 3]\nLength: 3, dtype: int64",
                                    "variable_type": "PandasArray",
                                    "variable_shape": "(3,)"
                                },
                                "_testing.assert_almost_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_testing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_extension_array_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_extension_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_categorical_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_category_order": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "__tracebackhide__": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_check_isinstance": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left": {
                                    "variable_value": "0    (0, 1]\ndtype: interval",
                                    "variable_type": "Series",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "0    (0, 1]\ndtype: object",
                                    "variable_type": "Series",
                                    "variable_shape": "(1,)"
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_series_type": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "assert_class_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "obj": {
                                    "variable_value": "'Series'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "msg1": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.index": {
                                    "variable_value": "RangeIndex(start=0, stop=1, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(1,)"
                                },
                                "msg2": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.index": {
                                    "variable_value": "RangeIndex(start=0, stop=1, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(1,)"
                                },
                                "raise_assert_detail": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_index_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_index_type": {
                                    "variable_value": "'equiv'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "check_names": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_less_precise": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_exact": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_categorical": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_dtype": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "is_categorical_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "interval[int64]",
                                    "variable_type": "IntervalDtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "assert_attr_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_numeric_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_numpy_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left._values": {
                                    "variable_value": "<IntervalArray>\n[(0, 1]]\nLength: 1, closed: right, dtype: interval[int64]",
                                    "variable_type": "IntervalArray",
                                    "variable_shape": "(1,)"
                                },
                                "right._values": {
                                    "variable_value": "array([Interval(0, 1, closed='right')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "check_datetimelike_compat": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "equals": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "msg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_interval_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_interval_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.array": {
                                    "variable_value": "<IntervalArray>\n[(0, 1]]\nLength: 1, closed: right, dtype: interval[int64]",
                                    "variable_type": "IntervalArray",
                                    "variable_shape": "(1,)"
                                },
                                "right.array": {
                                    "variable_value": "<PandasArray>\n[Interval(0, 1, closed='right')]\nLength: 1, dtype: object",
                                    "variable_type": "PandasArray",
                                    "variable_shape": "(1,)"
                                },
                                "_testing.assert_almost_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_testing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_extension_array_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_extension_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_categorical_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_category_order": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "__tracebackhide__": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "_check_isinstance": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left": {
                                    "variable_value": "0    (0, 1]\ndtype: interval",
                                    "variable_type": "Series",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "0    (0, 1]\ndtype: object",
                                    "variable_type": "Series",
                                    "variable_shape": "(1,)"
                                },
                                "Series": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_series_type": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "assert_class_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "obj": {
                                    "variable_value": "'Series'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "msg1": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.index": {
                                    "variable_value": "RangeIndex(start=0, stop=1, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(1,)"
                                },
                                "msg2": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.index": {
                                    "variable_value": "RangeIndex(start=0, stop=1, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(1,)"
                                },
                                "raise_assert_detail": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_index_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_index_type": {
                                    "variable_value": "'equiv'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "check_names": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_less_precise": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_exact": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_categorical": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "check_dtype": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "is_categorical_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "interval[int64]",
                                    "variable_type": "IntervalDtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "assert_attr_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_numeric_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_numpy_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left._values": {
                                    "variable_value": "<IntervalArray>\n[(0, 1]]\nLength: 1, closed: right, dtype: interval[int64]",
                                    "variable_type": "IntervalArray",
                                    "variable_shape": "(1,)"
                                },
                                "right._values": {
                                    "variable_value": "array([Interval(0, 1, closed='right')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "check_datetimelike_compat": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "equals": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "msg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_interval_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_interval_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.array": {
                                    "variable_value": "<IntervalArray>\n[(0, 1]]\nLength: 1, closed: right, dtype: interval[int64]",
                                    "variable_type": "IntervalArray",
                                    "variable_shape": "(1,)"
                                },
                                "right.array": {
                                    "variable_value": "<PandasArray>\n[Interval(0, 1, closed='right')]\nLength: 1, dtype: object",
                                    "variable_type": "PandasArray",
                                    "variable_shape": "(1,)"
                                },
                                "_testing.assert_almost_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_testing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_extension_array_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_extension_array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "assert_categorical_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_category_order": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def set_testing_mode():\n    # set the testing mode filters\n    testing_mode = os.environ.get(\"PANDAS_TESTING_MODE\", \"None\")\n    if \"deprecate\" in testing_mode:\n        warnings.simplefilter(\"always\", _testing_mode_warnings)",
                "def reset_testing_mode():\n    # reset the testing mode filters\n    testing_mode = os.environ.get(\"PANDAS_TESTING_MODE\", \"None\")\n    if \"deprecate\" in testing_mode:\n        warnings.simplefilter(\"ignore\", _testing_mode_warnings)",
                "def reset_display_options():\n    \"\"\"\n    Reset the display options for printing and representing objects.\n    \"\"\"\n    pd.reset_option(\"^display.\", silent=True)",
                "def round_trip_pickle(\n    obj: Any, path: Optional[FilePathOrBuffer] = None\n) -> FrameOrSeries:\n    \"\"\"\n    Pickle an object and then read it again.\n\n    Parameters\n    ----------\n    obj : any object\n        The object to pickle and then re-read.\n    path : str, path object or file-like object, default None\n        The path where the pickled object is written and then read.\n\n    Returns\n    -------\n    pandas object\n        The original object that was pickled and then re-read.\n    \"\"\"\n    _path = path\n    if _path is None:\n        _path = f\"__{rands(10)}__.pickle\"\n    with ensure_clean(_path) as temp_path:\n        pd.to_pickle(obj, temp_path)\n        return pd.read_pickle(temp_path)",
                "def round_trip_pathlib(writer, reader, path: Optional[str] = None):\n    \"\"\"\n    Write an object to file specified by a pathlib.Path and read it back\n\n    Parameters\n    ----------\n    writer : callable bound to pandas object\n        IO writing function (e.g. DataFrame.to_csv )\n    reader : callable\n        IO reading function (e.g. pd.read_csv )\n    path : str, default None\n        The path where the object is written and then read.\n\n    Returns\n    -------\n    pandas object\n        The original object that was serialized and then re-read.\n    \"\"\"\n    import pytest\n\n    Path = pytest.importorskip(\"pathlib\").Path\n    if path is None:\n        path = \"___pathlib___\"\n    with ensure_clean(path) as path:\n        writer(Path(path))\n        obj = reader(Path(path))\n    return obj",
                "def round_trip_localpath(writer, reader, path: Optional[str] = None):\n    \"\"\"\n    Write an object to file specified by a py.path LocalPath and read it back.\n\n    Parameters\n    ----------\n    writer : callable bound to pandas object\n        IO writing function (e.g. DataFrame.to_csv )\n    reader : callable\n        IO reading function (e.g. pd.read_csv )\n    path : str, default None\n        The path where the object is written and then read.\n\n    Returns\n    -------\n    pandas object\n        The original object that was serialized and then re-read.\n    \"\"\"\n    import pytest\n\n    LocalPath = pytest.importorskip(\"py.path\").local\n    if path is None:\n        path = \"___localpath___\"\n    with ensure_clean(path) as path:\n        writer(LocalPath(path))\n        obj = reader(LocalPath(path))\n    return obj",
                "@contextmanager\ndef decompress_file(path, compression):\n    \"\"\"\n    Open a compressed file and return a file object.\n\n    Parameters\n    ----------\n    path : str\n        The path where the file is read from.\n\n    compression : {'gzip', 'bz2', 'zip', 'xz', None}\n        Name of the decompression to use\n\n    Returns\n    -------\n    file object\n    \"\"\"\n    if compression is None:\n        f = open(path, \"rb\")\n    elif compression == \"gzip\":\n        f = gzip.open(path, \"rb\")\n    elif compression == \"bz2\":\n        f = bz2.BZ2File(path, \"rb\")\n    elif compression == \"xz\":\n        f = _get_lzma_file(lzma)(path, \"rb\")\n    elif compression == \"zip\":\n        zip_file = zipfile.ZipFile(path)\n        zip_names = zip_file.namelist()\n        if len(zip_names) == 1:\n            f = zip_file.open(zip_names.pop())\n        else:\n            raise ValueError(f\"ZIP file {path} error. Only one file per ZIP.\")\n    else:\n        raise ValueError(f\"Unrecognized compression type: {compression}\")\n\n    try:\n        yield f\n    finally:\n        f.close()\n        if compression == \"zip\":\n            zip_file.close()",
                "def write_to_compressed(compression, path, data, dest=\"test\"):\n    \"\"\"\n    Write data to a compressed file.\n\n    Parameters\n    ----------\n    compression : {'gzip', 'bz2', 'zip', 'xz'}\n        The compression type to use.\n    path : str\n        The file path to write the data.\n    data : str\n        The data to write.\n    dest : str, default \"test\"\n        The destination file (for ZIP only)\n\n    Raises\n    ------\n    ValueError : An invalid compression value was passed in.\n    \"\"\"\n    if compression == \"zip\":\n        import zipfile\n\n        compress_method = zipfile.ZipFile\n    elif compression == \"gzip\":\n        import gzip\n\n        compress_method = gzip.GzipFile\n    elif compression == \"bz2\":\n        import bz2\n\n        compress_method = bz2.BZ2File\n    elif compression == \"xz\":\n        compress_method = _get_lzma_file(lzma)\n    else:\n        raise ValueError(f\"Unrecognized compression type: {compression}\")\n\n    if compression == \"zip\":\n        mode = \"w\"\n        args = (dest, data)\n        method = \"writestr\"\n    else:\n        mode = \"wb\"\n        args = (data,)\n        method = \"write\"\n\n    with compress_method(path, mode=mode) as f:\n        getattr(f, method)(*args)",
                "def assert_almost_equal(\n    left,\n    right,\n    check_dtype: Union[bool, str] = \"equiv\",\n    check_less_precise: Union[bool, int] = False,\n    **kwargs,\n):\n    \"\"\"\n    Check that the left and right objects are approximately equal.\n\n    By approximately equal, we refer to objects that are numbers or that\n    contain numbers which may be equivalent to specific levels of precision.\n\n    Parameters\n    ----------\n    left : object\n    right : object\n    check_dtype : bool or {'equiv'}, default 'equiv'\n        Check dtype if both a and b are the same type. If 'equiv' is passed in,\n        then `RangeIndex` and `Int64Index` are also considered equivalent\n        when doing type checking.\n    check_less_precise : bool or int, default False\n        Specify comparison precision. 5 digits (False) or 3 digits (True)\n        after decimal points are compared. If int, then specify the number\n        of digits to compare.\n\n        When comparing two numbers, if the first number has magnitude less\n        than 1e-5, we compare the two numbers directly and check whether\n        they are equivalent within the specified precision. Otherwise, we\n        compare the **ratio** of the second number to the first number and\n        check whether it is equivalent to 1 within the specified precision.\n    \"\"\"\n    if isinstance(left, pd.Index):\n        assert_index_equal(\n            left,\n            right,\n            check_exact=False,\n            exact=check_dtype,\n            check_less_precise=check_less_precise,\n            **kwargs,\n        )\n\n    elif isinstance(left, pd.Series):\n        assert_series_equal(\n            left,\n            right,\n            check_exact=False,\n            check_dtype=check_dtype,\n            check_less_precise=check_less_precise,\n            **kwargs,\n        )\n\n    elif isinstance(left, pd.DataFrame):\n        assert_frame_equal(\n            left,\n            right,\n            check_exact=False,\n            check_dtype=check_dtype,\n            check_less_precise=check_less_precise,\n            **kwargs,\n        )\n\n    else:\n        # Other sequences.\n        if check_dtype:\n            if is_number(left) and is_number(right):\n                # Do not compare numeric classes, like np.float64 and float.\n                pass\n            elif is_bool(left) and is_bool(right):\n                # Do not compare bool classes, like np.bool_ and bool.\n                pass\n            else:\n                if isinstance(left, np.ndarray) or isinstance(right, np.ndarray):\n                    obj = \"numpy array\"\n                else:\n                    obj = \"Input\"\n                assert_class_equal(left, right, obj=obj)\n        _testing.assert_almost_equal(\n            left,\n            right,\n            check_dtype=check_dtype,\n            check_less_precise=check_less_precise,\n            **kwargs,\n        )",
                "def _check_isinstance(left, right, cls):\n    \"\"\"\n    Helper method for our assert_* methods that ensures that\n    the two objects being compared have the right type before\n    proceeding with the comparison.\n\n    Parameters\n    ----------\n    left : The first object being compared.\n    right : The second object being compared.\n    cls : The class type to check against.\n\n    Raises\n    ------\n    AssertionError : Either `left` or `right` is not an instance of `cls`.\n    \"\"\"\n    cls_name = cls.__name__\n\n    if not isinstance(left, cls):\n        raise AssertionError(\n            f\"{cls_name} Expected type {cls}, found {type(left)} instead\"\n        )\n    if not isinstance(right, cls):\n        raise AssertionError(\n            f\"{cls_name} Expected type {cls}, found {type(right)} instead\"\n        )",
                "def assert_dict_equal(left, right, compare_keys: bool = True):\n\n    _check_isinstance(left, right, dict)\n    _testing.assert_dict_equal(left, right, compare_keys=compare_keys)",
                "def randbool(size=(), p: float = 0.5):\n    return rand(*size) <= p",
                "def rands_array(nchars, size, dtype=\"O\"):\n    \"\"\"\n    Generate an array of byte strings.\n    \"\"\"\n    retval = (\n        np.random.choice(RANDS_CHARS, size=nchars * np.prod(size))\n        .view((np.str_, nchars))\n        .reshape(size)\n    )\n    return retval.astype(dtype)",
                "def randu_array(nchars, size, dtype=\"O\"):\n    \"\"\"\n    Generate an array of unicode strings.\n    \"\"\"\n    retval = (\n        np.random.choice(RANDU_CHARS, size=nchars * np.prod(size))\n        .view((np.unicode_, nchars))\n        .reshape(size)\n    )\n    return retval.astype(dtype)",
                "def rands(nchars):\n    \"\"\"\n    Generate one random byte string.\n\n    See `rands_array` if you want to create an array of random strings.\n\n    \"\"\"\n    return \"\".join(np.random.choice(RANDS_CHARS, nchars))",
                "def close(fignum=None):\n    from matplotlib.pyplot import get_fignums, close as _close\n\n    if fignum is None:\n        for fignum in get_fignums():\n            _close(fignum)\n    else:\n        _close(fignum)",
                "@contextmanager\ndef ensure_clean(filename=None, return_filelike=False, **kwargs):\n    \"\"\"\n    Gets a temporary path and agrees to remove on close.\n\n    Parameters\n    ----------\n    filename : str (optional)\n        if None, creates a temporary file which is then removed when out of\n        scope. if passed, creates temporary file with filename as ending.\n    return_filelike : bool (default False)\n        if True, returns a file-like which is *always* cleaned. Necessary for\n        savefig and other functions which want to append extensions.\n    **kwargs\n        Additional keywords passed in for creating a temporary file.\n        :meth:`tempFile.TemporaryFile` is used when `return_filelike` is ``True``.\n        :meth:`tempfile.mkstemp` is used when `return_filelike` is ``False``.\n        Note that the `filename` parameter will be passed in as the `suffix`\n        argument to either function.\n\n    See Also\n    --------\n    tempfile.TemporaryFile\n    tempfile.mkstemp\n    \"\"\"\n    filename = filename or \"\"\n    fd = None\n\n    kwargs[\"suffix\"] = filename\n\n    if return_filelike:\n        f = tempfile.TemporaryFile(**kwargs)\n\n        try:\n            yield f\n        finally:\n            f.close()\n    else:\n        # Don't generate tempfile if using a path with directory specified.\n        if len(os.path.dirname(filename)):\n            raise ValueError(\"Can't pass a qualified name to ensure_clean()\")\n\n        try:\n            fd, filename = tempfile.mkstemp(**kwargs)\n        except UnicodeEncodeError:\n            import pytest\n\n            pytest.skip(\"no unicode file names on this system\")\n\n        try:\n            yield filename\n        finally:\n            try:\n                os.close(fd)\n            except OSError:\n                print(f\"Couldn't close file descriptor: {fd} (file: {filename})\")\n            try:\n                if os.path.exists(filename):\n                    os.remove(filename)\n            except OSError as e:\n                print(f\"Exception on removing file: {e}\")",
                "@contextmanager\ndef ensure_clean_dir():\n    \"\"\"\n    Get a temporary directory path and agrees to remove on close.\n\n    Yields\n    ------\n    Temporary directory path\n    \"\"\"\n    directory_name = tempfile.mkdtemp(suffix=\"\")\n    try:\n        yield directory_name\n    finally:\n        try:\n            rmtree(directory_name)\n        except OSError:\n            pass",
                "@contextmanager\ndef ensure_safe_environment_variables():\n    \"\"\"\n    Get a context manager to safely set environment variables\n\n    All changes will be undone on close, hence environment variables set\n    within this contextmanager will neither persist nor change global state.\n    \"\"\"\n    saved_environ = dict(os.environ)\n    try:\n        yield\n    finally:\n        os.environ.clear()\n        os.environ.update(saved_environ)",
                "def equalContents(arr1, arr2) -> bool:\n    \"\"\"\n    Checks if the set of unique elements of arr1 and arr2 are equivalent.\n    \"\"\"\n    return frozenset(arr1) == frozenset(arr2)",
                "def assert_index_equal(\n    left: Index,\n    right: Index,\n    exact: Union[bool, str] = \"equiv\",\n    check_names: bool = True,\n    check_less_precise: Union[bool, int] = False,\n    check_exact: bool = True,\n    check_categorical: bool = True,\n    obj: str = \"Index\",\n) -> None:\n    \"\"\"\n    Check that left and right Index are equal.\n\n    Parameters\n    ----------\n    left : Index\n    right : Index\n    exact : bool or {'equiv'}, default 'equiv'\n        Whether to check the Index class, dtype and inferred_type\n        are identical. If 'equiv', then RangeIndex can be substituted for\n        Int64Index as well.\n    check_names : bool, default True\n        Whether to check the names attribute.\n    check_less_precise : bool or int, default False\n        Specify comparison precision. Only used when check_exact is False.\n        5 digits (False) or 3 digits (True) after decimal points are compared.\n        If int, then specify the digits to compare.\n    check_exact : bool, default True\n        Whether to compare number exactly.\n    check_categorical : bool, default True\n        Whether to compare internal Categorical exactly.\n    obj : str, default 'Index'\n        Specify object name being compared, internally used to show appropriate\n        assertion message.\n    \"\"\"\n    __tracebackhide__ = True\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n\n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n                assert_attr_equal(\"dtype\", l, r, obj=obj)\n\n            # allow string-like to have different inferred_types\n            if l.inferred_type in (\"string\"):\n                assert r.inferred_type in (\"string\")\n            else:\n                assert_attr_equal(\"inferred_type\", l, r, obj=obj)\n\n    def _get_ilevel_values(index, level):\n        # accept level number only\n        unique = index.levels[level]\n        level_codes = index.codes[level]\n        filled = take_1d(unique._values, level_codes, fill_value=unique._na_value)\n        values = unique._shallow_copy(filled, name=index.names[level])\n        return values\n\n    # instance validation\n    _check_isinstance(left, right, Index)\n\n    # class / dtype comparison\n    _check_types(left, right, obj=obj)\n\n    # level comparison\n    if left.nlevels != right.nlevels:\n        msg1 = f\"{obj} levels are different\"\n        msg2 = f\"{left.nlevels}, {left}\"\n        msg3 = f\"{right.nlevels}, {right}\"\n        raise_assert_detail(obj, msg1, msg2, msg3)\n\n    # length comparison\n    if len(left) != len(right):\n        msg1 = f\"{obj} length are different\"\n        msg2 = f\"{len(left)}, {left}\"\n        msg3 = f\"{len(right)}, {right}\"\n        raise_assert_detail(obj, msg1, msg2, msg3)\n\n    # MultiIndex special comparison for little-friendly error messages\n    if left.nlevels > 1:\n        left = cast(MultiIndex, left)\n        right = cast(MultiIndex, right)\n\n        for level in range(left.nlevels):\n            # cannot use get_level_values here because it can change dtype\n            llevel = _get_ilevel_values(left, level)\n            rlevel = _get_ilevel_values(right, level)\n\n            lobj = f\"MultiIndex level [{level}]\"\n            assert_index_equal(\n                llevel,\n                rlevel,\n                exact=exact,\n                check_names=check_names,\n                check_less_precise=check_less_precise,\n                check_exact=check_exact,\n                obj=lobj,\n            )\n            # get_level_values may change dtype\n            _check_types(left.levels[level], right.levels[level], obj=obj)\n\n    # skip exact index checking when `check_categorical` is False\n    if check_exact and check_categorical:\n        if not left.equals(right):\n            diff = np.sum((left.values != right.values).astype(int)) * 100.0 / len(left)\n            msg = f\"{obj} values are different ({np.round(diff, 5)} %)\"\n            raise_assert_detail(obj, msg, left, right)\n    else:\n        _testing.assert_almost_equal(\n            left.values,\n            right.values,\n            check_less_precise=check_less_precise,\n            check_dtype=exact,\n            obj=obj,\n            lobj=left,\n            robj=right,\n        )\n\n    # metadata comparison\n    if check_names:\n        assert_attr_equal(\"names\", left, right, obj=obj)\n    if isinstance(left, pd.PeriodIndex) or isinstance(right, pd.PeriodIndex):\n        assert_attr_equal(\"freq\", left, right, obj=obj)\n    if isinstance(left, pd.IntervalIndex) or isinstance(right, pd.IntervalIndex):\n        assert_interval_array_equal(left._values, right._values)\n\n    if check_categorical:\n        if is_categorical_dtype(left) or is_categorical_dtype(right):\n            assert_categorical_equal(left._values, right._values, obj=f\"{obj} category\")",
                "def assert_class_equal(left, right, exact: Union[bool, str] = True, obj=\"Input\"):\n    \"\"\"\n    Checks classes are equal.\n    \"\"\"\n    __tracebackhide__ = True\n\n    def repr_class(x):\n        if isinstance(x, Index):\n            # return Index as it is to include values in the error message\n            return x\n\n        return type(x).__name__\n\n    if exact == \"equiv\":\n        if type(left) != type(right):\n            # allow equivalence of Int64Index/RangeIndex\n            types = {type(left).__name__, type(right).__name__}\n            if len(types - {\"Int64Index\", \"RangeIndex\"}):\n                msg = f\"{obj} classes are not equivalent\"\n                raise_assert_detail(obj, msg, repr_class(left), repr_class(right))\n    elif exact:\n        if type(left) != type(right):\n            msg = f\"{obj} classes are different\"\n            raise_assert_detail(obj, msg, repr_class(left), repr_class(right))",
                "def assert_attr_equal(attr: str, left, right, obj: str = \"Attributes\"):\n    \"\"\"\n    Check attributes are equal. Both objects must have attribute.\n\n    Parameters\n    ----------\n    attr : str\n        Attribute name being compared.\n    left : object\n    right : object\n    obj : str, default 'Attributes'\n        Specify object name being compared, internally used to show appropriate\n        assertion message\n    \"\"\"\n    __tracebackhide__ = True\n\n    left_attr = getattr(left, attr)\n    right_attr = getattr(right, attr)\n\n    if left_attr is right_attr:\n        return True\n    elif (\n        is_number(left_attr)\n        and np.isnan(left_attr)\n        and is_number(right_attr)\n        and np.isnan(right_attr)\n    ):\n        # np.nan\n        return True\n\n    try:\n        result = left_attr == right_attr\n    except TypeError:\n        # datetimetz on rhs may raise TypeError\n        result = False\n    if not isinstance(result, bool):\n        result = result.all()\n\n    if result:\n        return True\n    else:\n        msg = f'Attribute \"{attr}\" are different'\n        raise_assert_detail(obj, msg, left_attr, right_attr)",
                "def assert_is_valid_plot_return_object(objs):\n    import matplotlib.pyplot as plt\n\n    if isinstance(objs, (pd.Series, np.ndarray)):\n        for el in objs.ravel():\n            msg = (\n                \"one of 'objs' is not a matplotlib Axes instance, \"\n                f\"type encountered {repr(type(el).__name__)}\"\n            )\n            assert isinstance(el, (plt.Axes, dict)), msg\n    else:\n        msg = (\n            \"objs is neither an ndarray of Artist instances nor a single \"\n            \"ArtistArtist instance, tuple, or dict, 'objs' is a \"\n            f\"{repr(type(objs).__name__)}\"\n        )\n        assert isinstance(objs, (plt.Artist, tuple, dict)), msg",
                "def assert_is_sorted(seq):\n    \"\"\"Assert that the sequence is sorted.\"\"\"\n    if isinstance(seq, (Index, Series)):\n        seq = seq.values\n    # sorting does not change precisions\n    assert_numpy_array_equal(seq, np.sort(np.array(seq)))",
                "def assert_categorical_equal(\n    left, right, check_dtype=True, check_category_order=True, obj=\"Categorical\"\n):\n    \"\"\"\n    Test that Categoricals are equivalent.\n\n    Parameters\n    ----------\n    left : Categorical\n    right : Categorical\n    check_dtype : bool, default True\n        Check that integer dtype of the codes are the same\n    check_category_order : bool, default True\n        Whether the order of the categories should be compared, which\n        implies identical integer codes.  If False, only the resulting\n        values are compared.  The ordered attribute is\n        checked regardless.\n    obj : str, default 'Categorical'\n        Specify object name being compared, internally used to show appropriate\n        assertion message\n    \"\"\"\n    _check_isinstance(left, right, Categorical)\n\n    if check_category_order:\n        assert_index_equal(left.categories, right.categories, obj=f\"{obj}.categories\")\n        assert_numpy_array_equal(\n            left.codes, right.codes, check_dtype=check_dtype, obj=f\"{obj}.codes\",\n        )\n    else:\n        try:\n            lc = left.categories.sort_values()\n            rc = right.categories.sort_values()\n        except TypeError:\n            # e.g. '<' not supported between instances of 'int' and 'str'\n            lc, rc = left.categories, right.categories\n        assert_index_equal(\n            lc, rc, obj=f\"{obj}.categories\",\n        )\n        assert_index_equal(\n            left.categories.take(left.codes),\n            right.categories.take(right.codes),\n            obj=f\"{obj}.values\",\n        )\n\n    assert_attr_equal(\"ordered\", left, right, obj=obj)",
                "def assert_interval_array_equal(left, right, exact=\"equiv\", obj=\"IntervalArray\"):\n    \"\"\"\n    Test that two IntervalArrays are equivalent.\n\n    Parameters\n    ----------\n    left, right : IntervalArray\n        The IntervalArrays to compare.\n    exact : bool or {'equiv'}, default 'equiv'\n        Whether to check the Index class, dtype and inferred_type\n        are identical. If 'equiv', then RangeIndex can be substituted for\n        Int64Index as well.\n    obj : str, default 'IntervalArray'\n        Specify object name being compared, internally used to show appropriate\n        assertion message\n    \"\"\"\n    _check_isinstance(left, right, IntervalArray)\n\n    assert_index_equal(left.left, right.left, exact=exact, obj=f\"{obj}.left\")\n    assert_index_equal(left.right, right.right, exact=exact, obj=f\"{obj}.left\")\n    assert_attr_equal(\"closed\", left, right, obj=obj)",
                "def assert_period_array_equal(left, right, obj=\"PeriodArray\"):\n    _check_isinstance(left, right, PeriodArray)\n\n    assert_numpy_array_equal(left._data, right._data, obj=f\"{obj}._data\")\n    assert_attr_equal(\"freq\", left, right, obj=obj)",
                "def assert_datetime_array_equal(left, right, obj=\"DatetimeArray\"):\n    __tracebackhide__ = True\n    _check_isinstance(left, right, DatetimeArray)\n\n    assert_numpy_array_equal(left._data, right._data, obj=f\"{obj}._data\")\n    assert_attr_equal(\"freq\", left, right, obj=obj)\n    assert_attr_equal(\"tz\", left, right, obj=obj)",
                "def assert_timedelta_array_equal(left, right, obj=\"TimedeltaArray\"):\n    __tracebackhide__ = True\n    _check_isinstance(left, right, TimedeltaArray)\n    assert_numpy_array_equal(left._data, right._data, obj=f\"{obj}._data\")\n    assert_attr_equal(\"freq\", left, right, obj=obj)",
                "def raise_assert_detail(obj, message, left, right, diff=None):\n    __tracebackhide__ = True\n\n    if isinstance(left, np.ndarray):\n        left = pprint_thing(left)\n    elif is_categorical_dtype(left):\n        left = repr(left)\n\n    if isinstance(right, np.ndarray):\n        right = pprint_thing(right)\n    elif is_categorical_dtype(right):\n        right = repr(right)\n\n    msg = f\"\"\"{obj} are different\n\n{message}\n[left]:  {left}\n[right]: {right}\"\"\"\n\n    if diff is not None:\n        msg += f\"\\n[diff]: {diff}\"\n\n    raise AssertionError(msg)",
                "def assert_numpy_array_equal(\n    left,\n    right,\n    strict_nan=False,\n    check_dtype=True,\n    err_msg=None,\n    check_same=None,\n    obj=\"numpy array\",\n):\n    \"\"\"\n    Check that 'np.ndarray' is equivalent.\n\n    Parameters\n    ----------\n    left, right : numpy.ndarray or iterable\n        The two arrays to be compared.\n    strict_nan : bool, default False\n        If True, consider NaN and None to be different.\n    check_dtype : bool, default True\n        Check dtype if both a and b are np.ndarray.\n    err_msg : str, default None\n        If provided, used as assertion message.\n    check_same : None|'copy'|'same', default None\n        Ensure left and right refer/do not refer to the same memory area.\n    obj : str, default 'numpy array'\n        Specify object name being compared, internally used to show appropriate\n        assertion message.\n    \"\"\"\n    __tracebackhide__ = True\n\n    # instance validation\n    # Show a detailed error message when classes are different\n    assert_class_equal(left, right, obj=obj)\n    # both classes must be an np.ndarray\n    _check_isinstance(left, right, np.ndarray)\n\n    def _get_base(obj):\n        return obj.base if getattr(obj, \"base\", None) is not None else obj\n\n    left_base = _get_base(left)\n    right_base = _get_base(right)\n\n    if check_same == \"same\":\n        if left_base is not right_base:\n            raise AssertionError(f\"{repr(left_base)} is not {repr(right_base)}\")\n    elif check_same == \"copy\":\n        if left_base is right_base:\n            raise AssertionError(f\"{repr(left_base)} is {repr(right_base)}\")\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n                raise_assert_detail(\n                    obj, f\"{obj} shapes are different\", left.shape, right.shape,\n                )\n\n            diff = 0\n            for l, r in zip(left, right):\n                # count up differences\n                if not array_equivalent(l, r, strict_nan=strict_nan):\n                    diff += 1\n\n            diff = diff * 100.0 / left.size\n            msg = f\"{obj} values are different ({np.round(diff, 5)} %)\"\n            raise_assert_detail(obj, msg, left, right)\n\n        raise AssertionError(err_msg)\n\n    # compare shape and values\n    if not array_equivalent(left, right, strict_nan=strict_nan):\n        _raise(left, right, err_msg)\n\n    if check_dtype:\n        if isinstance(left, np.ndarray) and isinstance(right, np.ndarray):\n            assert_attr_equal(\"dtype\", left, right, obj=obj)",
                "def assert_extension_array_equal(\n    left, right, check_dtype=True, check_less_precise=False, check_exact=False\n):\n    \"\"\"\n    Check that left and right ExtensionArrays are equal.\n\n    Parameters\n    ----------\n    left, right : ExtensionArray\n        The two arrays to compare.\n    check_dtype : bool, default True\n        Whether to check if the ExtensionArray dtypes are identical.\n    check_less_precise : bool or int, default False\n        Specify comparison precision. Only used when check_exact is False.\n        5 digits (False) or 3 digits (True) after decimal points are compared.\n        If int, then specify the digits to compare.\n    check_exact : bool, default False\n        Whether to compare number exactly.\n\n    Notes\n    -----\n    Missing values are checked separately from valid values.\n    A mask of missing values is computed for each and checked to match.\n    The remaining all-valid values are cast to object dtype and checked.\n    \"\"\"\n    assert isinstance(left, ExtensionArray), \"left is not an ExtensionArray\"\n    assert isinstance(right, ExtensionArray), \"right is not an ExtensionArray\"\n    if check_dtype:\n        assert_attr_equal(\"dtype\", left, right, obj=\"ExtensionArray\")\n\n    if hasattr(left, \"asi8\") and type(right) == type(left):\n        # Avoid slow object-dtype comparisons\n        # np.asarray for case where we have a np.MaskedArray\n        assert_numpy_array_equal(np.asarray(left.asi8), np.asarray(right.asi8))\n        return\n\n    left_na = np.asarray(left.isna())\n    right_na = np.asarray(right.isna())\n    assert_numpy_array_equal(left_na, right_na, obj=\"ExtensionArray NA mask\")\n\n    left_valid = np.asarray(left[~left_na].astype(object))\n    right_valid = np.asarray(right[~right_na].astype(object))\n    if check_exact:\n        assert_numpy_array_equal(left_valid, right_valid, obj=\"ExtensionArray\")\n    else:\n        _testing.assert_almost_equal(\n            left_valid,\n            right_valid,\n            check_dtype=check_dtype,\n            check_less_precise=check_less_precise,\n            obj=\"ExtensionArray\",\n        )",
                "def assert_series_equal(\n    left,\n    right,\n    check_dtype=True,\n    check_index_type=\"equiv\",\n    check_series_type=True,\n    check_less_precise=False,\n    check_names=True,\n    check_exact=False,\n    check_datetimelike_compat=False,\n    check_categorical=True,\n    check_category_order=True,\n    obj=\"Series\",\n):\n    \"\"\"\n    Check that left and right Series are equal.\n\n    Parameters\n    ----------\n    left : Series\n    right : Series\n    check_dtype : bool, default True\n        Whether to check the Series dtype is identical.\n    check_index_type : bool or {'equiv'}, default 'equiv'\n        Whether to check the Index class, dtype and inferred_type\n        are identical.\n    check_series_type : bool, default True\n         Whether to check the Series class is identical.\n    check_less_precise : bool or int, default False\n        Specify comparison precision. Only used when check_exact is False.\n        5 digits (False) or 3 digits (True) after decimal points are compared.\n        If int, then specify the digits to compare.\n\n        When comparing two numbers, if the first number has magnitude less\n        than 1e-5, we compare the two numbers directly and check whether\n        they are equivalent within the specified precision. Otherwise, we\n        compare the **ratio** of the second number to the first number and\n        check whether it is equivalent to 1 within the specified precision.\n    check_names : bool, default True\n        Whether to check the Series and Index names attribute.\n    check_exact : bool, default False\n        Whether to compare number exactly.\n    check_datetimelike_compat : bool, default False\n        Compare datetime-like which is comparable ignoring dtype.\n    check_categorical : bool, default True\n        Whether to compare internal Categorical exactly.\n    check_category_order : bool, default True\n        Whether to compare category order of internal Categoricals.\n\n        .. versionadded:: 1.0.2\n    obj : str, default 'Series'\n        Specify object name being compared, internally used to show appropriate\n        assertion message.\n    \"\"\"\n    __tracebackhide__ = True\n\n    # instance validation\n    _check_isinstance(left, right, Series)\n\n    if check_series_type:\n        assert_class_equal(left, right, obj=obj)\n\n    # length comparison\n    if len(left) != len(right):\n        msg1 = f\"{len(left)}, {left.index}\"\n        msg2 = f\"{len(right)}, {right.index}\"\n        raise_assert_detail(obj, \"Series length are different\", msg1, msg2)\n\n    # index comparison\n    assert_index_equal(\n        left.index,\n        right.index,\n        exact=check_index_type,\n        check_names=check_names,\n        check_less_precise=check_less_precise,\n        check_exact=check_exact,\n        check_categorical=check_categorical,\n        obj=f\"{obj}.index\",\n    )\n\n    if check_dtype:\n        # We want to skip exact dtype checking when `check_categorical`\n        # is False. We'll still raise if only one is a `Categorical`,\n        # regardless of `check_categorical`\n        if (\n            is_categorical_dtype(left.dtype)\n            and is_categorical_dtype(right.dtype)\n            and not check_categorical\n        ):\n            pass\n        else:\n            assert_attr_equal(\"dtype\", left, right, obj=f\"Attributes of {obj}\")\n\n    if check_exact:\n        if not is_numeric_dtype(left.dtype):\n            raise AssertionError(\"check_exact may only be used with numeric Series\")\n\n        assert_numpy_array_equal(\n            left._values, right._values, check_dtype=check_dtype, obj=str(obj)\n        )\n    elif check_datetimelike_compat and (\n        needs_i8_conversion(left.dtype) or needs_i8_conversion(right.dtype)\n    ):\n        # we want to check only if we have compat dtypes\n        # e.g. integer and M|m are NOT compat, but we can simply check\n        # the values in that case\n\n        # datetimelike may have different objects (e.g. datetime.datetime\n        # vs Timestamp) but will compare equal\n        if not Index(left._values).equals(Index(right._values)):\n            msg = (\n                f\"[datetimelike_compat=True] {left._values} \"\n                f\"is not equal to {right._values}.\"\n            )\n            raise AssertionError(msg)\n    elif is_interval_dtype(left.dtype) or is_interval_dtype(right.dtype):\n        assert_interval_array_equal(left.array, right.array)\n    elif is_categorical_dtype(left.dtype) or is_categorical_dtype(right.dtype):\n        _testing.assert_almost_equal(\n            left._values,\n            right._values,\n            check_less_precise=check_less_precise,\n            check_dtype=check_dtype,\n            obj=str(obj),\n        )\n    elif is_extension_array_dtype(left.dtype) or is_extension_array_dtype(right.dtype):\n        assert_extension_array_equal(left._values, right._values)\n    elif needs_i8_conversion(left.dtype) or needs_i8_conversion(right.dtype):\n        # DatetimeArray or TimedeltaArray\n        assert_extension_array_equal(left._values, right._values)\n    else:\n        _testing.assert_almost_equal(\n            left._values,\n            right._values,\n            check_less_precise=check_less_precise,\n            check_dtype=check_dtype,\n            obj=str(obj),\n        )\n\n    # metadata comparison\n    if check_names:\n        assert_attr_equal(\"name\", left, right, obj=obj)\n\n    if check_categorical:\n        if is_categorical_dtype(left) or is_categorical_dtype(right):\n            assert_categorical_equal(\n                left._values,\n                right._values,\n                obj=f\"{obj} category\",\n                check_category_order=check_category_order,\n            )",
                "def assert_frame_equal(\n    left,\n    right,\n    check_dtype=True,\n    check_index_type=\"equiv\",\n    check_column_type=\"equiv\",\n    check_frame_type=True,\n    check_less_precise=False,\n    check_names=True,\n    by_blocks=False,\n    check_exact=False,\n    check_datetimelike_compat=False,\n    check_categorical=True,\n    check_like=False,\n    obj=\"DataFrame\",\n):\n    \"\"\"\n    Check that left and right DataFrame are equal.\n\n    This function is intended to compare two DataFrames and output any\n    differences. Is is mostly intended for use in unit tests.\n    Additional parameters allow varying the strictness of the\n    equality checks performed.\n\n    Parameters\n    ----------\n    left : DataFrame\n        First DataFrame to compare.\n    right : DataFrame\n        Second DataFrame to compare.\n    check_dtype : bool, default True\n        Whether to check the DataFrame dtype is identical.\n    check_index_type : bool or {'equiv'}, default 'equiv'\n        Whether to check the Index class, dtype and inferred_type\n        are identical.\n    check_column_type : bool or {'equiv'}, default 'equiv'\n        Whether to check the columns class, dtype and inferred_type\n        are identical. Is passed as the ``exact`` argument of\n        :func:`assert_index_equal`.\n    check_frame_type : bool, default True\n        Whether to check the DataFrame class is identical.\n    check_less_precise : bool or int, default False\n        Specify comparison precision. Only used when check_exact is False.\n        5 digits (False) or 3 digits (True) after decimal points are compared.\n        If int, then specify the digits to compare.\n\n        When comparing two numbers, if the first number has magnitude less\n        than 1e-5, we compare the two numbers directly and check whether\n        they are equivalent within the specified precision. Otherwise, we\n        compare the **ratio** of the second number to the first number and\n        check whether it is equivalent to 1 within the specified precision.\n    check_names : bool, default True\n        Whether to check that the `names` attribute for both the `index`\n        and `column` attributes of the DataFrame is identical.\n    by_blocks : bool, default False\n        Specify how to compare internal data. If False, compare by columns.\n        If True, compare by blocks.\n    check_exact : bool, default False\n        Whether to compare number exactly.\n    check_datetimelike_compat : bool, default False\n        Compare datetime-like which is comparable ignoring dtype.\n    check_categorical : bool, default True\n        Whether to compare internal Categorical exactly.\n    check_like : bool, default False\n        If True, ignore the order of index & columns.\n        Note: index labels must match their respective rows\n        (same as in columns) - same labels must be with the same data.\n    obj : str, default 'DataFrame'\n        Specify object name being compared, internally used to show appropriate\n        assertion message.\n\n    See Also\n    --------\n    assert_series_equal : Equivalent method for asserting Series equality.\n    DataFrame.equals : Check DataFrame equality.\n\n    Examples\n    --------\n    This example shows comparing two DataFrames that are equal\n    but with columns of differing dtypes.\n\n    >>> from pandas._testing import assert_frame_equal\n    >>> df1 = pd.DataFrame({'a': [1, 2], 'b': [3, 4]})\n    >>> df2 = pd.DataFrame({'a': [1, 2], 'b': [3.0, 4.0]})\n\n    df1 equals itself.\n\n    >>> assert_frame_equal(df1, df1)\n\n    df1 differs from df2 as column 'b' is of a different type.\n\n    >>> assert_frame_equal(df1, df2)\n    Traceback (most recent call last):\n    ...\n    AssertionError: Attributes of DataFrame.iloc[:, 1] (column name=\"b\") are different\n\n    Attribute \"dtype\" are different\n    [left]:  int64\n    [right]: float64\n\n    Ignore differing dtypes in columns with check_dtype.\n\n    >>> assert_frame_equal(df1, df2, check_dtype=False)\n    \"\"\"\n    __tracebackhide__ = True\n\n    # instance validation\n    _check_isinstance(left, right, DataFrame)\n\n    if check_frame_type:\n        assert isinstance(left, type(right))\n        # assert_class_equal(left, right, obj=obj)\n\n    # shape comparison\n    if left.shape != right.shape:\n        raise_assert_detail(\n            obj, f\"{obj} shape mismatch\", f\"{repr(left.shape)}\", f\"{repr(right.shape)}\",\n        )\n\n    if check_like:\n        left, right = left.reindex_like(right), right\n\n    # index comparison\n    assert_index_equal(\n        left.index,\n        right.index,\n        exact=check_index_type,\n        check_names=check_names,\n        check_less_precise=check_less_precise,\n        check_exact=check_exact,\n        check_categorical=check_categorical,\n        obj=f\"{obj}.index\",\n    )\n\n    # column comparison\n    assert_index_equal(\n        left.columns,\n        right.columns,\n        exact=check_column_type,\n        check_names=check_names,\n        check_less_precise=check_less_precise,\n        check_exact=check_exact,\n        check_categorical=check_categorical,\n        obj=f\"{obj}.columns\",\n    )\n\n    # compare by blocks\n    if by_blocks:\n        rblocks = right._to_dict_of_blocks()\n        lblocks = left._to_dict_of_blocks()\n        for dtype in list(set(list(lblocks.keys()) + list(rblocks.keys()))):\n            assert dtype in lblocks\n            assert dtype in rblocks\n            assert_frame_equal(\n                lblocks[dtype], rblocks[dtype], check_dtype=check_dtype, obj=obj\n            )\n\n    # compare by columns\n    else:\n        for i, col in enumerate(left.columns):\n            assert col in right\n            lcol = left.iloc[:, i]\n            rcol = right.iloc[:, i]\n            assert_series_equal(\n                lcol,\n                rcol,\n                check_dtype=check_dtype,\n                check_index_type=check_index_type,\n                check_less_precise=check_less_precise,\n                check_exact=check_exact,\n                check_names=check_names,\n                check_datetimelike_compat=check_datetimelike_compat,\n                check_categorical=check_categorical,\n                obj=f'{obj}.iloc[:, {i}] (column name=\"{col}\")',\n            )",
                "def assert_equal(left, right, **kwargs):\n    \"\"\"\n    Wrapper for tm.assert_*_equal to dispatch to the appropriate test function.\n\n    Parameters\n    ----------\n    left, right : Index, Series, DataFrame, ExtensionArray, or np.ndarray\n        The two items to be compared.\n    **kwargs\n        All keyword arguments are passed through to the underlying assert method.\n    \"\"\"\n    __tracebackhide__ = True\n\n    if isinstance(left, pd.Index):\n        assert_index_equal(left, right, **kwargs)\n    elif isinstance(left, pd.Series):\n        assert_series_equal(left, right, **kwargs)\n    elif isinstance(left, pd.DataFrame):\n        assert_frame_equal(left, right, **kwargs)\n    elif isinstance(left, IntervalArray):\n        assert_interval_array_equal(left, right, **kwargs)\n    elif isinstance(left, PeriodArray):\n        assert_period_array_equal(left, right, **kwargs)\n    elif isinstance(left, DatetimeArray):\n        assert_datetime_array_equal(left, right, **kwargs)\n    elif isinstance(left, TimedeltaArray):\n        assert_timedelta_array_equal(left, right, **kwargs)\n    elif isinstance(left, ExtensionArray):\n        assert_extension_array_equal(left, right, **kwargs)\n    elif isinstance(left, np.ndarray):\n        assert_numpy_array_equal(left, right, **kwargs)\n    elif isinstance(left, str):\n        assert kwargs == {}\n        assert left == right\n    else:\n        raise NotImplementedError(type(left))",
                "def box_expected(expected, box_cls, transpose=True):\n    \"\"\"\n    Helper function to wrap the expected output of a test in a given box_class.\n\n    Parameters\n    ----------\n    expected : np.ndarray, Index, Series\n    box_cls : {Index, Series, DataFrame}\n\n    Returns\n    -------\n    subclass of box_cls\n    \"\"\"\n    if box_cls is pd.Index:\n        expected = pd.Index(expected)\n    elif box_cls is pd.Series:\n        expected = pd.Series(expected)\n    elif box_cls is pd.DataFrame:\n        expected = pd.Series(expected).to_frame()\n        if transpose:\n            # for vector operations, we we need a DataFrame to be a single-row,\n            #  not a single-column, in order to operate against non-DataFrame\n            #  vectors of the same length.\n            expected = expected.T\n    elif box_cls is PeriodArray:\n        # the PeriodArray constructor is not as flexible as period_array\n        expected = period_array(expected)\n    elif box_cls is DatetimeArray:\n        expected = DatetimeArray(expected)\n    elif box_cls is TimedeltaArray:\n        expected = TimedeltaArray(expected)\n    elif box_cls is np.ndarray:\n        expected = np.array(expected)\n    elif box_cls is to_array:\n        expected = to_array(expected)\n    else:\n        raise NotImplementedError(box_cls)\n    return expected",
                "def to_array(obj):\n    # temporary implementation until we get pd.array in place\n    if is_period_dtype(obj):\n        return period_array(obj)\n    elif is_datetime64_dtype(obj) or is_datetime64tz_dtype(obj):\n        return DatetimeArray._from_sequence(obj)\n    elif is_timedelta64_dtype(obj):\n        return TimedeltaArray._from_sequence(obj)\n    else:\n        return np.array(obj)",
                "def assert_sp_array_equal(left, right):\n    \"\"\"\n    Check that the left and right SparseArray are equal.\n\n    Parameters\n    ----------\n    left : SparseArray\n    right : SparseArray\n    \"\"\"\n    _check_isinstance(left, right, pd.arrays.SparseArray)\n\n    assert_numpy_array_equal(left.sp_values, right.sp_values)\n\n    # SparseIndex comparison\n    assert isinstance(left.sp_index, pd._libs.sparse.SparseIndex)\n    assert isinstance(right.sp_index, pd._libs.sparse.SparseIndex)\n\n    left_index = left.sp_index\n    right_index = right.sp_index\n\n    if not left_index.equals(right_index):\n        raise_assert_detail(\n            \"SparseArray.index\", \"index are not equal\", left_index, right_index\n        )\n    else:\n        # Just ensure a\n        pass\n\n    assert_attr_equal(\"fill_value\", left, right)\n    assert_attr_equal(\"dtype\", left, right)\n    assert_numpy_array_equal(left.to_dense(), right.to_dense())",
                "def assert_contains_all(iterable, dic):\n    for k in iterable:\n        assert k in dic, f\"Did not contain item: {repr(k)}\"",
                "def assert_copy(iter1, iter2, **eql_kwargs):\n    \"\"\"\n    iter1, iter2: iterables that produce elements\n    comparable with assert_almost_equal\n\n    Checks that the elements are equal, but not\n    the same object. (Does not check that items\n    in sequences are also not the same object)\n    \"\"\"\n    for elem1, elem2 in zip(iter1, iter2):\n        assert_almost_equal(elem1, elem2, **eql_kwargs)\n        msg = (\n            f\"Expected object {repr(type(elem1))} and object {repr(type(elem2))} to be \"\n            \"different objects, but they were the same object.\"\n        )\n        assert elem1 is not elem2, msg",
                "def getCols(k):\n    return string.ascii_uppercase[:k]",
                "def makeStringIndex(k=10, name=None):\n    return Index(rands_array(nchars=10, size=k), name=name)",
                "def makeUnicodeIndex(k=10, name=None):\n    return Index(randu_array(nchars=10, size=k), name=name)",
                "def makeCategoricalIndex(k=10, n=3, name=None, **kwargs):\n    \"\"\" make a length k index or n categories \"\"\"\n    x = rands_array(nchars=4, size=n)\n    return CategoricalIndex(\n        Categorical.from_codes(np.arange(k) % n, categories=x), name=name, **kwargs\n    )",
                "def makeIntervalIndex(k=10, name=None, **kwargs):\n    \"\"\" make a length k IntervalIndex \"\"\"\n    x = np.linspace(0, 100, num=(k + 1))\n    return IntervalIndex.from_breaks(x, name=name, **kwargs)",
                "def makeBoolIndex(k=10, name=None):\n    if k == 1:\n        return Index([True], name=name)\n    elif k == 2:\n        return Index([False, True], name=name)\n    return Index([False, True] + [False] * (k - 2), name=name)",
                "def makeIntIndex(k=10, name=None):\n    return Index(list(range(k)), name=name)",
                "def makeUIntIndex(k=10, name=None):\n    return Index([2 ** 63 + i for i in range(k)], name=name)",
                "def makeRangeIndex(k=10, name=None, **kwargs):\n    return RangeIndex(0, k, 1, name=name, **kwargs)",
                "def makeFloatIndex(k=10, name=None):\n    values = sorted(np.random.random_sample(k)) - np.random.random_sample(1)\n    return Index(values * (10 ** np.random.randint(0, 9)), name=name)",
                "def makeDateIndex(k=10, freq=\"B\", name=None, **kwargs):\n    dt = datetime(2000, 1, 1)\n    dr = bdate_range(dt, periods=k, freq=freq, name=name)\n    return DatetimeIndex(dr, name=name, **kwargs)",
                "def makeTimedeltaIndex(k=10, freq=\"D\", name=None, **kwargs):\n    return pd.timedelta_range(start=\"1 day\", periods=k, freq=freq, name=name, **kwargs)",
                "def makePeriodIndex(k=10, name=None, **kwargs):\n    dt = datetime(2000, 1, 1)\n    dr = pd.period_range(start=dt, periods=k, freq=\"B\", name=name, **kwargs)\n    return dr",
                "def makeMultiIndex(k=10, names=None, **kwargs):\n    return MultiIndex.from_product(((\"foo\", \"bar\"), (1, 2)), names=names, **kwargs)",
                "def _make_timeseries(start=\"2000-01-01\", end=\"2000-12-31\", freq=\"1D\", seed=None):\n    \"\"\"\n    Make a DataFrame with a DatetimeIndex\n\n    Parameters\n    ----------\n    start : str or Timestamp, default \"2000-01-01\"\n        The start of the index. Passed to date_range with `freq`.\n    end : str or Timestamp, default \"2000-12-31\"\n        The end of the index. Passed to date_range with `freq`.\n    freq : str or Freq\n        The frequency to use for the DatetimeIndex\n    seed : int, optional\n        The random state seed.\n\n        * name : object dtype with string names\n        * id : int dtype with\n        * x, y : float dtype\n\n    Examples\n    --------\n    >>> _make_timeseries()\n                  id    name         x         y\n    timestamp\n    2000-01-01   982   Frank  0.031261  0.986727\n    2000-01-02  1025   Edith -0.086358 -0.032920\n    2000-01-03   982   Edith  0.473177  0.298654\n    2000-01-04  1009   Sarah  0.534344 -0.750377\n    2000-01-05   963   Zelda -0.271573  0.054424\n    ...          ...     ...       ...       ...\n    2000-12-27   980  Ingrid -0.132333 -0.422195\n    2000-12-28   972   Frank -0.376007 -0.298687\n    2000-12-29  1009  Ursula -0.865047 -0.503133\n    2000-12-30  1000  Hannah -0.063757 -0.507336\n    2000-12-31   972     Tim -0.869120  0.531685\n    \"\"\"\n    index = pd.date_range(start=start, end=end, freq=freq, name=\"timestamp\")\n    n = len(index)\n    state = np.random.RandomState(seed)\n    columns = {\n        \"name\": state.choice(_names, size=n),\n        \"id\": state.poisson(1000, size=n),\n        \"x\": state.rand(n) * 2 - 1,\n        \"y\": state.rand(n) * 2 - 1,\n    }\n    df = pd.DataFrame(columns, index=index, columns=sorted(columns))\n    if df.index[-1] == end:\n        df = df.iloc[:-1]\n    return df",
                "def all_index_generator(k=10):\n    \"\"\"\n    Generator which can be iterated over to get instances of all the various\n    index classes.\n\n    Parameters\n    ----------\n    k: length of each of the index instances\n    \"\"\"\n    all_make_index_funcs = [\n        makeIntIndex,\n        makeFloatIndex,\n        makeStringIndex,\n        makeUnicodeIndex,\n        makeDateIndex,\n        makePeriodIndex,\n        makeTimedeltaIndex,\n        makeBoolIndex,\n        makeRangeIndex,\n        makeIntervalIndex,\n        makeCategoricalIndex,\n    ]\n    for make_index_func in all_make_index_funcs:\n        yield make_index_func(k=k)",
                "def index_subclass_makers_generator():\n    make_index_funcs = [\n        makeDateIndex,\n        makePeriodIndex,\n        makeTimedeltaIndex,\n        makeRangeIndex,\n        makeIntervalIndex,\n        makeCategoricalIndex,\n        makeMultiIndex,\n    ]\n    for make_index_func in make_index_funcs:\n        yield make_index_func",
                "def all_timeseries_index_generator(k=10):\n    \"\"\"\n    Generator which can be iterated over to get instances of all the classes\n    which represent time-series.\n\n    Parameters\n    ----------\n    k: length of each of the index instances\n    \"\"\"\n    make_index_funcs = [makeDateIndex, makePeriodIndex, makeTimedeltaIndex]\n    for make_index_func in make_index_funcs:\n        yield make_index_func(k=k)",
                "def makeFloatSeries(name=None):\n    index = makeStringIndex(_N)\n    return Series(randn(_N), index=index, name=name)",
                "def makeStringSeries(name=None):\n    index = makeStringIndex(_N)\n    return Series(randn(_N), index=index, name=name)",
                "def makeObjectSeries(name=None):\n    data = makeStringIndex(_N)\n    data = Index(data, dtype=object)\n    index = makeStringIndex(_N)\n    return Series(data, index=index, name=name)",
                "def getSeriesData():\n    index = makeStringIndex(_N)\n    return {c: Series(randn(_N), index=index) for c in getCols(_K)}",
                "def makeTimeSeries(nper=None, freq=\"B\", name=None):\n    if nper is None:\n        nper = _N\n    return Series(randn(nper), index=makeDateIndex(nper, freq=freq), name=name)",
                "def makePeriodSeries(nper=None, name=None):\n    if nper is None:\n        nper = _N\n    return Series(randn(nper), index=makePeriodIndex(nper), name=name)",
                "def getTimeSeriesData(nper=None, freq=\"B\"):\n    return {c: makeTimeSeries(nper, freq) for c in getCols(_K)}",
                "def getPeriodData(nper=None):\n    return {c: makePeriodSeries(nper) for c in getCols(_K)}",
                "def makeTimeDataFrame(nper=None, freq=\"B\"):\n    data = getTimeSeriesData(nper, freq)\n    return DataFrame(data)",
                "def makeDataFrame():\n    data = getSeriesData()\n    return DataFrame(data)",
                "def getMixedTypeDict():\n    index = Index([\"a\", \"b\", \"c\", \"d\", \"e\"])\n\n    data = {\n        \"A\": [0.0, 1.0, 2.0, 3.0, 4.0],\n        \"B\": [0.0, 1.0, 0.0, 1.0, 0.0],\n        \"C\": [\"foo1\", \"foo2\", \"foo3\", \"foo4\", \"foo5\"],\n        \"D\": bdate_range(\"1/1/2009\", periods=5),\n    }\n\n    return index, data",
                "def makeMixedDataFrame():\n    return DataFrame(getMixedTypeDict()[1])",
                "def makePeriodFrame(nper=None):\n    data = getPeriodData(nper)\n    return DataFrame(data)",
                "def makeCustomIndex(\n    nentries, nlevels, prefix=\"#\", names=False, ndupe_l=None, idx_type=None\n):\n    \"\"\"\n    Create an index/multindex with given dimensions, levels, names, etc'\n\n    nentries - number of entries in index\n    nlevels - number of levels (> 1 produces multindex)\n    prefix - a string prefix for labels\n    names - (Optional), bool or list of strings. if True will use default\n       names, if false will use no names, if a list is given, the name of\n       each level in the index will be taken from the list.\n    ndupe_l - (Optional), list of ints, the number of rows for which the\n       label will repeated at the corresponding level, you can specify just\n       the first few, the rest will use the default ndupe_l of 1.\n       len(ndupe_l) <= nlevels.\n    idx_type - \"i\"/\"f\"/\"s\"/\"u\"/\"dt\"/\"p\"/\"td\".\n       If idx_type is not None, `idx_nlevels` must be 1.\n       \"i\"/\"f\" creates an integer/float index,\n       \"s\"/\"u\" creates a string/unicode index\n       \"dt\" create a datetime index.\n       \"td\" create a datetime index.\n\n        if unspecified, string labels will be generated.\n    \"\"\"\n    if ndupe_l is None:\n        ndupe_l = [1] * nlevels\n    assert is_sequence(ndupe_l) and len(ndupe_l) <= nlevels\n    assert names is None or names is False or names is True or len(names) is nlevels\n    assert idx_type is None or (\n        idx_type in (\"i\", \"f\", \"s\", \"u\", \"dt\", \"p\", \"td\") and nlevels == 1\n    )\n\n    if names is True:\n        # build default names\n        names = [prefix + str(i) for i in range(nlevels)]\n    if names is False:\n        # pass None to index constructor for no name\n        names = None\n\n    # make singleton case uniform\n    if isinstance(names, str) and nlevels == 1:\n        names = [names]\n\n    # specific 1D index type requested?\n    idx_func = dict(\n        i=makeIntIndex,\n        f=makeFloatIndex,\n        s=makeStringIndex,\n        u=makeUnicodeIndex,\n        dt=makeDateIndex,\n        td=makeTimedeltaIndex,\n        p=makePeriodIndex,\n    ).get(idx_type)\n    if idx_func:\n        idx = idx_func(nentries)\n        # but we need to fill in the name\n        if names:\n            idx.name = names[0]\n        return idx\n    elif idx_type is not None:\n        raise ValueError(\n            f\"{repr(idx_type)} is not a legal value for `idx_type`, \"\n            \"use  'i'/'f'/'s'/'u'/'dt'/'p'/'td'.\"\n        )\n\n    if len(ndupe_l) < nlevels:\n        ndupe_l.extend([1] * (nlevels - len(ndupe_l)))\n    assert len(ndupe_l) == nlevels\n\n    assert all(x > 0 for x in ndupe_l)\n\n    tuples = []\n    for i in range(nlevels):\n\n        def keyfunc(x):\n            import re\n\n            numeric_tuple = re.sub(r\"[^\\d_]_?\", \"\", x).split(\"_\")\n            return [int(num) for num in numeric_tuple]\n\n        # build a list of lists to create the index from\n        div_factor = nentries // ndupe_l[i] + 1\n        cnt = Counter()\n        for j in range(div_factor):\n            label = f\"{prefix}_l{i}_g{j}\"\n            cnt[label] = ndupe_l[i]\n        # cute Counter trick\n        result = sorted(cnt.elements(), key=keyfunc)[:nentries]\n        tuples.append(result)\n\n    tuples = list(zip(*tuples))\n\n    # convert tuples to index\n    if nentries == 1:\n        # we have a single level of tuples, i.e. a regular Index\n        index = Index(tuples[0], name=names[0])\n    elif nlevels == 1:\n        name = None if names is None else names[0]\n        index = Index((x[0] for x in tuples), name=name)\n    else:\n        index = MultiIndex.from_tuples(tuples, names=names)\n    return index",
                "def makeCustomDataframe(\n    nrows,\n    ncols,\n    c_idx_names=True,\n    r_idx_names=True,\n    c_idx_nlevels=1,\n    r_idx_nlevels=1,\n    data_gen_f=None,\n    c_ndupe_l=None,\n    r_ndupe_l=None,\n    dtype=None,\n    c_idx_type=None,\n    r_idx_type=None,\n):\n    \"\"\"\n    Create a DataFrame using supplied parameters.\n\n    Parameters\n    ----------\n    nrows,  ncols - number of data rows/cols\n    c_idx_names, idx_names  - False/True/list of strings,  yields No names ,\n            default names or uses the provided names for the levels of the\n            corresponding index. You can provide a single string when\n            c_idx_nlevels ==1.\n    c_idx_nlevels - number of levels in columns index. > 1 will yield MultiIndex\n    r_idx_nlevels - number of levels in rows index. > 1 will yield MultiIndex\n    data_gen_f - a function f(row,col) which return the data value\n            at that position, the default generator used yields values of the form\n            \"RxCy\" based on position.\n    c_ndupe_l, r_ndupe_l - list of integers, determines the number\n            of duplicates for each label at a given level of the corresponding\n            index. The default `None` value produces a multiplicity of 1 across\n            all levels, i.e. a unique index. Will accept a partial list of length\n            N < idx_nlevels, for just the first N levels. If ndupe doesn't divide\n            nrows/ncol, the last label might have lower multiplicity.\n    dtype - passed to the DataFrame constructor as is, in case you wish to\n            have more control in conjunction with a custom `data_gen_f`\n    r_idx_type, c_idx_type -  \"i\"/\"f\"/\"s\"/\"u\"/\"dt\"/\"td\".\n        If idx_type is not None, `idx_nlevels` must be 1.\n        \"i\"/\"f\" creates an integer/float index,\n        \"s\"/\"u\" creates a string/unicode index\n        \"dt\" create a datetime index.\n        \"td\" create a timedelta index.\n\n            if unspecified, string labels will be generated.\n\n    Examples\n    --------\n    # 5 row, 3 columns, default names on both, single index on both axis\n    >> makeCustomDataframe(5,3)\n\n    # make the data a random int between 1 and 100\n    >> mkdf(5,3,data_gen_f=lambda r,c:randint(1,100))\n\n    # 2-level multiindex on rows with each label duplicated\n    # twice on first level, default names on both axis, single\n    # index on both axis\n    >> a=makeCustomDataframe(5,3,r_idx_nlevels=2,r_ndupe_l=[2])\n\n    # DatetimeIndex on row, index with unicode labels on columns\n    # no names on either axis\n    >> a=makeCustomDataframe(5,3,c_idx_names=False,r_idx_names=False,\n                             r_idx_type=\"dt\",c_idx_type=\"u\")\n\n    # 4-level multindex on rows with names provided, 2-level multindex\n    # on columns with default labels and default names.\n    >> a=makeCustomDataframe(5,3,r_idx_nlevels=4,\n                             r_idx_names=[\"FEE\",\"FI\",\"FO\",\"FAM\"],\n                             c_idx_nlevels=2)\n\n    >> a=mkdf(5,3,r_idx_nlevels=2,c_idx_nlevels=4)\n    \"\"\"\n    assert c_idx_nlevels > 0\n    assert r_idx_nlevels > 0\n    assert r_idx_type is None or (\n        r_idx_type in (\"i\", \"f\", \"s\", \"u\", \"dt\", \"p\", \"td\") and r_idx_nlevels == 1\n    )\n    assert c_idx_type is None or (\n        c_idx_type in (\"i\", \"f\", \"s\", \"u\", \"dt\", \"p\", \"td\") and c_idx_nlevels == 1\n    )\n\n    columns = makeCustomIndex(\n        ncols,\n        nlevels=c_idx_nlevels,\n        prefix=\"C\",\n        names=c_idx_names,\n        ndupe_l=c_ndupe_l,\n        idx_type=c_idx_type,\n    )\n    index = makeCustomIndex(\n        nrows,\n        nlevels=r_idx_nlevels,\n        prefix=\"R\",\n        names=r_idx_names,\n        ndupe_l=r_ndupe_l,\n        idx_type=r_idx_type,\n    )\n\n    # by default, generate data based on location\n    if data_gen_f is None:\n        data_gen_f = lambda r, c: f\"R{r}C{c}\"\n\n    data = [[data_gen_f(r, c) for c in range(ncols)] for r in range(nrows)]\n\n    return DataFrame(data, index, columns, dtype=dtype)",
                "def _create_missing_idx(nrows, ncols, density, random_state=None):\n    if random_state is None:\n        random_state = np.random\n    else:\n        random_state = np.random.RandomState(random_state)\n\n    # below is cribbed from scipy.sparse\n    size = int(np.round((1 - density) * nrows * ncols))\n    # generate a few more to ensure unique values\n    min_rows = 5\n    fac = 1.02\n    extra_size = min(size + min_rows, fac * size)\n\n    def _gen_unique_rand(rng, _extra_size):\n        ind = rng.rand(int(_extra_size))\n        return np.unique(np.floor(ind * nrows * ncols))[:size]\n\n    ind = _gen_unique_rand(random_state, extra_size)\n    while ind.size < size:\n        extra_size *= 1.05\n        ind = _gen_unique_rand(random_state, extra_size)\n\n    j = np.floor(ind * 1.0 / nrows).astype(int)\n    i = (ind - j * nrows).astype(int)\n    return i.tolist(), j.tolist()",
                "def makeMissingDataframe(density=0.9, random_state=None):\n    df = makeDataFrame()\n    i, j = _create_missing_idx(*df.shape, density=density, random_state=random_state)\n    df.values[i, j] = np.nan\n    return df",
                "def optional_args(decorator):\n    \"\"\"\n    allows a decorator to take optional positional and keyword arguments.\n    Assumes that taking a single, callable, positional argument means that\n    it is decorating a function, i.e. something like this::\n\n        @my_decorator\n        def function(): pass\n\n    Calls decorator with decorator(f, *args, **kwargs)\n    \"\"\"\n\n    @wraps(decorator)\n    def wrapper(*args, **kwargs):\n        def dec(f):\n            return decorator(f, *args, **kwargs)\n\n        is_decorating = not kwargs and len(args) == 1 and callable(args[0])\n        if is_decorating:\n            f = args[0]\n            args = []\n            return dec(f)\n        else:\n            return dec\n\n    return wrapper",
                "def _get_default_network_errors():\n    # Lazy import for http.client because it imports many things from the stdlib\n    import http.client\n\n    return (IOError, http.client.HTTPException, TimeoutError)",
                "def can_connect(url, error_classes=None):\n    \"\"\"\n    Try to connect to the given url. True if succeeds, False if IOError\n    raised\n\n    Parameters\n    ----------\n    url : basestring\n        The URL to try to connect to\n\n    Returns\n    -------\n    connectable : bool\n        Return True if no IOError (unable to connect) or URLError (bad url) was\n        raised\n    \"\"\"\n    if error_classes is None:\n        error_classes = _get_default_network_errors()\n\n    try:\n        with urlopen(url):\n            pass\n    except error_classes:\n        return False\n    else:\n        return True",
                "@optional_args\ndef network(\n    t,\n    url=\"http://www.google.com\",\n    raise_on_error=_RAISE_NETWORK_ERROR_DEFAULT,\n    check_before_test=False,\n    error_classes=None,\n    skip_errnos=_network_errno_vals,\n    _skip_on_messages=_network_error_messages,\n):\n    \"\"\"\n    Label a test as requiring network connection and, if an error is\n    encountered, only raise if it does not find a network connection.\n\n    In comparison to ``network``, this assumes an added contract to your test:\n    you must assert that, under normal conditions, your test will ONLY fail if\n    it does not have network connectivity.\n\n    You can call this in 3 ways: as a standard decorator, with keyword\n    arguments, or with a positional argument that is the url to check.\n\n    Parameters\n    ----------\n    t : callable\n        The test requiring network connectivity.\n    url : path\n        The url to test via ``pandas.io.common.urlopen`` to check\n        for connectivity. Defaults to 'http://www.google.com'.\n    raise_on_error : bool\n        If True, never catches errors.\n    check_before_test : bool\n        If True, checks connectivity before running the test case.\n    error_classes : tuple or Exception\n        error classes to ignore. If not in ``error_classes``, raises the error.\n        defaults to IOError. Be careful about changing the error classes here.\n    skip_errnos : iterable of int\n        Any exception that has .errno or .reason.erno set to one\n        of these values will be skipped with an appropriate\n        message.\n    _skip_on_messages: iterable of string\n        any exception e for which one of the strings is\n        a substring of str(e) will be skipped with an appropriate\n        message. Intended to suppress errors where an errno isn't available.\n\n    Notes\n    -----\n    * ``raise_on_error`` supercedes ``check_before_test``\n\n    Returns\n    -------\n    t : callable\n        The decorated test ``t``, with checks for connectivity errors.\n\n    Example\n    -------\n\n    Tests decorated with @network will fail if it's possible to make a network\n    connection to another URL (defaults to google.com)::\n\n      >>> from pandas._testing import network\n      >>> from pandas.io.common import urlopen\n      >>> @network\n      ... def test_network():\n      ...     with urlopen(\"rabbit://bonanza.com\"):\n      ...         pass\n      Traceback\n         ...\n      URLError: <urlopen error unknown url type: rabit>\n\n      You can specify alternative URLs::\n\n        >>> @network(\"http://www.yahoo.com\")\n        ... def test_something_with_yahoo():\n        ...    raise IOError(\"Failure Message\")\n        >>> test_something_with_yahoo()\n        Traceback (most recent call last):\n            ...\n        IOError: Failure Message\n\n    If you set check_before_test, it will check the url first and not run the\n    test on failure::\n\n        >>> @network(\"failing://url.blaher\", check_before_test=True)\n        ... def test_something():\n        ...     print(\"I ran!\")\n        ...     raise ValueError(\"Failure\")\n        >>> test_something()\n        Traceback (most recent call last):\n            ...\n\n    Errors not related to networking will always be raised.\n    \"\"\"\n    from pytest import skip\n\n    if error_classes is None:\n        error_classes = _get_default_network_errors()\n\n    t.network = True\n\n    @wraps(t)\n    def wrapper(*args, **kwargs):\n        if check_before_test and not raise_on_error:\n            if not can_connect(url, error_classes):\n                skip()\n        try:\n            return t(*args, **kwargs)\n        except Exception as err:\n            errno = getattr(err, \"errno\", None)\n            if not errno and hasattr(errno, \"reason\"):\n                errno = getattr(err.reason, \"errno\", None)\n\n            if errno in skip_errnos:\n                skip(f\"Skipping test due to known errno and error {err}\")\n\n            e_str = str(err)\n\n            if any(m.lower() in e_str.lower() for m in _skip_on_messages):\n                skip(\n                    f\"Skipping test because exception message is known and error {err}\"\n                )\n\n            if not isinstance(err, error_classes):\n                raise\n\n            if raise_on_error or can_connect(url, error_classes):\n                raise\n            else:\n                skip(f\"Skipping test due to lack of connectivity and error {err}\")\n\n    return wrapper",
                "@contextmanager\ndef assert_produces_warning(\n    expected_warning=Warning,\n    filter_level=\"always\",\n    check_stacklevel=True,\n    raise_on_extra_warnings=True,\n):\n    \"\"\"\n    Context manager for running code expected to either raise a specific\n    warning, or not raise any warnings. Verifies that the code raises the\n    expected warning, and that it does not raise any other unexpected\n    warnings. It is basically a wrapper around ``warnings.catch_warnings``.\n\n    Parameters\n    ----------\n    expected_warning : {Warning, False, None}, default Warning\n        The type of Exception raised. ``exception.Warning`` is the base\n        class for all warnings. To check that no warning is returned,\n        specify ``False`` or ``None``.\n    filter_level : str or None, default \"always\"\n        Specifies whether warnings are ignored, displayed, or turned\n        into errors.\n        Valid values are:\n\n        * \"error\" - turns matching warnings into exceptions\n        * \"ignore\" - discard the warning\n        * \"always\" - always emit a warning\n        * \"default\" - print the warning the first time it is generated\n          from each location\n        * \"module\" - print the warning the first time it is generated\n          from each module\n        * \"once\" - print the warning the first time it is generated\n\n    check_stacklevel : bool, default True\n        If True, displays the line that called the function containing\n        the warning to show were the function is called. Otherwise, the\n        line that implements the function is displayed.\n    raise_on_extra_warnings : bool, default True\n        Whether extra warnings not of the type `expected_warning` should\n        cause the test to fail.\n\n    Examples\n    --------\n    >>> import warnings\n    >>> with assert_produces_warning():\n    ...     warnings.warn(UserWarning())\n    ...\n    >>> with assert_produces_warning(False):\n    ...     warnings.warn(RuntimeWarning())\n    ...\n    Traceback (most recent call last):\n        ...\n    AssertionError: Caused unexpected warning(s): ['RuntimeWarning'].\n    >>> with assert_produces_warning(UserWarning):\n    ...     warnings.warn(RuntimeWarning())\n    Traceback (most recent call last):\n        ...\n    AssertionError: Did not see expected warning of class 'UserWarning'.\n\n    ..warn:: This is *not* thread-safe.\n    \"\"\"\n    __tracebackhide__ = True\n\n    with warnings.catch_warnings(record=True) as w:\n\n        saw_warning = False\n        warnings.simplefilter(filter_level)\n        yield w\n        extra_warnings = []\n\n        for actual_warning in w:\n            if expected_warning and issubclass(\n                actual_warning.category, expected_warning\n            ):\n                saw_warning = True\n\n                if check_stacklevel and issubclass(\n                    actual_warning.category, (FutureWarning, DeprecationWarning)\n                ):\n                    from inspect import getframeinfo, stack\n\n                    caller = getframeinfo(stack()[2][0])\n                    msg = (\n                        \"Warning not set with correct stacklevel. \"\n                        f\"File where warning is raised: {actual_warning.filename} != \"\n                        f\"{caller.filename}. Warning message: {actual_warning.message}\"\n                    )\n                    assert actual_warning.filename == caller.filename, msg\n            else:\n                extra_warnings.append(\n                    (\n                        actual_warning.category.__name__,\n                        actual_warning.message,\n                        actual_warning.filename,\n                        actual_warning.lineno,\n                    )\n                )\n        if expected_warning:\n            msg = (\n                f\"Did not see expected warning of class \"\n                f\"{repr(expected_warning.__name__)}\"\n            )\n            assert saw_warning, msg\n        if raise_on_extra_warnings and extra_warnings:\n            raise AssertionError(\n                f\"Caused unexpected warning(s): {repr(extra_warnings)}\"\n            )",
                "@contextmanager\ndef with_csv_dialect(name, **kwargs):\n    \"\"\"\n    Context manager to temporarily register a CSV dialect for parsing CSV.\n\n    Parameters\n    ----------\n    name : str\n        The name of the dialect.\n    kwargs : mapping\n        The parameters for the dialect.\n\n    Raises\n    ------\n    ValueError : the name of the dialect conflicts with a builtin one.\n\n    See Also\n    --------\n    csv : Python's CSV library.\n    \"\"\"\n    import csv\n\n    _BUILTIN_DIALECTS = {\"excel\", \"excel-tab\", \"unix\"}\n\n    if name in _BUILTIN_DIALECTS:\n        raise ValueError(\"Cannot override builtin dialect.\")\n\n    csv.register_dialect(name, **kwargs)\n    yield\n    csv.unregister_dialect(name)",
                "@contextmanager\ndef use_numexpr(use, min_elements=None):\n    from pandas.core.computation import expressions as expr\n\n    if min_elements is None:\n        min_elements = expr._MIN_ELEMENTS\n\n    olduse = expr._USE_NUMEXPR\n    oldmin = expr._MIN_ELEMENTS\n    expr.set_use_numexpr(use)\n    expr._MIN_ELEMENTS = min_elements\n    yield\n    expr._MIN_ELEMENTS = oldmin\n    expr.set_use_numexpr(olduse)",
                "def test_parallel(num_threads=2, kwargs_list=None):\n    \"\"\"\n    Decorator to run the same function multiple times in parallel.\n\n    Parameters\n    ----------\n    num_threads : int, optional\n        The number of times the function is run in parallel.\n    kwargs_list : list of dicts, optional\n        The list of kwargs to update original\n        function kwargs on different threads.\n\n    Notes\n    -----\n    This decorator does not pass the return value of the decorated function.\n\n    Original from scikit-image:\n\n    https://github.com/scikit-image/scikit-image/pull/1519\n\n    \"\"\"\n    assert num_threads > 0\n    has_kwargs_list = kwargs_list is not None\n    if has_kwargs_list:\n        assert len(kwargs_list) == num_threads\n    import threading\n\n    def wrapper(func):\n        @wraps(func)\n        def inner(*args, **kwargs):\n            if has_kwargs_list:\n                update_kwargs = lambda i: dict(kwargs, **kwargs_list[i])\n            else:\n                update_kwargs = lambda i: kwargs\n            threads = []\n            for i in range(num_threads):\n                updated_kwargs = update_kwargs(i)\n                thread = threading.Thread(target=func, args=args, kwargs=updated_kwargs)\n                threads.append(thread)\n            for thread in threads:\n                thread.start()\n            for thread in threads:\n                thread.join()\n\n        return inner\n\n    return wrapper",
                "@contextmanager\ndef set_timezone(tz: str):\n    \"\"\"\n    Context manager for temporarily setting a timezone.\n\n    Parameters\n    ----------\n    tz : str\n        A string representing a valid timezone.\n\n    Examples\n    --------\n    >>> from datetime import datetime\n    >>> from dateutil.tz import tzlocal\n    >>> tzlocal().tzname(datetime.now())\n    'IST'\n\n    >>> with set_timezone('US/Eastern'):\n    ...     tzlocal().tzname(datetime.now())\n    ...\n    'EDT'\n    \"\"\"\n    import os\n    import time\n\n    def setTZ(tz):\n        if tz is None:\n            try:\n                del os.environ[\"TZ\"]\n            except KeyError:\n                pass\n        else:\n            os.environ[\"TZ\"] = tz\n            time.tzset()\n\n    orig_tz = os.environ.get(\"TZ\")\n    setTZ(tz)\n    try:\n        yield\n    finally:\n        setTZ(orig_tz)",
                "def _make_skipna_wrapper(alternative, skipna_alternative=None):\n    \"\"\"\n    Create a function for calling on an array.\n\n    Parameters\n    ----------\n    alternative : function\n        The function to be called on the array with no NaNs.\n        Only used when 'skipna_alternative' is None.\n    skipna_alternative : function\n        The function to be called on the original array\n\n    Returns\n    -------\n    function\n    \"\"\"\n    if skipna_alternative:\n\n        def skipna_wrapper(x):\n            return skipna_alternative(x.values)\n\n    else:\n\n        def skipna_wrapper(x):\n            nona = x.dropna()\n            if len(nona) == 0:\n                return np.nan\n            return alternative(nona)\n\n    return skipna_wrapper",
                "def convert_rows_list_to_csv_str(rows_list: List[str]):\n    \"\"\"\n    Convert list of CSV rows to single CSV-formatted string for current OS.\n\n    This method is used for creating expected value of to_csv() method.\n\n    Parameters\n    ----------\n    rows_list : List[str]\n        Each element represents the row of csv.\n\n    Returns\n    -------\n    str\n        Expected output of to_csv() in current OS.\n    \"\"\"\n    sep = os.linesep\n    expected = sep.join(rows_list) + sep\n    return expected",
                "def external_error_raised(\n    expected_exception: Type[Exception],\n) -> Callable[[Type[Exception], None], None]:\n    \"\"\"\n    Helper function to mark pytest.raises that have an external error message.\n\n    Parameters\n    ----------\n    expected_exception : Exception\n        Expected error to raise.\n\n    Returns\n    -------\n    Callable\n        Regular `pytest.raises` function with `match` equal to `None`.\n    \"\"\"\n    import pytest\n\n    return pytest.raises(expected_exception, match=None)",
                "def _check_types(l, r, obj=\"Index\"):\n    if exact:\n        assert_class_equal(l, r, exact=exact, obj=obj)\n\n        # Skip exact dtype checking when `check_categorical` is False\n        if check_categorical:\n            assert_attr_equal(\"dtype\", l, r, obj=obj)\n\n        # allow string-like to have different inferred_types\n        if l.inferred_type in (\"string\"):\n            assert r.inferred_type in (\"string\")\n        else:\n            assert_attr_equal(\"inferred_type\", l, r, obj=obj)",
                "def _get_ilevel_values(index, level):\n    # accept level number only\n    unique = index.levels[level]\n    level_codes = index.codes[level]\n    filled = take_1d(unique._values, level_codes, fill_value=unique._na_value)\n    values = unique._shallow_copy(filled, name=index.names[level])\n    return values",
                "def repr_class(x):\n    if isinstance(x, Index):\n        # return Index as it is to include values in the error message\n        return x\n\n    return type(x).__name__",
                "def _get_base(obj):\n    return obj.base if getattr(obj, \"base\", None) is not None else obj",
                "def _raise(left, right, err_msg):\n    if err_msg is None:\n        if left.shape != right.shape:\n            raise_assert_detail(\n                obj, f\"{obj} shapes are different\", left.shape, right.shape,\n            )\n\n        diff = 0\n        for l, r in zip(left, right):\n            # count up differences\n            if not array_equivalent(l, r, strict_nan=strict_nan):\n                diff += 1\n\n        diff = diff * 100.0 / left.size\n        msg = f\"{obj} values are different ({np.round(diff, 5)} %)\"\n        raise_assert_detail(obj, msg, left, right)\n\n    raise AssertionError(err_msg)",
                "def _gen_unique_rand(rng, _extra_size):\n    ind = rng.rand(int(_extra_size))\n    return np.unique(np.floor(ind * nrows * ncols))[:size]",
                "@wraps(decorator)\ndef wrapper(*args, **kwargs):\n    def dec(f):\n        return decorator(f, *args, **kwargs)\n\n    is_decorating = not kwargs and len(args) == 1 and callable(args[0])\n    if is_decorating:\n        f = args[0]\n        args = []\n        return dec(f)\n    else:\n        return dec",
                "@wraps(t)\ndef wrapper(*args, **kwargs):\n    if check_before_test and not raise_on_error:\n        if not can_connect(url, error_classes):\n            skip()\n    try:\n        return t(*args, **kwargs)\n    except Exception as err:\n        errno = getattr(err, \"errno\", None)\n        if not errno and hasattr(errno, \"reason\"):\n            errno = getattr(err.reason, \"errno\", None)\n\n        if errno in skip_errnos:\n            skip(f\"Skipping test due to known errno and error {err}\")\n\n        e_str = str(err)\n\n        if any(m.lower() in e_str.lower() for m in _skip_on_messages):\n            skip(\n                f\"Skipping test because exception message is known and error {err}\"\n            )\n\n        if not isinstance(err, error_classes):\n            raise\n\n        if raise_on_error or can_connect(url, error_classes):\n            raise\n        else:\n            skip(f\"Skipping test due to lack of connectivity and error {err}\")",
                "def __init__(self, seed):\n    self.seed = seed",
                "def __enter__(self):\n\n    self.start_state = np.random.get_state()\n    np.random.seed(self.seed)",
                "def __exit__(self, exc_type, exc_value, traceback):\n\n    np.random.set_state(self.start_state)",
                "def wrapper(func):\n    @wraps(func)\n    def inner(*args, **kwargs):\n        if has_kwargs_list:\n            update_kwargs = lambda i: dict(kwargs, **kwargs_list[i])\n        else:\n            update_kwargs = lambda i: kwargs\n        threads = []\n        for i in range(num_threads):\n            updated_kwargs = update_kwargs(i)\n            thread = threading.Thread(target=func, args=args, kwargs=updated_kwargs)\n            threads.append(thread)\n        for thread in threads:\n            thread.start()\n        for thread in threads:\n            thread.join()\n\n    return inner",
                "@property\ndef _constructor(self):\n    return SubclassedSeries",
                "@property\ndef _constructor_expanddim(self):\n    return SubclassedDataFrame",
                "@property\ndef _constructor(self):\n    return SubclassedDataFrame",
                "@property\ndef _constructor_sliced(self):\n    return SubclassedSeries",
                "@property\ndef _constructor(self):\n    return SubclassedCategorical",
                "def setTZ(tz):\n    if tz is None:\n        try:\n            del os.environ[\"TZ\"]\n        except KeyError:\n            pass\n    else:\n        os.environ[\"TZ\"] = tz\n        time.tzset()",
                "def keyfunc(x):\n    import re\n\n    numeric_tuple = re.sub(r\"[^\\d_]_?\", \"\", x).split(\"_\")\n    return [int(num) for num in numeric_tuple]",
                "def dec(f):\n    return decorator(f, *args, **kwargs)",
                "@wraps(func)\ndef inner(*args, **kwargs):\n    if has_kwargs_list:\n        update_kwargs = lambda i: dict(kwargs, **kwargs_list[i])\n    else:\n        update_kwargs = lambda i: kwargs\n    threads = []\n    for i in range(num_threads):\n        updated_kwargs = update_kwargs(i)\n        thread = threading.Thread(target=func, args=args, kwargs=updated_kwargs)\n        threads.append(thread)\n    for thread in threads:\n        thread.start()\n    for thread in threads:\n        thread.join()",
                "def skipna_wrapper(x):\n    return skipna_alternative(x.values)",
                "def skipna_wrapper(x):\n    nona = x.dropna()\n    if len(nona) == 0:\n        return np.nan\n    return alternative(nona)"
            ],
            "inscope_function_signatures": [
                "set_testing_mode()",
                "reset_testing_mode()",
                "reset_display_options()",
                "round_trip_pickle(obj: Any, path: Optional[FilePathOrBuffer]=None) -> FrameOrSeries",
                "round_trip_pathlib(writer, reader, path: Optional[str]=None)",
                "round_trip_localpath(writer, reader, path: Optional[str]=None)",
                "decompress_file(path, compression)",
                "write_to_compressed(compression, path, data, dest='test')",
                "assert_almost_equal(left, right, check_dtype: Union[bool, str]='equiv', check_less_precise: Union[bool, int]=False, **kwargs)",
                "_check_isinstance(left, right, cls)",
                "assert_dict_equal(left, right, compare_keys: bool=True)",
                "randbool(size=(), p: float=0.5)",
                "rands_array(nchars, size, dtype='O')",
                "randu_array(nchars, size, dtype='O')",
                "rands(nchars)",
                "close(fignum=None)",
                "ensure_clean(filename=None, return_filelike=False, **kwargs)",
                "ensure_clean_dir()",
                "ensure_safe_environment_variables()",
                "equalContents(arr1, arr2) -> bool",
                "assert_index_equal(left: Index, right: Index, exact: Union[bool, str]='equiv', check_names: bool=True, check_less_precise: Union[bool, int]=False, check_exact: bool=True, check_categorical: bool=True, obj: str='Index') -> None",
                "assert_class_equal(left, right, exact: Union[bool, str]=True, obj='Input')",
                "assert_attr_equal(attr: str, left, right, obj: str='Attributes')",
                "assert_is_valid_plot_return_object(objs)",
                "assert_is_sorted(seq)",
                "assert_categorical_equal(left, right, check_dtype=True, check_category_order=True, obj='Categorical')",
                "assert_interval_array_equal(left, right, exact='equiv', obj='IntervalArray')",
                "assert_period_array_equal(left, right, obj='PeriodArray')",
                "assert_datetime_array_equal(left, right, obj='DatetimeArray')",
                "assert_timedelta_array_equal(left, right, obj='TimedeltaArray')",
                "raise_assert_detail(obj, message, left, right, diff=None)",
                "assert_numpy_array_equal(left, right, strict_nan=False, check_dtype=True, err_msg=None, check_same=None, obj='numpy array')",
                "assert_extension_array_equal(left, right, check_dtype=True, check_less_precise=False, check_exact=False)",
                "assert_series_equal(left, right, check_dtype=True, check_index_type='equiv', check_series_type=True, check_less_precise=False, check_names=True, check_exact=False, check_datetimelike_compat=False, check_categorical=True, check_category_order=True, obj='Series')",
                "assert_frame_equal(left, right, check_dtype=True, check_index_type='equiv', check_column_type='equiv', check_frame_type=True, check_less_precise=False, check_names=True, by_blocks=False, check_exact=False, check_datetimelike_compat=False, check_categorical=True, check_like=False, obj='DataFrame')",
                "assert_equal(left, right, **kwargs)",
                "box_expected(expected, box_cls, transpose=True)",
                "to_array(obj)",
                "assert_sp_array_equal(left, right)",
                "assert_contains_all(iterable, dic)",
                "assert_copy(iter1, iter2, **eql_kwargs)",
                "getCols(k)",
                "makeStringIndex(k=10, name=None)",
                "makeUnicodeIndex(k=10, name=None)",
                "makeCategoricalIndex(k=10, n=3, name=None, **kwargs)",
                "makeIntervalIndex(k=10, name=None, **kwargs)",
                "makeBoolIndex(k=10, name=None)",
                "makeIntIndex(k=10, name=None)",
                "makeUIntIndex(k=10, name=None)",
                "makeRangeIndex(k=10, name=None, **kwargs)",
                "makeFloatIndex(k=10, name=None)",
                "makeDateIndex(k=10, freq='B', name=None, **kwargs)",
                "makeTimedeltaIndex(k=10, freq='D', name=None, **kwargs)",
                "makePeriodIndex(k=10, name=None, **kwargs)",
                "makeMultiIndex(k=10, names=None, **kwargs)",
                "_make_timeseries(start='2000-01-01', end='2000-12-31', freq='1D', seed=None)",
                "all_index_generator(k=10)",
                "index_subclass_makers_generator()",
                "all_timeseries_index_generator(k=10)",
                "makeFloatSeries(name=None)",
                "makeStringSeries(name=None)",
                "makeObjectSeries(name=None)",
                "getSeriesData()",
                "makeTimeSeries(nper=None, freq='B', name=None)",
                "makePeriodSeries(nper=None, name=None)",
                "getTimeSeriesData(nper=None, freq='B')",
                "getPeriodData(nper=None)",
                "makeTimeDataFrame(nper=None, freq='B')",
                "makeDataFrame()",
                "getMixedTypeDict()",
                "makeMixedDataFrame()",
                "makePeriodFrame(nper=None)",
                "makeCustomIndex(nentries, nlevels, prefix='#', names=False, ndupe_l=None, idx_type=None)",
                "makeCustomDataframe(nrows, ncols, c_idx_names=True, r_idx_names=True, c_idx_nlevels=1, r_idx_nlevels=1, data_gen_f=None, c_ndupe_l=None, r_ndupe_l=None, dtype=None, c_idx_type=None, r_idx_type=None)",
                "_create_missing_idx(nrows, ncols, density, random_state=None)",
                "makeMissingDataframe(density=0.9, random_state=None)",
                "optional_args(decorator)",
                "_get_default_network_errors()",
                "can_connect(url, error_classes=None)",
                "network(t, url='http://www.google.com', raise_on_error=_RAISE_NETWORK_ERROR_DEFAULT, check_before_test=False, error_classes=None, skip_errnos=_network_errno_vals, _skip_on_messages=_network_error_messages)",
                "assert_produces_warning(expected_warning=Warning, filter_level='always', check_stacklevel=True, raise_on_extra_warnings=True)",
                "with_csv_dialect(name, **kwargs)",
                "use_numexpr(use, min_elements=None)",
                "test_parallel(num_threads=2, kwargs_list=None)",
                "set_timezone(tz: str)",
                "_make_skipna_wrapper(alternative, skipna_alternative=None)",
                "convert_rows_list_to_csv_str(rows_list: List[str])",
                "external_error_raised(expected_exception: Type[Exception]) -> Callable[[Type[Exception], None], None]",
                "_check_types(l, r, obj='Index')",
                "_get_ilevel_values(index, level)",
                "repr_class(x)",
                "_get_base(obj)",
                "_raise(left, right, err_msg)",
                "_gen_unique_rand(rng, _extra_size)",
                "wrapper(*args, **kwargs)",
                "wrapper(*args, **kwargs)",
                "__init__(self, seed)",
                "__enter__(self)",
                "__exit__(self, exc_type, exc_value, traceback)",
                "wrapper(func)",
                "_constructor(self)",
                "_constructor_expanddim(self)",
                "_constructor(self)",
                "_constructor_sliced(self)",
                "_constructor(self)",
                "setTZ(tz)",
                "keyfunc(x)",
                "dec(f)",
                "inner(*args, **kwargs)",
                "skipna_wrapper(x)",
                "skipna_wrapper(x)"
            ],
            "variables_in_file": {
                "lzma": [
                    212,
                    70,
                    263
                ],
                "_import_lzma": [
                    70
                ],
                "_N": [
                    1760,
                    1765,
                    72,
                    1771,
                    1742,
                    1743,
                    1747,
                    1748,
                    1752,
                    1754,
                    1759
                ],
                "_K": [
                    1760,
                    73,
                    1776,
                    1780
                ],
                "_RAISE_NETWORK_ERROR_DEFAULT": [
                    74,
                    2167
                ],
                "_testing_mode_warnings": [
                    91,
                    84,
                    77
                ],
                "DeprecationWarning": [
                    77,
                    2375
                ],
                "ResourceWarning": [
                    77
                ],
                "testing_mode": [
                    89,
                    82,
                    83,
                    90
                ],
                "os.environ.get": [
                    89,
                    82,
                    2598
                ],
                "os.environ": [
                    2595,
                    549,
                    2598,
                    553,
                    554,
                    82,
                    89,
                    2591
                ],
                "os": [
                    512,
                    2595,
                    516,
                    517,
                    549,
                    2598,
                    553,
                    554,
                    82,
                    498,
                    89,
                    2654,
                    2591
                ],
                "warnings.simplefilter": [
                    91,
                    84,
                    2364
                ],
                "warnings": [
                    2361,
                    91,
                    84,
                    2364
                ],
                "set_testing_mode": [
                    94
                ],
                "pd.reset_option": [
                    101
                ],
                "pd": [
                    774,
                    1671,
                    1680,
                    1430,
                    1431,
                    1432,
                    1433,
                    1434,
                    1435,
                    690,
                    692,
                    312,
                    1592,
                    1597,
                    322,
                    1482,
                    332,
                    1487,
                    1488,
                    101,
                    1392,
                    1394,
                    1396,
                    126,
                    127
                ],
                "Any": [
                    105
                ],
                "Optional": [
                    105,
                    130,
                    159
                ],
                "FilePathOrBuffer": [
                    105
                ],
                "_path": [
                    122,
                    123,
                    124,
                    125
                ],
                "path": [
                    154,
                    276,
                    206,
                    219,
                    208,
                    210,
                    180,
                    181,
                    182,
                    151,
                    152,
                    153,
                    122,
                    155,
                    184,
                    212,
                    183,
                    214
                ],
                "rands": [
                    124
                ],
                "ensure_clean": [
                    153,
                    125,
                    182
                ],
                "temp_path": [
                    125,
                    126,
                    127
                ],
                "pd.to_pickle": [
                    126
                ],
                "obj": [
                    768,
                    642,
                    645,
                    1146,
                    1375,
                    904,
                    1171,
                    155,
                    668,
                    156,
                    1184,
                    674,
                    675,
                    1189,
                    1318,
                    682,
                    1196,
                    689,
                    691,
                    948,
                    1333,
                    822,
                    1459,
                    184,
                    185,
                    697,
                    824,
                    953,
                    1460,
                    1461,
                    1462,
                    1463,
                    1345,
                    834,
                    1466,
                    1464,
                    839,
                    969,
                    842,
                    1356,
                    718,
                    719,
                    722,
                    723,
                    979,
                    980,
                    1108,
                    1114,
                    990,
                    607,
                    863,
                    353,
                    864,
                    355,
                    356,
                    611,
                    865,
                    871,
                    872,
                    617,
                    1125,
                    879,
                    880,
                    881,
                    887,
                    1139,
                    631,
                    888,
                    126,
                    635,
                    638
                ],
                "pd.read_pickle": [
                    127
                ],
                "FrameOrSeries": [
                    106
                ],
                "str": [
                    576,
                    1184,
                    130,
                    1410,
                    1851,
                    1857,
                    2277,
                    2564,
                    2638,
                    283,
                    1171,
                    726,
                    1146,
                    571,
                    700,
                    159
                ],
                "Path": [
                    154,
                    155,
                    150
                ],
                "pytest.importorskip": [
                    179,
                    150
                ],
                "pytest": [
                    506,
                    179,
                    2677,
                    150
                ],
                "writer": [
                    154,
                    183
                ],
                "reader": [
                    184,
                    155
                ],
                "LocalPath": [
                    184,
                    179,
                    183
                ],
                "local": [
                    179
                ],
                "compression": [
                    258,
                    227,
                    262,
                    265,
                    267,
                    205,
                    207,
                    209,
                    211,
                    213,
                    250,
                    221,
                    254
                ],
                "f": [
                    224,
                    2081,
                    226,
                    2083,
                    490,
                    493,
                    206,
                    495,
                    208,
                    210,
                    212,
                    276,
                    277,
                    217,
                    2077
                ],
                "open": [
                    206
                ],
                "gzip.open": [
                    208
                ],
                "gzip": [
                    208,
                    257
                ],
                "bz2.BZ2File": [
                    210,
                    261
                ],
                "bz2": [
                    210,
                    261
                ],
                "_get_lzma_file": [
                    212,
                    263
                ],
                "zip_file": [
                    217,
                    228,
                    214,
                    215
                ],
                "zipfile.ZipFile": [
                    253,
                    214
                ],
                "zipfile": [
                    253,
                    214
                ],
                "zip_names": [
                    216,
                    217,
                    215
                ],
                "zip_file.namelist": [
                    215
                ],
                "len": [
                    641,
                    643,
                    644,
                    1672,
                    2079,
                    673,
                    1843,
                    1844,
                    2631,
                    2508,
                    717,
                    1111,
                    216,
                    1113,
                    1882,
                    1883,
                    1112,
                    1884,
                    498
                ],
                "zip_file.open": [
                    217
                ],
                "zip_names.pop": [
                    217
                ],
                "ValueError": [
                    265,
                    499,
                    1877,
                    219,
                    221,
                    2461
                ],
                "f.close": [
                    226,
                    495
                ],
                "zip_file.close": [
                    228
                ],
                "contextmanager": [
                    2563,
                    2436,
                    2468,
                    522,
                    459,
                    2298,
                    188,
                    541
                ],
                "compress_method": [
                    257,
                    261,
                    263,
                    276,
                    253
                ],
                "gzip.GzipFile": [
                    257
                ],
                "mode": [
                    272,
                    268,
                    276
                ],
                "args": [
                    2081,
                    2082,
                    269,
                    273,
                    277,
                    2521,
                    2268,
                    2077,
                    2079
                ],
                "dest": [
                    269
                ],
                "data": [
                    1797,
                    2023,
                    2025,
                    1804,
                    269,
                    273,
                    1812,
                    1785,
                    1813,
                    1752,
                    1753,
                    1786,
                    1755,
                    1790,
                    1791
                ],
                "method": [
                    274,
                    277,
                    270
                ],
                "getattr": [
                    2272,
                    742,
                    743,
                    277,
                    953,
                    2270
                ],
                "Union": [
                    283,
                    284,
                    571,
                    700,
                    573
                ],
                "bool": [
                    700,
                    574,
                    394,
                    561,
                    761,
                    571,
                    283,
                    284,
                    573,
                    572,
                    575
                ],
                "int": [
                    673,
                    2050,
                    2051,
                    1895,
                    2035,
                    2042,
                    284,
                    573
                ],
                "isinstance": [
                    384,
                    1408,
                    1410,
                    899,
                    388,
                    774,
                    780,
                    1402,
                    787,
                    792,
                    1312,
                    1406,
                    690,
                    692,
                    312,
                    1857,
                    322,
                    707,
                    332,
                    1487,
                    1488,
                    989,
                    352,
                    2284,
                    1392,
                    1394,
                    1396,
                    1398,
                    1400,
                    761,
                    1018,
                    1019,
                    1404,
                    894
                ],
                "left": [
                    1026,
                    1029,
                    1033,
                    1105,
                    1108,
                    1111,
                    1112,
                    1118,
                    1133,
                    1139,
                    628,
                    1142,
                    631,
                    634,
                    1146,
                    636,
                    1149,
                    641,
                    643,
                    1157,
                    1159,
                    648,
                    649,
                    1163,
                    652,
                    1164,
                    654,
                    1165,
                    1167,
                    1173,
                    1174,
                    1175,
                    1177,
                    668,
                    1180,
                    672,
                    673,
                    675,
                    1189,
                    678,
                    1192,
                    1194,
                    683,
                    689,
                    690,
                    691,
                    692,
                    693,
                    696,
                    697,
                    714,
                    716,
                    719,
                    721,
                    723,
                    742,
                    1309,
                    1312,
                    1316,
                    1318,
                    1322,
                    1326,
                    819,
                    822,
                    312,
                    824,
                    314,
                    1338,
                    828,
                    832,
                    322,
                    324,
                    837,
                    1351,
                    842,
                    332,
                    334,
                    1361,
                    1363,
                    345,
                    348,
                    861,
                    863,
                    352,
                    864,
                    865,
                    356,
                    869,
                    358,
                    871,
                    872,
                    877,
                    879,
                    880,
                    881,
                    1392,
                    1393,
                    1394,
                    1395,
                    886,
                    887,
                    888,
                    1396,
                    1397,
                    1398,
                    1399,
                    1400,
                    894,
                    895,
                    384,
                    896,
                    386,
                    897,
                    1403,
                    1404,
                    1405,
                    1406,
                    1407,
                    1401,
                    1409,
                    907,
                    396,
                    397,
                    1402,
                    1414,
                    1408,
                    948,
                    950,
                    1410,
                    955,
                    1412,
                    967,
                    969,
                    1482,
                    1484,
                    973,
                    1487,
                    978,
                    1490,
                    980,
                    985,
                    986,
                    989,
                    990,
                    1501,
                    1502,
                    1503,
                    1018,
                    1021,
                    1023
                ],
                "pd.Index": [
                    312,
                    1392,
                    1430,
                    1431
                ],
                "assert_index_equal": [
                    864,
                    833,
                    836,
                    1337,
                    1325,
                    1393,
                    658,
                    822,
                    313,
                    1117,
                    863
                ],
                "right": [
                    1026,
                    1030,
                    1034,
                    1105,
                    1108,
                    1111,
                    1113,
                    1119,
                    1134,
                    1139,
                    628,
                    631,
                    634,
                    1146,
                    637,
                    1149,
                    641,
                    644,
                    1157,
                    1160,
                    650,
                    1163,
                    1164,
                    1165,
                    655,
                    1168,
                    1173,
                    1174,
                    1175,
                    1177,
                    668,
                    1181,
                    672,
                    673,
                    675,
                    1189,
                    679,
                    1192,
                    1195,
                    684,
                    689,
                    690,
                    691,
                    692,
                    693,
                    696,
                    697,
                    714,
                    716,
                    719,
                    721,
                    723,
                    743,
                    1309,
                    1312,
                    1316,
                    1318,
                    1322,
                    1327,
                    819,
                    822,
                    824,
                    315,
                    1339,
                    829,
                    832,
                    325,
                    838,
                    1350,
                    842,
                    335,
                    1362,
                    1364,
                    345,
                    348,
                    861,
                    863,
                    352,
                    864,
                    865,
                    356,
                    869,
                    359,
                    871,
                    872,
                    877,
                    879,
                    880,
                    881,
                    1393,
                    1395,
                    1397,
                    886,
                    887,
                    888,
                    1399,
                    1401,
                    1403,
                    1405,
                    1407,
                    1409,
                    899,
                    388,
                    900,
                    390,
                    901,
                    902,
                    1412,
                    396,
                    397,
                    908,
                    948,
                    950,
                    956,
                    967,
                    969,
                    1482,
                    1484,
                    973,
                    1488,
                    1491,
                    980,
                    985,
                    986,
                    989,
                    990,
                    1501,
                    1502,
                    1503,
                    1019,
                    1021,
                    1023
                ],
                "check_dtype": [
                    1368,
                    327,
                    360,
                    1128,
                    1020,
                    1356,
                    337,
                    824,
                    1041,
                    1170,
                    344,
                    1146,
                    988,
                    317,
                    1183
                ],
                "check_less_precise": [
                    1342,
                    1122,
                    328,
                    361,
                    680,
                    1169,
                    338,
                    1042,
                    1330,
                    663,
                    1370,
                    1182,
                    318
                ],
                "kwargs": [
                    1409,
                    1411,
                    1550,
                    1557,
                    2077,
                    2079,
                    2463,
                    1577,
                    1588,
                    1592,
                    1597,
                    319,
                    1602,
                    329,
                    339,
                    2515,
                    2517,
                    2268,
                    487,
                    362,
                    490,
                    1393,
                    1395,
                    1397,
                    502,
                    1399,
                    1401,
                    1403,
                    1405,
                    1407
                ],
                "pd.Series": [
                    322,
                    774,
                    1394,
                    1432,
                    1433,
                    1435
                ],
                "assert_series_equal": [
                    1395,
                    323,
                    1365
                ],
                "pd.DataFrame": [
                    1396,
                    1434,
                    332,
                    1680
                ],
                "assert_frame_equal": [
                    1397,
                    1355,
                    333
                ],
                "is_number": [
                    345,
                    748,
                    750
                ],
                "is_bool": [
                    348
                ],
                "np.ndarray": [
                    352,
                    1408,
                    899,
                    774,
                    1448,
                    950,
                    989,
                    894
                ],
                "np": [
                    1408,
                    2433,
                    1026,
                    899,
                    2050,
                    1029,
                    774,
                    1030,
                    1033,
                    1034,
                    1673,
                    2058,
                    1550,
                    404,
                    405,
                    1556,
                    407,
                    795,
                    416,
                    417,
                    673,
                    674,
                    1448,
                    1449,
                    428,
                    429,
                    1581,
                    1582,
                    950,
                    442,
                    1466,
                    2632,
                    979,
                    989,
                    352,
                    749,
                    2030,
                    751,
                    2032,
                    2035,
                    2043,
                    2428,
                    2429,
                    894
                ],
                "assert_class_equal": [
                    948,
                    356,
                    1108,
                    607
                ],
                "_testing.assert_almost_equal": [
                    357,
                    677,
                    1166,
                    1038,
                    1179
                ],
                "_testing": [
                    357,
                    677,
                    397,
                    1038,
                    1166,
                    1179
                ],
                "cls_name": [
                    386,
                    390,
                    382
                ],
                "cls.__name__": [
                    382
                ],
                "cls": [
                    384,
                    386,
                    388,
                    390,
                    382
                ],
                "AssertionError": [
                    960,
                    385,
                    2402,
                    963,
                    389,
                    1162,
                    913,
                    982,
                    1143
                ],
                "type": [
                    1312,
                    386,
                    390,
                    711,
                    1414,
                    714,
                    778,
                    716,
                    721,
                    785,
                    1527,
                    1023
                ],
                "_check_isinstance": [
                    869,
                    1482,
                    396,
                    877,
                    1105,
                    819,
                    628,
                    886,
                    950,
                    1309,
                    861
                ],
                "dict": [
                    549,
                    1861,
                    780,
                    396,
                    787,
                    2515
                ],
                "_testing.assert_dict_equal": [
                    397
                ],
                "compare_keys": [
                    397
                ],
                "float": [
                    400
                ],
                "rand": [
                    401
                ],
                "size": [
                    416,
                    418,
                    428,
                    430,
                    401,
                    2035,
                    2039,
                    2043,
                    2046
                ],
                "p": [
                    401
                ],
                "RANDS_CHARS": [
                    416,
                    442,
                    404
                ],
                "np.array": [
                    1449,
                    404,
                    405,
                    1466,
                    795
                ],
                "list": [
                    1569,
                    1352,
                    1907,
                    404,
                    406
                ],
                "string.ascii_letters": [
                    404
                ],
                "string": [
                    1534,
                    404,
                    406
                ],
                "string.digits": [
                    404,
                    406
                ],
                "np.str_": [
                    417,
                    404
                ],
                "RANDU_CHARS": [
                    428,
                    405
                ],
                "join": [
                    442,
                    406
                ],
                "map": [
                    406
                ],
                "chr": [
                    406
                ],
                "range": [
                    1569,
                    1889,
                    1573,
                    2023,
                    652,
                    1900,
                    406,
                    2519,
                    1851
                ],
                "np.unicode_": [
                    429,
                    407
                ],
                "retval": [
                    432,
                    427,
                    420,
                    415
                ],
                "reshape": [
                    416,
                    428
                ],
                "view": [
                    416,
                    428
                ],
                "np.random.choice": [
                    416,
                    442,
                    428
                ],
                "np.random": [
                    416,
                    2433,
                    1673,
                    428,
                    1581,
                    1582,
                    2030,
                    2032,
                    442,
                    2428,
                    2429
                ],
                "nchars": [
                    416,
                    417,
                    428,
                    429,
                    442
                ],
                "np.prod": [
                    416,
                    428
                ],
                "retval.astype": [
                    432,
                    420
                ],
                "dtype": [
                    420,
                    1352,
                    1353,
                    1354,
                    2025,
                    1356,
                    432
                ],
                "fignum": [
                    448,
                    449,
                    450,
                    452
                ],
                "get_fignums": [
                    449
                ],
                "_close": [
                    450,
                    452
                ],
                "filename": [
                    514,
                    484,
                    516,
                    517,
                    487,
                    498,
                    502,
                    509
                ],
                "fd": [
                    512,
                    514,
                    485,
                    502
                ],
                "return_filelike": [
                    489
                ],
                "tempfile.TemporaryFile": [
                    490
                ],
                "tempfile": [
                    490,
                    531,
                    502
                ],
                "os.path.dirname": [
                    498
                ],
                "os.path": [
                    498,
                    516
                ],
                "tempfile.mkstemp": [
                    502
                ],
                "UnicodeEncodeError": [
                    503
                ],
                "pytest.skip": [
                    506
                ],
                "os.close": [
                    512
                ],
                "OSError": [
                    513,
                    518,
                    537
                ],
                "print": [
                    514,
                    519
                ],
                "os.path.exists": [
                    516
                ],
                "os.remove": [
                    517
                ],
                "e": [
                    519
                ],
                "directory_name": [
                    536,
                    531,
                    533
                ],
                "tempfile.mkdtemp": [
                    531
                ],
                "rmtree": [
                    536
                ],
                "saved_environ": [
                    554,
                    549
                ],
                "os.environ.clear": [
                    553
                ],
                "os.environ.update": [
                    554
                ],
                "frozenset": [
                    565
                ],
                "arr1": [
                    565
                ],
                "arr2": [
                    565
                ],
                "Index": [
                    1569,
                    707,
                    1539,
                    1157,
                    1573,
                    1543,
                    1795,
                    1582,
                    1562,
                    628,
                    1753,
                    1912,
                    792,
                    569,
                    570,
                    1915,
                    1564,
                    1565
                ],
                "__tracebackhide__": [
                    704,
                    740,
                    876,
                    1102,
                    1390,
                    944,
                    885,
                    2359,
                    1306,
                    603,
                    892
                ],
                "exact": [
                    864,
                    681,
                    713,
                    720,
                    661,
                    863,
                    606,
                    607
                ],
                "l": [
                    611,
                    614,
                    617,
                    973,
                    975,
                    607
                ],
                "r": [
                    611,
                    2021,
                    615,
                    2023,
                    617,
                    973,
                    975,
                    607
                ],
                "check_categorical": [
                    1344,
                    610,
                    1124,
                    1191,
                    1135,
                    1332,
                    695,
                    1374,
                    671
                ],
                "assert_attr_equal": [
                    1501,
                    865,
                    611,
                    1189,
                    1502,
                    872,
                    617,
                    842,
                    880,
                    689,
                    881,
                    691,
                    1139,
                    888,
                    1021,
                    990
                ],
                "l.inferred_type": [
                    614
                ],
                "r.inferred_type": [
                    615
                ],
                "unique": [
                    624,
                    621,
                    623
                ],
                "index.levels": [
                    621
                ],
                "index": [
                    1795,
                    1671,
                    1672,
                    1804,
                    1680,
                    1742,
                    1743,
                    1747,
                    1748,
                    1754,
                    1755,
                    2010,
                    1759,
                    1760,
                    2025,
                    621,
                    622,
                    624,
                    1912,
                    1915,
                    1917,
                    1918
                ],
                "level": [
                    652,
                    621,
                    654,
                    622,
                    624,
                    655,
                    657,
                    668
                ],
                "level_codes": [
                    622,
                    623
                ],
                "index.codes": [
                    622
                ],
                "filled": [
                    624,
                    623
                ],
                "take_1d": [
                    623
                ],
                "unique._values": [
                    623
                ],
                "unique._na_value": [
                    623
                ],
                "values": [
                    624,
                    625,
                    1581,
                    1582
                ],
                "unique._shallow_copy": [
                    624
                ],
                "index.names": [
                    624
                ],
                "_check_types": [
                    668,
                    631
                ],
                "left.nlevels": [
                    648,
                    652,
                    634,
                    636
                ],
                "right.nlevels": [
                    634,
                    637
                ],
                "msg1": [
                    642,
                    645,
                    1112,
                    1114,
                    635,
                    638
                ],
                "msg2": [
                    643,
                    645,
                    1113,
                    1114,
                    636,
                    638
                ],
                "msg3": [
                    644,
                    637,
                    638,
                    645
                ],
                "raise_assert_detail": [
                    768,
                    675,
                    645,
                    1317,
                    968,
                    719,
                    723,
                    980,
                    1494,
                    1114,
                    638
                ],
                "cast": [
                    649,
                    650
                ],
                "MultiIndex": [
                    649,
                    650,
                    1917,
                    1602
                ],
                "llevel": [
                    659,
                    654
                ],
                "_get_ilevel_values": [
                    654,
                    655
                ],
                "rlevel": [
                    660,
                    655
                ],
                "lobj": [
                    657,
                    665
                ],
                "check_names": [
                    1121,
                    1188,
                    688,
                    1329,
                    662,
                    1372,
                    1341
                ],
                "check_exact": [
                    1123,
                    1343,
                    1035,
                    1331,
                    1141,
                    664,
                    1371,
                    671
                ],
                "left.levels": [
                    668
                ],
                "right.levels": [
                    668
                ],
                "left.equals": [
                    672
                ],
                "diff": [
                    673,
                    674,
                    972,
                    910,
                    911,
                    976,
                    978,
                    979
                ],
                "np.sum": [
                    673
                ],
                "astype": [
                    673,
                    2050,
                    2051,
                    1033,
                    1034
                ],
                "left.values": [
                    673,
                    678
                ],
                "right.values": [
                    673,
                    679
                ],
                "msg": [
                    768,
                    1158,
                    776,
                    904,
                    1162,
                    780,
                    782,
                    911,
                    913,
                    787,
                    674,
                    675,
                    2380,
                    718,
                    719,
                    2385,
                    722,
                    723,
                    979,
                    980,
                    2396,
                    2400,
                    1526,
                    1530,
                    767
                ],
                "np.round": [
                    674,
                    979,
                    2035
                ],
                "pd.PeriodIndex": [
                    690
                ],
                "pd.IntervalIndex": [
                    692
                ],
                "assert_interval_array_equal": [
                    1164,
                    693,
                    1399
                ],
                "left._values": [
                    1177,
                    1157,
                    1159,
                    1194,
                    1167,
                    693,
                    1174,
                    697,
                    1146,
                    1180
                ],
                "right._values": [
                    1177,
                    1157,
                    1160,
                    1195,
                    1168,
                    693,
                    1174,
                    697,
                    1146,
                    1181
                ],
                "is_categorical_dtype": [
                    896,
                    901,
                    1192,
                    1133,
                    1134,
                    1165,
                    696
                ],
                "assert_categorical_equal": [
                    697,
                    1193
                ],
                "x": [
                    2625,
                    707,
                    709,
                    1894,
                    711,
                    2630,
                    1548,
                    1550,
                    1556,
                    1557,
                    1915,
                    1886
                ],
                "__name__": [
                    785,
                    778,
                    716,
                    711
                ],
                "types": [
                    716,
                    717
                ],
                "repr_class": [
                    723,
                    719
                ],
                "left_attr": [
                    768,
                    742,
                    745,
                    748,
                    749,
                    757
                ],
                "attr": [
                    767,
                    742,
                    743
                ],
                "right_attr": [
                    768,
                    743,
                    745,
                    750,
                    751,
                    757
                ],
                "np.isnan": [
                    749,
                    751
                ],
                "result": [
                    1904,
                    1905,
                    757,
                    760,
                    761,
                    762,
                    764
                ],
                "TypeError": [
                    830,
                    758
                ],
                "result.all": [
                    762
                ],
                "objs": [
                    785,
                    787,
                    774,
                    775
                ],
                "el": [
                    778,
                    780,
                    775
                ],
                "objs.ravel": [
                    775
                ],
                "repr": [
                    960,
                    897,
                    963,
                    2403,
                    902,
                    1318,
                    1512,
                    778,
                    785,
                    1878,
                    1527,
                    2398
                ],
                "plt.Axes": [
                    780
                ],
                "plt": [
                    787,
                    780
                ],
                "plt.Artist": [
                    787
                ],
                "tuple": [
                    787
                ],
                "seq": [
                    792,
                    793,
                    795
                ],
                "Series": [
                    1760,
                    2533,
                    1766,
                    1772,
                    1743,
                    1105,
                    1748,
                    792,
                    1755
                ],
                "seq.values": [
                    793
                ],
                "assert_numpy_array_equal": [
                    1409,
                    1026,
                    871,
                    1031,
                    1036,
                    823,
                    1484,
                    879,
                    887,
                    1145,
                    795,
                    1503
                ],
                "np.sort": [
                    795
                ],
                "Categorical": [
                    819,
                    2557,
                    1550
                ],
                "check_category_order": [
                    821,
                    1197
                ],
                "left.categories": [
                    832,
                    828,
                    837,
                    822
                ],
                "right.categories": [
                    832,
                    838,
                    829,
                    822
                ],
                "left.codes": [
                    824,
                    837
                ],
                "right.codes": [
                    824,
                    838
                ],
                "lc": [
                    832,
                    834,
                    828
                ],
                "left.categories.sort_values": [
                    828
                ],
                "rc": [
                    832,
                    834,
                    829
                ],
                "right.categories.sort_values": [
                    829
                ],
                "left.categories.take": [
                    837
                ],
                "right.categories.take": [
                    838
                ],
                "IntervalArray": [
                    861,
                    1398
                ],
                "left.left": [
                    863
                ],
                "right.left": [
                    863
                ],
                "left.right": [
                    864
                ],
                "right.right": [
                    864
                ],
                "PeriodArray": [
                    1400,
                    1441,
                    869
                ],
                "left._data": [
                    879,
                    887,
                    871
                ],
                "right._data": [
                    879,
                    887,
                    871
                ],
                "DatetimeArray": [
                    1444,
                    1445,
                    877,
                    1462,
                    1402
                ],
                "TimedeltaArray": [
                    1446,
                    1447,
                    886,
                    1464,
                    1404
                ],
                "pprint_thing": [
                    900,
                    895
                ],
                "message": [
                    906
                ],
                "obj.base": [
                    953
                ],
                "left_base": [
                    960,
                    962,
                    963,
                    955,
                    959
                ],
                "_get_base": [
                    955,
                    956
                ],
                "right_base": [
                    960,
                    962,
                    963,
                    956,
                    959
                ],
                "check_same": [
                    961,
                    958
                ],
                "err_msg": [
                    986,
                    982,
                    966
                ],
                "left.shape": [
                    969,
                    1316,
                    1318,
                    967
                ],
                "right.shape": [
                    969,
                    1316,
                    1318,
                    967
                ],
                "zip": [
                    1907,
                    1524,
                    973
                ],
                "array_equivalent": [
                    985,
                    975
                ],
                "strict_nan": [
                    985,
                    975
                ],
                "left.size": [
                    978
                ],
                "_raise": [
                    986
                ],
                "ExtensionArray": [
                    1018,
                    1019,
                    1406
                ],
                "hasattr": [
                    2271,
                    1023
                ],
                "np.asarray": [
                    1026,
                    1029,
                    1030,
                    1033,
                    1034
                ],
                "left.asi8": [
                    1026
                ],
                "right.asi8": [
                    1026
                ],
                "left_na": [
                    1033,
                    1029,
                    1031
                ],
                "left.isna": [
                    1029
                ],
                "right_na": [
                    1034,
                    1030,
                    1031
                ],
                "right.isna": [
                    1030
                ],
                "left_valid": [
                    1033,
                    1036,
                    1039
                ],
                "object": [
                    1033,
                    1034,
                    1753
                ],
                "right_valid": [
                    1040,
                    1034,
                    1036
                ],
                "check_series_type": [
                    1107
                ],
                "left.index": [
                    1112,
                    1326,
                    1118
                ],
                "right.index": [
                    1113,
                    1327,
                    1119
                ],
                "check_index_type": [
                    1120,
                    1369,
                    1328
                ],
                "left.dtype": [
                    1163,
                    1165,
                    1133,
                    1173,
                    1142,
                    1175,
                    1149
                ],
                "right.dtype": [
                    1163,
                    1165,
                    1134,
                    1173,
                    1175,
                    1149
                ],
                "is_numeric_dtype": [
                    1142
                ],
                "check_datetimelike_compat": [
                    1148,
                    1373
                ],
                "needs_i8_conversion": [
                    1149,
                    1175
                ],
                "equals": [
                    1157
                ],
                "is_interval_dtype": [
                    1163
                ],
                "left.array": [
                    1164
                ],
                "right.array": [
                    1164
                ],
                "is_extension_array_dtype": [
                    1173
                ],
                "assert_extension_array_equal": [
                    1177,
                    1174,
                    1407
                ],
                "DataFrame": [
                    2025,
                    1808,
                    2545,
                    1813,
                    1786,
                    1309,
                    1791
                ],
                "check_frame_type": [
                    1311
                ],
                "check_like": [
                    1321
                ],
                "left.reindex_like": [
                    1322
                ],
                "left.columns": [
                    1361,
                    1338
                ],
                "right.columns": [
                    1339
                ],
                "check_column_type": [
                    1340
                ],
                "by_blocks": [
                    1349
                ],
                "rblocks": [
                    1352,
                    1354,
                    1356,
                    1350
                ],
                "right._to_dict_of_blocks": [
                    1350
                ],
                "lblocks": [
                    1352,
                    1353,
                    1356,
                    1351
                ],
                "left._to_dict_of_blocks": [
                    1351
                ],
                "set": [
                    1352
                ],
                "lblocks.keys": [
                    1352
                ],
                "rblocks.keys": [
                    1352
                ],
                "i": [
                    1889,
                    2051,
                    2052,
                    1573,
                    2057,
                    1898,
                    2058,
                    1901,
                    1902,
                    1361,
                    1363,
                    1364,
                    2515,
                    2519,
                    2520,
                    1851,
                    1375
                ],
                "col": [
                    1361,
                    1362,
                    1375
                ],
                "enumerate": [
                    1361
                ],
                "lcol": [
                    1363,
                    1366
                ],
                "left.iloc": [
                    1363
                ],
                "rcol": [
                    1364,
                    1367
                ],
                "right.iloc": [
                    1364
                ],
                "assert_period_array_equal": [
                    1401
                ],
                "assert_datetime_array_equal": [
                    1403
                ],
                "assert_timedelta_array_equal": [
                    1405
                ],
                "NotImplementedError": [
                    1453,
                    1414
                ],
                "box_cls": [
                    1441,
                    1444,
                    1446,
                    1448,
                    1450,
                    1453,
                    1430,
                    1432,
                    1434
                ],
                "expected": [
                    1440,
                    2656,
                    1443,
                    1445,
                    1447,
                    1449,
                    1451,
                    1454,
                    1431,
                    1433,
                    1435,
                    2655
                ],
                "to_frame": [
                    1435
                ],
                "transpose": [
                    1436
                ],
                "expected.T": [
                    1440
                ],
                "period_array": [
                    1443,
                    1460
                ],
                "to_array": [
                    1450,
                    1451
                ],
                "is_period_dtype": [
                    1459
                ],
                "is_datetime64_dtype": [
                    1461
                ],
                "is_datetime64tz_dtype": [
                    1461
                ],
                "DatetimeArray._from_sequence": [
                    1462
                ],
                "is_timedelta64_dtype": [
                    1463
                ],
                "TimedeltaArray._from_sequence": [
                    1464
                ],
                "pd.arrays.SparseArray": [
                    1482
                ],
                "pd.arrays": [
                    1482
                ],
                "left.sp_values": [
                    1484
                ],
                "right.sp_values": [
                    1484
                ],
                "left.sp_index": [
                    1490,
                    1487
                ],
                "pd._libs.sparse.SparseIndex": [
                    1488,
                    1487
                ],
                "pd._libs.sparse": [
                    1488,
                    1487
                ],
                "pd._libs": [
                    1488,
                    1487
                ],
                "right.sp_index": [
                    1488,
                    1491
                ],
                "left_index": [
                    1490,
                    1493,
                    1495
                ],
                "right_index": [
                    1491,
                    1493,
                    1495
                ],
                "left_index.equals": [
                    1493
                ],
                "left.to_dense": [
                    1503
                ],
                "right.to_dense": [
                    1503
                ],
                "k": [
                    1539,
                    1543,
                    1550,
                    1556,
                    1561,
                    1563,
                    1565,
                    1569,
                    1573,
                    1577,
                    1581,
                    1709,
                    1587,
                    1592,
                    1597,
                    1737,
                    1511,
                    1512,
                    1534
                ],
                "iterable": [
                    1511
                ],
                "dic": [
                    1512
                ],
                "elem1": [
                    1530,
                    1524,
                    1525,
                    1527
                ],
                "elem2": [
                    1530,
                    1524,
                    1525,
                    1527
                ],
                "iter1": [
                    1524
                ],
                "iter2": [
                    1524
                ],
                "assert_almost_equal": [
                    1525
                ],
                "eql_kwargs": [
                    1525
                ],
                "string.ascii_uppercase": [
                    1534
                ],
                "rands_array": [
                    1539,
                    1548
                ],
                "name": [
                    1539,
                    1543,
                    1550,
                    1557,
                    1562,
                    1564,
                    1565,
                    2460,
                    2463,
                    1569,
                    2465,
                    1573,
                    1577,
                    1582,
                    1587,
                    1588,
                    1592,
                    1597,
                    1743,
                    1748,
                    1755,
                    1766,
                    1772,
                    1914,
                    1915
                ],
                "randu_array": [
                    1543
                ],
                "n": [
                    1672,
                    1675,
                    1676,
                    1548,
                    1550,
                    1677,
                    1678
                ],
                "CategoricalIndex": [
                    1549
                ],
                "Categorical.from_codes": [
                    1550
                ],
                "np.arange": [
                    1550
                ],
                "np.linspace": [
                    1556
                ],
                "IntervalIndex.from_breaks": [
                    1557
                ],
                "IntervalIndex": [
                    1557
                ],
                "RangeIndex": [
                    1577
                ],
                "sorted": [
                    1680,
                    1904,
                    1581
                ],
                "np.random.random_sample": [
                    1581
                ],
                "np.random.randint": [
                    1582
                ],
                "dt": [
                    1586,
                    1587,
                    1596,
                    1597
                ],
                "datetime": [
                    1586,
                    1596
                ],
                "dr": [
                    1587,
                    1588,
                    1597,
                    1598
                ],
                "bdate_range": [
                    1801,
                    1587
                ],
                "freq": [
                    1766,
                    1671,
                    1776,
                    1587,
                    1592,
                    1785
                ],
                "DatetimeIndex": [
                    1588
                ],
                "pd.timedelta_range": [
                    1592
                ],
                "pd.period_range": [
                    1597
                ],
                "MultiIndex.from_product": [
                    1602
                ],
                "names": [
                    1857,
                    1602,
                    1858,
                    1873,
                    1874,
                    1844,
                    1912,
                    1849,
                    1914,
                    1851,
                    1852,
                    1917,
                    1854
                ],
                "_names": [
                    1675,
                    1605
                ],
                "pd.date_range": [
                    1671
                ],
                "start": [
                    1671
                ],
                "end": [
                    1681,
                    1671
                ],
                "state": [
                    1673,
                    1675,
                    1676,
                    1677,
                    1678
                ],
                "np.random.RandomState": [
                    2032,
                    1673
                ],
                "seed": [
                    2424,
                    1673
                ],
                "columns": [
                    1680,
                    2002,
                    1674,
                    2025
                ],
                "state.choice": [
                    1675
                ],
                "state.poisson": [
                    1676
                ],
                "state.rand": [
                    1677,
                    1678
                ],
                "df": [
                    2056,
                    2057,
                    2058,
                    2059,
                    1680,
                    1681,
                    1682,
                    1683
                ],
                "df.index": [
                    1681
                ],
                "df.iloc": [
                    1682
                ],
                "all_make_index_funcs": [
                    1708,
                    1695
                ],
                "makeIntIndex": [
                    1696,
                    1862
                ],
                "makeFloatIndex": [
                    1697,
                    1863
                ],
                "makeStringIndex": [
                    1698,
                    1864,
                    1742,
                    1747,
                    1752,
                    1754,
                    1759
                ],
                "makeUnicodeIndex": [
                    1865,
                    1699
                ],
                "makeDateIndex": [
                    1700,
                    1766,
                    1735,
                    1866,
                    1714
                ],
                "makePeriodIndex": [
                    1701,
                    1735,
                    1868,
                    1772,
                    1715
                ],
                "makeTimedeltaIndex": [
                    1867,
                    1716,
                    1702,
                    1735
                ],
                "makeBoolIndex": [
                    1703
                ],
                "makeRangeIndex": [
                    1704,
                    1717
                ],
                "makeIntervalIndex": [
                    1705,
                    1718
                ],
                "makeCategoricalIndex": [
                    1706,
                    1719
                ],
                "make_index_func": [
                    1736,
                    1737,
                    1708,
                    1709,
                    1722,
                    1723
                ],
                "make_index_funcs": [
                    1736,
                    1713,
                    1722,
                    1735
                ],
                "makeMultiIndex": [
                    1720
                ],
                "randn": [
                    1760,
                    1766,
                    1772,
                    1743,
                    1748
                ],
                "c": [
                    1760,
                    2021,
                    2023,
                    1776,
                    1780
                ],
                "getCols": [
                    1760,
                    1776,
                    1780
                ],
                "nper": [
                    1764,
                    1765,
                    1766,
                    1770,
                    1771,
                    1772,
                    1776,
                    1780,
                    1812,
                    1785
                ],
                "makeTimeSeries": [
                    1776
                ],
                "makePeriodSeries": [
                    1780
                ],
                "getTimeSeriesData": [
                    1785
                ],
                "getSeriesData": [
                    1790
                ],
                "getMixedTypeDict": [
                    1808
                ],
                "getPeriodData": [
                    1812
                ],
                "ndupe_l": [
                    1898,
                    1902,
                    1841,
                    1842,
                    1843,
                    1882,
                    1883,
                    1884,
                    1886
                ],
                "nlevels": [
                    1857,
                    1883,
                    1889,
                    1842,
                    1843,
                    1844,
                    1846,
                    1913,
                    1882,
                    1851,
                    1884
                ],
                "is_sequence": [
                    1843
                ],
                "idx_type": [
                    1869,
                    1876,
                    1845,
                    1878,
                    1846
                ],
                "prefix": [
                    1851,
                    1901
                ],
                "idx_func": [
                    1861,
                    1870,
                    1871
                ],
                "get": [
                    1861
                ],
                "idx": [
                    1874,
                    1875,
                    1871
                ],
                "nentries": [
                    1904,
                    1898,
                    1910,
                    1871
                ],
                "idx.name": [
                    1874
                ],
                "ndupe_l.extend": [
                    1883
                ],
                "all": [
                    1886
                ],
                "tuples": [
                    1888,
                    1905,
                    1907,
                    1912,
                    1915,
                    1917
                ],
                "numeric_tuple": [
                    1894,
                    1895
                ],
                "split": [
                    1894
                ],
                "re.sub": [
                    1894
                ],
                "re": [
                    1894
                ],
                "num": [
                    1895
                ],
                "div_factor": [
                    1898,
                    1900
                ],
                "cnt": [
                    1904,
                    1899,
                    1902
                ],
                "Counter": [
                    1899
                ],
                "j": [
                    2050,
                    2051,
                    2052,
                    2057,
                    2058,
                    1900,
                    1901
                ],
                "label": [
                    1901,
                    1902
                ],
                "cnt.elements": [
                    1904
                ],
                "keyfunc": [
                    1904
                ],
                "tuples.append": [
                    1905
                ],
                "MultiIndex.from_tuples": [
                    1917
                ],
                "c_idx_nlevels": [
                    1993,
                    2004,
                    1999
                ],
                "r_idx_nlevels": [
                    1994,
                    2012,
                    1996
                ],
                "r_idx_type": [
                    2016,
                    1995,
                    1996
                ],
                "c_idx_type": [
                    2008,
                    1998,
                    1999
                ],
                "makeCustomIndex": [
                    2010,
                    2002
                ],
                "ncols": [
                    2043,
                    2003,
                    2035,
                    2023
                ],
                "c_idx_names": [
                    2006
                ],
                "c_ndupe_l": [
                    2007
                ],
                "nrows": [
                    2050,
                    2051,
                    2011,
                    2023,
                    2035,
                    2043
                ],
                "r_idx_names": [
                    2014
                ],
                "r_ndupe_l": [
                    2015
                ],
                "data_gen_f": [
                    2020,
                    2021,
                    2023
                ],
                "random_state": [
                    2048,
                    2057,
                    2029,
                    2030,
                    2032,
                    2045
                ],
                "density": [
                    2057,
                    2035
                ],
                "min_rows": [
                    2037,
                    2039
                ],
                "fac": [
                    2038,
                    2039
                ],
                "extra_size": [
                    2048,
                    2047,
                    2045,
                    2039
                ],
                "min": [
                    2039
                ],
                "ind": [
                    2048,
                    2050,
                    2051,
                    2042,
                    2043,
                    2045,
                    2046
                ],
                "rng.rand": [
                    2042
                ],
                "rng": [
                    2042
                ],
                "_extra_size": [
                    2042
                ],
                "np.unique": [
                    2043
                ],
                "np.floor": [
                    2050,
                    2043
                ],
                "_gen_unique_rand": [
                    2048,
                    2045
                ],
                "ind.size": [
                    2046
                ],
                "i.tolist": [
                    2052
                ],
                "j.tolist": [
                    2052
                ],
                "makeDataFrame": [
                    2056
                ],
                "_create_missing_idx": [
                    2057
                ],
                "df.shape": [
                    2057
                ],
                "df.values": [
                    2058
                ],
                "np.nan": [
                    2632,
                    2058
                ],
                "decorator": [
                    2074,
                    2077
                ],
                "is_decorating": [
                    2080,
                    2079
                ],
                "callable": [
                    2079
                ],
                "dec": [
                    2083,
                    2085
                ],
                "wraps": [
                    2512,
                    2074,
                    2262
                ],
                "wrapper": [
                    2530,
                    2292,
                    2087
                ],
                "_network_error_messages": [
                    2171,
                    2091
                ],
                "_network_errno_vals": [
                    2170,
                    2111
                ],
                "IOError": [
                    2132
                ],
                "http.client.HTTPException": [
                    2132
                ],
                "http.client": [
                    2132
                ],
                "http": [
                    2132
                ],
                "TimeoutError": [
                    2132
                ],
                "error_classes": [
                    2151,
                    2152,
                    2284,
                    2157,
                    2287,
                    2257,
                    2258,
                    2265
                ],
                "_get_default_network_errors": [
                    2152,
                    2258
                ],
                "urlopen": [
                    2155
                ],
                "url": [
                    2265,
                    2155,
                    2287
                ],
                "t.network": [
                    2260
                ],
                "t": [
                    2268,
                    2260,
                    2262
                ],
                "check_before_test": [
                    2264
                ],
                "raise_on_error": [
                    2264,
                    2287
                ],
                "can_connect": [
                    2265,
                    2287
                ],
                "skip": [
                    2280,
                    2266,
                    2275,
                    2290
                ],
                "Exception": [
                    2661,
                    2660,
                    2269
                ],
                "errno": [
                    2272,
                    2274,
                    2270,
                    2271
                ],
                "err": [
                    2272,
                    2275,
                    2277,
                    2281,
                    2284,
                    2290,
                    2270
                ],
                "err.reason": [
                    2272
                ],
                "skip_errnos": [
                    2274
                ],
                "e_str": [
                    2277,
                    2279
                ],
                "any": [
                    2279
                ],
                "m.lower": [
                    2279
                ],
                "m": [
                    2279
                ],
                "e_str.lower": [
                    2279
                ],
                "_skip_on_messages": [
                    2279
                ],
                "optional_args": [
                    2163
                ],
                "with_connectivity_check": [
                    2295
                ],
                "network": [
                    2295
                ],
                "Warning": [
                    2300
                ],
                "warnings.catch_warnings": [
                    2361
                ],
                "w": [
                    2368,
                    2361,
                    2365
                ],
                "saw_warning": [
                    2400,
                    2363,
                    2372
                ],
                "filter_level": [
                    2364
                ],
                "extra_warnings": [
                    2401,
                    2403,
                    2387,
                    2366
                ],
                "actual_warning": [
                    2368,
                    2370,
                    2375,
                    2382,
                    2383,
                    2385,
                    2389,
                    2390,
                    2391,
                    2392
                ],
                "expected_warning": [
                    2369,
                    2370,
                    2395,
                    2398
                ],
                "issubclass": [
                    2369,
                    2374
                ],
                "actual_warning.category": [
                    2370,
                    2389,
                    2375
                ],
                "check_stacklevel": [
                    2374
                ],
                "FutureWarning": [
                    2375
                ],
                "caller": [
                    2385,
                    2379,
                    2383
                ],
                "getframeinfo": [
                    2379
                ],
                "stack": [
                    2379
                ],
                "actual_warning.filename": [
                    2385,
                    2382,
                    2391
                ],
                "caller.filename": [
                    2385,
                    2383
                ],
                "actual_warning.message": [
                    2390,
                    2383
                ],
                "extra_warnings.append": [
                    2387
                ],
                "actual_warning.category.__name__": [
                    2389
                ],
                "actual_warning.lineno": [
                    2392
                ],
                "expected_warning.__name__": [
                    2398
                ],
                "raise_on_extra_warnings": [
                    2401
                ],
                "self.seed": [
                    2424,
                    2429
                ],
                "self": [
                    2424,
                    2433,
                    2428,
                    2429
                ],
                "self.start_state": [
                    2433,
                    2428
                ],
                "np.random.get_state": [
                    2428
                ],
                "np.random.seed": [
                    2429
                ],
                "np.random.set_state": [
                    2433
                ],
                "_BUILTIN_DIALECTS": [
                    2458,
                    2460
                ],
                "csv.register_dialect": [
                    2463
                ],
                "csv": [
                    2465,
                    2463
                ],
                "csv.unregister_dialect": [
                    2465
                ],
                "min_elements": [
                    2472,
                    2473,
                    2478
                ],
                "expr._MIN_ELEMENTS": [
                    2480,
                    2473,
                    2476,
                    2478
                ],
                "expr": [
                    2473,
                    2475,
                    2476,
                    2477,
                    2478,
                    2480,
                    2481
                ],
                "olduse": [
                    2481,
                    2475
                ],
                "expr._USE_NUMEXPR": [
                    2475
                ],
                "oldmin": [
                    2480,
                    2476
                ],
                "expr.set_use_numexpr": [
                    2481,
                    2477
                ],
                "use": [
                    2477
                ],
                "num_threads": [
                    2505,
                    2508,
                    2519
                ],
                "has_kwargs_list": [
                    2514,
                    2506,
                    2507
                ],
                "kwargs_list": [
                    2506,
                    2515,
                    2508
                ],
                "update_kwargs": [
                    2520,
                    2515,
                    2517
                ],
                "threads": [
                    2522,
                    2523,
                    2525,
                    2518
                ],
                "updated_kwargs": [
                    2520,
                    2521
                ],
                "thread": [
                    2521,
                    2522,
                    2523,
                    2524,
                    2525,
                    2526
                ],
                "threading.Thread": [
                    2521
                ],
                "threading": [
                    2521
                ],
                "func": [
                    2512,
                    2521
                ],
                "threads.append": [
                    2522
                ],
                "thread.start": [
                    2524
                ],
                "thread.join": [
                    2526
                ],
                "inner": [
                    2528
                ],
                "_metadata": [
                    2546,
                    2534
                ],
                "SubclassedSeries": [
                    2538,
                    2554
                ],
                "property": [
                    2536,
                    2540,
                    2548,
                    2552,
                    2558
                ],
                "SubclassedDataFrame": [
                    2550,
                    2542
                ],
                "SubclassedCategorical": [
                    2560
                ],
                "tz": [
                    2595,
                    2589,
                    2599
                ],
                "KeyError": [
                    2592
                ],
                "time.tzset": [
                    2596
                ],
                "time": [
                    2596
                ],
                "orig_tz": [
                    2603,
                    2598
                ],
                "setTZ": [
                    2603,
                    2599
                ],
                "skipna_alternative": [
                    2625,
                    2622
                ],
                "x.values": [
                    2625
                ],
                "nona": [
                    2633,
                    2630,
                    2631
                ],
                "x.dropna": [
                    2630
                ],
                "alternative": [
                    2633
                ],
                "skipna_wrapper": [
                    2635
                ],
                "List": [
                    2638
                ],
                "sep": [
                    2654,
                    2655
                ],
                "os.linesep": [
                    2654
                ],
                "sep.join": [
                    2655
                ],
                "rows_list": [
                    2655
                ],
                "Type": [
                    2660,
                    2661
                ],
                "pytest.raises": [
                    2677
                ],
                "expected_exception": [
                    2677
                ],
                "Callable": [
                    2661
                ]
            },
            "filtered_variables_in_file": {
                "lzma": [
                    212,
                    70,
                    263
                ],
                "_import_lzma": [
                    70
                ],
                "_N": [
                    1760,
                    1765,
                    72,
                    1771,
                    1742,
                    1743,
                    1747,
                    1748,
                    1752,
                    1754,
                    1759
                ],
                "_K": [
                    1760,
                    73,
                    1776,
                    1780
                ],
                "_RAISE_NETWORK_ERROR_DEFAULT": [
                    74,
                    2167
                ],
                "_testing_mode_warnings": [
                    91,
                    84,
                    77
                ],
                "testing_mode": [
                    89,
                    82,
                    83,
                    90
                ],
                "os.environ.get": [
                    89,
                    82,
                    2598
                ],
                "os.environ": [
                    2595,
                    549,
                    2598,
                    553,
                    554,
                    82,
                    89,
                    2591
                ],
                "os": [
                    512,
                    2595,
                    516,
                    517,
                    549,
                    2598,
                    553,
                    554,
                    82,
                    498,
                    89,
                    2654,
                    2591
                ],
                "warnings.simplefilter": [
                    91,
                    84,
                    2364
                ],
                "warnings": [
                    2361,
                    91,
                    84,
                    2364
                ],
                "set_testing_mode": [
                    94
                ],
                "pd.reset_option": [
                    101
                ],
                "pd": [
                    774,
                    1671,
                    1680,
                    1430,
                    1431,
                    1432,
                    1433,
                    1434,
                    1435,
                    690,
                    692,
                    312,
                    1592,
                    1597,
                    322,
                    1482,
                    332,
                    1487,
                    1488,
                    101,
                    1392,
                    1394,
                    1396,
                    126,
                    127
                ],
                "Any": [
                    105
                ],
                "Optional": [
                    105,
                    130,
                    159
                ],
                "FilePathOrBuffer": [
                    105
                ],
                "_path": [
                    122,
                    123,
                    124,
                    125
                ],
                "path": [
                    154,
                    276,
                    206,
                    219,
                    208,
                    210,
                    180,
                    181,
                    182,
                    151,
                    152,
                    153,
                    122,
                    155,
                    184,
                    212,
                    183,
                    214
                ],
                "rands": [
                    124
                ],
                "ensure_clean": [
                    153,
                    125,
                    182
                ],
                "temp_path": [
                    125,
                    126,
                    127
                ],
                "pd.to_pickle": [
                    126
                ],
                "obj": [
                    768,
                    642,
                    645,
                    1146,
                    1375,
                    904,
                    1171,
                    155,
                    668,
                    156,
                    1184,
                    674,
                    675,
                    1189,
                    1318,
                    682,
                    1196,
                    689,
                    691,
                    948,
                    1333,
                    822,
                    1459,
                    184,
                    185,
                    697,
                    824,
                    953,
                    1460,
                    1461,
                    1462,
                    1463,
                    1345,
                    834,
                    1466,
                    1464,
                    839,
                    969,
                    842,
                    1356,
                    718,
                    719,
                    722,
                    723,
                    979,
                    980,
                    1108,
                    1114,
                    990,
                    607,
                    863,
                    353,
                    864,
                    355,
                    356,
                    611,
                    865,
                    871,
                    872,
                    617,
                    1125,
                    879,
                    880,
                    881,
                    887,
                    1139,
                    631,
                    888,
                    126,
                    635,
                    638
                ],
                "pd.read_pickle": [
                    127
                ],
                "FrameOrSeries": [
                    106
                ],
                "Path": [
                    154,
                    155,
                    150
                ],
                "pytest.importorskip": [
                    179,
                    150
                ],
                "pytest": [
                    506,
                    179,
                    2677,
                    150
                ],
                "writer": [
                    154,
                    183
                ],
                "reader": [
                    184,
                    155
                ],
                "LocalPath": [
                    184,
                    179,
                    183
                ],
                "local": [
                    179
                ],
                "compression": [
                    258,
                    227,
                    262,
                    265,
                    267,
                    205,
                    207,
                    209,
                    211,
                    213,
                    250,
                    221,
                    254
                ],
                "f": [
                    224,
                    2081,
                    226,
                    2083,
                    490,
                    493,
                    206,
                    495,
                    208,
                    210,
                    212,
                    276,
                    277,
                    217,
                    2077
                ],
                "gzip.open": [
                    208
                ],
                "gzip": [
                    208,
                    257
                ],
                "bz2.BZ2File": [
                    210,
                    261
                ],
                "bz2": [
                    210,
                    261
                ],
                "_get_lzma_file": [
                    212,
                    263
                ],
                "zip_file": [
                    217,
                    228,
                    214,
                    215
                ],
                "zipfile.ZipFile": [
                    253,
                    214
                ],
                "zipfile": [
                    253,
                    214
                ],
                "zip_names": [
                    216,
                    217,
                    215
                ],
                "zip_file.namelist": [
                    215
                ],
                "zip_file.open": [
                    217
                ],
                "zip_names.pop": [
                    217
                ],
                "f.close": [
                    226,
                    495
                ],
                "zip_file.close": [
                    228
                ],
                "contextmanager": [
                    2563,
                    2436,
                    2468,
                    522,
                    459,
                    2298,
                    188,
                    541
                ],
                "compress_method": [
                    257,
                    261,
                    263,
                    276,
                    253
                ],
                "gzip.GzipFile": [
                    257
                ],
                "mode": [
                    272,
                    268,
                    276
                ],
                "args": [
                    2081,
                    2082,
                    269,
                    273,
                    277,
                    2521,
                    2268,
                    2077,
                    2079
                ],
                "dest": [
                    269
                ],
                "data": [
                    1797,
                    2023,
                    2025,
                    1804,
                    269,
                    273,
                    1812,
                    1785,
                    1813,
                    1752,
                    1753,
                    1786,
                    1755,
                    1790,
                    1791
                ],
                "method": [
                    274,
                    277,
                    270
                ],
                "Union": [
                    283,
                    284,
                    571,
                    700,
                    573
                ],
                "left": [
                    1026,
                    1029,
                    1033,
                    1105,
                    1108,
                    1111,
                    1112,
                    1118,
                    1133,
                    1139,
                    628,
                    1142,
                    631,
                    634,
                    1146,
                    636,
                    1149,
                    641,
                    643,
                    1157,
                    1159,
                    648,
                    649,
                    1163,
                    652,
                    1164,
                    654,
                    1165,
                    1167,
                    1173,
                    1174,
                    1175,
                    1177,
                    668,
                    1180,
                    672,
                    673,
                    675,
                    1189,
                    678,
                    1192,
                    1194,
                    683,
                    689,
                    690,
                    691,
                    692,
                    693,
                    696,
                    697,
                    714,
                    716,
                    719,
                    721,
                    723,
                    742,
                    1309,
                    1312,
                    1316,
                    1318,
                    1322,
                    1326,
                    819,
                    822,
                    312,
                    824,
                    314,
                    1338,
                    828,
                    832,
                    322,
                    324,
                    837,
                    1351,
                    842,
                    332,
                    334,
                    1361,
                    1363,
                    345,
                    348,
                    861,
                    863,
                    352,
                    864,
                    865,
                    356,
                    869,
                    358,
                    871,
                    872,
                    877,
                    879,
                    880,
                    881,
                    1392,
                    1393,
                    1394,
                    1395,
                    886,
                    887,
                    888,
                    1396,
                    1397,
                    1398,
                    1399,
                    1400,
                    894,
                    895,
                    384,
                    896,
                    386,
                    897,
                    1403,
                    1404,
                    1405,
                    1406,
                    1407,
                    1401,
                    1409,
                    907,
                    396,
                    397,
                    1402,
                    1414,
                    1408,
                    948,
                    950,
                    1410,
                    955,
                    1412,
                    967,
                    969,
                    1482,
                    1484,
                    973,
                    1487,
                    978,
                    1490,
                    980,
                    985,
                    986,
                    989,
                    990,
                    1501,
                    1502,
                    1503,
                    1018,
                    1021,
                    1023
                ],
                "pd.Index": [
                    312,
                    1392,
                    1430,
                    1431
                ],
                "assert_index_equal": [
                    864,
                    833,
                    836,
                    1337,
                    1325,
                    1393,
                    658,
                    822,
                    313,
                    1117,
                    863
                ],
                "right": [
                    1026,
                    1030,
                    1034,
                    1105,
                    1108,
                    1111,
                    1113,
                    1119,
                    1134,
                    1139,
                    628,
                    631,
                    634,
                    1146,
                    637,
                    1149,
                    641,
                    644,
                    1157,
                    1160,
                    650,
                    1163,
                    1164,
                    1165,
                    655,
                    1168,
                    1173,
                    1174,
                    1175,
                    1177,
                    668,
                    1181,
                    672,
                    673,
                    675,
                    1189,
                    679,
                    1192,
                    1195,
                    684,
                    689,
                    690,
                    691,
                    692,
                    693,
                    696,
                    697,
                    714,
                    716,
                    719,
                    721,
                    723,
                    743,
                    1309,
                    1312,
                    1316,
                    1318,
                    1322,
                    1327,
                    819,
                    822,
                    824,
                    315,
                    1339,
                    829,
                    832,
                    325,
                    838,
                    1350,
                    842,
                    335,
                    1362,
                    1364,
                    345,
                    348,
                    861,
                    863,
                    352,
                    864,
                    865,
                    356,
                    869,
                    359,
                    871,
                    872,
                    877,
                    879,
                    880,
                    881,
                    1393,
                    1395,
                    1397,
                    886,
                    887,
                    888,
                    1399,
                    1401,
                    1403,
                    1405,
                    1407,
                    1409,
                    899,
                    388,
                    900,
                    390,
                    901,
                    902,
                    1412,
                    396,
                    397,
                    908,
                    948,
                    950,
                    956,
                    967,
                    969,
                    1482,
                    1484,
                    973,
                    1488,
                    1491,
                    980,
                    985,
                    986,
                    989,
                    990,
                    1501,
                    1502,
                    1503,
                    1019,
                    1021,
                    1023
                ],
                "check_dtype": [
                    1368,
                    327,
                    360,
                    1128,
                    1020,
                    1356,
                    337,
                    824,
                    1041,
                    1170,
                    344,
                    1146,
                    988,
                    317,
                    1183
                ],
                "check_less_precise": [
                    1342,
                    1122,
                    328,
                    361,
                    680,
                    1169,
                    338,
                    1042,
                    1330,
                    663,
                    1370,
                    1182,
                    318
                ],
                "kwargs": [
                    1409,
                    1411,
                    1550,
                    1557,
                    2077,
                    2079,
                    2463,
                    1577,
                    1588,
                    1592,
                    1597,
                    319,
                    1602,
                    329,
                    339,
                    2515,
                    2517,
                    2268,
                    487,
                    362,
                    490,
                    1393,
                    1395,
                    1397,
                    502,
                    1399,
                    1401,
                    1403,
                    1405,
                    1407
                ],
                "pd.Series": [
                    322,
                    774,
                    1394,
                    1432,
                    1433,
                    1435
                ],
                "assert_series_equal": [
                    1395,
                    323,
                    1365
                ],
                "pd.DataFrame": [
                    1396,
                    1434,
                    332,
                    1680
                ],
                "assert_frame_equal": [
                    1397,
                    1355,
                    333
                ],
                "is_number": [
                    345,
                    748,
                    750
                ],
                "is_bool": [
                    348
                ],
                "np.ndarray": [
                    352,
                    1408,
                    899,
                    774,
                    1448,
                    950,
                    989,
                    894
                ],
                "np": [
                    1408,
                    2433,
                    1026,
                    899,
                    2050,
                    1029,
                    774,
                    1030,
                    1033,
                    1034,
                    1673,
                    2058,
                    1550,
                    404,
                    405,
                    1556,
                    407,
                    795,
                    416,
                    417,
                    673,
                    674,
                    1448,
                    1449,
                    428,
                    429,
                    1581,
                    1582,
                    950,
                    442,
                    1466,
                    2632,
                    979,
                    989,
                    352,
                    749,
                    2030,
                    751,
                    2032,
                    2035,
                    2043,
                    2428,
                    2429,
                    894
                ],
                "assert_class_equal": [
                    948,
                    356,
                    1108,
                    607
                ],
                "_testing.assert_almost_equal": [
                    357,
                    677,
                    1166,
                    1038,
                    1179
                ],
                "_testing": [
                    357,
                    677,
                    397,
                    1038,
                    1166,
                    1179
                ],
                "cls_name": [
                    386,
                    390,
                    382
                ],
                "cls.__name__": [
                    382
                ],
                "cls": [
                    384,
                    386,
                    388,
                    390,
                    382
                ],
                "_check_isinstance": [
                    869,
                    1482,
                    396,
                    877,
                    1105,
                    819,
                    628,
                    886,
                    950,
                    1309,
                    861
                ],
                "_testing.assert_dict_equal": [
                    397
                ],
                "compare_keys": [
                    397
                ],
                "rand": [
                    401
                ],
                "size": [
                    416,
                    418,
                    428,
                    430,
                    401,
                    2035,
                    2039,
                    2043,
                    2046
                ],
                "p": [
                    401
                ],
                "RANDS_CHARS": [
                    416,
                    442,
                    404
                ],
                "np.array": [
                    1449,
                    404,
                    405,
                    1466,
                    795
                ],
                "string.ascii_letters": [
                    404
                ],
                "string": [
                    1534,
                    404,
                    406
                ],
                "string.digits": [
                    404,
                    406
                ],
                "np.str_": [
                    417,
                    404
                ],
                "RANDU_CHARS": [
                    428,
                    405
                ],
                "join": [
                    442,
                    406
                ],
                "np.unicode_": [
                    429,
                    407
                ],
                "retval": [
                    432,
                    427,
                    420,
                    415
                ],
                "reshape": [
                    416,
                    428
                ],
                "view": [
                    416,
                    428
                ],
                "np.random.choice": [
                    416,
                    442,
                    428
                ],
                "np.random": [
                    416,
                    2433,
                    1673,
                    428,
                    1581,
                    1582,
                    2030,
                    2032,
                    442,
                    2428,
                    2429
                ],
                "nchars": [
                    416,
                    417,
                    428,
                    429,
                    442
                ],
                "np.prod": [
                    416,
                    428
                ],
                "retval.astype": [
                    432,
                    420
                ],
                "dtype": [
                    420,
                    1352,
                    1353,
                    1354,
                    2025,
                    1356,
                    432
                ],
                "fignum": [
                    448,
                    449,
                    450,
                    452
                ],
                "get_fignums": [
                    449
                ],
                "_close": [
                    450,
                    452
                ],
                "filename": [
                    514,
                    484,
                    516,
                    517,
                    487,
                    498,
                    502,
                    509
                ],
                "fd": [
                    512,
                    514,
                    485,
                    502
                ],
                "return_filelike": [
                    489
                ],
                "tempfile.TemporaryFile": [
                    490
                ],
                "tempfile": [
                    490,
                    531,
                    502
                ],
                "os.path.dirname": [
                    498
                ],
                "os.path": [
                    498,
                    516
                ],
                "tempfile.mkstemp": [
                    502
                ],
                "pytest.skip": [
                    506
                ],
                "os.close": [
                    512
                ],
                "os.path.exists": [
                    516
                ],
                "os.remove": [
                    517
                ],
                "e": [
                    519
                ],
                "directory_name": [
                    536,
                    531,
                    533
                ],
                "tempfile.mkdtemp": [
                    531
                ],
                "rmtree": [
                    536
                ],
                "saved_environ": [
                    554,
                    549
                ],
                "os.environ.clear": [
                    553
                ],
                "os.environ.update": [
                    554
                ],
                "arr1": [
                    565
                ],
                "arr2": [
                    565
                ],
                "Index": [
                    1569,
                    707,
                    1539,
                    1157,
                    1573,
                    1543,
                    1795,
                    1582,
                    1562,
                    628,
                    1753,
                    1912,
                    792,
                    569,
                    570,
                    1915,
                    1564,
                    1565
                ],
                "__tracebackhide__": [
                    704,
                    740,
                    876,
                    1102,
                    1390,
                    944,
                    885,
                    2359,
                    1306,
                    603,
                    892
                ],
                "exact": [
                    864,
                    681,
                    713,
                    720,
                    661,
                    863,
                    606,
                    607
                ],
                "l": [
                    611,
                    614,
                    617,
                    973,
                    975,
                    607
                ],
                "r": [
                    611,
                    2021,
                    615,
                    2023,
                    617,
                    973,
                    975,
                    607
                ],
                "check_categorical": [
                    1344,
                    610,
                    1124,
                    1191,
                    1135,
                    1332,
                    695,
                    1374,
                    671
                ],
                "assert_attr_equal": [
                    1501,
                    865,
                    611,
                    1189,
                    1502,
                    872,
                    617,
                    842,
                    880,
                    689,
                    881,
                    691,
                    1139,
                    888,
                    1021,
                    990
                ],
                "l.inferred_type": [
                    614
                ],
                "r.inferred_type": [
                    615
                ],
                "unique": [
                    624,
                    621,
                    623
                ],
                "index.levels": [
                    621
                ],
                "index": [
                    1795,
                    1671,
                    1672,
                    1804,
                    1680,
                    1742,
                    1743,
                    1747,
                    1748,
                    1754,
                    1755,
                    2010,
                    1759,
                    1760,
                    2025,
                    621,
                    622,
                    624,
                    1912,
                    1915,
                    1917,
                    1918
                ],
                "level": [
                    652,
                    621,
                    654,
                    622,
                    624,
                    655,
                    657,
                    668
                ],
                "level_codes": [
                    622,
                    623
                ],
                "index.codes": [
                    622
                ],
                "filled": [
                    624,
                    623
                ],
                "take_1d": [
                    623
                ],
                "unique._values": [
                    623
                ],
                "unique._na_value": [
                    623
                ],
                "values": [
                    624,
                    625,
                    1581,
                    1582
                ],
                "unique._shallow_copy": [
                    624
                ],
                "index.names": [
                    624
                ],
                "_check_types": [
                    668,
                    631
                ],
                "left.nlevels": [
                    648,
                    652,
                    634,
                    636
                ],
                "right.nlevels": [
                    634,
                    637
                ],
                "msg1": [
                    642,
                    645,
                    1112,
                    1114,
                    635,
                    638
                ],
                "msg2": [
                    643,
                    645,
                    1113,
                    1114,
                    636,
                    638
                ],
                "msg3": [
                    644,
                    637,
                    638,
                    645
                ],
                "raise_assert_detail": [
                    768,
                    675,
                    645,
                    1317,
                    968,
                    719,
                    723,
                    980,
                    1494,
                    1114,
                    638
                ],
                "cast": [
                    649,
                    650
                ],
                "MultiIndex": [
                    649,
                    650,
                    1917,
                    1602
                ],
                "llevel": [
                    659,
                    654
                ],
                "_get_ilevel_values": [
                    654,
                    655
                ],
                "rlevel": [
                    660,
                    655
                ],
                "lobj": [
                    657,
                    665
                ],
                "check_names": [
                    1121,
                    1188,
                    688,
                    1329,
                    662,
                    1372,
                    1341
                ],
                "check_exact": [
                    1123,
                    1343,
                    1035,
                    1331,
                    1141,
                    664,
                    1371,
                    671
                ],
                "left.levels": [
                    668
                ],
                "right.levels": [
                    668
                ],
                "left.equals": [
                    672
                ],
                "diff": [
                    673,
                    674,
                    972,
                    910,
                    911,
                    976,
                    978,
                    979
                ],
                "np.sum": [
                    673
                ],
                "astype": [
                    673,
                    2050,
                    2051,
                    1033,
                    1034
                ],
                "left.values": [
                    673,
                    678
                ],
                "right.values": [
                    673,
                    679
                ],
                "msg": [
                    768,
                    1158,
                    776,
                    904,
                    1162,
                    780,
                    782,
                    911,
                    913,
                    787,
                    674,
                    675,
                    2380,
                    718,
                    719,
                    2385,
                    722,
                    723,
                    979,
                    980,
                    2396,
                    2400,
                    1526,
                    1530,
                    767
                ],
                "np.round": [
                    674,
                    979,
                    2035
                ],
                "pd.PeriodIndex": [
                    690
                ],
                "pd.IntervalIndex": [
                    692
                ],
                "assert_interval_array_equal": [
                    1164,
                    693,
                    1399
                ],
                "left._values": [
                    1177,
                    1157,
                    1159,
                    1194,
                    1167,
                    693,
                    1174,
                    697,
                    1146,
                    1180
                ],
                "right._values": [
                    1177,
                    1157,
                    1160,
                    1195,
                    1168,
                    693,
                    1174,
                    697,
                    1146,
                    1181
                ],
                "is_categorical_dtype": [
                    896,
                    901,
                    1192,
                    1133,
                    1134,
                    1165,
                    696
                ],
                "assert_categorical_equal": [
                    697,
                    1193
                ],
                "x": [
                    2625,
                    707,
                    709,
                    1894,
                    711,
                    2630,
                    1548,
                    1550,
                    1556,
                    1557,
                    1915,
                    1886
                ],
                "types": [
                    716,
                    717
                ],
                "repr_class": [
                    723,
                    719
                ],
                "left_attr": [
                    768,
                    742,
                    745,
                    748,
                    749,
                    757
                ],
                "attr": [
                    767,
                    742,
                    743
                ],
                "right_attr": [
                    768,
                    743,
                    745,
                    750,
                    751,
                    757
                ],
                "np.isnan": [
                    749,
                    751
                ],
                "result": [
                    1904,
                    1905,
                    757,
                    760,
                    761,
                    762,
                    764
                ],
                "result.all": [
                    762
                ],
                "objs": [
                    785,
                    787,
                    774,
                    775
                ],
                "el": [
                    778,
                    780,
                    775
                ],
                "objs.ravel": [
                    775
                ],
                "plt.Axes": [
                    780
                ],
                "plt": [
                    787,
                    780
                ],
                "plt.Artist": [
                    787
                ],
                "seq": [
                    792,
                    793,
                    795
                ],
                "Series": [
                    1760,
                    2533,
                    1766,
                    1772,
                    1743,
                    1105,
                    1748,
                    792,
                    1755
                ],
                "seq.values": [
                    793
                ],
                "assert_numpy_array_equal": [
                    1409,
                    1026,
                    871,
                    1031,
                    1036,
                    823,
                    1484,
                    879,
                    887,
                    1145,
                    795,
                    1503
                ],
                "np.sort": [
                    795
                ],
                "Categorical": [
                    819,
                    2557,
                    1550
                ],
                "check_category_order": [
                    821,
                    1197
                ],
                "left.categories": [
                    832,
                    828,
                    837,
                    822
                ],
                "right.categories": [
                    832,
                    838,
                    829,
                    822
                ],
                "left.codes": [
                    824,
                    837
                ],
                "right.codes": [
                    824,
                    838
                ],
                "lc": [
                    832,
                    834,
                    828
                ],
                "left.categories.sort_values": [
                    828
                ],
                "rc": [
                    832,
                    834,
                    829
                ],
                "right.categories.sort_values": [
                    829
                ],
                "left.categories.take": [
                    837
                ],
                "right.categories.take": [
                    838
                ],
                "IntervalArray": [
                    861,
                    1398
                ],
                "left.left": [
                    863
                ],
                "right.left": [
                    863
                ],
                "left.right": [
                    864
                ],
                "right.right": [
                    864
                ],
                "PeriodArray": [
                    1400,
                    1441,
                    869
                ],
                "left._data": [
                    879,
                    887,
                    871
                ],
                "right._data": [
                    879,
                    887,
                    871
                ],
                "DatetimeArray": [
                    1444,
                    1445,
                    877,
                    1462,
                    1402
                ],
                "TimedeltaArray": [
                    1446,
                    1447,
                    886,
                    1464,
                    1404
                ],
                "pprint_thing": [
                    900,
                    895
                ],
                "message": [
                    906
                ],
                "obj.base": [
                    953
                ],
                "left_base": [
                    960,
                    962,
                    963,
                    955,
                    959
                ],
                "_get_base": [
                    955,
                    956
                ],
                "right_base": [
                    960,
                    962,
                    963,
                    956,
                    959
                ],
                "check_same": [
                    961,
                    958
                ],
                "err_msg": [
                    986,
                    982,
                    966
                ],
                "left.shape": [
                    969,
                    1316,
                    1318,
                    967
                ],
                "right.shape": [
                    969,
                    1316,
                    1318,
                    967
                ],
                "array_equivalent": [
                    985,
                    975
                ],
                "strict_nan": [
                    985,
                    975
                ],
                "left.size": [
                    978
                ],
                "_raise": [
                    986
                ],
                "ExtensionArray": [
                    1018,
                    1019,
                    1406
                ],
                "np.asarray": [
                    1026,
                    1029,
                    1030,
                    1033,
                    1034
                ],
                "left.asi8": [
                    1026
                ],
                "right.asi8": [
                    1026
                ],
                "left_na": [
                    1033,
                    1029,
                    1031
                ],
                "left.isna": [
                    1029
                ],
                "right_na": [
                    1034,
                    1030,
                    1031
                ],
                "right.isna": [
                    1030
                ],
                "left_valid": [
                    1033,
                    1036,
                    1039
                ],
                "right_valid": [
                    1040,
                    1034,
                    1036
                ],
                "check_series_type": [
                    1107
                ],
                "left.index": [
                    1112,
                    1326,
                    1118
                ],
                "right.index": [
                    1113,
                    1327,
                    1119
                ],
                "check_index_type": [
                    1120,
                    1369,
                    1328
                ],
                "left.dtype": [
                    1163,
                    1165,
                    1133,
                    1173,
                    1142,
                    1175,
                    1149
                ],
                "right.dtype": [
                    1163,
                    1165,
                    1134,
                    1173,
                    1175,
                    1149
                ],
                "is_numeric_dtype": [
                    1142
                ],
                "check_datetimelike_compat": [
                    1148,
                    1373
                ],
                "needs_i8_conversion": [
                    1149,
                    1175
                ],
                "equals": [
                    1157
                ],
                "is_interval_dtype": [
                    1163
                ],
                "left.array": [
                    1164
                ],
                "right.array": [
                    1164
                ],
                "is_extension_array_dtype": [
                    1173
                ],
                "assert_extension_array_equal": [
                    1177,
                    1174,
                    1407
                ],
                "DataFrame": [
                    2025,
                    1808,
                    2545,
                    1813,
                    1786,
                    1309,
                    1791
                ],
                "check_frame_type": [
                    1311
                ],
                "check_like": [
                    1321
                ],
                "left.reindex_like": [
                    1322
                ],
                "left.columns": [
                    1361,
                    1338
                ],
                "right.columns": [
                    1339
                ],
                "check_column_type": [
                    1340
                ],
                "by_blocks": [
                    1349
                ],
                "rblocks": [
                    1352,
                    1354,
                    1356,
                    1350
                ],
                "right._to_dict_of_blocks": [
                    1350
                ],
                "lblocks": [
                    1352,
                    1353,
                    1356,
                    1351
                ],
                "left._to_dict_of_blocks": [
                    1351
                ],
                "lblocks.keys": [
                    1352
                ],
                "rblocks.keys": [
                    1352
                ],
                "i": [
                    1889,
                    2051,
                    2052,
                    1573,
                    2057,
                    1898,
                    2058,
                    1901,
                    1902,
                    1361,
                    1363,
                    1364,
                    2515,
                    2519,
                    2520,
                    1851,
                    1375
                ],
                "col": [
                    1361,
                    1362,
                    1375
                ],
                "lcol": [
                    1363,
                    1366
                ],
                "left.iloc": [
                    1363
                ],
                "rcol": [
                    1364,
                    1367
                ],
                "right.iloc": [
                    1364
                ],
                "assert_period_array_equal": [
                    1401
                ],
                "assert_datetime_array_equal": [
                    1403
                ],
                "assert_timedelta_array_equal": [
                    1405
                ],
                "box_cls": [
                    1441,
                    1444,
                    1446,
                    1448,
                    1450,
                    1453,
                    1430,
                    1432,
                    1434
                ],
                "expected": [
                    1440,
                    2656,
                    1443,
                    1445,
                    1447,
                    1449,
                    1451,
                    1454,
                    1431,
                    1433,
                    1435,
                    2655
                ],
                "to_frame": [
                    1435
                ],
                "transpose": [
                    1436
                ],
                "expected.T": [
                    1440
                ],
                "period_array": [
                    1443,
                    1460
                ],
                "to_array": [
                    1450,
                    1451
                ],
                "is_period_dtype": [
                    1459
                ],
                "is_datetime64_dtype": [
                    1461
                ],
                "is_datetime64tz_dtype": [
                    1461
                ],
                "DatetimeArray._from_sequence": [
                    1462
                ],
                "is_timedelta64_dtype": [
                    1463
                ],
                "TimedeltaArray._from_sequence": [
                    1464
                ],
                "pd.arrays.SparseArray": [
                    1482
                ],
                "pd.arrays": [
                    1482
                ],
                "left.sp_values": [
                    1484
                ],
                "right.sp_values": [
                    1484
                ],
                "left.sp_index": [
                    1490,
                    1487
                ],
                "pd._libs.sparse.SparseIndex": [
                    1488,
                    1487
                ],
                "pd._libs.sparse": [
                    1488,
                    1487
                ],
                "pd._libs": [
                    1488,
                    1487
                ],
                "right.sp_index": [
                    1488,
                    1491
                ],
                "left_index": [
                    1490,
                    1493,
                    1495
                ],
                "right_index": [
                    1491,
                    1493,
                    1495
                ],
                "left_index.equals": [
                    1493
                ],
                "left.to_dense": [
                    1503
                ],
                "right.to_dense": [
                    1503
                ],
                "k": [
                    1539,
                    1543,
                    1550,
                    1556,
                    1561,
                    1563,
                    1565,
                    1569,
                    1573,
                    1577,
                    1581,
                    1709,
                    1587,
                    1592,
                    1597,
                    1737,
                    1511,
                    1512,
                    1534
                ],
                "iterable": [
                    1511
                ],
                "dic": [
                    1512
                ],
                "elem1": [
                    1530,
                    1524,
                    1525,
                    1527
                ],
                "elem2": [
                    1530,
                    1524,
                    1525,
                    1527
                ],
                "iter1": [
                    1524
                ],
                "iter2": [
                    1524
                ],
                "assert_almost_equal": [
                    1525
                ],
                "eql_kwargs": [
                    1525
                ],
                "string.ascii_uppercase": [
                    1534
                ],
                "rands_array": [
                    1539,
                    1548
                ],
                "name": [
                    1539,
                    1543,
                    1550,
                    1557,
                    1562,
                    1564,
                    1565,
                    2460,
                    2463,
                    1569,
                    2465,
                    1573,
                    1577,
                    1582,
                    1587,
                    1588,
                    1592,
                    1597,
                    1743,
                    1748,
                    1755,
                    1766,
                    1772,
                    1914,
                    1915
                ],
                "randu_array": [
                    1543
                ],
                "n": [
                    1672,
                    1675,
                    1676,
                    1548,
                    1550,
                    1677,
                    1678
                ],
                "CategoricalIndex": [
                    1549
                ],
                "Categorical.from_codes": [
                    1550
                ],
                "np.arange": [
                    1550
                ],
                "np.linspace": [
                    1556
                ],
                "IntervalIndex.from_breaks": [
                    1557
                ],
                "IntervalIndex": [
                    1557
                ],
                "RangeIndex": [
                    1577
                ],
                "np.random.random_sample": [
                    1581
                ],
                "np.random.randint": [
                    1582
                ],
                "dt": [
                    1586,
                    1587,
                    1596,
                    1597
                ],
                "datetime": [
                    1586,
                    1596
                ],
                "dr": [
                    1587,
                    1588,
                    1597,
                    1598
                ],
                "bdate_range": [
                    1801,
                    1587
                ],
                "freq": [
                    1766,
                    1671,
                    1776,
                    1587,
                    1592,
                    1785
                ],
                "DatetimeIndex": [
                    1588
                ],
                "pd.timedelta_range": [
                    1592
                ],
                "pd.period_range": [
                    1597
                ],
                "MultiIndex.from_product": [
                    1602
                ],
                "names": [
                    1857,
                    1602,
                    1858,
                    1873,
                    1874,
                    1844,
                    1912,
                    1849,
                    1914,
                    1851,
                    1852,
                    1917,
                    1854
                ],
                "_names": [
                    1675,
                    1605
                ],
                "pd.date_range": [
                    1671
                ],
                "start": [
                    1671
                ],
                "end": [
                    1681,
                    1671
                ],
                "state": [
                    1673,
                    1675,
                    1676,
                    1677,
                    1678
                ],
                "np.random.RandomState": [
                    2032,
                    1673
                ],
                "seed": [
                    2424,
                    1673
                ],
                "columns": [
                    1680,
                    2002,
                    1674,
                    2025
                ],
                "state.choice": [
                    1675
                ],
                "state.poisson": [
                    1676
                ],
                "state.rand": [
                    1677,
                    1678
                ],
                "df": [
                    2056,
                    2057,
                    2058,
                    2059,
                    1680,
                    1681,
                    1682,
                    1683
                ],
                "df.index": [
                    1681
                ],
                "df.iloc": [
                    1682
                ],
                "all_make_index_funcs": [
                    1708,
                    1695
                ],
                "makeIntIndex": [
                    1696,
                    1862
                ],
                "makeFloatIndex": [
                    1697,
                    1863
                ],
                "makeStringIndex": [
                    1698,
                    1864,
                    1742,
                    1747,
                    1752,
                    1754,
                    1759
                ],
                "makeUnicodeIndex": [
                    1865,
                    1699
                ],
                "makeDateIndex": [
                    1700,
                    1766,
                    1735,
                    1866,
                    1714
                ],
                "makePeriodIndex": [
                    1701,
                    1735,
                    1868,
                    1772,
                    1715
                ],
                "makeTimedeltaIndex": [
                    1867,
                    1716,
                    1702,
                    1735
                ],
                "makeBoolIndex": [
                    1703
                ],
                "makeRangeIndex": [
                    1704,
                    1717
                ],
                "makeIntervalIndex": [
                    1705,
                    1718
                ],
                "makeCategoricalIndex": [
                    1706,
                    1719
                ],
                "make_index_func": [
                    1736,
                    1737,
                    1708,
                    1709,
                    1722,
                    1723
                ],
                "make_index_funcs": [
                    1736,
                    1713,
                    1722,
                    1735
                ],
                "makeMultiIndex": [
                    1720
                ],
                "randn": [
                    1760,
                    1766,
                    1772,
                    1743,
                    1748
                ],
                "c": [
                    1760,
                    2021,
                    2023,
                    1776,
                    1780
                ],
                "getCols": [
                    1760,
                    1776,
                    1780
                ],
                "nper": [
                    1764,
                    1765,
                    1766,
                    1770,
                    1771,
                    1772,
                    1776,
                    1780,
                    1812,
                    1785
                ],
                "makeTimeSeries": [
                    1776
                ],
                "makePeriodSeries": [
                    1780
                ],
                "getTimeSeriesData": [
                    1785
                ],
                "getSeriesData": [
                    1790
                ],
                "getMixedTypeDict": [
                    1808
                ],
                "getPeriodData": [
                    1812
                ],
                "ndupe_l": [
                    1898,
                    1902,
                    1841,
                    1842,
                    1843,
                    1882,
                    1883,
                    1884,
                    1886
                ],
                "nlevels": [
                    1857,
                    1883,
                    1889,
                    1842,
                    1843,
                    1844,
                    1846,
                    1913,
                    1882,
                    1851,
                    1884
                ],
                "is_sequence": [
                    1843
                ],
                "idx_type": [
                    1869,
                    1876,
                    1845,
                    1878,
                    1846
                ],
                "prefix": [
                    1851,
                    1901
                ],
                "idx_func": [
                    1861,
                    1870,
                    1871
                ],
                "get": [
                    1861
                ],
                "idx": [
                    1874,
                    1875,
                    1871
                ],
                "nentries": [
                    1904,
                    1898,
                    1910,
                    1871
                ],
                "idx.name": [
                    1874
                ],
                "ndupe_l.extend": [
                    1883
                ],
                "tuples": [
                    1888,
                    1905,
                    1907,
                    1912,
                    1915,
                    1917
                ],
                "numeric_tuple": [
                    1894,
                    1895
                ],
                "split": [
                    1894
                ],
                "re.sub": [
                    1894
                ],
                "re": [
                    1894
                ],
                "num": [
                    1895
                ],
                "div_factor": [
                    1898,
                    1900
                ],
                "cnt": [
                    1904,
                    1899,
                    1902
                ],
                "Counter": [
                    1899
                ],
                "j": [
                    2050,
                    2051,
                    2052,
                    2057,
                    2058,
                    1900,
                    1901
                ],
                "label": [
                    1901,
                    1902
                ],
                "cnt.elements": [
                    1904
                ],
                "keyfunc": [
                    1904
                ],
                "tuples.append": [
                    1905
                ],
                "MultiIndex.from_tuples": [
                    1917
                ],
                "c_idx_nlevels": [
                    1993,
                    2004,
                    1999
                ],
                "r_idx_nlevels": [
                    1994,
                    2012,
                    1996
                ],
                "r_idx_type": [
                    2016,
                    1995,
                    1996
                ],
                "c_idx_type": [
                    2008,
                    1998,
                    1999
                ],
                "makeCustomIndex": [
                    2010,
                    2002
                ],
                "ncols": [
                    2043,
                    2003,
                    2035,
                    2023
                ],
                "c_idx_names": [
                    2006
                ],
                "c_ndupe_l": [
                    2007
                ],
                "nrows": [
                    2050,
                    2051,
                    2011,
                    2023,
                    2035,
                    2043
                ],
                "r_idx_names": [
                    2014
                ],
                "r_ndupe_l": [
                    2015
                ],
                "data_gen_f": [
                    2020,
                    2021,
                    2023
                ],
                "random_state": [
                    2048,
                    2057,
                    2029,
                    2030,
                    2032,
                    2045
                ],
                "density": [
                    2057,
                    2035
                ],
                "min_rows": [
                    2037,
                    2039
                ],
                "fac": [
                    2038,
                    2039
                ],
                "extra_size": [
                    2048,
                    2047,
                    2045,
                    2039
                ],
                "ind": [
                    2048,
                    2050,
                    2051,
                    2042,
                    2043,
                    2045,
                    2046
                ],
                "rng.rand": [
                    2042
                ],
                "rng": [
                    2042
                ],
                "_extra_size": [
                    2042
                ],
                "np.unique": [
                    2043
                ],
                "np.floor": [
                    2050,
                    2043
                ],
                "_gen_unique_rand": [
                    2048,
                    2045
                ],
                "ind.size": [
                    2046
                ],
                "i.tolist": [
                    2052
                ],
                "j.tolist": [
                    2052
                ],
                "makeDataFrame": [
                    2056
                ],
                "_create_missing_idx": [
                    2057
                ],
                "df.shape": [
                    2057
                ],
                "df.values": [
                    2058
                ],
                "np.nan": [
                    2632,
                    2058
                ],
                "decorator": [
                    2074,
                    2077
                ],
                "is_decorating": [
                    2080,
                    2079
                ],
                "dec": [
                    2083,
                    2085
                ],
                "wraps": [
                    2512,
                    2074,
                    2262
                ],
                "wrapper": [
                    2530,
                    2292,
                    2087
                ],
                "_network_error_messages": [
                    2171,
                    2091
                ],
                "_network_errno_vals": [
                    2170,
                    2111
                ],
                "http.client.HTTPException": [
                    2132
                ],
                "http.client": [
                    2132
                ],
                "http": [
                    2132
                ],
                "error_classes": [
                    2151,
                    2152,
                    2284,
                    2157,
                    2287,
                    2257,
                    2258,
                    2265
                ],
                "_get_default_network_errors": [
                    2152,
                    2258
                ],
                "urlopen": [
                    2155
                ],
                "url": [
                    2265,
                    2155,
                    2287
                ],
                "t.network": [
                    2260
                ],
                "t": [
                    2268,
                    2260,
                    2262
                ],
                "check_before_test": [
                    2264
                ],
                "raise_on_error": [
                    2264,
                    2287
                ],
                "can_connect": [
                    2265,
                    2287
                ],
                "skip": [
                    2280,
                    2266,
                    2275,
                    2290
                ],
                "errno": [
                    2272,
                    2274,
                    2270,
                    2271
                ],
                "err": [
                    2272,
                    2275,
                    2277,
                    2281,
                    2284,
                    2290,
                    2270
                ],
                "err.reason": [
                    2272
                ],
                "skip_errnos": [
                    2274
                ],
                "e_str": [
                    2277,
                    2279
                ],
                "m.lower": [
                    2279
                ],
                "m": [
                    2279
                ],
                "e_str.lower": [
                    2279
                ],
                "_skip_on_messages": [
                    2279
                ],
                "optional_args": [
                    2163
                ],
                "with_connectivity_check": [
                    2295
                ],
                "network": [
                    2295
                ],
                "warnings.catch_warnings": [
                    2361
                ],
                "w": [
                    2368,
                    2361,
                    2365
                ],
                "saw_warning": [
                    2400,
                    2363,
                    2372
                ],
                "filter_level": [
                    2364
                ],
                "extra_warnings": [
                    2401,
                    2403,
                    2387,
                    2366
                ],
                "actual_warning": [
                    2368,
                    2370,
                    2375,
                    2382,
                    2383,
                    2385,
                    2389,
                    2390,
                    2391,
                    2392
                ],
                "expected_warning": [
                    2369,
                    2370,
                    2395,
                    2398
                ],
                "actual_warning.category": [
                    2370,
                    2389,
                    2375
                ],
                "check_stacklevel": [
                    2374
                ],
                "caller": [
                    2385,
                    2379,
                    2383
                ],
                "getframeinfo": [
                    2379
                ],
                "stack": [
                    2379
                ],
                "actual_warning.filename": [
                    2385,
                    2382,
                    2391
                ],
                "caller.filename": [
                    2385,
                    2383
                ],
                "actual_warning.message": [
                    2390,
                    2383
                ],
                "extra_warnings.append": [
                    2387
                ],
                "actual_warning.category.__name__": [
                    2389
                ],
                "actual_warning.lineno": [
                    2392
                ],
                "expected_warning.__name__": [
                    2398
                ],
                "raise_on_extra_warnings": [
                    2401
                ],
                "self.seed": [
                    2424,
                    2429
                ],
                "self": [
                    2424,
                    2433,
                    2428,
                    2429
                ],
                "self.start_state": [
                    2433,
                    2428
                ],
                "np.random.get_state": [
                    2428
                ],
                "np.random.seed": [
                    2429
                ],
                "np.random.set_state": [
                    2433
                ],
                "_BUILTIN_DIALECTS": [
                    2458,
                    2460
                ],
                "csv.register_dialect": [
                    2463
                ],
                "csv": [
                    2465,
                    2463
                ],
                "csv.unregister_dialect": [
                    2465
                ],
                "min_elements": [
                    2472,
                    2473,
                    2478
                ],
                "expr._MIN_ELEMENTS": [
                    2480,
                    2473,
                    2476,
                    2478
                ],
                "expr": [
                    2473,
                    2475,
                    2476,
                    2477,
                    2478,
                    2480,
                    2481
                ],
                "olduse": [
                    2481,
                    2475
                ],
                "expr._USE_NUMEXPR": [
                    2475
                ],
                "oldmin": [
                    2480,
                    2476
                ],
                "expr.set_use_numexpr": [
                    2481,
                    2477
                ],
                "use": [
                    2477
                ],
                "num_threads": [
                    2505,
                    2508,
                    2519
                ],
                "has_kwargs_list": [
                    2514,
                    2506,
                    2507
                ],
                "kwargs_list": [
                    2506,
                    2515,
                    2508
                ],
                "update_kwargs": [
                    2520,
                    2515,
                    2517
                ],
                "threads": [
                    2522,
                    2523,
                    2525,
                    2518
                ],
                "updated_kwargs": [
                    2520,
                    2521
                ],
                "thread": [
                    2521,
                    2522,
                    2523,
                    2524,
                    2525,
                    2526
                ],
                "threading.Thread": [
                    2521
                ],
                "threading": [
                    2521
                ],
                "func": [
                    2512,
                    2521
                ],
                "threads.append": [
                    2522
                ],
                "thread.start": [
                    2524
                ],
                "thread.join": [
                    2526
                ],
                "inner": [
                    2528
                ],
                "_metadata": [
                    2546,
                    2534
                ],
                "SubclassedSeries": [
                    2538,
                    2554
                ],
                "SubclassedDataFrame": [
                    2550,
                    2542
                ],
                "SubclassedCategorical": [
                    2560
                ],
                "tz": [
                    2595,
                    2589,
                    2599
                ],
                "time.tzset": [
                    2596
                ],
                "time": [
                    2596
                ],
                "orig_tz": [
                    2603,
                    2598
                ],
                "setTZ": [
                    2603,
                    2599
                ],
                "skipna_alternative": [
                    2625,
                    2622
                ],
                "x.values": [
                    2625
                ],
                "nona": [
                    2633,
                    2630,
                    2631
                ],
                "x.dropna": [
                    2630
                ],
                "alternative": [
                    2633
                ],
                "skipna_wrapper": [
                    2635
                ],
                "List": [
                    2638
                ],
                "sep": [
                    2654,
                    2655
                ],
                "os.linesep": [
                    2654
                ],
                "sep.join": [
                    2655
                ],
                "rows_list": [
                    2655
                ],
                "Type": [
                    2660,
                    2661
                ],
                "pytest.raises": [
                    2677
                ],
                "expected_exception": [
                    2677
                ],
                "Callable": [
                    2661
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_42/pandas/tests/util/test_assert_frame_equal.py",
                "test_function": "test_assert_frame_equal_extension_dtype_mismatch",
                "test_function_code": "def test_assert_frame_equal_extension_dtype_mismatch():\n    # https://github.com/pandas-dev/pandas/issues/32747\n    left = DataFrame({\"a\": [1, 2, 3]}, dtype=\"Int64\")\n    right = left.astype(int)\n\n    msg = (\n        \"Attributes of DataFrame\\\\.iloc\\\\[:, 0\\\\] \"\n        '\\\\(column name=\"a\"\\\\) are different\\n\\n'\n        'Attribute \"dtype\" are different\\n'\n        \"\\\\[left\\\\]:  Int64\\n\"\n        \"\\\\[right\\\\]: int[32|64]\"\n    )\n\n    tm.assert_frame_equal(left, right, check_dtype=False)\n\n    with pytest.raises(AssertionError, match=msg):\n        tm.assert_frame_equal(left, right, check_dtype=True)",
                "test_error": "AssertionError: right is not an ExtensionArray",
                "full_test_error": "def test_assert_frame_equal_extension_dtype_mismatch():\n        # https://github.com/pandas-dev/pandas/issues/32747\n        left = DataFrame({\"a\": [1, 2, 3]}, dtype=\"Int64\")\n        right = left.astype(int)\n    \n        msg = (\n            \"Attributes of DataFrame\\\\.iloc\\\\[:, 0\\\\] \"\n            '\\\\(column name=\"a\"\\\\) are different\\n\\n'\n            'Attribute \"dtype\" are different\\n'\n            \"\\\\[left\\\\]:  Int64\\n\"\n            \"\\\\[right\\\\]: int[32|64]\"\n        )\n    \n>       tm.assert_frame_equal(left, right, check_dtype=False)\n\npandas/tests/util/test_assert_frame_equal.py:237: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = <IntegerArray>\n[1, 2, 3]\nLength: 3, dtype: Int64\nright = array([1, 2, 3]), check_dtype = True, check_less_precise = False\ncheck_exact = False\n\n    def assert_extension_array_equal(\n        left, right, check_dtype=True, check_less_precise=False, check_exact=False\n    ):\n        \"\"\"\n        Check that left and right ExtensionArrays are equal.\n    \n        Parameters\n        ----------\n        left, right : ExtensionArray\n            The two arrays to compare.\n        check_dtype : bool, default True\n            Whether to check if the ExtensionArray dtypes are identical.\n        check_less_precise : bool or int, default False\n            Specify comparison precision. Only used when check_exact is False.\n            5 digits (False) or 3 digits (True) after decimal points are compared.\n            If int, then specify the digits to compare.\n        check_exact : bool, default False\n            Whether to compare number exactly.\n    \n        Notes\n        -----\n        Missing values are checked separately from valid values.\n        A mask of missing values is computed for each and checked to match.\n        The remaining all-valid values are cast to object dtype and checked.\n        \"\"\"\n        assert isinstance(left, ExtensionArray), \"left is not an ExtensionArray\"\n>       assert isinstance(right, ExtensionArray), \"right is not an ExtensionArray\"\nE       AssertionError: right is not an ExtensionArray\n\npandas/_testing.py:1019: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_42/pandas/tests/util/test_assert_frame_equal.py",
                "test_function": "test_assert_frame_equal_interval_dtype_mismatch",
                "test_function_code": "def test_assert_frame_equal_interval_dtype_mismatch():\n    # https://github.com/pandas-dev/pandas/issues/32747\n    left = DataFrame({\"a\": [pd.Interval(0, 1)]}, dtype=\"interval\")\n    right = left.astype(object)\n\n    msg = (\n        \"Attributes of DataFrame\\\\.iloc\\\\[:, 0\\\\] \"\n        '\\\\(column name=\"a\"\\\\) are different\\n\\n'\n        'Attribute \"dtype\" are different\\n'\n        \"\\\\[left\\\\]:  interval\\\\[int64\\\\]\\n\"\n        \"\\\\[right\\\\]: object\"\n    )\n\n    tm.assert_frame_equal(left, right, check_dtype=False)\n\n    with pytest.raises(AssertionError, match=msg):\n        tm.assert_frame_equal(left, right, check_dtype=True)",
                "test_error": "AssertionError: IntervalArray Expected type <class 'pandas.core.arrays.interval.IntervalArray'>, found <class 'pandas.core.arrays.numpy_.PandasArray'> instead",
                "full_test_error": "def test_assert_frame_equal_interval_dtype_mismatch():\n        # https://github.com/pandas-dev/pandas/issues/32747\n        left = DataFrame({\"a\": [pd.Interval(0, 1)]}, dtype=\"interval\")\n        right = left.astype(object)\n    \n        msg = (\n            \"Attributes of DataFrame\\\\.iloc\\\\[:, 0\\\\] \"\n            '\\\\(column name=\"a\"\\\\) are different\\n\\n'\n            'Attribute \"dtype\" are different\\n'\n            \"\\\\[left\\\\]:  interval\\\\[int64\\\\]\\n\"\n            \"\\\\[right\\\\]: object\"\n        )\n    \n>       tm.assert_frame_equal(left, right, check_dtype=False)\n\npandas/tests/util/test_assert_frame_equal.py:256: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/_testing.py:861: in assert_interval_array_equal\n    _check_isinstance(left, right, IntervalArray)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = <IntervalArray>\n[(0, 1]]\nLength: 1, closed: right, dtype: interval[int64]\nright = <PandasArray>\n[Interval(0, 1, closed='right')]\nLength: 1, dtype: object\ncls = <class 'pandas.core.arrays.interval.IntervalArray'>\n\n    def _check_isinstance(left, right, cls):\n        \"\"\"\n        Helper method for our assert_* methods that ensures that\n        the two objects being compared have the right type before\n        proceeding with the comparison.\n    \n        Parameters\n        ----------\n        left : The first object being compared.\n        right : The second object being compared.\n        cls : The class type to check against.\n    \n        Raises\n        ------\n        AssertionError : Either `left` or `right` is not an instance of `cls`.\n        \"\"\"\n        cls_name = cls.__name__\n    \n        if not isinstance(left, cls):\n            raise AssertionError(\n                f\"{cls_name} Expected type {cls}, found {type(left)} instead\"\n            )\n        if not isinstance(right, cls):\n>           raise AssertionError(\n                f\"{cls_name} Expected type {cls}, found {type(right)} instead\"\n            )\nE           AssertionError: IntervalArray Expected type <class 'pandas.core.arrays.interval.IntervalArray'>, found <class 'pandas.core.arrays.numpy_.PandasArray'> instead\n\npandas/_testing.py:389: AssertionError",
                "traceback": "pandas/_testing.py:861: in assert_interval_array_equal\n    _check_isinstance(left, right, IntervalArray)",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = <IntervalArray>\n[(0, 1]]\nLength: 1, closed: right, dtype: interval[int64]\nright = <PandasArray>\n[Interval(0, 1, closed='right')]\nLength: 1, dtype: object\ncls = <class 'pandas.core.arrays.interval.IntervalArray'>\n\n    def _check_isinstance(left, right, cls):\n        \"\"\"\n        Helper method for our assert_* methods that ensures that\n        the two objects being compared have the right type before\n        proceeding with the comparison.\n    \n        Parameters\n        ----------\n        left : The first object being compared.\n        right : The second object being compared.\n        cls : The class type to check against.\n    \n        Raises\n        ------\n        AssertionError : Either `left` or `right` is not an instance of `cls`.\n        \"\"\"\n        cls_name = cls.__name__\n    \n        if not isinstance(left, cls):\n            raise AssertionError(\n                f\"{cls_name} Expected type {cls}, found {type(left)} instead\"\n            )\n        if not isinstance(right, cls):\n>           raise AssertionError(\n                f\"{cls_name} Expected type {cls}, found {type(right)} instead\"\n            )\nE           AssertionError: IntervalArray Expected type <class 'pandas.core.arrays.interval.IntervalArray'>, found <class 'pandas.core.arrays.numpy_.PandasArray'> instead\n\npandas/_testing.py:389: AssertionError",
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_42/pandas/tests/util/test_assert_series_equal.py",
                "test_function": "test_assert_series_equal_extension_dtype_mismatch",
                "test_function_code": "def test_assert_series_equal_extension_dtype_mismatch():\n    # https://github.com/pandas-dev/pandas/issues/32747\n    left = Series(pd.array([1, 2, 3], dtype=\"Int64\"))\n    right = left.astype(int)\n\n    msg = \"\"\"Attributes of Series are different\n\nAttribute \"dtype\" are different\n\\\\[left\\\\]:  Int64\n\\\\[right\\\\]: int[32|64]\"\"\"\n\n    tm.assert_series_equal(left, right, check_dtype=False)\n\n    with pytest.raises(AssertionError, match=msg):\n        tm.assert_series_equal(left, right, check_dtype=True)",
                "test_error": "AssertionError: right is not an ExtensionArray",
                "full_test_error": "def test_assert_series_equal_extension_dtype_mismatch():\n        # https://github.com/pandas-dev/pandas/issues/32747\n        left = Series(pd.array([1, 2, 3], dtype=\"Int64\"))\n        right = left.astype(int)\n    \n        msg = \"\"\"Attributes of Series are different\n    \n    Attribute \"dtype\" are different\n    \\\\[left\\\\]:  Int64\n    \\\\[right\\\\]: int[32|64]\"\"\"\n    \n>       tm.assert_series_equal(left, right, check_dtype=False)\n\npandas/tests/util/test_assert_series_equal.py:211: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = <IntegerArray>\n[1, 2, 3]\nLength: 3, dtype: Int64\nright = array([1, 2, 3]), check_dtype = True, check_less_precise = False\ncheck_exact = False\n\n    def assert_extension_array_equal(\n        left, right, check_dtype=True, check_less_precise=False, check_exact=False\n    ):\n        \"\"\"\n        Check that left and right ExtensionArrays are equal.\n    \n        Parameters\n        ----------\n        left, right : ExtensionArray\n            The two arrays to compare.\n        check_dtype : bool, default True\n            Whether to check if the ExtensionArray dtypes are identical.\n        check_less_precise : bool or int, default False\n            Specify comparison precision. Only used when check_exact is False.\n            5 digits (False) or 3 digits (True) after decimal points are compared.\n            If int, then specify the digits to compare.\n        check_exact : bool, default False\n            Whether to compare number exactly.\n    \n        Notes\n        -----\n        Missing values are checked separately from valid values.\n        A mask of missing values is computed for each and checked to match.\n        The remaining all-valid values are cast to object dtype and checked.\n        \"\"\"\n        assert isinstance(left, ExtensionArray), \"left is not an ExtensionArray\"\n>       assert isinstance(right, ExtensionArray), \"right is not an ExtensionArray\"\nE       AssertionError: right is not an ExtensionArray\n\npandas/_testing.py:1019: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_42/pandas/tests/util/test_assert_series_equal.py",
                "test_function": "test_assert_series_equal_interval_dtype_mismatch",
                "test_function_code": "def test_assert_series_equal_interval_dtype_mismatch():\n    # https://github.com/pandas-dev/pandas/issues/32747\n    left = Series([pd.Interval(0, 1)], dtype=\"interval\")\n    right = left.astype(object)\n\n    msg = \"\"\"Attributes of Series are different\n\nAttribute \"dtype\" are different\n\\\\[left\\\\]:  interval\\\\[int64\\\\]\n\\\\[right\\\\]: object\"\"\"\n\n    tm.assert_series_equal(left, right, check_dtype=False)\n\n    with pytest.raises(AssertionError, match=msg):\n        tm.assert_series_equal(left, right, check_dtype=True)",
                "test_error": "AssertionError: IntervalArray Expected type <class 'pandas.core.arrays.interval.IntervalArray'>, found <class 'pandas.core.arrays.numpy_.PandasArray'> instead",
                "full_test_error": "def test_assert_series_equal_interval_dtype_mismatch():\n        # https://github.com/pandas-dev/pandas/issues/32747\n        left = Series([pd.Interval(0, 1)], dtype=\"interval\")\n        right = left.astype(object)\n    \n        msg = \"\"\"Attributes of Series are different\n    \n    Attribute \"dtype\" are different\n    \\\\[left\\\\]:  interval\\\\[int64\\\\]\n    \\\\[right\\\\]: object\"\"\"\n    \n>       tm.assert_series_equal(left, right, check_dtype=False)\n\npandas/tests/util/test_assert_series_equal.py:228: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/_testing.py:861: in assert_interval_array_equal\n    _check_isinstance(left, right, IntervalArray)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = <IntervalArray>\n[(0, 1]]\nLength: 1, closed: right, dtype: interval[int64]\nright = <PandasArray>\n[Interval(0, 1, closed='right')]\nLength: 1, dtype: object\ncls = <class 'pandas.core.arrays.interval.IntervalArray'>\n\n    def _check_isinstance(left, right, cls):\n        \"\"\"\n        Helper method for our assert_* methods that ensures that\n        the two objects being compared have the right type before\n        proceeding with the comparison.\n    \n        Parameters\n        ----------\n        left : The first object being compared.\n        right : The second object being compared.\n        cls : The class type to check against.\n    \n        Raises\n        ------\n        AssertionError : Either `left` or `right` is not an instance of `cls`.\n        \"\"\"\n        cls_name = cls.__name__\n    \n        if not isinstance(left, cls):\n            raise AssertionError(\n                f\"{cls_name} Expected type {cls}, found {type(left)} instead\"\n            )\n        if not isinstance(right, cls):\n>           raise AssertionError(\n                f\"{cls_name} Expected type {cls}, found {type(right)} instead\"\n            )\nE           AssertionError: IntervalArray Expected type <class 'pandas.core.arrays.interval.IntervalArray'>, found <class 'pandas.core.arrays.numpy_.PandasArray'> instead\n\npandas/_testing.py:389: AssertionError",
                "traceback": "pandas/_testing.py:861: in assert_interval_array_equal\n    _check_isinstance(left, right, IntervalArray)",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = <IntervalArray>\n[(0, 1]]\nLength: 1, closed: right, dtype: interval[int64]\nright = <PandasArray>\n[Interval(0, 1, closed='right')]\nLength: 1, dtype: object\ncls = <class 'pandas.core.arrays.interval.IntervalArray'>\n\n    def _check_isinstance(left, right, cls):\n        \"\"\"\n        Helper method for our assert_* methods that ensures that\n        the two objects being compared have the right type before\n        proceeding with the comparison.\n    \n        Parameters\n        ----------\n        left : The first object being compared.\n        right : The second object being compared.\n        cls : The class type to check against.\n    \n        Raises\n        ------\n        AssertionError : Either `left` or `right` is not an instance of `cls`.\n        \"\"\"\n        cls_name = cls.__name__\n    \n        if not isinstance(left, cls):\n            raise AssertionError(\n                f\"{cls_name} Expected type {cls}, found {type(left)} instead\"\n            )\n        if not isinstance(right, cls):\n>           raise AssertionError(\n                f\"{cls_name} Expected type {cls}, found {type(right)} instead\"\n            )\nE           AssertionError: IntervalArray Expected type <class 'pandas.core.arrays.interval.IntervalArray'>, found <class 'pandas.core.arrays.numpy_.PandasArray'> instead\n\npandas/_testing.py:389: AssertionError",
                "test_function_decorators": []
            }
        ]
    }
}