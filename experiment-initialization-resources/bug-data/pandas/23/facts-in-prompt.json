{
    "1": "    def intersection(self, other, sort=False):\n        \"\"\"\n        Specialized intersection for DatetimeIndex/TimedeltaIndex.\n    \n        May be much faster than Index.intersection\n    \n        Parameters\n        ----------\n        other : Same type as self or array-like\n        sort : False or None, default False\n            Sort the resulting index if possible.\n    \n            .. versionadded:: 0.24.0\n    \n            .. versionchanged:: 0.24.1\n    \n               Changed the default to ``False`` to match the behaviour\n               from before 0.24.0.\n    \n            .. versionchanged:: 0.25.0\n    \n               The `sort` keyword is added\n    \n        Returns\n        -------\n        y : Index or same type as self\n        \"\"\"\n        self._validate_sort_keyword(sort)\n        self._assert_can_do_setop(other)\n    \n        if self.equals(other):\n            return self._get_reconciled_name_object(other)\n    \n        if len(self) == 0:\n            return self.copy()\n        if len(other) == 0:\n            return other.copy()\n    \n        if not isinstance(other, type(self)):\n            result = Index.intersection(self, other, sort=sort)\n            if isinstance(result, type(self)):\n                if result.freq is None:\n                    result._set_freq(\"infer\")\n            return result\n    \n        elif (\n            other.freq is None\n            or self.freq is None\n            or other.freq != self.freq\n            or not other.freq.is_anchored()\n            or (not self.is_monotonic or not other.is_monotonic)\n        ):\n            result = Index.intersection(self, other, sort=sort)\n    \n            # Invalidate the freq of `result`, which may not be correct at\n            # this point, depending on the values.\n    \n            result._set_freq(None)\n            result = self._shallow_copy(result._data, name=result.name)\n            if result.freq is None:\n                result._set_freq(\"infer\")\n            return result\n    \n        # to make our life easier, \"sort\" the two ranges\n        if self[0] <= other[0]:\n            left, right = self, other\n        else:\n            left, right = other, self\n    \n        # after sorting, the intersection always starts with the right index\n        # and ends with the index of which the last elements is smallest\n        end = min(left[-1], right[-1])\n        start = right[0]\n    \n        if end < start:\n            return type(self)(data=[])\n        else:\n            lslice = slice(*left.slice_locs(start, end))\n            left_chunk = left.values[lslice]\n            return self._shallow_copy(left_chunk)\n    \n",
    "2": "# class declaration containing the buggy function\nclass DatetimeTimedeltaMixin(DatetimeIndexOpsMixin, Int64Index):\n    \"\"\"\n    Mixin class for methods shared by DatetimeIndex and TimedeltaIndex,\n    but not PeriodIndex\n    \"\"\"\n\n    # ... omitted code ...\n\n\n    # signature of a relative function in this class\n    def _set_freq(self, freq):\n        # ... omitted code ...\n        pass\n\n    # signature of a relative function in this class\n    def _shallow_copy(self, values=None, name: Label=lib.no_default):\n        # ... omitted code ...\n        pass\n\n    # signature of a relative function in this class\n    def intersection(self, other, sort=False):\n        # ... omitted code ...\n        pass\n\n",
    "3": "# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_23/pandas/core/indexes/datetimelike.py\n\n# relative function's signature in this file\ndef values(self):\n    # ... omitted code ...\n    pass\n\n# relative function's signature in this file\ndef equals(self, other) -> bool:\n    # ... omitted code ...\n    pass\n\n# relative function's signature in this file\ndef _set_freq(self, freq):\n    # ... omitted code ...\n    pass\n\n# relative function's signature in this file\ndef _shallow_copy(self, values=None, name: Label=lib.no_default):\n    # ... omitted code ...\n    pass\n\n# relative function's signature in this file\ndef intersection(self, other, sort=False):\n    # ... omitted code ...\n    pass\n\n",
    "4": "# A test function for the buggy function\n```python\n# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_23/pandas/tests/indexes/datetimes/test_setops.py\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n```\n\n## Error message from test function\n```text\nself = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110a7d400>\ntz_aware_fixture = 'UTC', freq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B'), obj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)\nE               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, UTC]\n\npandas/_testing.py:611: AssertionError\n\n```\n# A test function for the buggy function\n```python\n# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_23/pandas/tests/indexes/datetimes/test_setops.py\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n```\n\n## Error message from test function\n```text\nself = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110a64760>\ntz_aware_fixture = 'US/Eastern', freq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')\nobj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)\nE               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, US/Eastern]\n\npandas/_testing.py:611: AssertionError\n\n```\n# A test function for the buggy function\n```python\n# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_23/pandas/tests/indexes/datetimes/test_setops.py\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n```\n\n## Error message from test function\n```text\nself = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110b159d0>\ntz_aware_fixture = 'Asia/Tokyo', freq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')\nobj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)\nE               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, Asia/Tokyo]\n\npandas/_testing.py:611: AssertionError\n\n```\n# A test function for the buggy function\n```python\n# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_23/pandas/tests/indexes/datetimes/test_setops.py\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n```\n\n## Error message from test function\n```text\nself = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110a7d0d0>\ntz_aware_fixture = 'dateutil/US/Pacific', freq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')\nobj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)\nE               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]\n\npandas/_testing.py:611: AssertionError\n\n```\n# A test function for the buggy function\n```python\n# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_23/pandas/tests/indexes/datetimes/test_setops.py\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n```\n\n## Error message from test function\n```text\nself = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110a754c0>\ntz_aware_fixture = 'dateutil/Asia/Singapore', freq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')\nobj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)\nE               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]\n\npandas/_testing.py:611: AssertionError\n\n```\n# A test function for the buggy function\n```python\n# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_23/pandas/tests/indexes/datetimes/test_setops.py\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n```\n\n## Error message from test function\n```text\nself = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110a4b190>\ntz_aware_fixture = tzutc(), freq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B'), obj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)\nE               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, tzutc()]\n\npandas/_testing.py:611: AssertionError\n\n```\n# A test function for the buggy function\n```python\n# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_23/pandas/tests/indexes/datetimes/test_setops.py\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n```\n\n## Error message from test function\n```text\nself = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110a970a0>\ntz_aware_fixture = tzlocal(), freq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')\nobj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)\nE               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, tzlocal()]\n\npandas/_testing.py:611: AssertionError\n\n```\n# A test function for the buggy function\n```python\n# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_23/pandas/tests/indexes/datetimes/test_setops.py\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n```\n\n## Error message from test function\n```text\nself = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110bcbe80>\ntz_aware_fixture = pytz.FixedOffset(300), freq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')\nobj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)\nE               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, pytz.FixedOffset(300)]\n\npandas/_testing.py:611: AssertionError\n\n```\n# A test function for the buggy function\n```python\n# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_23/pandas/tests/indexes/datetimes/test_setops.py\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n```\n\n## Error message from test function\n```text\nself = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110c8ba30>\ntz_aware_fixture = <UTC>, freq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B'), obj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)\nE               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, UTC]\n\npandas/_testing.py:611: AssertionError\n\n```\n# A test function for the buggy function\n```python\n# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_23/pandas/tests/indexes/datetimes/test_setops.py\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n```\n\n## Error message from test function\n```text\nself = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110a64fa0>\ntz_aware_fixture = pytz.FixedOffset(-300), freq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')\nobj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)\nE               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, pytz.FixedOffset(-300)]\n\npandas/_testing.py:611: AssertionError\n\n```\n# A test function for the buggy function\n```python\n# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_23/pandas/tests/indexes/datetimes/test_setops.py\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n```\n\n## Error message from test function\n```text\nself = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110b589a0>\ntz_aware_fixture = datetime.timezone.utc, freq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B'), obj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)\nE               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, UTC]\n\npandas/_testing.py:611: AssertionError\n\n```\n# A test function for the buggy function\n```python\n# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_23/pandas/tests/indexes/datetimes/test_setops.py\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n```\n\n## Error message from test function\n```text\nself = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110c7aa00>\ntz_aware_fixture = datetime.timezone(datetime.timedelta(seconds=3600))\nfreq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')\nobj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)\nE               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, UTC+01:00]\n\npandas/_testing.py:611: AssertionError\n\n```\n# A test function for the buggy function\n```python\n# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_23/pandas/tests/indexes/datetimes/test_setops.py\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n```\n\n## Error message from test function\n```text\nself = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110c7e9d0>\ntz_aware_fixture = datetime.timezone(datetime.timedelta(days=-1, seconds=82800), 'foo')\nfreq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B'), obj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)\nE               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, foo]\n\npandas/_testing.py:611: AssertionError\n\n```\n# A test function for the buggy function\n```python\n# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_23/pandas/tests/indexes/datetimes/test_setops.py\n\n    def test_intersection_bug(self):\n        # GH #771\n        a = bdate_range(\"11/30/2011\", \"12/31/2011\")\n        b = bdate_range(\"12/10/2011\", \"12/20/2011\")\n        result = a.intersection(b)\n        tm.assert_index_equal(result, b)\n        assert result.freq == b.freq\n```\n\n## Error message from test function\n```text\nself = <pandas.tests.indexes.datetimes.test_setops.TestBusinessDatetimeIndex object at 0x110c75970>\n\n    def test_intersection_bug(self):\n        # GH #771\n        a = bdate_range(\"11/30/2011\", \"12/31/2011\")\n        b = bdate_range(\"12/10/2011\", \"12/20/2011\")\n        result = a.intersection(b)\n        tm.assert_index_equal(result, b)\n>       assert result.freq == b.freq\nE       assert None == <BusinessDay>\nE         +None\nE         -<BusinessDay>\n\npandas/tests/indexes/datetimes/test_setops.py:473: AssertionError\n\n```\n# A test function for the buggy function\n```python\n# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_23/pandas/tests/indexes/datetimes/test_setops.py\n\n    def test_intersection_bug(self):\n        # GH #771\n        a = bdate_range(\"11/30/2011\", \"12/31/2011\")\n        b = bdate_range(\"12/10/2011\", \"12/20/2011\")\n        result = a.intersection(b)\n        tm.assert_index_equal(result, b)\n        assert result.freq == b.freq\n```\n\n## Error message from test function\n```text\nself = <pandas.tests.indexes.datetimes.test_setops.TestCustomDatetimeIndex object at 0x110b58070>\n\n    def test_intersection_bug(self):\n        # GH #771\n        a = bdate_range(\"11/30/2011\", \"12/31/2011\", freq=\"C\")\n        b = bdate_range(\"12/10/2011\", \"12/20/2011\", freq=\"C\")\n        result = a.intersection(b)\n        tm.assert_index_equal(result, b)\n>       assert result.freq == b.freq\nE       assert None == <CustomBusinessDay>\nE         +None\nE         -<CustomBusinessDay>\n\npandas/tests/indexes/datetimes/test_setops.py:551: AssertionError\n\n```\n",
    "5": "# Variable runtime value and type inside buggy function\n## Buggy case 1\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nother, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... TC]', length=20161, freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, UTC]`, type: `DatetimeTZDtype`\n\n## Buggy case 2\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... TC]', length=20161, freq='T')>`, type: `method`\n\nself, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... TC]', length=20161, freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... TC]', length=20161, freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... TC]', length=20161, freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... TC]', length=20161, freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... TC]', length=20161, freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, UTC]`, type: `DatetimeTZDtype`\n\n## Buggy case 3\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, UTC]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nresult, value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)>`, type: `method`\n\nresult._data, value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, UTC]`, type: `DatetimeArray`\n\n## Buggy case 4\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, UTC]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nresult, value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)>`, type: `method`\n\nresult._data, value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, UTC]`, type: `DatetimeArray`\n\n## Buggy case 5\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, UTC]`, type: `DatetimeTZDtype`\n\n## Buggy case 6\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... tetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... tetime64[ns, UTC]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... tetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... tetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... tetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, UTC]`, type: `DatetimeTZDtype`\n\n## Buggy case 7\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, UTC]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2000-06-05 00:00:00+0000', tz='UTC', freq='B')`, type: `Timestamp`\n\nstart, value: `Timestamp('2000-06-13 00:00:00+0000', tz='UTC', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nleft._values, value: `<DatetimeArray>\n['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n '2000-06-05 00:00:00+00:00']\nLength: 3, dtype: datetime64[ns, UTC]`, type: `DatetimeArray`\n\n## Buggy case 8\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, UTC]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2000-06-05 00:00:00+0000', tz='UTC', freq='B')`, type: `Timestamp`\n\nstart, value: `Timestamp('2000-06-13 00:00:00+0000', tz='UTC', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nleft._values, value: `<DatetimeArray>\n['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n '2000-06-05 00:00:00+00:00']\nLength: 3, dtype: datetime64[ns, UTC]`, type: `DatetimeArray`\n\n## Buggy case 9\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nother, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... rn]', length=20161, freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, US/Eastern]`, type: `DatetimeTZDtype`\n\n## Buggy case 10\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... rn]', length=20161, freq='T')>`, type: `method`\n\nself, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... rn]', length=20161, freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... rn]', length=20161, freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... rn]', length=20161, freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... rn]', length=20161, freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... rn]', length=20161, freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, US/Eastern]`, type: `DatetimeTZDtype`\n\n## Buggy case 11\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, US/Eastern]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nresult, value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)>`, type: `method`\n\nresult._data, value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, US/Eastern]`, type: `DatetimeArray`\n\n## Buggy case 12\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, US/Eastern]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nresult, value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)>`, type: `method`\n\nresult._data, value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, US/Eastern]`, type: `DatetimeArray`\n\n## Buggy case 13\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',\n               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',\n               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',\n               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',\n               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',\n               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',\n               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, US/Eastern]`, type: `DatetimeTZDtype`\n\n## Buggy case 14\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... 4[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',\n               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',\n               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',\n               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... 4[ns, US/Eastern]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... 4[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... 4[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',\n               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',\n               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',\n               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... 4[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, US/Eastern]`, type: `DatetimeTZDtype`\n\n## Buggy case 15\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, US/Eastern]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2000-06-05 00:00:00-0400', tz='US/Eastern', freq='B')`, type: `Timestamp`\n\nstart, value: `Timestamp('2000-06-13 00:00:00-0400', tz='US/Eastern', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nleft._values, value: `<DatetimeArray>\n['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n '2000-06-05 00:00:00-04:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]`, type: `DatetimeArray`\n\n## Buggy case 16\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, US/Eastern]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2000-06-05 00:00:00-0400', tz='US/Eastern', freq='B')`, type: `Timestamp`\n\nstart, value: `Timestamp('2000-06-13 00:00:00-0400', tz='US/Eastern', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nleft._values, value: `<DatetimeArray>\n['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n '2000-06-05 00:00:00-04:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]`, type: `DatetimeArray`\n\n## Buggy case 17\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nother, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... yo]', length=20161, freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, Asia/Tokyo]`, type: `DatetimeTZDtype`\n\n## Buggy case 18\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... yo]', length=20161, freq='T')>`, type: `method`\n\nself, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... yo]', length=20161, freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... yo]', length=20161, freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... yo]', length=20161, freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... yo]', length=20161, freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... yo]', length=20161, freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, Asia/Tokyo]`, type: `DatetimeTZDtype`\n\n## Buggy case 19\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, Asia/Tokyo]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nresult, value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)>`, type: `method`\n\nresult._data, value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, Asia/Tokyo]`, type: `DatetimeArray`\n\n## Buggy case 20\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, Asia/Tokyo]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nresult, value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)>`, type: `method`\n\nresult._data, value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, Asia/Tokyo]`, type: `DatetimeArray`\n\n## Buggy case 21\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',\n               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',\n               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',\n               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',\n               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',\n               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',\n               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, Asia/Tokyo]`, type: `DatetimeTZDtype`\n\n## Buggy case 22\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... 4[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',\n               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',\n               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',\n               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... 4[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... 4[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... 4[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',\n               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',\n               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',\n               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... 4[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, Asia/Tokyo]`, type: `DatetimeTZDtype`\n\n## Buggy case 23\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, Asia/Tokyo]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2000-06-05 00:00:00+0900', tz='Asia/Tokyo', freq='B')`, type: `Timestamp`\n\nstart, value: `Timestamp('2000-06-13 00:00:00+0900', tz='Asia/Tokyo', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nleft._values, value: `<DatetimeArray>\n['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n '2000-06-05 00:00:00+09:00']\nLength: 3, dtype: datetime64[ns, Asia/Tokyo]`, type: `DatetimeArray`\n\n## Buggy case 24\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, Asia/Tokyo]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2000-06-05 00:00:00+0900', tz='Asia/Tokyo', freq='B')`, type: `Timestamp`\n\nstart, value: `Timestamp('2000-06-13 00:00:00+0900', tz='Asia/Tokyo', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nleft._values, value: `<DatetimeArray>\n['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n '2000-06-05 00:00:00+09:00']\nLength: 3, dtype: datetime64[ns, Asia/Tokyo]`, type: `DatetimeArray`\n\n## Buggy case 25\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nother, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... ')]', length=20161, freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeTZDtype`\n\n## Buggy case 26\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... ')]', length=20161, freq='T')>`, type: `method`\n\nself, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... ')]', length=20161, freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... ')]', length=20161, freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... ')]', length=20161, freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... ')]', length=20161, freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... ')]', length=20161, freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeTZDtype`\n\n## Buggy case 27\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nresult, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)>`, type: `method`\n\nresult._data, value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeArray`\n\n## Buggy case 28\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nresult, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)>`, type: `method`\n\nresult._data, value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeArray`\n\n## Buggy case 29\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00', '2000-06-06 00:00:00-07:00',\n               '2000-06-07 00:00:00-07:00', '2000-06-08 00:00:00-07:00',\n               '2000-06-09 00:00:00-07:00', '2000-06-12 00:00:00-07:00',\n               '2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... nfo/US/Pacific')]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeTZDtype`\n\n## Buggy case 30\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... nfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00', '2000-06-06 00:00:00-07:00',\n               '2000-06-07 00:00:00-07:00', '2000-06-08 00:00:00-07:00',\n               '2000-06-09 00:00:00-07:00', '2000-06-12 00:00:00-07:00',\n               '2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... nfo/US/Pacific')]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... nfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... nfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... nfo/US/Pacific')]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... nfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeTZDtype`\n\n## Buggy case 31\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2000-06-05 00:00:00-0700', tz='dateutil//usr/share/zoneinfo/US/Pacific', freq='B')`, type: `Timestamp`\n\nstart, value: `Timestamp('2000-06-13 00:00:00-0700', tz='dateutil//usr/share/zoneinfo/US/Pacific', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nleft._values, value: `<DatetimeArray>\n['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n '2000-06-05 00:00:00-07:00']\nLength: 3, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeArray`\n\n## Buggy case 32\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2000-06-05 00:00:00-0700', tz='dateutil//usr/share/zoneinfo/US/Pacific', freq='B')`, type: `Timestamp`\n\nstart, value: `Timestamp('2000-06-13 00:00:00-0700', tz='dateutil//usr/share/zoneinfo/US/Pacific', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nleft._values, value: `<DatetimeArray>\n['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n '2000-06-05 00:00:00-07:00']\nLength: 3, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeArray`\n\n## Buggy case 33\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nother, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... ')]', length=20161, freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeTZDtype`\n\n## Buggy case 34\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... ')]', length=20161, freq='T')>`, type: `method`\n\nself, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... ')]', length=20161, freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... ')]', length=20161, freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... ')]', length=20161, freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... ')]', length=20161, freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... ')]', length=20161, freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeTZDtype`\n\n## Buggy case 35\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nresult, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)>`, type: `method`\n\nresult._data, value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeArray`\n\n## Buggy case 36\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nresult, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)>`, type: `method`\n\nresult._data, value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeArray`\n\n## Buggy case 37\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nother, value: `array of shape (11,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... Asia/Singapore')]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeTZDtype`\n\n## Buggy case 38\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... Asia/Singapore')]', freq='B')>`, type: `method`\n\nself, value: `array of shape (11,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... Asia/Singapore')]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... Asia/Singapore')]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... Asia/Singapore')]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... Asia/Singapore')]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... Asia/Singapore')]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeTZDtype`\n\n## Buggy case 39\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2000-06-05 00:00:00+0800', tz='dateutil//usr/share/zoneinfo/Asia/Singapore', freq='B')`, type: `Timestamp`\n\nstart, value: `Timestamp('2000-06-13 00:00:00+0800', tz='dateutil//usr/share/zoneinfo/Asia/Singapore', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nleft._values, value: `<DatetimeArray>\n['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n '2000-06-05 00:00:00+08:00']\nLength: 3, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeArray`\n\n## Buggy case 40\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2000-06-05 00:00:00+0800', tz='dateutil//usr/share/zoneinfo/Asia/Singapore', freq='B')`, type: `Timestamp`\n\nstart, value: `Timestamp('2000-06-13 00:00:00+0800', tz='dateutil//usr/share/zoneinfo/Asia/Singapore', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nleft._values, value: `<DatetimeArray>\n['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n '2000-06-05 00:00:00+08:00']\nLength: 3, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeArray`\n\n## Buggy case 41\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nother, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... ()]', length=20161, freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzutc()]`, type: `DatetimeTZDtype`\n\n## Buggy case 42\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... ()]', length=20161, freq='T')>`, type: `method`\n\nself, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... ()]', length=20161, freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... ()]', length=20161, freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... ()]', length=20161, freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... ()]', length=20161, freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... ()]', length=20161, freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzutc()]`, type: `DatetimeTZDtype`\n\n## Buggy case 43\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzutc()]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nresult, value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)>`, type: `method`\n\nresult._data, value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzutc()]`, type: `DatetimeArray`\n\n## Buggy case 44\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzutc()]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nresult, value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)>`, type: `method`\n\nresult._data, value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzutc()]`, type: `DatetimeArray`\n\n## Buggy case 45\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzutc()]`, type: `DatetimeTZDtype`\n\n## Buggy case 46\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... me64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... me64[ns, tzutc()]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... me64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... me64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... me64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzutc()]`, type: `DatetimeTZDtype`\n\n## Buggy case 47\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzutc()]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2000-06-05 00:00:00+0000', tz='tzutc()', freq='B')`, type: `Timestamp`\n\nstart, value: `Timestamp('2000-06-13 00:00:00+0000', tz='tzutc()', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nleft._values, value: `<DatetimeArray>\n['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n '2000-06-05 00:00:00+00:00']\nLength: 3, dtype: datetime64[ns, tzutc()]`, type: `DatetimeArray`\n\n## Buggy case 48\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzutc()]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2000-06-05 00:00:00+0000', tz='tzutc()', freq='B')`, type: `Timestamp`\n\nstart, value: `Timestamp('2000-06-13 00:00:00+0000', tz='tzutc()', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nleft._values, value: `<DatetimeArray>\n['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n '2000-06-05 00:00:00+00:00']\nLength: 3, dtype: datetime64[ns, tzutc()]`, type: `DatetimeArray`\n\n## Buggy case 49\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nother, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... ()]', length=20161, freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzlocal()]`, type: `DatetimeTZDtype`\n\n## Buggy case 50\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... ()]', length=20161, freq='T')>`, type: `method`\n\nself, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... ()]', length=20161, freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... ()]', length=20161, freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... ()]', length=20161, freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... ()]', length=20161, freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... ()]', length=20161, freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzlocal()]`, type: `DatetimeTZDtype`\n\n## Buggy case 51\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzlocal()]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nresult, value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)>`, type: `method`\n\nresult._data, value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzlocal()]`, type: `DatetimeArray`\n\n## Buggy case 52\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzlocal()]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nresult, value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)>`, type: `method`\n\nresult._data, value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzlocal()]`, type: `DatetimeArray`\n\n## Buggy case 53\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzlocal()]`, type: `DatetimeTZDtype`\n\n## Buggy case 54\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... 64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... 64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... 64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... 64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... 64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzlocal()]`, type: `DatetimeTZDtype`\n\n## Buggy case 55\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzlocal()]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2000-06-05 00:00:00+0100', tz='tzlocal()', freq='B')`, type: `Timestamp`\n\nstart, value: `Timestamp('2000-06-13 00:00:00+0100', tz='tzlocal()', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nleft._values, value: `<DatetimeArray>\n['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n '2000-06-05 00:00:00+01:00']\nLength: 3, dtype: datetime64[ns, tzlocal()]`, type: `DatetimeArray`\n\n## Buggy case 56\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, tzlocal()]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2000-06-05 00:00:00+0100', tz='tzlocal()', freq='B')`, type: `Timestamp`\n\nstart, value: `Timestamp('2000-06-13 00:00:00+0100', tz='tzlocal()', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nleft._values, value: `<DatetimeArray>\n['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n '2000-06-05 00:00:00+01:00']\nLength: 3, dtype: datetime64[ns, tzlocal()]`, type: `DatetimeArray`\n\n## Buggy case 57\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nother, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeTZDtype`\n\n## Buggy case 58\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... 0)]', length=20161, freq='T')>`, type: `method`\n\nself, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... 0)]', length=20161, freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... 0)]', length=20161, freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... 0)]', length=20161, freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... 0)]', length=20161, freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeTZDtype`\n\n## Buggy case 59\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nresult, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)>`, type: `method`\n\nresult._data, value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeArray`\n\n## Buggy case 60\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nresult, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)>`, type: `method`\n\nresult._data, value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeArray`\n\n## Buggy case 61\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00', '2000-06-06 00:00:00+05:00',\n               '2000-06-07 00:00:00+05:00', '2000-06-08 00:00:00+05:00',\n               '2000-06-09 00:00:00+05:00', '2000-06-12 00:00:00+05:00',\n               '2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... FixedOffset(300)]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeTZDtype`\n\n## Buggy case 62\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... FixedOffset(300)]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00', '2000-06-06 00:00:00+05:00',\n               '2000-06-07 00:00:00+05:00', '2000-06-08 00:00:00+05:00',\n               '2000-06-09 00:00:00+05:00', '2000-06-12 00:00:00+05:00',\n               '2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... FixedOffset(300)]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... FixedOffset(300)]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... FixedOffset(300)]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... FixedOffset(300)]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... FixedOffset(300)]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeTZDtype`\n\n## Buggy case 63\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2000-06-05 00:00:00+0500', tz='pytz.FixedOffset(300)', freq='B')`, type: `Timestamp`\n\nstart, value: `Timestamp('2000-06-13 00:00:00+0500', tz='pytz.FixedOffset(300)', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nleft._values, value: `<DatetimeArray>\n['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n '2000-06-05 00:00:00+05:00']\nLength: 3, dtype: datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeArray`\n\n## Buggy case 64\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2000-06-05 00:00:00+0500', tz='pytz.FixedOffset(300)', freq='B')`, type: `Timestamp`\n\nstart, value: `Timestamp('2000-06-13 00:00:00+0500', tz='pytz.FixedOffset(300)', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nleft._values, value: `<DatetimeArray>\n['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n '2000-06-05 00:00:00+05:00']\nLength: 3, dtype: datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeArray`\n\n## Buggy case 65\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nother, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeTZDtype`\n\n## Buggy case 66\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... 0)]', length=20161, freq='T')>`, type: `method`\n\nself, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... 0)]', length=20161, freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... 0)]', length=20161, freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... 0)]', length=20161, freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... 0)]', length=20161, freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeTZDtype`\n\n## Buggy case 67\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nresult, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)>`, type: `method`\n\nresult._data, value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeArray`\n\n## Buggy case 68\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nresult, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)>`, type: `method`\n\nresult._data, value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeArray`\n\n## Buggy case 69\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00', '2000-06-06 00:00:00-05:00',\n               '2000-06-07 00:00:00-05:00', '2000-06-08 00:00:00-05:00',\n               '2000-06-09 00:00:00-05:00', '2000-06-12 00:00:00-05:00',\n               '2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... ixedOffset(-300)]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeTZDtype`\n\n## Buggy case 70\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... ixedOffset(-300)]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00', '2000-06-06 00:00:00-05:00',\n               '2000-06-07 00:00:00-05:00', '2000-06-08 00:00:00-05:00',\n               '2000-06-09 00:00:00-05:00', '2000-06-12 00:00:00-05:00',\n               '2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... ixedOffset(-300)]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... ixedOffset(-300)]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... ixedOffset(-300)]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... ixedOffset(-300)]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... ixedOffset(-300)]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeTZDtype`\n\n## Buggy case 71\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2000-06-05 00:00:00-0500', tz='pytz.FixedOffset(-300)', freq='B')`, type: `Timestamp`\n\nstart, value: `Timestamp('2000-06-13 00:00:00-0500', tz='pytz.FixedOffset(-300)', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nleft._values, value: `<DatetimeArray>\n['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n '2000-06-05 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeArray`\n\n## Buggy case 72\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2000-06-05 00:00:00-0500', tz='pytz.FixedOffset(-300)', freq='B')`, type: `Timestamp`\n\nstart, value: `Timestamp('2000-06-13 00:00:00-0500', tz='pytz.FixedOffset(-300)', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nleft._values, value: `<DatetimeArray>\n['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n '2000-06-05 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeArray`\n\n## Buggy case 73\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nother, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... 00]', length=20161, freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, UTC+01:00]`, type: `DatetimeTZDtype`\n\n## Buggy case 74\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... 00]', length=20161, freq='T')>`, type: `method`\n\nself, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... 00]', length=20161, freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... 00]', length=20161, freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... 00]', length=20161, freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... 00]', length=20161, freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... 00]', length=20161, freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, UTC+01:00]`, type: `DatetimeTZDtype`\n\n## Buggy case 75\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, UTC+01:00]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nresult, value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)>`, type: `method`\n\nresult._data, value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, UTC+01:00]`, type: `DatetimeArray`\n\n## Buggy case 76\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, UTC+01:00]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nresult, value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)>`, type: `method`\n\nresult._data, value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, UTC+01:00]`, type: `DatetimeArray`\n\n## Buggy case 77\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, UTC+01:00]`, type: `DatetimeTZDtype`\n\n## Buggy case 78\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... 64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... 64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... 64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... 64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... 64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, UTC+01:00]`, type: `DatetimeTZDtype`\n\n## Buggy case 79\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, UTC+01:00]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2000-06-05 00:00:00+0100', tz='UTC+01:00', freq='B')`, type: `Timestamp`\n\nstart, value: `Timestamp('2000-06-13 00:00:00+0100', tz='UTC+01:00', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nleft._values, value: `<DatetimeArray>\n['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n '2000-06-05 00:00:00+01:00']\nLength: 3, dtype: datetime64[ns, UTC+01:00]`, type: `DatetimeArray`\n\n## Buggy case 80\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, UTC+01:00]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2000-06-05 00:00:00+0100', tz='UTC+01:00', freq='B')`, type: `Timestamp`\n\nstart, value: `Timestamp('2000-06-13 00:00:00+0100', tz='UTC+01:00', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nleft._values, value: `<DatetimeArray>\n['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n '2000-06-05 00:00:00+01:00']\nLength: 3, dtype: datetime64[ns, UTC+01:00]`, type: `DatetimeArray`\n\n## Buggy case 81\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nother, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... oo]', length=20161, freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, foo]`, type: `DatetimeTZDtype`\n\n## Buggy case 82\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... oo]', length=20161, freq='T')>`, type: `method`\n\nself, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... oo]', length=20161, freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... oo]', length=20161, freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... oo]', length=20161, freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... oo]', length=20161, freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... oo]', length=20161, freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, foo]`, type: `DatetimeTZDtype`\n\n## Buggy case 83\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, foo]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nresult, value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)>`, type: `method`\n\nresult._data, value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, foo]`, type: `DatetimeArray`\n\n## Buggy case 84\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, foo]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nresult, value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)>`, type: `method`\n\nresult._data, value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, foo]`, type: `DatetimeArray`\n\n## Buggy case 85\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',\n               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',\n               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',\n               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',\n               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',\n               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',\n               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, foo]`, type: `DatetimeTZDtype`\n\n## Buggy case 86\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... tetime64[ns, foo]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',\n               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',\n               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',\n               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... tetime64[ns, foo]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... tetime64[ns, foo]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... tetime64[ns, foo]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',\n               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',\n               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',\n               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... tetime64[ns, foo]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, foo]`, type: `DatetimeTZDtype`\n\n## Buggy case 87\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, foo]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2000-06-05 00:00:00-0100', tz='foo', freq='B')`, type: `Timestamp`\n\nstart, value: `Timestamp('2000-06-13 00:00:00-0100', tz='foo', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nleft._values, value: `<DatetimeArray>\n['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n '2000-06-05 00:00:00-01:00']\nLength: 3, dtype: datetime64[ns, foo]`, type: `DatetimeArray`\n\n## Buggy case 88\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nself.dtype, value: `datetime64[ns, foo]`, type: `DatetimeTZDtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2000-06-05 00:00:00-0100', tz='foo', freq='B')`, type: `Timestamp`\n\nstart, value: `Timestamp('2000-06-13 00:00:00-0100', tz='foo', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nleft._values, value: `<DatetimeArray>\n['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n '2000-06-05 00:00:00-01:00']\nLength: 3, dtype: datetime64[ns, foo]`, type: `DatetimeArray`\n\n## Buggy case 89\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... e='datetime64[ns]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... e='datetime64[ns]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... e='datetime64[ns]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... e='datetime64[ns]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... e='datetime64[ns]', freq='B')>`, type: `method`\n\nself.dtype, value: `dtype('<M8[ns]')`, type: `dtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='B')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='B')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2011-12-20 00:00:00', freq='B')`, type: `Timestamp`\n\nstart, value: `Timestamp('2011-12-12 00:00:00', freq='B')`, type: `Timestamp`\n\nlslice, value: `slice(8, 15, None)`, type: `slice`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='B')>`, type: `method`\n\nleft_chunk, value: `<DatetimeArray>\n['2011-12-12 00:00:00', '2011-12-13 00:00:00', '2011-12-14 00:00:00',\n '2011-12-15 00:00:00', '2011-12-16 00:00:00', '2011-12-19 00:00:00',\n '2011-12-20 00:00:00']\nLength: 7, dtype: datetime64[ns]`, type: `DatetimeArray`\n\nleft._values, value: `array of shape (23,)`, type: `DatetimeArray`\n\n## Buggy case 90\n### input parameter runtime value and type for buggy function\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... e='datetime64[ns]', freq='C')>`, type: `method`\n\nself, value: `DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='C')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... e='datetime64[ns]', freq='C')>`, type: `method`\n\nother, value: `DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='C')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... e='datetime64[ns]', freq='C')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... e='datetime64[ns]', freq='C')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='C')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='C')>`, type: `method`\n\nother.freq, value: `<CustomBusinessDay>`, type: `CustomBusinessDay`\n\nself.freq, value: `<CustomBusinessDay>`, type: `CustomBusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... e='datetime64[ns]', freq='C')>`, type: `method`\n\nself.dtype, value: `dtype('<M8[ns]')`, type: `dtype`\n\n### variable runtime value and type before buggy function return\nleft, value: `DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='C')`, type: `DatetimeIndex`\n\nright, value: `DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='C')`, type: `DatetimeIndex`\n\nend, value: `Timestamp('2011-12-20 00:00:00', freq='C')`, type: `Timestamp`\n\nstart, value: `Timestamp('2011-12-12 00:00:00', freq='C')`, type: `Timestamp`\n\nlslice, value: `slice(8, 15, None)`, type: `slice`\n\nleft.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='C')>`, type: `method`\n\nleft_chunk, value: `<DatetimeArray>\n['2011-12-12 00:00:00', '2011-12-13 00:00:00', '2011-12-14 00:00:00',\n '2011-12-15 00:00:00', '2011-12-16 00:00:00', '2011-12-19 00:00:00',\n '2011-12-20 00:00:00']\nLength: 7, dtype: datetime64[ns]`, type: `DatetimeArray`\n\nleft._values, value: `array of shape (23,)`, type: `DatetimeArray`\n\n\n\n# Expected variable value and type in tests\n## Expected case 1\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nother, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... TC]', length=20161, freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\n## Expected case 2\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... TC]', length=20161, freq='T')>`, type: `method`\n\nself, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... TC]', length=20161, freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... TC]', length=20161, freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... TC]', length=20161, freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... TC]', length=20161, freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... TC]', length=20161, freq='T')>`, type: `method`\n\n## Expected case 3\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\n### Expected variable value and type before function return\nresult, expected value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)>`, type: `method`\n\nresult._data, expected value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, UTC]`, type: `DatetimeArray`\n\n## Expected case 4\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`\n\n### Expected variable value and type before function return\nresult, expected value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)>`, type: `method`\n\nresult._data, expected value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, UTC]`, type: `DatetimeArray`\n\n## Expected case 5\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\n## Expected case 6\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... tetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... tetime64[ns, UTC]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... tetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... tetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... tetime64[ns, UTC]', freq='B')>`, type: `method`\n\n## Expected case 7\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\n### Expected variable value and type before function return\nleft, expected value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`\n\nright, expected value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`\n\nend, expected value: `Timestamp('2000-06-05 00:00:00+0000', tz='UTC', freq='B')`, type: `Timestamp`\n\nstart, expected value: `Timestamp('2000-06-13 00:00:00+0000', tz='UTC', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`\n\nleft.values, expected value: `array(['2000-06-01T00:00:00.000000000', '2000-06-02T00:00:00.000000000',\n       '2000-06-05T00:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`\n\n## Expected case 8\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nother, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... rn]', length=20161, freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\n## Expected case 9\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... rn]', length=20161, freq='T')>`, type: `method`\n\nself, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... rn]', length=20161, freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... rn]', length=20161, freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... rn]', length=20161, freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... rn]', length=20161, freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... rn]', length=20161, freq='T')>`, type: `method`\n\n## Expected case 10\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\n### Expected variable value and type before function return\nresult, expected value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)>`, type: `method`\n\nresult._data, expected value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, US/Eastern]`, type: `DatetimeArray`\n\n## Expected case 11\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`\n\n### Expected variable value and type before function return\nresult, expected value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)>`, type: `method`\n\nresult._data, expected value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, US/Eastern]`, type: `DatetimeArray`\n\n## Expected case 12\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',\n               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',\n               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',\n               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',\n               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',\n               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',\n               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\n## Expected case 13\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... 4[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',\n               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',\n               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',\n               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... 4[ns, US/Eastern]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... 4[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... 4[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',\n               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',\n               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',\n               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... 4[ns, US/Eastern]', freq='B')>`, type: `method`\n\n## Expected case 14\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\n### Expected variable value and type before function return\nleft, expected value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`\n\nright, expected value: `DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`\n\nend, expected value: `Timestamp('2000-06-05 00:00:00-0400', tz='US/Eastern', freq='B')`, type: `Timestamp`\n\nstart, expected value: `Timestamp('2000-06-13 00:00:00-0400', tz='US/Eastern', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`\n\nleft.values, expected value: `array(['2000-06-01T04:00:00.000000000', '2000-06-02T04:00:00.000000000',\n       '2000-06-05T04:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`\n\n## Expected case 15\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nother, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... yo]', length=20161, freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\n## Expected case 16\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... yo]', length=20161, freq='T')>`, type: `method`\n\nself, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... yo]', length=20161, freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... yo]', length=20161, freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... yo]', length=20161, freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... yo]', length=20161, freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... yo]', length=20161, freq='T')>`, type: `method`\n\n## Expected case 17\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\n### Expected variable value and type before function return\nresult, expected value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)>`, type: `method`\n\nresult._data, expected value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, Asia/Tokyo]`, type: `DatetimeArray`\n\n## Expected case 18\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`\n\n### Expected variable value and type before function return\nresult, expected value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)>`, type: `method`\n\nresult._data, expected value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, Asia/Tokyo]`, type: `DatetimeArray`\n\n## Expected case 19\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',\n               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',\n               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',\n               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',\n               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',\n               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',\n               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\n## Expected case 20\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... 4[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',\n               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',\n               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',\n               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... 4[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... 4[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... 4[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',\n               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',\n               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',\n               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... 4[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\n## Expected case 21\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\n### Expected variable value and type before function return\nleft, expected value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`\n\nright, expected value: `DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`\n\nend, expected value: `Timestamp('2000-06-05 00:00:00+0900', tz='Asia/Tokyo', freq='B')`, type: `Timestamp`\n\nstart, expected value: `Timestamp('2000-06-13 00:00:00+0900', tz='Asia/Tokyo', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`\n\nleft.values, expected value: `array(['2000-05-31T15:00:00.000000000', '2000-06-01T15:00:00.000000000',\n       '2000-06-04T15:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`\n\n## Expected case 22\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nother, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... ')]', length=20161, freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\n## Expected case 23\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... ')]', length=20161, freq='T')>`, type: `method`\n\nself, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... ')]', length=20161, freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... ')]', length=20161, freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... ')]', length=20161, freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... ')]', length=20161, freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... ')]', length=20161, freq='T')>`, type: `method`\n\n## Expected case 24\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\n### Expected variable value and type before function return\nresult, expected value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)>`, type: `method`\n\nresult._data, expected value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeArray`\n\n## Expected case 25\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`\n\n### Expected variable value and type before function return\nresult, expected value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)>`, type: `method`\n\nresult._data, expected value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeArray`\n\n## Expected case 26\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00', '2000-06-06 00:00:00-07:00',\n               '2000-06-07 00:00:00-07:00', '2000-06-08 00:00:00-07:00',\n               '2000-06-09 00:00:00-07:00', '2000-06-12 00:00:00-07:00',\n               '2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... nfo/US/Pacific')]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\n## Expected case 27\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... nfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00', '2000-06-06 00:00:00-07:00',\n               '2000-06-07 00:00:00-07:00', '2000-06-08 00:00:00-07:00',\n               '2000-06-09 00:00:00-07:00', '2000-06-12 00:00:00-07:00',\n               '2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... nfo/US/Pacific')]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... nfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... nfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... nfo/US/Pacific')]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... nfo/US/Pacific')]', freq='B')>`, type: `method`\n\n## Expected case 28\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\n### Expected variable value and type before function return\nleft, expected value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`\n\nright, expected value: `DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`\n\nend, expected value: `Timestamp('2000-06-05 00:00:00-0700', tz='dateutil//usr/share/zoneinfo/US/Pacific', freq='B')`, type: `Timestamp`\n\nstart, expected value: `Timestamp('2000-06-13 00:00:00-0700', tz='dateutil//usr/share/zoneinfo/US/Pacific', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`\n\nleft.values, expected value: `array(['2000-06-01T07:00:00.000000000', '2000-06-02T07:00:00.000000000',\n       '2000-06-05T07:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`\n\n## Expected case 29\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nother, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... ')]', length=20161, freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\n## Expected case 30\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... ')]', length=20161, freq='T')>`, type: `method`\n\nself, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... ')]', length=20161, freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... ')]', length=20161, freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... ')]', length=20161, freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... ')]', length=20161, freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... ')]', length=20161, freq='T')>`, type: `method`\n\n## Expected case 31\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\n### Expected variable value and type before function return\nresult, expected value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)>`, type: `method`\n\nresult._data, expected value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeArray`\n\n## Expected case 32\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`\n\n### Expected variable value and type before function return\nresult, expected value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)>`, type: `method`\n\nresult._data, expected value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeArray`\n\n## Expected case 33\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nother, value: `array of shape (11,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... Asia/Singapore')]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\n## Expected case 34\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... Asia/Singapore')]', freq='B')>`, type: `method`\n\nself, value: `array of shape (11,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... Asia/Singapore')]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... Asia/Singapore')]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... Asia/Singapore')]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... Asia/Singapore')]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... Asia/Singapore')]', freq='B')>`, type: `method`\n\n## Expected case 35\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\n### Expected variable value and type before function return\nleft, expected value: `DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`\n\nright, expected value: `DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`\n\nend, expected value: `Timestamp('2000-06-05 00:00:00+0800', tz='dateutil//usr/share/zoneinfo/Asia/Singapore', freq='B')`, type: `Timestamp`\n\nstart, expected value: `Timestamp('2000-06-13 00:00:00+0800', tz='dateutil//usr/share/zoneinfo/Asia/Singapore', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`\n\nleft.values, expected value: `array(['2000-05-31T16:00:00.000000000', '2000-06-01T16:00:00.000000000',\n       '2000-06-04T16:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`\n\n## Expected case 36\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nother, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... ()]', length=20161, freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\n## Expected case 37\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... ()]', length=20161, freq='T')>`, type: `method`\n\nself, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... ()]', length=20161, freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... ()]', length=20161, freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... ()]', length=20161, freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... ()]', length=20161, freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... ()]', length=20161, freq='T')>`, type: `method`\n\n## Expected case 38\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\n### Expected variable value and type before function return\nresult, expected value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)>`, type: `method`\n\nresult._data, expected value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzutc()]`, type: `DatetimeArray`\n\n## Expected case 39\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`\n\n### Expected variable value and type before function return\nresult, expected value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)>`, type: `method`\n\nresult._data, expected value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzutc()]`, type: `DatetimeArray`\n\n## Expected case 40\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\n## Expected case 41\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... me64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... me64[ns, tzutc()]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... me64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... me64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... me64[ns, tzutc()]', freq='B')>`, type: `method`\n\n## Expected case 42\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\n### Expected variable value and type before function return\nleft, expected value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`\n\nright, expected value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`\n\nend, expected value: `Timestamp('2000-06-05 00:00:00+0000', tz='tzutc()', freq='B')`, type: `Timestamp`\n\nstart, expected value: `Timestamp('2000-06-13 00:00:00+0000', tz='tzutc()', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`\n\nleft.values, expected value: `array(['2000-06-01T00:00:00.000000000', '2000-06-02T00:00:00.000000000',\n       '2000-06-05T00:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`\n\n## Expected case 43\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nother, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... ()]', length=20161, freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\n## Expected case 44\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... ()]', length=20161, freq='T')>`, type: `method`\n\nself, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... ()]', length=20161, freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... ()]', length=20161, freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... ()]', length=20161, freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... ()]', length=20161, freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... ()]', length=20161, freq='T')>`, type: `method`\n\n## Expected case 45\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\n### Expected variable value and type before function return\nresult, expected value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)>`, type: `method`\n\nresult._data, expected value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzlocal()]`, type: `DatetimeArray`\n\n## Expected case 46\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`\n\n### Expected variable value and type before function return\nresult, expected value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)>`, type: `method`\n\nresult._data, expected value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzlocal()]`, type: `DatetimeArray`\n\n## Expected case 47\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\n## Expected case 48\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... 64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... 64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... 64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... 64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... 64[ns, tzlocal()]', freq='B')>`, type: `method`\n\n## Expected case 49\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\n### Expected variable value and type before function return\nleft, expected value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`\n\nright, expected value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`\n\nend, expected value: `Timestamp('2000-06-05 00:00:00+0100', tz='tzlocal()', freq='B')`, type: `Timestamp`\n\nstart, expected value: `Timestamp('2000-06-13 00:00:00+0100', tz='tzlocal()', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`\n\nleft.values, expected value: `array(['2000-05-31T23:00:00.000000000', '2000-06-01T23:00:00.000000000',\n       '2000-06-04T23:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`\n\n## Expected case 50\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nother, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\n## Expected case 51\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... 0)]', length=20161, freq='T')>`, type: `method`\n\nself, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... 0)]', length=20161, freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... 0)]', length=20161, freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... 0)]', length=20161, freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... 0)]', length=20161, freq='T')>`, type: `method`\n\n## Expected case 52\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\n### Expected variable value and type before function return\nresult, expected value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)>`, type: `method`\n\nresult._data, expected value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeArray`\n\n## Expected case 53\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`\n\n### Expected variable value and type before function return\nresult, expected value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)>`, type: `method`\n\nresult._data, expected value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeArray`\n\n## Expected case 54\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00', '2000-06-06 00:00:00+05:00',\n               '2000-06-07 00:00:00+05:00', '2000-06-08 00:00:00+05:00',\n               '2000-06-09 00:00:00+05:00', '2000-06-12 00:00:00+05:00',\n               '2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... FixedOffset(300)]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\n## Expected case 55\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... FixedOffset(300)]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00', '2000-06-06 00:00:00+05:00',\n               '2000-06-07 00:00:00+05:00', '2000-06-08 00:00:00+05:00',\n               '2000-06-09 00:00:00+05:00', '2000-06-12 00:00:00+05:00',\n               '2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... FixedOffset(300)]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... FixedOffset(300)]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... FixedOffset(300)]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... FixedOffset(300)]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... FixedOffset(300)]', freq='B')>`, type: `method`\n\n## Expected case 56\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\n### Expected variable value and type before function return\nleft, expected value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`\n\nright, expected value: `DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`\n\nend, expected value: `Timestamp('2000-06-05 00:00:00+0500', tz='pytz.FixedOffset(300)', freq='B')`, type: `Timestamp`\n\nstart, expected value: `Timestamp('2000-06-13 00:00:00+0500', tz='pytz.FixedOffset(300)', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`\n\nleft.values, expected value: `array(['2000-05-31T19:00:00.000000000', '2000-06-01T19:00:00.000000000',\n       '2000-06-04T19:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`\n\n## Expected case 57\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nother, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\n## Expected case 58\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... 0)]', length=20161, freq='T')>`, type: `method`\n\nself, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... 0)]', length=20161, freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... 0)]', length=20161, freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... 0)]', length=20161, freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... 0)]', length=20161, freq='T')>`, type: `method`\n\n## Expected case 59\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\n### Expected variable value and type before function return\nresult, expected value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)>`, type: `method`\n\nresult._data, expected value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeArray`\n\n## Expected case 60\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`\n\n### Expected variable value and type before function return\nresult, expected value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)>`, type: `method`\n\nresult._data, expected value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeArray`\n\n## Expected case 61\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00', '2000-06-06 00:00:00-05:00',\n               '2000-06-07 00:00:00-05:00', '2000-06-08 00:00:00-05:00',\n               '2000-06-09 00:00:00-05:00', '2000-06-12 00:00:00-05:00',\n               '2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... ixedOffset(-300)]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\n## Expected case 62\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... ixedOffset(-300)]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00', '2000-06-06 00:00:00-05:00',\n               '2000-06-07 00:00:00-05:00', '2000-06-08 00:00:00-05:00',\n               '2000-06-09 00:00:00-05:00', '2000-06-12 00:00:00-05:00',\n               '2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... ixedOffset(-300)]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... ixedOffset(-300)]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... ixedOffset(-300)]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... ixedOffset(-300)]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... ixedOffset(-300)]', freq='B')>`, type: `method`\n\n## Expected case 63\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\n### Expected variable value and type before function return\nleft, expected value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`\n\nright, expected value: `DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`\n\nend, expected value: `Timestamp('2000-06-05 00:00:00-0500', tz='pytz.FixedOffset(-300)', freq='B')`, type: `Timestamp`\n\nstart, expected value: `Timestamp('2000-06-13 00:00:00-0500', tz='pytz.FixedOffset(-300)', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`\n\nleft.values, expected value: `array(['2000-06-01T05:00:00.000000000', '2000-06-02T05:00:00.000000000',\n       '2000-06-05T05:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`\n\n## Expected case 64\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nother, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... 00]', length=20161, freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\n## Expected case 65\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... 00]', length=20161, freq='T')>`, type: `method`\n\nself, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... 00]', length=20161, freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... 00]', length=20161, freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... 00]', length=20161, freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... 00]', length=20161, freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... 00]', length=20161, freq='T')>`, type: `method`\n\n## Expected case 66\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\n### Expected variable value and type before function return\nresult, expected value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)>`, type: `method`\n\nresult._data, expected value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, UTC+01:00]`, type: `DatetimeArray`\n\n## Expected case 67\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`\n\n### Expected variable value and type before function return\nresult, expected value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)>`, type: `method`\n\nresult._data, expected value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, UTC+01:00]`, type: `DatetimeArray`\n\n## Expected case 68\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\n## Expected case 69\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... 64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... 64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... 64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... 64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... 64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\n## Expected case 70\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\n### Expected variable value and type before function return\nleft, expected value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`\n\nright, expected value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`\n\nend, expected value: `Timestamp('2000-06-05 00:00:00+0100', tz='UTC+01:00', freq='B')`, type: `Timestamp`\n\nstart, expected value: `Timestamp('2000-06-13 00:00:00+0100', tz='UTC+01:00', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`\n\nleft.values, expected value: `array(['2000-05-31T23:00:00.000000000', '2000-06-01T23:00:00.000000000',\n       '2000-06-04T23:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`\n\n## Expected case 71\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nother, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of Da ... oo]', length=20161, freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\n## Expected case 72\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... oo]', length=20161, freq='T')>`, type: `method`\n\nself, value: `array of shape (20161,)`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... oo]', length=20161, freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... oo]', length=20161, freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... oo]', length=20161, freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of Da ... oo]', length=20161, freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... oo]', length=20161, freq='T')>`, type: `method`\n\n## Expected case 73\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\n### Expected variable value and type before function return\nresult, expected value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)>`, type: `method`\n\nresult._data, expected value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, foo]`, type: `DatetimeArray`\n\n## Expected case 74\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\nother.freq, value: `<Minute>`, type: `Minute`\n\nself.freq, value: `<Minute>`, type: `Minute`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`\n\n### Expected variable value and type before function return\nresult, expected value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)`, type: `DatetimeIndex`\n\nresult._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)>`, type: `method`\n\nresult._data, expected value: `<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, foo]`, type: `DatetimeArray`\n\n## Expected case 75\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',\n               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',\n               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',\n               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',\n               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',\n               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',\n               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\n## Expected case 76\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... tetime64[ns, foo]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',\n               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',\n               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',\n               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... tetime64[ns, foo]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... tetime64[ns, foo]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... tetime64[ns, foo]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',\n               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',\n               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',\n               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... tetime64[ns, foo]', freq='B')>`, type: `method`\n\n## Expected case 77\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\n### Expected variable value and type before function return\nleft, expected value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`\n\nright, expected value: `DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`\n\nend, expected value: `Timestamp('2000-06-05 00:00:00-0100', tz='foo', freq='B')`, type: `Timestamp`\n\nstart, expected value: `Timestamp('2000-06-13 00:00:00-0100', tz='foo', freq='B')`, type: `Timestamp`\n\nleft.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`\n\nleft.values, expected value: `array(['2000-06-01T01:00:00.000000000', '2000-06-02T01:00:00.000000000',\n       '2000-06-05T01:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`\n\n## Expected case 78\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... e='datetime64[ns]', freq='B')>`, type: `method`\n\nself, value: `DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='B')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... e='datetime64[ns]', freq='B')>`, type: `method`\n\nother, value: `DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='B')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... e='datetime64[ns]', freq='B')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... e='datetime64[ns]', freq='B')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='B')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='B')>`, type: `method`\n\nother.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.freq, value: `<BusinessDay>`, type: `BusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... e='datetime64[ns]', freq='B')>`, type: `method`\n\n### Expected variable value and type before function return\nleft, expected value: `DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='B')`, type: `DatetimeIndex`\n\nright, expected value: `DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='B')`, type: `DatetimeIndex`\n\nend, expected value: `Timestamp('2011-12-20 00:00:00', freq='B')`, type: `Timestamp`\n\nstart, expected value: `Timestamp('2011-12-12 00:00:00', freq='B')`, type: `Timestamp`\n\nlslice, expected value: `slice(8, 15, None)`, type: `slice`\n\nleft.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='B')>`, type: `method`\n\nleft_chunk, expected value: `array(['2011-12-12T00:00:00.000000000', '2011-12-13T00:00:00.000000000',\n       '2011-12-14T00:00:00.000000000', '2011-12-15T00:00:00.000000000',\n       '2011-12-16T00:00:00.000000000', '2011-12-19T00:00:00.000000000',\n       '2011-12-20T00:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`\n\nleft.values, expected value: `array of shape (23,)`, type: `ndarray`\n\n## Expected case 79\n### Input parameter value and type\nself._validate_sort_keyword, value: `<bound method Index._validate_ ... e='datetime64[ns]', freq='C')>`, type: `method`\n\nself, value: `DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='C')`, type: `DatetimeIndex`\n\nsort, value: `False`, type: `bool`\n\nself._assert_can_do_setop, value: `<bound method Index._assert_ca ... e='datetime64[ns]', freq='C')>`, type: `method`\n\nother, value: `DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='C')`, type: `DatetimeIndex`\n\nself.equals, value: `<bound method DatetimeIndexOps ... e='datetime64[ns]', freq='C')>`, type: `method`\n\nself._get_reconciled_name_object, value: `<bound method Index._get_recon ... e='datetime64[ns]', freq='C')>`, type: `method`\n\nself.copy, value: `<bound method Index.copy of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='C')>`, type: `method`\n\nother.copy, value: `<bound method Index.copy of DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='C')>`, type: `method`\n\nother.freq, value: `<CustomBusinessDay>`, type: `CustomBusinessDay`\n\nself.freq, value: `<CustomBusinessDay>`, type: `CustomBusinessDay`\n\nself.is_monotonic, value: `True`, type: `bool`\n\nother.is_monotonic, value: `True`, type: `bool`\n\nself._shallow_copy, value: `<bound method DatetimeTimedelt ... e='datetime64[ns]', freq='C')>`, type: `method`\n\n### Expected variable value and type before function return\nleft, expected value: `DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='C')`, type: `DatetimeIndex`\n\nright, expected value: `DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='C')`, type: `DatetimeIndex`\n\nend, expected value: `Timestamp('2011-12-20 00:00:00', freq='C')`, type: `Timestamp`\n\nstart, expected value: `Timestamp('2011-12-12 00:00:00', freq='C')`, type: `Timestamp`\n\nlslice, expected value: `slice(8, 15, None)`, type: `slice`\n\nleft.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='C')>`, type: `method`\n\nleft_chunk, expected value: `array(['2011-12-12T00:00:00.000000000', '2011-12-13T00:00:00.000000000',\n       '2011-12-14T00:00:00.000000000', '2011-12-15T00:00:00.000000000',\n       '2011-12-16T00:00:00.000000000', '2011-12-19T00:00:00.000000000',\n       '2011-12-20T00:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`\n\nleft.values, expected value: `array of shape (23,)`, type: `ndarray`\n\n\n\n",
    "6": "",
    "7": "# Instructions\n\n1. Analyze the test case and its relationship with the error message, if applicable.\n2. Identify the potential error location within the problematic function.\n3. Explain the reasons behind the occurrence of the bug.\n4. Suggest possible approaches for fixing the bug.\n5. Present the corrected code for the problematic function."
}