{
    "pandas:143": {
        "/home/ubuntu/Desktop/bgp_envs_local/repos/pandas_143/pandas/core/indexes/range.py": {
            "buggy_functions": [
                {
                    "function_name": "get_indexer",
                    "function_code": "@Appender(_index_shared_docs[\"get_indexer\"])\ndef get_indexer(self, target, method=None, limit=None, tolerance=None):\n    if not (method is None and tolerance is None and is_list_like(target)):\n        return super().get_indexer(target, method=method, tolerance=tolerance)\n\n    if self.step > 0:\n        start, stop, step = self.start, self.stop, self.step\n    else:\n        # Work on reversed range for simplicity:\n        start, stop, step = (self.stop - self.step, self.start + 1, -self.step)\n\n    target_array = np.asarray(target)\n    if not (is_integer_dtype(target_array) and target_array.ndim == 1):\n        # checks/conversions/roundings are delegated to general method\n        return super().get_indexer(target, method=method, tolerance=tolerance)\n\n    locs = target_array - start\n    valid = (locs % step == 0) & (locs >= 0) & (target_array < stop)\n    locs[~valid] = -1\n    locs[valid] = locs[valid] / step\n\n    if step != self.step:\n        # We reversed this range: transform to original locs\n        locs[valid] = len(self) - 1 - locs[valid]\n    return ensure_platform_int(locs)\n",
                    "decorators": [
                        "Appender(_index_shared_docs['get_indexer'])"
                    ],
                    "docstring": null,
                    "start_line": 381,
                    "end_line": 405,
                    "variables": {
                        "method": [
                            384,
                            395,
                            383
                        ],
                        "tolerance": [
                            384,
                            395,
                            383
                        ],
                        "is_list_like": [
                            383
                        ],
                        "target": [
                            384,
                            395,
                            392,
                            383
                        ],
                        "get_indexer": [
                            384,
                            395
                        ],
                        "super": [
                            384,
                            395
                        ],
                        "self.step": [
                            386,
                            387,
                            390,
                            402
                        ],
                        "self": [
                            386,
                            387,
                            390,
                            402,
                            404
                        ],
                        "start": [
                            387,
                            397,
                            390
                        ],
                        "stop": [
                            398,
                            387,
                            390
                        ],
                        "step": [
                            387,
                            390,
                            398,
                            400,
                            402
                        ],
                        "self.start": [
                            387,
                            390
                        ],
                        "self.stop": [
                            387,
                            390
                        ],
                        "target_array": [
                            392,
                            393,
                            397,
                            398
                        ],
                        "np.asarray": [
                            392
                        ],
                        "np": [
                            392
                        ],
                        "is_integer_dtype": [
                            393
                        ],
                        "target_array.ndim": [
                            393
                        ],
                        "locs": [
                            397,
                            398,
                            399,
                            400,
                            404,
                            405
                        ],
                        "valid": [
                            400,
                            404,
                            398,
                            399
                        ],
                        "len": [
                            404
                        ],
                        "ensure_platform_int": [
                            405
                        ],
                        "Appender": [
                            381
                        ],
                        "_index_shared_docs": [
                            381
                        ]
                    },
                    "filtered_variables": {
                        "method": [
                            384,
                            395,
                            383
                        ],
                        "tolerance": [
                            384,
                            395,
                            383
                        ],
                        "is_list_like": [
                            383
                        ],
                        "target": [
                            384,
                            395,
                            392,
                            383
                        ],
                        "get_indexer": [
                            384,
                            395
                        ],
                        "self.step": [
                            386,
                            387,
                            390,
                            402
                        ],
                        "self": [
                            386,
                            387,
                            390,
                            402,
                            404
                        ],
                        "start": [
                            387,
                            397,
                            390
                        ],
                        "stop": [
                            398,
                            387,
                            390
                        ],
                        "step": [
                            387,
                            390,
                            398,
                            400,
                            402
                        ],
                        "self.start": [
                            387,
                            390
                        ],
                        "self.stop": [
                            387,
                            390
                        ],
                        "target_array": [
                            392,
                            393,
                            397,
                            398
                        ],
                        "np.asarray": [
                            392
                        ],
                        "np": [
                            392
                        ],
                        "is_integer_dtype": [
                            393
                        ],
                        "target_array.ndim": [
                            393
                        ],
                        "locs": [
                            397,
                            398,
                            399,
                            400,
                            404,
                            405
                        ],
                        "valid": [
                            400,
                            404,
                            398,
                            399
                        ],
                        "ensure_platform_int": [
                            405
                        ],
                        "Appender": [
                            381
                        ],
                        "_index_shared_docs": [
                            381
                        ]
                    },
                    "diff_line_number": 383,
                    "class_data": {
                        "signature": "class RangeIndex(Int64Index)",
                        "docstring": "Immutable Index implementing a monotonic integer range.\n\nRangeIndex is a memory-saving special case of Int64Index limited to\nrepresenting monotonic ranges. Using RangeIndex may in some instances\nimprove computing speed.\n\nThis is the default index type used\nby DataFrame and Series when no explicit index is provided by the user.\n\nParameters\n----------\nstart : int (default: 0), or other RangeIndex instance\n    If int and \"stop\" is not given, interpreted as \"stop\" instead.\nstop : int (default: 0)\nstep : int (default: 1)\nname : object, optional\n    Name to be stored in the index\ncopy : bool, default False\n    Unused, accepted for homogeneity with other index types.\n\nAttributes\n----------\nstart\nstop\nstep\n\nMethods\n-------\nfrom_range\n\nSee Also\n--------\nIndex : The base pandas Index type.\nInt64Index : Index of int64 data.",
                        "constructor_docstring": null,
                        "functions": [
                            "def __new__(cls, start=None, stop=None, step=None, dtype=None, copy=False, name=None, fastpath=None):\n    if fastpath is not None:\n        warnings.warn(\"The 'fastpath' keyword is deprecated, and will be removed in a future version.\", FutureWarning, stacklevel=2)\n        if fastpath:\n            return cls._simple_new(range(start, stop, step), name=name)\n    cls._validate_dtype(dtype)\n    if isinstance(start, RangeIndex):\n        name = start.name if name is None else name\n        start = start._range\n        return cls._simple_new(start, dtype=dtype, name=name)\n    if com.all_none(start, stop, step):\n        raise TypeError('RangeIndex(...) must be called with integers')\n    start = ensure_python_int(start) if start is not None else 0\n    if stop is None:\n        (start, stop) = (0, start)\n    else:\n        stop = ensure_python_int(stop)\n    step = ensure_python_int(step) if step is not None else 1\n    if step == 0:\n        raise ValueError('Step must not be zero')\n    rng = range(start, stop, step)\n    return cls._simple_new(rng, dtype=dtype, name=name)",
                            "@classmethod\ndef from_range(cls, data, name=None, dtype=None):\n    \"\"\"\n    Create RangeIndex from a range object.\n\n    Returns\n    -------\n    RangeIndex\n    \"\"\"\n    if not isinstance(data, range):\n        raise TypeError('{0}(...) must be called with object coercible to a range, {1} was passed'.format(cls.__name__, repr(data)))\n    cls._validate_dtype(dtype)\n    return cls._simple_new(data, dtype=dtype, name=name)",
                            "@classmethod\ndef _simple_new(cls, values, name=None, dtype=None, **kwargs):\n    result = object.__new__(cls)\n    if values is None:\n        values = range(0, 0, 1)\n    elif not isinstance(values, range):\n        return Index(values, dtype=dtype, name=name, **kwargs)\n    result._range = values\n    result.name = name\n    for (k, v) in kwargs.items():\n        setattr(result, k, v)\n    result._reset_identity()\n    return result",
                            "@staticmethod\ndef _validate_dtype(dtype):\n    \"\"\" require dtype to be None or int64 \"\"\"\n    if not (dtype is None or is_int64_dtype(dtype)):\n        raise TypeError('Invalid to pass a non-int64 dtype to RangeIndex')",
                            "@cache_readonly\ndef _constructor(self):\n    \"\"\" return the class to use for construction \"\"\"\n    return Int64Index",
                            "@property\ndef _data(self):\n    \"\"\"\n    An int array that for performance reasons is created only when needed.\n\n    The constructed array is saved in ``_cached_data``. This allows us to\n    check if the array has been created without accessing ``_data`` and\n    triggering the construction.\n    \"\"\"\n    if self._cached_data is None:\n        self._cached_data = np.arange(self.start, self.stop, self.step, dtype=np.int64)\n    return self._cached_data",
                            "@cache_readonly\ndef _int64index(self):\n    return Int64Index._simple_new(self._data, name=self.name)",
                            "def _get_data_as_items(self):\n    \"\"\" return a list of tuples of start, stop, step \"\"\"\n    rng = self._range\n    return [('start', rng.start), ('stop', rng.stop), ('step', rng.step)]",
                            "def __reduce__(self):\n    d = self._get_attributes_dict()\n    d.update(dict(self._get_data_as_items()))\n    return (ibase._new_Index, (self.__class__, d), None)",
                            "def _format_attrs(self):\n    \"\"\"\n    Return a list of tuples of the (attr, formatted_value)\n    \"\"\"\n    attrs = self._get_data_as_items()\n    if self.name is not None:\n        attrs.append(('name', ibase.default_pprint(self.name)))\n    return attrs",
                            "def _format_data(self, name=None):\n    return None",
                            "def _format_with_header(self, header, na_rep='NaN', **kwargs):\n    return header + list(map(pprint_thing, self._range))",
                            "@cache_readonly\ndef start(self):\n    \"\"\"\n    The value of the `start` parameter (``0`` if this was not supplied).\n    \"\"\"\n    return self._range.start",
                            "@property\ndef _start(self):\n    \"\"\"\n    The value of the `start` parameter (``0`` if this was not supplied).\n\n     .. deprecated:: 0.25.0\n        Use ``start`` instead.\n    \"\"\"\n    warnings.warn(self._deprecation_message.format('_start', 'start'), DeprecationWarning, stacklevel=2)\n    return self.start",
                            "@cache_readonly\ndef stop(self):\n    \"\"\"\n    The value of the `stop` parameter.\n    \"\"\"\n    return self._range.stop",
                            "@property\ndef _stop(self):\n    \"\"\"\n    The value of the `stop` parameter.\n\n     .. deprecated:: 0.25.0\n        Use ``stop`` instead.\n    \"\"\"\n    warnings.warn(self._deprecation_message.format('_stop', 'stop'), DeprecationWarning, stacklevel=2)\n    return self.stop",
                            "@cache_readonly\ndef step(self):\n    \"\"\"\n    The value of the `step` parameter (``1`` if this was not supplied).\n    \"\"\"\n    return self._range.step",
                            "@property\ndef _step(self):\n    \"\"\"\n    The value of the `step` parameter (``1`` if this was not supplied).\n\n     .. deprecated:: 0.25.0\n        Use ``step`` instead.\n    \"\"\"\n    warnings.warn(self._deprecation_message.format('_step', 'step'), DeprecationWarning, stacklevel=2)\n    return self.step",
                            "@cache_readonly\ndef nbytes(self):\n    \"\"\"\n    Return the number of bytes in the underlying data.\n    \"\"\"\n    rng = self._range\n    return getsizeof(rng) + sum((getsizeof(getattr(rng, attr_name)) for attr_name in ['start', 'stop', 'step']))",
                            "def memory_usage(self, deep=False):\n    \"\"\"\n    Memory usage of my values\n\n    Parameters\n    ----------\n    deep : bool\n        Introspect the data deeply, interrogate\n        `object` dtypes for system-level memory consumption\n\n    Returns\n    -------\n    bytes used\n\n    Notes\n    -----\n    Memory usage does not include memory consumed by elements that\n    are not components of the array if deep=False\n\n    See Also\n    --------\n    numpy.ndarray.nbytes\n    \"\"\"\n    return self.nbytes",
                            "@property\ndef dtype(self):\n    return np.dtype(np.int64)",
                            "@property\ndef is_unique(self):\n    \"\"\" return if the index has unique values \"\"\"\n    return True",
                            "@cache_readonly\ndef is_monotonic_increasing(self):\n    return self._range.step > 0 or len(self) <= 1",
                            "@cache_readonly\ndef is_monotonic_decreasing(self):\n    return self._range.step < 0 or len(self) <= 1",
                            "@property\ndef has_duplicates(self):\n    return False",
                            "def __contains__(self, key: Union[int, np.integer]) -> bool:\n    hash(key)\n    try:\n        key = ensure_python_int(key)\n    except TypeError:\n        return False\n    return key in self._range",
                            "@Appender(_index_shared_docs['get_loc'])\ndef get_loc(self, key, method=None, tolerance=None):\n    if is_integer(key) and method is None and (tolerance is None):\n        new_key = int(key)\n        try:\n            return self._range.index(new_key)\n        except ValueError:\n            raise KeyError(key)\n    return super().get_loc(key, method=method, tolerance=tolerance)",
                            "@Appender(_index_shared_docs['get_indexer'])\ndef get_indexer(self, target, method=None, limit=None, tolerance=None):\n    if not (method is None and tolerance is None and is_list_like(target)):\n        return super().get_indexer(target, method=method, tolerance=tolerance)\n    if self.step > 0:\n        (start, stop, step) = (self.start, self.stop, self.step)\n    else:\n        (start, stop, step) = (self.stop - self.step, self.start + 1, -self.step)\n    target_array = np.asarray(target)\n    if not (is_integer_dtype(target_array) and target_array.ndim == 1):\n        return super().get_indexer(target, method=method, tolerance=tolerance)\n    locs = target_array - start\n    valid = (locs % step == 0) & (locs >= 0) & (target_array < stop)\n    locs[~valid] = -1\n    locs[valid] = locs[valid] / step\n    if step != self.step:\n        locs[valid] = len(self) - 1 - locs[valid]\n    return ensure_platform_int(locs)",
                            "def tolist(self):\n    return list(self._range)",
                            "@Appender(_index_shared_docs['_shallow_copy'])\ndef _shallow_copy(self, values=None, **kwargs):\n    if values is None:\n        name = kwargs.get('name', self.name)\n        return self._simple_new(self._range, name=name)\n    else:\n        kwargs.setdefault('name', self.name)\n        return self._int64index._shallow_copy(values, **kwargs)",
                            "@Appender(ibase._index_shared_docs['copy'])\ndef copy(self, name=None, deep=False, dtype=None, **kwargs):\n    self._validate_dtype(dtype)\n    if name is None:\n        name = self.name\n    return self.from_range(self._range, name=name)",
                            "def _minmax(self, meth):\n    no_steps = len(self) - 1\n    if no_steps == -1:\n        return np.nan\n    elif meth == 'min' and self.step > 0 or (meth == 'max' and self.step < 0):\n        return self.start\n    return self.start + self.step * no_steps",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"The minimum value of the RangeIndex\"\"\"\n    nv.validate_minmax_axis(axis)\n    nv.validate_min(args, kwargs)\n    return self._minmax('min')",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"The maximum value of the RangeIndex\"\"\"\n    nv.validate_minmax_axis(axis)\n    nv.validate_max(args, kwargs)\n    return self._minmax('max')",
                            "def argsort(self, *args, **kwargs):\n    \"\"\"\n    Returns the indices that would sort the index and its\n    underlying data.\n\n    Returns\n    -------\n    argsorted : numpy array\n\n    See Also\n    --------\n    numpy.ndarray.argsort\n    \"\"\"\n    nv.validate_argsort(args, kwargs)\n    if self._range.step > 0:\n        return np.arange(len(self))\n    else:\n        return np.arange(len(self) - 1, -1, -1)",
                            "def equals(self, other):\n    \"\"\"\n    Determines if two Index objects contain the same elements.\n    \"\"\"\n    if isinstance(other, RangeIndex):\n        return self._range == other._range\n    return super().equals(other)",
                            "def intersection(self, other, sort=False):\n    \"\"\"\n    Form the intersection of two Index objects.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : False or None, default False\n        Sort the resulting index if possible\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default to ``False`` to match the behaviour\n           from before 0.24.0.\n\n    Returns\n    -------\n    intersection : Index\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    if self.equals(other):\n        return self._get_reconciled_name_object(other)\n    if not isinstance(other, RangeIndex):\n        return super().intersection(other, sort=sort)\n    if not len(self) or not len(other):\n        return self._simple_new(None)\n    first = self._range[::-1] if self.step < 0 else self._range\n    second = other._range[::-1] if other.step < 0 else other._range\n    int_low = max(first.start, second.start)\n    int_high = min(first.stop, second.stop)\n    if int_high <= int_low:\n        return self._simple_new(None)\n    (gcd, s, t) = self._extended_gcd(first.step, second.step)\n    if (first.start - second.start) % gcd:\n        return self._simple_new(None)\n    tmp_start = first.start + (second.start - first.start) * first.step // gcd * s\n    new_step = first.step * second.step // gcd\n    new_range = range(tmp_start, int_high, new_step)\n    new_index = self._simple_new(new_range)\n    new_start = new_index._min_fitting_element(int_low)\n    new_range = range(new_start, new_index.stop, new_index.step)\n    new_index = self._simple_new(new_range)\n    if (self.step < 0 and other.step < 0) is not (new_index.step < 0):\n        new_index = new_index[::-1]\n    if sort is None:\n        new_index = new_index.sort_values()\n    return new_index",
                            "def _min_fitting_element(self, lower_limit):\n    \"\"\"Returns the smallest element greater than or equal to the limit\"\"\"\n    no_steps = -(-(lower_limit - self.start) // abs(self.step))\n    return self.start + abs(self.step) * no_steps",
                            "def _max_fitting_element(self, upper_limit):\n    \"\"\"Returns the largest element smaller than or equal to the limit\"\"\"\n    no_steps = (upper_limit - self.start) // abs(self.step)\n    return self.start + abs(self.step) * no_steps",
                            "def _extended_gcd(self, a, b):\n    \"\"\"\n    Extended Euclidean algorithms to solve Bezout's identity:\n       a*x + b*y = gcd(x, y)\n    Finds one particular solution for x, y: s, t\n    Returns: gcd, s, t\n    \"\"\"\n    (s, old_s) = (0, 1)\n    (t, old_t) = (1, 0)\n    (r, old_r) = (b, a)\n    while r:\n        quotient = old_r // r\n        (old_r, r) = (r, old_r - quotient * r)\n        (old_s, s) = (s, old_s - quotient * s)\n        (old_t, t) = (t, old_t - quotient * t)\n    return (old_r, old_s, old_t)",
                            "def _union(self, other, sort):\n    \"\"\"\n    Form the union of two Index objects and sorts if possible\n\n    Parameters\n    ----------\n    other : Index or array-like\n\n    sort : False or None, default None\n        Whether to sort resulting index. ``sort=None`` returns a\n        monotonically increasing ``RangeIndex`` if possible or a sorted\n        ``Int64Index`` if not. ``sort=False`` always returns an\n        unsorted ``Int64Index``\n\n        .. versionadded:: 0.25.0\n\n    Returns\n    -------\n    union : Index\n    \"\"\"\n    if not len(other) or self.equals(other) or (not len(self)):\n        return super()._union(other, sort=sort)\n    if isinstance(other, RangeIndex) and sort is None:\n        (start_s, step_s) = (self.start, self.step)\n        end_s = self.start + self.step * (len(self) - 1)\n        (start_o, step_o) = (other.start, other.step)\n        end_o = other.start + other.step * (len(other) - 1)\n        if self.step < 0:\n            (start_s, step_s, end_s) = (end_s, -step_s, start_s)\n        if other.step < 0:\n            (start_o, step_o, end_o) = (end_o, -step_o, start_o)\n        if len(self) == 1 and len(other) == 1:\n            step_s = step_o = abs(self.start - other.start)\n        elif len(self) == 1:\n            step_s = step_o\n        elif len(other) == 1:\n            step_o = step_s\n        start_r = min(start_s, start_o)\n        end_r = max(end_s, end_o)\n        if step_o == step_s:\n            if (start_s - start_o) % step_s == 0 and start_s - end_o <= step_s and (start_o - end_s <= step_s):\n                return self.__class__(start_r, end_r + step_s, step_s)\n            if step_s % 2 == 0 and abs(start_s - start_o) <= step_s / 2 and (abs(end_s - end_o) <= step_s / 2):\n                return self.__class__(start_r, end_r + step_s / 2, step_s / 2)\n        elif step_o % step_s == 0:\n            if (start_o - start_s) % step_s == 0 and start_o + step_s >= start_s and (end_o - step_s <= end_s):\n                return self.__class__(start_r, end_r + step_s, step_s)\n        elif step_s % step_o == 0:\n            if (start_s - start_o) % step_o == 0 and start_s + step_o >= start_o and (end_s - step_o <= end_o):\n                return self.__class__(start_r, end_r + step_o, step_o)\n    return self._int64index._union(other, sort=sort)",
                            "@Appender(_index_shared_docs['join'])\ndef join(self, other, how='left', level=None, return_indexers=False, sort=False):\n    if how == 'outer' and self is not other:\n        return self._int64index.join(other, how, level, return_indexers, sort)\n    return super().join(other, how, level, return_indexers, sort)",
                            "def _concat_same_dtype(self, indexes, name):\n    \"\"\"\n    Concatenates multiple RangeIndex instances. All members of \"indexes\" must\n    be of type RangeIndex; result will be RangeIndex if possible, Int64Index\n    otherwise. E.g.:\n    indexes = [RangeIndex(3), RangeIndex(3, 6)] -> RangeIndex(6)\n    indexes = [RangeIndex(3), RangeIndex(4, 6)] -> Int64Index([0,1,2,4,5])\n    \"\"\"\n    start = step = next_ = None\n    non_empty_indexes = [obj for obj in indexes if len(obj)]\n    for obj in non_empty_indexes:\n        rng = obj._range\n        if start is None:\n            start = rng.start\n            if step is None and len(rng) > 1:\n                step = rng.step\n        elif step is None:\n            if rng.start == start:\n                result = Int64Index(np.concatenate([x._values for x in indexes]))\n                return result.rename(name)\n            step = rng.start - start\n        non_consecutive = step != rng.step and len(rng) > 1 or (next_ is not None and rng.start != next_)\n        if non_consecutive:\n            result = Int64Index(np.concatenate([x._values for x in indexes]))\n            return result.rename(name)\n        if step is not None:\n            next_ = rng[-1] + step\n    if non_empty_indexes:\n        stop = non_empty_indexes[-1].stop if next_ is None else next_\n        return RangeIndex(start, stop, step).rename(name)\n    return RangeIndex(0, 0).rename(name)",
                            "def __len__(self):\n    \"\"\"\n    return the length of the RangeIndex\n    \"\"\"\n    return len(self._range)",
                            "@property\ndef size(self):\n    return len(self)",
                            "def __getitem__(self, key):\n    \"\"\"\n    Conserve RangeIndex type for scalar and slice keys.\n    \"\"\"\n    if isinstance(key, slice):\n        new_range = self._range[key]\n        return self._simple_new(new_range, name=self.name)\n    elif is_integer(key):\n        new_key = int(key)\n        try:\n            return self._range[new_key]\n        except IndexError:\n            raise IndexError('index {key} is out of bounds for axis 0 with size {size}'.format(key=key, size=len(self)))\n    elif is_scalar(key):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    return super().__getitem__(key)",
                            "def __floordiv__(self, other):\n    if isinstance(other, (ABCSeries, ABCDataFrame)):\n        return NotImplemented\n    if is_integer(other) and other != 0:\n        if len(self) == 0 or (self.start % other == 0 and self.step % other == 0):\n            start = self.start // other\n            step = self.step // other\n            stop = start + len(self) * step\n            new_range = range(start, stop, step or 1)\n            return self._simple_new(new_range, name=self.name)\n        if len(self) == 1:\n            start = self.start // other\n            new_range = range(start, start + 1, 1)\n            return self._simple_new(new_range, name=self.name)\n    return self._int64index // other",
                            "def all(self) -> bool:\n    return 0 not in self._range",
                            "def any(self) -> bool:\n    return any(self._range)",
                            "@classmethod\ndef _add_numeric_methods_binary(cls):\n    \"\"\" add in numeric methods, specialized to RangeIndex \"\"\"\n\n    def _make_evaluate_binop(op, step=False):\n        \"\"\"\n        Parameters\n        ----------\n        op : callable that accepts 2 parms\n            perform the binary op\n        step : callable, optional, default to False\n            op to apply to the step parm if not None\n            if False, use the existing step\n        \"\"\"\n\n        def _evaluate_numeric_binop(self, other):\n            if isinstance(other, (ABCSeries, ABCDataFrame)):\n                return NotImplemented\n            elif isinstance(other, ABCTimedeltaIndex):\n                return NotImplemented\n            elif isinstance(other, (timedelta, np.timedelta64)):\n                return op(self._int64index, other)\n            elif is_timedelta64_dtype(other):\n                return op(self._int64index, other)\n            other = extract_array(other, extract_numpy=True)\n            attrs = self._get_attributes_dict()\n            (left, right) = (self, other)\n            try:\n                if step:\n                    with np.errstate(all='ignore'):\n                        rstep = step(left.step, right)\n                    if not is_integer(rstep) or not rstep:\n                        raise ValueError\n                else:\n                    rstep = left.step\n                with np.errstate(all='ignore'):\n                    rstart = op(left.start, right)\n                    rstop = op(left.stop, right)\n                result = self.__class__(rstart, rstop, rstep, **attrs)\n                if not all((is_integer(x) for x in [rstart, rstop, rstep])):\n                    result = result.astype('float64')\n                return result\n            except (ValueError, TypeError, ZeroDivisionError):\n                return op(self._int64index, other)\n        name = '__{name}__'.format(name=op.__name__)\n        return compat.set_function_name(_evaluate_numeric_binop, name, cls)\n    cls.__add__ = _make_evaluate_binop(operator.add)\n    cls.__radd__ = _make_evaluate_binop(ops.radd)\n    cls.__sub__ = _make_evaluate_binop(operator.sub)\n    cls.__rsub__ = _make_evaluate_binop(ops.rsub)\n    cls.__mul__ = _make_evaluate_binop(operator.mul, step=operator.mul)\n    cls.__rmul__ = _make_evaluate_binop(ops.rmul, step=ops.rmul)\n    cls.__truediv__ = _make_evaluate_binop(operator.truediv, step=operator.truediv)\n    cls.__rtruediv__ = _make_evaluate_binop(ops.rtruediv, step=ops.rtruediv)",
                            "def _make_evaluate_binop(op, step=False):\n    \"\"\"\n    Parameters\n    ----------\n    op : callable that accepts 2 parms\n        perform the binary op\n    step : callable, optional, default to False\n        op to apply to the step parm if not None\n        if False, use the existing step\n    \"\"\"\n\n    def _evaluate_numeric_binop(self, other):\n        if isinstance(other, (ABCSeries, ABCDataFrame)):\n            return NotImplemented\n        elif isinstance(other, ABCTimedeltaIndex):\n            return NotImplemented\n        elif isinstance(other, (timedelta, np.timedelta64)):\n            return op(self._int64index, other)\n        elif is_timedelta64_dtype(other):\n            return op(self._int64index, other)\n        other = extract_array(other, extract_numpy=True)\n        attrs = self._get_attributes_dict()\n        (left, right) = (self, other)\n        try:\n            if step:\n                with np.errstate(all='ignore'):\n                    rstep = step(left.step, right)\n                if not is_integer(rstep) or not rstep:\n                    raise ValueError\n            else:\n                rstep = left.step\n            with np.errstate(all='ignore'):\n                rstart = op(left.start, right)\n                rstop = op(left.stop, right)\n            result = self.__class__(rstart, rstop, rstep, **attrs)\n            if not all((is_integer(x) for x in [rstart, rstop, rstep])):\n                result = result.astype('float64')\n            return result\n        except (ValueError, TypeError, ZeroDivisionError):\n            return op(self._int64index, other)\n    name = '__{name}__'.format(name=op.__name__)\n    return compat.set_function_name(_evaluate_numeric_binop, name, cls)",
                            "def _evaluate_numeric_binop(self, other):\n    if isinstance(other, (ABCSeries, ABCDataFrame)):\n        return NotImplemented\n    elif isinstance(other, ABCTimedeltaIndex):\n        return NotImplemented\n    elif isinstance(other, (timedelta, np.timedelta64)):\n        return op(self._int64index, other)\n    elif is_timedelta64_dtype(other):\n        return op(self._int64index, other)\n    other = extract_array(other, extract_numpy=True)\n    attrs = self._get_attributes_dict()\n    (left, right) = (self, other)\n    try:\n        if step:\n            with np.errstate(all='ignore'):\n                rstep = step(left.step, right)\n            if not is_integer(rstep) or not rstep:\n                raise ValueError\n        else:\n            rstep = left.step\n        with np.errstate(all='ignore'):\n            rstart = op(left.start, right)\n            rstop = op(left.stop, right)\n        result = self.__class__(rstart, rstop, rstep, **attrs)\n        if not all((is_integer(x) for x in [rstart, rstop, rstep])):\n            result = result.astype('float64')\n        return result\n    except (ValueError, TypeError, ZeroDivisionError):\n        return op(self._int64index, other)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_typ = 'rangeindex'",
                            "_engine_type = libindex.Int64Engine",
                            "_range = None",
                            "_cached_data = None",
                            "_deprecation_message = 'RangeIndex.{} is deprecated and will be removed in a future version. Use RangeIndex.{} instead'"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "__new__(cls, start=None, stop=None, step=None, dtype=None, copy=False, name=None, fastpath=None)",
                            "from_range(cls, data, name=None, dtype=None)",
                            "_simple_new(cls, values, name=None, dtype=None, **kwargs)",
                            "_validate_dtype(dtype)",
                            "_constructor(self)",
                            "_data(self)",
                            "_int64index(self)",
                            "_get_data_as_items(self)",
                            "__reduce__(self)",
                            "_format_attrs(self)",
                            "_format_data(self, name=None)",
                            "_format_with_header(self, header, na_rep='NaN', **kwargs)",
                            "start(self)",
                            "_start(self)",
                            "stop(self)",
                            "_stop(self)",
                            "step(self)",
                            "_step(self)",
                            "nbytes(self)",
                            "memory_usage(self, deep=False)",
                            "dtype(self)",
                            "is_unique(self)",
                            "is_monotonic_increasing(self)",
                            "is_monotonic_decreasing(self)",
                            "has_duplicates(self)",
                            "__contains__(self, key: Union[int, np.integer]) -> bool",
                            "get_loc(self, key, method=None, tolerance=None)",
                            "get_indexer(self, target, method=None, limit=None, tolerance=None)",
                            "tolist(self)",
                            "_shallow_copy(self, values=None, **kwargs)",
                            "copy(self, name=None, deep=False, dtype=None, **kwargs)",
                            "_minmax(self, meth)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "argsort(self, *args, **kwargs)",
                            "equals(self, other)",
                            "intersection(self, other, sort=False)",
                            "_min_fitting_element(self, lower_limit)",
                            "_max_fitting_element(self, upper_limit)",
                            "_extended_gcd(self, a, b)",
                            "_union(self, other, sort)",
                            "join(self, other, how='left', level=None, return_indexers=False, sort=False)",
                            "_concat_same_dtype(self, indexes, name)",
                            "__len__(self)",
                            "size(self)",
                            "__getitem__(self, key)",
                            "__floordiv__(self, other)",
                            "all(self) -> bool",
                            "any(self) -> bool",
                            "_add_numeric_methods_binary(cls)",
                            "_make_evaluate_binop(op, step=False)",
                            "_evaluate_numeric_binop(self, other)"
                        ],
                        "class_level_variable_names": [
                            "_typ",
                            "_engine_type",
                            "_range",
                            "_cached_data",
                            "_deprecation_message"
                        ],
                        "constructor_variable_names": []
                    },
                    "used_imports": [
                        "import numpy as np",
                        "from pandas.util._decorators import Appender, cache_readonly",
                        "from pandas.core.dtypes.common import ensure_platform_int, ensure_python_int, is_int64_dtype, is_integer, is_integer_dtype, is_list_like, is_scalar, is_timedelta64_dtype",
                        "from pandas.core.indexes.base import Index, _index_shared_docs"
                    ],
                    "variable_values": [
                        [
                            {
                                "method": {
                                    "variable_value": "'pad'",
                                    "variable_type": "str",
                                    "variable_shape": "3"
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target": {
                                    "variable_value": "Int64Index([0, 1, 2, 3, 4, 5], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(6,)"
                                },
                                "get_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.step": {
                                    "variable_value": "1",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "RangeIndex(start=0, stop=4, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(4,)"
                                },
                                "start": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "stop": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "step": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.start": {
                                    "variable_value": "0",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self.stop": {
                                    "variable_value": "4",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "target_array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_integer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target_array.ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "locs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "valid": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "method": {
                                    "variable_value": "'pad'",
                                    "variable_type": "str",
                                    "variable_shape": "3"
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target": {
                                    "variable_value": "Int64Index([0, 1, 2, 3, 4, 5], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(6,)"
                                },
                                "get_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.step": {
                                    "variable_value": "1",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "RangeIndex(start=0, stop=4, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(4,)"
                                },
                                "start": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "stop": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "step": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.start": {
                                    "variable_value": "0",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self.stop": {
                                    "variable_value": "4",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "target_array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_integer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target_array.ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "locs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "valid": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "method": {
                                    "variable_value": "'pad'",
                                    "variable_type": "str",
                                    "variable_shape": "3"
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target": {
                                    "variable_value": "RangeIndex(start=0, stop=6, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(6,)"
                                },
                                "get_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.step": {
                                    "variable_value": "1",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "RangeIndex(start=0, stop=4, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(4,)"
                                },
                                "start": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "stop": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "step": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.start": {
                                    "variable_value": "0",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self.stop": {
                                    "variable_value": "4",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "target_array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_integer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target_array.ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "locs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "valid": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "method": {
                                    "variable_value": "'pad'",
                                    "variable_type": "str",
                                    "variable_shape": "3"
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target": {
                                    "variable_value": "RangeIndex(start=0, stop=6, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(6,)"
                                },
                                "get_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.step": {
                                    "variable_value": "1",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "RangeIndex(start=0, stop=4, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(4,)"
                                },
                                "start": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "stop": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "step": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.start": {
                                    "variable_value": "0",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self.stop": {
                                    "variable_value": "4",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "target_array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_integer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target_array.ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "locs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "valid": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "com.any_not_none": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "com": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "method": {
                                    "variable_value": "'pad'",
                                    "variable_type": "str",
                                    "variable_shape": "3"
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "limit": {
                                    "variable_value": "1",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target": {
                                    "variable_value": "Int64Index([0, 1, 2, 3, 4, 5], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(6,)"
                                },
                                "get_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.step": {
                                    "variable_value": "1",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "RangeIndex(start=0, stop=4, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(4,)"
                                },
                                "start": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "stop": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "step": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.start": {
                                    "variable_value": "0",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self.stop": {
                                    "variable_value": "4",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "target_array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_integer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target_array.ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "locs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "valid": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "com.any_not_none": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "com": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "method": {
                                    "variable_value": "'pad'",
                                    "variable_type": "str",
                                    "variable_shape": "3"
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "limit": {
                                    "variable_value": "1",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target": {
                                    "variable_value": "Int64Index([0, 1, 2, 3, 4, 5], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(6,)"
                                },
                                "get_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.step": {
                                    "variable_value": "1",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "RangeIndex(start=0, stop=4, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(4,)"
                                },
                                "start": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "stop": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "step": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.start": {
                                    "variable_value": "0",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self.stop": {
                                    "variable_value": "4",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "target_array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_integer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target_array.ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "locs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "valid": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "com.any_not_none": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "com": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "method": {
                                    "variable_value": "'pad'",
                                    "variable_type": "str",
                                    "variable_shape": "3"
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "limit": {
                                    "variable_value": "1",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target": {
                                    "variable_value": "RangeIndex(start=0, stop=6, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(6,)"
                                },
                                "get_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.step": {
                                    "variable_value": "1",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "RangeIndex(start=0, stop=4, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(4,)"
                                },
                                "start": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "stop": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "step": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.start": {
                                    "variable_value": "0",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self.stop": {
                                    "variable_value": "4",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "target_array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_integer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target_array.ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "locs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "valid": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "com.any_not_none": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "com": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "method": {
                                    "variable_value": "'pad'",
                                    "variable_type": "str",
                                    "variable_shape": "3"
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "limit": {
                                    "variable_value": "1",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target": {
                                    "variable_value": "RangeIndex(start=0, stop=6, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(6,)"
                                },
                                "get_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.step": {
                                    "variable_value": "1",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "RangeIndex(start=0, stop=4, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(4,)"
                                },
                                "start": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "stop": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "step": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.start": {
                                    "variable_value": "0",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self.stop": {
                                    "variable_value": "4",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "target_array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_integer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target_array.ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "locs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "valid": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def __new__(\n    cls,\n    start=None,\n    stop=None,\n    step=None,\n    dtype=None,\n    copy=False,\n    name=None,\n    fastpath=None,\n):\n\n    if fastpath is not None:\n        warnings.warn(\n            \"The 'fastpath' keyword is deprecated, and will be \"\n            \"removed in a future version.\",\n            FutureWarning,\n            stacklevel=2,\n        )\n        if fastpath:\n            return cls._simple_new(range(start, stop, step), name=name)\n\n    cls._validate_dtype(dtype)\n\n    # RangeIndex\n    if isinstance(start, RangeIndex):\n        name = start.name if name is None else name\n        start = start._range\n        return cls._simple_new(start, dtype=dtype, name=name)\n\n    # validate the arguments\n    if com.all_none(start, stop, step):\n        raise TypeError(\"RangeIndex(...) must be called with integers\")\n\n    start = ensure_python_int(start) if start is not None else 0\n\n    if stop is None:\n        start, stop = 0, start\n    else:\n        stop = ensure_python_int(stop)\n\n    step = ensure_python_int(step) if step is not None else 1\n    if step == 0:\n        raise ValueError(\"Step must not be zero\")\n\n    rng = range(start, stop, step)\n    return cls._simple_new(rng, dtype=dtype, name=name)",
                "@classmethod\ndef from_range(cls, data, name=None, dtype=None):\n    \"\"\"\n    Create RangeIndex from a range object.\n\n    Returns\n    -------\n    RangeIndex\n    \"\"\"\n    if not isinstance(data, range):\n        raise TypeError(\n            \"{0}(...) must be called with object coercible to a \"\n            \"range, {1} was passed\".format(cls.__name__, repr(data))\n        )\n\n    cls._validate_dtype(dtype)\n    return cls._simple_new(data, dtype=dtype, name=name)",
                "@classmethod\ndef _simple_new(cls, values, name=None, dtype=None, **kwargs):\n    result = object.__new__(cls)\n\n    # handle passed None, non-integers\n    if values is None:\n        # empty\n        values = range(0, 0, 1)\n    elif not isinstance(values, range):\n        return Index(values, dtype=dtype, name=name, **kwargs)\n\n    result._range = values\n\n    result.name = name\n    for k, v in kwargs.items():\n        setattr(result, k, v)\n\n    result._reset_identity()\n    return result",
                "@staticmethod\ndef _validate_dtype(dtype):\n    \"\"\" require dtype to be None or int64 \"\"\"\n    if not (dtype is None or is_int64_dtype(dtype)):\n        raise TypeError(\"Invalid to pass a non-int64 dtype to RangeIndex\")",
                "@cache_readonly\ndef _constructor(self):\n    \"\"\" return the class to use for construction \"\"\"\n    return Int64Index",
                "@property\ndef _data(self):\n    \"\"\"\n    An int array that for performance reasons is created only when needed.\n\n    The constructed array is saved in ``_cached_data``. This allows us to\n    check if the array has been created without accessing ``_data`` and\n    triggering the construction.\n    \"\"\"\n    if self._cached_data is None:\n        self._cached_data = np.arange(\n            self.start, self.stop, self.step, dtype=np.int64\n        )\n    return self._cached_data",
                "@cache_readonly\ndef _int64index(self):\n    return Int64Index._simple_new(self._data, name=self.name)",
                "def _get_data_as_items(self):\n    \"\"\" return a list of tuples of start, stop, step \"\"\"\n    rng = self._range\n    return [(\"start\", rng.start), (\"stop\", rng.stop), (\"step\", rng.step)]",
                "def __reduce__(self):\n    d = self._get_attributes_dict()\n    d.update(dict(self._get_data_as_items()))\n    return ibase._new_Index, (self.__class__, d), None",
                "def _format_attrs(self):\n    \"\"\"\n    Return a list of tuples of the (attr, formatted_value)\n    \"\"\"\n    attrs = self._get_data_as_items()\n    if self.name is not None:\n        attrs.append((\"name\", ibase.default_pprint(self.name)))\n    return attrs",
                "def _format_data(self, name=None):\n    # we are formatting thru the attributes\n    return None",
                "def _format_with_header(self, header, na_rep=\"NaN\", **kwargs):\n    return header + list(map(pprint_thing, self._range))",
                "@cache_readonly\ndef start(self):\n    \"\"\"\n    The value of the `start` parameter (``0`` if this was not supplied).\n    \"\"\"\n    # GH 25710\n    return self._range.start",
                "@property\ndef _start(self):\n    \"\"\"\n    The value of the `start` parameter (``0`` if this was not supplied).\n\n     .. deprecated:: 0.25.0\n        Use ``start`` instead.\n    \"\"\"\n    warnings.warn(\n        self._deprecation_message.format(\"_start\", \"start\"),\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return self.start",
                "@cache_readonly\ndef stop(self):\n    \"\"\"\n    The value of the `stop` parameter.\n    \"\"\"\n    return self._range.stop",
                "@property\ndef _stop(self):\n    \"\"\"\n    The value of the `stop` parameter.\n\n     .. deprecated:: 0.25.0\n        Use ``stop`` instead.\n    \"\"\"\n    # GH 25710\n    warnings.warn(\n        self._deprecation_message.format(\"_stop\", \"stop\"),\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return self.stop",
                "@cache_readonly\ndef step(self):\n    \"\"\"\n    The value of the `step` parameter (``1`` if this was not supplied).\n    \"\"\"\n    # GH 25710\n    return self._range.step",
                "@property\ndef _step(self):\n    \"\"\"\n    The value of the `step` parameter (``1`` if this was not supplied).\n\n     .. deprecated:: 0.25.0\n        Use ``step`` instead.\n    \"\"\"\n    # GH 25710\n    warnings.warn(\n        self._deprecation_message.format(\"_step\", \"step\"),\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return self.step",
                "@cache_readonly\ndef nbytes(self):\n    \"\"\"\n    Return the number of bytes in the underlying data.\n    \"\"\"\n    rng = self._range\n    return getsizeof(rng) + sum(\n        getsizeof(getattr(rng, attr_name))\n        for attr_name in [\"start\", \"stop\", \"step\"]\n    )",
                "def memory_usage(self, deep=False):\n    \"\"\"\n    Memory usage of my values\n\n    Parameters\n    ----------\n    deep : bool\n        Introspect the data deeply, interrogate\n        `object` dtypes for system-level memory consumption\n\n    Returns\n    -------\n    bytes used\n\n    Notes\n    -----\n    Memory usage does not include memory consumed by elements that\n    are not components of the array if deep=False\n\n    See Also\n    --------\n    numpy.ndarray.nbytes\n    \"\"\"\n    return self.nbytes",
                "@property\ndef dtype(self):\n    return np.dtype(np.int64)",
                "@property\ndef is_unique(self):\n    \"\"\" return if the index has unique values \"\"\"\n    return True",
                "@cache_readonly\ndef is_monotonic_increasing(self):\n    return self._range.step > 0 or len(self) <= 1",
                "@cache_readonly\ndef is_monotonic_decreasing(self):\n    return self._range.step < 0 or len(self) <= 1",
                "@property\ndef has_duplicates(self):\n    return False",
                "def __contains__(self, key: Union[int, np.integer]) -> bool:\n    hash(key)\n    try:\n        key = ensure_python_int(key)\n    except TypeError:\n        return False\n    return key in self._range",
                "@Appender(_index_shared_docs[\"get_loc\"])\ndef get_loc(self, key, method=None, tolerance=None):\n    if is_integer(key) and method is None and tolerance is None:\n        new_key = int(key)\n        try:\n            return self._range.index(new_key)\n        except ValueError:\n            raise KeyError(key)\n    return super().get_loc(key, method=method, tolerance=tolerance)",
                "@Appender(_index_shared_docs[\"get_indexer\"])\ndef get_indexer(self, target, method=None, limit=None, tolerance=None):\n    if not (method is None and tolerance is None and is_list_like(target)):\n        return super().get_indexer(target, method=method, tolerance=tolerance)\n\n    if self.step > 0:\n        start, stop, step = self.start, self.stop, self.step\n    else:\n        # Work on reversed range for simplicity:\n        start, stop, step = (self.stop - self.step, self.start + 1, -self.step)\n\n    target_array = np.asarray(target)\n    if not (is_integer_dtype(target_array) and target_array.ndim == 1):\n        # checks/conversions/roundings are delegated to general method\n        return super().get_indexer(target, method=method, tolerance=tolerance)\n\n    locs = target_array - start\n    valid = (locs % step == 0) & (locs >= 0) & (target_array < stop)\n    locs[~valid] = -1\n    locs[valid] = locs[valid] / step\n\n    if step != self.step:\n        # We reversed this range: transform to original locs\n        locs[valid] = len(self) - 1 - locs[valid]\n    return ensure_platform_int(locs)",
                "def tolist(self):\n    return list(self._range)",
                "@Appender(_index_shared_docs[\"_shallow_copy\"])\ndef _shallow_copy(self, values=None, **kwargs):\n    if values is None:\n        name = kwargs.get(\"name\", self.name)\n        return self._simple_new(self._range, name=name)\n    else:\n        kwargs.setdefault(\"name\", self.name)\n        return self._int64index._shallow_copy(values, **kwargs)",
                "@Appender(ibase._index_shared_docs[\"copy\"])\ndef copy(self, name=None, deep=False, dtype=None, **kwargs):\n    self._validate_dtype(dtype)\n    if name is None:\n        name = self.name\n    return self.from_range(self._range, name=name)",
                "def _minmax(self, meth):\n    no_steps = len(self) - 1\n    if no_steps == -1:\n        return np.nan\n    elif (meth == \"min\" and self.step > 0) or (meth == \"max\" and self.step < 0):\n        return self.start\n\n    return self.start + self.step * no_steps",
                "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"The minimum value of the RangeIndex\"\"\"\n    nv.validate_minmax_axis(axis)\n    nv.validate_min(args, kwargs)\n    return self._minmax(\"min\")",
                "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"The maximum value of the RangeIndex\"\"\"\n    nv.validate_minmax_axis(axis)\n    nv.validate_max(args, kwargs)\n    return self._minmax(\"max\")",
                "def argsort(self, *args, **kwargs):\n    \"\"\"\n    Returns the indices that would sort the index and its\n    underlying data.\n\n    Returns\n    -------\n    argsorted : numpy array\n\n    See Also\n    --------\n    numpy.ndarray.argsort\n    \"\"\"\n    nv.validate_argsort(args, kwargs)\n\n    if self._range.step > 0:\n        return np.arange(len(self))\n    else:\n        return np.arange(len(self) - 1, -1, -1)",
                "def equals(self, other):\n    \"\"\"\n    Determines if two Index objects contain the same elements.\n    \"\"\"\n    if isinstance(other, RangeIndex):\n        return self._range == other._range\n    return super().equals(other)",
                "def intersection(self, other, sort=False):\n    \"\"\"\n    Form the intersection of two Index objects.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : False or None, default False\n        Sort the resulting index if possible\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default to ``False`` to match the behaviour\n           from before 0.24.0.\n\n    Returns\n    -------\n    intersection : Index\n    \"\"\"\n    self._validate_sort_keyword(sort)\n\n    if self.equals(other):\n        return self._get_reconciled_name_object(other)\n\n    if not isinstance(other, RangeIndex):\n        return super().intersection(other, sort=sort)\n\n    if not len(self) or not len(other):\n        return self._simple_new(None)\n\n    first = self._range[::-1] if self.step < 0 else self._range\n    second = other._range[::-1] if other.step < 0 else other._range\n\n    # check whether intervals intersect\n    # deals with in- and decreasing ranges\n    int_low = max(first.start, second.start)\n    int_high = min(first.stop, second.stop)\n    if int_high <= int_low:\n        return self._simple_new(None)\n\n    # Method hint: linear Diophantine equation\n    # solve intersection problem\n    # performance hint: for identical step sizes, could use\n    # cheaper alternative\n    gcd, s, t = self._extended_gcd(first.step, second.step)\n\n    # check whether element sets intersect\n    if (first.start - second.start) % gcd:\n        return self._simple_new(None)\n\n    # calculate parameters for the RangeIndex describing the\n    # intersection disregarding the lower bounds\n    tmp_start = first.start + (second.start - first.start) * first.step // gcd * s\n    new_step = first.step * second.step // gcd\n    new_range = range(tmp_start, int_high, new_step)\n    new_index = self._simple_new(new_range)\n\n    # adjust index to limiting interval\n    new_start = new_index._min_fitting_element(int_low)\n    new_range = range(new_start, new_index.stop, new_index.step)\n    new_index = self._simple_new(new_range)\n\n    if (self.step < 0 and other.step < 0) is not (new_index.step < 0):\n        new_index = new_index[::-1]\n    if sort is None:\n        new_index = new_index.sort_values()\n    return new_index",
                "def _min_fitting_element(self, lower_limit):\n    \"\"\"Returns the smallest element greater than or equal to the limit\"\"\"\n    no_steps = -(-(lower_limit - self.start) // abs(self.step))\n    return self.start + abs(self.step) * no_steps",
                "def _max_fitting_element(self, upper_limit):\n    \"\"\"Returns the largest element smaller than or equal to the limit\"\"\"\n    no_steps = (upper_limit - self.start) // abs(self.step)\n    return self.start + abs(self.step) * no_steps",
                "def _extended_gcd(self, a, b):\n    \"\"\"\n    Extended Euclidean algorithms to solve Bezout's identity:\n       a*x + b*y = gcd(x, y)\n    Finds one particular solution for x, y: s, t\n    Returns: gcd, s, t\n    \"\"\"\n    s, old_s = 0, 1\n    t, old_t = 1, 0\n    r, old_r = b, a\n    while r:\n        quotient = old_r // r\n        old_r, r = r, old_r - quotient * r\n        old_s, s = s, old_s - quotient * s\n        old_t, t = t, old_t - quotient * t\n    return old_r, old_s, old_t",
                "def _union(self, other, sort):\n    \"\"\"\n    Form the union of two Index objects and sorts if possible\n\n    Parameters\n    ----------\n    other : Index or array-like\n\n    sort : False or None, default None\n        Whether to sort resulting index. ``sort=None`` returns a\n        monotonically increasing ``RangeIndex`` if possible or a sorted\n        ``Int64Index`` if not. ``sort=False`` always returns an\n        unsorted ``Int64Index``\n\n        .. versionadded:: 0.25.0\n\n    Returns\n    -------\n    union : Index\n    \"\"\"\n    if not len(other) or self.equals(other) or not len(self):\n        return super()._union(other, sort=sort)\n\n    if isinstance(other, RangeIndex) and sort is None:\n        start_s, step_s = self.start, self.step\n        end_s = self.start + self.step * (len(self) - 1)\n        start_o, step_o = other.start, other.step\n        end_o = other.start + other.step * (len(other) - 1)\n        if self.step < 0:\n            start_s, step_s, end_s = end_s, -step_s, start_s\n        if other.step < 0:\n            start_o, step_o, end_o = end_o, -step_o, start_o\n        if len(self) == 1 and len(other) == 1:\n            step_s = step_o = abs(self.start - other.start)\n        elif len(self) == 1:\n            step_s = step_o\n        elif len(other) == 1:\n            step_o = step_s\n        start_r = min(start_s, start_o)\n        end_r = max(end_s, end_o)\n        if step_o == step_s:\n            if (\n                (start_s - start_o) % step_s == 0\n                and (start_s - end_o) <= step_s\n                and (start_o - end_s) <= step_s\n            ):\n                return self.__class__(start_r, end_r + step_s, step_s)\n            if (\n                (step_s % 2 == 0)\n                and (abs(start_s - start_o) <= step_s / 2)\n                and (abs(end_s - end_o) <= step_s / 2)\n            ):\n                return self.__class__(start_r, end_r + step_s / 2, step_s / 2)\n        elif step_o % step_s == 0:\n            if (\n                (start_o - start_s) % step_s == 0\n                and (start_o + step_s >= start_s)\n                and (end_o - step_s <= end_s)\n            ):\n                return self.__class__(start_r, end_r + step_s, step_s)\n        elif step_s % step_o == 0:\n            if (\n                (start_s - start_o) % step_o == 0\n                and (start_s + step_o >= start_o)\n                and (end_s - step_o <= end_o)\n            ):\n                return self.__class__(start_r, end_r + step_o, step_o)\n    return self._int64index._union(other, sort=sort)",
                "@Appender(_index_shared_docs[\"join\"])\ndef join(self, other, how=\"left\", level=None, return_indexers=False, sort=False):\n    if how == \"outer\" and self is not other:\n        # note: could return RangeIndex in more circumstances\n        return self._int64index.join(other, how, level, return_indexers, sort)\n\n    return super().join(other, how, level, return_indexers, sort)",
                "def _concat_same_dtype(self, indexes, name):\n    \"\"\"\n    Concatenates multiple RangeIndex instances. All members of \"indexes\" must\n    be of type RangeIndex; result will be RangeIndex if possible, Int64Index\n    otherwise. E.g.:\n    indexes = [RangeIndex(3), RangeIndex(3, 6)] -> RangeIndex(6)\n    indexes = [RangeIndex(3), RangeIndex(4, 6)] -> Int64Index([0,1,2,4,5])\n    \"\"\"\n    start = step = next_ = None\n\n    # Filter the empty indexes\n    non_empty_indexes = [obj for obj in indexes if len(obj)]\n\n    for obj in non_empty_indexes:\n        rng = obj._range  # type: range\n\n        if start is None:\n            # This is set by the first non-empty index\n            start = rng.start\n            if step is None and len(rng) > 1:\n                step = rng.step\n        elif step is None:\n            # First non-empty index had only one element\n            if rng.start == start:\n                result = Int64Index(np.concatenate([x._values for x in indexes]))\n                return result.rename(name)\n\n            step = rng.start - start\n\n        non_consecutive = (step != rng.step and len(rng) > 1) or (\n            next_ is not None and rng.start != next_\n        )\n        if non_consecutive:\n            result = Int64Index(np.concatenate([x._values for x in indexes]))\n            return result.rename(name)\n\n        if step is not None:\n            next_ = rng[-1] + step\n\n    if non_empty_indexes:\n        # Get the stop value from \"next\" or alternatively\n        # from the last non-empty index\n        stop = non_empty_indexes[-1].stop if next_ is None else next_\n        return RangeIndex(start, stop, step).rename(name)\n\n    # Here all \"indexes\" had 0 length, i.e. were empty.\n    # In this case return an empty range index.\n    return RangeIndex(0, 0).rename(name)",
                "def __len__(self):\n    \"\"\"\n    return the length of the RangeIndex\n    \"\"\"\n    return len(self._range)",
                "@property\ndef size(self):\n    return len(self)",
                "def __getitem__(self, key):\n    \"\"\"\n    Conserve RangeIndex type for scalar and slice keys.\n    \"\"\"\n    if isinstance(key, slice):\n        new_range = self._range[key]\n        return self._simple_new(new_range, name=self.name)\n    elif is_integer(key):\n        new_key = int(key)\n        try:\n            return self._range[new_key]\n        except IndexError:\n            raise IndexError(\n                \"index {key} is out of bounds for axis 0 \"\n                \"with size {size}\".format(key=key, size=len(self))\n            )\n    elif is_scalar(key):\n        raise IndexError(\n            \"only integers, slices (`:`), \"\n            \"ellipsis (`...`), numpy.newaxis (`None`) \"\n            \"and integer or boolean \"\n            \"arrays are valid indices\"\n        )\n    # fall back to Int64Index\n    return super().__getitem__(key)",
                "def __floordiv__(self, other):\n    if isinstance(other, (ABCSeries, ABCDataFrame)):\n        return NotImplemented\n\n    if is_integer(other) and other != 0:\n        if len(self) == 0 or self.start % other == 0 and self.step % other == 0:\n            start = self.start // other\n            step = self.step // other\n            stop = start + len(self) * step\n            new_range = range(start, stop, step or 1)\n            return self._simple_new(new_range, name=self.name)\n        if len(self) == 1:\n            start = self.start // other\n            new_range = range(start, start + 1, 1)\n            return self._simple_new(new_range, name=self.name)\n    return self._int64index // other",
                "def all(self) -> bool:\n    return 0 not in self._range",
                "def any(self) -> bool:\n    return any(self._range)",
                "@classmethod\ndef _add_numeric_methods_binary(cls):\n    \"\"\" add in numeric methods, specialized to RangeIndex \"\"\"\n\n    def _make_evaluate_binop(op, step=False):\n        \"\"\"\n        Parameters\n        ----------\n        op : callable that accepts 2 parms\n            perform the binary op\n        step : callable, optional, default to False\n            op to apply to the step parm if not None\n            if False, use the existing step\n        \"\"\"\n\n        def _evaluate_numeric_binop(self, other):\n            if isinstance(other, (ABCSeries, ABCDataFrame)):\n                return NotImplemented\n            elif isinstance(other, ABCTimedeltaIndex):\n                # Defer to TimedeltaIndex implementation\n                return NotImplemented\n            elif isinstance(other, (timedelta, np.timedelta64)):\n                # GH#19333 is_integer evaluated True on timedelta64,\n                # so we need to catch these explicitly\n                return op(self._int64index, other)\n            elif is_timedelta64_dtype(other):\n                # Must be an np.ndarray; GH#22390\n                return op(self._int64index, other)\n\n            other = extract_array(other, extract_numpy=True)\n            attrs = self._get_attributes_dict()\n\n            left, right = self, other\n\n            try:\n                # apply if we have an override\n                if step:\n                    with np.errstate(all=\"ignore\"):\n                        rstep = step(left.step, right)\n\n                    # we don't have a representable op\n                    # so return a base index\n                    if not is_integer(rstep) or not rstep:\n                        raise ValueError\n\n                else:\n                    rstep = left.step\n\n                with np.errstate(all=\"ignore\"):\n                    rstart = op(left.start, right)\n                    rstop = op(left.stop, right)\n\n                result = self.__class__(rstart, rstop, rstep, **attrs)\n\n                # for compat with numpy / Int64Index\n                # even if we can represent as a RangeIndex, return\n                # as a Float64Index if we have float-like descriptors\n                if not all(is_integer(x) for x in [rstart, rstop, rstep]):\n                    result = result.astype(\"float64\")\n\n                return result\n\n            except (ValueError, TypeError, ZeroDivisionError):\n                # Defer to Int64Index implementation\n                return op(self._int64index, other)\n                # TODO: Do attrs get handled reliably?\n\n        name = \"__{name}__\".format(name=op.__name__)\n        return compat.set_function_name(_evaluate_numeric_binop, name, cls)\n\n    cls.__add__ = _make_evaluate_binop(operator.add)\n    cls.__radd__ = _make_evaluate_binop(ops.radd)\n    cls.__sub__ = _make_evaluate_binop(operator.sub)\n    cls.__rsub__ = _make_evaluate_binop(ops.rsub)\n    cls.__mul__ = _make_evaluate_binop(operator.mul, step=operator.mul)\n    cls.__rmul__ = _make_evaluate_binop(ops.rmul, step=ops.rmul)\n    cls.__truediv__ = _make_evaluate_binop(operator.truediv, step=operator.truediv)\n    cls.__rtruediv__ = _make_evaluate_binop(ops.rtruediv, step=ops.rtruediv)",
                "def _make_evaluate_binop(op, step=False):\n    \"\"\"\n    Parameters\n    ----------\n    op : callable that accepts 2 parms\n        perform the binary op\n    step : callable, optional, default to False\n        op to apply to the step parm if not None\n        if False, use the existing step\n    \"\"\"\n\n    def _evaluate_numeric_binop(self, other):\n        if isinstance(other, (ABCSeries, ABCDataFrame)):\n            return NotImplemented\n        elif isinstance(other, ABCTimedeltaIndex):\n            # Defer to TimedeltaIndex implementation\n            return NotImplemented\n        elif isinstance(other, (timedelta, np.timedelta64)):\n            # GH#19333 is_integer evaluated True on timedelta64,\n            # so we need to catch these explicitly\n            return op(self._int64index, other)\n        elif is_timedelta64_dtype(other):\n            # Must be an np.ndarray; GH#22390\n            return op(self._int64index, other)\n\n        other = extract_array(other, extract_numpy=True)\n        attrs = self._get_attributes_dict()\n\n        left, right = self, other\n\n        try:\n            # apply if we have an override\n            if step:\n                with np.errstate(all=\"ignore\"):\n                    rstep = step(left.step, right)\n\n                # we don't have a representable op\n                # so return a base index\n                if not is_integer(rstep) or not rstep:\n                    raise ValueError\n\n            else:\n                rstep = left.step\n\n            with np.errstate(all=\"ignore\"):\n                rstart = op(left.start, right)\n                rstop = op(left.stop, right)\n\n            result = self.__class__(rstart, rstop, rstep, **attrs)\n\n            # for compat with numpy / Int64Index\n            # even if we can represent as a RangeIndex, return\n            # as a Float64Index if we have float-like descriptors\n            if not all(is_integer(x) for x in [rstart, rstop, rstep]):\n                result = result.astype(\"float64\")\n\n            return result\n\n        except (ValueError, TypeError, ZeroDivisionError):\n            # Defer to Int64Index implementation\n            return op(self._int64index, other)\n            # TODO: Do attrs get handled reliably?\n\n    name = \"__{name}__\".format(name=op.__name__)\n    return compat.set_function_name(_evaluate_numeric_binop, name, cls)",
                "def _evaluate_numeric_binop(self, other):\n    if isinstance(other, (ABCSeries, ABCDataFrame)):\n        return NotImplemented\n    elif isinstance(other, ABCTimedeltaIndex):\n        # Defer to TimedeltaIndex implementation\n        return NotImplemented\n    elif isinstance(other, (timedelta, np.timedelta64)):\n        # GH#19333 is_integer evaluated True on timedelta64,\n        # so we need to catch these explicitly\n        return op(self._int64index, other)\n    elif is_timedelta64_dtype(other):\n        # Must be an np.ndarray; GH#22390\n        return op(self._int64index, other)\n\n    other = extract_array(other, extract_numpy=True)\n    attrs = self._get_attributes_dict()\n\n    left, right = self, other\n\n    try:\n        # apply if we have an override\n        if step:\n            with np.errstate(all=\"ignore\"):\n                rstep = step(left.step, right)\n\n            # we don't have a representable op\n            # so return a base index\n            if not is_integer(rstep) or not rstep:\n                raise ValueError\n\n        else:\n            rstep = left.step\n\n        with np.errstate(all=\"ignore\"):\n            rstart = op(left.start, right)\n            rstop = op(left.stop, right)\n\n        result = self.__class__(rstart, rstop, rstep, **attrs)\n\n        # for compat with numpy / Int64Index\n        # even if we can represent as a RangeIndex, return\n        # as a Float64Index if we have float-like descriptors\n        if not all(is_integer(x) for x in [rstart, rstop, rstep]):\n            result = result.astype(\"float64\")\n\n        return result\n\n    except (ValueError, TypeError, ZeroDivisionError):\n        # Defer to Int64Index implementation\n        return op(self._int64index, other)"
            ],
            "inscope_function_signatures": [
                "__new__(cls, start=None, stop=None, step=None, dtype=None, copy=False, name=None, fastpath=None)",
                "from_range(cls, data, name=None, dtype=None)",
                "_simple_new(cls, values, name=None, dtype=None, **kwargs)",
                "_validate_dtype(dtype)",
                "_constructor(self)",
                "_data(self)",
                "_int64index(self)",
                "_get_data_as_items(self)",
                "__reduce__(self)",
                "_format_attrs(self)",
                "_format_data(self, name=None)",
                "_format_with_header(self, header, na_rep='NaN', **kwargs)",
                "start(self)",
                "_start(self)",
                "stop(self)",
                "_stop(self)",
                "step(self)",
                "_step(self)",
                "nbytes(self)",
                "memory_usage(self, deep=False)",
                "dtype(self)",
                "is_unique(self)",
                "is_monotonic_increasing(self)",
                "is_monotonic_decreasing(self)",
                "has_duplicates(self)",
                "__contains__(self, key: Union[int, np.integer]) -> bool",
                "get_loc(self, key, method=None, tolerance=None)",
                "get_indexer(self, target, method=None, limit=None, tolerance=None)",
                "tolist(self)",
                "_shallow_copy(self, values=None, **kwargs)",
                "copy(self, name=None, deep=False, dtype=None, **kwargs)",
                "_minmax(self, meth)",
                "min(self, axis=None, skipna=True, *args, **kwargs)",
                "max(self, axis=None, skipna=True, *args, **kwargs)",
                "argsort(self, *args, **kwargs)",
                "equals(self, other)",
                "intersection(self, other, sort=False)",
                "_min_fitting_element(self, lower_limit)",
                "_max_fitting_element(self, upper_limit)",
                "_extended_gcd(self, a, b)",
                "_union(self, other, sort)",
                "join(self, other, how='left', level=None, return_indexers=False, sort=False)",
                "_concat_same_dtype(self, indexes, name)",
                "__len__(self)",
                "size(self)",
                "__getitem__(self, key)",
                "__floordiv__(self, other)",
                "all(self) -> bool",
                "any(self) -> bool",
                "_add_numeric_methods_binary(cls)",
                "_make_evaluate_binop(op, step=False)",
                "_evaluate_numeric_binop(self, other)"
            ],
            "variables_in_file": {
                "Int64Index": [
                    673,
                    36,
                    198,
                    682,
                    179
                ],
                "_typ": [
                    74
                ],
                "_engine_type": [
                    75
                ],
                "libindex.Int64Engine": [
                    75
                ],
                "libindex": [
                    75
                ],
                "_range": [
                    76
                ],
                "_cached_data": [
                    79
                ],
                "fastpath": [
                    101,
                    94
                ],
                "warnings.warn": [
                    299,
                    275,
                    252,
                    95
                ],
                "warnings": [
                    299,
                    275,
                    252,
                    95
                ],
                "FutureWarning": [
                    98
                ],
                "cls._simple_new": [
                    128,
                    110,
                    102,
                    146
                ],
                "cls": [
                    128,
                    832,
                    833,
                    834,
                    102,
                    104,
                    110,
                    142,
                    145,
                    146,
                    150,
                    825,
                    827,
                    828,
                    829,
                    830,
                    831
                ],
                "range": [
                    102,
                    743,
                    139,
                    747,
                    531,
                    536,
                    155,
                    156,
                    127
                ],
                "start": [
                    387,
                    390,
                    397,
                    657,
                    665,
                    667,
                    672,
                    676,
                    692,
                    740,
                    102,
                    742,
                    743,
                    746,
                    107,
                    108,
                    109,
                    110,
                    747,
                    113,
                    116,
                    119,
                    127
                ],
                "stop": [
                    387,
                    102,
                    390,
                    742,
                    743,
                    398,
                    113,
                    691,
                    692,
                    118,
                    119,
                    121,
                    127
                ],
                "step": [
                    387,
                    390,
                    398,
                    400,
                    657,
                    402,
                    793,
                    795,
                    668,
                    669,
                    670,
                    676,
                    678,
                    685,
                    686,
                    692,
                    741,
                    102,
                    742,
                    743,
                    113,
                    123,
                    124,
                    127
                ],
                "name": [
                    128,
                    161,
                    674,
                    414,
                    102,
                    422,
                    423,
                    424,
                    683,
                    108,
                    110,
                    146,
                    824,
                    692,
                    696,
                    825,
                    157,
                    413
                ],
                "cls._validate_dtype": [
                    104,
                    145
                ],
                "dtype": [
                    128,
                    421,
                    104,
                    173,
                    110,
                    145,
                    146,
                    157
                ],
                "isinstance": [
                    773,
                    775,
                    712,
                    778,
                    107,
                    139,
                    595,
                    501,
                    471,
                    156,
                    735
                ],
                "RangeIndex": [
                    837,
                    107,
                    595,
                    692,
                    501,
                    471,
                    696
                ],
                "start.name": [
                    108
                ],
                "start._range": [
                    109
                ],
                "com.all_none": [
                    113
                ],
                "com": [
                    113
                ],
                "TypeError": [
                    140,
                    174,
                    367,
                    114,
                    819
                ],
                "ensure_python_int": [
                    121,
                    123,
                    116,
                    366
                ],
                "ValueError": [
                    800,
                    377,
                    819,
                    125
                ],
                "rng": [
                    128,
                    672,
                    676,
                    678,
                    679,
                    663,
                    202,
                    203,
                    686,
                    311,
                    312,
                    313,
                    667,
                    668,
                    669,
                    127
                ],
                "data": [
                    146,
                    139,
                    142
                ],
                "format": [
                    824,
                    721,
                    141
                ],
                "cls.__name__": [
                    142
                ],
                "repr": [
                    142
                ],
                "classmethod": [
                    130,
                    148,
                    757
                ],
                "result": [
                    161,
                    673,
                    163,
                    674,
                    165,
                    166,
                    809,
                    682,
                    683,
                    815,
                    817,
                    150,
                    159
                ],
                "object.__new__": [
                    150
                ],
                "object": [
                    150
                ],
                "values": [
                    417,
                    153,
                    155,
                    156,
                    157,
                    412,
                    159
                ],
                "Index": [
                    157
                ],
                "kwargs": [
                    416,
                    417,
                    162,
                    460,
                    438,
                    444,
                    157,
                    413
                ],
                "result._range": [
                    159
                ],
                "result.name": [
                    161
                ],
                "k": [
                    162,
                    163
                ],
                "v": [
                    162,
                    163
                ],
                "kwargs.items": [
                    162
                ],
                "setattr": [
                    163
                ],
                "result._reset_identity": [
                    165
                ],
                "is_int64_dtype": [
                    173
                ],
                "staticmethod": [
                    170
                ],
                "cache_readonly": [
                    259,
                    196,
                    355,
                    236,
                    176,
                    306,
                    282,
                    351
                ],
                "self._cached_data": [
                    194,
                    190,
                    191
                ],
                "self": [
                    515,
                    521,
                    525,
                    532,
                    537,
                    539,
                    547,
                    548,
                    552,
                    553,
                    592,
                    596,
                    597,
                    600,
                    604,
                    605,
                    606,
                    618,
                    624,
                    631,
                    638,
                    639,
                    643,
                    645,
                    190,
                    191,
                    192,
                    702,
                    194,
                    706,
                    198,
                    713,
                    202,
                    714,
                    206,
                    207,
                    208,
                    718,
                    722,
                    217,
                    218,
                    219,
                    227,
                    739,
                    740,
                    741,
                    742,
                    744,
                    745,
                    746,
                    748,
                    749,
                    752,
                    242,
                    755,
                    253,
                    257,
                    264,
                    781,
                    784,
                    787,
                    276,
                    789,
                    280,
                    288,
                    809,
                    300,
                    304,
                    821,
                    311,
                    340,
                    353,
                    357,
                    369,
                    376,
                    386,
                    387,
                    390,
                    402,
                    404,
                    408,
                    413,
                    414,
                    416,
                    417,
                    421,
                    423,
                    424,
                    427,
                    430,
                    431,
                    433,
                    439,
                    445,
                    462,
                    463,
                    465,
                    472,
                    496,
                    498,
                    499,
                    504,
                    505,
                    507
                ],
                "np.arange": [
                    465,
                    463,
                    191
                ],
                "np": [
                    192,
                    673,
                    805,
                    392,
                    682,
                    363,
                    778,
                    429,
                    463,
                    465,
                    344,
                    794,
                    191
                ],
                "self.start": [
                    192,
                    257,
                    387,
                    547,
                    548,
                    390,
                    739,
                    552,
                    553,
                    740,
                    746,
                    431,
                    433,
                    596,
                    597,
                    605
                ],
                "self.stop": [
                    192,
                    280,
                    387,
                    390
                ],
                "self.step": [
                    386,
                    387,
                    390,
                    402,
                    539,
                    547,
                    548,
                    552,
                    553,
                    430,
                    304,
                    433,
                    192,
                    596,
                    597,
                    600,
                    739,
                    741,
                    507
                ],
                "np.int64": [
                    192,
                    344
                ],
                "property": [
                    704,
                    290,
                    359,
                    266,
                    244,
                    181,
                    342,
                    346
                ],
                "Int64Index._simple_new": [
                    198
                ],
                "self._data": [
                    198
                ],
                "self.name": [
                    416,
                    198,
                    423,
                    744,
                    714,
                    748,
                    218,
                    219,
                    413
                ],
                "self._range": [
                    264,
                    408,
                    414,
                    288,
                    424,
                    311,
                    702,
                    713,
                    202,
                    462,
                    718,
                    472,
                    353,
                    227,
                    357,
                    752,
                    369,
                    242,
                    755,
                    376,
                    507
                ],
                "rng.start": [
                    672,
                    676,
                    679,
                    203,
                    667
                ],
                "rng.stop": [
                    203
                ],
                "rng.step": [
                    203,
                    669,
                    678
                ],
                "d": [
                    208,
                    206,
                    207
                ],
                "self._get_attributes_dict": [
                    787,
                    206
                ],
                "d.update": [
                    207
                ],
                "dict": [
                    207
                ],
                "self._get_data_as_items": [
                    217,
                    207
                ],
                "ibase._new_Index": [
                    208
                ],
                "ibase": [
                    208,
                    219,
                    419
                ],
                "self.__class__": [
                    809,
                    618,
                    208,
                    624,
                    631,
                    638
                ],
                "attrs": [
                    809,
                    787,
                    217,
                    219,
                    220
                ],
                "attrs.append": [
                    219
                ],
                "ibase.default_pprint": [
                    219
                ],
                "header": [
                    227
                ],
                "list": [
                    408,
                    227
                ],
                "map": [
                    227
                ],
                "pprint_thing": [
                    227
                ],
                "_deprecation_message": [
                    230
                ],
                "self._range.start": [
                    242
                ],
                "self._deprecation_message.format": [
                    276,
                    253,
                    300
                ],
                "self._deprecation_message": [
                    276,
                    253,
                    300
                ],
                "DeprecationWarning": [
                    301,
                    277,
                    254
                ],
                "self._range.stop": [
                    264
                ],
                "self._range.step": [
                    288,
                    353,
                    357,
                    462
                ],
                "getsizeof": [
                    312,
                    313
                ],
                "sum": [
                    312
                ],
                "getattr": [
                    313
                ],
                "attr_name": [
                    313,
                    314
                ],
                "self.nbytes": [
                    340
                ],
                "np.dtype": [
                    344
                ],
                "len": [
                    404,
                    660,
                    668,
                    678,
                    427,
                    702,
                    706,
                    463,
                    592,
                    465,
                    722,
                    597,
                    599,
                    604,
                    606,
                    608,
                    353,
                    739,
                    357,
                    742,
                    745,
                    504
                ],
                "Union": [
                    363
                ],
                "int": [
                    363,
                    716,
                    374
                ],
                "np.integer": [
                    363
                ],
                "hash": [
                    364
                ],
                "key": [
                    712,
                    713,
                    715,
                    364,
                    716,
                    366,
                    369,
                    722,
                    724,
                    373,
                    374,
                    378,
                    379,
                    732
                ],
                "bool": [
                    754,
                    363,
                    751
                ],
                "is_integer": [
                    738,
                    715,
                    814,
                    373,
                    799
                ],
                "method": [
                    384,
                    395,
                    373,
                    379,
                    383
                ],
                "tolerance": [
                    384,
                    395,
                    373,
                    379,
                    383
                ],
                "new_key": [
                    376,
                    716,
                    718,
                    374
                ],
                "self._range.index": [
                    376
                ],
                "KeyError": [
                    378
                ],
                "get_loc": [
                    379
                ],
                "super": [
                    384,
                    647,
                    395,
                    593,
                    502,
                    473,
                    379,
                    732
                ],
                "Appender": [
                    641,
                    419,
                    371,
                    410,
                    381
                ],
                "_index_shared_docs": [
                    641,
                    410,
                    371,
                    381
                ],
                "is_list_like": [
                    383
                ],
                "target": [
                    384,
                    395,
                    392,
                    383
                ],
                "get_indexer": [
                    384,
                    395
                ],
                "target_array": [
                    392,
                    393,
                    397,
                    398
                ],
                "np.asarray": [
                    392
                ],
                "is_integer_dtype": [
                    393
                ],
                "target_array.ndim": [
                    393
                ],
                "locs": [
                    397,
                    398,
                    399,
                    400,
                    404,
                    405
                ],
                "valid": [
                    400,
                    404,
                    398,
                    399
                ],
                "ensure_platform_int": [
                    405
                ],
                "kwargs.get": [
                    413
                ],
                "self._simple_new": [
                    515,
                    744,
                    714,
                    748,
                    525,
                    537,
                    532,
                    505,
                    414
                ],
                "kwargs.setdefault": [
                    416
                ],
                "self._int64index._shallow_copy": [
                    417
                ],
                "self._int64index": [
                    417,
                    645,
                    781,
                    749,
                    784,
                    821,
                    639
                ],
                "self._validate_dtype": [
                    421
                ],
                "self.from_range": [
                    424
                ],
                "ibase._index_shared_docs": [
                    419
                ],
                "no_steps": [
                    547,
                    548,
                    552,
                    553,
                    427,
                    428,
                    433
                ],
                "np.nan": [
                    429
                ],
                "meth": [
                    430
                ],
                "nv.validate_minmax_axis": [
                    443,
                    437
                ],
                "nv": [
                    460,
                    437,
                    438,
                    443,
                    444
                ],
                "axis": [
                    443,
                    437
                ],
                "nv.validate_min": [
                    438
                ],
                "args": [
                    460,
                    444,
                    438
                ],
                "self._minmax": [
                    445,
                    439
                ],
                "nv.validate_max": [
                    444
                ],
                "nv.validate_argsort": [
                    460
                ],
                "other": [
                    643,
                    645,
                    773,
                    647,
                    775,
                    778,
                    781,
                    782,
                    784,
                    786,
                    789,
                    539,
                    821,
                    592,
                    593,
                    595,
                    598,
                    599,
                    471,
                    472,
                    473,
                    602,
                    604,
                    605,
                    735,
                    608,
                    738,
                    739,
                    740,
                    741,
                    746,
                    749,
                    498,
                    499,
                    501,
                    502,
                    504,
                    508,
                    639
                ],
                "other._range": [
                    472,
                    508
                ],
                "equals": [
                    473
                ],
                "self._validate_sort_keyword": [
                    496
                ],
                "sort": [
                    645,
                    647,
                    496,
                    593,
                    595,
                    502,
                    541,
                    639
                ],
                "self.equals": [
                    592,
                    498
                ],
                "self._get_reconciled_name_object": [
                    499
                ],
                "intersection": [
                    502
                ],
                "first": [
                    512,
                    513,
                    521,
                    524,
                    529,
                    530,
                    507
                ],
                "second": [
                    512,
                    513,
                    521,
                    524,
                    529,
                    530,
                    508
                ],
                "other.step": [
                    598,
                    599,
                    602,
                    539,
                    508
                ],
                "int_low": [
                    512,
                    514,
                    535
                ],
                "max": [
                    512,
                    611
                ],
                "first.start": [
                    512,
                    529,
                    524
                ],
                "second.start": [
                    512,
                    529,
                    524
                ],
                "int_high": [
                    513,
                    514,
                    531
                ],
                "min": [
                    513,
                    610
                ],
                "first.stop": [
                    513
                ],
                "second.stop": [
                    513
                ],
                "gcd": [
                    521,
                    530,
                    524,
                    529
                ],
                "s": [
                    568,
                    521,
                    562,
                    529
                ],
                "t": [
                    521,
                    563,
                    569
                ],
                "self._extended_gcd": [
                    521
                ],
                "first.step": [
                    521,
                    530,
                    529
                ],
                "second.step": [
                    521,
                    530
                ],
                "tmp_start": [
                    529,
                    531
                ],
                "new_step": [
                    530,
                    531
                ],
                "new_range": [
                    743,
                    744,
                    713,
                    714,
                    747,
                    748,
                    531,
                    532,
                    536,
                    537
                ],
                "new_index": [
                    532,
                    535,
                    536,
                    537,
                    539,
                    540,
                    542,
                    543
                ],
                "new_start": [
                    536,
                    535
                ],
                "new_index._min_fitting_element": [
                    535
                ],
                "new_index.stop": [
                    536
                ],
                "new_index.step": [
                    536,
                    539
                ],
                "new_index.sort_values": [
                    542
                ],
                "lower_limit": [
                    547
                ],
                "abs": [
                    547,
                    548,
                    552,
                    553,
                    621,
                    622,
                    605
                ],
                "upper_limit": [
                    552
                ],
                "old_s": [
                    568,
                    562,
                    570
                ],
                "old_t": [
                    569,
                    570,
                    563
                ],
                "r": [
                    564,
                    565,
                    566,
                    567
                ],
                "old_r": [
                    570,
                    564,
                    566,
                    567
                ],
                "b": [
                    564
                ],
                "a": [
                    564
                ],
                "quotient": [
                    568,
                    569,
                    566,
                    567
                ],
                "_union": [
                    593
                ],
                "start_s": [
                    610,
                    614,
                    615,
                    621,
                    627,
                    596,
                    628,
                    601,
                    634,
                    635
                ],
                "step_s": [
                    596,
                    601,
                    605,
                    607,
                    609,
                    612,
                    614,
                    615,
                    616,
                    618,
                    620,
                    621,
                    622,
                    624,
                    625,
                    627,
                    628,
                    629,
                    631,
                    632
                ],
                "end_s": [
                    611,
                    616,
                    622,
                    597,
                    629,
                    601,
                    636
                ],
                "start_o": [
                    610,
                    614,
                    616,
                    635,
                    621,
                    627,
                    628,
                    598,
                    634,
                    603
                ],
                "step_o": [
                    609,
                    612,
                    635,
                    625,
                    598,
                    632,
                    634,
                    603,
                    636,
                    605,
                    638,
                    607
                ],
                "other.start": [
                    605,
                    598,
                    599
                ],
                "end_o": [
                    611,
                    615,
                    622,
                    629,
                    599,
                    603,
                    636
                ],
                "start_r": [
                    610,
                    618,
                    624,
                    631,
                    638
                ],
                "end_r": [
                    611,
                    618,
                    624,
                    631,
                    638
                ],
                "self._int64index._union": [
                    639
                ],
                "how": [
                    643,
                    645,
                    647
                ],
                "self._int64index.join": [
                    645
                ],
                "level": [
                    645,
                    647
                ],
                "return_indexers": [
                    645,
                    647
                ],
                "join": [
                    647
                ],
                "next_": [
                    657,
                    691,
                    686,
                    679
                ],
                "non_empty_indexes": [
                    688,
                    691,
                    660,
                    662
                ],
                "obj": [
                    660,
                    662,
                    663
                ],
                "indexes": [
                    673,
                    682,
                    660
                ],
                "obj._range": [
                    663
                ],
                "np.concatenate": [
                    673,
                    682
                ],
                "x._values": [
                    673,
                    682
                ],
                "x": [
                    673,
                    682,
                    814
                ],
                "result.rename": [
                    674,
                    683
                ],
                "non_consecutive": [
                    681,
                    678
                ],
                "rename": [
                    696,
                    692
                ],
                "slice": [
                    712
                ],
                "IndexError": [
                    720,
                    725,
                    719
                ],
                "is_scalar": [
                    724
                ],
                "__getitem__": [
                    732
                ],
                "ABCSeries": [
                    773,
                    735
                ],
                "ABCDataFrame": [
                    773,
                    735
                ],
                "NotImplemented": [
                    736,
                    777,
                    774
                ],
                "any": [
                    755
                ],
                "ABCTimedeltaIndex": [
                    775
                ],
                "timedelta": [
                    778
                ],
                "np.timedelta64": [
                    778
                ],
                "op": [
                    806,
                    807,
                    781,
                    784,
                    821,
                    824
                ],
                "is_timedelta64_dtype": [
                    782
                ],
                "extract_array": [
                    786
                ],
                "left": [
                    803,
                    806,
                    807,
                    789,
                    795
                ],
                "right": [
                    795,
                    789,
                    806,
                    807
                ],
                "np.errstate": [
                    794,
                    805
                ],
                "rstep": [
                    803,
                    809,
                    814,
                    795,
                    799
                ],
                "left.step": [
                    803,
                    795
                ],
                "rstart": [
                    814,
                    809,
                    806
                ],
                "left.start": [
                    806
                ],
                "rstop": [
                    809,
                    814,
                    807
                ],
                "left.stop": [
                    807
                ],
                "all": [
                    814
                ],
                "result.astype": [
                    815
                ],
                "ZeroDivisionError": [
                    819
                ],
                "op.__name__": [
                    824
                ],
                "compat.set_function_name": [
                    825
                ],
                "compat": [
                    825
                ],
                "_evaluate_numeric_binop": [
                    825
                ],
                "cls.__add__": [
                    827
                ],
                "_make_evaluate_binop": [
                    832,
                    833,
                    834,
                    827,
                    828,
                    829,
                    830,
                    831
                ],
                "operator.add": [
                    827
                ],
                "operator": [
                    833,
                    827,
                    829,
                    831
                ],
                "cls.__radd__": [
                    828
                ],
                "ops.radd": [
                    828
                ],
                "ops": [
                    832,
                    834,
                    828,
                    830
                ],
                "cls.__sub__": [
                    829
                ],
                "operator.sub": [
                    829
                ],
                "cls.__rsub__": [
                    830
                ],
                "ops.rsub": [
                    830
                ],
                "cls.__mul__": [
                    831
                ],
                "operator.mul": [
                    831
                ],
                "cls.__rmul__": [
                    832
                ],
                "ops.rmul": [
                    832
                ],
                "cls.__truediv__": [
                    833
                ],
                "operator.truediv": [
                    833
                ],
                "cls.__rtruediv__": [
                    834
                ],
                "ops.rtruediv": [
                    834
                ],
                "RangeIndex._add_numeric_methods": [
                    837
                ]
            },
            "filtered_variables_in_file": {
                "Int64Index": [
                    673,
                    36,
                    198,
                    682,
                    179
                ],
                "_typ": [
                    74
                ],
                "_engine_type": [
                    75
                ],
                "libindex.Int64Engine": [
                    75
                ],
                "libindex": [
                    75
                ],
                "_range": [
                    76
                ],
                "_cached_data": [
                    79
                ],
                "fastpath": [
                    101,
                    94
                ],
                "warnings.warn": [
                    299,
                    275,
                    252,
                    95
                ],
                "warnings": [
                    299,
                    275,
                    252,
                    95
                ],
                "cls._simple_new": [
                    128,
                    110,
                    102,
                    146
                ],
                "cls": [
                    128,
                    832,
                    833,
                    834,
                    102,
                    104,
                    110,
                    142,
                    145,
                    146,
                    150,
                    825,
                    827,
                    828,
                    829,
                    830,
                    831
                ],
                "start": [
                    387,
                    390,
                    397,
                    657,
                    665,
                    667,
                    672,
                    676,
                    692,
                    740,
                    102,
                    742,
                    743,
                    746,
                    107,
                    108,
                    109,
                    110,
                    747,
                    113,
                    116,
                    119,
                    127
                ],
                "stop": [
                    387,
                    102,
                    390,
                    742,
                    743,
                    398,
                    113,
                    691,
                    692,
                    118,
                    119,
                    121,
                    127
                ],
                "step": [
                    387,
                    390,
                    398,
                    400,
                    657,
                    402,
                    793,
                    795,
                    668,
                    669,
                    670,
                    676,
                    678,
                    685,
                    686,
                    692,
                    741,
                    102,
                    742,
                    743,
                    113,
                    123,
                    124,
                    127
                ],
                "name": [
                    128,
                    161,
                    674,
                    414,
                    102,
                    422,
                    423,
                    424,
                    683,
                    108,
                    110,
                    146,
                    824,
                    692,
                    696,
                    825,
                    157,
                    413
                ],
                "cls._validate_dtype": [
                    104,
                    145
                ],
                "dtype": [
                    128,
                    421,
                    104,
                    173,
                    110,
                    145,
                    146,
                    157
                ],
                "RangeIndex": [
                    837,
                    107,
                    595,
                    692,
                    501,
                    471,
                    696
                ],
                "start.name": [
                    108
                ],
                "start._range": [
                    109
                ],
                "com.all_none": [
                    113
                ],
                "com": [
                    113
                ],
                "ensure_python_int": [
                    121,
                    123,
                    116,
                    366
                ],
                "rng": [
                    128,
                    672,
                    676,
                    678,
                    679,
                    663,
                    202,
                    203,
                    686,
                    311,
                    312,
                    313,
                    667,
                    668,
                    669,
                    127
                ],
                "data": [
                    146,
                    139,
                    142
                ],
                "cls.__name__": [
                    142
                ],
                "result": [
                    161,
                    673,
                    163,
                    674,
                    165,
                    166,
                    809,
                    682,
                    683,
                    815,
                    817,
                    150,
                    159
                ],
                "object.__new__": [
                    150
                ],
                "values": [
                    417,
                    153,
                    155,
                    156,
                    157,
                    412,
                    159
                ],
                "Index": [
                    157
                ],
                "kwargs": [
                    416,
                    417,
                    162,
                    460,
                    438,
                    444,
                    157,
                    413
                ],
                "result._range": [
                    159
                ],
                "result.name": [
                    161
                ],
                "k": [
                    162,
                    163
                ],
                "v": [
                    162,
                    163
                ],
                "kwargs.items": [
                    162
                ],
                "result._reset_identity": [
                    165
                ],
                "is_int64_dtype": [
                    173
                ],
                "cache_readonly": [
                    259,
                    196,
                    355,
                    236,
                    176,
                    306,
                    282,
                    351
                ],
                "self._cached_data": [
                    194,
                    190,
                    191
                ],
                "self": [
                    515,
                    521,
                    525,
                    532,
                    537,
                    539,
                    547,
                    548,
                    552,
                    553,
                    592,
                    596,
                    597,
                    600,
                    604,
                    605,
                    606,
                    618,
                    624,
                    631,
                    638,
                    639,
                    643,
                    645,
                    190,
                    191,
                    192,
                    702,
                    194,
                    706,
                    198,
                    713,
                    202,
                    714,
                    206,
                    207,
                    208,
                    718,
                    722,
                    217,
                    218,
                    219,
                    227,
                    739,
                    740,
                    741,
                    742,
                    744,
                    745,
                    746,
                    748,
                    749,
                    752,
                    242,
                    755,
                    253,
                    257,
                    264,
                    781,
                    784,
                    787,
                    276,
                    789,
                    280,
                    288,
                    809,
                    300,
                    304,
                    821,
                    311,
                    340,
                    353,
                    357,
                    369,
                    376,
                    386,
                    387,
                    390,
                    402,
                    404,
                    408,
                    413,
                    414,
                    416,
                    417,
                    421,
                    423,
                    424,
                    427,
                    430,
                    431,
                    433,
                    439,
                    445,
                    462,
                    463,
                    465,
                    472,
                    496,
                    498,
                    499,
                    504,
                    505,
                    507
                ],
                "np.arange": [
                    465,
                    463,
                    191
                ],
                "np": [
                    192,
                    673,
                    805,
                    392,
                    682,
                    363,
                    778,
                    429,
                    463,
                    465,
                    344,
                    794,
                    191
                ],
                "self.start": [
                    192,
                    257,
                    387,
                    547,
                    548,
                    390,
                    739,
                    552,
                    553,
                    740,
                    746,
                    431,
                    433,
                    596,
                    597,
                    605
                ],
                "self.stop": [
                    192,
                    280,
                    387,
                    390
                ],
                "self.step": [
                    386,
                    387,
                    390,
                    402,
                    539,
                    547,
                    548,
                    552,
                    553,
                    430,
                    304,
                    433,
                    192,
                    596,
                    597,
                    600,
                    739,
                    741,
                    507
                ],
                "np.int64": [
                    192,
                    344
                ],
                "Int64Index._simple_new": [
                    198
                ],
                "self._data": [
                    198
                ],
                "self.name": [
                    416,
                    198,
                    423,
                    744,
                    714,
                    748,
                    218,
                    219,
                    413
                ],
                "self._range": [
                    264,
                    408,
                    414,
                    288,
                    424,
                    311,
                    702,
                    713,
                    202,
                    462,
                    718,
                    472,
                    353,
                    227,
                    357,
                    752,
                    369,
                    242,
                    755,
                    376,
                    507
                ],
                "rng.start": [
                    672,
                    676,
                    679,
                    203,
                    667
                ],
                "rng.stop": [
                    203
                ],
                "rng.step": [
                    203,
                    669,
                    678
                ],
                "d": [
                    208,
                    206,
                    207
                ],
                "self._get_attributes_dict": [
                    787,
                    206
                ],
                "d.update": [
                    207
                ],
                "self._get_data_as_items": [
                    217,
                    207
                ],
                "ibase._new_Index": [
                    208
                ],
                "ibase": [
                    208,
                    219,
                    419
                ],
                "self.__class__": [
                    809,
                    618,
                    208,
                    624,
                    631,
                    638
                ],
                "attrs": [
                    809,
                    787,
                    217,
                    219,
                    220
                ],
                "attrs.append": [
                    219
                ],
                "ibase.default_pprint": [
                    219
                ],
                "header": [
                    227
                ],
                "pprint_thing": [
                    227
                ],
                "_deprecation_message": [
                    230
                ],
                "self._range.start": [
                    242
                ],
                "self._deprecation_message.format": [
                    276,
                    253,
                    300
                ],
                "self._deprecation_message": [
                    276,
                    253,
                    300
                ],
                "self._range.stop": [
                    264
                ],
                "self._range.step": [
                    288,
                    353,
                    357,
                    462
                ],
                "getsizeof": [
                    312,
                    313
                ],
                "attr_name": [
                    313,
                    314
                ],
                "self.nbytes": [
                    340
                ],
                "np.dtype": [
                    344
                ],
                "Union": [
                    363
                ],
                "np.integer": [
                    363
                ],
                "key": [
                    712,
                    713,
                    715,
                    364,
                    716,
                    366,
                    369,
                    722,
                    724,
                    373,
                    374,
                    378,
                    379,
                    732
                ],
                "is_integer": [
                    738,
                    715,
                    814,
                    373,
                    799
                ],
                "method": [
                    384,
                    395,
                    373,
                    379,
                    383
                ],
                "tolerance": [
                    384,
                    395,
                    373,
                    379,
                    383
                ],
                "new_key": [
                    376,
                    716,
                    718,
                    374
                ],
                "self._range.index": [
                    376
                ],
                "get_loc": [
                    379
                ],
                "Appender": [
                    641,
                    419,
                    371,
                    410,
                    381
                ],
                "_index_shared_docs": [
                    641,
                    410,
                    371,
                    381
                ],
                "is_list_like": [
                    383
                ],
                "target": [
                    384,
                    395,
                    392,
                    383
                ],
                "get_indexer": [
                    384,
                    395
                ],
                "target_array": [
                    392,
                    393,
                    397,
                    398
                ],
                "np.asarray": [
                    392
                ],
                "is_integer_dtype": [
                    393
                ],
                "target_array.ndim": [
                    393
                ],
                "locs": [
                    397,
                    398,
                    399,
                    400,
                    404,
                    405
                ],
                "valid": [
                    400,
                    404,
                    398,
                    399
                ],
                "ensure_platform_int": [
                    405
                ],
                "kwargs.get": [
                    413
                ],
                "self._simple_new": [
                    515,
                    744,
                    714,
                    748,
                    525,
                    537,
                    532,
                    505,
                    414
                ],
                "kwargs.setdefault": [
                    416
                ],
                "self._int64index._shallow_copy": [
                    417
                ],
                "self._int64index": [
                    417,
                    645,
                    781,
                    749,
                    784,
                    821,
                    639
                ],
                "self._validate_dtype": [
                    421
                ],
                "self.from_range": [
                    424
                ],
                "ibase._index_shared_docs": [
                    419
                ],
                "no_steps": [
                    547,
                    548,
                    552,
                    553,
                    427,
                    428,
                    433
                ],
                "np.nan": [
                    429
                ],
                "meth": [
                    430
                ],
                "nv.validate_minmax_axis": [
                    443,
                    437
                ],
                "nv": [
                    460,
                    437,
                    438,
                    443,
                    444
                ],
                "axis": [
                    443,
                    437
                ],
                "nv.validate_min": [
                    438
                ],
                "args": [
                    460,
                    444,
                    438
                ],
                "self._minmax": [
                    445,
                    439
                ],
                "nv.validate_max": [
                    444
                ],
                "nv.validate_argsort": [
                    460
                ],
                "other": [
                    643,
                    645,
                    773,
                    647,
                    775,
                    778,
                    781,
                    782,
                    784,
                    786,
                    789,
                    539,
                    821,
                    592,
                    593,
                    595,
                    598,
                    599,
                    471,
                    472,
                    473,
                    602,
                    604,
                    605,
                    735,
                    608,
                    738,
                    739,
                    740,
                    741,
                    746,
                    749,
                    498,
                    499,
                    501,
                    502,
                    504,
                    508,
                    639
                ],
                "other._range": [
                    472,
                    508
                ],
                "equals": [
                    473
                ],
                "self._validate_sort_keyword": [
                    496
                ],
                "sort": [
                    645,
                    647,
                    496,
                    593,
                    595,
                    502,
                    541,
                    639
                ],
                "self.equals": [
                    592,
                    498
                ],
                "self._get_reconciled_name_object": [
                    499
                ],
                "intersection": [
                    502
                ],
                "first": [
                    512,
                    513,
                    521,
                    524,
                    529,
                    530,
                    507
                ],
                "second": [
                    512,
                    513,
                    521,
                    524,
                    529,
                    530,
                    508
                ],
                "other.step": [
                    598,
                    599,
                    602,
                    539,
                    508
                ],
                "int_low": [
                    512,
                    514,
                    535
                ],
                "first.start": [
                    512,
                    529,
                    524
                ],
                "second.start": [
                    512,
                    529,
                    524
                ],
                "int_high": [
                    513,
                    514,
                    531
                ],
                "first.stop": [
                    513
                ],
                "second.stop": [
                    513
                ],
                "gcd": [
                    521,
                    530,
                    524,
                    529
                ],
                "s": [
                    568,
                    521,
                    562,
                    529
                ],
                "t": [
                    521,
                    563,
                    569
                ],
                "self._extended_gcd": [
                    521
                ],
                "first.step": [
                    521,
                    530,
                    529
                ],
                "second.step": [
                    521,
                    530
                ],
                "tmp_start": [
                    529,
                    531
                ],
                "new_step": [
                    530,
                    531
                ],
                "new_range": [
                    743,
                    744,
                    713,
                    714,
                    747,
                    748,
                    531,
                    532,
                    536,
                    537
                ],
                "new_index": [
                    532,
                    535,
                    536,
                    537,
                    539,
                    540,
                    542,
                    543
                ],
                "new_start": [
                    536,
                    535
                ],
                "new_index._min_fitting_element": [
                    535
                ],
                "new_index.stop": [
                    536
                ],
                "new_index.step": [
                    536,
                    539
                ],
                "new_index.sort_values": [
                    542
                ],
                "lower_limit": [
                    547
                ],
                "upper_limit": [
                    552
                ],
                "old_s": [
                    568,
                    562,
                    570
                ],
                "old_t": [
                    569,
                    570,
                    563
                ],
                "r": [
                    564,
                    565,
                    566,
                    567
                ],
                "old_r": [
                    570,
                    564,
                    566,
                    567
                ],
                "b": [
                    564
                ],
                "a": [
                    564
                ],
                "quotient": [
                    568,
                    569,
                    566,
                    567
                ],
                "_union": [
                    593
                ],
                "start_s": [
                    610,
                    614,
                    615,
                    621,
                    627,
                    596,
                    628,
                    601,
                    634,
                    635
                ],
                "step_s": [
                    596,
                    601,
                    605,
                    607,
                    609,
                    612,
                    614,
                    615,
                    616,
                    618,
                    620,
                    621,
                    622,
                    624,
                    625,
                    627,
                    628,
                    629,
                    631,
                    632
                ],
                "end_s": [
                    611,
                    616,
                    622,
                    597,
                    629,
                    601,
                    636
                ],
                "start_o": [
                    610,
                    614,
                    616,
                    635,
                    621,
                    627,
                    628,
                    598,
                    634,
                    603
                ],
                "step_o": [
                    609,
                    612,
                    635,
                    625,
                    598,
                    632,
                    634,
                    603,
                    636,
                    605,
                    638,
                    607
                ],
                "other.start": [
                    605,
                    598,
                    599
                ],
                "end_o": [
                    611,
                    615,
                    622,
                    629,
                    599,
                    603,
                    636
                ],
                "start_r": [
                    610,
                    618,
                    624,
                    631,
                    638
                ],
                "end_r": [
                    611,
                    618,
                    624,
                    631,
                    638
                ],
                "self._int64index._union": [
                    639
                ],
                "how": [
                    643,
                    645,
                    647
                ],
                "self._int64index.join": [
                    645
                ],
                "level": [
                    645,
                    647
                ],
                "return_indexers": [
                    645,
                    647
                ],
                "join": [
                    647
                ],
                "next_": [
                    657,
                    691,
                    686,
                    679
                ],
                "non_empty_indexes": [
                    688,
                    691,
                    660,
                    662
                ],
                "obj": [
                    660,
                    662,
                    663
                ],
                "indexes": [
                    673,
                    682,
                    660
                ],
                "obj._range": [
                    663
                ],
                "np.concatenate": [
                    673,
                    682
                ],
                "x._values": [
                    673,
                    682
                ],
                "x": [
                    673,
                    682,
                    814
                ],
                "result.rename": [
                    674,
                    683
                ],
                "non_consecutive": [
                    681,
                    678
                ],
                "rename": [
                    696,
                    692
                ],
                "is_scalar": [
                    724
                ],
                "__getitem__": [
                    732
                ],
                "ABCSeries": [
                    773,
                    735
                ],
                "ABCDataFrame": [
                    773,
                    735
                ],
                "ABCTimedeltaIndex": [
                    775
                ],
                "timedelta": [
                    778
                ],
                "np.timedelta64": [
                    778
                ],
                "op": [
                    806,
                    807,
                    781,
                    784,
                    821,
                    824
                ],
                "is_timedelta64_dtype": [
                    782
                ],
                "extract_array": [
                    786
                ],
                "left": [
                    803,
                    806,
                    807,
                    789,
                    795
                ],
                "right": [
                    795,
                    789,
                    806,
                    807
                ],
                "np.errstate": [
                    794,
                    805
                ],
                "rstep": [
                    803,
                    809,
                    814,
                    795,
                    799
                ],
                "left.step": [
                    803,
                    795
                ],
                "rstart": [
                    814,
                    809,
                    806
                ],
                "left.start": [
                    806
                ],
                "rstop": [
                    809,
                    814,
                    807
                ],
                "left.stop": [
                    807
                ],
                "result.astype": [
                    815
                ],
                "op.__name__": [
                    824
                ],
                "compat.set_function_name": [
                    825
                ],
                "compat": [
                    825
                ],
                "_evaluate_numeric_binop": [
                    825
                ],
                "cls.__add__": [
                    827
                ],
                "_make_evaluate_binop": [
                    832,
                    833,
                    834,
                    827,
                    828,
                    829,
                    830,
                    831
                ],
                "operator.add": [
                    827
                ],
                "operator": [
                    833,
                    827,
                    829,
                    831
                ],
                "cls.__radd__": [
                    828
                ],
                "ops.radd": [
                    828
                ],
                "ops": [
                    832,
                    834,
                    828,
                    830
                ],
                "cls.__sub__": [
                    829
                ],
                "operator.sub": [
                    829
                ],
                "cls.__rsub__": [
                    830
                ],
                "ops.rsub": [
                    830
                ],
                "cls.__mul__": [
                    831
                ],
                "operator.mul": [
                    831
                ],
                "cls.__rmul__": [
                    832
                ],
                "ops.rmul": [
                    832
                ],
                "cls.__truediv__": [
                    833
                ],
                "operator.truediv": [
                    833
                ],
                "cls.__rtruediv__": [
                    834
                ],
                "ops.rtruediv": [
                    834
                ],
                "RangeIndex._add_numeric_methods": [
                    837
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/home/ubuntu/Desktop/bgp_envs_local/repos/pandas_143/pandas/tests/frame/test_indexing.py",
                "test_function": "test_reindex_limit",
                "test_function_code": "    def test_reindex_limit(self):\n        # GH 28631\n        data = [[\"A\", \"A\", \"A\"], [\"B\", \"B\", \"B\"], [\"C\", \"C\", \"C\"], [\"D\", \"D\", \"D\"]]\n        exp_data = [\n            [\"A\", \"A\", \"A\"],\n            [\"B\", \"B\", \"B\"],\n            [\"C\", \"C\", \"C\"],\n            [\"D\", \"D\", \"D\"],\n            [\"D\", \"D\", \"D\"],\n            [np.nan, np.nan, np.nan],\n        ]\n        df = DataFrame(data)\n        result = df.reindex([0, 1, 2, 3, 4, 5], method=\"ffill\", limit=1)\n        expected = DataFrame(exp_data)\n        tm.assert_frame_equal(result, expected)",
                "test_error": "AssertionError: DataFrame.iloc[:, 0] are different  DataFrame.iloc[:, 0] values are different (16.66667 %) [left]:  [A, B, C, D, D, D] [right]: [A, B, C, D, D, nan]",
                "full_test_error": "self = <pandas.tests.frame.test_indexing.TestDataFrameIndexing object at 0x7f2450ddd910>\n\n    def test_reindex_limit(self):\n        # GH 28631\n        data = [[\"A\", \"A\", \"A\"], [\"B\", \"B\", \"B\"], [\"C\", \"C\", \"C\"], [\"D\", \"D\", \"D\"]]\n        exp_data = [\n            [\"A\", \"A\", \"A\"],\n            [\"B\", \"B\", \"B\"],\n            [\"C\", \"C\", \"C\"],\n            [\"D\", \"D\", \"D\"],\n            [\"D\", \"D\", \"D\"],\n            [np.nan, np.nan, np.nan],\n        ]\n        df = DataFrame(data)\n        result = df.reindex([0, 1, 2, 3, 4, 5], method=\"ffill\", limit=1)\n        expected = DataFrame(exp_data)\n>       tm.assert_frame_equal(result, expected)\n\npandas/tests/frame/test_indexing.py:2234: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/_libs/testing.pyx:65: in pandas._libs.testing.assert_almost_equal\n    cpdef assert_almost_equal(a, b,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>   raise_assert_detail(obj, msg, lobj, robj)\nE   AssertionError: DataFrame.iloc[:, 0] are different\nE   \nE   DataFrame.iloc[:, 0] values are different (16.66667 %)\nE   [left]:  [A, B, C, D, D, D]\nE   [right]: [A, B, C, D, D, nan]\n\npandas/_libs/testing.pyx:176: AssertionError",
                "traceback": "pandas/_libs/testing.pyx:65: in pandas._libs.testing.assert_almost_equal\n    cpdef assert_almost_equal(a, b,",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>   raise_assert_detail(obj, msg, lobj, robj)\nE   AssertionError: DataFrame.iloc[:, 0] are different\nE   \nE   DataFrame.iloc[:, 0] values are different (16.66667 %)\nE   [left]:  [A, B, C, D, D, D]\nE   [right]: [A, B, C, D, D, nan]\n\npandas/_libs/testing.pyx:176: AssertionError",
                "test_function_decorators": []
            },
            {
                "test_path": "/home/ubuntu/Desktop/bgp_envs_local/repos/pandas_143/pandas/tests/indexes/test_range.py",
                "test_function": "test_get_indexer_limit",
                "test_function_code": "    def test_get_indexer_limit(self):\n        # GH 28631\n        idx = RangeIndex(4)\n        target = RangeIndex(6)\n        result = idx.get_indexer(target, method=\"pad\", limit=1)\n        expected = np.array([0, 1, 2, 3, 3, -1], dtype=np.intp)\n        tm.assert_numpy_array_equal(result, expected)",
                "test_error": "AssertionError: numpy array are different  numpy array values are different (16.66667 %) [left]:  [0, 1, 2, 3, 3, 3] [right]: [0, 1, 2, 3, 3, -1]",
                "full_test_error": "self = <pandas.tests.indexes.test_range.TestRangeIndex object at 0x7f2436caf160>\n\n    def test_get_indexer_limit(self):\n        # GH 28631\n        idx = RangeIndex(4)\n        target = RangeIndex(6)\n        result = idx.get_indexer(target, method=\"pad\", limit=1)\n        expected = np.array([0, 1, 2, 3, 3, -1], dtype=np.intp)\n>       tm.assert_numpy_array_equal(result, expected)\n\npandas/tests/indexes/test_range.py:425: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = array([0, 1, 2, 3, 3, 3]), right = array([ 0,  1,  2,  3,  3, -1])\nerr_msg = None\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n                raise_assert_detail(\n                    obj,\n                    \"{obj} shapes are different\".format(obj=obj),\n                    left.shape,\n                    right.shape,\n                )\n    \n            diff = 0\n            for l, r in zip(left, right):\n                # count up differences\n                if not array_equivalent(l, r, strict_nan=strict_nan):\n                    diff += 1\n    \n            diff = diff * 100.0 / left.size\n            msg = \"{obj} values are different ({pct} %)\".format(\n                obj=obj, pct=np.round(diff, 5)\n            )\n>           raise_assert_detail(obj, msg, left, right)\nE           AssertionError: numpy array are different\nE           \nE           numpy array values are different (16.66667 %)\nE           [left]:  [0, 1, 2, 3, 3, 3]\nE           [right]: [0, 1, 2, 3, 3, -1]\n\npandas/util/testing.py:1004: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            }
        ]
    }
}