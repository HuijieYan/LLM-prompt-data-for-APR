{
    "1.1.1": "def _coerce_to_type(x):\n    \n    dtype = None\n\n    if is_datetime64tz_dtype(x):\n        dtype = x.dtype\n    elif is_datetime64_dtype(x):\n        x = to_datetime(x)\n        dtype = np.dtype(\"datetime64[ns]\")\n    elif is_timedelta64_dtype(x):\n        x = to_timedelta(x)\n        dtype = np.dtype(\"timedelta64[ns]\")\n\n    if dtype is not None:\n        # GH 19768: force NaT to NaN during integer conversion\n        x = np.where(x.notna(), x.view(np.int64), np.nan)\n\n    return x, dtype\n",
    "1.1.2": "if the passed data is of datetime/timedelta type,\nthis method converts it to numeric so that cut method can\nhandle it",
    "1.2.1": null,
    "1.2.2": null,
    "1.2.3": null,
    "1.3.1": "pandas/core/reshape/tile.py",
    "1.3.2": null,
    "1.4.1": [
        "@pytest.mark.parametrize(\"bins\", [6, 7])\n@pytest.mark.parametrize(\n    \"box, compare\",\n    [\n        (Series, tm.assert_series_equal),\n        (np.array, tm.assert_categorical_equal),\n        (list, tm.assert_equal),\n    ],\n)\ndef test_qcut_bool_coercion_to_int(bins, box, compare):\n    # issue 20303\n    data_expected = box([0, 1, 1, 0, 1] * 10)\n    data_result = box([False, True, True, False, True] * 10)\n    expected = qcut(data_expected, bins, duplicates=\"drop\")\n    result = qcut(data_result, bins, duplicates=\"drop\")\n    compare(result, expected)",
        "@pytest.mark.parametrize(\"bins\", [6, 7])\n@pytest.mark.parametrize(\n    \"box, compare\",\n    [\n        (Series, tm.assert_series_equal),\n        (np.array, tm.assert_categorical_equal),\n        (list, tm.assert_equal),\n    ],\n)\ndef test_qcut_bool_coercion_to_int(bins, box, compare):\n    # issue 20303\n    data_expected = box([0, 1, 1, 0, 1] * 10)\n    data_result = box([False, True, True, False, True] * 10)\n    expected = qcut(data_expected, bins, duplicates=\"drop\")\n    result = qcut(data_result, bins, duplicates=\"drop\")\n    compare(result, expected)",
        "@pytest.mark.parametrize(\"bins\", [6, 7])\n@pytest.mark.parametrize(\n    \"box, compare\",\n    [\n        (Series, tm.assert_series_equal),\n        (np.array, tm.assert_categorical_equal),\n        (list, tm.assert_equal),\n    ],\n)\ndef test_qcut_bool_coercion_to_int(bins, box, compare):\n    # issue 20303\n    data_expected = box([0, 1, 1, 0, 1] * 10)\n    data_result = box([False, True, True, False, True] * 10)\n    expected = qcut(data_expected, bins, duplicates=\"drop\")\n    result = qcut(data_result, bins, duplicates=\"drop\")\n    compare(result, expected)",
        "@pytest.mark.parametrize(\"bins\", [6, 7])\n@pytest.mark.parametrize(\n    \"box, compare\",\n    [\n        (Series, tm.assert_series_equal),\n        (np.array, tm.assert_categorical_equal),\n        (list, tm.assert_equal),\n    ],\n)\ndef test_qcut_bool_coercion_to_int(bins, box, compare):\n    # issue 20303\n    data_expected = box([0, 1, 1, 0, 1] * 10)\n    data_result = box([False, True, True, False, True] * 10)\n    expected = qcut(data_expected, bins, duplicates=\"drop\")\n    result = qcut(data_result, bins, duplicates=\"drop\")\n    compare(result, expected)",
        "@pytest.mark.parametrize(\"bins\", [6, 7])\n@pytest.mark.parametrize(\n    \"box, compare\",\n    [\n        (Series, tm.assert_series_equal),\n        (np.array, tm.assert_categorical_equal),\n        (list, tm.assert_equal),\n    ],\n)\ndef test_qcut_bool_coercion_to_int(bins, box, compare):\n    # issue 20303\n    data_expected = box([0, 1, 1, 0, 1] * 10)\n    data_result = box([False, True, True, False, True] * 10)\n    expected = qcut(data_expected, bins, duplicates=\"drop\")\n    result = qcut(data_result, bins, duplicates=\"drop\")\n    compare(result, expected)",
        "@pytest.mark.parametrize(\"bins\", [6, 7])\n@pytest.mark.parametrize(\n    \"box, compare\",\n    [\n        (Series, tm.assert_series_equal),\n        (np.array, tm.assert_categorical_equal),\n        (list, tm.assert_equal),\n    ],\n)\ndef test_qcut_bool_coercion_to_int(bins, box, compare):\n    # issue 20303\n    data_expected = box([0, 1, 1, 0, 1] * 10)\n    data_result = box([False, True, True, False, True] * 10)\n    expected = qcut(data_expected, bins, duplicates=\"drop\")\n    result = qcut(data_result, bins, duplicates=\"drop\")\n    compare(result, expected)"
    ],
    "1.4.2": [
        "pandas/tests/reshape/test_qcut.py",
        "pandas/tests/reshape/test_qcut.py",
        "pandas/tests/reshape/test_qcut.py",
        "pandas/tests/reshape/test_qcut.py",
        "pandas/tests/reshape/test_qcut.py",
        "pandas/tests/reshape/test_qcut.py"
    ],
    "2.1.1": [
        [
            "E       TypeError: numpy boolean subtract, the `-` operator, is not supported, use the bitwise_xor, the `^` operator, or the logical_xor function instead."
        ],
        [
            "E       TypeError: numpy boolean subtract, the `-` operator, is not supported, use the bitwise_xor, the `^` operator, or the logical_xor function instead."
        ],
        [
            "E       TypeError: numpy boolean subtract, the `-` operator, is not supported, use the bitwise_xor, the `^` operator, or the logical_xor function instead."
        ],
        [
            "E       TypeError: numpy boolean subtract, the `-` operator, is not supported, use the bitwise_xor, the `^` operator, or the logical_xor function instead."
        ],
        [
            "E       TypeError: numpy boolean subtract, the `-` operator, is not supported, use the bitwise_xor, the `^` operator, or the logical_xor function instead."
        ],
        [
            "E       TypeError: numpy boolean subtract, the `-` operator, is not supported, use the bitwise_xor, the `^` operator, or the logical_xor function instead."
        ]
    ],
    "2.1.2": [
        [
            "bins = 6, box = <class 'pandas.core.series.Series'>\ncompare = <function assert_series_equal at 0x7ff9e9d4ba60>\n\n    @pytest.mark.parametrize(\"bins\", [6, 7])\n    @pytest.mark.parametrize(\n        \"box, compare\",\n        [\n            (Series, tm.assert_series_equal),\n            (np.array, tm.assert_categorical_equal),\n            (list, tm.assert_equal),\n        ],\n    )\n    def test_qcut_bool_coercion_to_int(bins, box, compare):\n        # issue 20303\n        data_expected = box([0, 1, 1, 0, 1] * 10)\n        data_result = box([False, True, True, False, True] * 10)\n        expected = qcut(data_expected, bins, duplicates=\"drop\")\n>       result = qcut(data_result, bins, duplicates=\"drop\")\n\npandas/tests/reshape/test_qcut.py:255: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/tile.py:340: in qcut\n    bins = algos.quantile(x, quantiles)\npandas/core/algorithms.py:1096: in quantile\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1096: in <listcomp>\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1079: in _get_score\n    score = _interpolate(values[int(idx)], values[int(idx) + 1], idx % 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = False, b = False, fraction = 0.16666666666666607\n\n    def _interpolate(a, b, fraction):\n        \"\"\"Returns the point at the given fraction between a and b, where\n        'fraction' must be between 0 and 1.\n        \"\"\"\n>       return a + (b - a) * fraction",
            "\npandas/core/algorithms.py:1068: TypeError"
        ],
        [
            "bins = 7, box = <class 'pandas.core.series.Series'>\ncompare = <function assert_series_equal at 0x7ff9e9d4ba60>\n\n    @pytest.mark.parametrize(\"bins\", [6, 7])\n    @pytest.mark.parametrize(\n        \"box, compare\",\n        [\n            (Series, tm.assert_series_equal),\n            (np.array, tm.assert_categorical_equal),\n            (list, tm.assert_equal),\n        ],\n    )\n    def test_qcut_bool_coercion_to_int(bins, box, compare):\n        # issue 20303\n        data_expected = box([0, 1, 1, 0, 1] * 10)\n        data_result = box([False, True, True, False, True] * 10)\n        expected = qcut(data_expected, bins, duplicates=\"drop\")\n>       result = qcut(data_result, bins, duplicates=\"drop\")\n\npandas/tests/reshape/test_qcut.py:255: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/tile.py:340: in qcut\n    bins = algos.quantile(x, quantiles)\npandas/core/algorithms.py:1096: in quantile\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1096: in <listcomp>\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1079: in _get_score\n    score = _interpolate(values[int(idx)], values[int(idx) + 1], idx % 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = True, b = True, fraction = 0.9999999999999929\n\n    def _interpolate(a, b, fraction):\n        \"\"\"Returns the point at the given fraction between a and b, where\n        'fraction' must be between 0 and 1.\n        \"\"\"\n>       return a + (b - a) * fraction",
            "\npandas/core/algorithms.py:1068: TypeError"
        ],
        [
            "bins = 6, box = <built-in function array>\ncompare = <function assert_categorical_equal at 0x7ff9e9d4b5e0>\n\n    @pytest.mark.parametrize(\"bins\", [6, 7])\n    @pytest.mark.parametrize(\n        \"box, compare\",\n        [\n            (Series, tm.assert_series_equal),\n            (np.array, tm.assert_categorical_equal),\n            (list, tm.assert_equal),\n        ],\n    )\n    def test_qcut_bool_coercion_to_int(bins, box, compare):\n        # issue 20303\n        data_expected = box([0, 1, 1, 0, 1] * 10)\n        data_result = box([False, True, True, False, True] * 10)\n        expected = qcut(data_expected, bins, duplicates=\"drop\")\n>       result = qcut(data_result, bins, duplicates=\"drop\")\n\npandas/tests/reshape/test_qcut.py:255: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/tile.py:340: in qcut\n    bins = algos.quantile(x, quantiles)\npandas/core/algorithms.py:1096: in quantile\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1096: in <listcomp>\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1079: in _get_score\n    score = _interpolate(values[int(idx)], values[int(idx) + 1], idx % 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = False, b = False, fraction = 0.16666666666666607\n\n    def _interpolate(a, b, fraction):\n        \"\"\"Returns the point at the given fraction between a and b, where\n        'fraction' must be between 0 and 1.\n        \"\"\"\n>       return a + (b - a) * fraction",
            "\npandas/core/algorithms.py:1068: TypeError"
        ],
        [
            "bins = 7, box = <built-in function array>\ncompare = <function assert_categorical_equal at 0x7ff9e9d4b5e0>\n\n    @pytest.mark.parametrize(\"bins\", [6, 7])\n    @pytest.mark.parametrize(\n        \"box, compare\",\n        [\n            (Series, tm.assert_series_equal),\n            (np.array, tm.assert_categorical_equal),\n            (list, tm.assert_equal),\n        ],\n    )\n    def test_qcut_bool_coercion_to_int(bins, box, compare):\n        # issue 20303\n        data_expected = box([0, 1, 1, 0, 1] * 10)\n        data_result = box([False, True, True, False, True] * 10)\n        expected = qcut(data_expected, bins, duplicates=\"drop\")\n>       result = qcut(data_result, bins, duplicates=\"drop\")\n\npandas/tests/reshape/test_qcut.py:255: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/tile.py:340: in qcut\n    bins = algos.quantile(x, quantiles)\npandas/core/algorithms.py:1096: in quantile\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1096: in <listcomp>\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1079: in _get_score\n    score = _interpolate(values[int(idx)], values[int(idx) + 1], idx % 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = True, b = True, fraction = 0.9999999999999929\n\n    def _interpolate(a, b, fraction):\n        \"\"\"Returns the point at the given fraction between a and b, where\n        'fraction' must be between 0 and 1.\n        \"\"\"\n>       return a + (b - a) * fraction",
            "\npandas/core/algorithms.py:1068: TypeError"
        ],
        [
            "bins = 6, box = <class 'list'>\ncompare = <function assert_equal at 0x7ff9e9d4bb80>\n\n    @pytest.mark.parametrize(\"bins\", [6, 7])\n    @pytest.mark.parametrize(\n        \"box, compare\",\n        [\n            (Series, tm.assert_series_equal),\n            (np.array, tm.assert_categorical_equal),\n            (list, tm.assert_equal),\n        ],\n    )\n    def test_qcut_bool_coercion_to_int(bins, box, compare):\n        # issue 20303\n        data_expected = box([0, 1, 1, 0, 1] * 10)\n        data_result = box([False, True, True, False, True] * 10)\n        expected = qcut(data_expected, bins, duplicates=\"drop\")\n>       result = qcut(data_result, bins, duplicates=\"drop\")\n\npandas/tests/reshape/test_qcut.py:255: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/tile.py:340: in qcut\n    bins = algos.quantile(x, quantiles)\npandas/core/algorithms.py:1096: in quantile\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1096: in <listcomp>\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1079: in _get_score\n    score = _interpolate(values[int(idx)], values[int(idx) + 1], idx % 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = False, b = False, fraction = 0.16666666666666607\n\n    def _interpolate(a, b, fraction):\n        \"\"\"Returns the point at the given fraction between a and b, where\n        'fraction' must be between 0 and 1.\n        \"\"\"\n>       return a + (b - a) * fraction",
            "\npandas/core/algorithms.py:1068: TypeError"
        ],
        [
            "bins = 7, box = <class 'list'>\ncompare = <function assert_equal at 0x7ff9e9d4bb80>\n\n    @pytest.mark.parametrize(\"bins\", [6, 7])\n    @pytest.mark.parametrize(\n        \"box, compare\",\n        [\n            (Series, tm.assert_series_equal),\n            (np.array, tm.assert_categorical_equal),\n            (list, tm.assert_equal),\n        ],\n    )\n    def test_qcut_bool_coercion_to_int(bins, box, compare):\n        # issue 20303\n        data_expected = box([0, 1, 1, 0, 1] * 10)\n        data_result = box([False, True, True, False, True] * 10)\n        expected = qcut(data_expected, bins, duplicates=\"drop\")\n>       result = qcut(data_result, bins, duplicates=\"drop\")\n\npandas/tests/reshape/test_qcut.py:255: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/tile.py:340: in qcut\n    bins = algos.quantile(x, quantiles)\npandas/core/algorithms.py:1096: in quantile\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1096: in <listcomp>\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1079: in _get_score\n    score = _interpolate(values[int(idx)], values[int(idx) + 1], idx % 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = True, b = True, fraction = 0.9999999999999929\n\n    def _interpolate(a, b, fraction):\n        \"\"\"Returns the point at the given fraction between a and b, where\n        'fraction' must be between 0 and 1.\n        \"\"\"\n>       return a + (b - a) * fraction",
            "\npandas/core/algorithms.py:1068: TypeError"
        ]
    ],
    "2.1.3": [
        [
            {
                "x": {
                    "value": "0     0\n1     1\n2     1\n3     0\n4     1\n5     0\n6     1\n7     1\n8     0\n9     1\n10    0\n11    1\n12    1\n13    0\n14    1\n15    0\n16    1\n17    1\n18    0\n19    1\n20    0\n21    1\n22    1\n23    0\n24    1\n25    0\n26    1\n27    1\n28    0\n29    1\n30    0\n31    1\n32    1\n33    0\n34    1\n35    0\n36    1\n37    1\n38    0\n39    1\n40    0\n41    1\n42    1\n43    0\n44    1\n45    0\n46    1\n47    1\n48    0\n49    1\ndtype: int64",
                    "shape": "(50,)",
                    "omitted": false
                },
                "x.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "x": {
                    "value": "0     False\n1      True\n2       ...  False\n49     True\ndtype: bool",
                    "shape": "(50,)",
                    "omitted": true
                },
                "x.dtype": {
                    "value": "dtype('bool')",
                    "shape": "()",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "x": {
                    "value": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                    "shape": "(50,)",
                    "omitted": false
                },
                "x.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "x": {
                    "value": "array([False,  True,  True, False,  True, False,  True,  True, False,\n        True, False,  True,  True, False,  True, False,  True,  True,\n       False,  True, False,  True,  True, False,  True, False,  True,\n        True, False,  True, False,  True,  True, False,  True, False,\n        True,  True, False,  True, False,  True,  True, False,  True,\n       False,  True,  True, False,  True])",
                    "shape": "(50,)",
                    "omitted": false
                },
                "x.dtype": {
                    "value": "dtype('bool')",
                    "shape": "()",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "x": {
                    "value": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                    "shape": "(50,)",
                    "omitted": false
                },
                "x.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "x": {
                    "value": "array([False,  True,  True, False,  True, False,  True,  True, False,\n        True, False,  True,  True, False,  True, False,  True,  True,\n       False,  True, False,  True,  True, False,  True, False,  True,\n        True, False,  True, False,  True,  True, False,  True, False,\n        True,  True, False,  True, False,  True,  True, False,  True,\n       False,  True,  True, False,  True])",
                    "shape": "(50,)",
                    "omitted": false
                },
                "x.dtype": {
                    "value": "dtype('bool')",
                    "shape": "()",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "x": {
                    "value": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                    "shape": "(50,)",
                    "omitted": false
                },
                "x.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "x": {
                    "value": "array([False,  True,  True, False,  True, False,  True,  True, False,\n        True, False,  True,  True, False,  True, False,  True,  True,\n       False,  True, False,  True,  True, False,  True, False,  True,\n        True, False,  True, False,  True,  True, False,  True, False,\n        True,  True, False,  True, False,  True,  True, False,  True,\n       False,  True,  True, False,  True])",
                    "shape": "(50,)",
                    "omitted": false
                },
                "x.dtype": {
                    "value": "dtype('bool')",
                    "shape": "()",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "x": {
                    "value": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                    "shape": "(50,)",
                    "omitted": false
                },
                "x.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "x": {
                    "value": "array([False,  True,  True, False,  True, False,  True,  True, False,\n        True, False,  True,  True, False,  True, False,  True,  True,\n       False,  True, False,  True,  True, False,  True, False,  True,\n        True, False,  True, False,  True,  True, False,  True, False,\n        True,  True, False,  True, False,  True,  True, False,  True,\n       False,  True,  True, False,  True])",
                    "shape": "(50,)",
                    "omitted": false
                },
                "x.dtype": {
                    "value": "dtype('bool')",
                    "shape": "()",
                    "omitted": false
                }
            },
            {}
        ]
    ],
    "2.1.4": [
        [
            {
                "x": "Series",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "Series",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ]
    ],
    "2.1.5": [
        [
            {
                "x": {
                    "value": "0     0\n1     1\n2     1\n3     0\n4     1\n5     0\n6     1\n7     1\n8     0\n9     1\n10    0\n11    1\n12    1\n13    0\n14    1\n15    0\n16    1\n17    1\n18    0\n19    1\n20    0\n21    1\n22    1\n23    0\n24    1\n25    0\n26    1\n27    1\n28    0\n29    1\n30    0\n31    1\n32    1\n33    0\n34    1\n35    0\n36    1\n37    1\n38    0\n39    1\n40    0\n41    1\n42    1\n43    0\n44    1\n45    0\n46    1\n47    1\n48    0\n49    1\ndtype: int64",
                    "shape": "(50,)",
                    "omitted": false
                },
                "x.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "x": {
                    "value": "0     False\n1      True\n2       ...  False\n49     True\ndtype: bool",
                    "shape": "(50,)",
                    "omitted": true
                },
                "x.dtype": {
                    "value": "dtype('bool')",
                    "shape": "()",
                    "omitted": false
                }
            },
            {
                "x": {
                    "value": "0     0\n1     1\n2     1\n3     0\n4     1\n5     0\n6     1\n7     1\n8     0\n9     1\n10    0\n11    1\n12    1\n13    0\n14    1\n15    0\n16    1\n17    1\n18    0\n19    1\n20    0\n21    1\n22    1\n23    0\n24    1\n25    0\n26    1\n27    1\n28    0\n29    1\n30    0\n31    1\n32    1\n33    0\n34    1\n35    0\n36    1\n37    1\n38    0\n39    1\n40    0\n41    1\n42    1\n43    0\n44    1\n45    0\n46    1\n47    1\n48    0\n49    1\ndtype: int64",
                    "shape": "(50,)",
                    "omitted": false
                },
                "x.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                }
            }
        ],
        [
            {
                "x": {
                    "value": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                    "shape": "(50,)",
                    "omitted": false
                },
                "x.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "x": {
                    "value": "array([False,  True,  True, False,  True, False,  True,  True, False,\n        True, False,  True,  True, False,  True, False,  True,  True,\n       False,  True, False,  True,  True, False,  True, False,  True,\n        True, False,  True, False,  True,  True, False,  True, False,\n        True,  True, False,  True, False,  True,  True, False,  True,\n       False,  True,  True, False,  True])",
                    "shape": "(50,)",
                    "omitted": false
                },
                "x.dtype": {
                    "value": "dtype('bool')",
                    "shape": "()",
                    "omitted": false
                }
            },
            {
                "x": {
                    "value": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                    "shape": "(50,)",
                    "omitted": false
                },
                "x.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                }
            }
        ],
        [
            {
                "x": {
                    "value": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                    "shape": "(50,)",
                    "omitted": false
                },
                "x.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "x": {
                    "value": "array([False,  True,  True, False,  True, False,  True,  True, False,\n        True, False,  True,  True, False,  True, False,  True,  True,\n       False,  True, False,  True,  True, False,  True, False,  True,\n        True, False,  True, False,  True,  True, False,  True, False,\n        True,  True, False,  True, False,  True,  True, False,  True,\n       False,  True,  True, False,  True])",
                    "shape": "(50,)",
                    "omitted": false
                },
                "x.dtype": {
                    "value": "dtype('bool')",
                    "shape": "()",
                    "omitted": false
                }
            },
            {
                "x": {
                    "value": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                    "shape": "(50,)",
                    "omitted": false
                },
                "x.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                }
            }
        ],
        [
            {
                "x": {
                    "value": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                    "shape": "(50,)",
                    "omitted": false
                },
                "x.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "x": {
                    "value": "array([False,  True,  True, False,  True, False,  True,  True, False,\n        True, False,  True,  True, False,  True, False,  True,  True,\n       False,  True, False,  True,  True, False,  True, False,  True,\n        True, False,  True, False,  True,  True, False,  True, False,\n        True,  True, False,  True, False,  True,  True, False,  True,\n       False,  True,  True, False,  True])",
                    "shape": "(50,)",
                    "omitted": false
                },
                "x.dtype": {
                    "value": "dtype('bool')",
                    "shape": "()",
                    "omitted": false
                }
            },
            {
                "x": {
                    "value": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                    "shape": "(50,)",
                    "omitted": false
                },
                "x.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                }
            }
        ],
        [
            {
                "x": {
                    "value": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                    "shape": "(50,)",
                    "omitted": false
                },
                "x.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                }
            },
            {}
        ],
        [
            {
                "x": {
                    "value": "array([False,  True,  True, False,  True, False,  True,  True, False,\n        True, False,  True,  True, False,  True, False,  True,  True,\n       False,  True, False,  True,  True, False,  True, False,  True,\n        True, False,  True, False,  True,  True, False,  True, False,\n        True,  True, False,  True, False,  True,  True, False,  True,\n       False,  True,  True, False,  True])",
                    "shape": "(50,)",
                    "omitted": false
                },
                "x.dtype": {
                    "value": "dtype('bool')",
                    "shape": "()",
                    "omitted": false
                }
            },
            {
                "x": {
                    "value": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                    "shape": "(50,)",
                    "omitted": false
                },
                "x.dtype": {
                    "value": "dtype('int64')",
                    "shape": "()",
                    "omitted": false
                }
            }
        ]
    ],
    "2.1.6": [
        [
            {
                "x": "Series",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "Series",
                "x.dtype": "dtype"
            },
            {
                "x": "Series",
                "x.dtype": "dtype"
            }
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            }
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            }
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            }
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            }
        ]
    ],
    "3.1.1": [
        "qcut raising TypeError for boolean Series\n"
    ],
    "3.1.2": [
        "Code Sample, a copy-pastable example if possible\nimport pandas as pd\npd.qcut(pd.Series([True, False, False, False, False, False, True]), 6, duplicates=\"drop\", precision=2)\nProblem description\nPandas throws a TypeError:\n\nTraceback (most recent call last):\n  File \"/tmp/pandas/env/lib/python3.5/site-packages/numpy/core/fromnumeric.py\", line 52, in _wrapfunc\n    return getattr(obj, method)(*args, **kwds)\nTypeError: Cannot cast ufunc multiply output from dtype('float64') to dtype('bool') with casting rule 'same_kind'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/tmp/pandas/env/src/pandas/pandas/core/reshape/tile.py\", line 210, in qcut\n    dtype=dtype, duplicates=duplicates)\n  File \"/tmp/pandas/env/src/pandas/pandas/core/reshape/tile.py\", line 254, in _bins_to_cuts\n    dtype=dtype)\n  File \"/tmp/pandas/env/src/pandas/pandas/core/reshape/tile.py\", line 351, in _format_labels\n    precision = _infer_precision(precision, bins)\n  File \"/tmp/pandas/env/src/pandas/pandas/core/reshape/tile.py\", line 429, in _infer_precision\n    levels = [_round_frac(b, precision) for b in bins]\n  File \"/tmp/pandas/env/src/pandas/pandas/core/reshape/tile.py\", line 429, in <listcomp>\n    levels = [_round_frac(b, precision) for b in bins]\n  File \"/tmp/pandas/env/src/pandas/pandas/core/reshape/tile.py\", line 422, in _round_frac\n    return np.around(x, digits)\n  File \"/tmp/pandas/env/lib/python3.5/site-packages/numpy/core/fromnumeric.py\", line 2837, in around\n    return _wrapfunc(a, 'round', decimals=decimals, out=out)\n  File \"/tmp/pandas/env/lib/python3.5/site-packages/numpy/core/fromnumeric.py\", line 62, in _wrapfunc\n    return _wrapit(obj, method, *args, **kwds)\n  File \"/tmp/pandas/env/lib/python3.5/site-packages/numpy/core/fromnumeric.py\", line 42, in _wrapit\n    result = getattr(asarray(obj), method)(*args, **kwds)\nTypeError: Cannot cast ufunc multiply output from dtype('float64') to dtype('bool') with casting rule 'same_kind'\nIf the second parameter for qcut is changed from 6 to 7, a different TypeError is raised:\n\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/tmp/pandas/env/src/pandas/pandas/core/reshape/tile.py\", line 207, in qcut\n    bins = algos.quantile(x, quantiles)\n  File \"/tmp/pandas/env/src/pandas/pandas/core/algorithms.py\", line 903, in quantile\n    return algos.arrmap_float64(q, _get_score)\n  File \"pandas/_libs/algos_common_helper.pxi\", line 416, in pandas._libs.algos.arrmap_float64\n  File \"/tmp/pandas/env/src/pandas/pandas/core/algorithms.py\", line 888, in _get_score\n    idx % 1)\n  File \"/tmp/pandas/env/src/pandas/pandas/core/algorithms.py\", line 876, in _interpolate\n    return a + (b - a) * fraction\nTypeError: numpy boolean subtract, the `-` operator, is deprecated, use the bitwise_xor, the `^` operator, or the logical_xor function instead.\nExpected Output\nSomething like\n\n0      (0.29, 1.0]\n1    (-0.01, 0.29]\n2    (-0.01, 0.29]\n3    (-0.01, 0.29]\n4    (-0.01, 0.29]\n5    (-0.01, 0.29]\n6      (0.29, 1.0]\ndtype: category\nCategories (2, interval[float64]): [(-0.01, 0.29] < (0.29, 1.0]]\n"
    ],
    "used_imports": "import numpy as np\nfrom pandas.core.dtypes.common import _NS_DTYPE, ensure_int64, is_categorical_dtype, is_datetime64_dtype, is_datetime64tz_dtype, is_datetime_or_timedelta_dtype, is_integer, is_scalar, is_timedelta64_dtype\nfrom pandas import Categorical, Index, Interval, IntervalIndex, Series, to_datetime, to_timedelta"
}