{
    "pandas:98": {
        "github_issue_title": [
            "BUG/API: Index constructor does not enforce specified dtype\n",
            "Index Constructors inferring output from data\n"
        ],
        "github_issue_description": [
            "Code Sample, a copy-pastable example if possible\nManually specifying a dtype does not garantuee the output is in that dtype. Eg with Series if incompatible data is passed, an error is raised, while for Index it just silently outputs another dtype:\n\nIn [11]: pd.Series(['a', 'b', 'c'], dtype='int64')\n...\nValueError: invalid literal for int() with base 10: 'a'\n\nIn [12]: pd.Index(['a', 'b', 'c'], dtype='int64')\nOut[12]: Index(['a', 'b', 'c'], dtype='object')\n",
            "Two proposals:\n\nConsolidate all inference to the Index constructor\nRetain Index(...) inferring the best container for the data passed\nRemove MultiIndex(data) returning an Index when data is a list of length-1 tuples (xref API: Have MultiIndex consturctors always return a MI #17236)\nPassing dtype=object disables inference\nIndex(..., dtype=object) disable all inference. So Index([1, 2], dtype=object) will give you an Index instead of Int64Index, and Index([(1, 'a'), (2, 'b')], dtype=object) an Index instead of MultiIndex, etc.\n\n(original post follows)\n\nOr how much magic should we have in the Index constructors? Currently we infer the index type from the data, which is often convenient, but sometime difficult to reason able behavior. e.g. hash_tuples currently doesn't work if your tuples all happen to be length 1, since it uses a MultiIndex internally.\n\nDo we want to make our Index constructors more predictable? For reference, here are some examples:\n\n>>> import pandas as pd\n# 1.) Index -> MultiIndex\n>>> pd.Index([(1, 2), (3, 4)])\nMultiIndex(levels=[[1, 3], [2, 4]],\n           labels=[[0, 1], [0, 1]])\n\n>>> pd.Index([(1, 2), (3, 4)], tupleize_cols=False)\nIndex([(1, 2), (3, 4)], dtype='object')\n\n# 2.) Index -> Int64Index\n>>> pd.Index([1, 2, 3, 4, 5])\nInt64Index([1, 2, 3, 4, 5], dtype='int64')\n\n# 3.) Index -> RangeIndex\n>>> pd.Index(range(1, 5))\nRangeIndex(start=1, stop=5, step=1)\n\n# 4.) Index -> DatetimeIndex\n>>> pd.Index([pd.Timestamp('2017'), pd.Timestamp('2018')])\nDatetimeIndex(['2017-01-01', '2018-01-01'], dtype='datetime64[ns]', freq=None)\n\n# 5.) Index -> IntervalIndex\n>>> pd.Index([pd.Interval(3, 4), pd.Interval(4, 5)])\nIntervalIndex([(3, 4], (4, 5]]\n              closed='right',\n              dtype='interval[int64]')\n\n# 5.) MultiIndex -> Index\n>>> pd.MultiIndex.from_tuples([(1,), (2,), (3,)])\nInt64Index([1, 2, 3], dtype='int64')\nOf these, I think the first (Index -> MultiIndex if you have tuples) and the last (MultiIndex -> Index if you're tuples are all length 1) are undesirable. The Index -> MultiIndex one has the tupleize_cols keyword to control this behavior. In #17236 I add an analogous keyword to the MI constructor. The rest are probably fine, but I don't have any real reason for saying that [1, 2, 3] magically returning an Int64Index is ok, but [(1, 2), (3, 4)] returning a MI isn't (maybe the difference between a MI and Index is larger than the difference between an Int64Index and Index?). I believe that in either the RangeIndex or IntervalIndex someone (@shoyer?) had objections to overloading the Index constructor to return the specialized type.\n\nSo, what should we do about these? Leave them as is? Deprecate the type inference? My vote is for merging #17236 and leaving everything else as is. To me, it's not worth breaking API over.\n\ncc @jreback, @jorisvandenbossche, @shoyer\n"
        ]
    }
}