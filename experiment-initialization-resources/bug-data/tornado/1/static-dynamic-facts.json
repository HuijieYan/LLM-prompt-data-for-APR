{
    "tornado:1": {
        "/home/ubuntu/Desktop/bgp_envs_local/repos/tornado_1/tornado/websocket.py": {
            "buggy_functions": [
                {
                    "function_name": "set_nodelay",
                    "function_code": "def set_nodelay(self, value: bool) -> None:\n    \"\"\"Set the no-delay flag for this stream.\n\n    By default, small messages may be delayed and/or combined to minimize\n    the number of packets sent.  This can sometimes cause 200-500ms delays\n    due to the interaction between Nagle's algorithm and TCP delayed\n    ACKs.  To reduce this delay (at the expense of possibly increasing\n    bandwidth usage), call ``self.set_nodelay(True)`` once the websocket\n    connection is established.\n\n    See `.BaseIOStream.set_nodelay` for additional details.\n\n    .. versionadded:: 3.1\n    \"\"\"\n    assert self.stream is not None\n    self.stream.set_nodelay(value)\n",
                    "decorators": [],
                    "docstring": "Set the no-delay flag for this stream.\n\nBy default, small messages may be delayed and/or combined to minimize\nthe number of packets sent.  This can sometimes cause 200-500ms delays\ndue to the interaction between Nagle's algorithm and TCP delayed\nACKs.  To reduce this delay (at the expense of possibly increasing\nbandwidth usage), call ``self.set_nodelay(True)`` once the websocket\nconnection is established.\n\nSee `.BaseIOStream.set_nodelay` for additional details.\n\n.. versionadded:: 3.1",
                    "start_line": 547,
                    "end_line": 562,
                    "variables": {
                        "bool": [
                            547
                        ],
                        "self.stream": [
                            561,
                            562
                        ],
                        "self": [
                            561,
                            562
                        ],
                        "self.stream.set_nodelay": [
                            562
                        ],
                        "value": [
                            562
                        ]
                    },
                    "filtered_variables": {
                        "self.stream": [
                            561,
                            562
                        ],
                        "self": [
                            561,
                            562
                        ],
                        "self.stream.set_nodelay": [
                            562
                        ],
                        "value": [
                            562
                        ]
                    },
                    "diff_line_number": 561,
                    "class_data": {
                        "signature": "class WebSocketHandler(tornado.web.RequestHandler)",
                        "docstring": "Subclass this class to create a basic WebSocket handler.\n\nOverride `on_message` to handle incoming messages, and use\n`write_message` to send messages to the client. You can also\noverride `open` and `on_close` to handle opened and closed\nconnections.\n\nCustom upgrade response headers can be sent by overriding\n`~tornado.web.RequestHandler.set_default_headers` or\n`~tornado.web.RequestHandler.prepare`.\n\nSee http://dev.w3.org/html5/websockets/ for details on the\nJavaScript interface.  The protocol is specified at\nhttp://tools.ietf.org/html/rfc6455.\n\nHere is an example WebSocket handler that echos back all received messages\nback to the client:\n\n.. testcode::\n\n  class EchoWebSocket(tornado.websocket.WebSocketHandler):\n      def open(self):\n          print(\"WebSocket opened\")\n\n      def on_message(self, message):\n          self.write_message(u\"You said: \" + message)\n\n      def on_close(self):\n          print(\"WebSocket closed\")\n\n.. testoutput::\n   :hide:\n\nWebSockets are not standard HTTP connections. The \"handshake\" is\nHTTP, but after the handshake, the protocol is\nmessage-based. Consequently, most of the Tornado HTTP facilities\nare not available in handlers of this type. The only communication\nmethods available to you are `write_message()`, `ping()`, and\n`close()`. Likewise, your request handler class should implement\n`open()` method rather than ``get()`` or ``post()``.\n\nIf you map the handler above to ``/websocket`` in your application, you can\ninvoke it in JavaScript with::\n\n  var ws = new WebSocket(\"ws://localhost:8888/websocket\");\n  ws.onopen = function() {\n     ws.send(\"Hello, world\");\n  };\n  ws.onmessage = function (evt) {\n     alert(evt.data);\n  };\n\nThis script pops up an alert box that says \"You said: Hello, world\".\n\nWeb browsers allow any site to open a websocket connection to any other,\ninstead of using the same-origin policy that governs other network\naccess from javascript.  This can be surprising and is a potential\nsecurity hole, so since Tornado 4.0 `WebSocketHandler` requires\napplications that wish to receive cross-origin websockets to opt in\nby overriding the `~WebSocketHandler.check_origin` method (see that\nmethod's docs for details).  Failure to do so is the most likely\ncause of 403 errors when making a websocket connection.\n\nWhen using a secure websocket connection (``wss://``) with a self-signed\ncertificate, the connection from a browser may fail because it wants\nto show the \"accept this certificate\" dialog but has nowhere to show it.\nYou must first visit a regular HTML page using the same certificate\nto accept it before the websocket connection will succeed.\n\nIf the application setting ``websocket_ping_interval`` has a non-zero\nvalue, a ping will be sent periodically, and the connection will be\nclosed if a response is not received before the ``websocket_ping_timeout``.\n\nMessages larger than the ``websocket_max_message_size`` application setting\n(default 10MiB) will not be accepted.\n\n.. versionchanged:: 4.5\n   Added ``websocket_ping_interval``, ``websocket_ping_timeout``, and\n   ``websocket_max_message_size``.",
                        "constructor_docstring": null,
                        "functions": [
                            "def __init__(self, application: tornado.web.Application, request: httputil.HTTPServerRequest, **kwargs: Any) -> None:\n    super(WebSocketHandler, self).__init__(application, request, **kwargs)\n    self.ws_connection = None\n    self.close_code = None\n    self.close_reason = None\n    self.stream = None\n    self._on_close_called = False",
                            "async def get(self, *args: Any, **kwargs: Any) -> None:\n    self.open_args = args\n    self.open_kwargs = kwargs\n    if self.request.headers.get('Upgrade', '').lower() != 'websocket':\n        self.set_status(400)\n        log_msg = 'Can \"Upgrade\" only to \"WebSocket\".'\n        self.finish(log_msg)\n        gen_log.debug(log_msg)\n        return\n    headers = self.request.headers\n    connection = map(lambda s: s.strip().lower(), headers.get('Connection', '').split(','))\n    if 'upgrade' not in connection:\n        self.set_status(400)\n        log_msg = '\"Connection\" must be \"Upgrade\".'\n        self.finish(log_msg)\n        gen_log.debug(log_msg)\n        return\n    if 'Origin' in self.request.headers:\n        origin = self.request.headers.get('Origin')\n    else:\n        origin = self.request.headers.get('Sec-Websocket-Origin', None)\n    if origin is not None and (not self.check_origin(origin)):\n        self.set_status(403)\n        log_msg = 'Cross origin websockets not allowed'\n        self.finish(log_msg)\n        gen_log.debug(log_msg)\n        return\n    self.ws_connection = self.get_websocket_protocol()\n    if self.ws_connection:\n        await self.ws_connection.accept_connection(self)\n    else:\n        self.set_status(426, 'Upgrade Required')\n        self.set_header('Sec-WebSocket-Version', '7, 8, 13')",
                            "@property\ndef ping_interval(self) -> Optional[float]:\n    \"\"\"The interval for websocket keep-alive pings.\n\n    Set websocket_ping_interval = 0 to disable pings.\n    \"\"\"\n    return self.settings.get('websocket_ping_interval', None)",
                            "@property\ndef ping_timeout(self) -> Optional[float]:\n    \"\"\"If no ping is received in this many seconds,\n    close the websocket connection (VPNs, etc. can fail to cleanly close ws connections).\n    Default is max of 3 pings or 30 seconds.\n    \"\"\"\n    return self.settings.get('websocket_ping_timeout', None)",
                            "@property\ndef max_message_size(self) -> int:\n    \"\"\"Maximum allowed message size.\n\n    If the remote peer sends a message larger than this, the connection\n    will be closed.\n\n    Default is 10MiB.\n    \"\"\"\n    return self.settings.get('websocket_max_message_size', _default_max_message_size)",
                            "def write_message(self, message: Union[bytes, str, Dict[str, Any]], binary: bool=False) -> 'Future[None]':\n    \"\"\"Sends the given message to the client of this Web Socket.\n\n    The message may be either a string or a dict (which will be\n    encoded as json).  If the ``binary`` argument is false, the\n    message will be sent as utf8; in binary mode any byte string\n    is allowed.\n\n    If the connection is already closed, raises `WebSocketClosedError`.\n    Returns a `.Future` which can be used for flow control.\n\n    .. versionchanged:: 3.2\n       `WebSocketClosedError` was added (previously a closed connection\n       would raise an `AttributeError`)\n\n    .. versionchanged:: 4.3\n       Returns a `.Future` which can be used for flow control.\n\n    .. versionchanged:: 5.0\n       Consistently raises `WebSocketClosedError`. Previously could\n       sometimes raise `.StreamClosedError`.\n    \"\"\"\n    if self.ws_connection is None or self.ws_connection.is_closing():\n        raise WebSocketClosedError()\n    if isinstance(message, dict):\n        message = tornado.escape.json_encode(message)\n    return self.ws_connection.write_message(message, binary=binary)",
                            "def select_subprotocol(self, subprotocols: List[str]) -> Optional[str]:\n    \"\"\"Override to implement subprotocol negotiation.\n\n    ``subprotocols`` is a list of strings identifying the\n    subprotocols proposed by the client.  This method may be\n    overridden to return one of those strings to select it, or\n    ``None`` to not select a subprotocol.\n\n    Failure to select a subprotocol does not automatically abort\n    the connection, although clients may close the connection if\n    none of their proposed subprotocols was selected.\n\n    The list may be empty, in which case this method must return\n    None. This method is always called exactly once even if no\n    subprotocols were proposed so that the handler can be advised\n    of this fact.\n\n    .. versionchanged:: 5.1\n\n       Previously, this method was called with a list containing\n       an empty string instead of an empty list if no subprotocols\n       were proposed by the client.\n    \"\"\"\n    return None",
                            "@property\ndef selected_subprotocol(self) -> Optional[str]:\n    \"\"\"The subprotocol returned by `select_subprotocol`.\n\n    .. versionadded:: 5.1\n    \"\"\"\n    assert self.ws_connection is not None\n    return self.ws_connection.selected_subprotocol",
                            "def get_compression_options(self) -> Optional[Dict[str, Any]]:\n    \"\"\"Override to return compression options for the connection.\n\n    If this method returns None (the default), compression will\n    be disabled.  If it returns a dict (even an empty one), it\n    will be enabled.  The contents of the dict may be used to\n    control the following compression options:\n\n    ``compression_level`` specifies the compression level.\n\n    ``mem_level`` specifies the amount of memory used for the internal compression state.\n\n     These parameters are documented in details here:\n     https://docs.python.org/3.6/library/zlib.html#zlib.compressobj\n\n    .. versionadded:: 4.1\n\n    .. versionchanged:: 4.5\n\n       Added ``compression_level`` and ``mem_level``.\n    \"\"\"\n    return None",
                            "def open(self, *args: str, **kwargs: str) -> Optional[Awaitable[None]]:\n    \"\"\"Invoked when a new WebSocket is opened.\n\n    The arguments to `open` are extracted from the `tornado.web.URLSpec`\n    regular expression, just like the arguments to\n    `tornado.web.RequestHandler.get`.\n\n    `open` may be a coroutine. `on_message` will not be called until\n    `open` has returned.\n\n    .. versionchanged:: 5.1\n\n       ``open`` may be a coroutine.\n    \"\"\"\n    pass",
                            "def on_message(self, message: Union[str, bytes]) -> Optional[Awaitable[None]]:\n    \"\"\"Handle incoming messages on the WebSocket\n\n    This method must be overridden.\n\n    .. versionchanged:: 4.5\n\n       ``on_message`` can be a coroutine.\n    \"\"\"\n    raise NotImplementedError",
                            "def ping(self, data: Union[str, bytes]=b'') -> None:\n    \"\"\"Send ping frame to the remote end.\n\n    The data argument allows a small amount of data (up to 125\n    bytes) to be sent as a part of the ping message. Note that not\n    all websocket implementations expose this data to\n    applications.\n\n    Consider using the ``websocket_ping_interval`` application\n    setting instead of sending pings manually.\n\n    .. versionchanged:: 5.1\n\n       The data argument is now optional.\n\n    \"\"\"\n    data = utf8(data)\n    if self.ws_connection is None or self.ws_connection.is_closing():\n        raise WebSocketClosedError()\n    self.ws_connection.write_ping(data)",
                            "def on_pong(self, data: bytes) -> None:\n    \"\"\"Invoked when the response to a ping frame is received.\"\"\"\n    pass",
                            "def on_ping(self, data: bytes) -> None:\n    \"\"\"Invoked when the a ping frame is received.\"\"\"\n    pass",
                            "def on_close(self) -> None:\n    \"\"\"Invoked when the WebSocket is closed.\n\n    If the connection was closed cleanly and a status code or reason\n    phrase was supplied, these values will be available as the attributes\n    ``self.close_code`` and ``self.close_reason``.\n\n    .. versionchanged:: 4.0\n\n       Added ``close_code`` and ``close_reason`` attributes.\n    \"\"\"\n    pass",
                            "def close(self, code: int=None, reason: str=None) -> None:\n    \"\"\"Closes this Web Socket.\n\n    Once the close handshake is successful the socket will be closed.\n\n    ``code`` may be a numeric status code, taken from the values\n    defined in `RFC 6455 section 7.4.1\n    <https://tools.ietf.org/html/rfc6455#section-7.4.1>`_.\n    ``reason`` may be a textual message about why the connection is\n    closing.  These values are made available to the client, but are\n    not otherwise interpreted by the websocket protocol.\n\n    .. versionchanged:: 4.0\n\n       Added the ``code`` and ``reason`` arguments.\n    \"\"\"\n    if self.ws_connection:\n        self.ws_connection.close(code, reason)\n        self.ws_connection = None",
                            "def check_origin(self, origin: str) -> bool:\n    \"\"\"Override to enable support for allowing alternate origins.\n\n    The ``origin`` argument is the value of the ``Origin`` HTTP\n    header, the url responsible for initiating this request.  This\n    method is not called for clients that do not send this header;\n    such requests are always allowed (because all browsers that\n    implement WebSockets support this header, and non-browser\n    clients do not have the same cross-site security concerns).\n\n    Should return ``True`` to accept the request or ``False`` to\n    reject it. By default, rejects all requests with an origin on\n    a host other than this one.\n\n    This is a security protection against cross site scripting attacks on\n    browsers, since WebSockets are allowed to bypass the usual same-origin\n    policies and don't use CORS headers.\n\n    .. warning::\n\n       This is an important security measure; don't disable it\n       without understanding the security implications. In\n       particular, if your authentication is cookie-based, you\n       must either restrict the origins allowed by\n       ``check_origin()`` or implement your own XSRF-like\n       protection for websocket connections. See `these\n       <https://www.christian-schneider.net/CrossSiteWebSocketHijacking.html>`_\n       `articles\n       <https://devcenter.heroku.com/articles/websocket-security>`_\n       for more.\n\n    To accept all cross-origin traffic (which was the default prior to\n    Tornado 4.0), simply override this method to always return ``True``::\n\n        def check_origin(self, origin):\n            return True\n\n    To allow connections from any subdomain of your site, you might\n    do something like::\n\n        def check_origin(self, origin):\n            parsed_origin = urllib.parse.urlparse(origin)\n            return parsed_origin.netloc.endswith(\".mydomain.com\")\n\n    .. versionadded:: 4.0\n\n    \"\"\"\n    parsed_origin = urlparse(origin)\n    origin = parsed_origin.netloc\n    origin = origin.lower()\n    host = self.request.headers.get('Host')\n    return origin == host",
                            "def set_nodelay(self, value: bool) -> None:\n    \"\"\"Set the no-delay flag for this stream.\n\n    By default, small messages may be delayed and/or combined to minimize\n    the number of packets sent.  This can sometimes cause 200-500ms delays\n    due to the interaction between Nagle's algorithm and TCP delayed\n    ACKs.  To reduce this delay (at the expense of possibly increasing\n    bandwidth usage), call ``self.set_nodelay(True)`` once the websocket\n    connection is established.\n\n    See `.BaseIOStream.set_nodelay` for additional details.\n\n    .. versionadded:: 3.1\n    \"\"\"\n    assert self.stream is not None\n    self.stream.set_nodelay(value)",
                            "def on_connection_close(self) -> None:\n    if self.ws_connection:\n        self.ws_connection.on_connection_close()\n        self.ws_connection = None\n    if not self._on_close_called:\n        self._on_close_called = True\n        self.on_close()\n        self._break_cycles()",
                            "def on_ws_connection_close(self, close_code: int=None, close_reason: str=None) -> None:\n    self.close_code = close_code\n    self.close_reason = close_reason\n    self.on_connection_close()",
                            "def _break_cycles(self) -> None:\n    if self.get_status() != 101 or self._on_close_called:\n        super(WebSocketHandler, self)._break_cycles()",
                            "def send_error(self, *args: Any, **kwargs: Any) -> None:\n    if self.stream is None:\n        super(WebSocketHandler, self).send_error(*args, **kwargs)\n    else:\n        self.stream.close()",
                            "def get_websocket_protocol(self) -> Optional['WebSocketProtocol']:\n    websocket_version = self.request.headers.get('Sec-WebSocket-Version')\n    if websocket_version in ('7', '8', '13'):\n        params = _WebSocketParams(ping_interval=self.ping_interval, ping_timeout=self.ping_timeout, max_message_size=self.max_message_size, compression_options=self.get_compression_options())\n        return WebSocketProtocol13(self, False, params)\n    return None",
                            "def _detach_stream(self) -> IOStream:\n    for method in ['write', 'redirect', 'set_header', 'set_cookie', 'set_status', 'flush', 'finish']:\n        setattr(self, method, _raise_not_supported_for_websockets)\n    return self.detach()"
                        ],
                        "constructor_variables": [
                            "self.ws_connection = None",
                            "self.close_code = None",
                            "self.close_reason = None",
                            "self.stream = None",
                            "self._on_close_called = False"
                        ],
                        "class_level_variables": [
                            "stream = None"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "__init__(self, application: tornado.web.Application, request: httputil.HTTPServerRequest, **kwargs: Any) -> None",
                            "get(self, *args: Any, **kwargs: Any) -> None",
                            "ping_interval(self) -> Optional[float]",
                            "ping_timeout(self) -> Optional[float]",
                            "max_message_size(self) -> int",
                            "write_message(self, message: Union[bytes, str, Dict[str, Any]], binary: bool=False) -> 'Future[None]'",
                            "select_subprotocol(self, subprotocols: List[str]) -> Optional[str]",
                            "selected_subprotocol(self) -> Optional[str]",
                            "get_compression_options(self) -> Optional[Dict[str, Any]]",
                            "open(self, *args: str, **kwargs: str) -> Optional[Awaitable[None]]",
                            "on_message(self, message: Union[str, bytes]) -> Optional[Awaitable[None]]",
                            "ping(self, data: Union[str, bytes]=b'') -> None",
                            "on_pong(self, data: bytes) -> None",
                            "on_ping(self, data: bytes) -> None",
                            "on_close(self) -> None",
                            "close(self, code: int=None, reason: str=None) -> None",
                            "check_origin(self, origin: str) -> bool",
                            "set_nodelay(self, value: bool) -> None",
                            "on_connection_close(self) -> None",
                            "on_ws_connection_close(self, close_code: int=None, close_reason: str=None) -> None",
                            "_break_cycles(self) -> None",
                            "send_error(self, *args: Any, **kwargs: Any) -> None",
                            "get_websocket_protocol(self) -> Optional['WebSocketProtocol']",
                            "_detach_stream(self) -> IOStream"
                        ],
                        "class_level_variable_names": [
                            "stream"
                        ],
                        "constructor_variable_names": [
                            "_on_close_called",
                            "ws_connection",
                            "close_reason",
                            "close_code",
                            "stream"
                        ]
                    },
                    "used_imports": [],
                    "variable_values": [
                        [
                            {
                                "self.stream": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<tornado.test.websocket_test.NoDelayHandler object at 0x7f69f7ad4950>",
                                    "variable_type": "NoDelayHandler",
                                    "variable_shape": null
                                },
                                "self.stream.set_nodelay": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "value": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "self.ws_connection": {
                                    "variable_value": "<tornado.websocket.WebSocketProtocol13 object at 0x7ff6b0eaf1d0>",
                                    "variable_type": "WebSocketProtocol13",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<tornado.test.websocket_test.NoDelayHandler object at 0x7ff6b0ef7d50>",
                                    "variable_type": "NoDelayHandler",
                                    "variable_shape": null
                                },
                                "self.ws_connection.set_nodelay": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "value": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.ws_connection": {
                                    "variable_value": "<tornado.websocket.WebSocketProtocol13 object at 0x7ff6b0eaf1d0>",
                                    "variable_type": "WebSocketProtocol13",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<tornado.test.websocket_test.NoDelayHandler object at 0x7ff6b0ef7d50>",
                                    "variable_type": "NoDelayHandler",
                                    "variable_shape": null
                                },
                                "self.ws_connection.set_nodelay": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "value": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                }
            ],
            "inscope_functions": {
                "file_scope_functions": [
                    {
                        "code": "def _raise_not_supported_for_websockets(*args: Any, **kwargs: Any) -> None:\n    raise RuntimeError(\"Method not supported for Web Sockets\")",
                        "signature": "_raise_not_supported_for_websockets(*args: Any, **kwargs: Any) -> None"
                    },
                    {
                        "code": "def websocket_connect(\n    url: Union[str, httpclient.HTTPRequest],\n    callback: Callable[[\"Future[WebSocketClientConnection]\"], None] = None,\n    connect_timeout: float = None,\n    on_message_callback: Callable[[Union[None, str, bytes]], None] = None,\n    compression_options: Dict[str, Any] = None,\n    ping_interval: float = None,\n    ping_timeout: float = None,\n    max_message_size: int = _default_max_message_size,\n    subprotocols: List[str] = None,\n) -> \"Awaitable[WebSocketClientConnection]\":\n    \"\"\"Client-side websocket support.\n\n    Takes a url and returns a Future whose result is a\n    `WebSocketClientConnection`.\n\n    ``compression_options`` is interpreted in the same way as the\n    return value of `.WebSocketHandler.get_compression_options`.\n\n    The connection supports two styles of operation. In the coroutine\n    style, the application typically calls\n    `~.WebSocketClientConnection.read_message` in a loop::\n\n        conn = yield websocket_connect(url)\n        while True:\n            msg = yield conn.read_message()\n            if msg is None: break\n            # Do something with msg\n\n    In the callback style, pass an ``on_message_callback`` to\n    ``websocket_connect``. In both styles, a message of ``None``\n    indicates that the connection has been closed.\n\n    ``subprotocols`` may be a list of strings specifying proposed\n    subprotocols. The selected protocol may be found on the\n    ``selected_subprotocol`` attribute of the connection object\n    when the connection is complete.\n\n    .. versionchanged:: 3.2\n       Also accepts ``HTTPRequest`` objects in place of urls.\n\n    .. versionchanged:: 4.1\n       Added ``compression_options`` and ``on_message_callback``.\n\n    .. versionchanged:: 4.5\n       Added the ``ping_interval``, ``ping_timeout``, and ``max_message_size``\n       arguments, which have the same meaning as in `WebSocketHandler`.\n\n    .. versionchanged:: 5.0\n       The ``io_loop`` argument (deprecated since version 4.1) has been removed.\n\n    .. versionchanged:: 5.1\n       Added the ``subprotocols`` argument.\n    \"\"\"\n    if isinstance(url, httpclient.HTTPRequest):\n        assert connect_timeout is None\n        request = url\n        # Copy and convert the headers dict/object (see comments in\n        # AsyncHTTPClient.fetch)\n        request.headers = httputil.HTTPHeaders(request.headers)\n    else:\n        request = httpclient.HTTPRequest(url, connect_timeout=connect_timeout)\n    request = cast(\n        httpclient.HTTPRequest,\n        httpclient._RequestProxy(request, httpclient.HTTPRequest._DEFAULTS),\n    )\n    conn = WebSocketClientConnection(\n        request,\n        on_message_callback=on_message_callback,\n        compression_options=compression_options,\n        ping_interval=ping_interval,\n        ping_timeout=ping_timeout,\n        max_message_size=max_message_size,\n        subprotocols=subprotocols,\n    )\n    if callback is not None:\n        IOLoop.current().add_future(conn.connect_future, callback)\n    return conn.connect_future",
                        "signature": "websocket_connect(url: Union[str, httpclient.HTTPRequest], callback: Callable[['Future[WebSocketClientConnection]'], None]=None, connect_timeout: float=None, on_message_callback: Callable[[Union[None, str, bytes]], None]=None, compression_options: Dict[str, Any]=None, ping_interval: float=None, ping_timeout: float=None, max_message_size: int=_default_max_message_size, subprotocols: List[str]=None) -> 'Awaitable[WebSocketClientConnection]'"
                    }
                ],
                "file_scope_classes": [
                    {
                        "class_declaration": "class WebSocketError:",
                        "functions": []
                    },
                    {
                        "class_declaration": "class WebSocketClosedError:",
                        "functions": []
                    },
                    {
                        "class_declaration": "class _DecompressTooLargeError:",
                        "functions": []
                    },
                    {
                        "class_declaration": "class _WebSocketParams:",
                        "functions": [
                            {
                                "code": "def __init__(\n    self,\n    ping_interval: float = None,\n    ping_timeout: float = None,\n    max_message_size: int = _default_max_message_size,\n    compression_options: Dict[str, Any] = None,\n) -> None:\n    self.ping_interval = ping_interval\n    self.ping_timeout = ping_timeout\n    self.max_message_size = max_message_size\n    self.compression_options = compression_options",
                                "signature": "__init__(self, ping_interval: float=None, ping_timeout: float=None, max_message_size: int=_default_max_message_size, compression_options: Dict[str, Any]=None) -> None"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class WebSocketHandler:",
                        "functions": [
                            {
                                "code": "def __init__(\n    self,\n    application: tornado.web.Application,\n    request: httputil.HTTPServerRequest,\n    **kwargs: Any\n) -> None:\n    super(WebSocketHandler, self).__init__(application, request, **kwargs)\n    self.ws_connection = None  # type: Optional[WebSocketProtocol]\n    self.close_code = None  # type: Optional[int]\n    self.close_reason = None  # type: Optional[str]\n    self.stream = None  # type: Optional[IOStream]\n    self._on_close_called = False",
                                "signature": "__init__(self, application: tornado.web.Application, request: httputil.HTTPServerRequest, **kwargs: Any) -> None"
                            },
                            {
                                "code": "async def get(self, *args: Any, **kwargs: Any) -> None:\n    self.open_args = args\n    self.open_kwargs = kwargs\n\n    # Upgrade header should be present and should be equal to WebSocket\n    if self.request.headers.get(\"Upgrade\", \"\").lower() != \"websocket\":\n        self.set_status(400)\n        log_msg = 'Can \"Upgrade\" only to \"WebSocket\".'\n        self.finish(log_msg)\n        gen_log.debug(log_msg)\n        return\n\n    # Connection header should be upgrade.\n    # Some proxy servers/load balancers\n    # might mess with it.\n    headers = self.request.headers\n    connection = map(\n        lambda s: s.strip().lower(), headers.get(\"Connection\", \"\").split(\",\")\n    )\n    if \"upgrade\" not in connection:\n        self.set_status(400)\n        log_msg = '\"Connection\" must be \"Upgrade\".'\n        self.finish(log_msg)\n        gen_log.debug(log_msg)\n        return\n\n    # Handle WebSocket Origin naming convention differences\n    # The difference between version 8 and 13 is that in 8 the\n    # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n    # simply \"Origin\".\n    if \"Origin\" in self.request.headers:\n        origin = self.request.headers.get(\"Origin\")\n    else:\n        origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n\n    # If there was an origin header, check to make sure it matches\n    # according to check_origin. When the origin is None, we assume it\n    # did not come from a browser and that it can be passed on.\n    if origin is not None and not self.check_origin(origin):\n        self.set_status(403)\n        log_msg = \"Cross origin websockets not allowed\"\n        self.finish(log_msg)\n        gen_log.debug(log_msg)\n        return\n\n    self.ws_connection = self.get_websocket_protocol()\n    if self.ws_connection:\n        await self.ws_connection.accept_connection(self)\n    else:\n        self.set_status(426, \"Upgrade Required\")\n        self.set_header(\"Sec-WebSocket-Version\", \"7, 8, 13\")",
                                "signature": "get(self, *args: Any, **kwargs: Any) -> None"
                            },
                            {
                                "code": "@property\ndef ping_interval(self) -> Optional[float]:\n    \"\"\"The interval for websocket keep-alive pings.\n\n    Set websocket_ping_interval = 0 to disable pings.\n    \"\"\"\n    return self.settings.get(\"websocket_ping_interval\", None)",
                                "signature": "ping_interval(self) -> Optional[float]"
                            },
                            {
                                "code": "@property\ndef ping_timeout(self) -> Optional[float]:\n    \"\"\"If no ping is received in this many seconds,\n    close the websocket connection (VPNs, etc. can fail to cleanly close ws connections).\n    Default is max of 3 pings or 30 seconds.\n    \"\"\"\n    return self.settings.get(\"websocket_ping_timeout\", None)",
                                "signature": "ping_timeout(self) -> Optional[float]"
                            },
                            {
                                "code": "@property\ndef max_message_size(self) -> int:\n    \"\"\"Maximum allowed message size.\n\n    If the remote peer sends a message larger than this, the connection\n    will be closed.\n\n    Default is 10MiB.\n    \"\"\"\n    return self.settings.get(\n        \"websocket_max_message_size\", _default_max_message_size\n    )",
                                "signature": "max_message_size(self) -> int"
                            },
                            {
                                "code": "def write_message(\n    self, message: Union[bytes, str, Dict[str, Any]], binary: bool = False\n) -> \"Future[None]\":\n    \"\"\"Sends the given message to the client of this Web Socket.\n\n    The message may be either a string or a dict (which will be\n    encoded as json).  If the ``binary`` argument is false, the\n    message will be sent as utf8; in binary mode any byte string\n    is allowed.\n\n    If the connection is already closed, raises `WebSocketClosedError`.\n    Returns a `.Future` which can be used for flow control.\n\n    .. versionchanged:: 3.2\n       `WebSocketClosedError` was added (previously a closed connection\n       would raise an `AttributeError`)\n\n    .. versionchanged:: 4.3\n       Returns a `.Future` which can be used for flow control.\n\n    .. versionchanged:: 5.0\n       Consistently raises `WebSocketClosedError`. Previously could\n       sometimes raise `.StreamClosedError`.\n    \"\"\"\n    if self.ws_connection is None or self.ws_connection.is_closing():\n        raise WebSocketClosedError()\n    if isinstance(message, dict):\n        message = tornado.escape.json_encode(message)\n    return self.ws_connection.write_message(message, binary=binary)",
                                "signature": "write_message(self, message: Union[bytes, str, Dict[str, Any]], binary: bool=False) -> 'Future[None]'"
                            },
                            {
                                "code": "def select_subprotocol(self, subprotocols: List[str]) -> Optional[str]:\n    \"\"\"Override to implement subprotocol negotiation.\n\n    ``subprotocols`` is a list of strings identifying the\n    subprotocols proposed by the client.  This method may be\n    overridden to return one of those strings to select it, or\n    ``None`` to not select a subprotocol.\n\n    Failure to select a subprotocol does not automatically abort\n    the connection, although clients may close the connection if\n    none of their proposed subprotocols was selected.\n\n    The list may be empty, in which case this method must return\n    None. This method is always called exactly once even if no\n    subprotocols were proposed so that the handler can be advised\n    of this fact.\n\n    .. versionchanged:: 5.1\n\n       Previously, this method was called with a list containing\n       an empty string instead of an empty list if no subprotocols\n       were proposed by the client.\n    \"\"\"\n    return None",
                                "signature": "select_subprotocol(self, subprotocols: List[str]) -> Optional[str]"
                            },
                            {
                                "code": "@property\ndef selected_subprotocol(self) -> Optional[str]:\n    \"\"\"The subprotocol returned by `select_subprotocol`.\n\n    .. versionadded:: 5.1\n    \"\"\"\n    assert self.ws_connection is not None\n    return self.ws_connection.selected_subprotocol",
                                "signature": "selected_subprotocol(self) -> Optional[str]"
                            },
                            {
                                "code": "def get_compression_options(self) -> Optional[Dict[str, Any]]:\n    \"\"\"Override to return compression options for the connection.\n\n    If this method returns None (the default), compression will\n    be disabled.  If it returns a dict (even an empty one), it\n    will be enabled.  The contents of the dict may be used to\n    control the following compression options:\n\n    ``compression_level`` specifies the compression level.\n\n    ``mem_level`` specifies the amount of memory used for the internal compression state.\n\n     These parameters are documented in details here:\n     https://docs.python.org/3.6/library/zlib.html#zlib.compressobj\n\n    .. versionadded:: 4.1\n\n    .. versionchanged:: 4.5\n\n       Added ``compression_level`` and ``mem_level``.\n    \"\"\"\n    # TODO: Add wbits option.\n    return None",
                                "signature": "get_compression_options(self) -> Optional[Dict[str, Any]]"
                            },
                            {
                                "code": "def open(self, *args: str, **kwargs: str) -> Optional[Awaitable[None]]:\n    \"\"\"Invoked when a new WebSocket is opened.\n\n    The arguments to `open` are extracted from the `tornado.web.URLSpec`\n    regular expression, just like the arguments to\n    `tornado.web.RequestHandler.get`.\n\n    `open` may be a coroutine. `on_message` will not be called until\n    `open` has returned.\n\n    .. versionchanged:: 5.1\n\n       ``open`` may be a coroutine.\n    \"\"\"\n    pass",
                                "signature": "open(self, *args: str, **kwargs: str) -> Optional[Awaitable[None]]"
                            },
                            {
                                "code": "def on_message(self, message: Union[str, bytes]) -> Optional[Awaitable[None]]:\n    \"\"\"Handle incoming messages on the WebSocket\n\n    This method must be overridden.\n\n    .. versionchanged:: 4.5\n\n       ``on_message`` can be a coroutine.\n    \"\"\"\n    raise NotImplementedError",
                                "signature": "on_message(self, message: Union[str, bytes]) -> Optional[Awaitable[None]]"
                            },
                            {
                                "code": "def ping(self, data: Union[str, bytes] = b\"\") -> None:\n    \"\"\"Send ping frame to the remote end.\n\n    The data argument allows a small amount of data (up to 125\n    bytes) to be sent as a part of the ping message. Note that not\n    all websocket implementations expose this data to\n    applications.\n\n    Consider using the ``websocket_ping_interval`` application\n    setting instead of sending pings manually.\n\n    .. versionchanged:: 5.1\n\n       The data argument is now optional.\n\n    \"\"\"\n    data = utf8(data)\n    if self.ws_connection is None or self.ws_connection.is_closing():\n        raise WebSocketClosedError()\n    self.ws_connection.write_ping(data)",
                                "signature": "ping(self, data: Union[str, bytes]=b'') -> None"
                            },
                            {
                                "code": "def on_pong(self, data: bytes) -> None:\n    \"\"\"Invoked when the response to a ping frame is received.\"\"\"\n    pass",
                                "signature": "on_pong(self, data: bytes) -> None"
                            },
                            {
                                "code": "def on_ping(self, data: bytes) -> None:\n    \"\"\"Invoked when the a ping frame is received.\"\"\"\n    pass",
                                "signature": "on_ping(self, data: bytes) -> None"
                            },
                            {
                                "code": "def on_close(self) -> None:\n    \"\"\"Invoked when the WebSocket is closed.\n\n    If the connection was closed cleanly and a status code or reason\n    phrase was supplied, these values will be available as the attributes\n    ``self.close_code`` and ``self.close_reason``.\n\n    .. versionchanged:: 4.0\n\n       Added ``close_code`` and ``close_reason`` attributes.\n    \"\"\"\n    pass",
                                "signature": "on_close(self) -> None"
                            },
                            {
                                "code": "def close(self, code: int = None, reason: str = None) -> None:\n    \"\"\"Closes this Web Socket.\n\n    Once the close handshake is successful the socket will be closed.\n\n    ``code`` may be a numeric status code, taken from the values\n    defined in `RFC 6455 section 7.4.1\n    <https://tools.ietf.org/html/rfc6455#section-7.4.1>`_.\n    ``reason`` may be a textual message about why the connection is\n    closing.  These values are made available to the client, but are\n    not otherwise interpreted by the websocket protocol.\n\n    .. versionchanged:: 4.0\n\n       Added the ``code`` and ``reason`` arguments.\n    \"\"\"\n    if self.ws_connection:\n        self.ws_connection.close(code, reason)\n        self.ws_connection = None",
                                "signature": "close(self, code: int=None, reason: str=None) -> None"
                            },
                            {
                                "code": "def check_origin(self, origin: str) -> bool:\n    \"\"\"Override to enable support for allowing alternate origins.\n\n    The ``origin`` argument is the value of the ``Origin`` HTTP\n    header, the url responsible for initiating this request.  This\n    method is not called for clients that do not send this header;\n    such requests are always allowed (because all browsers that\n    implement WebSockets support this header, and non-browser\n    clients do not have the same cross-site security concerns).\n\n    Should return ``True`` to accept the request or ``False`` to\n    reject it. By default, rejects all requests with an origin on\n    a host other than this one.\n\n    This is a security protection against cross site scripting attacks on\n    browsers, since WebSockets are allowed to bypass the usual same-origin\n    policies and don't use CORS headers.\n\n    .. warning::\n\n       This is an important security measure; don't disable it\n       without understanding the security implications. In\n       particular, if your authentication is cookie-based, you\n       must either restrict the origins allowed by\n       ``check_origin()`` or implement your own XSRF-like\n       protection for websocket connections. See `these\n       <https://www.christian-schneider.net/CrossSiteWebSocketHijacking.html>`_\n       `articles\n       <https://devcenter.heroku.com/articles/websocket-security>`_\n       for more.\n\n    To accept all cross-origin traffic (which was the default prior to\n    Tornado 4.0), simply override this method to always return ``True``::\n\n        def check_origin(self, origin):\n            return True\n\n    To allow connections from any subdomain of your site, you might\n    do something like::\n\n        def check_origin(self, origin):\n            parsed_origin = urllib.parse.urlparse(origin)\n            return parsed_origin.netloc.endswith(\".mydomain.com\")\n\n    .. versionadded:: 4.0\n\n    \"\"\"\n    parsed_origin = urlparse(origin)\n    origin = parsed_origin.netloc\n    origin = origin.lower()\n\n    host = self.request.headers.get(\"Host\")\n\n    # Check to see that origin matches host directly, including ports\n    return origin == host",
                                "signature": "check_origin(self, origin: str) -> bool"
                            },
                            {
                                "code": "def set_nodelay(self, value: bool) -> None:\n    \"\"\"Set the no-delay flag for this stream.\n\n    By default, small messages may be delayed and/or combined to minimize\n    the number of packets sent.  This can sometimes cause 200-500ms delays\n    due to the interaction between Nagle's algorithm and TCP delayed\n    ACKs.  To reduce this delay (at the expense of possibly increasing\n    bandwidth usage), call ``self.set_nodelay(True)`` once the websocket\n    connection is established.\n\n    See `.BaseIOStream.set_nodelay` for additional details.\n\n    .. versionadded:: 3.1\n    \"\"\"\n    assert self.stream is not None\n    self.stream.set_nodelay(value)",
                                "signature": "set_nodelay(self, value: bool) -> None"
                            },
                            {
                                "code": "def on_connection_close(self) -> None:\n    if self.ws_connection:\n        self.ws_connection.on_connection_close()\n        self.ws_connection = None\n    if not self._on_close_called:\n        self._on_close_called = True\n        self.on_close()\n        self._break_cycles()",
                                "signature": "on_connection_close(self) -> None"
                            },
                            {
                                "code": "def on_ws_connection_close(\n    self, close_code: int = None, close_reason: str = None\n) -> None:\n    self.close_code = close_code\n    self.close_reason = close_reason\n    self.on_connection_close()",
                                "signature": "on_ws_connection_close(self, close_code: int=None, close_reason: str=None) -> None"
                            },
                            {
                                "code": "def _break_cycles(self) -> None:\n    # WebSocketHandlers call finish() early, but we don't want to\n    # break up reference cycles (which makes it impossible to call\n    # self.render_string) until after we've really closed the\n    # connection (if it was established in the first place,\n    # indicated by status code 101).\n    if self.get_status() != 101 or self._on_close_called:\n        super(WebSocketHandler, self)._break_cycles()",
                                "signature": "_break_cycles(self) -> None"
                            },
                            {
                                "code": "def send_error(self, *args: Any, **kwargs: Any) -> None:\n    if self.stream is None:\n        super(WebSocketHandler, self).send_error(*args, **kwargs)\n    else:\n        # If we get an uncaught exception during the handshake,\n        # we have no choice but to abruptly close the connection.\n        # TODO: for uncaught exceptions after the handshake,\n        # we can close the connection more gracefully.\n        self.stream.close()",
                                "signature": "send_error(self, *args: Any, **kwargs: Any) -> None"
                            },
                            {
                                "code": "def get_websocket_protocol(self) -> Optional[\"WebSocketProtocol\"]:\n    websocket_version = self.request.headers.get(\"Sec-WebSocket-Version\")\n    if websocket_version in (\"7\", \"8\", \"13\"):\n        params = _WebSocketParams(\n            ping_interval=self.ping_interval,\n            ping_timeout=self.ping_timeout,\n            max_message_size=self.max_message_size,\n            compression_options=self.get_compression_options(),\n        )\n        return WebSocketProtocol13(self, False, params)\n    return None",
                                "signature": "get_websocket_protocol(self) -> Optional['WebSocketProtocol']"
                            },
                            {
                                "code": "def _detach_stream(self) -> IOStream:\n    # disable non-WS methods\n    for method in [\n        \"write\",\n        \"redirect\",\n        \"set_header\",\n        \"set_cookie\",\n        \"set_status\",\n        \"flush\",\n        \"finish\",\n    ]:\n        setattr(self, method, _raise_not_supported_for_websockets)\n    return self.detach()",
                                "signature": "_detach_stream(self) -> IOStream"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class WebSocketProtocol:",
                        "functions": [
                            {
                                "code": "def __init__(self, handler: \"_WebSocketDelegate\") -> None:\n    self.handler = handler\n    self.stream = None  # type: Optional[IOStream]\n    self.client_terminated = False\n    self.server_terminated = False",
                                "signature": "__init__(self, handler: '_WebSocketDelegate') -> None"
                            },
                            {
                                "code": "def _run_callback(\n    self, callback: Callable, *args: Any, **kwargs: Any\n) -> \"Optional[Future[Any]]\":\n    \"\"\"Runs the given callback with exception handling.\n\n    If the callback is a coroutine, returns its Future. On error, aborts the\n    websocket connection and returns None.\n    \"\"\"\n    try:\n        result = callback(*args, **kwargs)\n    except Exception:\n        self.handler.log_exception(*sys.exc_info())\n        self._abort()\n        return None\n    else:\n        if result is not None:\n            result = gen.convert_yielded(result)\n            assert self.stream is not None\n            self.stream.io_loop.add_future(result, lambda f: f.result())\n        return result",
                                "signature": "_run_callback(self, callback: Callable, *args: Any, **kwargs: Any) -> 'Optional[Future[Any]]'"
                            },
                            {
                                "code": "def on_connection_close(self) -> None:\n    self._abort()",
                                "signature": "on_connection_close(self) -> None"
                            },
                            {
                                "code": "def _abort(self) -> None:\n    \"\"\"Instantly aborts the WebSocket connection by closing the socket\"\"\"\n    self.client_terminated = True\n    self.server_terminated = True\n    if self.stream is not None:\n        self.stream.close()  # forcibly tear down the connection\n    self.close()  # let the subclass cleanup",
                                "signature": "_abort(self) -> None"
                            },
                            {
                                "code": "@abc.abstractmethod\ndef close(self, code: int = None, reason: str = None) -> None:\n    raise NotImplementedError()",
                                "signature": "close(self, code: int=None, reason: str=None) -> None"
                            },
                            {
                                "code": "@abc.abstractmethod\ndef is_closing(self) -> bool:\n    raise NotImplementedError()",
                                "signature": "is_closing(self) -> bool"
                            },
                            {
                                "code": "@abc.abstractmethod\nasync def accept_connection(self, handler: WebSocketHandler) -> None:\n    raise NotImplementedError()",
                                "signature": "accept_connection(self, handler: WebSocketHandler) -> None"
                            },
                            {
                                "code": "@abc.abstractmethod\ndef write_message(\n    self, message: Union[str, bytes], binary: bool = False\n) -> \"Future[None]\":\n    raise NotImplementedError()",
                                "signature": "write_message(self, message: Union[str, bytes], binary: bool=False) -> 'Future[None]'"
                            },
                            {
                                "code": "@property\n@abc.abstractmethod\ndef selected_subprotocol(self) -> Optional[str]:\n    raise NotImplementedError()",
                                "signature": "selected_subprotocol(self) -> Optional[str]"
                            },
                            {
                                "code": "@abc.abstractmethod\ndef write_ping(self, data: bytes) -> None:\n    raise NotImplementedError()",
                                "signature": "write_ping(self, data: bytes) -> None"
                            },
                            {
                                "code": "@abc.abstractmethod\ndef _process_server_headers(\n    self, key: Union[str, bytes], headers: httputil.HTTPHeaders\n) -> None:\n    raise NotImplementedError()",
                                "signature": "_process_server_headers(self, key: Union[str, bytes], headers: httputil.HTTPHeaders) -> None"
                            },
                            {
                                "code": "@abc.abstractmethod\ndef start_pinging(self) -> None:\n    raise NotImplementedError()",
                                "signature": "start_pinging(self) -> None"
                            },
                            {
                                "code": "@abc.abstractmethod\nasync def _receive_frame_loop(self) -> None:\n    raise NotImplementedError()",
                                "signature": "_receive_frame_loop(self) -> None"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class _PerMessageDeflateCompressor:",
                        "functions": [
                            {
                                "code": "def __init__(\n    self,\n    persistent: bool,\n    max_wbits: Optional[int],\n    compression_options: Dict[str, Any] = None,\n) -> None:\n    if max_wbits is None:\n        max_wbits = zlib.MAX_WBITS\n    # There is no symbolic constant for the minimum wbits value.\n    if not (8 <= max_wbits <= zlib.MAX_WBITS):\n        raise ValueError(\n            \"Invalid max_wbits value %r; allowed range 8-%d\",\n            max_wbits,\n            zlib.MAX_WBITS,\n        )\n    self._max_wbits = max_wbits\n\n    if (\n        compression_options is None\n        or \"compression_level\" not in compression_options\n    ):\n        self._compression_level = tornado.web.GZipContentEncoding.GZIP_LEVEL\n    else:\n        self._compression_level = compression_options[\"compression_level\"]\n\n    if compression_options is None or \"mem_level\" not in compression_options:\n        self._mem_level = 8\n    else:\n        self._mem_level = compression_options[\"mem_level\"]\n\n    if persistent:\n        self._compressor = self._create_compressor()  # type: Optional[_Compressor]\n    else:\n        self._compressor = None",
                                "signature": "__init__(self, persistent: bool, max_wbits: Optional[int], compression_options: Dict[str, Any]=None) -> None"
                            },
                            {
                                "code": "def _create_compressor(self) -> \"_Compressor\":\n    return zlib.compressobj(\n        self._compression_level, zlib.DEFLATED, -self._max_wbits, self._mem_level\n    )",
                                "signature": "_create_compressor(self) -> '_Compressor'"
                            },
                            {
                                "code": "def compress(self, data: bytes) -> bytes:\n    compressor = self._compressor or self._create_compressor()\n    data = compressor.compress(data) + compressor.flush(zlib.Z_SYNC_FLUSH)\n    assert data.endswith(b\"\\x00\\x00\\xff\\xff\")\n    return data[:-4]",
                                "signature": "compress(self, data: bytes) -> bytes"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class _PerMessageDeflateDecompressor:",
                        "functions": [
                            {
                                "code": "def __init__(\n    self,\n    persistent: bool,\n    max_wbits: Optional[int],\n    max_message_size: int,\n    compression_options: Dict[str, Any] = None,\n) -> None:\n    self._max_message_size = max_message_size\n    if max_wbits is None:\n        max_wbits = zlib.MAX_WBITS\n    if not (8 <= max_wbits <= zlib.MAX_WBITS):\n        raise ValueError(\n            \"Invalid max_wbits value %r; allowed range 8-%d\",\n            max_wbits,\n            zlib.MAX_WBITS,\n        )\n    self._max_wbits = max_wbits\n    if persistent:\n        self._decompressor = (\n            self._create_decompressor()\n        )  # type: Optional[_Decompressor]\n    else:\n        self._decompressor = None",
                                "signature": "__init__(self, persistent: bool, max_wbits: Optional[int], max_message_size: int, compression_options: Dict[str, Any]=None) -> None"
                            },
                            {
                                "code": "def _create_decompressor(self) -> \"_Decompressor\":\n    return zlib.decompressobj(-self._max_wbits)",
                                "signature": "_create_decompressor(self) -> '_Decompressor'"
                            },
                            {
                                "code": "def decompress(self, data: bytes) -> bytes:\n    decompressor = self._decompressor or self._create_decompressor()\n    result = decompressor.decompress(\n        data + b\"\\x00\\x00\\xff\\xff\", self._max_message_size\n    )\n    if decompressor.unconsumed_tail:\n        raise _DecompressTooLargeError()\n    return result",
                                "signature": "decompress(self, data: bytes) -> bytes"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class WebSocketProtocol13:",
                        "functions": [
                            {
                                "code": "def __init__(\n    self,\n    handler: \"_WebSocketDelegate\",\n    mask_outgoing: bool,\n    params: _WebSocketParams,\n) -> None:\n    WebSocketProtocol.__init__(self, handler)\n    self.mask_outgoing = mask_outgoing\n    self.params = params\n    self._final_frame = False\n    self._frame_opcode = None\n    self._masked_frame = None\n    self._frame_mask = None  # type: Optional[bytes]\n    self._frame_length = None\n    self._fragmented_message_buffer = None  # type: Optional[bytes]\n    self._fragmented_message_opcode = None\n    self._waiting = None  # type: object\n    self._compression_options = params.compression_options\n    self._decompressor = None  # type: Optional[_PerMessageDeflateDecompressor]\n    self._compressor = None  # type: Optional[_PerMessageDeflateCompressor]\n    self._frame_compressed = None  # type: Optional[bool]\n    # The total uncompressed size of all messages received or sent.\n    # Unicode messages are encoded to utf8.\n    # Only for testing; subject to change.\n    self._message_bytes_in = 0\n    self._message_bytes_out = 0\n    # The total size of all packets received or sent.  Includes\n    # the effect of compression, frame overhead, and control frames.\n    self._wire_bytes_in = 0\n    self._wire_bytes_out = 0\n    self.ping_callback = None  # type: Optional[PeriodicCallback]\n    self.last_ping = 0.0\n    self.last_pong = 0.0\n    self.close_code = None  # type: Optional[int]\n    self.close_reason = None  # type: Optional[str]",
                                "signature": "__init__(self, handler: '_WebSocketDelegate', mask_outgoing: bool, params: _WebSocketParams) -> None"
                            },
                            {
                                "code": "@property\ndef selected_subprotocol(self) -> Optional[str]:\n    return self._selected_subprotocol",
                                "signature": "selected_subprotocol(self) -> Optional[str]"
                            },
                            {
                                "code": "@selected_subprotocol.setter\ndef selected_subprotocol(self, value: Optional[str]) -> None:\n    self._selected_subprotocol = value",
                                "signature": "selected_subprotocol(self, value: Optional[str]) -> None"
                            },
                            {
                                "code": "async def accept_connection(self, handler: WebSocketHandler) -> None:\n    try:\n        self._handle_websocket_headers(handler)\n    except ValueError:\n        handler.set_status(400)\n        log_msg = \"Missing/Invalid WebSocket headers\"\n        handler.finish(log_msg)\n        gen_log.debug(log_msg)\n        return\n\n    try:\n        await self._accept_connection(handler)\n    except asyncio.CancelledError:\n        self._abort()\n        return\n    except ValueError:\n        gen_log.debug(\"Malformed WebSocket request received\", exc_info=True)\n        self._abort()\n        return",
                                "signature": "accept_connection(self, handler: WebSocketHandler) -> None"
                            },
                            {
                                "code": "def _handle_websocket_headers(self, handler: WebSocketHandler) -> None:\n    \"\"\"Verifies all invariant- and required headers\n\n    If a header is missing or have an incorrect value ValueError will be\n    raised\n    \"\"\"\n    fields = (\"Host\", \"Sec-Websocket-Key\", \"Sec-Websocket-Version\")\n    if not all(map(lambda f: handler.request.headers.get(f), fields)):\n        raise ValueError(\"Missing/Invalid WebSocket headers\")",
                                "signature": "_handle_websocket_headers(self, handler: WebSocketHandler) -> None"
                            },
                            {
                                "code": "@staticmethod\ndef compute_accept_value(key: Union[str, bytes]) -> str:\n    \"\"\"Computes the value for the Sec-WebSocket-Accept header,\n    given the value for Sec-WebSocket-Key.\n    \"\"\"\n    sha1 = hashlib.sha1()\n    sha1.update(utf8(key))\n    sha1.update(b\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\")  # Magic value\n    return native_str(base64.b64encode(sha1.digest()))",
                                "signature": "compute_accept_value(key: Union[str, bytes]) -> str"
                            },
                            {
                                "code": "def _challenge_response(self, handler: WebSocketHandler) -> str:\n    return WebSocketProtocol13.compute_accept_value(\n        cast(str, handler.request.headers.get(\"Sec-Websocket-Key\"))\n    )",
                                "signature": "_challenge_response(self, handler: WebSocketHandler) -> str"
                            },
                            {
                                "code": "async def _accept_connection(self, handler: WebSocketHandler) -> None:\n    subprotocol_header = handler.request.headers.get(\"Sec-WebSocket-Protocol\")\n    if subprotocol_header:\n        subprotocols = [s.strip() for s in subprotocol_header.split(\",\")]\n    else:\n        subprotocols = []\n    self.selected_subprotocol = handler.select_subprotocol(subprotocols)\n    if self.selected_subprotocol:\n        assert self.selected_subprotocol in subprotocols\n        handler.set_header(\"Sec-WebSocket-Protocol\", self.selected_subprotocol)\n\n    extensions = self._parse_extensions_header(handler.request.headers)\n    for ext in extensions:\n        if ext[0] == \"permessage-deflate\" and self._compression_options is not None:\n            # TODO: negotiate parameters if compression_options\n            # specifies limits.\n            self._create_compressors(\"server\", ext[1], self._compression_options)\n            if (\n                \"client_max_window_bits\" in ext[1]\n                and ext[1][\"client_max_window_bits\"] is None\n            ):\n                # Don't echo an offered client_max_window_bits\n                # parameter with no value.\n                del ext[1][\"client_max_window_bits\"]\n            handler.set_header(\n                \"Sec-WebSocket-Extensions\",\n                httputil._encode_header(\"permessage-deflate\", ext[1]),\n            )\n            break\n\n    handler.clear_header(\"Content-Type\")\n    handler.set_status(101)\n    handler.set_header(\"Upgrade\", \"websocket\")\n    handler.set_header(\"Connection\", \"Upgrade\")\n    handler.set_header(\"Sec-WebSocket-Accept\", self._challenge_response(handler))\n    handler.finish()\n\n    self.stream = handler._detach_stream()\n\n    self.start_pinging()\n    try:\n        open_result = handler.open(*handler.open_args, **handler.open_kwargs)\n        if open_result is not None:\n            await open_result\n    except Exception:\n        handler.log_exception(*sys.exc_info())\n        self._abort()\n        return\n\n    await self._receive_frame_loop()",
                                "signature": "_accept_connection(self, handler: WebSocketHandler) -> None"
                            },
                            {
                                "code": "def _parse_extensions_header(\n    self, headers: httputil.HTTPHeaders\n) -> List[Tuple[str, Dict[str, str]]]:\n    extensions = headers.get(\"Sec-WebSocket-Extensions\", \"\")\n    if extensions:\n        return [httputil._parse_header(e.strip()) for e in extensions.split(\",\")]\n    return []",
                                "signature": "_parse_extensions_header(self, headers: httputil.HTTPHeaders) -> List[Tuple[str, Dict[str, str]]]"
                            },
                            {
                                "code": "def _process_server_headers(\n    self, key: Union[str, bytes], headers: httputil.HTTPHeaders\n) -> None:\n    \"\"\"Process the headers sent by the server to this client connection.\n\n    'key' is the websocket handshake challenge/response key.\n    \"\"\"\n    assert headers[\"Upgrade\"].lower() == \"websocket\"\n    assert headers[\"Connection\"].lower() == \"upgrade\"\n    accept = self.compute_accept_value(key)\n    assert headers[\"Sec-Websocket-Accept\"] == accept\n\n    extensions = self._parse_extensions_header(headers)\n    for ext in extensions:\n        if ext[0] == \"permessage-deflate\" and self._compression_options is not None:\n            self._create_compressors(\"client\", ext[1])\n        else:\n            raise ValueError(\"unsupported extension %r\", ext)\n\n    self.selected_subprotocol = headers.get(\"Sec-WebSocket-Protocol\", None)",
                                "signature": "_process_server_headers(self, key: Union[str, bytes], headers: httputil.HTTPHeaders) -> None"
                            },
                            {
                                "code": "def _get_compressor_options(\n    self,\n    side: str,\n    agreed_parameters: Dict[str, Any],\n    compression_options: Dict[str, Any] = None,\n) -> Dict[str, Any]:\n    \"\"\"Converts a websocket agreed_parameters set to keyword arguments\n    for our compressor objects.\n    \"\"\"\n    options = dict(\n        persistent=(side + \"_no_context_takeover\") not in agreed_parameters\n    )  # type: Dict[str, Any]\n    wbits_header = agreed_parameters.get(side + \"_max_window_bits\", None)\n    if wbits_header is None:\n        options[\"max_wbits\"] = zlib.MAX_WBITS\n    else:\n        options[\"max_wbits\"] = int(wbits_header)\n    options[\"compression_options\"] = compression_options\n    return options",
                                "signature": "_get_compressor_options(self, side: str, agreed_parameters: Dict[str, Any], compression_options: Dict[str, Any]=None) -> Dict[str, Any]"
                            },
                            {
                                "code": "def _create_compressors(\n    self,\n    side: str,\n    agreed_parameters: Dict[str, Any],\n    compression_options: Dict[str, Any] = None,\n) -> None:\n    # TODO: handle invalid parameters gracefully\n    allowed_keys = set(\n        [\n            \"server_no_context_takeover\",\n            \"client_no_context_takeover\",\n            \"server_max_window_bits\",\n            \"client_max_window_bits\",\n        ]\n    )\n    for key in agreed_parameters:\n        if key not in allowed_keys:\n            raise ValueError(\"unsupported compression parameter %r\" % key)\n    other_side = \"client\" if (side == \"server\") else \"server\"\n    self._compressor = _PerMessageDeflateCompressor(\n        **self._get_compressor_options(side, agreed_parameters, compression_options)\n    )\n    self._decompressor = _PerMessageDeflateDecompressor(\n        max_message_size=self.params.max_message_size,\n        **self._get_compressor_options(\n            other_side, agreed_parameters, compression_options\n        )\n    )",
                                "signature": "_create_compressors(self, side: str, agreed_parameters: Dict[str, Any], compression_options: Dict[str, Any]=None) -> None"
                            },
                            {
                                "code": "def _write_frame(\n    self, fin: bool, opcode: int, data: bytes, flags: int = 0\n) -> \"Future[None]\":\n    data_len = len(data)\n    if opcode & 0x8:\n        # All control frames MUST have a payload length of 125\n        # bytes or less and MUST NOT be fragmented.\n        if not fin:\n            raise ValueError(\"control frames may not be fragmented\")\n        if data_len > 125:\n            raise ValueError(\"control frame payloads may not exceed 125 bytes\")\n    if fin:\n        finbit = self.FIN\n    else:\n        finbit = 0\n    frame = struct.pack(\"B\", finbit | opcode | flags)\n    if self.mask_outgoing:\n        mask_bit = 0x80\n    else:\n        mask_bit = 0\n    if data_len < 126:\n        frame += struct.pack(\"B\", data_len | mask_bit)\n    elif data_len <= 0xFFFF:\n        frame += struct.pack(\"!BH\", 126 | mask_bit, data_len)\n    else:\n        frame += struct.pack(\"!BQ\", 127 | mask_bit, data_len)\n    if self.mask_outgoing:\n        mask = os.urandom(4)\n        data = mask + _websocket_mask(mask, data)\n    frame += data\n    self._wire_bytes_out += len(frame)\n    return self.stream.write(frame)",
                                "signature": "_write_frame(self, fin: bool, opcode: int, data: bytes, flags: int=0) -> 'Future[None]'"
                            },
                            {
                                "code": "def write_message(\n    self, message: Union[str, bytes], binary: bool = False\n) -> \"Future[None]\":\n    \"\"\"Sends the given message to the client of this Web Socket.\"\"\"\n    if binary:\n        opcode = 0x2\n    else:\n        opcode = 0x1\n    message = tornado.escape.utf8(message)\n    assert isinstance(message, bytes)\n    self._message_bytes_out += len(message)\n    flags = 0\n    if self._compressor:\n        message = self._compressor.compress(message)\n        flags |= self.RSV1\n    # For historical reasons, write methods in Tornado operate in a semi-synchronous\n    # mode in which awaiting the Future they return is optional (But errors can\n    # still be raised). This requires us to go through an awkward dance here\n    # to transform the errors that may be returned while presenting the same\n    # semi-synchronous interface.\n    try:\n        fut = self._write_frame(True, opcode, message, flags=flags)\n    except StreamClosedError:\n        raise WebSocketClosedError()\n\n    async def wrapper() -> None:\n        try:\n            await fut\n        except StreamClosedError:\n            raise WebSocketClosedError()\n\n    return asyncio.ensure_future(wrapper())",
                                "signature": "write_message(self, message: Union[str, bytes], binary: bool=False) -> 'Future[None]'"
                            },
                            {
                                "code": "def write_ping(self, data: bytes) -> None:\n    \"\"\"Send ping frame.\"\"\"\n    assert isinstance(data, bytes)\n    self._write_frame(True, 0x9, data)",
                                "signature": "write_ping(self, data: bytes) -> None"
                            },
                            {
                                "code": "async def _receive_frame_loop(self) -> None:\n    try:\n        while not self.client_terminated:\n            await self._receive_frame()\n    except StreamClosedError:\n        self._abort()\n    self.handler.on_ws_connection_close(self.close_code, self.close_reason)",
                                "signature": "_receive_frame_loop(self) -> None"
                            },
                            {
                                "code": "async def _read_bytes(self, n: int) -> bytes:\n    data = await self.stream.read_bytes(n)\n    self._wire_bytes_in += n\n    return data",
                                "signature": "_read_bytes(self, n: int) -> bytes"
                            },
                            {
                                "code": "async def _receive_frame(self) -> None:\n    # Read the frame header.\n    data = await self._read_bytes(2)\n    header, mask_payloadlen = struct.unpack(\"BB\", data)\n    is_final_frame = header & self.FIN\n    reserved_bits = header & self.RSV_MASK\n    opcode = header & self.OPCODE_MASK\n    opcode_is_control = opcode & 0x8\n    if self._decompressor is not None and opcode != 0:\n        # Compression flag is present in the first frame's header,\n        # but we can't decompress until we have all the frames of\n        # the message.\n        self._frame_compressed = bool(reserved_bits & self.RSV1)\n        reserved_bits &= ~self.RSV1\n    if reserved_bits:\n        # client is using as-yet-undefined extensions; abort\n        self._abort()\n        return\n    is_masked = bool(mask_payloadlen & 0x80)\n    payloadlen = mask_payloadlen & 0x7F\n\n    # Parse and validate the length.\n    if opcode_is_control and payloadlen >= 126:\n        # control frames must have payload < 126\n        self._abort()\n        return\n    if payloadlen < 126:\n        self._frame_length = payloadlen\n    elif payloadlen == 126:\n        data = await self._read_bytes(2)\n        payloadlen = struct.unpack(\"!H\", data)[0]\n    elif payloadlen == 127:\n        data = await self._read_bytes(8)\n        payloadlen = struct.unpack(\"!Q\", data)[0]\n    new_len = payloadlen\n    if self._fragmented_message_buffer is not None:\n        new_len += len(self._fragmented_message_buffer)\n    if new_len > self.params.max_message_size:\n        self.close(1009, \"message too big\")\n        self._abort()\n        return\n\n    # Read the payload, unmasking if necessary.\n    if is_masked:\n        self._frame_mask = await self._read_bytes(4)\n    data = await self._read_bytes(payloadlen)\n    if is_masked:\n        assert self._frame_mask is not None\n        data = _websocket_mask(self._frame_mask, data)\n\n    # Decide what to do with this frame.\n    if opcode_is_control:\n        # control frames may be interleaved with a series of fragmented\n        # data frames, so control frames must not interact with\n        # self._fragmented_*\n        if not is_final_frame:\n            # control frames must not be fragmented\n            self._abort()\n            return\n    elif opcode == 0:  # continuation frame\n        if self._fragmented_message_buffer is None:\n            # nothing to continue\n            self._abort()\n            return\n        self._fragmented_message_buffer += data\n        if is_final_frame:\n            opcode = self._fragmented_message_opcode\n            data = self._fragmented_message_buffer\n            self._fragmented_message_buffer = None\n    else:  # start of new data message\n        if self._fragmented_message_buffer is not None:\n            # can't start new message until the old one is finished\n            self._abort()\n            return\n        if not is_final_frame:\n            self._fragmented_message_opcode = opcode\n            self._fragmented_message_buffer = data\n\n    if is_final_frame:\n        handled_future = self._handle_message(opcode, data)\n        if handled_future is not None:\n            await handled_future",
                                "signature": "_receive_frame(self) -> None"
                            },
                            {
                                "code": "def _handle_message(self, opcode: int, data: bytes) -> \"Optional[Future[None]]\":\n    \"\"\"Execute on_message, returning its Future if it is a coroutine.\"\"\"\n    if self.client_terminated:\n        return None\n\n    if self._frame_compressed:\n        assert self._decompressor is not None\n        try:\n            data = self._decompressor.decompress(data)\n        except _DecompressTooLargeError:\n            self.close(1009, \"message too big after decompression\")\n            self._abort()\n            return None\n\n    if opcode == 0x1:\n        # UTF-8 data\n        self._message_bytes_in += len(data)\n        try:\n            decoded = data.decode(\"utf-8\")\n        except UnicodeDecodeError:\n            self._abort()\n            return None\n        return self._run_callback(self.handler.on_message, decoded)\n    elif opcode == 0x2:\n        # Binary data\n        self._message_bytes_in += len(data)\n        return self._run_callback(self.handler.on_message, data)\n    elif opcode == 0x8:\n        # Close\n        self.client_terminated = True\n        if len(data) >= 2:\n            self.close_code = struct.unpack(\">H\", data[:2])[0]\n        if len(data) > 2:\n            self.close_reason = to_unicode(data[2:])\n        # Echo the received close code, if any (RFC 6455 section 5.5.1).\n        self.close(self.close_code)\n    elif opcode == 0x9:\n        # Ping\n        try:\n            self._write_frame(True, 0xA, data)\n        except StreamClosedError:\n            self._abort()\n        self._run_callback(self.handler.on_ping, data)\n    elif opcode == 0xA:\n        # Pong\n        self.last_pong = IOLoop.current().time()\n        return self._run_callback(self.handler.on_pong, data)\n    else:\n        self._abort()\n    return None",
                                "signature": "_handle_message(self, opcode: int, data: bytes) -> 'Optional[Future[None]]'"
                            },
                            {
                                "code": "def close(self, code: int = None, reason: str = None) -> None:\n    \"\"\"Closes the WebSocket connection.\"\"\"\n    if not self.server_terminated:\n        if not self.stream.closed():\n            if code is None and reason is not None:\n                code = 1000  # \"normal closure\" status code\n            if code is None:\n                close_data = b\"\"\n            else:\n                close_data = struct.pack(\">H\", code)\n            if reason is not None:\n                close_data += utf8(reason)\n            try:\n                self._write_frame(True, 0x8, close_data)\n            except StreamClosedError:\n                self._abort()\n        self.server_terminated = True\n    if self.client_terminated:\n        if self._waiting is not None:\n            self.stream.io_loop.remove_timeout(self._waiting)\n            self._waiting = None\n        self.stream.close()\n    elif self._waiting is None:\n        # Give the client a few seconds to complete a clean shutdown,\n        # otherwise just close the connection.\n        self._waiting = self.stream.io_loop.add_timeout(\n            self.stream.io_loop.time() + 5, self._abort\n        )",
                                "signature": "close(self, code: int=None, reason: str=None) -> None"
                            },
                            {
                                "code": "def is_closing(self) -> bool:\n    \"\"\"Return ``True`` if this connection is closing.\n\n    The connection is considered closing if either side has\n    initiated its closing handshake or if the stream has been\n    shut down uncleanly.\n    \"\"\"\n    return self.stream.closed() or self.client_terminated or self.server_terminated",
                                "signature": "is_closing(self) -> bool"
                            },
                            {
                                "code": "@property\ndef ping_interval(self) -> Optional[float]:\n    interval = self.params.ping_interval\n    if interval is not None:\n        return interval\n    return 0",
                                "signature": "ping_interval(self) -> Optional[float]"
                            },
                            {
                                "code": "@property\ndef ping_timeout(self) -> Optional[float]:\n    timeout = self.params.ping_timeout\n    if timeout is not None:\n        return timeout\n    assert self.ping_interval is not None\n    return max(3 * self.ping_interval, 30)",
                                "signature": "ping_timeout(self) -> Optional[float]"
                            },
                            {
                                "code": "def start_pinging(self) -> None:\n    \"\"\"Start sending periodic pings to keep the connection alive\"\"\"\n    assert self.ping_interval is not None\n    if self.ping_interval > 0:\n        self.last_ping = self.last_pong = IOLoop.current().time()\n        self.ping_callback = PeriodicCallback(\n            self.periodic_ping, self.ping_interval * 1000\n        )\n        self.ping_callback.start()",
                                "signature": "start_pinging(self) -> None"
                            },
                            {
                                "code": "def periodic_ping(self) -> None:\n    \"\"\"Send a ping to keep the websocket alive\n\n    Called periodically if the websocket_ping_interval is set and non-zero.\n    \"\"\"\n    if self.is_closing() and self.ping_callback is not None:\n        self.ping_callback.stop()\n        return\n\n    # Check for timeout on pong. Make sure that we really have\n    # sent a recent ping in case the machine with both server and\n    # client has been suspended since the last ping.\n    now = IOLoop.current().time()\n    since_last_pong = now - self.last_pong\n    since_last_ping = now - self.last_ping\n    assert self.ping_interval is not None\n    assert self.ping_timeout is not None\n    if (\n        since_last_ping < 2 * self.ping_interval\n        and since_last_pong > self.ping_timeout\n    ):\n        self.close()\n        return\n\n    self.write_ping(b\"\")\n    self.last_ping = now",
                                "signature": "periodic_ping(self) -> None"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class WebSocketClientConnection:",
                        "functions": [
                            {
                                "code": "def __init__(\n    self,\n    request: httpclient.HTTPRequest,\n    on_message_callback: Callable[[Union[None, str, bytes]], None] = None,\n    compression_options: Dict[str, Any] = None,\n    ping_interval: float = None,\n    ping_timeout: float = None,\n    max_message_size: int = _default_max_message_size,\n    subprotocols: Optional[List[str]] = [],\n) -> None:\n    self.connect_future = Future()  # type: Future[WebSocketClientConnection]\n    self.read_queue = Queue(1)  # type: Queue[Union[None, str, bytes]]\n    self.key = base64.b64encode(os.urandom(16))\n    self._on_message_callback = on_message_callback\n    self.close_code = None  # type: Optional[int]\n    self.close_reason = None  # type: Optional[str]\n    self.params = _WebSocketParams(\n        ping_interval=ping_interval,\n        ping_timeout=ping_timeout,\n        max_message_size=max_message_size,\n        compression_options=compression_options,\n    )\n\n    scheme, sep, rest = request.url.partition(\":\")\n    scheme = {\"ws\": \"http\", \"wss\": \"https\"}[scheme]\n    request.url = scheme + sep + rest\n    request.headers.update(\n        {\n            \"Upgrade\": \"websocket\",\n            \"Connection\": \"Upgrade\",\n            \"Sec-WebSocket-Key\": self.key,\n            \"Sec-WebSocket-Version\": \"13\",\n        }\n    )\n    if subprotocols is not None:\n        request.headers[\"Sec-WebSocket-Protocol\"] = \",\".join(subprotocols)\n    if compression_options is not None:\n        # Always offer to let the server set our max_wbits (and even though\n        # we don't offer it, we will accept a client_no_context_takeover\n        # from the server).\n        # TODO: set server parameters for deflate extension\n        # if requested in self.compression_options.\n        request.headers[\n            \"Sec-WebSocket-Extensions\"\n        ] = \"permessage-deflate; client_max_window_bits\"\n\n    self.tcp_client = TCPClient()\n    super(WebSocketClientConnection, self).__init__(\n        None,\n        request,\n        lambda: None,\n        self._on_http_response,\n        104857600,\n        self.tcp_client,\n        65536,\n        104857600,\n    )",
                                "signature": "__init__(self, request: httpclient.HTTPRequest, on_message_callback: Callable[[Union[None, str, bytes]], None]=None, compression_options: Dict[str, Any]=None, ping_interval: float=None, ping_timeout: float=None, max_message_size: int=_default_max_message_size, subprotocols: Optional[List[str]]=[]) -> None"
                            },
                            {
                                "code": "def close(self, code: int = None, reason: str = None) -> None:\n    \"\"\"Closes the websocket connection.\n\n    ``code`` and ``reason`` are documented under\n    `WebSocketHandler.close`.\n\n    .. versionadded:: 3.2\n\n    .. versionchanged:: 4.0\n\n       Added the ``code`` and ``reason`` arguments.\n    \"\"\"\n    if self.protocol is not None:\n        self.protocol.close(code, reason)\n        self.protocol = None  # type: ignore",
                                "signature": "close(self, code: int=None, reason: str=None) -> None"
                            },
                            {
                                "code": "def on_connection_close(self) -> None:\n    if not self.connect_future.done():\n        self.connect_future.set_exception(StreamClosedError())\n    self._on_message(None)\n    self.tcp_client.close()\n    super(WebSocketClientConnection, self).on_connection_close()",
                                "signature": "on_connection_close(self) -> None"
                            },
                            {
                                "code": "def on_ws_connection_close(\n    self, close_code: int = None, close_reason: str = None\n) -> None:\n    self.close_code = close_code\n    self.close_reason = close_reason\n    self.on_connection_close()",
                                "signature": "on_ws_connection_close(self, close_code: int=None, close_reason: str=None) -> None"
                            },
                            {
                                "code": "def _on_http_response(self, response: httpclient.HTTPResponse) -> None:\n    if not self.connect_future.done():\n        if response.error:\n            self.connect_future.set_exception(response.error)\n        else:\n            self.connect_future.set_exception(\n                WebSocketError(\"Non-websocket response\")\n            )",
                                "signature": "_on_http_response(self, response: httpclient.HTTPResponse) -> None"
                            },
                            {
                                "code": "async def headers_received(\n    self,\n    start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine],\n    headers: httputil.HTTPHeaders,\n) -> None:\n    assert isinstance(start_line, httputil.ResponseStartLine)\n    if start_line.code != 101:\n        await super(WebSocketClientConnection, self).headers_received(\n            start_line, headers\n        )\n        return\n\n    if self._timeout is not None:\n        self.io_loop.remove_timeout(self._timeout)\n        self._timeout = None\n\n    self.headers = headers\n    self.protocol = self.get_websocket_protocol()\n    self.protocol._process_server_headers(self.key, self.headers)\n    self.protocol.stream = self.connection.detach()\n\n    IOLoop.current().add_callback(self.protocol._receive_frame_loop)\n    self.protocol.start_pinging()\n\n    # Once we've taken over the connection, clear the final callback\n    # we set on the http request.  This deactivates the error handling\n    # in simple_httpclient that would otherwise interfere with our\n    # ability to see exceptions.\n    self.final_callback = None  # type: ignore\n\n    future_set_result_unless_cancelled(self.connect_future, self)",
                                "signature": "headers_received(self, start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine], headers: httputil.HTTPHeaders) -> None"
                            },
                            {
                                "code": "def write_message(\n    self, message: Union[str, bytes], binary: bool = False\n) -> \"Future[None]\":\n    \"\"\"Sends a message to the WebSocket server.\n\n    If the stream is closed, raises `WebSocketClosedError`.\n    Returns a `.Future` which can be used for flow control.\n\n    .. versionchanged:: 5.0\n       Exception raised on a closed stream changed from `.StreamClosedError`\n       to `WebSocketClosedError`.\n    \"\"\"\n    return self.protocol.write_message(message, binary=binary)",
                                "signature": "write_message(self, message: Union[str, bytes], binary: bool=False) -> 'Future[None]'"
                            },
                            {
                                "code": "def read_message(\n    self, callback: Callable[[\"Future[Union[None, str, bytes]]\"], None] = None\n) -> Awaitable[Union[None, str, bytes]]:\n    \"\"\"Reads a message from the WebSocket server.\n\n    If on_message_callback was specified at WebSocket\n    initialization, this function will never return messages\n\n    Returns a future whose result is the message, or None\n    if the connection is closed.  If a callback argument\n    is given it will be called with the future when it is\n    ready.\n    \"\"\"\n\n    awaitable = self.read_queue.get()\n    if callback is not None:\n        self.io_loop.add_future(asyncio.ensure_future(awaitable), callback)\n    return awaitable",
                                "signature": "read_message(self, callback: Callable[['Future[Union[None, str, bytes]]'], None]=None) -> Awaitable[Union[None, str, bytes]]"
                            },
                            {
                                "code": "def on_message(self, message: Union[str, bytes]) -> Optional[Awaitable[None]]:\n    return self._on_message(message)",
                                "signature": "on_message(self, message: Union[str, bytes]) -> Optional[Awaitable[None]]"
                            },
                            {
                                "code": "def _on_message(\n    self, message: Union[None, str, bytes]\n) -> Optional[Awaitable[None]]:\n    if self._on_message_callback:\n        self._on_message_callback(message)\n        return None\n    else:\n        return self.read_queue.put(message)",
                                "signature": "_on_message(self, message: Union[None, str, bytes]) -> Optional[Awaitable[None]]"
                            },
                            {
                                "code": "def ping(self, data: bytes = b\"\") -> None:\n    \"\"\"Send ping frame to the remote end.\n\n    The data argument allows a small amount of data (up to 125\n    bytes) to be sent as a part of the ping message. Note that not\n    all websocket implementations expose this data to\n    applications.\n\n    Consider using the ``ping_interval`` argument to\n    `websocket_connect` instead of sending pings manually.\n\n    .. versionadded:: 5.1\n\n    \"\"\"\n    data = utf8(data)\n    if self.protocol is None:\n        raise WebSocketClosedError()\n    self.protocol.write_ping(data)",
                                "signature": "ping(self, data: bytes=b'') -> None"
                            },
                            {
                                "code": "def on_pong(self, data: bytes) -> None:\n    pass",
                                "signature": "on_pong(self, data: bytes) -> None"
                            },
                            {
                                "code": "def on_ping(self, data: bytes) -> None:\n    pass",
                                "signature": "on_ping(self, data: bytes) -> None"
                            },
                            {
                                "code": "def get_websocket_protocol(self) -> WebSocketProtocol:\n    return WebSocketProtocol13(self, mask_outgoing=True, params=self.params)",
                                "signature": "get_websocket_protocol(self) -> WebSocketProtocol"
                            },
                            {
                                "code": "@property\ndef selected_subprotocol(self) -> Optional[str]:\n    \"\"\"The subprotocol selected by the server.\n\n    .. versionadded:: 5.1\n    \"\"\"\n    return self.protocol.selected_subprotocol",
                                "signature": "selected_subprotocol(self) -> Optional[str]"
                            },
                            {
                                "code": "def log_exception(\n    self,\n    typ: \"Optional[Type[BaseException]]\",\n    value: Optional[BaseException],\n    tb: Optional[TracebackType],\n) -> None:\n    assert typ is not None\n    assert value is not None\n    app_log.error(\"Uncaught exception %s\", value, exc_info=(typ, value, tb))",
                                "signature": "log_exception(self, typ: 'Optional[Type[BaseException]]', value: Optional[BaseException], tb: Optional[TracebackType]) -> None"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class _Compressor:",
                        "functions": [
                            {
                                "code": "def compress(self, data: bytes) -> bytes:\n    pass",
                                "signature": "compress(self, data: bytes) -> bytes"
                            },
                            {
                                "code": "def flush(self, mode: int) -> bytes:\n    pass",
                                "signature": "flush(self, mode: int) -> bytes"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class _Decompressor:",
                        "functions": [
                            {
                                "code": "def decompress(self, data: bytes, max_length: int) -> bytes:\n    pass",
                                "signature": "decompress(self, data: bytes, max_length: int) -> bytes"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class _WebSocketDelegate:",
                        "functions": [
                            {
                                "code": "def on_ws_connection_close(\n    self, close_code: int = None, close_reason: str = None\n) -> None:\n    pass",
                                "signature": "on_ws_connection_close(self, close_code: int=None, close_reason: str=None) -> None"
                            },
                            {
                                "code": "def on_message(self, message: Union[str, bytes]) -> Optional[\"Awaitable[None]\"]:\n    pass",
                                "signature": "on_message(self, message: Union[str, bytes]) -> Optional['Awaitable[None]']"
                            },
                            {
                                "code": "def on_ping(self, data: bytes) -> None:\n    pass",
                                "signature": "on_ping(self, data: bytes) -> None"
                            },
                            {
                                "code": "def on_pong(self, data: bytes) -> None:\n    pass",
                                "signature": "on_pong(self, data: bytes) -> None"
                            },
                            {
                                "code": "def log_exception(\n    self,\n    typ: Optional[Type[BaseException]],\n    value: Optional[BaseException],\n    tb: Optional[TracebackType],\n) -> None:\n    pass",
                                "signature": "log_exception(self, typ: Optional[Type[BaseException]], value: Optional[BaseException], tb: Optional[TracebackType]) -> None"
                            }
                        ]
                    }
                ]
            },
            "variables_in_file": {
                "TYPE_CHECKING": [
                    57
                ],
                "Protocol": [
                    75,
                    69,
                    62
                ],
                "bytes": [
                    897,
                    1551,
                    1041,
                    1554,
                    794,
                    418,
                    429,
                    686,
                    1583,
                    1074,
                    1207,
                    696,
                    1082,
                    315,
                    63,
                    705,
                    66,
                    450,
                    454,
                    72,
                    971,
                    1488,
                    1361,
                    1106,
                    84,
                    1108,
                    87,
                    90,
                    1119,
                    1503,
                    1520,
                    1524,
                    759,
                    1532
                ],
                "int": [
                    770,
                    771,
                    1416,
                    1041,
                    1440,
                    673,
                    302,
                    1587,
                    1207,
                    574,
                    66,
                    72,
                    80,
                    722,
                    1365,
                    471,
                    1119,
                    1258,
                    1007,
                    127
                ],
                "unconsumed_tail": [
                    70
                ],
                "str": [
                    128,
                    897,
                    772,
                    1416,
                    906,
                    908,
                    402,
                    1561,
                    1440,
                    673,
                    418,
                    1580,
                    429,
                    686,
                    1583,
                    1584,
                    1074,
                    692,
                    1588,
                    315,
                    574,
                    705,
                    964,
                    971,
                    80,
                    1361,
                    1362,
                    723,
                    84,
                    1488,
                    1366,
                    471,
                    344,
                    859,
                    863,
                    1503,
                    993,
                    994,
                    995,
                    996,
                    1258,
                    491,
                    1520,
                    370,
                    1524,
                    1013,
                    1014,
                    1015,
                    378
                ],
                "Union": [
                    705,
                    418,
                    897,
                    971,
                    1580,
                    429,
                    686,
                    1583,
                    1488,
                    1361,
                    1074,
                    1457,
                    84,
                    1520,
                    1524,
                    315,
                    1503
                ],
                "Optional": [
                    770,
                    1297,
                    402,
                    1304,
                    1561,
                    286,
                    418,
                    1571,
                    1572,
                    294,
                    692,
                    722,
                    84,
                    1366,
                    599,
                    344,
                    859,
                    863,
                    96,
                    97,
                    95,
                    1520,
                    370,
                    1525,
                    378
                ],
                "Type": [
                    95
                ],
                "BaseException": [
                    96,
                    1571,
                    95
                ],
                "TracebackType": [
                    97,
                    1572
                ],
                "_default_max_message_size": [
                    102,
                    1587,
                    1365,
                    311,
                    127
                ],
                "Exception": [
                    105,
                    650,
                    955,
                    118
                ],
                "WebSocketError": [
                    1452,
                    109
                ],
                "object": [
                    122,
                    718,
                    766
                ],
                "float": [
                    294,
                    1582,
                    1297,
                    1585,
                    1363,
                    1364,
                    1586,
                    1304,
                    125,
                    126,
                    286
                ],
                "Dict": [
                    128,
                    994,
                    995,
                    772,
                    964,
                    996,
                    1584,
                    1362,
                    723,
                    1014,
                    1015,
                    378,
                    315
                ],
                "Any": [
                    128,
                    641,
                    994,
                    995,
                    772,
                    996,
                    231,
                    589,
                    1584,
                    626,
                    723,
                    1362,
                    1014,
                    1015,
                    378,
                    315,
                    222
                ],
                "self.ping_interval": [
                    1313,
                    130,
                    1314,
                    1317,
                    1339,
                    1336,
                    603,
                    1308,
                    1309
                ],
                "self": [
                    1030,
                    1031,
                    1033,
                    1034,
                    1035,
                    1547,
                    1549,
                    1558,
                    1052,
                    542,
                    1566,
                    1056,
                    1066,
                    1070,
                    1071,
                    561,
                    562,
                    565,
                    566,
                    567,
                    568,
                    569,
                    570,
                    571,
                    1083,
                    1085,
                    1086,
                    1087,
                    576,
                    577,
                    578,
                    1094,
                    586,
                    587,
                    590,
                    591,
                    1339,
                    597,
                    1109,
                    1340,
                    600,
                    1113,
                    1114,
                    603,
                    604,
                    605,
                    606,
                    1116,
                    608,
                    1117,
                    1120,
                    1121,
                    1342,
                    1126,
                    1128,
                    1129,
                    1130,
                    1132,
                    622,
                    623,
                    1136,
                    1137,
                    1140,
                    635,
                    636,
                    637,
                    638,
                    1148,
                    1151,
                    1153,
                    130,
                    131,
                    132,
                    133,
                    1156,
                    1159,
                    1160,
                    1161,
                    1162,
                    651,
                    652,
                    1163,
                    1248,
                    1249,
                    1168,
                    657,
                    658,
                    1169,
                    1171,
                    1172,
                    662,
                    666,
                    667,
                    668,
                    669,
                    670,
                    1181,
                    1184,
                    1252,
                    1186,
                    1253,
                    1188,
                    1190,
                    1191,
                    1192,
                    1194,
                    1255,
                    1196,
                    1199,
                    1200,
                    1203,
                    1209,
                    1212,
                    1213,
                    1215,
                    1217,
                    1218,
                    1223,
                    1227,
                    1229,
                    1232,
                    1233,
                    1236,
                    1238,
                    1240,
                    1242,
                    734,
                    1246,
                    224,
                    225,
                    226,
                    227,
                    228,
                    229,
                    740,
                    742,
                    232,
                    233,
                    745,
                    747,
                    236,
                    237,
                    750,
                    239,
                    752,
                    1260,
                    1261,
                    756,
                    246,
                    1271,
                    760,
                    1273,
                    1274,
                    251,
                    1275,
                    253,
                    1276,
                    1277,
                    1278,
                    1279,
                    1280,
                    1283,
                    1284,
                    261,
                    262,
                    774,
                    264,
                    269,
                    270,
                    783,
                    272,
                    785,
                    786,
                    1294,
                    276,
                    277,
                    278,
                    789,
                    280,
                    281,
                    792,
                    795,
                    1305,
                    797,
                    1308,
                    1309,
                    1313,
                    1314,
                    291,
                    1315,
                    1316,
                    1317,
                    1319,
                    299,
                    1326,
                    1327,
                    310,
                    1334,
                    1335,
                    1336,
                    1337,
                    827,
                    828,
                    829,
                    830,
                    831,
                    832,
                    833,
                    834,
                    835,
                    836,
                    837,
                    838,
                    839,
                    840,
                    841,
                    1345,
                    1346,
                    845,
                    846,
                    849,
                    338,
                    850,
                    851,
                    852,
                    342,
                    853,
                    854,
                    855,
                    1368,
                    1369,
                    860,
                    1370,
                    1371,
                    1372,
                    864,
                    1373,
                    1374,
                    868,
                    1388,
                    877,
                    879,
                    883,
                    375,
                    376,
                    1404,
                    1405,
                    1409,
                    1298,
                    1411,
                    1428,
                    917,
                    918,
                    919,
                    920,
                    1429,
                    922,
                    1430,
                    924,
                    1433,
                    1434,
                    927,
                    1435,
                    1436,
                    1437,
                    1442,
                    1443,
                    1444,
                    1447,
                    1449,
                    1451,
                    945,
                    948,
                    950,
                    1462,
                    1467,
                    1468,
                    957,
                    446,
                    1469,
                    448,
                    960,
                    1471,
                    1472,
                    1473,
                    1474,
                    1476,
                    1477,
                    1483,
                    1485,
                    979,
                    982,
                    984,
                    985,
                    1499,
                    989,
                    487,
                    488,
                    489,
                    1515,
                    1517,
                    1521,
                    1526,
                    1527,
                    1530
                ],
                "ping_interval": [
                    1649,
                    130,
                    1375
                ],
                "self.ping_timeout": [
                    1337,
                    131,
                    604,
                    1340
                ],
                "ping_timeout": [
                    1376,
                    1650,
                    131
                ],
                "self.max_message_size": [
                    132,
                    605
                ],
                "max_message_size": [
                    1377,
                    1651,
                    132,
                    774
                ],
                "self.compression_options": [
                    133
                ],
                "compression_options": [
                    737,
                    738,
                    1378,
                    133,
                    742,
                    1031,
                    744,
                    747,
                    1036,
                    1008,
                    1648,
                    1394
                ],
                "tornado.web.RequestHandler": [
                    136
                ],
                "tornado.web": [
                    136,
                    220,
                    740
                ],
                "tornado": [
                    740,
                    136,
                    341,
                    1081,
                    220
                ],
                "tornado.web.Application": [
                    220
                ],
                "httputil.HTTPServerRequest": [
                    221
                ],
                "httputil": [
                    705,
                    963,
                    1638,
                    967,
                    937,
                    971,
                    1457,
                    1458,
                    1460,
                    221
                ],
                "__init__": [
                    224,
                    1405
                ],
                "super": [
                    224,
                    587,
                    591,
                    1462,
                    1405,
                    1437
                ],
                "WebSocketHandler": [
                    224,
                    866,
                    681,
                    906,
                    587,
                    591,
                    911,
                    886
                ],
                "application": [
                    224
                ],
                "request": [
                    224,
                    1635,
                    1381,
                    1638,
                    1383,
                    1384,
                    1640,
                    1641,
                    1643,
                    1646,
                    1393,
                    1400,
                    1407
                ],
                "kwargs": [
                    224,
                    233,
                    649,
                    591
                ],
                "self.ws_connection": [
                    448,
                    225,
                    567,
                    487,
                    488,
                    489,
                    338,
                    276,
                    277,
                    278,
                    342,
                    376,
                    565,
                    566,
                    446,
                    375
                ],
                "self.close_code": [
                    576,
                    226,
                    1442,
                    1238,
                    854,
                    1242,
                    1372,
                    1117
                ],
                "self.close_reason": [
                    577,
                    227,
                    1443,
                    855,
                    1240,
                    1373,
                    1117
                ],
                "self.stream": [
                    1283,
                    1284,
                    1294,
                    657,
                    658,
                    668,
                    669,
                    1071,
                    561,
                    562,
                    948,
                    590,
                    597,
                    1120,
                    228,
                    1261,
                    636,
                    1277,
                    1279
                ],
                "self._on_close_called": [
                    568,
                    569,
                    586,
                    229
                ],
                "self.open_args": [
                    232
                ],
                "args": [
                    232,
                    649,
                    591
                ],
                "self.open_kwargs": [
                    233
                ],
                "lower": [
                    248,
                    977,
                    978,
                    236
                ],
                "self.request.headers.get": [
                    262,
                    264,
                    236,
                    600,
                    542
                ],
                "self.request.headers": [
                    261,
                    262,
                    264,
                    236,
                    246,
                    600,
                    542
                ],
                "self.request": [
                    261,
                    262,
                    264,
                    236,
                    246,
                    600,
                    542
                ],
                "self.set_status": [
                    280,
                    251,
                    237,
                    270
                ],
                "log_msg": [
                    871,
                    872,
                    873,
                    238,
                    239,
                    240,
                    271,
                    272,
                    273,
                    252,
                    253,
                    254
                ],
                "self.finish": [
                    272,
                    253,
                    239
                ],
                "gen_log.debug": [
                    873,
                    240,
                    273,
                    882,
                    254
                ],
                "gen_log": [
                    873,
                    240,
                    273,
                    882,
                    254
                ],
                "headers": [
                    1463,
                    965,
                    977,
                    978,
                    980,
                    246,
                    982,
                    248,
                    989,
                    1471
                ],
                "connection": [
                    250,
                    247
                ],
                "map": [
                    893,
                    247
                ],
                "s.strip": [
                    248,
                    914
                ],
                "s": [
                    248,
                    914
                ],
                "split": [
                    248
                ],
                "headers.get": [
                    248,
                    989,
                    965
                ],
                "origin": [
                    545,
                    262,
                    264,
                    269,
                    538,
                    539,
                    540
                ],
                "self.check_origin": [
                    269
                ],
                "self.get_websocket_protocol": [
                    1472,
                    276
                ],
                "self.ws_connection.accept_connection": [
                    278
                ],
                "self.set_header": [
                    281
                ],
                "stream": [
                    819,
                    283
                ],
                "self.settings.get": [
                    299,
                    291,
                    310
                ],
                "self.settings": [
                    299,
                    291,
                    310
                ],
                "property": [
                    293,
                    301,
                    1296,
                    369,
                    690,
                    1303,
                    1560,
                    858,
                    285
                ],
                "bool": [
                    769,
                    547,
                    677,
                    1287,
                    491,
                    686,
                    1136,
                    721,
                    1041,
                    1074,
                    1488,
                    1142,
                    824,
                    315
                ],
                "self.ws_connection.is_closing": [
                    338,
                    446
                ],
                "WebSocketClosedError": [
                    1096,
                    1548,
                    1102,
                    339,
                    447
                ],
                "isinstance": [
                    1633,
                    340,
                    1460,
                    1108,
                    1082
                ],
                "message": [
                    1527,
                    1094,
                    1521,
                    1530,
                    340,
                    341,
                    342,
                    1499,
                    1081,
                    1082,
                    1083,
                    1086
                ],
                "dict": [
                    1000,
                    340
                ],
                "tornado.escape.json_encode": [
                    341
                ],
                "tornado.escape": [
                    1081,
                    341
                ],
                "self.ws_connection.write_message": [
                    342
                ],
                "binary": [
                    1499,
                    1077,
                    342
                ],
                "List": [
                    344,
                    1588,
                    964,
                    1366
                ],
                "self.ws_connection.selected_subprotocol": [
                    376
                ],
                "Awaitable": [
                    418,
                    1520,
                    402,
                    1525,
                    1503
                ],
                "NotImplementedError": [
                    674,
                    707,
                    678,
                    711,
                    682,
                    427,
                    715,
                    688,
                    693,
                    697
                ],
                "data": [
                    1153,
                    1154,
                    1156,
                    1157,
                    1546,
                    1549,
                    1169,
                    1043,
                    1172,
                    797,
                    1188,
                    1191,
                    1068,
                    1069,
                    1200,
                    1203,
                    445,
                    1215,
                    448,
                    1223,
                    1225,
                    1232,
                    1233,
                    1108,
                    1109,
                    1237,
                    1238,
                    1239,
                    1240,
                    1246,
                    1120,
                    1249,
                    1122,
                    1253,
                    1126,
                    1127,
                    761,
                    762,
                    763
                ],
                "utf8": [
                    1269,
                    1546,
                    445,
                    902
                ],
                "self.ws_connection.write_ping": [
                    448
                ],
                "self.ws_connection.close": [
                    488
                ],
                "code": [
                    488,
                    1262,
                    1263,
                    1264,
                    1267,
                    1429
                ],
                "reason": [
                    488,
                    1262,
                    1268,
                    1429,
                    1269
                ],
                "parsed_origin": [
                    538,
                    539
                ],
                "urlparse": [
                    538
                ],
                "parsed_origin.netloc": [
                    539
                ],
                "origin.lower": [
                    540
                ],
                "host": [
                    545,
                    542
                ],
                "self.stream.set_nodelay": [
                    562
                ],
                "value": [
                    864,
                    562,
                    1576,
                    1575
                ],
                "self.ws_connection.on_connection_close": [
                    566
                ],
                "self.on_close": [
                    570
                ],
                "self._break_cycles": [
                    571
                ],
                "close_code": [
                    576,
                    1442
                ],
                "close_reason": [
                    577,
                    1443
                ],
                "self.on_connection_close": [
                    578,
                    1444
                ],
                "self.get_status": [
                    586
                ],
                "_break_cycles": [
                    587
                ],
                "send_error": [
                    591
                ],
                "self.stream.close": [
                    597,
                    669,
                    1279
                ],
                "websocket_version": [
                    600,
                    601
                ],
                "params": [
                    608,
                    602,
                    829,
                    838
                ],
                "_WebSocketParams": [
                    825,
                    602,
                    1374
                ],
                "self.get_compression_options": [
                    606
                ],
                "WebSocketProtocol13": [
                    608,
                    907,
                    1558
                ],
                "method": [
                    613,
                    622
                ],
                "setattr": [
                    622
                ],
                "_raise_not_supported_for_websockets": [
                    622
                ],
                "self.detach": [
                    623
                ],
                "IOStream": [
                    611
                ],
                "RuntimeError": [
                    627
                ],
                "abc.ABC": [
                    630
                ],
                "abc": [
                    672,
                    676,
                    709,
                    680,
                    713,
                    684,
                    691,
                    630,
                    695,
                    703
                ],
                "self.handler": [
                    1249,
                    1253,
                    651,
                    1229,
                    1233,
                    635,
                    1117
                ],
                "handler": [
                    908,
                    912,
                    917,
                    920,
                    922,
                    935,
                    941,
                    942,
                    943,
                    944,
                    945,
                    946,
                    948,
                    952,
                    827,
                    956,
                    868,
                    870,
                    872,
                    877,
                    635,
                    893
                ],
                "self.client_terminated": [
                    1209,
                    1294,
                    1236,
                    1113,
                    666,
                    1275,
                    637
                ],
                "self.server_terminated": [
                    1260,
                    1294,
                    1274,
                    667,
                    638
                ],
                "Callable": [
                    641,
                    1581,
                    1583,
                    1361,
                    1502
                ],
                "result": [
                    801,
                    649,
                    655,
                    656,
                    658,
                    659,
                    796
                ],
                "callback": [
                    649,
                    1516,
                    1517,
                    1654,
                    1655
                ],
                "self.handler.log_exception": [
                    651
                ],
                "sys.exc_info": [
                    651,
                    956
                ],
                "sys": [
                    651,
                    956
                ],
                "self._abort": [
                    1248,
                    1186,
                    1218,
                    1284,
                    1255,
                    1163,
                    652,
                    1196,
                    1227,
                    879,
                    1148,
                    883,
                    1140,
                    662,
                    1181,
                    1273,
                    1116,
                    957
                ],
                "gen.convert_yielded": [
                    656
                ],
                "gen": [
                    656
                ],
                "self.stream.io_loop.add_future": [
                    658
                ],
                "self.stream.io_loop": [
                    658,
                    1283,
                    1284,
                    1277
                ],
                "f.result": [
                    658
                ],
                "f": [
                    658,
                    893
                ],
                "self.close": [
                    1217,
                    1162,
                    670,
                    1242,
                    1342
                ],
                "abc.abstractmethod": [
                    672,
                    676,
                    709,
                    680,
                    713,
                    684,
                    691,
                    695,
                    703
                ],
                "httputil.HTTPHeaders": [
                    705,
                    963,
                    1638,
                    971,
                    1458
                ],
                "max_wbits": [
                    775,
                    776,
                    777,
                    780,
                    783,
                    725,
                    726,
                    728,
                    731,
                    734
                ],
                "zlib.MAX_WBITS": [
                    776,
                    777,
                    781,
                    1005,
                    726,
                    728,
                    732
                ],
                "zlib": [
                    776,
                    777,
                    781,
                    1005,
                    792,
                    755,
                    756,
                    726,
                    728,
                    761,
                    732
                ],
                "ValueError": [
                    1028,
                    869,
                    778,
                    881,
                    1048,
                    729,
                    1050,
                    987,
                    894
                ],
                "self._max_wbits": [
                    792,
                    756,
                    734,
                    783
                ],
                "self._compression_level": [
                    740,
                    756,
                    742
                ],
                "tornado.web.GZipContentEncoding.GZIP_LEVEL": [
                    740
                ],
                "tornado.web.GZipContentEncoding": [
                    740
                ],
                "self._mem_level": [
                    745,
                    747,
                    756
                ],
                "persistent": [
                    784,
                    749
                ],
                "self._compressor": [
                    1030,
                    840,
                    750,
                    752,
                    760,
                    1085,
                    1086
                ],
                "self._create_compressor": [
                    760,
                    750
                ],
                "zlib.compressobj": [
                    755
                ],
                "zlib.DEFLATED": [
                    756
                ],
                "compressor": [
                    760,
                    761
                ],
                "compressor.compress": [
                    761
                ],
                "compressor.flush": [
                    761
                ],
                "zlib.Z_SYNC_FLUSH": [
                    761
                ],
                "data.endswith": [
                    762
                ],
                "self._max_message_size": [
                    797,
                    774
                ],
                "self._decompressor": [
                    839,
                    1033,
                    1132,
                    785,
                    789,
                    795,
                    1213,
                    1215
                ],
                "self._create_decompressor": [
                    786,
                    795
                ],
                "zlib.decompressobj": [
                    792
                ],
                "decompressor": [
                    795,
                    796,
                    799
                ],
                "decompressor.decompress": [
                    796
                ],
                "decompressor.unconsumed_tail": [
                    799
                ],
                "_DecompressTooLargeError": [
                    800,
                    1216
                ],
                "WebSocketProtocol": [
                    827,
                    804,
                    1557
                ],
                "FIN": [
                    812
                ],
                "RSV1": [
                    816,
                    813
                ],
                "RSV2": [
                    816,
                    814
                ],
                "RSV3": [
                    816,
                    815
                ],
                "RSV_MASK": [
                    816
                ],
                "OPCODE_MASK": [
                    817
                ],
                "WebSocketProtocol.__init__": [
                    827
                ],
                "self.mask_outgoing": [
                    1056,
                    1066,
                    828
                ],
                "mask_outgoing": [
                    828
                ],
                "self.params": [
                    1161,
                    1034,
                    1298,
                    1558,
                    1305,
                    829,
                    1374
                ],
                "self._final_frame": [
                    830
                ],
                "self._frame_opcode": [
                    831
                ],
                "self._masked_frame": [
                    832
                ],
                "self._frame_mask": [
                    1168,
                    833,
                    1171,
                    1172
                ],
                "self._frame_length": [
                    834,
                    1151
                ],
                "self._fragmented_message_buffer": [
                    1184,
                    835,
                    1188,
                    1159,
                    1160,
                    1191,
                    1192,
                    1194,
                    1200
                ],
                "self._fragmented_message_opcode": [
                    836,
                    1190,
                    1199
                ],
                "self._waiting": [
                    1280,
                    1283,
                    837,
                    1276,
                    1277,
                    1278
                ],
                "self._compression_options": [
                    984,
                    924,
                    838,
                    927
                ],
                "params.compression_options": [
                    838
                ],
                "self._frame_compressed": [
                    1136,
                    841,
                    1212
                ],
                "self._message_bytes_in": [
                    1232,
                    845,
                    1223
                ],
                "self._message_bytes_out": [
                    1083,
                    846
                ],
                "self._wire_bytes_in": [
                    849,
                    1121
                ],
                "self._wire_bytes_out": [
                    850,
                    1070
                ],
                "self.ping_callback": [
                    1316,
                    1319,
                    1326,
                    1327,
                    851
                ],
                "self.last_ping": [
                    1346,
                    1315,
                    852,
                    1335
                ],
                "self.last_pong": [
                    1315,
                    1252,
                    853,
                    1334
                ],
                "self._selected_subprotocol": [
                    864,
                    860
                ],
                "selected_subprotocol.setter": [
                    862
                ],
                "selected_subprotocol": [
                    862
                ],
                "self._handle_websocket_headers": [
                    868
                ],
                "handler.set_status": [
                    942,
                    870
                ],
                "handler.finish": [
                    872,
                    946
                ],
                "self._accept_connection": [
                    877
                ],
                "asyncio.CancelledError": [
                    878
                ],
                "asyncio": [
                    1104,
                    1517,
                    878
                ],
                "fields": [
                    892,
                    893
                ],
                "all": [
                    893
                ],
                "handler.request.headers.get": [
                    912,
                    908,
                    893
                ],
                "handler.request.headers": [
                    912,
                    922,
                    908,
                    893
                ],
                "handler.request": [
                    912,
                    922,
                    908,
                    893
                ],
                "sha1": [
                    904,
                    901,
                    902,
                    903
                ],
                "hashlib.sha1": [
                    901
                ],
                "hashlib": [
                    901
                ],
                "sha1.update": [
                    902,
                    903
                ],
                "key": [
                    1026,
                    1027,
                    1028,
                    902,
                    979
                ],
                "native_str": [
                    904
                ],
                "base64.b64encode": [
                    904,
                    1370
                ],
                "base64": [
                    904,
                    1370
                ],
                "sha1.digest": [
                    904
                ],
                "staticmethod": [
                    896
                ],
                "WebSocketProtocol13.compute_accept_value": [
                    907
                ],
                "cast": [
                    1641,
                    908
                ],
                "subprotocol_header": [
                    912,
                    913,
                    914
                ],
                "subprotocols": [
                    1392,
                    1393,
                    914,
                    916,
                    917,
                    1652,
                    919
                ],
                "subprotocol_header.split": [
                    914
                ],
                "self.selected_subprotocol": [
                    917,
                    918,
                    919,
                    920,
                    989
                ],
                "handler.select_subprotocol": [
                    917
                ],
                "handler.set_header": [
                    935,
                    943,
                    944,
                    945,
                    920
                ],
                "extensions": [
                    965,
                    966,
                    967,
                    982,
                    983,
                    922,
                    923
                ],
                "self._parse_extensions_header": [
                    922,
                    982
                ],
                "ext": [
                    929,
                    930,
                    934,
                    987,
                    937,
                    983,
                    984,
                    985,
                    923,
                    924,
                    927
                ],
                "self._create_compressors": [
                    985,
                    927
                ],
                "httputil._encode_header": [
                    937
                ],
                "handler.clear_header": [
                    941
                ],
                "self._challenge_response": [
                    945
                ],
                "handler._detach_stream": [
                    948
                ],
                "self.start_pinging": [
                    950
                ],
                "open_result": [
                    952,
                    953,
                    954
                ],
                "handler.open": [
                    952
                ],
                "handler.open_args": [
                    952
                ],
                "handler.open_kwargs": [
                    952
                ],
                "handler.log_exception": [
                    956
                ],
                "self._receive_frame_loop": [
                    960
                ],
                "httputil._parse_header": [
                    967
                ],
                "e.strip": [
                    967
                ],
                "e": [
                    967
                ],
                "extensions.split": [
                    967
                ],
                "Tuple": [
                    964
                ],
                "accept": [
                    979,
                    980
                ],
                "self.compute_accept_value": [
                    979
                ],
                "options": [
                    1000,
                    1005,
                    1007,
                    1008,
                    1009
                ],
                "side": [
                    1001,
                    1003,
                    1029,
                    1031
                ],
                "agreed_parameters": [
                    1026,
                    1031,
                    1001,
                    1003,
                    1036
                ],
                "wbits_header": [
                    1003,
                    1004,
                    1007
                ],
                "agreed_parameters.get": [
                    1003
                ],
                "allowed_keys": [
                    1018,
                    1027
                ],
                "set": [
                    1018
                ],
                "other_side": [
                    1036,
                    1029
                ],
                "_PerMessageDeflateCompressor": [
                    1030
                ],
                "self._get_compressor_options": [
                    1035,
                    1031
                ],
                "_PerMessageDeflateDecompressor": [
                    1033
                ],
                "self.params.max_message_size": [
                    1161,
                    1034
                ],
                "data_len": [
                    1060,
                    1061,
                    1062,
                    1063,
                    1065,
                    1043,
                    1049
                ],
                "len": [
                    1223,
                    1160,
                    1070,
                    1232,
                    1043,
                    1237,
                    1239,
                    1083
                ],
                "opcode": [
                    1183,
                    1250,
                    1221,
                    1094,
                    1190,
                    1130,
                    1131,
                    1132,
                    1230,
                    1199,
                    1234,
                    1203,
                    1044,
                    1078,
                    1080,
                    1243,
                    1055
                ],
                "fin": [
                    1051,
                    1047
                ],
                "finbit": [
                    1052,
                    1054,
                    1055
                ],
                "self.FIN": [
                    1128,
                    1052
                ],
                "frame": [
                    1061,
                    1063,
                    1065,
                    1069,
                    1070,
                    1071,
                    1055
                ],
                "struct.pack": [
                    1061,
                    1063,
                    1065,
                    1267,
                    1055
                ],
                "struct": [
                    1154,
                    1061,
                    1157,
                    1127,
                    1063,
                    1065,
                    1267,
                    1238,
                    1055
                ],
                "flags": [
                    1084,
                    1087,
                    1094,
                    1055
                ],
                "mask_bit": [
                    1057,
                    1059,
                    1061,
                    1063,
                    1065
                ],
                "mask": [
                    1067,
                    1068
                ],
                "os.urandom": [
                    1370,
                    1067
                ],
                "os": [
                    1370,
                    1067
                ],
                "_websocket_mask": [
                    1172,
                    1068
                ],
                "self.stream.write": [
                    1071
                ],
                "tornado.escape.utf8": [
                    1081
                ],
                "self._compressor.compress": [
                    1086
                ],
                "self.RSV1": [
                    1136,
                    1137,
                    1087
                ],
                "fut": [
                    1100,
                    1094
                ],
                "self._write_frame": [
                    1246,
                    1109,
                    1094,
                    1271
                ],
                "StreamClosedError": [
                    1095,
                    1101,
                    1272,
                    1434,
                    1115,
                    1247
                ],
                "asyncio.ensure_future": [
                    1104,
                    1517
                ],
                "wrapper": [
                    1104
                ],
                "self._receive_frame": [
                    1114
                ],
                "self.handler.on_ws_connection_close": [
                    1117
                ],
                "self.stream.read_bytes": [
                    1120
                ],
                "n": [
                    1120,
                    1121
                ],
                "self._read_bytes": [
                    1153,
                    1156,
                    1126,
                    1168,
                    1169
                ],
                "header": [
                    1128,
                    1129,
                    1130,
                    1127
                ],
                "mask_payloadlen": [
                    1143,
                    1142,
                    1127
                ],
                "struct.unpack": [
                    1154,
                    1157,
                    1238,
                    1127
                ],
                "is_final_frame": [
                    1189,
                    1128,
                    1198,
                    1202,
                    1179
                ],
                "reserved_bits": [
                    1136,
                    1129,
                    1138,
                    1137
                ],
                "self.RSV_MASK": [
                    1129
                ],
                "self.OPCODE_MASK": [
                    1130
                ],
                "opcode_is_control": [
                    1146,
                    1131,
                    1175
                ],
                "is_masked": [
                    1170,
                    1142,
                    1167
                ],
                "payloadlen": [
                    1152,
                    1154,
                    1155,
                    1157,
                    1158,
                    1169,
                    1143,
                    1146,
                    1150,
                    1151
                ],
                "new_len": [
                    1160,
                    1161,
                    1158
                ],
                "handled_future": [
                    1203,
                    1204,
                    1205
                ],
                "self._handle_message": [
                    1203
                ],
                "self._decompressor.decompress": [
                    1215
                ],
                "decoded": [
                    1225,
                    1229
                ],
                "data.decode": [
                    1225
                ],
                "UnicodeDecodeError": [
                    1226
                ],
                "self._run_callback": [
                    1233,
                    1249,
                    1229,
                    1253
                ],
                "self.handler.on_message": [
                    1233,
                    1229
                ],
                "to_unicode": [
                    1240
                ],
                "self.handler.on_ping": [
                    1249
                ],
                "time": [
                    1315,
                    1252,
                    1333
                ],
                "IOLoop.current": [
                    1315,
                    1476,
                    1252,
                    1333,
                    1655
                ],
                "IOLoop": [
                    1315,
                    1476,
                    1252,
                    1333,
                    1655
                ],
                "self.handler.on_pong": [
                    1253
                ],
                "self.stream.closed": [
                    1261,
                    1294
                ],
                "close_data": [
                    1265,
                    1267,
                    1269,
                    1271
                ],
                "self.stream.io_loop.remove_timeout": [
                    1277
                ],
                "self.stream.io_loop.add_timeout": [
                    1283
                ],
                "self.stream.io_loop.time": [
                    1284
                ],
                "interval": [
                    1298,
                    1299,
                    1300
                ],
                "self.params.ping_interval": [
                    1298
                ],
                "timeout": [
                    1305,
                    1306,
                    1307
                ],
                "self.params.ping_timeout": [
                    1305
                ],
                "max": [
                    1309
                ],
                "PeriodicCallback": [
                    1316
                ],
                "self.periodic_ping": [
                    1317
                ],
                "self.ping_callback.start": [
                    1319
                ],
                "self.is_closing": [
                    1326
                ],
                "self.ping_callback.stop": [
                    1327
                ],
                "now": [
                    1346,
                    1333,
                    1334,
                    1335
                ],
                "since_last_pong": [
                    1340,
                    1334
                ],
                "since_last_ping": [
                    1339,
                    1335
                ],
                "self.write_ping": [
                    1345
                ],
                "simple_httpclient._HTTPConnection": [
                    1349
                ],
                "simple_httpclient": [
                    1349
                ],
                "protocol": [
                    1356
                ],
                "httpclient.HTTPRequest": [
                    1633,
                    1640,
                    1642,
                    1643,
                    1580,
                    1360
                ],
                "httpclient": [
                    1633,
                    1446,
                    1640,
                    1642,
                    1643,
                    1580,
                    1360
                ],
                "self.connect_future": [
                    1447,
                    1449,
                    1451,
                    1485,
                    1368,
                    1433,
                    1434
                ],
                "Future": [
                    1368
                ],
                "self.read_queue": [
                    1369,
                    1530,
                    1515
                ],
                "Queue": [
                    1369
                ],
                "self.key": [
                    1473,
                    1370,
                    1388
                ],
                "self._on_message_callback": [
                    1371,
                    1526,
                    1527
                ],
                "on_message_callback": [
                    1371,
                    1647
                ],
                "scheme": [
                    1381,
                    1382,
                    1383
                ],
                "sep": [
                    1381,
                    1383
                ],
                "rest": [
                    1381,
                    1383
                ],
                "request.url.partition": [
                    1381
                ],
                "request.url": [
                    1381,
                    1383
                ],
                "request.headers.update": [
                    1384
                ],
                "request.headers": [
                    1384,
                    1393,
                    1400,
                    1638
                ],
                "join": [
                    1393
                ],
                "self.tcp_client": [
                    1436,
                    1411,
                    1404
                ],
                "TCPClient": [
                    1404
                ],
                "WebSocketClientConnection": [
                    1645,
                    1462,
                    1405,
                    1437
                ],
                "self._on_http_response": [
                    1409
                ],
                "self.protocol": [
                    1472,
                    1473,
                    1474,
                    1476,
                    1477,
                    1547,
                    1549,
                    1428,
                    1429,
                    1430,
                    1499,
                    1566
                ],
                "self.protocol.close": [
                    1429
                ],
                "self.connect_future.done": [
                    1433,
                    1447
                ],
                "self.connect_future.set_exception": [
                    1449,
                    1434,
                    1451
                ],
                "self._on_message": [
                    1521,
                    1435
                ],
                "self.tcp_client.close": [
                    1436
                ],
                "on_connection_close": [
                    1437
                ],
                "httpclient.HTTPResponse": [
                    1446
                ],
                "response.error": [
                    1448,
                    1449
                ],
                "response": [
                    1448,
                    1449
                ],
                "httputil.RequestStartLine": [
                    1457
                ],
                "httputil.ResponseStartLine": [
                    1457,
                    1460
                ],
                "start_line": [
                    1460,
                    1461,
                    1463
                ],
                "start_line.code": [
                    1461
                ],
                "headers_received": [
                    1462
                ],
                "self._timeout": [
                    1467,
                    1468,
                    1469
                ],
                "self.io_loop.remove_timeout": [
                    1468
                ],
                "self.io_loop": [
                    1468,
                    1517
                ],
                "self.headers": [
                    1473,
                    1471
                ],
                "self.protocol._process_server_headers": [
                    1473
                ],
                "self.protocol.stream": [
                    1474
                ],
                "self.connection.detach": [
                    1474
                ],
                "self.connection": [
                    1474
                ],
                "add_callback": [
                    1476
                ],
                "self.protocol._receive_frame_loop": [
                    1476
                ],
                "self.protocol.start_pinging": [
                    1477
                ],
                "self.final_callback": [
                    1483
                ],
                "future_set_result_unless_cancelled": [
                    1485
                ],
                "self.protocol.write_message": [
                    1499
                ],
                "awaitable": [
                    1515,
                    1517,
                    1518
                ],
                "self.read_queue.get": [
                    1515
                ],
                "self.io_loop.add_future": [
                    1517
                ],
                "self.read_queue.put": [
                    1530
                ],
                "self.protocol.write_ping": [
                    1549
                ],
                "self.protocol.selected_subprotocol": [
                    1566
                ],
                "typ": [
                    1576,
                    1574
                ],
                "app_log.error": [
                    1576
                ],
                "app_log": [
                    1576
                ],
                "tb": [
                    1576
                ],
                "url": [
                    1640,
                    1633,
                    1635
                ],
                "connect_timeout": [
                    1640,
                    1634
                ],
                "httpclient._RequestProxy": [
                    1643
                ],
                "httpclient.HTTPRequest._DEFAULTS": [
                    1643
                ],
                "conn": [
                    1656,
                    1645,
                    1655
                ],
                "add_future": [
                    1655
                ],
                "conn.connect_future": [
                    1656,
                    1655
                ]
            },
            "filtered_variables_in_file": {
                "TYPE_CHECKING": [
                    57
                ],
                "Protocol": [
                    75,
                    69,
                    62
                ],
                "unconsumed_tail": [
                    70
                ],
                "Union": [
                    705,
                    418,
                    897,
                    971,
                    1580,
                    429,
                    686,
                    1583,
                    1488,
                    1361,
                    1074,
                    1457,
                    84,
                    1520,
                    1524,
                    315,
                    1503
                ],
                "Optional": [
                    770,
                    1297,
                    402,
                    1304,
                    1561,
                    286,
                    418,
                    1571,
                    1572,
                    294,
                    692,
                    722,
                    84,
                    1366,
                    599,
                    344,
                    859,
                    863,
                    96,
                    97,
                    95,
                    1520,
                    370,
                    1525,
                    378
                ],
                "Type": [
                    95
                ],
                "TracebackType": [
                    97,
                    1572
                ],
                "_default_max_message_size": [
                    102,
                    1587,
                    1365,
                    311,
                    127
                ],
                "WebSocketError": [
                    1452,
                    109
                ],
                "Dict": [
                    128,
                    994,
                    995,
                    772,
                    964,
                    996,
                    1584,
                    1362,
                    723,
                    1014,
                    1015,
                    378,
                    315
                ],
                "Any": [
                    128,
                    641,
                    994,
                    995,
                    772,
                    996,
                    231,
                    589,
                    1584,
                    626,
                    723,
                    1362,
                    1014,
                    1015,
                    378,
                    315,
                    222
                ],
                "self.ping_interval": [
                    1313,
                    130,
                    1314,
                    1317,
                    1339,
                    1336,
                    603,
                    1308,
                    1309
                ],
                "self": [
                    1030,
                    1031,
                    1033,
                    1034,
                    1035,
                    1547,
                    1549,
                    1558,
                    1052,
                    542,
                    1566,
                    1056,
                    1066,
                    1070,
                    1071,
                    561,
                    562,
                    565,
                    566,
                    567,
                    568,
                    569,
                    570,
                    571,
                    1083,
                    1085,
                    1086,
                    1087,
                    576,
                    577,
                    578,
                    1094,
                    586,
                    587,
                    590,
                    591,
                    1339,
                    597,
                    1109,
                    1340,
                    600,
                    1113,
                    1114,
                    603,
                    604,
                    605,
                    606,
                    1116,
                    608,
                    1117,
                    1120,
                    1121,
                    1342,
                    1126,
                    1128,
                    1129,
                    1130,
                    1132,
                    622,
                    623,
                    1136,
                    1137,
                    1140,
                    635,
                    636,
                    637,
                    638,
                    1148,
                    1151,
                    1153,
                    130,
                    131,
                    132,
                    133,
                    1156,
                    1159,
                    1160,
                    1161,
                    1162,
                    651,
                    652,
                    1163,
                    1248,
                    1249,
                    1168,
                    657,
                    658,
                    1169,
                    1171,
                    1172,
                    662,
                    666,
                    667,
                    668,
                    669,
                    670,
                    1181,
                    1184,
                    1252,
                    1186,
                    1253,
                    1188,
                    1190,
                    1191,
                    1192,
                    1194,
                    1255,
                    1196,
                    1199,
                    1200,
                    1203,
                    1209,
                    1212,
                    1213,
                    1215,
                    1217,
                    1218,
                    1223,
                    1227,
                    1229,
                    1232,
                    1233,
                    1236,
                    1238,
                    1240,
                    1242,
                    734,
                    1246,
                    224,
                    225,
                    226,
                    227,
                    228,
                    229,
                    740,
                    742,
                    232,
                    233,
                    745,
                    747,
                    236,
                    237,
                    750,
                    239,
                    752,
                    1260,
                    1261,
                    756,
                    246,
                    1271,
                    760,
                    1273,
                    1274,
                    251,
                    1275,
                    253,
                    1276,
                    1277,
                    1278,
                    1279,
                    1280,
                    1283,
                    1284,
                    261,
                    262,
                    774,
                    264,
                    269,
                    270,
                    783,
                    272,
                    785,
                    786,
                    1294,
                    276,
                    277,
                    278,
                    789,
                    280,
                    281,
                    792,
                    795,
                    1305,
                    797,
                    1308,
                    1309,
                    1313,
                    1314,
                    291,
                    1315,
                    1316,
                    1317,
                    1319,
                    299,
                    1326,
                    1327,
                    310,
                    1334,
                    1335,
                    1336,
                    1337,
                    827,
                    828,
                    829,
                    830,
                    831,
                    832,
                    833,
                    834,
                    835,
                    836,
                    837,
                    838,
                    839,
                    840,
                    841,
                    1345,
                    1346,
                    845,
                    846,
                    849,
                    338,
                    850,
                    851,
                    852,
                    342,
                    853,
                    854,
                    855,
                    1368,
                    1369,
                    860,
                    1370,
                    1371,
                    1372,
                    864,
                    1373,
                    1374,
                    868,
                    1388,
                    877,
                    879,
                    883,
                    375,
                    376,
                    1404,
                    1405,
                    1409,
                    1298,
                    1411,
                    1428,
                    917,
                    918,
                    919,
                    920,
                    1429,
                    922,
                    1430,
                    924,
                    1433,
                    1434,
                    927,
                    1435,
                    1436,
                    1437,
                    1442,
                    1443,
                    1444,
                    1447,
                    1449,
                    1451,
                    945,
                    948,
                    950,
                    1462,
                    1467,
                    1468,
                    957,
                    446,
                    1469,
                    448,
                    960,
                    1471,
                    1472,
                    1473,
                    1474,
                    1476,
                    1477,
                    1483,
                    1485,
                    979,
                    982,
                    984,
                    985,
                    1499,
                    989,
                    487,
                    488,
                    489,
                    1515,
                    1517,
                    1521,
                    1526,
                    1527,
                    1530
                ],
                "ping_interval": [
                    1649,
                    130,
                    1375
                ],
                "self.ping_timeout": [
                    1337,
                    131,
                    604,
                    1340
                ],
                "ping_timeout": [
                    1376,
                    1650,
                    131
                ],
                "self.max_message_size": [
                    132,
                    605
                ],
                "max_message_size": [
                    1377,
                    1651,
                    132,
                    774
                ],
                "self.compression_options": [
                    133
                ],
                "compression_options": [
                    737,
                    738,
                    1378,
                    133,
                    742,
                    1031,
                    744,
                    747,
                    1036,
                    1008,
                    1648,
                    1394
                ],
                "tornado.web.RequestHandler": [
                    136
                ],
                "tornado.web": [
                    136,
                    220,
                    740
                ],
                "tornado": [
                    740,
                    136,
                    341,
                    1081,
                    220
                ],
                "tornado.web.Application": [
                    220
                ],
                "httputil.HTTPServerRequest": [
                    221
                ],
                "httputil": [
                    705,
                    963,
                    1638,
                    967,
                    937,
                    971,
                    1457,
                    1458,
                    1460,
                    221
                ],
                "__init__": [
                    224,
                    1405
                ],
                "WebSocketHandler": [
                    224,
                    866,
                    681,
                    906,
                    587,
                    591,
                    911,
                    886
                ],
                "application": [
                    224
                ],
                "request": [
                    224,
                    1635,
                    1381,
                    1638,
                    1383,
                    1384,
                    1640,
                    1641,
                    1643,
                    1646,
                    1393,
                    1400,
                    1407
                ],
                "kwargs": [
                    224,
                    233,
                    649,
                    591
                ],
                "self.ws_connection": [
                    448,
                    225,
                    567,
                    487,
                    488,
                    489,
                    338,
                    276,
                    277,
                    278,
                    342,
                    376,
                    565,
                    566,
                    446,
                    375
                ],
                "self.close_code": [
                    576,
                    226,
                    1442,
                    1238,
                    854,
                    1242,
                    1372,
                    1117
                ],
                "self.close_reason": [
                    577,
                    227,
                    1443,
                    855,
                    1240,
                    1373,
                    1117
                ],
                "self.stream": [
                    1283,
                    1284,
                    1294,
                    657,
                    658,
                    668,
                    669,
                    1071,
                    561,
                    562,
                    948,
                    590,
                    597,
                    1120,
                    228,
                    1261,
                    636,
                    1277,
                    1279
                ],
                "self._on_close_called": [
                    568,
                    569,
                    586,
                    229
                ],
                "self.open_args": [
                    232
                ],
                "args": [
                    232,
                    649,
                    591
                ],
                "self.open_kwargs": [
                    233
                ],
                "lower": [
                    248,
                    977,
                    978,
                    236
                ],
                "self.request.headers.get": [
                    262,
                    264,
                    236,
                    600,
                    542
                ],
                "self.request.headers": [
                    261,
                    262,
                    264,
                    236,
                    246,
                    600,
                    542
                ],
                "self.request": [
                    261,
                    262,
                    264,
                    236,
                    246,
                    600,
                    542
                ],
                "self.set_status": [
                    280,
                    251,
                    237,
                    270
                ],
                "log_msg": [
                    871,
                    872,
                    873,
                    238,
                    239,
                    240,
                    271,
                    272,
                    273,
                    252,
                    253,
                    254
                ],
                "self.finish": [
                    272,
                    253,
                    239
                ],
                "gen_log.debug": [
                    873,
                    240,
                    273,
                    882,
                    254
                ],
                "gen_log": [
                    873,
                    240,
                    273,
                    882,
                    254
                ],
                "headers": [
                    1463,
                    965,
                    977,
                    978,
                    980,
                    246,
                    982,
                    248,
                    989,
                    1471
                ],
                "connection": [
                    250,
                    247
                ],
                "s.strip": [
                    248,
                    914
                ],
                "s": [
                    248,
                    914
                ],
                "split": [
                    248
                ],
                "headers.get": [
                    248,
                    989,
                    965
                ],
                "origin": [
                    545,
                    262,
                    264,
                    269,
                    538,
                    539,
                    540
                ],
                "self.check_origin": [
                    269
                ],
                "self.get_websocket_protocol": [
                    1472,
                    276
                ],
                "self.ws_connection.accept_connection": [
                    278
                ],
                "self.set_header": [
                    281
                ],
                "stream": [
                    819,
                    283
                ],
                "self.settings.get": [
                    299,
                    291,
                    310
                ],
                "self.settings": [
                    299,
                    291,
                    310
                ],
                "self.ws_connection.is_closing": [
                    338,
                    446
                ],
                "WebSocketClosedError": [
                    1096,
                    1548,
                    1102,
                    339,
                    447
                ],
                "message": [
                    1527,
                    1094,
                    1521,
                    1530,
                    340,
                    341,
                    342,
                    1499,
                    1081,
                    1082,
                    1083,
                    1086
                ],
                "tornado.escape.json_encode": [
                    341
                ],
                "tornado.escape": [
                    1081,
                    341
                ],
                "self.ws_connection.write_message": [
                    342
                ],
                "binary": [
                    1499,
                    1077,
                    342
                ],
                "List": [
                    344,
                    1588,
                    964,
                    1366
                ],
                "self.ws_connection.selected_subprotocol": [
                    376
                ],
                "Awaitable": [
                    418,
                    1520,
                    402,
                    1525,
                    1503
                ],
                "data": [
                    1153,
                    1154,
                    1156,
                    1157,
                    1546,
                    1549,
                    1169,
                    1043,
                    1172,
                    797,
                    1188,
                    1191,
                    1068,
                    1069,
                    1200,
                    1203,
                    445,
                    1215,
                    448,
                    1223,
                    1225,
                    1232,
                    1233,
                    1108,
                    1109,
                    1237,
                    1238,
                    1239,
                    1240,
                    1246,
                    1120,
                    1249,
                    1122,
                    1253,
                    1126,
                    1127,
                    761,
                    762,
                    763
                ],
                "utf8": [
                    1269,
                    1546,
                    445,
                    902
                ],
                "self.ws_connection.write_ping": [
                    448
                ],
                "self.ws_connection.close": [
                    488
                ],
                "code": [
                    488,
                    1262,
                    1263,
                    1264,
                    1267,
                    1429
                ],
                "reason": [
                    488,
                    1262,
                    1268,
                    1429,
                    1269
                ],
                "parsed_origin": [
                    538,
                    539
                ],
                "urlparse": [
                    538
                ],
                "parsed_origin.netloc": [
                    539
                ],
                "origin.lower": [
                    540
                ],
                "host": [
                    545,
                    542
                ],
                "self.stream.set_nodelay": [
                    562
                ],
                "value": [
                    864,
                    562,
                    1576,
                    1575
                ],
                "self.ws_connection.on_connection_close": [
                    566
                ],
                "self.on_close": [
                    570
                ],
                "self._break_cycles": [
                    571
                ],
                "close_code": [
                    576,
                    1442
                ],
                "close_reason": [
                    577,
                    1443
                ],
                "self.on_connection_close": [
                    578,
                    1444
                ],
                "self.get_status": [
                    586
                ],
                "_break_cycles": [
                    587
                ],
                "send_error": [
                    591
                ],
                "self.stream.close": [
                    597,
                    669,
                    1279
                ],
                "websocket_version": [
                    600,
                    601
                ],
                "params": [
                    608,
                    602,
                    829,
                    838
                ],
                "_WebSocketParams": [
                    825,
                    602,
                    1374
                ],
                "self.get_compression_options": [
                    606
                ],
                "WebSocketProtocol13": [
                    608,
                    907,
                    1558
                ],
                "method": [
                    613,
                    622
                ],
                "_raise_not_supported_for_websockets": [
                    622
                ],
                "self.detach": [
                    623
                ],
                "IOStream": [
                    611
                ],
                "abc.ABC": [
                    630
                ],
                "abc": [
                    672,
                    676,
                    709,
                    680,
                    713,
                    684,
                    691,
                    630,
                    695,
                    703
                ],
                "self.handler": [
                    1249,
                    1253,
                    651,
                    1229,
                    1233,
                    635,
                    1117
                ],
                "handler": [
                    908,
                    912,
                    917,
                    920,
                    922,
                    935,
                    941,
                    942,
                    943,
                    944,
                    945,
                    946,
                    948,
                    952,
                    827,
                    956,
                    868,
                    870,
                    872,
                    877,
                    635,
                    893
                ],
                "self.client_terminated": [
                    1209,
                    1294,
                    1236,
                    1113,
                    666,
                    1275,
                    637
                ],
                "self.server_terminated": [
                    1260,
                    1294,
                    1274,
                    667,
                    638
                ],
                "Callable": [
                    641,
                    1581,
                    1583,
                    1361,
                    1502
                ],
                "result": [
                    801,
                    649,
                    655,
                    656,
                    658,
                    659,
                    796
                ],
                "callback": [
                    649,
                    1516,
                    1517,
                    1654,
                    1655
                ],
                "self.handler.log_exception": [
                    651
                ],
                "sys.exc_info": [
                    651,
                    956
                ],
                "sys": [
                    651,
                    956
                ],
                "self._abort": [
                    1248,
                    1186,
                    1218,
                    1284,
                    1255,
                    1163,
                    652,
                    1196,
                    1227,
                    879,
                    1148,
                    883,
                    1140,
                    662,
                    1181,
                    1273,
                    1116,
                    957
                ],
                "gen.convert_yielded": [
                    656
                ],
                "gen": [
                    656
                ],
                "self.stream.io_loop.add_future": [
                    658
                ],
                "self.stream.io_loop": [
                    658,
                    1283,
                    1284,
                    1277
                ],
                "f.result": [
                    658
                ],
                "f": [
                    658,
                    893
                ],
                "self.close": [
                    1217,
                    1162,
                    670,
                    1242,
                    1342
                ],
                "abc.abstractmethod": [
                    672,
                    676,
                    709,
                    680,
                    713,
                    684,
                    691,
                    695,
                    703
                ],
                "httputil.HTTPHeaders": [
                    705,
                    963,
                    1638,
                    971,
                    1458
                ],
                "max_wbits": [
                    775,
                    776,
                    777,
                    780,
                    783,
                    725,
                    726,
                    728,
                    731,
                    734
                ],
                "zlib.MAX_WBITS": [
                    776,
                    777,
                    781,
                    1005,
                    726,
                    728,
                    732
                ],
                "zlib": [
                    776,
                    777,
                    781,
                    1005,
                    792,
                    755,
                    756,
                    726,
                    728,
                    761,
                    732
                ],
                "self._max_wbits": [
                    792,
                    756,
                    734,
                    783
                ],
                "self._compression_level": [
                    740,
                    756,
                    742
                ],
                "tornado.web.GZipContentEncoding.GZIP_LEVEL": [
                    740
                ],
                "tornado.web.GZipContentEncoding": [
                    740
                ],
                "self._mem_level": [
                    745,
                    747,
                    756
                ],
                "persistent": [
                    784,
                    749
                ],
                "self._compressor": [
                    1030,
                    840,
                    750,
                    752,
                    760,
                    1085,
                    1086
                ],
                "self._create_compressor": [
                    760,
                    750
                ],
                "zlib.compressobj": [
                    755
                ],
                "zlib.DEFLATED": [
                    756
                ],
                "compressor": [
                    760,
                    761
                ],
                "compressor.compress": [
                    761
                ],
                "compressor.flush": [
                    761
                ],
                "zlib.Z_SYNC_FLUSH": [
                    761
                ],
                "data.endswith": [
                    762
                ],
                "self._max_message_size": [
                    797,
                    774
                ],
                "self._decompressor": [
                    839,
                    1033,
                    1132,
                    785,
                    789,
                    795,
                    1213,
                    1215
                ],
                "self._create_decompressor": [
                    786,
                    795
                ],
                "zlib.decompressobj": [
                    792
                ],
                "decompressor": [
                    795,
                    796,
                    799
                ],
                "decompressor.decompress": [
                    796
                ],
                "decompressor.unconsumed_tail": [
                    799
                ],
                "_DecompressTooLargeError": [
                    800,
                    1216
                ],
                "WebSocketProtocol": [
                    827,
                    804,
                    1557
                ],
                "FIN": [
                    812
                ],
                "RSV1": [
                    816,
                    813
                ],
                "RSV2": [
                    816,
                    814
                ],
                "RSV3": [
                    816,
                    815
                ],
                "RSV_MASK": [
                    816
                ],
                "OPCODE_MASK": [
                    817
                ],
                "WebSocketProtocol.__init__": [
                    827
                ],
                "self.mask_outgoing": [
                    1056,
                    1066,
                    828
                ],
                "mask_outgoing": [
                    828
                ],
                "self.params": [
                    1161,
                    1034,
                    1298,
                    1558,
                    1305,
                    829,
                    1374
                ],
                "self._final_frame": [
                    830
                ],
                "self._frame_opcode": [
                    831
                ],
                "self._masked_frame": [
                    832
                ],
                "self._frame_mask": [
                    1168,
                    833,
                    1171,
                    1172
                ],
                "self._frame_length": [
                    834,
                    1151
                ],
                "self._fragmented_message_buffer": [
                    1184,
                    835,
                    1188,
                    1159,
                    1160,
                    1191,
                    1192,
                    1194,
                    1200
                ],
                "self._fragmented_message_opcode": [
                    836,
                    1190,
                    1199
                ],
                "self._waiting": [
                    1280,
                    1283,
                    837,
                    1276,
                    1277,
                    1278
                ],
                "self._compression_options": [
                    984,
                    924,
                    838,
                    927
                ],
                "params.compression_options": [
                    838
                ],
                "self._frame_compressed": [
                    1136,
                    841,
                    1212
                ],
                "self._message_bytes_in": [
                    1232,
                    845,
                    1223
                ],
                "self._message_bytes_out": [
                    1083,
                    846
                ],
                "self._wire_bytes_in": [
                    849,
                    1121
                ],
                "self._wire_bytes_out": [
                    850,
                    1070
                ],
                "self.ping_callback": [
                    1316,
                    1319,
                    1326,
                    1327,
                    851
                ],
                "self.last_ping": [
                    1346,
                    1315,
                    852,
                    1335
                ],
                "self.last_pong": [
                    1315,
                    1252,
                    853,
                    1334
                ],
                "self._selected_subprotocol": [
                    864,
                    860
                ],
                "selected_subprotocol.setter": [
                    862
                ],
                "selected_subprotocol": [
                    862
                ],
                "self._handle_websocket_headers": [
                    868
                ],
                "handler.set_status": [
                    942,
                    870
                ],
                "handler.finish": [
                    872,
                    946
                ],
                "self._accept_connection": [
                    877
                ],
                "asyncio.CancelledError": [
                    878
                ],
                "asyncio": [
                    1104,
                    1517,
                    878
                ],
                "fields": [
                    892,
                    893
                ],
                "handler.request.headers.get": [
                    912,
                    908,
                    893
                ],
                "handler.request.headers": [
                    912,
                    922,
                    908,
                    893
                ],
                "handler.request": [
                    912,
                    922,
                    908,
                    893
                ],
                "sha1": [
                    904,
                    901,
                    902,
                    903
                ],
                "hashlib.sha1": [
                    901
                ],
                "hashlib": [
                    901
                ],
                "sha1.update": [
                    902,
                    903
                ],
                "key": [
                    1026,
                    1027,
                    1028,
                    902,
                    979
                ],
                "native_str": [
                    904
                ],
                "base64.b64encode": [
                    904,
                    1370
                ],
                "base64": [
                    904,
                    1370
                ],
                "sha1.digest": [
                    904
                ],
                "WebSocketProtocol13.compute_accept_value": [
                    907
                ],
                "cast": [
                    1641,
                    908
                ],
                "subprotocol_header": [
                    912,
                    913,
                    914
                ],
                "subprotocols": [
                    1392,
                    1393,
                    914,
                    916,
                    917,
                    1652,
                    919
                ],
                "subprotocol_header.split": [
                    914
                ],
                "self.selected_subprotocol": [
                    917,
                    918,
                    919,
                    920,
                    989
                ],
                "handler.select_subprotocol": [
                    917
                ],
                "handler.set_header": [
                    935,
                    943,
                    944,
                    945,
                    920
                ],
                "extensions": [
                    965,
                    966,
                    967,
                    982,
                    983,
                    922,
                    923
                ],
                "self._parse_extensions_header": [
                    922,
                    982
                ],
                "ext": [
                    929,
                    930,
                    934,
                    987,
                    937,
                    983,
                    984,
                    985,
                    923,
                    924,
                    927
                ],
                "self._create_compressors": [
                    985,
                    927
                ],
                "httputil._encode_header": [
                    937
                ],
                "handler.clear_header": [
                    941
                ],
                "self._challenge_response": [
                    945
                ],
                "handler._detach_stream": [
                    948
                ],
                "self.start_pinging": [
                    950
                ],
                "open_result": [
                    952,
                    953,
                    954
                ],
                "handler.open": [
                    952
                ],
                "handler.open_args": [
                    952
                ],
                "handler.open_kwargs": [
                    952
                ],
                "handler.log_exception": [
                    956
                ],
                "self._receive_frame_loop": [
                    960
                ],
                "httputil._parse_header": [
                    967
                ],
                "e.strip": [
                    967
                ],
                "e": [
                    967
                ],
                "extensions.split": [
                    967
                ],
                "Tuple": [
                    964
                ],
                "accept": [
                    979,
                    980
                ],
                "self.compute_accept_value": [
                    979
                ],
                "options": [
                    1000,
                    1005,
                    1007,
                    1008,
                    1009
                ],
                "side": [
                    1001,
                    1003,
                    1029,
                    1031
                ],
                "agreed_parameters": [
                    1026,
                    1031,
                    1001,
                    1003,
                    1036
                ],
                "wbits_header": [
                    1003,
                    1004,
                    1007
                ],
                "agreed_parameters.get": [
                    1003
                ],
                "allowed_keys": [
                    1018,
                    1027
                ],
                "other_side": [
                    1036,
                    1029
                ],
                "_PerMessageDeflateCompressor": [
                    1030
                ],
                "self._get_compressor_options": [
                    1035,
                    1031
                ],
                "_PerMessageDeflateDecompressor": [
                    1033
                ],
                "self.params.max_message_size": [
                    1161,
                    1034
                ],
                "data_len": [
                    1060,
                    1061,
                    1062,
                    1063,
                    1065,
                    1043,
                    1049
                ],
                "opcode": [
                    1183,
                    1250,
                    1221,
                    1094,
                    1190,
                    1130,
                    1131,
                    1132,
                    1230,
                    1199,
                    1234,
                    1203,
                    1044,
                    1078,
                    1080,
                    1243,
                    1055
                ],
                "fin": [
                    1051,
                    1047
                ],
                "finbit": [
                    1052,
                    1054,
                    1055
                ],
                "self.FIN": [
                    1128,
                    1052
                ],
                "frame": [
                    1061,
                    1063,
                    1065,
                    1069,
                    1070,
                    1071,
                    1055
                ],
                "struct.pack": [
                    1061,
                    1063,
                    1065,
                    1267,
                    1055
                ],
                "struct": [
                    1154,
                    1061,
                    1157,
                    1127,
                    1063,
                    1065,
                    1267,
                    1238,
                    1055
                ],
                "flags": [
                    1084,
                    1087,
                    1094,
                    1055
                ],
                "mask_bit": [
                    1057,
                    1059,
                    1061,
                    1063,
                    1065
                ],
                "mask": [
                    1067,
                    1068
                ],
                "os.urandom": [
                    1370,
                    1067
                ],
                "os": [
                    1370,
                    1067
                ],
                "_websocket_mask": [
                    1172,
                    1068
                ],
                "self.stream.write": [
                    1071
                ],
                "tornado.escape.utf8": [
                    1081
                ],
                "self._compressor.compress": [
                    1086
                ],
                "self.RSV1": [
                    1136,
                    1137,
                    1087
                ],
                "fut": [
                    1100,
                    1094
                ],
                "self._write_frame": [
                    1246,
                    1109,
                    1094,
                    1271
                ],
                "StreamClosedError": [
                    1095,
                    1101,
                    1272,
                    1434,
                    1115,
                    1247
                ],
                "asyncio.ensure_future": [
                    1104,
                    1517
                ],
                "wrapper": [
                    1104
                ],
                "self._receive_frame": [
                    1114
                ],
                "self.handler.on_ws_connection_close": [
                    1117
                ],
                "self.stream.read_bytes": [
                    1120
                ],
                "n": [
                    1120,
                    1121
                ],
                "self._read_bytes": [
                    1153,
                    1156,
                    1126,
                    1168,
                    1169
                ],
                "header": [
                    1128,
                    1129,
                    1130,
                    1127
                ],
                "mask_payloadlen": [
                    1143,
                    1142,
                    1127
                ],
                "struct.unpack": [
                    1154,
                    1157,
                    1238,
                    1127
                ],
                "is_final_frame": [
                    1189,
                    1128,
                    1198,
                    1202,
                    1179
                ],
                "reserved_bits": [
                    1136,
                    1129,
                    1138,
                    1137
                ],
                "self.RSV_MASK": [
                    1129
                ],
                "self.OPCODE_MASK": [
                    1130
                ],
                "opcode_is_control": [
                    1146,
                    1131,
                    1175
                ],
                "is_masked": [
                    1170,
                    1142,
                    1167
                ],
                "payloadlen": [
                    1152,
                    1154,
                    1155,
                    1157,
                    1158,
                    1169,
                    1143,
                    1146,
                    1150,
                    1151
                ],
                "new_len": [
                    1160,
                    1161,
                    1158
                ],
                "handled_future": [
                    1203,
                    1204,
                    1205
                ],
                "self._handle_message": [
                    1203
                ],
                "self._decompressor.decompress": [
                    1215
                ],
                "decoded": [
                    1225,
                    1229
                ],
                "data.decode": [
                    1225
                ],
                "self._run_callback": [
                    1233,
                    1249,
                    1229,
                    1253
                ],
                "self.handler.on_message": [
                    1233,
                    1229
                ],
                "to_unicode": [
                    1240
                ],
                "self.handler.on_ping": [
                    1249
                ],
                "time": [
                    1315,
                    1252,
                    1333
                ],
                "IOLoop.current": [
                    1315,
                    1476,
                    1252,
                    1333,
                    1655
                ],
                "IOLoop": [
                    1315,
                    1476,
                    1252,
                    1333,
                    1655
                ],
                "self.handler.on_pong": [
                    1253
                ],
                "self.stream.closed": [
                    1261,
                    1294
                ],
                "close_data": [
                    1265,
                    1267,
                    1269,
                    1271
                ],
                "self.stream.io_loop.remove_timeout": [
                    1277
                ],
                "self.stream.io_loop.add_timeout": [
                    1283
                ],
                "self.stream.io_loop.time": [
                    1284
                ],
                "interval": [
                    1298,
                    1299,
                    1300
                ],
                "self.params.ping_interval": [
                    1298
                ],
                "timeout": [
                    1305,
                    1306,
                    1307
                ],
                "self.params.ping_timeout": [
                    1305
                ],
                "PeriodicCallback": [
                    1316
                ],
                "self.periodic_ping": [
                    1317
                ],
                "self.ping_callback.start": [
                    1319
                ],
                "self.is_closing": [
                    1326
                ],
                "self.ping_callback.stop": [
                    1327
                ],
                "now": [
                    1346,
                    1333,
                    1334,
                    1335
                ],
                "since_last_pong": [
                    1340,
                    1334
                ],
                "since_last_ping": [
                    1339,
                    1335
                ],
                "self.write_ping": [
                    1345
                ],
                "simple_httpclient._HTTPConnection": [
                    1349
                ],
                "simple_httpclient": [
                    1349
                ],
                "protocol": [
                    1356
                ],
                "httpclient.HTTPRequest": [
                    1633,
                    1640,
                    1642,
                    1643,
                    1580,
                    1360
                ],
                "httpclient": [
                    1633,
                    1446,
                    1640,
                    1642,
                    1643,
                    1580,
                    1360
                ],
                "self.connect_future": [
                    1447,
                    1449,
                    1451,
                    1485,
                    1368,
                    1433,
                    1434
                ],
                "Future": [
                    1368
                ],
                "self.read_queue": [
                    1369,
                    1530,
                    1515
                ],
                "Queue": [
                    1369
                ],
                "self.key": [
                    1473,
                    1370,
                    1388
                ],
                "self._on_message_callback": [
                    1371,
                    1526,
                    1527
                ],
                "on_message_callback": [
                    1371,
                    1647
                ],
                "scheme": [
                    1381,
                    1382,
                    1383
                ],
                "sep": [
                    1381,
                    1383
                ],
                "rest": [
                    1381,
                    1383
                ],
                "request.url.partition": [
                    1381
                ],
                "request.url": [
                    1381,
                    1383
                ],
                "request.headers.update": [
                    1384
                ],
                "request.headers": [
                    1384,
                    1393,
                    1400,
                    1638
                ],
                "join": [
                    1393
                ],
                "self.tcp_client": [
                    1436,
                    1411,
                    1404
                ],
                "TCPClient": [
                    1404
                ],
                "WebSocketClientConnection": [
                    1645,
                    1462,
                    1405,
                    1437
                ],
                "self._on_http_response": [
                    1409
                ],
                "self.protocol": [
                    1472,
                    1473,
                    1474,
                    1476,
                    1477,
                    1547,
                    1549,
                    1428,
                    1429,
                    1430,
                    1499,
                    1566
                ],
                "self.protocol.close": [
                    1429
                ],
                "self.connect_future.done": [
                    1433,
                    1447
                ],
                "self.connect_future.set_exception": [
                    1449,
                    1434,
                    1451
                ],
                "self._on_message": [
                    1521,
                    1435
                ],
                "self.tcp_client.close": [
                    1436
                ],
                "on_connection_close": [
                    1437
                ],
                "httpclient.HTTPResponse": [
                    1446
                ],
                "response.error": [
                    1448,
                    1449
                ],
                "response": [
                    1448,
                    1449
                ],
                "httputil.RequestStartLine": [
                    1457
                ],
                "httputil.ResponseStartLine": [
                    1457,
                    1460
                ],
                "start_line": [
                    1460,
                    1461,
                    1463
                ],
                "start_line.code": [
                    1461
                ],
                "headers_received": [
                    1462
                ],
                "self._timeout": [
                    1467,
                    1468,
                    1469
                ],
                "self.io_loop.remove_timeout": [
                    1468
                ],
                "self.io_loop": [
                    1468,
                    1517
                ],
                "self.headers": [
                    1473,
                    1471
                ],
                "self.protocol._process_server_headers": [
                    1473
                ],
                "self.protocol.stream": [
                    1474
                ],
                "self.connection.detach": [
                    1474
                ],
                "self.connection": [
                    1474
                ],
                "add_callback": [
                    1476
                ],
                "self.protocol._receive_frame_loop": [
                    1476
                ],
                "self.protocol.start_pinging": [
                    1477
                ],
                "self.final_callback": [
                    1483
                ],
                "future_set_result_unless_cancelled": [
                    1485
                ],
                "self.protocol.write_message": [
                    1499
                ],
                "awaitable": [
                    1515,
                    1517,
                    1518
                ],
                "self.read_queue.get": [
                    1515
                ],
                "self.io_loop.add_future": [
                    1517
                ],
                "self.read_queue.put": [
                    1530
                ],
                "self.protocol.write_ping": [
                    1549
                ],
                "self.protocol.selected_subprotocol": [
                    1566
                ],
                "typ": [
                    1576,
                    1574
                ],
                "app_log.error": [
                    1576
                ],
                "app_log": [
                    1576
                ],
                "tb": [
                    1576
                ],
                "url": [
                    1640,
                    1633,
                    1635
                ],
                "connect_timeout": [
                    1640,
                    1634
                ],
                "httpclient._RequestProxy": [
                    1643
                ],
                "httpclient.HTTPRequest._DEFAULTS": [
                    1643
                ],
                "conn": [
                    1656,
                    1645,
                    1655
                ],
                "add_future": [
                    1655
                ],
                "conn.connect_future": [
                    1656,
                    1655
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/home/ubuntu/Desktop/bgp_envs_local/repos/tornado_1/tornado/test/websocket_test.py",
                "test_function": "test_nodelay",
                "test_function_code": "    @gen_test\n    def test_nodelay(self):\n        ws = yield self.ws_connect(\"/nodelay\")\n        res = yield ws.read_message()\n        self.assertEqual(res, \"hello\")",
                "test_error": "AssertionError: None != 'hello'",
                "full_test_error": "self = <tornado.test.websocket_test.WebSocketTest testMethod=test_nodelay>\n\n    @gen_test\n    def test_nodelay(self):\n        ws = yield self.ws_connect(\"/nodelay\")\n        res = yield ws.read_message()\n>       self.assertEqual(res, \"hello\")\nE       AssertionError: None != 'hello'\n\ntornado/test/websocket_test.py:576: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "gen_test"
                ]
            }
        ]
    }
}