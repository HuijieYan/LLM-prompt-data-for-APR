{
    "1": "Assume that the following list of imports are available in the current environment, so you don't need to import them when generating a fix.\n```python\nfrom tornado import httputil\nfrom tornado import iostream\n```\n\n## The source code of the buggy function\n```python\n# The relative path of the buggy file: tornado/web.py\n\n\n\n    # this is the buggy function you need to fix\n    async def get(self, path: str, include_body: bool = True) -> None:\n        # Set up our path instance variables.\n        self.path = self.parse_url_path(path)\n        del path  # make sure we don't refer to path instead of self.path again\n        absolute_path = self.get_absolute_path(self.root, self.path)\n        self.absolute_path = self.validate_absolute_path(self.root, absolute_path)\n        if self.absolute_path is None:\n            return\n    \n        self.modified = self.get_modified_time()\n        self.set_headers()\n    \n        if self.should_return_304():\n            self.set_status(304)\n            return\n    \n        request_range = None\n        range_header = self.request.headers.get(\"Range\")\n        if range_header:\n            # As per RFC 2616 14.16, if an invalid Range header is specified,\n            # the request will be treated as if the header didn't exist.\n            request_range = httputil._parse_request_range(range_header)\n    \n        size = self.get_content_size()\n        if request_range:\n            start, end = request_range\n            if (start is not None and start >= size) or end == 0:\n                # As per RFC 2616 14.35.1, a range is not satisfiable only: if\n                # the first requested byte is equal to or greater than the\n                # content, or when a suffix with length 0 is specified\n                self.set_status(416)  # Range Not Satisfiable\n                self.set_header(\"Content-Type\", \"text/plain\")\n                self.set_header(\"Content-Range\", \"bytes */%s\" % (size,))\n                return\n            if start is not None and start < 0:\n                start += size\n            if end is not None and end > size:\n                # Clients sometimes blindly use a large range to limit their\n                # download size; cap the endpoint at the actual file size.\n                end = size\n            # Note: only return HTTP 206 if less than the entire range has been\n            # requested. Not only is this semantically correct, but Chrome\n            # refuses to play audio if it gets an HTTP 206 in response to\n            # ``Range: bytes=0-``.\n            if size != (end or size) - (start or 0):\n                self.set_status(206)  # Partial Content\n                self.set_header(\n                    \"Content-Range\", httputil._get_content_range(start, end, size)\n                )\n        else:\n            start = end = None\n    \n        if start is not None and end is not None:\n            content_length = end - start\n        elif end is not None:\n            content_length = end\n        elif start is not None:\n            content_length = size - start\n        else:\n            content_length = size\n        self.set_header(\"Content-Length\", content_length)\n    \n        if include_body:\n            content = self.get_content(self.absolute_path, start, end)\n            if isinstance(content, bytes):\n                content = [content]\n            for chunk in content:\n                try:\n                    self.write(chunk)\n                    await self.flush()\n                except iostream.StreamClosedError:\n                    return\n        else:\n            assert self.request.method == \"HEAD\"\n    \n```",
    "2": "# The declaration of the class containing the buggy function\nclass StaticFileHandler(RequestHandler):\n    \"\"\"\n    A simple handler that can serve static content from a directory.\n    \n    A `StaticFileHandler` is configured automatically if you pass the\n    ``static_path`` keyword argument to `Application`.  This handler\n    can be customized with the ``static_url_prefix``, ``static_handler_class``,\n    and ``static_handler_args`` settings.\n    \n    To map an additional path to this handler for a static data directory\n    you would add a line to your application like::\n    \n        application = web.Application([\n            (r\"/content/(.*)\", web.StaticFileHandler, {\"path\": \"/var/www\"}),\n        ])\n    \n    The handler constructor requires a ``path`` argument, which specifies the\n    local root directory of the content to be served.\n    \n    Note that a capture group in the regex is required to parse the value for\n    the ``path`` argument to the get() method (different than the constructor\n    argument above); see `URLSpec` for details.\n    \n    To serve a file like ``index.html`` automatically when a directory is\n    requested, set ``static_handler_args=dict(default_filename=\"index.html\")``\n    in your application settings, or add ``default_filename`` as an initializer\n    argument for your ``StaticFileHandler``.\n    \n    To maximize the effectiveness of browser caching, this class supports\n    versioned urls (by default using the argument ``?v=``).  If a version\n    is given, we instruct the browser to cache this file indefinitely.\n    `make_static_url` (also available as `RequestHandler.static_url`) can\n    be used to construct a versioned url.\n    \n    This handler is intended primarily for use in development and light-duty\n    file serving; for heavy traffic it will be more efficient to use\n    a dedicated static file server (such as nginx or Apache).  We support\n    the HTTP ``Accept-Ranges`` mechanism to return partial content (because\n    some browsers require this functionality to be present to seek in\n    HTML5 audio or video).\n    \n    **Subclassing notes**\n    \n    This class is designed to be extensible by subclassing, but because\n    of the way static urls are generated with class methods rather than\n    instance methods, the inheritance patterns are somewhat unusual.\n    Be sure to use the ``@classmethod`` decorator when overriding a\n    class method.  Instance methods may use the attributes ``self.path``\n    ``self.absolute_path``, and ``self.modified``.\n    \n    Subclasses should only override methods discussed in this section;\n    overriding other methods is error-prone.  Overriding\n    ``StaticFileHandler.get`` is particularly problematic due to the\n    tight coupling with ``compute_etag`` and other methods.\n    \n    To change the way static urls are generated (e.g. to match the behavior\n    of another server or CDN), override `make_static_url`, `parse_url_path`,\n    `get_cache_time`, and/or `get_version`.\n    \n    To replace all interaction with the filesystem (e.g. to serve\n    static content from a database), override `get_content`,\n    `get_content_size`, `get_modified_time`, `get_absolute_path`, and\n    `validate_absolute_path`.\n    \n    .. versionchanged:: 3.1\n       Many of the methods for subclasses were added in Tornado 3.1.\n    \"\"\"\n\n\n",
    "3": "# This function from the same file, but not the same class, is called by the buggy function\ndef set_status(self, status_code: int, reason: str=None) -> None:\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef set_header(self, name: str, value: _HeaderTypes) -> None:\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef write(self, chunk: Union[str, bytes, dict]) -> None:\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef flush(self, include_footers: bool=False) -> 'Future[None]':\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef get(self, *args: Any) -> None:\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef set_headers(self) -> None:\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef should_return_304(self) -> bool:\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef get_absolute_path(cls, root: str, path: str) -> str:\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef validate_absolute_path(self, root: str, absolute_path: str) -> Optional[str]:\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef get_content(cls, abspath: str, start: int=None, end: int=None) -> Generator[bytes, None, None]:\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef get_content_size(self) -> int:\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef get_modified_time(self) -> Optional[datetime.datetime]:\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef parse_url_path(self, url_path: str) -> str:\n    # Please ignore the body of this function\n\n    # This function from the same class is called by the buggy function\n    def set_headers(self) -> None:\n        # Please ignore the body of this function\n\n    # This function from the same class is called by the buggy function\n    def should_return_304(self) -> bool:\n        # Please ignore the body of this function\n\n    # This function from the same class is called by the buggy function\n    def get_absolute_path(cls, root: str, path: str) -> str:\n        # Please ignore the body of this function\n\n    # This function from the same class is called by the buggy function\n    def validate_absolute_path(self, root: str, absolute_path: str) -> Optional[str]:\n        # Please ignore the body of this function\n\n    # This function from the same class is called by the buggy function\n    def get_content(cls, abspath: str, start: int=None, end: int=None) -> Generator[bytes, None, None]:\n        # Please ignore the body of this function\n\n    # This function from the same class is called by the buggy function\n    def get_content_size(self) -> int:\n        # Please ignore the body of this function\n\n    # This function from the same class is called by the buggy function\n    def get_modified_time(self) -> Optional[datetime.datetime]:\n        # Please ignore the body of this function\n\n    # This function from the same class is called by the buggy function\n    def parse_url_path(self, url_path: str) -> str:\n        # Please ignore the body of this function\n\n",
    "4": "## A failing test function for the buggy function\n```python\n# The relative path of the failing test file: tornado/test/web_test.py\n\n    def test_static_unsatisfiable_range_end_less_than_start(self):\n        response = self.get_and_head(\n            \"/static/robots.txt\", headers={\"Range\": \"bytes=10-3\"}\n        )\n        self.assertEqual(response.code, 416)\n        self.assertEqual(response.headers.get(\"Content-Range\"), \"bytes */26\")\n```\n\n\n",
    "5": "### The error message from the failing test\n```text\nself = <tornado.test.web_test.StaticFileTest testMethod=test_static_unsatisfiable_range_end_less_than_start>\n\n    def test_static_unsatisfiable_range_end_less_than_start(self):\n        response = self.get_and_head(\n>           \"/static/robots.txt\", headers={\"Range\": \"bytes=10-3\"}\n        )\n\ntornado/test/web_test.py:1314: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntornado/test/web_test.py:1154: in get_and_head\n    % (h, head_response.headers.get(h), get_response.headers.get(h)),\nE   AssertionError: '-6' != '93'\nE   - -6\nE   + 93\nE    : Content-Length differs between GET (-6) and HEAD (93)\n\n```\n",
    "6": "## Runtime values and types of variables inside the buggy function\nEach case below includes input parameter values and types, and the values and types of relevant variables at the function's return, derived from executing failing tests. If an input parameter is not reflected in the output, it is assumed to remain unchanged. Note that some of these values at the function's return might be incorrect. Analyze these cases to identify why the tests are failing to effectively fix the bug.\n\n### Case 1\n#### Runtime values and types of the input parameters of the buggy function\npath, value: `'robots.txt'`, type: `str`\n\nself.root, value: `'/home/ubuntu/Desktop/bgp_envs_local/repos/tornado_4/tornado/test/static'`, type: `str`\n\nself.request, value: `HTTPServerRequest(protocol='http', host='127.0.0.1:41697', method='HEAD', uri='/static/robots.txt', version='HTTP/1.1', remote_ip='127.0.0.1')`, type: `HTTPServerRequest`\n\ninclude_body, value: `False`, type: `bool`\n\n#### Runtime values and types of variables right before the buggy function's return\nself.path, value: `'robots.txt'`, type: `str`\n\nabsolute_path, value: `'/home/ubuntu/Desktop/bgp_envs_local/repos/tornado_4/tornado/test/static/robots.txt'`, type: `str`\n\nself.absolute_path, value: `'/home/ubuntu/Desktop/bgp_envs_local/repos/tornado_4/tornado/test/static/robots.txt'`, type: `str`\n\nself.modified, value: `datetime.datetime(2023, 12, 13, 14, 31, 22)`, type: `datetime`\n\nrequest_range, value: `(10, 4)`, type: `tuple`\n\nrange_header, value: `'bytes=10-3'`, type: `str`\n\nsize, value: `26`, type: `int`\n\nstart, value: `10`, type: `int`\n\nend, value: `4`, type: `int`\n\n### Case 2\n#### Runtime values and types of the input parameters of the buggy function\npath, value: `'robots.txt'`, type: `str`\n\nself.root, value: `'/home/ubuntu/Desktop/bgp_envs_local/repos/tornado_4/tornado/test/static'`, type: `str`\n\nself.request, value: `HTTPServerRequest(protocol='http', host='127.0.0.1:41697', method='GET', uri='/static/robots.txt', version='HTTP/1.1', remote_ip='127.0.0.1')`, type: `HTTPServerRequest`\n\ninclude_body, value: `True`, type: `bool`\n\n#### Runtime values and types of variables right before the buggy function's return\nself.path, value: `'robots.txt'`, type: `str`\n\nabsolute_path, value: `'/home/ubuntu/Desktop/bgp_envs_local/repos/tornado_4/tornado/test/static/robots.txt'`, type: `str`\n\nself.absolute_path, value: `'/home/ubuntu/Desktop/bgp_envs_local/repos/tornado_4/tornado/test/static/robots.txt'`, type: `str`\n\nself.modified, value: `datetime.datetime(2023, 12, 13, 14, 31, 22)`, type: `datetime`\n\nrequest_range, value: `(10, 4)`, type: `tuple`\n\nrange_header, value: `'bytes=10-3'`, type: `str`\n\nsize, value: `26`, type: `int`\n\nstart, value: `10`, type: `int`\n\nend, value: `4`, type: `int`\n\n",
    "7": "## Expected values and types of variables during the failing test execution\nEach case below includes input parameter values and types, and the expected values and types of relevant variables at the function's return. If an input parameter is not reflected in the output, it is assumed to remain unchanged. A corrected function must satisfy all these cases.\n\n### Expected case 1\n#### The values and types of buggy function's parameters\npath, value: `'robots.txt'`, type: `str`\n\nself.root, value: `'/home/ubuntu/Desktop/bgp_envs_local/repos/tornado_4/tornado/test/static'`, type: `str`\n\nself.request, value: `HTTPServerRequest(protocol='http', host='127.0.0.1:34699', method='HEAD', uri='/static/robots.txt', version='HTTP/1.1', remote_ip='127.0.0.1')`, type: `HTTPServerRequest`\n\ninclude_body, value: `False`, type: `bool`\n\n#### Expected values and types of variables right before the buggy function's return\nself.path, expected value: `'robots.txt'`, type: `str`\n\nabsolute_path, expected value: `'/home/ubuntu/Desktop/bgp_envs_local/repos/tornado_4/tornado/test/static/robots.txt'`, type: `str`\n\nself.absolute_path, expected value: `'/home/ubuntu/Desktop/bgp_envs_local/repos/tornado_4/tornado/test/static/robots.txt'`, type: `str`\n\nself.modified, expected value: `datetime.datetime(2023, 12, 13, 14, 31, 22)`, type: `datetime`\n\nrequest_range, expected value: `(10, 4)`, type: `tuple`\n\nrange_header, expected value: `'bytes=10-3'`, type: `str`\n\nsize, expected value: `26`, type: `int`\n\nstart, expected value: `10`, type: `int`\n\nend, expected value: `4`, type: `int`\n\ncontent_length, expected value: `-6`, type: `int`\n\n",
    "8": "## A GitHub issue for this bug\n\nThe issue's title:\n```text\nStaticFileHandler breaks with negative range\n```\n\nThe issue's detailed description:\n```text\nWhen passing a negative range (example: bytes=-30720) in the Range header, but the requested file is smaller than the range requested, StaticFileHandler will try to seek to a negative position in the file and get an error from the operating system (linux in my case).\n\nTraceback (most recent call last):\n  File \"/home/venzano/venvs/zoe-2018.08/lib/python3.5/site-packages/tornado/web.py\", line 1592, in _execute\n    result = yield result\n  File \"/home/venzano/venvs/zoe-2018.08/lib/python3.5/site-packages/tornado/gen.py\", line 1133, in run\n    value = future.result()\n  File \"/usr/lib/python3.5/asyncio/futures.py\", line 274, in result\n    raise self._exception\n  File \"/home/venzano/venvs/zoe-2018.08/lib/python3.5/site-packages/tornado/gen.py\", line 326, in wrapper\n    yielded = next(result)\n  File \"/home/venzano/venvs/zoe-2018.08/lib/python3.5/site-packages/tornado/web.py\", line 2525, in get\n    for chunk in content:\n  File \"/home/venzano/venvs/zoe-2018.08/lib/python3.5/site-packages/tornado/web.py\", line 2680, in get_content\n    file.seek(start)\nOSError: [Errno 22] Invalid argument\nThe code (file web.py around line 2494 in Tornado 5.1.1):\n\n            if start is not None and start < 0:\n                start += size\nis not sufficient, it should check if size is smaller than start and in that case just set start=size.\n```\n\n",
    "9": "Your output should follow these steps:\n1. Analyze the buggy function and its relationship with the buggy class, related functions, test code, corresponding error message, the actual input/output variable information, the expected input/output variable information, the github issue.\n2. Identify a potential error location within the buggy function.\n3. Elucidate the bug's cause using:\n   (a) The buggy function, \n   (b) The buggy class docs, \n   (c) The related functions, \n   (d) The failing test, \n   (e) The corresponding error message, \n   (f) The actual input/output variable values, \n   (g) The expected input/output variable values, \n   (h) The GitHub Issue information\n\n4. Suggest approaches for fixing the bug.\n5. Present the corrected code for the buggy function such that it satisfied the following:\n   (a) the program passes the failing test, \n   (b) the function satisfies the expected input/output variable information provided, \n   (c) successfully resolves the issue posted in GitHub\n\n",
    "1.3.3": "Assume that the following list of imports are available in the current environment, so you don't need to import them when generating a fix.\n```python\nfrom tornado import httputil\nfrom tornado import iostream\n```\n\n",
    "source_code_body": "# This function from the same file, but not the same class, is called by the buggy function\ndef set_status(self, status_code: int, reason: str=None) -> None:\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef set_header(self, name: str, value: _HeaderTypes) -> None:\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef write(self, chunk: Union[str, bytes, dict]) -> None:\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef flush(self, include_footers: bool=False) -> 'Future[None]':\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef get(self, *args: Any) -> None:\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef set_headers(self) -> None:\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef should_return_304(self) -> bool:\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef get_absolute_path(cls, root: str, path: str) -> str:\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef validate_absolute_path(self, root: str, absolute_path: str) -> Optional[str]:\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef get_content(cls, abspath: str, start: int=None, end: int=None) -> Generator[bytes, None, None]:\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef get_content_size(self) -> int:\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef get_modified_time(self) -> Optional[datetime.datetime]:\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef parse_url_path(self, url_path: str) -> str:\n    # Please ignore the body of this function\n\n# The declaration of the class containing the buggy function\nclass StaticFileHandler(RequestHandler):\n    \"\"\"\n    A simple handler that can serve static content from a directory.\n    \n    A `StaticFileHandler` is configured automatically if you pass the\n    ``static_path`` keyword argument to `Application`.  This handler\n    can be customized with the ``static_url_prefix``, ``static_handler_class``,\n    and ``static_handler_args`` settings.\n    \n    To map an additional path to this handler for a static data directory\n    you would add a line to your application like::\n    \n        application = web.Application([\n            (r\"/content/(.*)\", web.StaticFileHandler, {\"path\": \"/var/www\"}),\n        ])\n    \n    The handler constructor requires a ``path`` argument, which specifies the\n    local root directory of the content to be served.\n    \n    Note that a capture group in the regex is required to parse the value for\n    the ``path`` argument to the get() method (different than the constructor\n    argument above); see `URLSpec` for details.\n    \n    To serve a file like ``index.html`` automatically when a directory is\n    requested, set ``static_handler_args=dict(default_filename=\"index.html\")``\n    in your application settings, or add ``default_filename`` as an initializer\n    argument for your ``StaticFileHandler``.\n    \n    To maximize the effectiveness of browser caching, this class supports\n    versioned urls (by default using the argument ``?v=``).  If a version\n    is given, we instruct the browser to cache this file indefinitely.\n    `make_static_url` (also available as `RequestHandler.static_url`) can\n    be used to construct a versioned url.\n    \n    This handler is intended primarily for use in development and light-duty\n    file serving; for heavy traffic it will be more efficient to use\n    a dedicated static file server (such as nginx or Apache).  We support\n    the HTTP ``Accept-Ranges`` mechanism to return partial content (because\n    some browsers require this functionality to be present to seek in\n    HTML5 audio or video).\n    \n    **Subclassing notes**\n    \n    This class is designed to be extensible by subclassing, but because\n    of the way static urls are generated with class methods rather than\n    instance methods, the inheritance patterns are somewhat unusual.\n    Be sure to use the ``@classmethod`` decorator when overriding a\n    class method.  Instance methods may use the attributes ``self.path``\n    ``self.absolute_path``, and ``self.modified``.\n    \n    Subclasses should only override methods discussed in this section;\n    overriding other methods is error-prone.  Overriding\n    ``StaticFileHandler.get`` is particularly problematic due to the\n    tight coupling with ``compute_etag`` and other methods.\n    \n    To change the way static urls are generated (e.g. to match the behavior\n    of another server or CDN), override `make_static_url`, `parse_url_path`,\n    `get_cache_time`, and/or `get_version`.\n    \n    To replace all interaction with the filesystem (e.g. to serve\n    static content from a database), override `get_content`,\n    `get_content_size`, `get_modified_time`, `get_absolute_path`, and\n    `validate_absolute_path`.\n    \n    .. versionchanged:: 3.1\n       Many of the methods for subclasses were added in Tornado 3.1.\n    \"\"\"\n\n\n    # This function from the same class is called by the buggy function\n    def set_headers(self) -> None:\n        # Please ignore the body of this function\n\n    # This function from the same class is called by the buggy function\n    def should_return_304(self) -> bool:\n        # Please ignore the body of this function\n\n    # This function from the same class is called by the buggy function\n    def get_absolute_path(cls, root: str, path: str) -> str:\n        # Please ignore the body of this function\n\n    # This function from the same class is called by the buggy function\n    def validate_absolute_path(self, root: str, absolute_path: str) -> Optional[str]:\n        # Please ignore the body of this function\n\n    # This function from the same class is called by the buggy function\n    def get_content(cls, abspath: str, start: int=None, end: int=None) -> Generator[bytes, None, None]:\n        # Please ignore the body of this function\n\n    # This function from the same class is called by the buggy function\n    def get_content_size(self) -> int:\n        # Please ignore the body of this function\n\n    # This function from the same class is called by the buggy function\n    def get_modified_time(self) -> Optional[datetime.datetime]:\n        # Please ignore the body of this function\n\n    # This function from the same class is called by the buggy function\n    def parse_url_path(self, url_path: str) -> str:\n        # Please ignore the body of this function\n\n\n\n    # this is the buggy function you need to fix\n    async def get(self, path: str, include_body: bool = True) -> None:\n        # Set up our path instance variables.\n        self.path = self.parse_url_path(path)\n        del path  # make sure we don't refer to path instead of self.path again\n        absolute_path = self.get_absolute_path(self.root, self.path)\n        self.absolute_path = self.validate_absolute_path(self.root, absolute_path)\n        if self.absolute_path is None:\n            return\n    \n        self.modified = self.get_modified_time()\n        self.set_headers()\n    \n        if self.should_return_304():\n            self.set_status(304)\n            return\n    \n        request_range = None\n        range_header = self.request.headers.get(\"Range\")\n        if range_header:\n            # As per RFC 2616 14.16, if an invalid Range header is specified,\n            # the request will be treated as if the header didn't exist.\n            request_range = httputil._parse_request_range(range_header)\n    \n        size = self.get_content_size()\n        if request_range:\n            start, end = request_range\n            if (start is not None and start >= size) or end == 0:\n                # As per RFC 2616 14.35.1, a range is not satisfiable only: if\n                # the first requested byte is equal to or greater than the\n                # content, or when a suffix with length 0 is specified\n                self.set_status(416)  # Range Not Satisfiable\n                self.set_header(\"Content-Type\", \"text/plain\")\n                self.set_header(\"Content-Range\", \"bytes */%s\" % (size,))\n                return\n            if start is not None and start < 0:\n                start += size\n            if end is not None and end > size:\n                # Clients sometimes blindly use a large range to limit their\n                # download size; cap the endpoint at the actual file size.\n                end = size\n            # Note: only return HTTP 206 if less than the entire range has been\n            # requested. Not only is this semantically correct, but Chrome\n            # refuses to play audio if it gets an HTTP 206 in response to\n            # ``Range: bytes=0-``.\n            if size != (end or size) - (start or 0):\n                self.set_status(206)  # Partial Content\n                self.set_header(\n                    \"Content-Range\", httputil._get_content_range(start, end, size)\n                )\n        else:\n            start = end = None\n    \n        if start is not None and end is not None:\n            content_length = end - start\n        elif end is not None:\n            content_length = end\n        elif start is not None:\n            content_length = size - start\n        else:\n            content_length = size\n        self.set_header(\"Content-Length\", content_length)\n    \n        if include_body:\n            content = self.get_content(self.absolute_path, start, end)\n            if isinstance(content, bytes):\n                content = [content]\n            for chunk in content:\n                try:\n                    self.write(chunk)\n                    await self.flush()\n                except iostream.StreamClosedError:\n                    return\n        else:\n            assert self.request.method == \"HEAD\"\n    \n"
}