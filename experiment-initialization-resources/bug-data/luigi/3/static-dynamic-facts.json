{
    "luigi:3": {
        "/home/ubuntu/Desktop/bgp_envs_local/repos/luigi_3/luigi/parameter.py": {
            "buggy_functions": [
                {
                    "function_name": "parse",
                    "function_code": "def parse(self, x):\n    \"\"\"\n    Parse an individual value from the input.\n\n    :param str x: the value to parse.\n    :return: the parsed value.\n    \"\"\"\n    # Since the result of json.dumps(tuple) differs from a tuple string, we must handle either case.\n    # A tuple string may come from a config file or from cli execution.\n\n    # t = ((1, 2), (3, 4))\n    # t_str = '((1,2),(3,4))'\n    # t_json_str = json.dumps(t)\n    # t_json_str == '[[1, 2], [3, 4]]'\n    # json.loads(t_json_str) == t\n    # json.loads(t_str) == ValueError: No JSON object could be decoded\n\n    # Therefore, if json.loads(x) returns a ValueError, try ast.literal_eval(x).\n    # ast.literal_eval(t_str) == t\n    try:\n        # loop required to parse tuple of tuples\n        return tuple(tuple(x) for x in json.loads(x, object_pairs_hook=_FrozenOrderedDict))\n    except ValueError:\n        return literal_eval(x)  # if this causes an error, let that error be raised.\n",
                    "decorators": [],
                    "docstring": "Parse an individual value from the input.\n\n:param str x: the value to parse.\n:return: the parsed value.",
                    "start_line": 1095,
                    "end_line": 1118,
                    "variables": {
                        "tuple": [
                            1116
                        ],
                        "x": [
                            1116,
                            1118
                        ],
                        "json.loads": [
                            1116
                        ],
                        "json": [
                            1116
                        ],
                        "_FrozenOrderedDict": [
                            1116
                        ],
                        "ValueError": [
                            1117
                        ],
                        "literal_eval": [
                            1118
                        ]
                    },
                    "filtered_variables": {
                        "x": [
                            1116,
                            1118
                        ],
                        "json.loads": [
                            1116
                        ],
                        "json": [
                            1116
                        ],
                        "_FrozenOrderedDict": [
                            1116
                        ],
                        "literal_eval": [
                            1118
                        ]
                    },
                    "diff_line_number": 1117,
                    "class_data": {
                        "signature": "class TupleParameter(ListParameter)",
                        "docstring": "Parameter whose value is a ``tuple`` or ``tuple`` of tuples.\n\nIn the task definition, use\n\n.. code-block:: python\n\n    class MyTask(luigi.Task):\n      book_locations = luigi.TupleParameter()\n\n        def run(self):\n            for location in self.book_locations:\n                print(\"Go to page %d, line %d\" % (location[0], location[1]))\n\n\nAt the command line, use\n\n.. code-block:: console\n\n    $ luigi --module my_tasks MyTask --book_locations <JSON string>\n\nSimple example with two grades:\n\n.. code-block:: console\n\n    $ luigi --module my_tasks MyTask --book_locations '((12,3),(4,15),(52,1))'",
                        "constructor_docstring": null,
                        "functions": [
                            "def parse(self, x):\n    \"\"\"\n    Parse an individual value from the input.\n\n    :param str x: the value to parse.\n    :return: the parsed value.\n    \"\"\"\n    try:\n        return tuple((tuple(x) for x in json.loads(x, object_pairs_hook=_FrozenOrderedDict)))\n    except ValueError:\n        return literal_eval(x)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [],
                        "class_decorators": [],
                        "function_signatures": [
                            "parse(self, x)"
                        ],
                        "class_level_variable_names": [],
                        "constructor_variable_names": []
                    },
                    "used_imports": [
                        "import json",
                        "from ast import literal_eval"
                    ],
                    "variable_values": [
                        [
                            {
                                "x": {
                                    "variable_value": "'[1, 2, 3]'",
                                    "variable_type": "str",
                                    "variable_shape": "9"
                                },
                                "json.loads": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "json": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_FrozenOrderedDict": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "literal_eval": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "x": {
                                    "variable_value": "'[1, 2, 3]'",
                                    "variable_type": "str",
                                    "variable_shape": "9"
                                },
                                "json.loads": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "json": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_FrozenOrderedDict": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "literal_eval": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "x": {
                                    "variable_value": "'[1, 2, 3]'",
                                    "variable_type": "str",
                                    "variable_shape": "9"
                                },
                                "json.loads": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "json": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_FrozenOrderedDict": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "literal_eval": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "x": {
                                    "variable_value": "'[1, 2, 3]'",
                                    "variable_type": "str",
                                    "variable_shape": "9"
                                },
                                "json.loads": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "json": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_FrozenOrderedDict": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "literal_eval": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "x": {
                                    "variable_value": "'[1, 2, 3]'",
                                    "variable_type": "str",
                                    "variable_shape": "9"
                                },
                                "json.loads": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "json": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_FrozenOrderedDict": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "literal_eval": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "x": {
                                    "variable_value": "'[1, 2, 3]'",
                                    "variable_type": "str",
                                    "variable_shape": "9"
                                },
                                "json.loads": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "json": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_FrozenOrderedDict": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "literal_eval": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                }
            ],
            "inscope_functions": {
                "file_scope_functions": [
                    {
                        "code": "def _recursively_freeze(value):\n    \"\"\"\n    Recursively walks ``Mapping``s and ``list``s and converts them to ``_FrozenOrderedDict`` and ``tuples``, respectively.\n    \"\"\"\n    if isinstance(value, Mapping):\n        return _FrozenOrderedDict(((k, _recursively_freeze(v)) for k, v in value.items()))\n    elif isinstance(value, list) or isinstance(value, tuple):\n        return tuple(_recursively_freeze(v) for v in value)\n    return value",
                        "signature": "_recursively_freeze(value)"
                    }
                ],
                "file_scope_classes": [
                    {
                        "class_declaration": "class ParameterVisibility:",
                        "functions": [
                            {
                                "code": "@classmethod\ndef has_value(cls, value):\n    return any(value == item.value for item in cls)",
                                "signature": "has_value(cls, value)"
                            },
                            {
                                "code": "def serialize(self):\n    return self.value",
                                "signature": "serialize(self)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class ParameterException:",
                        "functions": []
                    },
                    {
                        "class_declaration": "class MissingParameterException:",
                        "functions": []
                    },
                    {
                        "class_declaration": "class UnknownParameterException:",
                        "functions": []
                    },
                    {
                        "class_declaration": "class DuplicateParameterException:",
                        "functions": []
                    },
                    {
                        "class_declaration": "class Parameter:",
                        "functions": [
                            {
                                "code": "def __init__(self, default=_no_value, is_global=False, significant=True, description=None,\n             config_path=None, positional=True, always_in_help=False, batch_method=None,\n             visibility=ParameterVisibility.PUBLIC):\n    \"\"\"\n    :param default: the default value for this parameter. This should match the type of the\n                    Parameter, i.e. ``datetime.date`` for ``DateParameter`` or ``int`` for\n                    ``IntParameter``. By default, no default is stored and\n                    the value must be specified at runtime.\n    :param bool significant: specify ``False`` if the parameter should not be treated as part of\n                             the unique identifier for a Task. An insignificant Parameter might\n                             also be used to specify a password or other sensitive information\n                             that should not be made public via the scheduler. Default:\n                             ``True``.\n    :param str description: A human-readable string describing the purpose of this Parameter.\n                            For command-line invocations, this will be used as the `help` string\n                            shown to users. Default: ``None``.\n    :param dict config_path: a dictionary with entries ``section`` and ``name``\n                             specifying a config file entry from which to read the\n                             default value for this parameter. DEPRECATED.\n                             Default: ``None``.\n    :param bool positional: If true, you can set the argument as a\n                            positional argument. It's true by default but we recommend\n                            ``positional=False`` for abstract base classes and similar cases.\n    :param bool always_in_help: For the --help option in the command line\n                                parsing. Set true to always show in --help.\n    :param function(iterable[A])->A batch_method: Method to combine an iterable of parsed\n                                                    parameter values into a single value. Used\n                                                    when receiving batched parameter lists from\n                                                    the scheduler. See :ref:`batch_method`\n\n    :param visibility: A Parameter whose value is a :py:class:`~luigi.parameter.ParameterVisibility`.\n                        Default value is ParameterVisibility.PUBLIC\n\n    \"\"\"\n    self._default = default\n    self._batch_method = batch_method\n    if is_global:\n        warnings.warn(\"is_global support is removed. Assuming positional=False\",\n                      DeprecationWarning,\n                      stacklevel=2)\n        positional = False\n    self.significant = significant  # Whether different values for this parameter will differentiate otherwise equal tasks\n    self.positional = positional\n    self.visibility = visibility if ParameterVisibility.has_value(visibility) else ParameterVisibility.PUBLIC\n\n    self.description = description\n    self.always_in_help = always_in_help\n\n    if config_path is not None and ('section' not in config_path or 'name' not in config_path):\n        raise ParameterException('config_path must be a hash containing entries for section and name')\n    self._config_path = config_path\n\n    self._counter = Parameter._counter  # We need to keep track of this to get the order right (see Task class)\n    Parameter._counter += 1",
                                "signature": "__init__(self, default=_no_value, is_global=False, significant=True, description=None, config_path=None, positional=True, always_in_help=False, batch_method=None, visibility=ParameterVisibility.PUBLIC)"
                            },
                            {
                                "code": "def _get_value_from_config(self, section, name):\n    \"\"\"Loads the default from the config. Returns _no_value if it doesn't exist\"\"\"\n\n    conf = configuration.get_config()\n\n    try:\n        value = conf.get(section, name)\n    except (NoSectionError, NoOptionError, KeyError):\n        return _no_value\n\n    return self.parse(value)",
                                "signature": "_get_value_from_config(self, section, name)"
                            },
                            {
                                "code": "def _get_value(self, task_name, param_name):\n    for value, warn in self._value_iterator(task_name, param_name):\n        if value != _no_value:\n            if warn:\n                warnings.warn(warn, DeprecationWarning)\n            return value\n    return _no_value",
                                "signature": "_get_value(self, task_name, param_name)"
                            },
                            {
                                "code": "def _value_iterator(self, task_name, param_name):\n    \"\"\"\n    Yield the parameter values, with optional deprecation warning as second tuple value.\n\n    The parameter value will be whatever non-_no_value that is yielded first.\n    \"\"\"\n    cp_parser = CmdlineParser.get_instance()\n    if cp_parser:\n        dest = self._parser_global_dest(param_name, task_name)\n        found = getattr(cp_parser.known_args, dest, None)\n        yield (self._parse_or_no_value(found), None)\n    yield (self._get_value_from_config(task_name, param_name), None)\n    yield (self._get_value_from_config(task_name, param_name.replace('_', '-')),\n           'Configuration [{}] {} (with dashes) should be avoided. Please use underscores.'.format(\n               task_name, param_name))\n    if self._config_path:\n        yield (self._get_value_from_config(self._config_path['section'], self._config_path['name']),\n               'The use of the configuration [{}] {} is deprecated. Please use [{}] {}'.format(\n                   self._config_path['section'], self._config_path['name'], task_name, param_name))\n    yield (self._default, None)",
                                "signature": "_value_iterator(self, task_name, param_name)"
                            },
                            {
                                "code": "def has_task_value(self, task_name, param_name):\n    return self._get_value(task_name, param_name) != _no_value",
                                "signature": "has_task_value(self, task_name, param_name)"
                            },
                            {
                                "code": "def task_value(self, task_name, param_name):\n    value = self._get_value(task_name, param_name)\n    if value == _no_value:\n        raise MissingParameterException(\"No default specified\")\n    else:\n        return self.normalize(value)",
                                "signature": "task_value(self, task_name, param_name)"
                            },
                            {
                                "code": "def _is_batchable(self):\n    return self._batch_method is not None",
                                "signature": "_is_batchable(self)"
                            },
                            {
                                "code": "def parse(self, x):\n    \"\"\"\n    Parse an individual value from the input.\n\n    The default implementation is the identity function, but subclasses should override\n    this method for specialized parsing.\n\n    :param str x: the value to parse.\n    :return: the parsed value.\n    \"\"\"\n    return x  # default impl",
                                "signature": "parse(self, x)"
                            },
                            {
                                "code": "def _parse_list(self, xs):\n    \"\"\"\n    Parse a list of values from the scheduler.\n\n    Only possible if this is_batchable() is True. This will combine the list into a single\n    parameter value using batch method. This should never need to be overridden.\n\n    :param xs: list of values to parse and combine\n    :return: the combined parsed values\n    \"\"\"\n    if not self._is_batchable():\n        raise NotImplementedError('No batch method found')\n    elif not xs:\n        raise ValueError('Empty parameter list passed to parse_list')\n    else:\n        return self._batch_method(map(self.parse, xs))",
                                "signature": "_parse_list(self, xs)"
                            },
                            {
                                "code": "def serialize(self, x):\n    \"\"\"\n    Opposite of :py:meth:`parse`.\n\n    Converts the value ``x`` to a string.\n\n    :param x: the value to serialize.\n    \"\"\"\n    return str(x)",
                                "signature": "serialize(self, x)"
                            },
                            {
                                "code": "def _warn_on_wrong_param_type(self, param_name, param_value):\n    if self.__class__ != Parameter:\n        return\n    if not isinstance(param_value, six.string_types):\n        warnings.warn('Parameter \"{}\" with value \"{}\" is not of type string.'.format(param_name, param_value))",
                                "signature": "_warn_on_wrong_param_type(self, param_name, param_value)"
                            },
                            {
                                "code": "def normalize(self, x):\n    \"\"\"\n    Given a parsed parameter value, normalizes it.\n\n    The value can either be the result of parse(), the default value or\n    arguments passed into the task's constructor by instantiation.\n\n    This is very implementation defined, but can be used to validate/clamp\n    valid values. For example, if you wanted to only accept even integers,\n    and \"correct\" odd values to the nearest integer, you can implement\n    normalize as ``x // 2 * 2``.\n    \"\"\"\n    return x  # default impl",
                                "signature": "normalize(self, x)"
                            },
                            {
                                "code": "def next_in_enumeration(self, _value):\n    \"\"\"\n    If your Parameter type has an enumerable ordering of values. You can\n    choose to override this method. This method is used by the\n    :py:mod:`luigi.execution_summary` module for pretty printing\n    purposes. Enabling it to pretty print tasks like ``MyTask(num=1),\n    MyTask(num=2), MyTask(num=3)`` to ``MyTask(num=1..3)``.\n\n    :param value: The value\n    :return: The next value, like \"value + 1\". Or ``None`` if there's no enumerable ordering.\n    \"\"\"\n    return None",
                                "signature": "next_in_enumeration(self, _value)"
                            },
                            {
                                "code": "def _parse_or_no_value(self, x):\n    if not x:\n        return _no_value\n    else:\n        return self.parse(x)",
                                "signature": "_parse_or_no_value(self, x)"
                            },
                            {
                                "code": "@staticmethod\ndef _parser_global_dest(param_name, task_name):\n    return task_name + '_' + param_name",
                                "signature": "_parser_global_dest(param_name, task_name)"
                            },
                            {
                                "code": "@classmethod\ndef _parser_kwargs(cls, param_name, task_name=None):\n    return {\n        \"action\": \"store\",\n        \"dest\": cls._parser_global_dest(param_name, task_name) if task_name else param_name,\n    }",
                                "signature": "_parser_kwargs(cls, param_name, task_name=None)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class OptionalParameter:",
                        "functions": [
                            {
                                "code": "def serialize(self, x):\n    if x is None:\n        return ''\n    else:\n        return str(x)",
                                "signature": "serialize(self, x)"
                            },
                            {
                                "code": "def parse(self, x):\n    return x or None",
                                "signature": "parse(self, x)"
                            },
                            {
                                "code": "def _warn_on_wrong_param_type(self, param_name, param_value):\n    if self.__class__ != OptionalParameter:\n        return\n    if not isinstance(param_value, six.string_types) and param_value is not None:\n        warnings.warn('OptionalParameter \"{}\" with value \"{}\" is not of type string or None.'.format(\n            param_name, param_value))",
                                "signature": "_warn_on_wrong_param_type(self, param_name, param_value)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class _DateParameterBase:",
                        "functions": [
                            {
                                "code": "def __init__(self, interval=1, start=None, **kwargs):\n    super(_DateParameterBase, self).__init__(**kwargs)\n    self.interval = interval\n    self.start = start if start is not None else _UNIX_EPOCH.date()",
                                "signature": "__init__(self, interval=1, start=None, **kwargs)"
                            },
                            {
                                "code": "@abc.abstractproperty\ndef date_format(self):\n    \"\"\"\n    Override me with a :py:meth:`~datetime.date.strftime` string.\n    \"\"\"\n    pass",
                                "signature": "date_format(self)"
                            },
                            {
                                "code": "def parse(self, s):\n    \"\"\"\n    Parses a date string formatted like ``YYYY-MM-DD``.\n    \"\"\"\n    return datetime.datetime.strptime(s, self.date_format).date()",
                                "signature": "parse(self, s)"
                            },
                            {
                                "code": "def serialize(self, dt):\n    \"\"\"\n    Converts the date to a string using the :py:attr:`~_DateParameterBase.date_format`.\n    \"\"\"\n    if dt is None:\n        return str(dt)\n    return dt.strftime(self.date_format)",
                                "signature": "serialize(self, dt)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class DateParameter:",
                        "functions": [
                            {
                                "code": "def next_in_enumeration(self, value):\n    return value + datetime.timedelta(days=self.interval)",
                                "signature": "next_in_enumeration(self, value)"
                            },
                            {
                                "code": "def normalize(self, value):\n    if value is None:\n        return None\n\n    if isinstance(value, datetime.datetime):\n        value = value.date()\n\n    delta = (value - self.start).days % self.interval\n    return value - datetime.timedelta(days=delta)",
                                "signature": "normalize(self, value)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class MonthParameter:",
                        "functions": [
                            {
                                "code": "def _add_months(self, date, months):\n    \"\"\"\n    Add ``months`` months to ``date``.\n\n    Unfortunately we can't use timedeltas to add months because timedelta counts in days\n    and there's no foolproof way to add N months in days without counting the number of\n    days per month.\n    \"\"\"\n    year = date.year + (date.month + months - 1) // 12\n    month = (date.month + months - 1) % 12 + 1\n    return datetime.date(year=year, month=month, day=1)",
                                "signature": "_add_months(self, date, months)"
                            },
                            {
                                "code": "def next_in_enumeration(self, value):\n    return self._add_months(value, self.interval)",
                                "signature": "next_in_enumeration(self, value)"
                            },
                            {
                                "code": "def normalize(self, value):\n    if value is None:\n        return None\n\n    if isinstance(value, date_interval.Month):\n        value = value.date_a\n\n    months_since_start = (value.year - self.start.year) * 12 + (value.month - self.start.month)\n    months_since_start -= months_since_start % self.interval\n\n    return self._add_months(self.start, months_since_start)",
                                "signature": "normalize(self, value)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class YearParameter:",
                        "functions": [
                            {
                                "code": "def next_in_enumeration(self, value):\n    return value.replace(year=value.year + self.interval)",
                                "signature": "next_in_enumeration(self, value)"
                            },
                            {
                                "code": "def normalize(self, value):\n    if value is None:\n        return None\n\n    if isinstance(value, date_interval.Year):\n        value = value.date_a\n\n    delta = (value.year - self.start.year) % self.interval\n    return datetime.date(year=value.year - delta, month=1, day=1)",
                                "signature": "normalize(self, value)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class _DatetimeParameterBase:",
                        "functions": [
                            {
                                "code": "def __init__(self, interval=1, start=None, **kwargs):\n    super(_DatetimeParameterBase, self).__init__(**kwargs)\n    self.interval = interval\n    self.start = start if start is not None else _UNIX_EPOCH",
                                "signature": "__init__(self, interval=1, start=None, **kwargs)"
                            },
                            {
                                "code": "@abc.abstractproperty\ndef date_format(self):\n    \"\"\"\n    Override me with a :py:meth:`~datetime.date.strftime` string.\n    \"\"\"\n    pass",
                                "signature": "date_format(self)"
                            },
                            {
                                "code": "@abc.abstractproperty\ndef _timedelta(self):\n    \"\"\"\n    How to move one interval of this type forward (i.e. not counting self.interval).\n    \"\"\"\n    pass",
                                "signature": "_timedelta(self)"
                            },
                            {
                                "code": "def parse(self, s):\n    \"\"\"\n    Parses a string to a :py:class:`~datetime.datetime`.\n    \"\"\"\n    return datetime.datetime.strptime(s, self.date_format)",
                                "signature": "parse(self, s)"
                            },
                            {
                                "code": "def serialize(self, dt):\n    \"\"\"\n    Converts the date to a string using the :py:attr:`~_DatetimeParameterBase.date_format`.\n    \"\"\"\n    if dt is None:\n        return str(dt)\n    return dt.strftime(self.date_format)",
                                "signature": "serialize(self, dt)"
                            },
                            {
                                "code": "@staticmethod\ndef _convert_to_dt(dt):\n    if not isinstance(dt, datetime.datetime):\n        dt = datetime.datetime.combine(dt, datetime.time.min)\n    return dt",
                                "signature": "_convert_to_dt(dt)"
                            },
                            {
                                "code": "def normalize(self, dt):\n    \"\"\"\n    Clamp dt to every Nth :py:attr:`~_DatetimeParameterBase.interval` starting at\n    :py:attr:`~_DatetimeParameterBase.start`.\n    \"\"\"\n    if dt is None:\n        return None\n\n    dt = self._convert_to_dt(dt)\n\n    dt = dt.replace(microsecond=0)  # remove microseconds, to avoid float rounding issues.\n    delta = (dt - self.start).total_seconds()\n    granularity = (self._timedelta * self.interval).total_seconds()\n    return dt - datetime.timedelta(seconds=delta % granularity)",
                                "signature": "normalize(self, dt)"
                            },
                            {
                                "code": "def next_in_enumeration(self, value):\n    return value + self._timedelta * self.interval",
                                "signature": "next_in_enumeration(self, value)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class DateHourParameter:",
                        "functions": []
                    },
                    {
                        "class_declaration": "class DateMinuteParameter:",
                        "functions": [
                            {
                                "code": "def parse(self, s):\n    try:\n        value = datetime.datetime.strptime(s, self.deprecated_date_format)\n        warnings.warn(\n            'Using \"H\" between hours and minutes is deprecated, omit it instead.',\n            DeprecationWarning,\n            stacklevel=2\n        )\n        return value\n    except ValueError:\n        return super(DateMinuteParameter, self).parse(s)",
                                "signature": "parse(self, s)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class DateSecondParameter:",
                        "functions": []
                    },
                    {
                        "class_declaration": "class IntParameter:",
                        "functions": [
                            {
                                "code": "def parse(self, s):\n    \"\"\"\n    Parses an ``int`` from the string using ``int()``.\n    \"\"\"\n    return int(s)",
                                "signature": "parse(self, s)"
                            },
                            {
                                "code": "def next_in_enumeration(self, value):\n    return value + 1",
                                "signature": "next_in_enumeration(self, value)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class FloatParameter:",
                        "functions": [
                            {
                                "code": "def parse(self, s):\n    \"\"\"\n    Parses a ``float`` from the string using ``float()``.\n    \"\"\"\n    return float(s)",
                                "signature": "parse(self, s)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class BoolParameter:",
                        "functions": [
                            {
                                "code": "def __init__(self, *args, **kwargs):\n    self.parsing = kwargs.pop(\"parsing\", self.__class__.parsing)\n    super(BoolParameter, self).__init__(*args, **kwargs)\n    if self._default == _no_value:\n        self._default = False",
                                "signature": "__init__(self, *args, **kwargs)"
                            },
                            {
                                "code": "def parse(self, val):\n    \"\"\"\n    Parses a ``bool`` from the string, matching 'true' or 'false' ignoring case.\n    \"\"\"\n    s = str(val).lower()\n    if s == \"true\":\n        return True\n    elif s == \"false\":\n        return False\n    else:\n        raise ValueError(\"cannot interpret '{}' as boolean\".format(val))",
                                "signature": "parse(self, val)"
                            },
                            {
                                "code": "def normalize(self, value):\n    try:\n        return self.parse(value)\n    except ValueError:\n        return None",
                                "signature": "normalize(self, value)"
                            },
                            {
                                "code": "def _parser_kwargs(self, *args, **kwargs):\n    parser_kwargs = super(BoolParameter, self)._parser_kwargs(*args, **kwargs)\n    if self.parsing == self.IMPLICIT_PARSING:\n        parser_kwargs[\"action\"] = \"store_true\"\n    elif self.parsing == self.EXPLICIT_PARSING:\n        parser_kwargs[\"nargs\"] = \"?\"\n        parser_kwargs[\"const\"] = True\n    else:\n        raise ValueError(\"unknown parsing value '{}'\".format(self.parsing))\n    return parser_kwargs",
                                "signature": "_parser_kwargs(self, *args, **kwargs)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class DateIntervalParameter:",
                        "functions": [
                            {
                                "code": "def parse(self, s):\n    \"\"\"\n    Parses a :py:class:`~luigi.date_interval.DateInterval` from the input.\n\n    see :py:mod:`luigi.date_interval`\n      for details on the parsing of DateIntervals.\n    \"\"\"\n    # TODO: can we use xml.utils.iso8601 or something similar?\n\n    from luigi import date_interval as d\n\n    for cls in [d.Year, d.Month, d.Week, d.Date, d.Custom]:\n        i = cls.parse(s)\n        if i:\n            return i\n\n    raise ValueError('Invalid date interval - could not be parsed')",
                                "signature": "parse(self, s)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class TimeDeltaParameter:",
                        "functions": [
                            {
                                "code": "def _apply_regex(self, regex, input):\n    import re\n    re_match = re.match(regex, input)\n    if re_match and any(re_match.groups()):\n        kwargs = {}\n        has_val = False\n        for k, v in six.iteritems(re_match.groupdict(default=\"0\")):\n            val = int(v)\n            if val > -1:\n                has_val = True\n                kwargs[k] = val\n        if has_val:\n            return datetime.timedelta(**kwargs)",
                                "signature": "_apply_regex(self, regex, input)"
                            },
                            {
                                "code": "def _parseIso8601(self, input):\n    def field(key):\n        return r\"(?P<%s>\\d+)%s\" % (key, key[0].upper())\n\n    def optional_field(key):\n        return \"(%s)?\" % field(key)\n\n    # A little loose: ISO 8601 does not allow weeks in combination with other fields, but this regex does (as does python timedelta)\n    regex = \"P(%s|%s(T%s)?)\" % (field(\"weeks\"), optional_field(\"days\"),\n                                \"\".join([optional_field(key) for key in [\"hours\", \"minutes\", \"seconds\"]]))\n    return self._apply_regex(regex, input)",
                                "signature": "_parseIso8601(self, input)"
                            },
                            {
                                "code": "def _parseSimple(self, input):\n    keys = [\"weeks\", \"days\", \"hours\", \"minutes\", \"seconds\"]\n    # Give the digits a regex group name from the keys, then look for text with the first letter of the key,\n    # optionally followed by the rest of the word, with final char (the \"s\") optional\n    regex = \"\".join([r\"((?P<%s>\\d+) ?%s(%s)?(%s)? ?)?\" % (k, k[0], k[1:-1], k[-1]) for k in keys])\n    return self._apply_regex(regex, input)",
                                "signature": "_parseSimple(self, input)"
                            },
                            {
                                "code": "def parse(self, input):\n    \"\"\"\n    Parses a time delta from the input.\n\n    See :py:class:`TimeDeltaParameter` for details on supported formats.\n    \"\"\"\n    result = self._parseIso8601(input)\n    if not result:\n        result = self._parseSimple(input)\n    if result is not None:\n        return result\n    else:\n        raise ParameterException(\"Invalid time delta - could not parse %s\" % input)",
                                "signature": "parse(self, input)"
                            },
                            {
                                "code": "def serialize(self, x):\n    \"\"\"\n    Converts datetime.timedelta to a string\n\n    :param x: the value to serialize.\n    \"\"\"\n    weeks = x.days // 7\n    days = x.days % 7\n    hours = x.seconds // 3600\n    minutes = (x.seconds % 3600) // 60\n    seconds = (x.seconds % 3600) % 60\n    result = \"{} w {} d {} h {} m {} s\".format(weeks, days, hours, minutes, seconds)\n    return result",
                                "signature": "serialize(self, x)"
                            },
                            {
                                "code": "def _warn_on_wrong_param_type(self, param_name, param_value):\n    if self.__class__ != TimeDeltaParameter:\n        return\n    if not isinstance(param_value, datetime.timedelta):\n        warnings.warn('Parameter \"{}\" with value \"{}\" is not of type timedelta.'.format(param_name, param_value))",
                                "signature": "_warn_on_wrong_param_type(self, param_name, param_value)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class TaskParameter:",
                        "functions": [
                            {
                                "code": "def parse(self, input):\n    \"\"\"\n    Parse a task_famly using the :class:`~luigi.task_register.Register`\n    \"\"\"\n    return task_register.Register.get_task_cls(input)",
                                "signature": "parse(self, input)"
                            },
                            {
                                "code": "def serialize(self, cls):\n    \"\"\"\n    Converts the :py:class:`luigi.task.Task` (sub) class to its family name.\n    \"\"\"\n    return cls.get_task_family()",
                                "signature": "serialize(self, cls)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class EnumParameter:",
                        "functions": [
                            {
                                "code": "def __init__(self, *args, **kwargs):\n    if 'enum' not in kwargs:\n        raise ParameterException('An enum class must be specified.')\n    self._enum = kwargs.pop('enum')\n    super(EnumParameter, self).__init__(*args, **kwargs)",
                                "signature": "__init__(self, *args, **kwargs)"
                            },
                            {
                                "code": "def parse(self, s):\n    try:\n        return self._enum[s]\n    except KeyError:\n        raise ValueError('Invalid enum value - could not be parsed')",
                                "signature": "parse(self, s)"
                            },
                            {
                                "code": "def serialize(self, e):\n    return e.name",
                                "signature": "serialize(self, e)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class _FrozenOrderedDict:",
                        "functions": [
                            {
                                "code": "def __init__(self, *args, **kwargs):\n    self.__dict = OrderedDict(*args, **kwargs)\n    self.__hash = None",
                                "signature": "__init__(self, *args, **kwargs)"
                            },
                            {
                                "code": "def __getitem__(self, key):\n    return self.__dict[key]",
                                "signature": "__getitem__(self, key)"
                            },
                            {
                                "code": "def __iter__(self):\n    return iter(self.__dict)",
                                "signature": "__iter__(self)"
                            },
                            {
                                "code": "def __len__(self):\n    return len(self.__dict)",
                                "signature": "__len__(self)"
                            },
                            {
                                "code": "def __repr__(self):\n    return '<FrozenOrderedDict %s>' % repr(self.__dict)",
                                "signature": "__repr__(self)"
                            },
                            {
                                "code": "def __hash__(self):\n    if self.__hash is None:\n        hashes = map(hash, self.items())\n        self.__hash = functools.reduce(operator.xor, hashes, 0)\n\n    return self.__hash",
                                "signature": "__hash__(self)"
                            },
                            {
                                "code": "def get_wrapped(self):\n    return self.__dict",
                                "signature": "get_wrapped(self)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class _DictParamEncoder:",
                        "functions": [
                            {
                                "code": "def default(self, obj):\n    if isinstance(obj, _FrozenOrderedDict):\n        return obj.get_wrapped()\n    return json.JSONEncoder.default(self, obj)",
                                "signature": "default(self, obj)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class DictParameter:",
                        "functions": [
                            {
                                "code": "def normalize(self, value):\n    \"\"\"\n    Ensure that dictionary parameter is converted to a _FrozenOrderedDict so it can be hashed.\n    \"\"\"\n    return _recursively_freeze(value)",
                                "signature": "normalize(self, value)"
                            },
                            {
                                "code": "def parse(self, s):\n    \"\"\"\n    Parses an immutable and ordered ``dict`` from a JSON string using standard JSON library.\n\n    We need to use an immutable dictionary, to create a hashable parameter and also preserve the internal structure\n    of parsing. The traversal order of standard ``dict`` is undefined, which can result various string\n    representations of this parameter, and therefore a different task id for the task containing this parameter.\n    This is because task id contains the hash of parameters' JSON representation.\n\n    :param s: String to be parse\n    \"\"\"\n    return json.loads(s, object_pairs_hook=_FrozenOrderedDict)",
                                "signature": "parse(self, s)"
                            },
                            {
                                "code": "def serialize(self, x):\n    return json.dumps(x, cls=_DictParamEncoder)",
                                "signature": "serialize(self, x)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class ListParameter:",
                        "functions": [
                            {
                                "code": "def normalize(self, x):\n    \"\"\"\n    Ensure that struct is recursively converted to a tuple so it can be hashed.\n\n    :param str x: the value to parse.\n    :return: the normalized (hashable/immutable) value.\n    \"\"\"\n    return _recursively_freeze(x)",
                                "signature": "normalize(self, x)"
                            },
                            {
                                "code": "def parse(self, x):\n    \"\"\"\n    Parse an individual value from the input.\n\n    :param str x: the value to parse.\n    :return: the parsed value.\n    \"\"\"\n    return list(json.loads(x, object_pairs_hook=_FrozenOrderedDict))",
                                "signature": "parse(self, x)"
                            },
                            {
                                "code": "def serialize(self, x):\n    \"\"\"\n    Opposite of :py:meth:`parse`.\n\n    Converts the value ``x`` to a string.\n\n    :param x: the value to serialize.\n    \"\"\"\n    return json.dumps(x, cls=_DictParamEncoder)",
                                "signature": "serialize(self, x)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class TupleParameter:",
                        "functions": [
                            {
                                "code": "def parse(self, x):\n    \"\"\"\n    Parse an individual value from the input.\n\n    :param str x: the value to parse.\n    :return: the parsed value.\n    \"\"\"\n    # Since the result of json.dumps(tuple) differs from a tuple string, we must handle either case.\n    # A tuple string may come from a config file or from cli execution.\n\n    # t = ((1, 2), (3, 4))\n    # t_str = '((1,2),(3,4))'\n    # t_json_str = json.dumps(t)\n    # t_json_str == '[[1, 2], [3, 4]]'\n    # json.loads(t_json_str) == t\n    # json.loads(t_str) == ValueError: No JSON object could be decoded\n\n    # Therefore, if json.loads(x) returns a ValueError, try ast.literal_eval(x).\n    # ast.literal_eval(t_str) == t\n    try:\n        # loop required to parse tuple of tuples\n        return tuple(tuple(x) for x in json.loads(x, object_pairs_hook=_FrozenOrderedDict))\n    except ValueError:\n        return literal_eval(x)  # if this causes an error, let that error be raised.",
                                "signature": "parse(self, x)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class NumericalParameter:",
                        "functions": [
                            {
                                "code": "def __init__(self, left_op=operator.le, right_op=operator.lt, *args, **kwargs):\n    \"\"\"\n    :param function var_type: The type of the input variable, e.g. int or float.\n    :param min_value: The minimum value permissible in the accepted values\n                      range.  May be inclusive or exclusive based on left_op parameter.\n                      This should be the same type as var_type.\n    :param max_value: The maximum value permissible in the accepted values\n                      range.  May be inclusive or exclusive based on right_op parameter.\n                      This should be the same type as var_type.\n    :param function left_op: The comparison operator for the left-most comparison in\n                             the expression ``min_value left_op value right_op value``.\n                             This operator should generally be either\n                             ``operator.lt`` or ``operator.le``.\n                             Default: ``operator.le``.\n    :param function right_op: The comparison operator for the right-most comparison in\n                              the expression ``min_value left_op value right_op value``.\n                              This operator should generally be either\n                              ``operator.lt`` or ``operator.le``.\n                              Default: ``operator.lt``.\n    \"\"\"\n    if \"var_type\" not in kwargs:\n        raise ParameterException(\"var_type must be specified\")\n    self._var_type = kwargs.pop(\"var_type\")\n    if \"min_value\" not in kwargs:\n        raise ParameterException(\"min_value must be specified\")\n    self._min_value = kwargs.pop(\"min_value\")\n    if \"max_value\" not in kwargs:\n        raise ParameterException(\"max_value must be specified\")\n    self._max_value = kwargs.pop(\"max_value\")\n    self._left_op = left_op\n    self._right_op = right_op\n    self._permitted_range = (\n        \"{var_type} in {left_endpoint}{min_value}, {max_value}{right_endpoint}\".format(\n            var_type=self._var_type.__name__,\n            min_value=self._min_value, max_value=self._max_value,\n            left_endpoint=\"[\" if left_op == operator.le else \"(\",\n            right_endpoint=\")\" if right_op == operator.lt else \"]\"))\n    super(NumericalParameter, self).__init__(*args, **kwargs)\n    if self.description:\n        self.description += \" \"\n    else:\n        self.description = \"\"\n    self.description += \"permitted values: \" + self._permitted_range",
                                "signature": "__init__(self, left_op=operator.le, right_op=operator.lt, *args, **kwargs)"
                            },
                            {
                                "code": "def parse(self, s):\n    value = self._var_type(s)\n    if (self._left_op(self._min_value, value) and self._right_op(value, self._max_value)):\n        return value\n    else:\n        raise ValueError(\n            \"{s} is not in the set of {permitted_range}\".format(\n                s=s, permitted_range=self._permitted_range))",
                                "signature": "parse(self, s)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class ChoiceParameter:",
                        "functions": [
                            {
                                "code": "def __init__(self, var_type=str, *args, **kwargs):\n    \"\"\"\n    :param function var_type: The type of the input variable, e.g. str, int,\n                              float, etc.\n                              Default: str\n    :param choices: An iterable, all of whose elements are of `var_type` to\n                    restrict parameter choices to.\n    \"\"\"\n    if \"choices\" not in kwargs:\n        raise ParameterException(\"A choices iterable must be specified\")\n    self._choices = set(kwargs.pop(\"choices\"))\n    self._var_type = var_type\n    assert all(type(choice) is self._var_type for choice in self._choices), \"Invalid type in choices\"\n    super(ChoiceParameter, self).__init__(*args, **kwargs)\n    if self.description:\n        self.description += \" \"\n    else:\n        self.description = \"\"\n    self.description += (\n        \"Choices: {\" + \", \".join(str(choice) for choice in self._choices) + \"}\")",
                                "signature": "__init__(self, var_type=str, *args, **kwargs)"
                            },
                            {
                                "code": "def parse(self, s):\n    var = self._var_type(s)\n    return self.normalize(var)",
                                "signature": "parse(self, s)"
                            },
                            {
                                "code": "def normalize(self, var):\n    if var in self._choices:\n        return var\n    else:\n        raise ValueError(\"{var} is not a valid choice from {choices}\".format(\n            var=var, choices=self._choices))",
                                "signature": "normalize(self, var)"
                            }
                        ]
                    }
                ]
            },
            "variables_in_file": {
                "ImportError": [
                    36
                ],
                "_no_value": [
                    196,
                    133,
                    230,
                    202,
                    234,
                    682,
                    45,
                    206,
                    316
                ],
                "object": [
                    93,
                    45
                ],
                "IntEnum": [
                    48
                ],
                "PUBLIC": [
                    53
                ],
                "HIDDEN": [
                    54
                ],
                "PRIVATE": [
                    55
                ],
                "any": [
                    59,
                    759
                ],
                "value": [
                    932,
                    421,
                    933,
                    934,
                    424,
                    935,
                    936,
                    427,
                    428,
                    1188,
                    430,
                    431,
                    559,
                    59,
                    699,
                    194,
                    198,
                    201,
                    202,
                    459,
                    205,
                    462,
                    592,
                    465,
                    466,
                    468,
                    598,
                    987,
                    1189,
                    1190,
                    486,
                    233,
                    234,
                    489,
                    492,
                    237,
                    493,
                    495,
                    496,
                    630
                ],
                "item.value": [
                    59
                ],
                "item": [
                    59
                ],
                "cls": [
                    736,
                    737,
                    328,
                    853,
                    59
                ],
                "classmethod": [
                    57,
                    324
                ],
                "self.value": [
                    62
                ],
                "self": [
                    527,
                    535,
                    551,
                    554,
                    555,
                    559,
                    62,
                    592,
                    600,
                    1165,
                    1168,
                    1171,
                    1172,
                    1173,
                    1174,
                    1176,
                    1177,
                    1180,
                    1181,
                    1182,
                    1184,
                    1185,
                    1188,
                    1189,
                    167,
                    168,
                    680,
                    681,
                    682,
                    683,
                    1194,
                    174,
                    175,
                    176,
                    178,
                    179,
                    183,
                    185,
                    699,
                    704,
                    705,
                    707,
                    198,
                    711,
                    201,
                    1232,
                    1233,
                    1234,
                    1235,
                    1236,
                    1237,
                    1239,
                    216,
                    1240,
                    218,
                    219,
                    220,
                    1241,
                    1244,
                    223,
                    224,
                    1245,
                    226,
                    227,
                    1248,
                    1252,
                    230,
                    233,
                    237,
                    240,
                    264,
                    780,
                    269,
                    787,
                    282,
                    795,
                    797,
                    818,
                    318,
                    345,
                    361,
                    362,
                    363,
                    882,
                    883,
                    887,
                    376,
                    384,
                    902,
                    903,
                    906,
                    909,
                    912,
                    915,
                    918,
                    919,
                    920,
                    922,
                    925,
                    421,
                    430,
                    947,
                    459,
                    468,
                    469,
                    471,
                    486,
                    495,
                    505,
                    506,
                    507
                ],
                "Exception": [
                    65
                ],
                "ParameterException": [
                    801,
                    72,
                    1164,
                    79,
                    1167,
                    881,
                    1170,
                    1231,
                    182,
                    86
                ],
                "_counter": [
                    131
                ],
                "ParameterVisibility.PUBLIC": [
                    176,
                    135
                ],
                "ParameterVisibility": [
                    176,
                    135
                ],
                "self._default": [
                    682,
                    227,
                    683,
                    167
                ],
                "default": [
                    167
                ],
                "self._batch_method": [
                    168,
                    240,
                    269
                ],
                "batch_method": [
                    168
                ],
                "is_global": [
                    169
                ],
                "warnings.warn": [
                    170,
                    204,
                    593,
                    821,
                    348,
                    285
                ],
                "warnings": [
                    170,
                    204,
                    593,
                    821,
                    348,
                    285
                ],
                "DeprecationWarning": [
                    595,
                    171,
                    204
                ],
                "positional": [
                    173,
                    175
                ],
                "self.significant": [
                    174
                ],
                "significant": [
                    174
                ],
                "self.positional": [
                    175
                ],
                "self.visibility": [
                    176
                ],
                "ParameterVisibility.has_value": [
                    176
                ],
                "visibility": [
                    176
                ],
                "self.description": [
                    1184,
                    1185,
                    178,
                    1236,
                    1237,
                    1239,
                    1240,
                    1181,
                    1182
                ],
                "description": [
                    178
                ],
                "self.always_in_help": [
                    179
                ],
                "always_in_help": [
                    179
                ],
                "config_path": [
                    181,
                    183
                ],
                "self._config_path": [
                    224,
                    223,
                    226,
                    183
                ],
                "self._counter": [
                    185
                ],
                "Parameter._counter": [
                    185,
                    186
                ],
                "Parameter": [
                    1121,
                    355,
                    645,
                    744,
                    618,
                    282,
                    332,
                    715,
                    1006,
                    1197,
                    633,
                    499,
                    856,
                    950,
                    824,
                    185,
                    186
                ],
                "conf": [
                    194,
                    191
                ],
                "configuration.get_config": [
                    191
                ],
                "configuration": [
                    191
                ],
                "conf.get": [
                    194
                ],
                "section": [
                    194
                ],
                "name": [
                    194
                ],
                "NoSectionError": [
                    195
                ],
                "NoOptionError": [
                    195
                ],
                "KeyError": [
                    888,
                    195
                ],
                "self.parse": [
                    318,
                    699,
                    269,
                    198
                ],
                "warn": [
                    201,
                    203,
                    204
                ],
                "self._value_iterator": [
                    201
                ],
                "task_name": [
                    226,
                    322,
                    230,
                    328,
                    201,
                    233,
                    216,
                    219,
                    220,
                    222
                ],
                "param_name": [
                    226,
                    322,
                    230,
                    328,
                    201,
                    233,
                    349,
                    821,
                    216,
                    219,
                    220,
                    285,
                    222
                ],
                "cp_parser": [
                    217,
                    214,
                    215
                ],
                "CmdlineParser.get_instance": [
                    214
                ],
                "CmdlineParser": [
                    214
                ],
                "dest": [
                    216,
                    217
                ],
                "self._parser_global_dest": [
                    216
                ],
                "found": [
                    217,
                    218
                ],
                "getattr": [
                    217
                ],
                "cp_parser.known_args": [
                    217
                ],
                "self._parse_or_no_value": [
                    218
                ],
                "self._get_value_from_config": [
                    224,
                    219,
                    220
                ],
                "param_name.replace": [
                    220
                ],
                "format": [
                    225,
                    1251,
                    711,
                    1193,
                    814,
                    821,
                    695,
                    221,
                    1175,
                    348,
                    285
                ],
                "self._get_value": [
                    233,
                    230
                ],
                "MissingParameterException": [
                    235
                ],
                "self.normalize": [
                    1245,
                    237
                ],
                "x": [
                    1044,
                    279,
                    1053,
                    1063,
                    809,
                    810,
                    299,
                    811,
                    812,
                    813,
                    315,
                    318,
                    336,
                    339,
                    342,
                    1116,
                    1118,
                    1003,
                    252
                ],
                "self._is_batchable": [
                    264
                ],
                "NotImplementedError": [
                    265
                ],
                "xs": [
                    266,
                    269
                ],
                "ValueError": [
                    1251,
                    741,
                    599,
                    711,
                    1192,
                    267,
                    695,
                    889,
                    700,
                    1117
                ],
                "map": [
                    269,
                    919
                ],
                "str": [
                    1222,
                    689,
                    339,
                    534,
                    279,
                    1241,
                    383
                ],
                "self.__class__": [
                    680,
                    345,
                    282,
                    818
                ],
                "isinstance": [
                    932,
                    934,
                    427,
                    492,
                    465,
                    945,
                    820,
                    539,
                    347,
                    284
                ],
                "param_value": [
                    820,
                    821,
                    285,
                    347,
                    284,
                    349
                ],
                "six.string_types": [
                    347,
                    284
                ],
                "six": [
                    762,
                    347,
                    284
                ],
                "staticmethod": [
                    320,
                    537
                ],
                "cls._parser_global_dest": [
                    328
                ],
                "OptionalParameter": [
                    345
                ],
                "_UNIX_EPOCH": [
                    352,
                    363,
                    507
                ],
                "datetime.datetime.utcfromtimestamp": [
                    352
                ],
                "datetime.datetime": [
                    352,
                    427,
                    527,
                    592,
                    376,
                    539,
                    540
                ],
                "datetime": [
                    352,
                    768,
                    421,
                    615,
                    456,
                    427,
                    556,
                    587,
                    431,
                    496,
                    527,
                    592,
                    820,
                    376,
                    539,
                    540,
                    572
                ],
                "__init__": [
                    361,
                    681,
                    883,
                    1235,
                    505,
                    1180
                ],
                "super": [
                    704,
                    361,
                    681,
                    883,
                    1235,
                    600,
                    505,
                    1180
                ],
                "_DateParameterBase": [
                    361,
                    387
                ],
                "kwargs": [
                    768,
                    902,
                    1163,
                    1165,
                    1166,
                    1168,
                    1169,
                    1171,
                    1180,
                    680,
                    681,
                    704,
                    1230,
                    1232,
                    1235,
                    361,
                    880,
                    882,
                    883,
                    760,
                    505,
                    766
                ],
                "self.interval": [
                    421,
                    486,
                    362,
                    459,
                    555,
                    430,
                    495,
                    559,
                    469,
                    506
                ],
                "interval": [
                    362,
                    506
                ],
                "self.start": [
                    554,
                    363,
                    430,
                    495,
                    468,
                    471,
                    507
                ],
                "start": [
                    363,
                    507
                ],
                "_UNIX_EPOCH.date": [
                    363
                ],
                "abc.abstractproperty": [
                    509,
                    516,
                    365
                ],
                "abc": [
                    509,
                    516,
                    365
                ],
                "date": [
                    376,
                    454,
                    455
                ],
                "datetime.datetime.strptime": [
                    376,
                    592,
                    527
                ],
                "s": [
                    737,
                    642,
                    1188,
                    1000,
                    1194,
                    600,
                    527,
                    592,
                    689,
                    690,
                    627,
                    692,
                    887,
                    376,
                    1244
                ],
                "self.date_format": [
                    376,
                    535,
                    384,
                    527
                ],
                "dt": [
                    384,
                    548,
                    551,
                    553,
                    554,
                    556,
                    533,
                    534,
                    535,
                    539,
                    540,
                    541,
                    382,
                    383
                ],
                "dt.strftime": [
                    384,
                    535
                ],
                "date_format": [
                    418,
                    483,
                    614,
                    586,
                    571,
                    444
                ],
                "datetime.timedelta": [
                    768,
                    421,
                    615,
                    587,
                    556,
                    431,
                    820,
                    572
                ],
                "value.date": [
                    428
                ],
                "delta": [
                    554,
                    556,
                    430,
                    495,
                    496,
                    431
                ],
                "days": [
                    814,
                    810,
                    430
                ],
                "DateParameter": [
                    474,
                    434
                ],
                "year": [
                    456,
                    454
                ],
                "date.year": [
                    454
                ],
                "date.month": [
                    454,
                    455
                ],
                "months": [
                    454,
                    455
                ],
                "month": [
                    456,
                    455
                ],
                "datetime.date": [
                    456,
                    496
                ],
                "self._add_months": [
                    459,
                    471
                ],
                "date_interval.Month": [
                    465
                ],
                "date_interval": [
                    465,
                    492
                ],
                "value.date_a": [
                    466,
                    493
                ],
                "months_since_start": [
                    468,
                    469,
                    471
                ],
                "value.year": [
                    496,
                    468,
                    486,
                    495
                ],
                "self.start.year": [
                    468,
                    495
                ],
                "value.month": [
                    468
                ],
                "self.start.month": [
                    468
                ],
                "value.replace": [
                    486
                ],
                "date_interval.Year": [
                    492
                ],
                "_DatetimeParameterBase": [
                    505,
                    562,
                    603,
                    575
                ],
                "datetime.datetime.combine": [
                    540
                ],
                "datetime.time.min": [
                    540
                ],
                "datetime.time": [
                    540
                ],
                "self._convert_to_dt": [
                    551
                ],
                "dt.replace": [
                    553
                ],
                "total_seconds": [
                    554,
                    555
                ],
                "granularity": [
                    555,
                    556
                ],
                "self._timedelta": [
                    555,
                    559
                ],
                "_timedelta": [
                    587,
                    572,
                    615
                ],
                "deprecated_date_format": [
                    588
                ],
                "self.deprecated_date_format": [
                    592
                ],
                "parse": [
                    600
                ],
                "DateMinuteParameter": [
                    600
                ],
                "int": [
                    627,
                    763
                ],
                "float": [
                    642
                ],
                "IMPLICIT_PARSING": [
                    674,
                    677
                ],
                "EXPLICIT_PARSING": [
                    675
                ],
                "parsing": [
                    677
                ],
                "self.parsing": [
                    680,
                    705,
                    707,
                    711
                ],
                "kwargs.pop": [
                    680,
                    1165,
                    1168,
                    1232,
                    882,
                    1171
                ],
                "self.__class__.parsing": [
                    680
                ],
                "BoolParameter": [
                    704,
                    681
                ],
                "args": [
                    704,
                    902,
                    681,
                    883,
                    1235,
                    1180
                ],
                "lower": [
                    689
                ],
                "val": [
                    689,
                    695,
                    763,
                    764,
                    766
                ],
                "parser_kwargs": [
                    704,
                    706,
                    708,
                    709,
                    712
                ],
                "_parser_kwargs": [
                    704
                ],
                "self.IMPLICIT_PARSING": [
                    705
                ],
                "self.EXPLICIT_PARSING": [
                    707
                ],
                "d.Year": [
                    736
                ],
                "d": [
                    736
                ],
                "d.Month": [
                    736
                ],
                "d.Week": [
                    736
                ],
                "d.Date": [
                    736
                ],
                "d.Custom": [
                    736
                ],
                "i": [
                    737,
                    738,
                    739
                ],
                "cls.parse": [
                    737
                ],
                "re_match": [
                    762,
                    758,
                    759
                ],
                "re.match": [
                    758
                ],
                "re": [
                    758
                ],
                "regex": [
                    778,
                    780,
                    786,
                    787,
                    758
                ],
                "input": [
                    801,
                    780,
                    847,
                    787,
                    758,
                    795,
                    797
                ],
                "re_match.groups": [
                    759
                ],
                "has_val": [
                    761,
                    765,
                    767
                ],
                "k": [
                    762,
                    786,
                    933,
                    766
                ],
                "v": [
                    762,
                    763,
                    933,
                    935
                ],
                "six.iteritems": [
                    762
                ],
                "re_match.groupdict": [
                    762
                ],
                "key": [
                    906,
                    779,
                    772,
                    775
                ],
                "upper": [
                    772
                ],
                "field": [
                    778,
                    775
                ],
                "optional_field": [
                    778,
                    779
                ],
                "join": [
                    1241,
                    786,
                    779
                ],
                "self._apply_regex": [
                    787,
                    780
                ],
                "keys": [
                    786,
                    783
                ],
                "result": [
                    814,
                    815,
                    795,
                    796,
                    797,
                    798,
                    799
                ],
                "self._parseIso8601": [
                    795
                ],
                "self._parseSimple": [
                    797
                ],
                "weeks": [
                    809,
                    814
                ],
                "x.days": [
                    809,
                    810
                ],
                "hours": [
                    811,
                    814
                ],
                "x.seconds": [
                    811,
                    812,
                    813
                ],
                "minutes": [
                    812,
                    814
                ],
                "seconds": [
                    813,
                    814
                ],
                "TimeDeltaParameter": [
                    818
                ],
                "task_register.Register.get_task_cls": [
                    847
                ],
                "task_register.Register": [
                    847
                ],
                "task_register": [
                    847
                ],
                "cls.get_task_family": [
                    853
                ],
                "self._enum": [
                    882,
                    887
                ],
                "EnumParameter": [
                    883
                ],
                "e.name": [
                    892
                ],
                "e": [
                    892
                ],
                "Mapping": [
                    932,
                    895
                ],
                "self.__dict": [
                    902,
                    906,
                    909,
                    912,
                    915,
                    925
                ],
                "OrderedDict": [
                    902
                ],
                "self.__hash": [
                    920,
                    922,
                    918,
                    903
                ],
                "iter": [
                    909
                ],
                "len": [
                    912
                ],
                "repr": [
                    915
                ],
                "hashes": [
                    920,
                    919
                ],
                "hash": [
                    919
                ],
                "self.items": [
                    919
                ],
                "functools.reduce": [
                    920
                ],
                "functools": [
                    920
                ],
                "operator.xor": [
                    920
                ],
                "operator": [
                    920,
                    1178,
                    1179,
                    1143
                ],
                "_FrozenOrderedDict": [
                    933,
                    1000,
                    945,
                    1116,
                    1053
                ],
                "_recursively_freeze": [
                    987,
                    1044,
                    933,
                    935
                ],
                "value.items": [
                    933
                ],
                "list": [
                    1053,
                    934
                ],
                "tuple": [
                    1116,
                    934,
                    935
                ],
                "JSONEncoder": [
                    939
                ],
                "obj": [
                    945,
                    946,
                    947
                ],
                "obj.get_wrapped": [
                    946
                ],
                "json.JSONEncoder.default": [
                    947
                ],
                "json.JSONEncoder": [
                    947
                ],
                "json": [
                    1063,
                    1000,
                    1003,
                    947,
                    1116,
                    1053
                ],
                "json.loads": [
                    1000,
                    1116,
                    1053
                ],
                "json.dumps": [
                    1003,
                    1063
                ],
                "_DictParamEncoder": [
                    1003,
                    1063
                ],
                "ListParameter": [
                    1066
                ],
                "literal_eval": [
                    1118
                ],
                "operator.le": [
                    1178,
                    1143
                ],
                "operator.lt": [
                    1179,
                    1143
                ],
                "self._var_type": [
                    1188,
                    1165,
                    1233,
                    1234,
                    1176,
                    1244
                ],
                "self._min_value": [
                    1168,
                    1177,
                    1189
                ],
                "self._max_value": [
                    1177,
                    1171,
                    1189
                ],
                "self._left_op": [
                    1172,
                    1189
                ],
                "left_op": [
                    1178,
                    1172
                ],
                "self._right_op": [
                    1173,
                    1189
                ],
                "right_op": [
                    1179,
                    1173
                ],
                "self._permitted_range": [
                    1185,
                    1194,
                    1174
                ],
                "self._var_type.__name__": [
                    1176
                ],
                "NumericalParameter": [
                    1180
                ],
                "self._choices": [
                    1248,
                    1252,
                    1232,
                    1234,
                    1241
                ],
                "set": [
                    1232
                ],
                "var_type": [
                    1233
                ],
                "all": [
                    1234
                ],
                "type": [
                    1234
                ],
                "choice": [
                    1241,
                    1234
                ],
                "ChoiceParameter": [
                    1235
                ],
                "var": [
                    1248,
                    1249,
                    1252,
                    1244,
                    1245
                ]
            },
            "filtered_variables_in_file": {
                "_no_value": [
                    196,
                    133,
                    230,
                    202,
                    234,
                    682,
                    45,
                    206,
                    316
                ],
                "IntEnum": [
                    48
                ],
                "PUBLIC": [
                    53
                ],
                "HIDDEN": [
                    54
                ],
                "PRIVATE": [
                    55
                ],
                "value": [
                    932,
                    421,
                    933,
                    934,
                    424,
                    935,
                    936,
                    427,
                    428,
                    1188,
                    430,
                    431,
                    559,
                    59,
                    699,
                    194,
                    198,
                    201,
                    202,
                    459,
                    205,
                    462,
                    592,
                    465,
                    466,
                    468,
                    598,
                    987,
                    1189,
                    1190,
                    486,
                    233,
                    234,
                    489,
                    492,
                    237,
                    493,
                    495,
                    496,
                    630
                ],
                "item.value": [
                    59
                ],
                "item": [
                    59
                ],
                "cls": [
                    736,
                    737,
                    328,
                    853,
                    59
                ],
                "self.value": [
                    62
                ],
                "self": [
                    527,
                    535,
                    551,
                    554,
                    555,
                    559,
                    62,
                    592,
                    600,
                    1165,
                    1168,
                    1171,
                    1172,
                    1173,
                    1174,
                    1176,
                    1177,
                    1180,
                    1181,
                    1182,
                    1184,
                    1185,
                    1188,
                    1189,
                    167,
                    168,
                    680,
                    681,
                    682,
                    683,
                    1194,
                    174,
                    175,
                    176,
                    178,
                    179,
                    183,
                    185,
                    699,
                    704,
                    705,
                    707,
                    198,
                    711,
                    201,
                    1232,
                    1233,
                    1234,
                    1235,
                    1236,
                    1237,
                    1239,
                    216,
                    1240,
                    218,
                    219,
                    220,
                    1241,
                    1244,
                    223,
                    224,
                    1245,
                    226,
                    227,
                    1248,
                    1252,
                    230,
                    233,
                    237,
                    240,
                    264,
                    780,
                    269,
                    787,
                    282,
                    795,
                    797,
                    818,
                    318,
                    345,
                    361,
                    362,
                    363,
                    882,
                    883,
                    887,
                    376,
                    384,
                    902,
                    903,
                    906,
                    909,
                    912,
                    915,
                    918,
                    919,
                    920,
                    922,
                    925,
                    421,
                    430,
                    947,
                    459,
                    468,
                    469,
                    471,
                    486,
                    495,
                    505,
                    506,
                    507
                ],
                "ParameterException": [
                    801,
                    72,
                    1164,
                    79,
                    1167,
                    881,
                    1170,
                    1231,
                    182,
                    86
                ],
                "_counter": [
                    131
                ],
                "ParameterVisibility.PUBLIC": [
                    176,
                    135
                ],
                "ParameterVisibility": [
                    176,
                    135
                ],
                "self._default": [
                    682,
                    227,
                    683,
                    167
                ],
                "default": [
                    167
                ],
                "self._batch_method": [
                    168,
                    240,
                    269
                ],
                "batch_method": [
                    168
                ],
                "is_global": [
                    169
                ],
                "warnings.warn": [
                    170,
                    204,
                    593,
                    821,
                    348,
                    285
                ],
                "warnings": [
                    170,
                    204,
                    593,
                    821,
                    348,
                    285
                ],
                "positional": [
                    173,
                    175
                ],
                "self.significant": [
                    174
                ],
                "significant": [
                    174
                ],
                "self.positional": [
                    175
                ],
                "self.visibility": [
                    176
                ],
                "ParameterVisibility.has_value": [
                    176
                ],
                "visibility": [
                    176
                ],
                "self.description": [
                    1184,
                    1185,
                    178,
                    1236,
                    1237,
                    1239,
                    1240,
                    1181,
                    1182
                ],
                "description": [
                    178
                ],
                "self.always_in_help": [
                    179
                ],
                "always_in_help": [
                    179
                ],
                "config_path": [
                    181,
                    183
                ],
                "self._config_path": [
                    224,
                    223,
                    226,
                    183
                ],
                "self._counter": [
                    185
                ],
                "Parameter._counter": [
                    185,
                    186
                ],
                "Parameter": [
                    1121,
                    355,
                    645,
                    744,
                    618,
                    282,
                    332,
                    715,
                    1006,
                    1197,
                    633,
                    499,
                    856,
                    950,
                    824,
                    185,
                    186
                ],
                "conf": [
                    194,
                    191
                ],
                "configuration.get_config": [
                    191
                ],
                "configuration": [
                    191
                ],
                "conf.get": [
                    194
                ],
                "section": [
                    194
                ],
                "name": [
                    194
                ],
                "NoSectionError": [
                    195
                ],
                "NoOptionError": [
                    195
                ],
                "self.parse": [
                    318,
                    699,
                    269,
                    198
                ],
                "warn": [
                    201,
                    203,
                    204
                ],
                "self._value_iterator": [
                    201
                ],
                "task_name": [
                    226,
                    322,
                    230,
                    328,
                    201,
                    233,
                    216,
                    219,
                    220,
                    222
                ],
                "param_name": [
                    226,
                    322,
                    230,
                    328,
                    201,
                    233,
                    349,
                    821,
                    216,
                    219,
                    220,
                    285,
                    222
                ],
                "cp_parser": [
                    217,
                    214,
                    215
                ],
                "CmdlineParser.get_instance": [
                    214
                ],
                "CmdlineParser": [
                    214
                ],
                "dest": [
                    216,
                    217
                ],
                "self._parser_global_dest": [
                    216
                ],
                "found": [
                    217,
                    218
                ],
                "cp_parser.known_args": [
                    217
                ],
                "self._parse_or_no_value": [
                    218
                ],
                "self._get_value_from_config": [
                    224,
                    219,
                    220
                ],
                "param_name.replace": [
                    220
                ],
                "self._get_value": [
                    233,
                    230
                ],
                "MissingParameterException": [
                    235
                ],
                "self.normalize": [
                    1245,
                    237
                ],
                "x": [
                    1044,
                    279,
                    1053,
                    1063,
                    809,
                    810,
                    299,
                    811,
                    812,
                    813,
                    315,
                    318,
                    336,
                    339,
                    342,
                    1116,
                    1118,
                    1003,
                    252
                ],
                "self._is_batchable": [
                    264
                ],
                "xs": [
                    266,
                    269
                ],
                "self.__class__": [
                    680,
                    345,
                    282,
                    818
                ],
                "param_value": [
                    820,
                    821,
                    285,
                    347,
                    284,
                    349
                ],
                "six.string_types": [
                    347,
                    284
                ],
                "six": [
                    762,
                    347,
                    284
                ],
                "cls._parser_global_dest": [
                    328
                ],
                "OptionalParameter": [
                    345
                ],
                "_UNIX_EPOCH": [
                    352,
                    363,
                    507
                ],
                "datetime.datetime.utcfromtimestamp": [
                    352
                ],
                "datetime.datetime": [
                    352,
                    427,
                    527,
                    592,
                    376,
                    539,
                    540
                ],
                "datetime": [
                    352,
                    768,
                    421,
                    615,
                    456,
                    427,
                    556,
                    587,
                    431,
                    496,
                    527,
                    592,
                    820,
                    376,
                    539,
                    540,
                    572
                ],
                "__init__": [
                    361,
                    681,
                    883,
                    1235,
                    505,
                    1180
                ],
                "_DateParameterBase": [
                    361,
                    387
                ],
                "kwargs": [
                    768,
                    902,
                    1163,
                    1165,
                    1166,
                    1168,
                    1169,
                    1171,
                    1180,
                    680,
                    681,
                    704,
                    1230,
                    1232,
                    1235,
                    361,
                    880,
                    882,
                    883,
                    760,
                    505,
                    766
                ],
                "self.interval": [
                    421,
                    486,
                    362,
                    459,
                    555,
                    430,
                    495,
                    559,
                    469,
                    506
                ],
                "interval": [
                    362,
                    506
                ],
                "self.start": [
                    554,
                    363,
                    430,
                    495,
                    468,
                    471,
                    507
                ],
                "start": [
                    363,
                    507
                ],
                "_UNIX_EPOCH.date": [
                    363
                ],
                "abc.abstractproperty": [
                    509,
                    516,
                    365
                ],
                "abc": [
                    509,
                    516,
                    365
                ],
                "date": [
                    376,
                    454,
                    455
                ],
                "datetime.datetime.strptime": [
                    376,
                    592,
                    527
                ],
                "s": [
                    737,
                    642,
                    1188,
                    1000,
                    1194,
                    600,
                    527,
                    592,
                    689,
                    690,
                    627,
                    692,
                    887,
                    376,
                    1244
                ],
                "self.date_format": [
                    376,
                    535,
                    384,
                    527
                ],
                "dt": [
                    384,
                    548,
                    551,
                    553,
                    554,
                    556,
                    533,
                    534,
                    535,
                    539,
                    540,
                    541,
                    382,
                    383
                ],
                "dt.strftime": [
                    384,
                    535
                ],
                "date_format": [
                    418,
                    483,
                    614,
                    586,
                    571,
                    444
                ],
                "datetime.timedelta": [
                    768,
                    421,
                    615,
                    587,
                    556,
                    431,
                    820,
                    572
                ],
                "value.date": [
                    428
                ],
                "delta": [
                    554,
                    556,
                    430,
                    495,
                    496,
                    431
                ],
                "days": [
                    814,
                    810,
                    430
                ],
                "DateParameter": [
                    474,
                    434
                ],
                "year": [
                    456,
                    454
                ],
                "date.year": [
                    454
                ],
                "date.month": [
                    454,
                    455
                ],
                "months": [
                    454,
                    455
                ],
                "month": [
                    456,
                    455
                ],
                "datetime.date": [
                    456,
                    496
                ],
                "self._add_months": [
                    459,
                    471
                ],
                "date_interval.Month": [
                    465
                ],
                "date_interval": [
                    465,
                    492
                ],
                "value.date_a": [
                    466,
                    493
                ],
                "months_since_start": [
                    468,
                    469,
                    471
                ],
                "value.year": [
                    496,
                    468,
                    486,
                    495
                ],
                "self.start.year": [
                    468,
                    495
                ],
                "value.month": [
                    468
                ],
                "self.start.month": [
                    468
                ],
                "value.replace": [
                    486
                ],
                "date_interval.Year": [
                    492
                ],
                "_DatetimeParameterBase": [
                    505,
                    562,
                    603,
                    575
                ],
                "datetime.datetime.combine": [
                    540
                ],
                "datetime.time.min": [
                    540
                ],
                "datetime.time": [
                    540
                ],
                "self._convert_to_dt": [
                    551
                ],
                "dt.replace": [
                    553
                ],
                "total_seconds": [
                    554,
                    555
                ],
                "granularity": [
                    555,
                    556
                ],
                "self._timedelta": [
                    555,
                    559
                ],
                "_timedelta": [
                    587,
                    572,
                    615
                ],
                "deprecated_date_format": [
                    588
                ],
                "self.deprecated_date_format": [
                    592
                ],
                "parse": [
                    600
                ],
                "DateMinuteParameter": [
                    600
                ],
                "IMPLICIT_PARSING": [
                    674,
                    677
                ],
                "EXPLICIT_PARSING": [
                    675
                ],
                "parsing": [
                    677
                ],
                "self.parsing": [
                    680,
                    705,
                    707,
                    711
                ],
                "kwargs.pop": [
                    680,
                    1165,
                    1168,
                    1232,
                    882,
                    1171
                ],
                "self.__class__.parsing": [
                    680
                ],
                "BoolParameter": [
                    704,
                    681
                ],
                "args": [
                    704,
                    902,
                    681,
                    883,
                    1235,
                    1180
                ],
                "lower": [
                    689
                ],
                "val": [
                    689,
                    695,
                    763,
                    764,
                    766
                ],
                "parser_kwargs": [
                    704,
                    706,
                    708,
                    709,
                    712
                ],
                "_parser_kwargs": [
                    704
                ],
                "self.IMPLICIT_PARSING": [
                    705
                ],
                "self.EXPLICIT_PARSING": [
                    707
                ],
                "d.Year": [
                    736
                ],
                "d": [
                    736
                ],
                "d.Month": [
                    736
                ],
                "d.Week": [
                    736
                ],
                "d.Date": [
                    736
                ],
                "d.Custom": [
                    736
                ],
                "i": [
                    737,
                    738,
                    739
                ],
                "cls.parse": [
                    737
                ],
                "re_match": [
                    762,
                    758,
                    759
                ],
                "re.match": [
                    758
                ],
                "re": [
                    758
                ],
                "regex": [
                    778,
                    780,
                    786,
                    787,
                    758
                ],
                "re_match.groups": [
                    759
                ],
                "has_val": [
                    761,
                    765,
                    767
                ],
                "k": [
                    762,
                    786,
                    933,
                    766
                ],
                "v": [
                    762,
                    763,
                    933,
                    935
                ],
                "six.iteritems": [
                    762
                ],
                "re_match.groupdict": [
                    762
                ],
                "key": [
                    906,
                    779,
                    772,
                    775
                ],
                "upper": [
                    772
                ],
                "field": [
                    778,
                    775
                ],
                "optional_field": [
                    778,
                    779
                ],
                "join": [
                    1241,
                    786,
                    779
                ],
                "self._apply_regex": [
                    787,
                    780
                ],
                "keys": [
                    786,
                    783
                ],
                "result": [
                    814,
                    815,
                    795,
                    796,
                    797,
                    798,
                    799
                ],
                "self._parseIso8601": [
                    795
                ],
                "self._parseSimple": [
                    797
                ],
                "weeks": [
                    809,
                    814
                ],
                "x.days": [
                    809,
                    810
                ],
                "hours": [
                    811,
                    814
                ],
                "x.seconds": [
                    811,
                    812,
                    813
                ],
                "minutes": [
                    812,
                    814
                ],
                "seconds": [
                    813,
                    814
                ],
                "TimeDeltaParameter": [
                    818
                ],
                "task_register.Register.get_task_cls": [
                    847
                ],
                "task_register.Register": [
                    847
                ],
                "task_register": [
                    847
                ],
                "cls.get_task_family": [
                    853
                ],
                "self._enum": [
                    882,
                    887
                ],
                "EnumParameter": [
                    883
                ],
                "e.name": [
                    892
                ],
                "e": [
                    892
                ],
                "Mapping": [
                    932,
                    895
                ],
                "self.__dict": [
                    902,
                    906,
                    909,
                    912,
                    915,
                    925
                ],
                "OrderedDict": [
                    902
                ],
                "self.__hash": [
                    920,
                    922,
                    918,
                    903
                ],
                "hashes": [
                    920,
                    919
                ],
                "self.items": [
                    919
                ],
                "functools.reduce": [
                    920
                ],
                "functools": [
                    920
                ],
                "operator.xor": [
                    920
                ],
                "operator": [
                    920,
                    1178,
                    1179,
                    1143
                ],
                "_FrozenOrderedDict": [
                    933,
                    1000,
                    945,
                    1116,
                    1053
                ],
                "_recursively_freeze": [
                    987,
                    1044,
                    933,
                    935
                ],
                "value.items": [
                    933
                ],
                "JSONEncoder": [
                    939
                ],
                "obj": [
                    945,
                    946,
                    947
                ],
                "obj.get_wrapped": [
                    946
                ],
                "json.JSONEncoder.default": [
                    947
                ],
                "json.JSONEncoder": [
                    947
                ],
                "json": [
                    1063,
                    1000,
                    1003,
                    947,
                    1116,
                    1053
                ],
                "json.loads": [
                    1000,
                    1116,
                    1053
                ],
                "json.dumps": [
                    1003,
                    1063
                ],
                "_DictParamEncoder": [
                    1003,
                    1063
                ],
                "ListParameter": [
                    1066
                ],
                "literal_eval": [
                    1118
                ],
                "operator.le": [
                    1178,
                    1143
                ],
                "operator.lt": [
                    1179,
                    1143
                ],
                "self._var_type": [
                    1188,
                    1165,
                    1233,
                    1234,
                    1176,
                    1244
                ],
                "self._min_value": [
                    1168,
                    1177,
                    1189
                ],
                "self._max_value": [
                    1177,
                    1171,
                    1189
                ],
                "self._left_op": [
                    1172,
                    1189
                ],
                "left_op": [
                    1178,
                    1172
                ],
                "self._right_op": [
                    1173,
                    1189
                ],
                "right_op": [
                    1179,
                    1173
                ],
                "self._permitted_range": [
                    1185,
                    1194,
                    1174
                ],
                "self._var_type.__name__": [
                    1176
                ],
                "NumericalParameter": [
                    1180
                ],
                "self._choices": [
                    1248,
                    1252,
                    1232,
                    1234,
                    1241
                ],
                "var_type": [
                    1233
                ],
                "choice": [
                    1241,
                    1234
                ],
                "ChoiceParameter": [
                    1235
                ],
                "var": [
                    1248,
                    1249,
                    1252,
                    1244,
                    1245
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/home/ubuntu/Desktop/bgp_envs_local/repos/luigi_3/test/parameter_test.py",
                "test_function": "testSerialize",
                "test_function_code": "    def testSerialize(self):\n        date = datetime.date(2013, 2, 3)\n        self.assertEqual(luigi.DateParameter().serialize(date), '2013-02-03')\n        self.assertEqual(luigi.YearParameter().serialize(date), '2013')\n        self.assertEqual(luigi.MonthParameter().serialize(date), '2013-02')\n        dt = datetime.datetime(2013, 2, 3, 4, 5)\n        self.assertEqual(luigi.DateHourParameter().serialize(dt), '2013-02-03T04')",
                "test_error": "TypeError: 'int' object is not iterable",
                "full_test_error": "self = <parameter_test.TestSerializeTupleParameter testMethod=testSerialize>\n\n    def testSerialize(self):\n        the_tuple = (1, 2, 3)\n    \n>       self.assertEqual(luigi.TupleParameter().parse(luigi.TupleParameter().serialize(the_tuple)), the_tuple)\n\ntest/parameter_test.py:1106: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nluigi/parameter.py:1116: in parse\n    return tuple(tuple(x) for x in json.loads(x, object_pairs_hook=_FrozenOrderedDict))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n.0 = <list_iterator object at 0x7f42345eeaf0>\n\n>   return tuple(tuple(x) for x in json.loads(x, object_pairs_hook=_FrozenOrderedDict))\nE   TypeError: 'int' object is not iterable\n\nluigi/parameter.py:1116: TypeError",
                "traceback": "luigi/parameter.py:1116: in parse\n    return tuple(tuple(x) for x in json.loads(x, object_pairs_hook=_FrozenOrderedDict))",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n.0 = <list_iterator object at 0x7f42345eeaf0>\n\n>   return tuple(tuple(x) for x in json.loads(x, object_pairs_hook=_FrozenOrderedDict))\nE   TypeError: 'int' object is not iterable\n\nluigi/parameter.py:1116: TypeError",
                "test_function_decorators": []
            }
        ]
    }
}