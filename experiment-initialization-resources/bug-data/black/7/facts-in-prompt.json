{
    "1": "    def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:\n        \"\"\"Make existing optional parentheses invisible or create new ones.\n    \n        `parens_after` is a set of string leaf values immeditely after which parens\n        should be put.\n    \n        Standardizes on visible parentheses for single-element tuples, and keeps\n        existing visible parentheses for other tuples and generator expressions.\n        \"\"\"\n        for pc in list_comments(node.prefix, is_endmarker=False):\n            if pc.value in FMT_OFF:\n                # This `node` has a prefix with `# fmt: off`, don't mess with parens.\n                return\n    \n        check_lpar = False\n        for index, child in enumerate(list(node.children)):\n            if check_lpar:\n                if child.type == syms.atom:\n                    if maybe_make_parens_invisible_in_atom(child, parent=node):\n                        lpar = Leaf(token.LPAR, \"\")\n                        rpar = Leaf(token.RPAR, \"\")\n                        index = child.remove() or 0\n                        node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))\n                elif is_one_tuple(child):\n                    # wrap child in visible parentheses\n                    lpar = Leaf(token.LPAR, \"(\")\n                    rpar = Leaf(token.RPAR, \")\")\n                    child.remove()\n                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))\n                elif node.type == syms.import_from:\n                    # \"import from\" nodes store parentheses directly as part of\n                    # the statement\n                    if child.type == token.LPAR:\n                        # make parentheses invisible\n                        child.value = \"\"  # type: ignore\n                        node.children[-1].value = \"\"  # type: ignore\n                    elif child.type != token.STAR:\n                        # insert invisible parentheses\n                        node.insert_child(index, Leaf(token.LPAR, \"\"))\n                        node.append_child(Leaf(token.RPAR, \"\"))\n                    break\n    \n                elif not (isinstance(child, Leaf) and is_multiline_string(child)):\n                    # wrap child in invisible parentheses\n                    lpar = Leaf(token.LPAR, \"\")\n                    rpar = Leaf(token.RPAR, \"\")\n                    index = child.remove() or 0\n                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))\n    \n            check_lpar = isinstance(child, Leaf) and child.value in parens_after\n    \n",
    "2": "",
    "3": "# file name: /Volumes/SSD2T/bgp_envs/repos/black_7/black.py\n\n# relative function's signature in this file\ndef list_comments(prefix: str) -> List[ProtoComment]:\n    # ... omitted code ...\n    pass\n\n# relative function's signature in this file\ndef maybe_make_parens_invisible_in_atom(node: LN, parent: LN) -> bool:\n    # ... omitted code ...\n    pass\n\n# relative function's signature in this file\ndef is_one_tuple(node: LN) -> bool:\n    # ... omitted code ...\n    pass\n\n# relative function's signature in this file\ndef is_multiline_string(leaf: Leaf) -> bool:\n    # ... omitted code ...\n    pass\n\n",
    "4": "# A test function for the buggy function\n```python\n# file name: /Volumes/SSD2T/bgp_envs/repos/black_7/tests/test_black.py\n\n    @patch(\"black.dump_to_file\", dump_to_stderr)\n    def test_tuple_assign(self) -> None:\n        source, expected = read_data(\"tupleassign\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())\n```\n\n## Error message from test function\n```text\nself = <test_black.BlackTestCase testMethod=test_tuple_assign>\n\n    @patch(\"black.dump_to_file\", dump_to_stderr)\n    def test_tuple_assign(self) -> None:\n        source, expected = read_data(\"tupleassign\")\n        actual = fs(source)\n>       self.assertFormatEqual(expected, actual)\n\ntests/test_black.py:549: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/test_black.py:159: in assertFormatEqual\n    self.assertEqual(expected, actual)\nE   AssertionError: '(\\n    sdfjklsdfsjldkflkjsf,\\n    sdfjsdf[81 chars]3)\\n' != 'sdfjklsdfsjldkflkjsf, sdfjsdfjlksdljkfsdl[74 chars]n)\\n'\nE   + sdfjklsdfsjldkflkjsf, sdfjsdfjlksdljkfsdlkf, sdfsdjfklsdfjlksdljkf, sdsfsdfjskdflsfsdf = (\nE   +     1,\nE   +     2,\nE   +     3,\nE   + )\nE   - (\nE   -     sdfjklsdfsjldkflkjsf,\nE   -     sdfjsdfjlksdljkfsdlkf,\nE   -     sdfsdjfklsdfjlksdljkf,\nE   -     sdsfsdfjskdflsfsdf,\nE   - ) = (1, 2, 3)\n\n```\n",
    "5": "# Variable runtime value and type inside buggy function\n## Buggy case 1\n### input parameter runtime value and type for buggy function\nnode.prefix, value: `''`, type: `str`\n\nnode, value: `Node(expr_stmt, [Node(testlist_star_expr, [Leaf(NAME, 'sdfjklsdfsjldkflkjsf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfjsdfjlksdljkfsdlkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfsdjfklsdfjlksdljkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdsfsdfjskdflsfsdf')]), Leaf(EQUAL, '='), Node(testlist_star_expr, [Leaf(NUMBER, '1'), Leaf(COMMA, ','), Leaf(NUMBER, '2'), Leaf(COMMA, ','), Leaf(NUMBER, '3')])])`, type: `Node`\n\nnode.children, value: `[Node(testlist_star_expr, [Leaf(NAME, 'sdfjklsdfsjldkflkjsf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfjsdfjlksdljkfsdlkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfsdjfklsdfjlksdljkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdsfsdfjskdflsfsdf')]), Leaf(EQUAL, '='), Node(testlist_star_expr, [Leaf(NUMBER, '1'), Leaf(COMMA, ','), Leaf(NUMBER, '2'), Leaf(COMMA, ','), Leaf(NUMBER, '3')])]`, type: `list`\n\nnode.insert_child, value: `<bound method Node.insert_child of Node(expr_stmt, [Node(testlist_star_expr, [Leaf(NAME, 'sdfjklsdfsjldkflkjsf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfjsdfjlksdljkfsdlkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfsdjfklsdfjlksdljkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdsfsdfjskdflsfsdf')]), Leaf(EQUAL, '='), Node(testlist_star_expr, [Leaf(NUMBER, '1'), Leaf(COMMA, ','), Leaf(NUMBER, '2'), Leaf(COMMA, ','), Leaf(NUMBER, '3')])])>`, type: `method`\n\nnode.type, value: `290`, type: `int`\n\nnode.append_child, value: `<bound method Node.append_child of Node(expr_stmt, [Node(testlist_star_expr, [Leaf(NAME, 'sdfjklsdfsjldkflkjsf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfjsdfjlksdljkfsdlkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfsdjfklsdfjlksdljkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdsfsdfjskdflsfsdf')]), Leaf(EQUAL, '='), Node(testlist_star_expr, [Leaf(NUMBER, '1'), Leaf(COMMA, ','), Leaf(NUMBER, '2'), Leaf(COMMA, ','), Leaf(NUMBER, '3')])])>`, type: `method`\n\nparens_after, value: `{'%=', '^=', '//=', '&=', '=', '`, type: `set`\n\n### variable runtime value and type before buggy function return\nnode, value: `Node(expr_stmt, [Node(atom, [Leaf(LPAR, ''), Node(testlist_star_expr, [Leaf(NAME, 'sdfjklsdfsjldkflkjsf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfjsdfjlksdljkfsdlkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfsdjfklsdfjlksdljkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdsfsdfjskdflsfsdf')]), Leaf(RPAR, '')]), Leaf(EQUAL, '='), Node(atom, [Leaf(LPAR, ''), Node(testlist_star_expr, [Leaf(NUMBER, '1'), Leaf(COMMA, ','), Leaf(NUMBER, '2'), Leaf(COMMA, ','), Leaf(NUMBER, '3')]), Leaf(RPAR, '')])])`, type: `Node`\n\ncheck_lpar, value: `False`, type: `bool`\n\nindex, value: `2`, type: `int`\n\nchild, value: `Node(testlist_star_expr, [Leaf(NUMBER, '1'), Leaf(COMMA, ','), Leaf(NUMBER, '2'), Leaf(COMMA, ','), Leaf(NUMBER, '3')])`, type: `Node`\n\nnode.children, value: `[Node(atom, [Leaf(LPAR, ''), Node(testlist_star_expr, [Leaf(NAME, 'sdfjklsdfsjldkflkjsf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfjsdfjlksdljkfsdlkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfsdjfklsdfjlksdljkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdsfsdfjskdflsfsdf')]), Leaf(RPAR, '')]), Leaf(EQUAL, '='), Node(atom, [Leaf(LPAR, ''), Node(testlist_star_expr, [Leaf(NUMBER, '1'), Leaf(COMMA, ','), Leaf(NUMBER, '2'), Leaf(COMMA, ','), Leaf(NUMBER, '3')]), Leaf(RPAR, '')])]`, type: `list`\n\nchild.type, value: `334`, type: `int`\n\nlpar, value: `Leaf(LPAR, '')`, type: `Leaf`\n\nrpar, value: `Leaf(RPAR, '')`, type: `Leaf`\n\nchild.remove, value: `<bound method Base.remove of Node(testlist_star_expr, [Leaf(NUMBER, '1'), Leaf(COMMA, ','), Leaf(NUMBER, '2'), Leaf(COMMA, ','), Leaf(NUMBER, '3')])>`, type: `method`\n\nnode.insert_child, value: `<bound method Node.insert_chil ... R, '3')]), Leaf(RPAR, '')])])>`, type: `method`\n\nnode.append_child, value: `<bound method Node.append_chil ... R, '3')]), Leaf(RPAR, '')])])>`, type: `method`\n\nprefix, value: `' '`, type: `str`\n\nchild.prefix, value: `''`, type: `str`\n\nnew_child, value: `Node(atom, [Leaf(LPAR, ''), Node(testlist_star_expr, [Leaf(NUMBER, '1'), Leaf(COMMA, ','), Leaf(NUMBER, '2'), Leaf(COMMA, ','), Leaf(NUMBER, '3')]), Leaf(RPAR, '')])`, type: `Node`\n\nnew_child.prefix, value: `' '`, type: `str`\n\n## Buggy case 2\n### input parameter runtime value and type for buggy function\nnode.prefix, value: `''`, type: `str`\n\nnode, value: `Node(expr_stmt, [Node(atom, [Leaf(LPAR, '('), Node(testlist_gexp, [Leaf(NAME, 'sdfjklsdfsjldkflkjsf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfjsdfjlksdljkfsdlkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfsdjfklsdfjlksdljkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdsfsdfjskdflsfsdf'), Leaf(COMMA, ',')]), Leaf(RPAR, ')')]), Leaf(EQUAL, '='), Node(atom, [Leaf(LPAR, '('), Node(testlist_gexp, [Leaf(NUMBER, '1'), Leaf(COMMA, ','), Leaf(NUMBER, '2'), Leaf(COMMA, ','), Leaf(NUMBER, '3')]), Leaf(RPAR, ')')])])`, type: `Node`\n\nnode.children, value: `[Node(atom, [Leaf(LPAR, '('), Node(testlist_gexp, [Leaf(NAME, 'sdfjklsdfsjldkflkjsf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfjsdfjlksdljkfsdlkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfsdjfklsdfjlksdljkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdsfsdfjskdflsfsdf'), Leaf(COMMA, ',')]), Leaf(RPAR, ')')]), Leaf(EQUAL, '='), Node(atom, [Leaf(LPAR, '('), Node(testlist_gexp, [Leaf(NUMBER, '1'), Leaf(COMMA, ','), Leaf(NUMBER, '2'), Leaf(COMMA, ','), Leaf(NUMBER, '3')]), Leaf(RPAR, ')')])]`, type: `list`\n\nnode.insert_child, value: `<bound method Node.insert_chil ... , '3')]), Leaf(RPAR, ')')])])>`, type: `method`\n\nnode.type, value: `290`, type: `int`\n\nnode.append_child, value: `<bound method Node.append_chil ... , '3')]), Leaf(RPAR, ')')])])>`, type: `method`\n\nparens_after, value: `{'%=', '^=', '//=', '&=', '=', '`, type: `set`\n\n### variable runtime value and type before buggy function return\ncheck_lpar, value: `False`, type: `bool`\n\nindex, value: `2`, type: `int`\n\nchild, value: `Node(atom, [Leaf(LPAR, '('), Node(testlist_gexp, [Leaf(NUMBER, '1'), Leaf(COMMA, ','), Leaf(NUMBER, '2'), Leaf(COMMA, ','), Leaf(NUMBER, '3')]), Leaf(RPAR, ')')])`, type: `Node`\n\nchild.type, value: `266`, type: `int`\n\nchild.remove, value: `<bound method Base.remove of Node(atom, [Leaf(LPAR, '('), Node(testlist_gexp, [Leaf(NUMBER, '1'), Leaf(COMMA, ','), Leaf(NUMBER, '2'), Leaf(COMMA, ','), Leaf(NUMBER, '3')]), Leaf(RPAR, ')')])>`, type: `method`\n\nchild.prefix, value: `' '`, type: `str`\n\n\n\n# Expected variable value and type in tests\n## Expected case 1\n### Input parameter value and type\nnode.prefix, value: `''`, type: `str`\n\nnode, value: `Node(expr_stmt, [Node(testlist_star_expr, [Leaf(NAME, 'sdfjklsdfsjldkflkjsf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfjsdfjlksdljkfsdlkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfsdjfklsdfjlksdljkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdsfsdfjskdflsfsdf')]), Leaf(EQUAL, '='), Node(testlist_star_expr, [Leaf(NUMBER, '1'), Leaf(COMMA, ','), Leaf(NUMBER, '2'), Leaf(COMMA, ','), Leaf(NUMBER, '3')])])`, type: `Node`\n\nnode.children, value: `[Node(testlist_star_expr, [Leaf(NAME, 'sdfjklsdfsjldkflkjsf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfjsdfjlksdljkfsdlkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfsdjfklsdfjlksdljkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdsfsdfjskdflsfsdf')]), Leaf(EQUAL, '='), Node(testlist_star_expr, [Leaf(NUMBER, '1'), Leaf(COMMA, ','), Leaf(NUMBER, '2'), Leaf(COMMA, ','), Leaf(NUMBER, '3')])]`, type: `list`\n\nnode.insert_child, value: `<bound method Node.insert_child of Node(expr_stmt, [Node(testlist_star_expr, [Leaf(NAME, 'sdfjklsdfsjldkflkjsf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfjsdfjlksdljkfsdlkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfsdjfklsdfjlksdljkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdsfsdfjskdflsfsdf')]), Leaf(EQUAL, '='), Node(testlist_star_expr, [Leaf(NUMBER, '1'), Leaf(COMMA, ','), Leaf(NUMBER, '2'), Leaf(COMMA, ','), Leaf(NUMBER, '3')])])>`, type: `method`\n\nnode.type, value: `290`, type: `int`\n\nnode.append_child, value: `<bound method Node.append_child of Node(expr_stmt, [Node(testlist_star_expr, [Leaf(NAME, 'sdfjklsdfsjldkflkjsf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfjsdfjlksdljkfsdlkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfsdjfklsdfjlksdljkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdsfsdfjskdflsfsdf')]), Leaf(EQUAL, '='), Node(testlist_star_expr, [Leaf(NUMBER, '1'), Leaf(COMMA, ','), Leaf(NUMBER, '2'), Leaf(COMMA, ','), Leaf(NUMBER, '3')])])>`, type: `method`\n\nparens_after, value: `{'%=', '&=', '**=', '*=', '@=', '^=', '=', '`, type: `set`\n\n### Expected variable value and type before function return\nnode, expected value: `Node(expr_stmt, [Node(testlist_star_expr, [Leaf(NAME, 'sdfjklsdfsjldkflkjsf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfjsdfjlksdljkfsdlkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfsdjfklsdfjlksdljkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdsfsdfjskdflsfsdf')]), Leaf(EQUAL, '='), Node(atom, [Leaf(LPAR, ''), Node(testlist_star_expr, [Leaf(NUMBER, '1'), Leaf(COMMA, ','), Leaf(NUMBER, '2'), Leaf(COMMA, ','), Leaf(NUMBER, '3')]), Leaf(RPAR, '')])])`, type: `Node`\n\ncheck_lpar, expected value: `False`, type: `bool`\n\nindex, expected value: `2`, type: `int`\n\nchild, expected value: `Node(testlist_star_expr, [Leaf(NUMBER, '1'), Leaf(COMMA, ','), Leaf(NUMBER, '2'), Leaf(COMMA, ','), Leaf(NUMBER, '3')])`, type: `Node`\n\nnode.children, expected value: `[Node(testlist_star_expr, [Leaf(NAME, 'sdfjklsdfsjldkflkjsf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfjsdfjlksdljkfsdlkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfsdjfklsdfjlksdljkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdsfsdfjskdflsfsdf')]), Leaf(EQUAL, '='), Node(atom, [Leaf(LPAR, ''), Node(testlist_star_expr, [Leaf(NUMBER, '1'), Leaf(COMMA, ','), Leaf(NUMBER, '2'), Leaf(COMMA, ','), Leaf(NUMBER, '3')]), Leaf(RPAR, '')])]`, type: `list`\n\nchild.type, expected value: `334`, type: `int`\n\nlpar, expected value: `Leaf(LPAR, '')`, type: `Leaf`\n\nrpar, expected value: `Leaf(RPAR, '')`, type: `Leaf`\n\nchild.remove, expected value: `<bound method Base.remove of Node(testlist_star_expr, [Leaf(NUMBER, '1'), Leaf(COMMA, ','), Leaf(NUMBER, '2'), Leaf(COMMA, ','), Leaf(NUMBER, '3')])>`, type: `method`\n\nnode.insert_child, expected value: `<bound method Node.insert_child of Node(expr_stmt, [Node(testlist_star_expr, [Leaf(NAME, 'sdfjklsdfsjldkflkjsf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfjsdfjlksdljkfsdlkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfsdjfklsdfjlksdljkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdsfsdfjskdflsfsdf')]), Leaf(EQUAL, '='), Node(atom, [Leaf(LPAR, ''), Node(testlist_star_expr, [Leaf(NUMBER, '1'), Leaf(COMMA, ','), Leaf(NUMBER, '2'), Leaf(COMMA, ','), Leaf(NUMBER, '3')]), Leaf(RPAR, '')])])>`, type: `method`\n\nnode.append_child, expected value: `<bound method Node.append_child of Node(expr_stmt, [Node(testlist_star_expr, [Leaf(NAME, 'sdfjklsdfsjldkflkjsf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfjsdfjlksdljkfsdlkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdfsdjfklsdfjlksdljkf'), Leaf(COMMA, ','), Leaf(NAME, 'sdsfsdfjskdflsfsdf')]), Leaf(EQUAL, '='), Node(atom, [Leaf(LPAR, ''), Node(testlist_star_expr, [Leaf(NUMBER, '1'), Leaf(COMMA, ','), Leaf(NUMBER, '2'), Leaf(COMMA, ','), Leaf(NUMBER, '3')]), Leaf(RPAR, '')])])>`, type: `method`\n\n\n\n",
    "6": "# A GitHub issue title for this bug\n```text\nline not shortened if it starts as a backslashed tuple assignment left side\n```\n\n## The associated detailed issue description\n```text\nOperating system: Fedora 29\nPython version: 3.7.0\nBlack version: 18.9b0\nDoes also happen on master: seems that way, reproduces on web tool as well\n\ngiven code:\n\ndef test_of_type(self):\n    JuniorEngineer, Company, companies, Manager, \\\n        Employee, employees, Engineer, Programmer = (\n         self.classes.JuniorEngineer,\n         self.classes.Company,\n         self.tables.companies,\n         self.classes.Manager,\n         self.classes.Employee,\n         self.tables.employees,\n         self.classes.Engineer,\n         self.classes.Programmer)\ncomes out as:\n\ndef test_of_type(self):\n    JuniorEngineer, Company, companies, Manager, Employee, employees, Engineer, Programmer = (\n        self.classes.JuniorEngineer,\n        self.classes.Company,\n        self.tables.companies,\n        self.classes.Manager,\n        self.classes.Employee,\n        self.tables.employees,\n        self.classes.Engineer,\n        self.classes.Programmer,\n    )\nlong line is 95 characters.\n```\n\n",
    "7": "# Instructions\n\n1. Analyze the test case and its relationship with the error message, if applicable.\n2. Identify the potential error location within the problematic function.\n3. Explain the reasons behind the occurrence of the bug.\n4. Suggest possible approaches for fixing the bug.\n5. Present the corrected code for the problematic function."
}