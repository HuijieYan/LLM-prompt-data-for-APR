# Error stack trace

```json
[
    [
        "self = <test_black.BlackTestCase testMethod=test_symlink_out_of_root_directory>\n\n    def test_symlink_out_of_root_directory(self) -> None:\n        # prepare argumens\n        path = MagicMock()\n        root = THIS_DIR\n        child = MagicMock()\n        include = re.compile(black.DEFAULT_INCLUDES)\n        exclude = re.compile(black.DEFAULT_EXCLUDES)\n        report = black.Report()\n    \n        # set the behavior of mock arguments\n        # child should behave like a symlink which resolved path is clearly\n        # outside of the root directory\n        path.iterdir.return_value = [child]\n        child.resolve.return_value = Path(\"/a/b/c\")\n        child.is_symlink.return_value = True\n    \n        # call the method\n        # it should not raise any error\n>       list(black.gen_python_files_in_dir(path, root, include, exclude, report))\n\ntests/test_black.py:1183: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nblack.py:2948: in gen_python_files_in_dir\n    normalized_path = \"/\" + child.resolve().relative_to(root).as_posix()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = PosixPath('/a/b/c')\nother = (PosixPath('/home/ubuntu/Desktop/bgp_envs_local/repos/black_16/tests'),)\nparts = ['/', 'a', 'b', 'c'], drv = '', root = '/'\n\n    def relative_to(self, *other):\n        \"\"\"Return the relative path to another path identified by the passed\n        arguments.  If the operation is not possible (because this is not\n        a subpath of the other path), raise ValueError.\n        \"\"\"\n        # For the purpose of this method, drive and root are considered\n        # separate parts, i.e.:\n        #   Path('c:/').relative_to('c:')  gives Path('/')\n        #   Path('c:/').relative_to('/')   raise ValueError\n        if not other:\n            raise TypeError(\"need at least one argument\")\n        parts = self._parts\n        drv = self._drv\n        root = self._root\n        if root:\n            abs_parts = [drv, root] + parts[1:]\n        else:\n            abs_parts = parts\n        to_drv, to_root, to_parts = self._parse_args(other)\n        if to_root:\n            to_abs_parts = [to_drv, to_root] + to_parts[1:]\n        else:\n            to_abs_parts = to_parts\n        n = len(to_abs_parts)\n        cf = self._flavour.casefold_parts\n        if (root or drv) if n == 0 else cf(abs_parts[:n]) != cf(to_abs_parts):\n            formatted = self._format_parsed_parts(to_drv, to_root, to_parts)\n>           raise ValueError(\"{!r} does not start with {!r}\"\n                             .format(str(self), str(formatted)))",
        "\n/usr/local/lib/python3.8/pathlib.py:908: ValueError"
    ]
]
```
