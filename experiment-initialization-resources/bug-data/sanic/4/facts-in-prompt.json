{
    "1": "# The source code of the buggy function\n```python\n# The relative path of the buggy file: sanic/request.py\n\n\n\n    # this is the buggy function you need to fix\n    def url_for(self, view_name, **kwargs):\n        \"\"\"\n        Same as :func:`sanic.Sanic.url_for`, but automatically determine\n        `scheme` and `netloc` base on the request. Since this method is aiming\n        to generate correct schema & netloc, `_external` is implied.\n    \n        :param kwargs: takes same parameters as in :func:`sanic.Sanic.url_for`\n        :return: an absolute url to the given view\n        :rtype: str\n        \"\"\"\n        # Full URL SERVER_NAME can only be handled in app.url_for\n        if \"//\" in self.app.config.SERVER_NAME:\n            return self.app.url_for(view_name, _external=True, **kwargs)\n    \n        scheme = self.scheme\n        host = self.server_name\n        port = self.server_port\n    \n        if (scheme.lower() in (\"http\", \"ws\") and port == 80) or (\n            scheme.lower() in (\"https\", \"wss\") and port == 443\n        ):\n            netloc = host\n        else:\n            netloc = \"{}:{}\".format(host, port)\n    \n        return self.app.url_for(\n            view_name, _external=True, _scheme=scheme, _server=netloc, **kwargs\n        )\n    \n```",
    "2": "# The declaration of the class containing the buggy function\nclass Request():\n    \"\"\"\n    Properties of an HTTP request such as URL, headers, etc.\n    \"\"\"\n\n\n",
    "3": "# This function from the same file, but not the same class, is called by the buggy function\ndef port(self):\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef server_name(self):\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef server_port(self):\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef scheme(self):\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef host(self):\n    # Please ignore the body of this function\n\n# This function from the same file, but not the same class, is called by the buggy function\ndef url_for(self, view_name, **kwargs):\n    # Please ignore the body of this function\n\n    # This function from the same class is called by the buggy function\n    def port(self):\n        # Please ignore the body of this function\n\n    # This function from the same class is called by the buggy function\n    def server_name(self):\n        # Please ignore the body of this function\n\n    # This function from the same class is called by the buggy function\n    def server_port(self):\n        # Please ignore the body of this function\n\n    # This function from the same class is called by the buggy function\n    def scheme(self):\n        # Please ignore the body of this function\n\n    # This function from the same class is called by the buggy function\n    def host(self):\n        # Please ignore the body of this function\n\n    # This function from the same class is called by the buggy function\n    def url_for(self, view_name, **kwargs):\n        # Please ignore the body of this function\n\n",
    "4": "# A failing test function for the buggy function\n```python\n# The relative path of the failing test file: tests/test_requests.py\n\ndef test_url_for_without_server_name(app):\n    @app.route(\"/sample\")\n    def sample(request):\n        return json({\"url\": request.url_for(\"url_for\")})\n\n    @app.route(\"/url-for\")\n    def url_for(request):\n        return text(\"url-for\")\n\n    request, response = app.test_client.get(\"/sample\")\n    assert (\n        response.json[\"url\"]\n        == f\"http://127.0.0.1:{app.test_client.port}/url-for\"\n    )\n```\n\n\n",
    "5": "## The error message from the failing test\n```text\napp = <sanic.app.Sanic object at 0x7fb44100ce80>\n\n    def test_url_for_without_server_name(app):\n        @app.route(\"/sample\")\n        def sample(request):\n            return json({\"url\": request.url_for(\"url_for\")})\n    \n        @app.route(\"/url-for\")\n        def url_for(request):\n            return text(\"url-for\")\n    \n        request, response = app.test_client.get(\"/sample\")\n>       assert (\n            response.json[\"url\"]\n            == f\"http://127.0.0.1:{app.test_client.port}/url-for\"\n        )\nE       TypeError: 'NoneType' object is not subscriptable\n\ntests/test_requests.py:2118: TypeError\n\n```\n",
    "6": "# Runtime values and types of variables inside the buggy function\nEach case below includes input parameter values and types, and the values and types of relevant variables at the function's return, derived from executing failing tests. If an input parameter is not reflected in the output, it is assumed to remain unchanged. Note that some of these values at the function's return might be incorrect. Analyze these cases to identify why the tests are failing to effectively fix the bug.\n\n## Case 1\n### Runtime values and types of the input parameters of the buggy function\nself, value: `<Request: GET /sample>`, type: `Request`\n\nview_name, value: `'url_for'`, type: `str`\n\nkwargs, value: `{}`, type: `dict`\n\nself.scheme, value: `'http'`, type: `str`\n\nself.server_name, value: `'127.0.0.1'`, type: `str`\n\nself.server_port, value: `42101`, type: `int`\n\n### Runtime values and types of variables right before the buggy function's return\nscheme, value: `'http'`, type: `str`\n\nhost, value: `'127.0.0.1'`, type: `str`\n\nport, value: `42101`, type: `int`\n\nnetloc, value: `'127.0.0.1:42101'`, type: `str`\n\n",
    "7": "",
    "8": "# A GitHub issue for this bug\n\nThe issue's title:\n```text\nImprove documentation in *Accessing values using get and getlist*\n```\n\nThe issue's detailed description:\n```text\nIs your feature request related to a problem? Please describe.\nDocumentation here should be improved:\nhttps://sanic.readthedocs.io/en/latest/sanic/request_data.html#accessing-values-using-get-and-getlist\nIt isn't clear how to use get and getlist\n\nDescribe the solution you'd like\nChange\n\nThe request properties which return a dictionary actually return a subclass of dict called RequestParameters.\n\nTo\n\nrequest.args which return a dictionary actually return a subclass of dict called RequestParameters.\n```\n\n# A GitHub issue for this bug\n\nThe issue's title:\n```text\nUsing request.url_for throws KeyError: 'SERVER_NAME' in 19.9.0\n```\n\nThe issue's detailed description:\n```text\nDescribe the bug\nRunning Sanic behind a proxy and trying to generate an url using request.url_for throws a KeyError. This used to work but now Sanic suddenly requires a SERVER_NAME in order to do this. I get the following trace:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.7/site-packages/sanic/app.py\", line 942, in handle_request\n    response = await response\n  File \"/app/tsauth/views/activate.py\", line 41, in init_activate\n    request=request)\n  File \"/usr/local/lib/python3.7/site-packages/mako/template.py\", line 476, in render\n    return runtime._render(self, self.callable_, args, data)\n  File \"/usr/local/lib/python3.7/site-packages/mako/runtime.py\", line 883, in _render\n    **_kwargs_for_callable(callable_, data)\n  File \"/usr/local/lib/python3.7/site-packages/mako/runtime.py\", line 920, in _render_context\n    _exec_template(inherit, lclcontext, args=args, kwargs=kwargs)\n  File \"/usr/local/lib/python3.7/site-packages/mako/runtime.py\", line 947, in _exec_template\n    callable_(context, *args, **kwargs)\n  File \"transaction_mako\", line 60, in render_body\n  File \"/usr/local/lib/python3.7/site-packages/sanic/request.py\", line 522, in url_for\n    if \"//\" in self.app.config.SERVER_NAME:\n  File \"/usr/local/lib/python3.7/site-packages/sanic/config.py\", line 54, in __getattr__\n    raise AttributeError(\"Config has no '{}'\".format(ke.args[0]))\nAttributeError: Config has no 'SERVER_NAME'\n[2019-10-23 12:38:09 +0000] - (sanic.access)[INFO][<redacted>:33328]: GET <redacted>  500 144\n10/23/2019 12:38:09 PM ERROR Exception occurred while handling uri: '<redacted>'\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.7/site-packages/sanic/config.py\", line 52, in __getattr__\n    return self[attr]\nKeyError: 'SERVER_NAME'\nCode snippet\nrequest.url_for(\"static\",  name='static', filename=\"badge.png\")\n\nExpected behavior\nrequest.url_for should generate a full url with the given path, e.g. https://hostname:port/static/badge.png. As I am running my server behind a proxy, I do not want to hardcode the hostname in the SERVER_NAME. This used to work with Sanic version 19.6.3.\n\nEnvironment (please complete the following information):\n\nPython 3.7 Docker container, Kubernetes v1.16.2 with nginx-ingress 0.26.1\nSanic version 19.9.0\nAdditional context\nThe calling code to request.url_for has not changed since the Sanic version update.\nThe documentation also does not speak a word about why the SERVER_NAME variable needs to be configured...\n```\n\n",
    "9": "Your output should follow these steps:\n1. Analyze the buggy function and its relationship with the buggy class, related functions, test code, corresponding error message, the actual input/output variable information, the github issue.\n2. Identify a potential error location within the buggy function.\n3. Elucidate the bug's cause using:\n   (a) The buggy function, \n   (b) The buggy class docs, \n   (c) The related functions, \n   (d) The failing test, \n   (e) The corresponding error message, \n   (f) The actual input/output variable values, \n   (g) The GitHub Issue information\n\n4. Suggest approaches for fixing the bug.\n5. Present the corrected code for the buggy function such that it satisfied the following:\n   (a) the program passes the failing test, \n   (b) successfully resolves the issue posted in GitHub\n\n",
    "1.3.3": "",
    "source_code_section": "# The source code of the buggy function\n```python\n# The relative path of the buggy file: sanic/request.py\n\n\n\n    # this is the buggy function you need to fix\n    def url_for(self, view_name, **kwargs):\n        \"\"\"\n        Same as :func:`sanic.Sanic.url_for`, but automatically determine\n        `scheme` and `netloc` base on the request. Since this method is aiming\n        to generate correct schema & netloc, `_external` is implied.\n    \n        :param kwargs: takes same parameters as in :func:`sanic.Sanic.url_for`\n        :return: an absolute url to the given view\n        :rtype: str\n        \"\"\"\n        # Full URL SERVER_NAME can only be handled in app.url_for\n        if \"//\" in self.app.config.SERVER_NAME:\n            return self.app.url_for(view_name, _external=True, **kwargs)\n    \n        scheme = self.scheme\n        host = self.server_name\n        port = self.server_port\n    \n        if (scheme.lower() in (\"http\", \"ws\") and port == 80) or (\n            scheme.lower() in (\"https\", \"wss\") and port == 443\n        ):\n            netloc = host\n        else:\n            netloc = \"{}:{}\".format(host, port)\n    \n        return self.app.url_for(\n            view_name, _external=True, _scheme=scheme, _server=netloc, **kwargs\n        )\n    \n```",
    "source_code_body": "# The source code of the buggy function\n```python\n# The relative path of the buggy file: sanic/request.py\n\n\n\n    # this is the buggy function you need to fix\n    def url_for(self, view_name, **kwargs):\n        \"\"\"\n        Same as :func:`sanic.Sanic.url_for`, but automatically determine\n        `scheme` and `netloc` base on the request. Since this method is aiming\n        to generate correct schema & netloc, `_external` is implied.\n    \n        :param kwargs: takes same parameters as in :func:`sanic.Sanic.url_for`\n        :return: an absolute url to the given view\n        :rtype: str\n        \"\"\"\n        # Full URL SERVER_NAME can only be handled in app.url_for\n        if \"//\" in self.app.config.SERVER_NAME:\n            return self.app.url_for(view_name, _external=True, **kwargs)\n    \n        scheme = self.scheme\n        host = self.server_name\n        port = self.server_port\n    \n        if (scheme.lower() in (\"http\", \"ws\") and port == 80) or (\n            scheme.lower() in (\"https\", \"wss\") and port == 443\n        ):\n            netloc = host\n        else:\n            netloc = \"{}:{}\".format(host, port)\n    \n        return self.app.url_for(\n            view_name, _external=True, _scheme=scheme, _server=netloc, **kwargs\n        )\n    \n```"
}