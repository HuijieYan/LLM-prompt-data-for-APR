{
    "keras:7": {
        "/home/ubuntu/Desktop/bgp_envs_local/repos/keras_7/keras/wrappers/scikit_learn.py": {
            "buggy_functions": [
                {
                    "function_name": "predict",
                    "function_code": "def predict(self, x, **kwargs):\n    \"\"\"Returns predictions for the given test data.\n\n    # Arguments\n        x: array-like, shape `(n_samples, n_features)`\n            Test samples where `n_samples` is the number of samples\n            and `n_features` is the number of features.\n        **kwargs: dictionary arguments\n            Legal arguments are the arguments of `Sequential.predict`.\n\n    # Returns\n        preds: array-like, shape `(n_samples,)`\n            Predictions.\n    \"\"\"\n    kwargs = self.filter_sk_params(Sequential.predict, kwargs)\n    return np.squeeze(self.model.predict(x, **kwargs))\n",
                    "decorators": [],
                    "docstring": "Returns predictions for the given test data.\n\n# Arguments\n    x: array-like, shape `(n_samples, n_features)`\n        Test samples where `n_samples` is the number of samples\n        and `n_features` is the number of features.\n    **kwargs: dictionary arguments\n        Legal arguments are the arguments of `Sequential.predict`.\n\n# Returns\n    preds: array-like, shape `(n_samples,)`\n        Predictions.",
                    "start_line": 308,
                    "end_line": 323,
                    "variables": {
                        "kwargs": [
                            322,
                            323
                        ],
                        "self.filter_sk_params": [
                            322
                        ],
                        "self": [
                            322,
                            323
                        ],
                        "Sequential.predict": [
                            322
                        ],
                        "Sequential": [
                            322
                        ],
                        "np.squeeze": [
                            323
                        ],
                        "np": [
                            323
                        ],
                        "self.model.predict": [
                            323
                        ],
                        "self.model": [
                            323
                        ],
                        "x": [
                            323
                        ]
                    },
                    "filtered_variables": {
                        "kwargs": [
                            322,
                            323
                        ],
                        "self.filter_sk_params": [
                            322
                        ],
                        "self": [
                            322,
                            323
                        ],
                        "Sequential.predict": [
                            322
                        ],
                        "Sequential": [
                            322
                        ],
                        "np.squeeze": [
                            323
                        ],
                        "np": [
                            323
                        ],
                        "self.model.predict": [
                            323
                        ],
                        "self.model": [
                            323
                        ],
                        "x": [
                            323
                        ]
                    },
                    "diff_line_number": 323,
                    "class_data": {
                        "signature": "class KerasRegressor(BaseWrapper)",
                        "docstring": "Implementation of the scikit-learn regressor API for Keras.\n    ",
                        "constructor_docstring": null,
                        "functions": [
                            "def predict(self, x, **kwargs):\n    \"\"\"Returns predictions for the given test data.\n\n    # Arguments\n        x: array-like, shape `(n_samples, n_features)`\n            Test samples where `n_samples` is the number of samples\n            and `n_features` is the number of features.\n        **kwargs: dictionary arguments\n            Legal arguments are the arguments of `Sequential.predict`.\n\n    # Returns\n        preds: array-like, shape `(n_samples,)`\n            Predictions.\n    \"\"\"\n    kwargs = self.filter_sk_params(Sequential.predict, kwargs)\n    return np.squeeze(self.model.predict(x, **kwargs))",
                            "def score(self, x, y, **kwargs):\n    \"\"\"Returns the mean loss on the given test data and labels.\n\n    # Arguments\n        x: array-like, shape `(n_samples, n_features)`\n            Test samples where `n_samples` is the number of samples\n            and `n_features` is the number of features.\n        y: array-like, shape `(n_samples,)`\n            True labels for `x`.\n        **kwargs: dictionary arguments\n            Legal arguments are the arguments of `Sequential.evaluate`.\n\n    # Returns\n        score: float\n            Mean accuracy of predictions on `x` wrt. `y`.\n    \"\"\"\n    kwargs = self.filter_sk_params(Sequential.evaluate, kwargs)\n    loss = self.model.evaluate(x, y, **kwargs)\n    if isinstance(loss, list):\n        return -loss[0]\n    return -loss"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [],
                        "class_decorators": [],
                        "function_signatures": [
                            "predict(self, x, **kwargs)",
                            "score(self, x, y, **kwargs)"
                        ],
                        "class_level_variable_names": [],
                        "constructor_variable_names": []
                    },
                    "used_imports": [
                        "import numpy as np",
                        "from ..models import Sequential"
                    ],
                    "variable_values": [
                        [
                            {
                                "kwargs": {
                                    "variable_value": "{'batch_size': 32}",
                                    "variable_type": "dict",
                                    "variable_shape": "1"
                                },
                                "self.filter_sk_params": {
                                    "variable_value": "<bound method BaseWrapper.filter_sk_params of <keras.wrappers.scikit_learn.KerasRegressor object at 0x7fc99d0b9d50>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<keras.wrappers.scikit_learn.KerasRegressor object at 0x7fc99d0b9d50>",
                                    "variable_type": "KerasRegressor",
                                    "variable_shape": null
                                },
                                "Sequential.predict": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Sequential": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.squeeze": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.model.predict": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.model": {
                                    "variable_value": "<keras.engine.sequential.Sequential object at 0x7fc99d0b9cd0>",
                                    "variable_type": "Sequential",
                                    "variable_shape": null
                                },
                                "x": {
                                    "variable_value": "array([[2.115636 , 2.3982556, 1.3876354, 1.719739 , 2.3565648]],\n      dtype=float32)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1, 5)"
                                }
                            },
                            {
                                "kwargs": {
                                    "variable_value": "{'batch_size': 32}",
                                    "variable_type": "dict",
                                    "variable_shape": "1"
                                },
                                "self.filter_sk_params": {
                                    "variable_value": "<bound method BaseWrapper.filter_sk_params of <keras.wrappers.scikit_learn.KerasRegressor object at 0x7fc99d0b9d50>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<keras.wrappers.scikit_learn.KerasRegressor object at 0x7fc99d0b9d50>",
                                    "variable_type": "KerasRegressor",
                                    "variable_shape": null
                                },
                                "Sequential.predict": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Sequential": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.squeeze": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.model.predict": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.model": {
                                    "variable_value": "<keras.engine.sequential.Sequential object at 0x7fc99d0b9cd0>",
                                    "variable_type": "Sequential",
                                    "variable_shape": null
                                },
                                "x": {
                                    "variable_value": "array([[2.115636 , 2.3982556, 1.3876354, 1.719739 , 2.3565648]],\n      dtype=float32)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1, 5)"
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "kwargs": {
                                    "variable_value": "{'batch_size': 32}",
                                    "variable_type": "dict",
                                    "variable_shape": "1"
                                },
                                "self.filter_sk_params": {
                                    "variable_value": "<bound method BaseWrapper.filter_sk_params of <keras.wrappers.scikit_learn.KerasRegressor object at 0x7f5a7af11b50>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<keras.wrappers.scikit_learn.KerasRegressor object at 0x7f5a7af11b50>",
                                    "variable_type": "KerasRegressor",
                                    "variable_shape": null
                                },
                                "Sequential.predict": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Sequential": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.squeeze": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.model.predict": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.model": {
                                    "variable_value": "<keras.engine.sequential.Sequential object at 0x7f5a7af11d90>",
                                    "variable_type": "Sequential",
                                    "variable_shape": null
                                },
                                "x": {
                                    "variable_value": "array([[2.115636 , 2.3982556, 1.3876354, 1.719739 , 2.3565648]],\n      dtype=float32)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1, 5)"
                                }
                            },
                            {
                                "kwargs": {
                                    "variable_value": "{'batch_size': 32}",
                                    "variable_type": "dict",
                                    "variable_shape": "1"
                                },
                                "self.filter_sk_params": {
                                    "variable_value": "<bound method BaseWrapper.filter_sk_params of <keras.wrappers.scikit_learn.KerasRegressor object at 0x7f5a7af11b50>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<keras.wrappers.scikit_learn.KerasRegressor object at 0x7f5a7af11b50>",
                                    "variable_type": "KerasRegressor",
                                    "variable_shape": null
                                },
                                "Sequential.predict": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Sequential": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.squeeze": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.model.predict": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.model": {
                                    "variable_value": "<keras.engine.sequential.Sequential object at 0x7f5a7af11d90>",
                                    "variable_type": "Sequential",
                                    "variable_shape": null
                                },
                                "x": {
                                    "variable_value": "array([[2.115636 , 2.3982556, 1.3876354, 1.719739 , 2.3565648]],\n      dtype=float32)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1, 5)"
                                }
                            }
                        ]
                    ]
                }
            ],
            "inscope_functions": {
                "file_scope_functions": [],
                "file_scope_classes": [
                    {
                        "class_declaration": "class BaseWrapper:",
                        "functions": [
                            {
                                "code": "def __init__(self, build_fn=None, **sk_params):\n    self.build_fn = build_fn\n    self.sk_params = sk_params\n    self.check_params(sk_params)",
                                "signature": "__init__(self, build_fn=None, **sk_params)"
                            },
                            {
                                "code": "def check_params(self, params):\n    \"\"\"Checks for user typos in `params`.\n\n    # Arguments\n        params: dictionary; the parameters to be checked\n\n    # Raises\n        ValueError: if any member of `params` is not a valid argument.\n    \"\"\"\n    legal_params_fns = [Sequential.fit, Sequential.predict,\n                        Sequential.predict_classes, Sequential.evaluate]\n    if self.build_fn is None:\n        legal_params_fns.append(self.__call__)\n    elif (not isinstance(self.build_fn, types.FunctionType) and\n          not isinstance(self.build_fn, types.MethodType)):\n        legal_params_fns.append(self.build_fn.__call__)\n    else:\n        legal_params_fns.append(self.build_fn)\n\n    for params_name in params:\n        for fn in legal_params_fns:\n            if has_arg(fn, params_name):\n                break\n        else:\n            if params_name != 'nb_epoch':\n                raise ValueError(\n                    '{} is not a legal parameter'.format(params_name))",
                                "signature": "check_params(self, params)"
                            },
                            {
                                "code": "def get_params(self, **params):\n    \"\"\"Gets parameters for this estimator.\n\n    # Arguments\n        **params: ignored (exists for API compatibility).\n\n    # Returns\n        Dictionary of parameter names mapped to their values.\n    \"\"\"\n    res = copy.deepcopy(self.sk_params)\n    res.update({'build_fn': self.build_fn})\n    return res",
                                "signature": "get_params(self, **params)"
                            },
                            {
                                "code": "def set_params(self, **params):\n    \"\"\"Sets the parameters of this estimator.\n\n    # Arguments\n        **params: Dictionary of parameter names mapped to their values.\n\n    # Returns\n        self\n    \"\"\"\n    self.check_params(params)\n    self.sk_params.update(params)\n    return self",
                                "signature": "set_params(self, **params)"
                            },
                            {
                                "code": "def fit(self, x, y, **kwargs):\n    \"\"\"Constructs a new model with `build_fn` & fit the model to `(x, y)`.\n\n    # Arguments\n        x : array-like, shape `(n_samples, n_features)`\n            Training samples where `n_samples` is the number of samples\n            and `n_features` is the number of features.\n        y : array-like, shape `(n_samples,)` or `(n_samples, n_outputs)`\n            True labels for `x`.\n        **kwargs: dictionary arguments\n            Legal arguments are the arguments of `Sequential.fit`\n\n    # Returns\n        history : object\n            details about the training history at each epoch.\n    \"\"\"\n    if self.build_fn is None:\n        self.model = self.__call__(**self.filter_sk_params(self.__call__))\n    elif (not isinstance(self.build_fn, types.FunctionType) and\n          not isinstance(self.build_fn, types.MethodType)):\n        self.model = self.build_fn(\n            **self.filter_sk_params(self.build_fn.__call__))\n    else:\n        self.model = self.build_fn(**self.filter_sk_params(self.build_fn))\n\n    loss_name = self.model.loss\n    if hasattr(loss_name, '__name__'):\n        loss_name = loss_name.__name__\n    if loss_name == 'categorical_crossentropy' and len(y.shape) != 2:\n        y = to_categorical(y)\n\n    fit_args = copy.deepcopy(self.filter_sk_params(Sequential.fit))\n    fit_args.update(kwargs)\n\n    history = self.model.fit(x, y, **fit_args)\n\n    return history",
                                "signature": "fit(self, x, y, **kwargs)"
                            },
                            {
                                "code": "def filter_sk_params(self, fn, override=None):\n    \"\"\"Filters `sk_params` and returns those in `fn`'s arguments.\n\n    # Arguments\n        fn : arbitrary function\n        override: dictionary, values to override `sk_params`\n\n    # Returns\n        res : dictionary containing variables\n            in both `sk_params` and `fn`'s arguments.\n    \"\"\"\n    override = override or {}\n    res = {}\n    for name, value in self.sk_params.items():\n        if has_arg(fn, name):\n            res.update({name: value})\n    res.update(override)\n    return res",
                                "signature": "filter_sk_params(self, fn, override=None)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class KerasClassifier:",
                        "functions": [
                            {
                                "code": "def fit(self, x, y, sample_weight=None, **kwargs):\n    \"\"\"Constructs a new model with `build_fn` & fit the model to `(x, y)`.\n\n    # Arguments\n        x : array-like, shape `(n_samples, n_features)`\n            Training samples where `n_samples` is the number of samples\n            and `n_features` is the number of features.\n        y : array-like, shape `(n_samples,)` or `(n_samples, n_outputs)`\n            True labels for `x`.\n        **kwargs: dictionary arguments\n            Legal arguments are the arguments of `Sequential.fit`\n\n    # Returns\n        history : object\n            details about the training history at each epoch.\n\n    # Raises\n        ValueError: In case of invalid shape for `y` argument.\n    \"\"\"\n    y = np.array(y)\n    if len(y.shape) == 2 and y.shape[1] > 1:\n        self.classes_ = np.arange(y.shape[1])\n    elif (len(y.shape) == 2 and y.shape[1] == 1) or len(y.shape) == 1:\n        self.classes_ = np.unique(y)\n        y = np.searchsorted(self.classes_, y)\n    else:\n        raise ValueError('Invalid shape for y: ' + str(y.shape))\n    self.n_classes_ = len(self.classes_)\n    if sample_weight is not None:\n        kwargs['sample_weight'] = sample_weight\n    return super(KerasClassifier, self).fit(x, y, **kwargs)",
                                "signature": "fit(self, x, y, sample_weight=None, **kwargs)"
                            },
                            {
                                "code": "def predict(self, x, **kwargs):\n    \"\"\"Returns the class predictions for the given test data.\n\n    # Arguments\n        x: array-like, shape `(n_samples, n_features)`\n            Test samples where `n_samples` is the number of samples\n            and `n_features` is the number of features.\n        **kwargs: dictionary arguments\n            Legal arguments are the arguments\n            of `Sequential.predict_classes`.\n\n    # Returns\n        preds: array-like, shape `(n_samples,)`\n            Class predictions.\n    \"\"\"\n    kwargs = self.filter_sk_params(Sequential.predict_classes, kwargs)\n\n    proba = self.model.predict(x, **kwargs)\n    if proba.shape[-1] > 1:\n        classes = proba.argmax(axis=-1)\n    else:\n        classes = (proba > 0.5).astype('int32')\n    return self.classes_[classes]",
                                "signature": "predict(self, x, **kwargs)"
                            },
                            {
                                "code": "def predict_proba(self, x, **kwargs):\n    \"\"\"Returns class probability estimates for the given test data.\n\n    # Arguments\n        x: array-like, shape `(n_samples, n_features)`\n            Test samples where `n_samples` is the number of samples\n            and `n_features` is the number of features.\n        **kwargs: dictionary arguments\n            Legal arguments are the arguments\n            of `Sequential.predict_classes`.\n\n    # Returns\n        proba: array-like, shape `(n_samples, n_outputs)`\n            Class probability estimates.\n            In the case of binary classification,\n            to match the scikit-learn API,\n            will return an array of shape `(n_samples, 2)`\n            (instead of `(n_sample, 1)` as in Keras).\n    \"\"\"\n    kwargs = self.filter_sk_params(Sequential.predict_proba, kwargs)\n    probs = self.model.predict(x, **kwargs)\n\n    # check if binary classification\n    if probs.shape[1] == 1:\n        # first column is probability of class 0 and second is of class 1\n        probs = np.hstack([1 - probs, probs])\n    return probs",
                                "signature": "predict_proba(self, x, **kwargs)"
                            },
                            {
                                "code": "def score(self, x, y, **kwargs):\n    \"\"\"Returns the mean accuracy on the given test data and labels.\n\n    # Arguments\n        x: array-like, shape `(n_samples, n_features)`\n            Test samples where `n_samples` is the number of samples\n            and `n_features` is the number of features.\n        y: array-like, shape `(n_samples,)` or `(n_samples, n_outputs)`\n            True labels for `x`.\n        **kwargs: dictionary arguments\n            Legal arguments are the arguments of `Sequential.evaluate`.\n\n    # Returns\n        score: float\n            Mean accuracy of predictions on `x` wrt. `y`.\n\n    # Raises\n        ValueError: If the underlying model isn't configured to\n            compute accuracy. You should pass `metrics=[\"accuracy\"]` to\n            the `.compile()` method of the model.\n    \"\"\"\n    y = np.searchsorted(self.classes_, y)\n    kwargs = self.filter_sk_params(Sequential.evaluate, kwargs)\n\n    loss_name = self.model.loss\n    if hasattr(loss_name, '__name__'):\n        loss_name = loss_name.__name__\n    if loss_name == 'categorical_crossentropy' and len(y.shape) != 2:\n        y = to_categorical(y)\n\n    outputs = self.model.evaluate(x, y, **kwargs)\n    outputs = to_list(outputs)\n    for name, output in zip(self.model.metrics_names, outputs):\n        if name == 'acc':\n            return output\n    raise ValueError('The model is not configured to compute accuracy. '\n                     'You should pass `metrics=[\"accuracy\"]` to '\n                     'the `model.compile()` method.')",
                                "signature": "score(self, x, y, **kwargs)"
                            }
                        ]
                    },
                    {
                        "class_declaration": "class KerasRegressor:",
                        "functions": [
                            {
                                "code": "def predict(self, x, **kwargs):\n    \"\"\"Returns predictions for the given test data.\n\n    # Arguments\n        x: array-like, shape `(n_samples, n_features)`\n            Test samples where `n_samples` is the number of samples\n            and `n_features` is the number of features.\n        **kwargs: dictionary arguments\n            Legal arguments are the arguments of `Sequential.predict`.\n\n    # Returns\n        preds: array-like, shape `(n_samples,)`\n            Predictions.\n    \"\"\"\n    kwargs = self.filter_sk_params(Sequential.predict, kwargs)\n    return np.squeeze(self.model.predict(x, **kwargs))",
                                "signature": "predict(self, x, **kwargs)"
                            },
                            {
                                "code": "def score(self, x, y, **kwargs):\n    \"\"\"Returns the mean loss on the given test data and labels.\n\n    # Arguments\n        x: array-like, shape `(n_samples, n_features)`\n            Test samples where `n_samples` is the number of samples\n            and `n_features` is the number of features.\n        y: array-like, shape `(n_samples,)`\n            True labels for `x`.\n        **kwargs: dictionary arguments\n            Legal arguments are the arguments of `Sequential.evaluate`.\n\n    # Returns\n        score: float\n            Mean accuracy of predictions on `x` wrt. `y`.\n    \"\"\"\n    kwargs = self.filter_sk_params(Sequential.evaluate, kwargs)\n    loss = self.model.evaluate(x, y, **kwargs)\n    if isinstance(loss, list):\n        return -loss[0]\n    return -loss",
                                "signature": "score(self, x, y, **kwargs)"
                            }
                        ]
                    }
                ]
            },
            "variables_in_file": {
                "object": [
                    18
                ],
                "self.build_fn": [
                    102,
                    134,
                    136,
                    137,
                    138,
                    75,
                    139,
                    77,
                    78,
                    79,
                    141,
                    81,
                    60
                ],
                "self": [
                    256,
                    134,
                    135,
                    136,
                    137,
                    138,
                    139,
                    141,
                    143,
                    149,
                    152,
                    285,
                    286,
                    288,
                    294,
                    296,
                    169,
                    60,
                    61,
                    62,
                    322,
                    323,
                    201,
                    75,
                    76,
                    77,
                    78,
                    79,
                    203,
                    81,
                    204,
                    207,
                    210,
                    341,
                    342,
                    227,
                    101,
                    102,
                    229,
                    234,
                    114,
                    115,
                    116,
                    255
                ],
                "build_fn": [
                    60
                ],
                "self.sk_params": [
                    169,
                    101,
                    115,
                    61
                ],
                "sk_params": [
                    61,
                    62
                ],
                "self.check_params": [
                    114,
                    62
                ],
                "legal_params_fns": [
                    73,
                    76,
                    79,
                    81,
                    84
                ],
                "Sequential.fit": [
                    73,
                    149
                ],
                "Sequential": [
                    322,
                    227,
                    73,
                    74,
                    149,
                    341,
                    286,
                    255
                ],
                "Sequential.predict": [
                    73,
                    322
                ],
                "Sequential.predict_classes": [
                    74,
                    227
                ],
                "Sequential.evaluate": [
                    74,
                    341,
                    286
                ],
                "legal_params_fns.append": [
                    81,
                    76,
                    79
                ],
                "self.__call__": [
                    76,
                    135
                ],
                "isinstance": [
                    136,
                    137,
                    77,
                    78,
                    343
                ],
                "types.FunctionType": [
                    136,
                    77
                ],
                "types": [
                    136,
                    137,
                    77,
                    78
                ],
                "types.MethodType": [
                    137,
                    78
                ],
                "self.build_fn.__call__": [
                    139,
                    79
                ],
                "params_name": [
                    88,
                    90,
                    83,
                    85
                ],
                "params": [
                    115,
                    114,
                    83
                ],
                "fn": [
                    170,
                    84,
                    85
                ],
                "has_arg": [
                    170,
                    85
                ],
                "ValueError": [
                    89,
                    299,
                    206
                ],
                "format": [
                    90
                ],
                "res": [
                    101,
                    102,
                    103,
                    168,
                    171,
                    172,
                    173
                ],
                "copy.deepcopy": [
                    101,
                    149
                ],
                "copy": [
                    101,
                    149
                ],
                "res.update": [
                    171,
                    172,
                    102
                ],
                "self.sk_params.update": [
                    115
                ],
                "self.model": [
                    256,
                    288,
                    323,
                    229,
                    294,
                    135,
                    296,
                    138,
                    141,
                    143,
                    342,
                    152
                ],
                "self.filter_sk_params": [
                    322,
                    227,
                    135,
                    139,
                    141,
                    149,
                    341,
                    286,
                    255
                ],
                "loss_name": [
                    288,
                    289,
                    290,
                    291,
                    143,
                    144,
                    145,
                    146
                ],
                "self.model.loss": [
                    288,
                    143
                ],
                "hasattr": [
                    144,
                    289
                ],
                "loss_name.__name__": [
                    145,
                    290
                ],
                "len": [
                    291,
                    200,
                    202,
                    207,
                    146
                ],
                "y.shape": [
                    291,
                    200,
                    201,
                    202,
                    206,
                    146
                ],
                "y": [
                    291,
                    292,
                    294,
                    199,
                    200,
                    201,
                    202,
                    203,
                    204,
                    206,
                    146,
                    147,
                    210,
                    342,
                    152,
                    285
                ],
                "to_categorical": [
                    147,
                    292
                ],
                "fit_args": [
                    152,
                    149,
                    150
                ],
                "fit_args.update": [
                    150
                ],
                "kwargs": [
                    256,
                    322,
                    227,
                    323,
                    229,
                    294,
                    209,
                    210,
                    341,
                    150,
                    342,
                    286,
                    255
                ],
                "history": [
                    152,
                    154
                ],
                "self.model.fit": [
                    152
                ],
                "x": [
                    256,
                    323,
                    229,
                    294,
                    210,
                    342,
                    152
                ],
                "override": [
                    172,
                    167
                ],
                "name": [
                    296,
                    169,
                    170,
                    171,
                    297
                ],
                "value": [
                    169,
                    171
                ],
                "self.sk_params.items": [
                    169
                ],
                "BaseWrapper": [
                    176,
                    304
                ],
                "np.array": [
                    199
                ],
                "np": [
                    323,
                    261,
                    199,
                    201,
                    203,
                    204,
                    285
                ],
                "self.classes_": [
                    201,
                    234,
                    203,
                    204,
                    207,
                    285
                ],
                "np.arange": [
                    201
                ],
                "np.unique": [
                    203
                ],
                "np.searchsorted": [
                    204,
                    285
                ],
                "str": [
                    206
                ],
                "self.n_classes_": [
                    207
                ],
                "sample_weight": [
                    208,
                    209
                ],
                "fit": [
                    210
                ],
                "super": [
                    210
                ],
                "KerasClassifier": [
                    210
                ],
                "proba": [
                    233,
                    229,
                    230,
                    231
                ],
                "self.model.predict": [
                    256,
                    323,
                    229
                ],
                "proba.shape": [
                    230
                ],
                "classes": [
                    233,
                    234,
                    231
                ],
                "proba.argmax": [
                    231
                ],
                "astype": [
                    233
                ],
                "Sequential.predict_proba": [
                    255
                ],
                "probs": [
                    256,
                    259,
                    261,
                    262
                ],
                "probs.shape": [
                    259
                ],
                "np.hstack": [
                    261
                ],
                "outputs": [
                    296,
                    294,
                    295
                ],
                "self.model.evaluate": [
                    342,
                    294
                ],
                "to_list": [
                    295
                ],
                "output": [
                    296,
                    298
                ],
                "zip": [
                    296
                ],
                "self.model.metrics_names": [
                    296
                ],
                "np.squeeze": [
                    323
                ],
                "loss": [
                    344,
                    345,
                    342,
                    343
                ],
                "list": [
                    343
                ]
            },
            "filtered_variables_in_file": {
                "self.build_fn": [
                    102,
                    134,
                    136,
                    137,
                    138,
                    75,
                    139,
                    77,
                    78,
                    79,
                    141,
                    81,
                    60
                ],
                "self": [
                    256,
                    134,
                    135,
                    136,
                    137,
                    138,
                    139,
                    141,
                    143,
                    149,
                    152,
                    285,
                    286,
                    288,
                    294,
                    296,
                    169,
                    60,
                    61,
                    62,
                    322,
                    323,
                    201,
                    75,
                    76,
                    77,
                    78,
                    79,
                    203,
                    81,
                    204,
                    207,
                    210,
                    341,
                    342,
                    227,
                    101,
                    102,
                    229,
                    234,
                    114,
                    115,
                    116,
                    255
                ],
                "build_fn": [
                    60
                ],
                "self.sk_params": [
                    169,
                    101,
                    115,
                    61
                ],
                "sk_params": [
                    61,
                    62
                ],
                "self.check_params": [
                    114,
                    62
                ],
                "legal_params_fns": [
                    73,
                    76,
                    79,
                    81,
                    84
                ],
                "Sequential.fit": [
                    73,
                    149
                ],
                "Sequential": [
                    322,
                    227,
                    73,
                    74,
                    149,
                    341,
                    286,
                    255
                ],
                "Sequential.predict": [
                    73,
                    322
                ],
                "Sequential.predict_classes": [
                    74,
                    227
                ],
                "Sequential.evaluate": [
                    74,
                    341,
                    286
                ],
                "legal_params_fns.append": [
                    81,
                    76,
                    79
                ],
                "self.__call__": [
                    76,
                    135
                ],
                "types.FunctionType": [
                    136,
                    77
                ],
                "types": [
                    136,
                    137,
                    77,
                    78
                ],
                "types.MethodType": [
                    137,
                    78
                ],
                "self.build_fn.__call__": [
                    139,
                    79
                ],
                "params_name": [
                    88,
                    90,
                    83,
                    85
                ],
                "params": [
                    115,
                    114,
                    83
                ],
                "fn": [
                    170,
                    84,
                    85
                ],
                "has_arg": [
                    170,
                    85
                ],
                "res": [
                    101,
                    102,
                    103,
                    168,
                    171,
                    172,
                    173
                ],
                "copy.deepcopy": [
                    101,
                    149
                ],
                "copy": [
                    101,
                    149
                ],
                "res.update": [
                    171,
                    172,
                    102
                ],
                "self.sk_params.update": [
                    115
                ],
                "self.model": [
                    256,
                    288,
                    323,
                    229,
                    294,
                    135,
                    296,
                    138,
                    141,
                    143,
                    342,
                    152
                ],
                "self.filter_sk_params": [
                    322,
                    227,
                    135,
                    139,
                    141,
                    149,
                    341,
                    286,
                    255
                ],
                "loss_name": [
                    288,
                    289,
                    290,
                    291,
                    143,
                    144,
                    145,
                    146
                ],
                "self.model.loss": [
                    288,
                    143
                ],
                "loss_name.__name__": [
                    145,
                    290
                ],
                "y.shape": [
                    291,
                    200,
                    201,
                    202,
                    206,
                    146
                ],
                "y": [
                    291,
                    292,
                    294,
                    199,
                    200,
                    201,
                    202,
                    203,
                    204,
                    206,
                    146,
                    147,
                    210,
                    342,
                    152,
                    285
                ],
                "to_categorical": [
                    147,
                    292
                ],
                "fit_args": [
                    152,
                    149,
                    150
                ],
                "fit_args.update": [
                    150
                ],
                "kwargs": [
                    256,
                    322,
                    227,
                    323,
                    229,
                    294,
                    209,
                    210,
                    341,
                    150,
                    342,
                    286,
                    255
                ],
                "history": [
                    152,
                    154
                ],
                "self.model.fit": [
                    152
                ],
                "x": [
                    256,
                    323,
                    229,
                    294,
                    210,
                    342,
                    152
                ],
                "override": [
                    172,
                    167
                ],
                "name": [
                    296,
                    169,
                    170,
                    171,
                    297
                ],
                "value": [
                    169,
                    171
                ],
                "self.sk_params.items": [
                    169
                ],
                "BaseWrapper": [
                    176,
                    304
                ],
                "np.array": [
                    199
                ],
                "np": [
                    323,
                    261,
                    199,
                    201,
                    203,
                    204,
                    285
                ],
                "self.classes_": [
                    201,
                    234,
                    203,
                    204,
                    207,
                    285
                ],
                "np.arange": [
                    201
                ],
                "np.unique": [
                    203
                ],
                "np.searchsorted": [
                    204,
                    285
                ],
                "self.n_classes_": [
                    207
                ],
                "sample_weight": [
                    208,
                    209
                ],
                "fit": [
                    210
                ],
                "KerasClassifier": [
                    210
                ],
                "proba": [
                    233,
                    229,
                    230,
                    231
                ],
                "self.model.predict": [
                    256,
                    323,
                    229
                ],
                "proba.shape": [
                    230
                ],
                "classes": [
                    233,
                    234,
                    231
                ],
                "proba.argmax": [
                    231
                ],
                "astype": [
                    233
                ],
                "Sequential.predict_proba": [
                    255
                ],
                "probs": [
                    256,
                    259,
                    261,
                    262
                ],
                "probs.shape": [
                    259
                ],
                "np.hstack": [
                    261
                ],
                "outputs": [
                    296,
                    294,
                    295
                ],
                "self.model.evaluate": [
                    342,
                    294
                ],
                "to_list": [
                    295
                ],
                "output": [
                    296,
                    298
                ],
                "self.model.metrics_names": [
                    296
                ],
                "np.squeeze": [
                    323
                ],
                "loss": [
                    344,
                    345,
                    342,
                    343
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/home/ubuntu/Desktop/bgp_envs_local/repos/keras_7/tests/keras/wrappers/scikit_learn_test.py",
                "test_function": "test_regression_predict_shape_correct_num_test_1",
                "test_function_code": "def test_regression_predict_shape_correct_num_test_1():\n    assert_regression_predict_shape_correct(num_test=1)",
                "test_error": "assert () == (1,)   Right contains one more item: 1   Full diff:   - (1,)   + ()",
                "full_test_error": "def test_regression_predict_shape_correct_num_test_1():\n>       assert_regression_predict_shape_correct(num_test=1)\n\ntests/keras/wrappers/scikit_learn_test.py:175: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nnum_test = 1\n\n    def assert_regression_predict_shape_correct(num_test):\n        reg = KerasRegressor(\n            build_fn=build_fn_reg, hidden_dims=hidden_dims,\n            batch_size=batch_size, epochs=epochs)\n        reg.fit(X_train, y_train, batch_size=batch_size, epochs=epochs)\n    \n        preds = reg.predict(X_test[:num_test], batch_size=batch_size)\n>       assert preds.shape == (num_test, )\nE       assert () == (1,)\nE         Right contains one more item: 1\nE         Full diff:\nE         - (1,)\nE         + ()\n\ntests/keras/wrappers/scikit_learn_test.py:185: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            }
        ]
    }
}