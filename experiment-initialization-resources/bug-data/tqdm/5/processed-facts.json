{
    "1.1.1": "    def __init__(self, iterable=None, desc=None, total=None, leave=True,\n                 file=None, ncols=None, mininterval=0.1, maxinterval=10.0,\n                 miniters=None, ascii=None, disable=False, unit='it',\n                 unit_scale=False, dynamic_ncols=False, smoothing=0.3,\n                 bar_format=None, initial=0, position=None, postfix=None,\n                 unit_divisor=1000, gui=False, **kwargs):\n        \n\n        if file is None:\n            file = sys.stderr\n\n        if disable is None and hasattr(file, \"isatty\") and not file.isatty():\n            disable = True\n\n        if disable:\n            self.iterable = iterable\n            self.disable = disable\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            self.n = initial\n            return\n\n        if kwargs:\n            self.disable = True\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            raise (TqdmDeprecationWarning(\"\"\"\\\n`nested` is deprecated and automated. Use position instead for manual control.\n\"\"\", fp_write=getattr(file, 'write', sys.stderr.write)) if \"nested\" in kwargs\n                else TqdmKeyError(\"Unknown argument(s): \" + str(kwargs)))\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:  # pragma: no cover\n            if dynamic_ncols:\n                dynamic_ncols = _environ_cols_wrapper()\n                if dynamic_ncols:\n                    ncols = dynamic_ncols(file)\n                # elif ncols is not None:\n                #     ncols = 79\n            else:\n                _dynamic_ncols = _environ_cols_wrapper()\n                if _dynamic_ncols:\n                    ncols = _dynamic_ncols(file)\n                # else:\n                #     ncols = 79\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if bar_format and not ascii:\n            # Convert bar format into unicode since terminal uses unicode\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc or ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.unit_divisor = unit_divisor\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_time = None\n        self._time = time\n        self.bar_format = bar_format\n        self.postfix = None\n        if postfix:\n            try:\n                self.set_postfix(refresh=False, **postfix)\n            except TypeError:\n                self.postfix = postfix\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        with self._lock:\n            if position is None:\n                self.pos = self._get_free_pos(self)\n            else:  # mark fixed positions as negative\n                self.pos = -position\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = self.status_printer(self.fp)\n            with self._lock:\n                if self.pos:\n                    self.moveto(abs(self.pos))\n                self.sp(self.__repr__(elapsed=0))\n                if self.pos:\n                    self.moveto(-abs(self.pos))\n\n        # Init the time counter\n        self.last_print_t = self._time()\n        # NB: Avoid race conditions by setting start_t at the very end of init\n        self.start_t = self.last_print_t\n",
    "1.1.2": "Parameters\n----------\niterable  : iterable, optional\n    Iterable to decorate with a progressbar.\n    Leave blank to manually manage the updates.\ndesc  : str, optional\n    Prefix for the progressbar.\ntotal  : int, optional\n    The number of expected iterations. If unspecified,\n    len(iterable) is used if possible. As a last resort, only basic\n    progress statistics are displayed (no ETA, no progressbar).\n    If `gui` is True and this parameter needs subsequent updating,\n    specify an initial arbitrary large positive integer,\n    e.g. int(9e9).\nleave  : bool, optional\n    If [default: True], keeps all traces of the progressbar\n    upon termination of iteration.\nfile  : `io.TextIOWrapper` or `io.StringIO`, optional\n    Specifies where to output the progress messages\n    (default: sys.stderr). Uses `file.write(str)` and `file.flush()`\n    methods.\nncols  : int, optional\n    The width of the entire output message. If specified,\n    dynamically resizes the progressbar to stay within this bound.\n    If unspecified, attempts to use environment width. The\n    fallback is a meter width of 10 and no limit for the counter and\n    statistics. If 0, will not print any meter (only stats).\nmininterval  : float, optional\n    Minimum progress display update interval, in seconds [default: 0.1].\nmaxinterval  : float, optional\n    Maximum progress display update interval, in seconds [default: 10].\n    Automatically adjusts `miniters` to correspond to `mininterval`\n    after long display update lag. Only works if `dynamic_miniters`\n    or monitor thread is enabled.\nminiters  : int, optional\n    Minimum progress display update interval, in iterations.\n    If 0 and `dynamic_miniters`, will automatically adjust to equal\n    `mininterval` (more CPU efficient, good for tight loops).\n    If > 0, will skip display of specified number of iterations.\n    Tweak this and `mininterval` to get very efficient loops.\n    If your progress is erratic with both fast and slow iterations\n    (network, skipping items, etc) you should set miniters=1.\nascii  : bool, optional\n    If unspecified or False, use unicode (smooth blocks) to fill\n    the meter. The fallback is to use ASCII characters `1-9 #`.\ndisable  : bool, optional\n    Whether to disable the entire progressbar wrapper\n    [default: False]. If set to None, disable on non-TTY.\nunit  : str, optional\n    String that will be used to define the unit of each iteration\n    [default: it].\nunit_scale  : bool or int or float, optional\n    If 1 or True, the number of iterations will be reduced/scaled\n    automatically and a metric prefix following the\n    International System of Units standard will be added\n    (kilo, mega, etc.) [default: False]. If any other non-zero\n    number, will scale `total` and `n`.\ndynamic_ncols  : bool, optional\n    If set, constantly alters `ncols` to the environment (allowing\n    for window resizes) [default: False].\nsmoothing  : float, optional\n    Exponential moving average smoothing factor for speed estimates\n    (ignored in GUI mode). Ranges from 0 (average speed) to 1\n    (current/instantaneous speed) [default: 0.3].\nbar_format  : str, optional\n    Specify a custom bar string formatting. May impact performance.\n    [default: '{l_bar}{bar}{r_bar}'], where\n    l_bar='{desc}: {percentage:3.0f}%|' and\n    r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n      '{rate_fmt}{postfix}]'\n    Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n      percentage, rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n      rate_inv, rate_inv_fmt, elapsed, remaining, desc, postfix.\n    Note that a trailing \": \" is automatically removed after {desc}\n    if the latter is empty.\ninitial  : int, optional\n    The initial counter value. Useful when restarting a progress\n    bar [default: 0].\nposition  : int, optional\n    Specify the line offset to print this bar (starting from 0)\n    Automatic if unspecified.\n    Useful to manage multiple bars at once (eg, from threads).\npostfix  : dict or *, optional\n    Specify additional stats to display at the end of the bar.\n    Calls `set_postfix(**postfix)` if possible (dict).\nunit_divisor  : float, optional\n    [default: 1000], ignored unless `unit_scale` is True.\ngui  : bool, optional\n    WARNING: internal parameter - do not use.\n    Use tqdm_gui(...) instead. If set, will attempt to use\n    matplotlib animations for a graphical output [default: False].\n\nReturns\n-------\nout  : decorated iterator.",
    "1.2.1": "tqdm/_tqdm.py",
    "1.2.2": null,
    "1.3.1": "class tqdm(Comparable)",
    "1.3.2": "Decorate an iterable object, returning an iterator which acts exactly\nlike the original iterable, but prints a dynamically updating\nprogressbar every time a value is requested.",
    "1.4.1": [
        "status_printer(file)",
        "_get_free_pos(cls, instance=None)",
        "write(cls, s, file=None, end='\\n', nolock=False)",
        "__repr__(self, elapsed=None)",
        "set_postfix(self, ordered_dict=None, refresh=True, **kwargs)",
        "moveto(self, n)"
    ],
    "1.4.2": null,
    "1.5.1": [
        "@with_setup(pretest, posttest)\ndef test_bool():\n    \"\"\"Test boolean cast\"\"\"\n    def internal(our_file, disable):\n        with tqdm(total=10, file=our_file, disable=disable) as t:\n            assert t\n        with tqdm(total=0, file=our_file, disable=disable) as t:\n            assert not t\n        with trange(10, file=our_file, disable=disable) as t:\n            assert t\n        with trange(0, file=our_file, disable=disable) as t:\n            assert not t\n        with tqdm([], file=our_file, disable=disable) as t:\n            assert not t\n        with tqdm([0], file=our_file, disable=disable) as t:\n            assert t\n        with tqdm(file=our_file, disable=disable) as t:\n            try:\n                print(bool(t))\n            except TypeError:\n                pass\n            else:\n                raise TypeError(\n                    \"Expected tqdm() with neither total nor iterable to fail\")\n\n    # test with and without disable\n    with closing(StringIO()) as our_file:\n        internal(our_file, False)\n        internal(our_file, True)"
    ],
    "1.5.2": [
        "tqdm/tests/tests_tqdm.py"
    ],
    "2.1.1": [
        [
            "E       AttributeError: 'tqdm' object has no attribute 'total'"
        ]
    ],
    "2.1.2": [
        [
            "@with_setup(pretest, posttest)\n    def test_bool():\n        \"\"\"Test boolean cast\"\"\"\n        def internal(our_file, disable):\n            with tqdm(total=10, file=our_file, disable=disable) as t:\n                assert t\n            with tqdm(total=0, file=our_file, disable=disable) as t:\n                assert not t\n            with trange(10, file=our_file, disable=disable) as t:\n                assert t\n            with trange(0, file=our_file, disable=disable) as t:\n                assert not t\n            with tqdm([], file=our_file, disable=disable) as t:\n                assert not t\n            with tqdm([0], file=our_file, disable=disable) as t:\n                assert t\n            with tqdm(file=our_file, disable=disable) as t:\n                try:\n                    print(bool(t))\n                except TypeError:\n                    pass\n                else:\n                    raise TypeError(\n                        \"Expected tqdm() with neither total nor iterable to fail\")\n    \n        # test with and without disable\n        with closing(StringIO()) as our_file:\n            internal(our_file, False)\n>           internal(our_file, True)\n\ntqdm/tests/tests_tqdm.py:1591: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntqdm/tests/tests_tqdm.py:1568: in internal\n    assert t\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <[AttributeError(\"'tqdm' object has no attribute 'total'\") raised in repr()] tqdm object at 0x7f4d470d0310>\n\n    def __len__(self):\n>       return self.total if self.iterable is None else \\\n            (self.iterable.shape[0] if hasattr(self.iterable, \"shape\")\n             else len(self.iterable) if hasattr(self.iterable, \"__len__\")\n             else getattr(self, \"total\", None))",
            "\ntqdm/_tqdm.py:869: AttributeError"
        ]
    ],
    "2.2.1": null,
    "2.2.2": null,
    "2.3.1": null,
    "2.3.2": null,
    "3.1.1": [
        "Can't evaluate tqdm as a boolean if disable is True\n"
    ],
    "3.1.2": [
        "If I convert a tqdm object to boolean to test for existence, I get an AttributeError if it was created with disable=True. Instead I would expect it to evaluate to False.\n\nIn [3]: pbar = tqdm(disable=False, total=100)\n  0%|                                                                              | 0/100 [00:00<?, ?it/s]\nIn [4]: bool(pbar)\nOut[4]: True\n\nIn [5]: pbar = tqdm(disable=True, total=100)\n\nIn [6]: bool(pbar)\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n<ipython-input-6-da3b9c36e33c> in <module>()\n----> 1 bool(pbar)\n\n~/prog/vopu/lib/python3.5/site-packages/tqdm/_tqdm.py in __len__(self)\n    867 \n    868     def __len__(self):\n--> 869         return self.total if self.iterable is None else \\\n    870             (self.iterable.shape[0] if hasattr(self.iterable, \"shape\")\n    871              else len(self.iterable) if hasattr(self.iterable, \"__len__\")\n\nAttributeError: 'tqdm' object has no attribute 'total'\nIn [7]: print(tqdm.__version__, sys.version, sys.platform)\n4.23.4 3.5.2 (default, Nov 23 2017, 16:37:01) \n[GCC 5.4.0 20160609] linux\n I have visited the source website, and in particular\nread the known issues\n I have searched through the issue tracker for duplicates\n I have mentioned version numbers, operating system and\nenvironment, where applicable:\nimport tqdm, sys\nprint(tqdm.__version__, sys.version, sys.platform)\n"
    ]
}