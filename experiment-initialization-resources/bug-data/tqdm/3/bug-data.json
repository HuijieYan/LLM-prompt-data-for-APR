{
    "tqdm:3": {
        "/home/ubuntu/Desktop/bgp_envs_local/repos/tqdm_3/tqdm/_tqdm.py": {
            "buggy_functions": [
                {
                    "function_name": "__len__",
                    "function_code": "def __len__(self):\n    return self.total if self.iterable is None else \\\n        (self.iterable.shape[0] if hasattr(self.iterable, \"shape\")\n         else len(self.iterable) if hasattr(self.iterable, \"__len__\")\n         else getattr(self, \"total\", None))\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 950,
                    "end_line": 954,
                    "variables": {
                        "self.iterable": [
                            952,
                            953,
                            951
                        ],
                        "self": [
                            952,
                            953,
                            954,
                            951
                        ],
                        "self.total": [
                            951
                        ],
                        "hasattr": [
                            952,
                            953
                        ],
                        "self.iterable.shape": [
                            952
                        ],
                        "len": [
                            953
                        ],
                        "getattr": [
                            954
                        ]
                    },
                    "filtered_variables": {
                        "self.iterable": [
                            952,
                            953,
                            951
                        ],
                        "self": [
                            952,
                            953,
                            954,
                            951
                        ],
                        "self.total": [
                            951
                        ],
                        "self.iterable.shape": [
                            952
                        ]
                    },
                    "diff_line_number": 950,
                    "class_data": {
                        "signature": "class tqdm(Comparable)",
                        "docstring": "Decorate an iterable object, returning an iterator which acts exactly\nlike the original iterable, but prints a dynamically updating\nprogressbar every time a value is requested.",
                        "constructor_docstring": "Parameters\n----------\niterable  : iterable, optional\n    Iterable to decorate with a progressbar.\n    Leave blank to manually manage the updates.\ndesc  : str, optional\n    Prefix for the progressbar.\ntotal  : int, optional\n    The number of expected iterations. If unspecified,\n    len(iterable) is used if possible. If float(\"inf\") or as a last\n    resort, only basic progress statistics are displayed\n    (no ETA, no progressbar).\n    If `gui` is True and this parameter needs subsequent updating,\n    specify an initial arbitrary large positive integer,\n    e.g. int(9e9).\nleave  : bool, optional\n    If [default: True], keeps all traces of the progressbar\n    upon termination of iteration.\nfile  : `io.TextIOWrapper` or `io.StringIO`, optional\n    Specifies where to output the progress messages\n    (default: sys.stderr). Uses `file.write(str)` and `file.flush()`\n    methods.  For encoding, see `write_bytes`.\nncols  : int, optional\n    The width of the entire output message. If specified,\n    dynamically resizes the progressbar to stay within this bound.\n    If unspecified, attempts to use environment width. The\n    fallback is a meter width of 10 and no limit for the counter and\n    statistics. If 0, will not print any meter (only stats).\nmininterval  : float, optional\n    Minimum progress display update interval [default: 0.1] seconds.\nmaxinterval  : float, optional\n    Maximum progress display update interval [default: 10] seconds.\n    Automatically adjusts `miniters` to correspond to `mininterval`\n    after long display update lag. Only works if `dynamic_miniters`\n    or monitor thread is enabled.\nminiters  : int, optional\n    Minimum progress display update interval, in iterations.\n    If 0 and `dynamic_miniters`, will automatically adjust to equal\n    `mininterval` (more CPU efficient, good for tight loops).\n    If > 0, will skip display of specified number of iterations.\n    Tweak this and `mininterval` to get very efficient loops.\n    If your progress is erratic with both fast and slow iterations\n    (network, skipping items, etc) you should set miniters=1.\nascii  : bool or str, optional\n    If unspecified or False, use unicode (smooth blocks) to fill\n    the meter. The fallback is to use ASCII characters \" 123456789#\".\ndisable  : bool, optional\n    Whether to disable the entire progressbar wrapper\n    [default: False]. If set to None, disable on non-TTY.\nunit  : str, optional\n    String that will be used to define the unit of each iteration\n    [default: it].\nunit_scale  : bool or int or float, optional\n    If 1 or True, the number of iterations will be reduced/scaled\n    automatically and a metric prefix following the\n    International System of Units standard will be added\n    (kilo, mega, etc.) [default: False]. If any other non-zero\n    number, will scale `total` and `n`.\ndynamic_ncols  : bool, optional\n    If set, constantly alters `ncols` to the environment (allowing\n    for window resizes) [default: False].\nsmoothing  : float, optional\n    Exponential moving average smoothing factor for speed estimates\n    (ignored in GUI mode). Ranges from 0 (average speed) to 1\n    (current/instantaneous speed) [default: 0.3].\nbar_format  : str, optional\n    Specify a custom bar string formatting. May impact performance.\n    [default: '{l_bar}{bar}{r_bar}'], where\n    l_bar='{desc}: {percentage:3.0f}%|' and\n    r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n      '{rate_fmt}{postfix}]'\n    Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n      percentage, rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n      rate_inv, rate_inv_fmt, elapsed, elapsed_s, remaining,\n      remaining_s, desc, postfix, unit.\n    Note that a trailing \": \" is automatically removed after {desc}\n    if the latter is empty.\ninitial  : int, optional\n    The initial counter value. Useful when restarting a progress\n    bar [default: 0].\nposition  : int, optional\n    Specify the line offset to print this bar (starting from 0)\n    Automatic if unspecified.\n    Useful to manage multiple bars at once (eg, from threads).\npostfix  : dict or *, optional\n    Specify additional stats to display at the end of the bar.\n    Calls `set_postfix(**postfix)` if possible (dict).\nunit_divisor  : float, optional\n    [default: 1000], ignored unless `unit_scale` is True.\nwrite_bytes  : bool, optional\n    If (default: None) and `file` is unspecified,\n    bytes will be written in Python 2. If `True` will also write\n    bytes. In all other cases will default to unicode.\ngui  : bool, optional\n    WARNING: internal parameter - do not use.\n    Use tqdm_gui(...) instead. If set, will attempt to use\n    matplotlib animations for a graphical output [default: False].\n\nReturns\n-------\nout  : decorated iterator.",
                        "functions": [
                            "@staticmethod\ndef format_sizeof(num, suffix='', divisor=1000):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude\n    prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n    divisor  : float, optionl\n        Divisor between prefixes [default: 1000].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.5:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= divisor\n    return '{0:3.1f}Y'.format(num) + suffix",
                            "@staticmethod\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    (mins, s) = divmod(int(t), 60)\n    (h, m) = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)",
                            "@staticmethod\ndef format_num(n):\n    \"\"\"\n    Intelligent scientific notation (.3g).\n\n    Parameters\n    ----------\n    n  : int or float or Numeric\n        A Number.\n\n    Returns\n    -------\n    out  : str\n        Formatted number.\n    \"\"\"\n    f = '{0:.3g}'.format(n).replace('+0', '+').replace('-0', '-')\n    n = str(n)\n    return f if len(f) < len(n) else n",
                            "@staticmethod\ndef ema(x, mu=None, alpha=0.3):\n    \"\"\"\n    Exponential moving average: smoothing to give progressively lower\n    weights to older values.\n\n    Parameters\n    ----------\n    x  : float\n        New value to include in EMA.\n    mu  : float, optional\n        Previous EMA value.\n    alpha  : float, optional\n        Smoothing factor in range [0, 1], [default: 0.3].\n        Increase to give more weight to recent values.\n        Ranges from 0 (yields mu) to 1 (yields x).\n    \"\"\"\n    return x if mu is None else alpha * x + (1 - alpha) * mu",
                            "@staticmethod\ndef status_printer(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place\n    updating may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    fp_flush = getattr(fp, 'flush', lambda : None)\n\n    def fp_write(s):\n        fp.write(_unicode(s))\n        fp_flush()\n    last_len = [0]\n\n    def print_status(s):\n        len_s = len(s)\n        fp_write('\\r' + s + ' ' * max(last_len[0] - len_s, 0))\n        last_len[0] = len_s\n    return print_status",
                            "@staticmethod\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None, postfix=None, unit_divisor=1000, **extra_kwargs):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified,\n        dynamically resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress\n        bar + no limit for the iterations counter and statistics. If 0,\n        will not print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n        Use as {desc} in bar_format string.\n    ascii  : bool, optional or str, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters\n        \" 123456789#\".\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool or int or float, optional\n        If 1 or True, the number of iterations will be printed with an\n        appropriate SI metric prefix (k = 10^3, M = 10^6, etc.)\n        [default: False]. If any other non-zero number, will scale\n        `total` and `n`.\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where\n        l_bar='{desc}: {percentage:3.0f}%|' and\n        r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n          '{rate_fmt}{postfix}]'\n        Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n          percentage, rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n          rate_inv, rate_inv_fmt, elapsed, elapsed_s,\n          remaining, remaining_s, desc, postfix, unit.\n        Note that a trailing \": \" is automatically removed after {desc}\n        if the latter is empty.\n    postfix  : *, optional\n        Similar to `prefix`, but placed at the end\n        (e.g. for additional stats).\n        Note: postfix is usually a string (not a dict) for this method,\n        and will if possible be set to postfix = ', ' + postfix.\n        However other types are supported (#382).\n    unit_divisor  : float, optional\n        [default: 1000], ignored unless `unit_scale` is True.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    if unit_scale and unit_scale not in (True, 1):\n        if total:\n            total *= unit_scale\n        n *= unit_scale\n        if rate:\n            rate *= unit_scale\n        unit_scale = False\n    elapsed_str = tqdm.format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate else None\n    format_sizeof = tqdm.format_sizeof\n    rate_noinv_fmt = ((format_sizeof(rate) if unit_scale else '{0:5.2f}'.format(rate)) if rate else '?') + unit + '/s'\n    rate_inv_fmt = ((format_sizeof(inv_rate) if unit_scale else '{0:5.2f}'.format(inv_rate)) if inv_rate else '?') + 's/' + unit\n    rate_fmt = rate_inv_fmt if inv_rate and inv_rate > 1 else rate_noinv_fmt\n    if unit_scale:\n        n_fmt = format_sizeof(n, divisor=unit_divisor)\n        total_fmt = format_sizeof(total, divisor=unit_divisor) if total is not None else '?'\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total) if total is not None else '?'\n    try:\n        postfix = ', ' + postfix if postfix else ''\n    except TypeError:\n        pass\n    remaining = (total - n) / rate if rate and total else 0\n    remaining_str = tqdm.format_interval(remaining) if rate else '?'\n    if prefix:\n        bool_prefix_colon_already = prefix[-2:] == ': '\n        l_bar = prefix if bool_prefix_colon_already else prefix + ': '\n    else:\n        l_bar = ''\n    r_bar = '| {0}/{1} [{2}<{3}, {4}{5}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt, postfix)\n    format_dict = dict(n=n, n_fmt=n_fmt, total=total, total_fmt=total_fmt, rate=inv_rate if inv_rate and inv_rate > 1 else rate, rate_fmt=rate_fmt, rate_noinv=rate, rate_noinv_fmt=rate_noinv_fmt, rate_inv=inv_rate, rate_inv_fmt=rate_inv_fmt, elapsed=elapsed_str, elapsed_s=elapsed, remaining=remaining_str, remaining_s=remaining, l_bar=l_bar, r_bar=r_bar, desc=prefix or '', postfix=postfix, unit=unit, **extra_kwargs)\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        l_bar += '{0:3.0f}%|'.format(percentage)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        if bar_format:\n            format_dict.update(l_bar=l_bar, percentage=percentage)\n            if not prefix:\n                bar_format = bar_format.replace('{desc}: ', '')\n            if '{bar}' in bar_format:\n                (l_bar_user, r_bar_user) = bar_format.split('{bar}')\n                l_bar = l_bar_user.format(**format_dict)\n                r_bar = r_bar_user.format(**format_dict)\n            else:\n                return bar_format.format(**format_dict)\n        if ncols:\n            N_BARS = max(1, ncols - len(RE_ANSI.sub('', l_bar + r_bar)))\n        else:\n            N_BARS = 10\n        if ascii is True:\n            ascii = ASCII_FMT\n        elif ascii is False:\n            ascii = UTF_FMT\n        nsyms = len(ascii) - 1\n        (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * nsyms), nsyms)\n        bar = ascii[-1] * bar_length\n        frac_bar = ascii[frac_bar_length]\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ascii[0] * (N_BARS - bar_length - 1)\n        else:\n            full_bar = bar + ascii[0] * (N_BARS - bar_length)\n        return l_bar + full_bar + r_bar\n    elif bar_format:\n        return bar_format.format(bar='?', **format_dict)\n    else:\n        return (prefix + ': ' if prefix else '') + '{0}{1} [{2}, {3}{4}]'.format(n_fmt, unit, elapsed_str, rate_fmt, postfix)",
                            "def __new__(cls, *args, **kwargs):\n    instance = object.__new__(cls)\n    if not hasattr(cls, '_instances'):\n        cls._instances = WeakSet()\n    with cls.get_lock():\n        cls._instances.add(instance)\n    if cls.monitor_interval and (cls.monitor is None or not cls.monitor.report()):\n        try:\n            cls.monitor = TMonitor(cls, cls.monitor_interval)\n        except Exception as e:\n            warn('tqdm:disabling monitor support (monitor_interval = 0) due to:\\n' + str(e), TqdmMonitorWarning)\n            cls.monitor_interval = 0\n    return instance",
                            "@classmethod\ndef _get_free_pos(cls, instance=None):\n    \"\"\"Skips specified instance.\"\"\"\n    positions = set((abs(inst.pos) for inst in cls._instances if inst is not instance and hasattr(inst, 'pos')))\n    return min(set(range(len(positions) + 1)).difference(positions))",
                            "@classmethod\ndef _decr_instances(cls, instance):\n    \"\"\"\n    Remove from list and reposition other bars\n    so that newer bars won't overlap previous bars\n    \"\"\"\n    with cls._lock:\n        try:\n            cls._instances.remove(instance)\n        except KeyError:\n            pass\n        if not instance.gui:\n            for inst in cls._instances:\n                if hasattr(inst, 'pos') and inst.pos > abs(instance.pos):\n                    inst.pos -= 1\n    if not cls._instances and cls.monitor:\n        try:\n            cls.monitor.exit()\n            del cls.monitor\n        except AttributeError:\n            pass\n        else:\n            cls.monitor = None",
                            "@classmethod\ndef write(cls, s, file=None, end='\\n', nolock=False):\n    \"\"\"Print a message via tqdm (without overlap with bars).\"\"\"\n    fp = file if file is not None else sys.stdout\n    with cls.external_write_mode(file=file, nolock=nolock):\n        fp.write(s)\n        fp.write(end)",
                            "@classmethod\n@contextmanager\ndef external_write_mode(cls, file=None, nolock=False):\n    \"\"\"\n    Disable tqdm within context and refresh tqdm when exits.\n    Useful when writing to standard output stream\n    \"\"\"\n    fp = file if file is not None else sys.stdout\n    if not nolock:\n        cls.get_lock().acquire()\n    inst_cleared = []\n    for inst in getattr(cls, '_instances', []):\n        if hasattr(inst, 'start_t') and (inst.fp == fp or all((f in (sys.stdout, sys.stderr) for f in (fp, inst.fp)))):\n            inst.clear(nolock=True)\n            inst_cleared.append(inst)\n    yield\n    for inst in inst_cleared:\n        inst.refresh(nolock=True)\n    if not nolock:\n        cls._lock.release()",
                            "@classmethod\ndef set_lock(cls, lock):\n    \"\"\"Set the global lock.\"\"\"\n    cls._lock = lock",
                            "@classmethod\ndef get_lock(cls):\n    \"\"\"Get the global lock. Construct it if it does not exist.\"\"\"\n    if not hasattr(cls, '_lock'):\n        cls._lock = TqdmDefaultWriteLock()\n    return cls._lock",
                            "@classmethod\ndef pandas(tclass, *targs, **tkwargs):\n    \"\"\"\n    Registers the given `tqdm` class with\n        pandas.core.\n        ( frame.DataFrame\n        | series.Series\n        | groupby.DataFrameGroupBy\n        | groupby.SeriesGroupBy\n        ).progress_apply\n\n    A new instance will be create every time `progress_apply` is called,\n    and each instance will automatically close() upon completion.\n\n    Parameters\n    ----------\n    targs, tkwargs  : arguments for the tqdm instance\n\n    Examples\n    --------\n    >>> import pandas as pd\n    >>> import numpy as np\n    >>> from tqdm import tqdm, tqdm_gui\n    >>>\n    >>> df = pd.DataFrame(np.random.randint(0, 100, (100000, 6)))\n    >>> tqdm.pandas(ncols=50)  # can use tqdm_gui, optional kwargs, etc\n    >>> # Now you can use `progress_apply` instead of `apply`\n    >>> df.groupby(0).progress_apply(lambda x: x**2)\n\n    References\n    ----------\n    https://stackoverflow.com/questions/18603270/\n    progress-indicator-during-pandas-operations-python\n    \"\"\"\n    from pandas.core.frame import DataFrame\n    from pandas.core.series import Series\n    from pandas import Panel\n    try:\n        from pandas.core.window import _Rolling_and_Expanding\n    except ImportError:\n        _Rolling_and_Expanding = None\n    try:\n        from pandas.core.groupby.groupby import DataFrameGroupBy, SeriesGroupBy, GroupBy, PanelGroupBy\n    except ImportError:\n        from pandas.core.groupby import DataFrameGroupBy, SeriesGroupBy, GroupBy, PanelGroupBy\n    deprecated_t = [tkwargs.pop('deprecated_t', None)]\n\n    def inner_generator(df_function='apply'):\n\n        def inner(df, func, *args, **kwargs):\n            \"\"\"\n            Parameters\n            ----------\n            df  : (DataFrame|Series)[GroupBy]\n                Data (may be grouped).\n            func  : function\n                To be applied on the (grouped) data.\n            **kwargs  : optional\n                Transmitted to `df.apply()`.\n            \"\"\"\n            total = tkwargs.pop('total', getattr(df, 'ngroups', None))\n            if total is None:\n                if df_function == 'applymap':\n                    total = df.size\n                elif isinstance(df, Series):\n                    total = len(df)\n                elif _Rolling_and_Expanding is None or not isinstance(df, _Rolling_and_Expanding):\n                    axis = kwargs.get('axis', 0)\n                    if axis == 'index':\n                        axis = 0\n                    elif axis == 'columns':\n                        axis = 1\n                    total = df.size // df.shape[axis]\n            if deprecated_t[0] is not None:\n                t = deprecated_t[0]\n                deprecated_t[0] = None\n            else:\n                t = tclass(*targs, total=total, **tkwargs)\n            if len(args) > 0:\n                TqdmDeprecationWarning('Except func, normal arguments are intentionally' + ' not supported by' + ' `(DataFrame|Series|GroupBy).progress_apply`.' + ' Use keyword arguments instead.', fp_write=getattr(t.fp, 'write', sys.stderr.write))\n\n            def wrapper(*args, **kwargs):\n                t.update(n=1 if not t.total or t.n < t.total else 0)\n                return func(*args, **kwargs)\n            result = getattr(df, df_function)(wrapper, **kwargs)\n            t.close()\n            return result\n        return inner\n    Series.progress_apply = inner_generator()\n    SeriesGroupBy.progress_apply = inner_generator()\n    Series.progress_map = inner_generator('map')\n    SeriesGroupBy.progress_map = inner_generator('map')\n    DataFrame.progress_apply = inner_generator()\n    DataFrameGroupBy.progress_apply = inner_generator()\n    DataFrame.progress_applymap = inner_generator('applymap')\n    Panel.progress_apply = inner_generator()\n    PanelGroupBy.progress_apply = inner_generator()\n    GroupBy.progress_apply = inner_generator()\n    GroupBy.progress_aggregate = inner_generator('aggregate')\n    GroupBy.progress_transform = inner_generator('transform')\n    if _Rolling_and_Expanding is not None:\n        _Rolling_and_Expanding.progress_apply = inner_generator()",
                            "def __init__(self, iterable=None, desc=None, total=None, leave=True, file=None, ncols=None, mininterval=0.1, maxinterval=10.0, miniters=None, ascii=None, disable=False, unit='it', unit_scale=False, dynamic_ncols=False, smoothing=0.3, bar_format=None, initial=0, position=None, postfix=None, unit_divisor=1000, write_bytes=None, gui=False, **kwargs):\n    \"\"\"\n    Parameters\n    ----------\n    iterable  : iterable, optional\n        Iterable to decorate with a progressbar.\n        Leave blank to manually manage the updates.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If unspecified,\n        len(iterable) is used if possible. If float(\"inf\") or as a last\n        resort, only basic progress statistics are displayed\n        (no ETA, no progressbar).\n        If `gui` is True and this parameter needs subsequent updating,\n        specify an initial arbitrary large positive integer,\n        e.g. int(9e9).\n    leave  : bool, optional\n        If [default: True], keeps all traces of the progressbar\n        upon termination of iteration.\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages\n        (default: sys.stderr). Uses `file.write(str)` and `file.flush()`\n        methods.  For encoding, see `write_bytes`.\n    ncols  : int, optional\n        The width of the entire output message. If specified,\n        dynamically resizes the progressbar to stay within this bound.\n        If unspecified, attempts to use environment width. The\n        fallback is a meter width of 10 and no limit for the counter and\n        statistics. If 0, will not print any meter (only stats).\n    mininterval  : float, optional\n        Minimum progress display update interval [default: 0.1] seconds.\n    maxinterval  : float, optional\n        Maximum progress display update interval [default: 10] seconds.\n        Automatically adjusts `miniters` to correspond to `mininterval`\n        after long display update lag. Only works if `dynamic_miniters`\n        or monitor thread is enabled.\n    miniters  : int, optional\n        Minimum progress display update interval, in iterations.\n        If 0 and `dynamic_miniters`, will automatically adjust to equal\n        `mininterval` (more CPU efficient, good for tight loops).\n        If > 0, will skip display of specified number of iterations.\n        Tweak this and `mininterval` to get very efficient loops.\n        If your progress is erratic with both fast and slow iterations\n        (network, skipping items, etc) you should set miniters=1.\n    ascii  : bool or str, optional\n        If unspecified or False, use unicode (smooth blocks) to fill\n        the meter. The fallback is to use ASCII characters \" 123456789#\".\n    disable  : bool, optional\n        Whether to disable the entire progressbar wrapper\n        [default: False]. If set to None, disable on non-TTY.\n    unit  : str, optional\n        String that will be used to define the unit of each iteration\n        [default: it].\n    unit_scale  : bool or int or float, optional\n        If 1 or True, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.) [default: False]. If any other non-zero\n        number, will scale `total` and `n`.\n    dynamic_ncols  : bool, optional\n        If set, constantly alters `ncols` to the environment (allowing\n        for window resizes) [default: False].\n    smoothing  : float, optional\n        Exponential moving average smoothing factor for speed estimates\n        (ignored in GUI mode). Ranges from 0 (average speed) to 1\n        (current/instantaneous speed) [default: 0.3].\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where\n        l_bar='{desc}: {percentage:3.0f}%|' and\n        r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n          '{rate_fmt}{postfix}]'\n        Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n          percentage, rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n          rate_inv, rate_inv_fmt, elapsed, elapsed_s, remaining,\n          remaining_s, desc, postfix, unit.\n        Note that a trailing \": \" is automatically removed after {desc}\n        if the latter is empty.\n    initial  : int, optional\n        The initial counter value. Useful when restarting a progress\n        bar [default: 0].\n    position  : int, optional\n        Specify the line offset to print this bar (starting from 0)\n        Automatic if unspecified.\n        Useful to manage multiple bars at once (eg, from threads).\n    postfix  : dict or *, optional\n        Specify additional stats to display at the end of the bar.\n        Calls `set_postfix(**postfix)` if possible (dict).\n    unit_divisor  : float, optional\n        [default: 1000], ignored unless `unit_scale` is True.\n    write_bytes  : bool, optional\n        If (default: None) and `file` is unspecified,\n        bytes will be written in Python 2. If `True` will also write\n        bytes. In all other cases will default to unicode.\n    gui  : bool, optional\n        WARNING: internal parameter - do not use.\n        Use tqdm_gui(...) instead. If set, will attempt to use\n        matplotlib animations for a graphical output [default: False].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n    if write_bytes is None:\n        write_bytes = file is None and sys.version_info < (3,)\n    if file is None:\n        file = sys.stderr\n    if write_bytes:\n        file = SimpleTextIOWrapper(file, encoding=getattr(file, 'encoding', None) or 'utf-8')\n    if disable is None and hasattr(file, 'isatty') and (not file.isatty()):\n        disable = True\n    if total is None and iterable is not None:\n        try:\n            total = len(iterable)\n        except (TypeError, AttributeError):\n            total = None\n    if total == float('inf'):\n        total = None\n    if disable:\n        self.iterable = iterable\n        self.disable = disable\n        self.pos = self._get_free_pos(self)\n        self._instances.remove(self)\n        self.n = initial\n        self.total = total\n        return\n    if kwargs:\n        self.disable = True\n        self.pos = self._get_free_pos(self)\n        self._instances.remove(self)\n        from textwrap import dedent\n        raise TqdmDeprecationWarning(dedent('                       `nested` is deprecated and automated.\\n                       Use `position` instead for manual control.\\n                       '), fp_write=getattr(file, 'write', sys.stderr.write)) if 'nested' in kwargs else TqdmKeyError('Unknown argument(s): ' + str(kwargs))\n    if ncols is None and file in (sys.stderr, sys.stdout) or dynamic_ncols:\n        if dynamic_ncols:\n            dynamic_ncols = _environ_cols_wrapper()\n            if dynamic_ncols:\n                ncols = dynamic_ncols(file)\n        else:\n            _dynamic_ncols = _environ_cols_wrapper()\n            if _dynamic_ncols:\n                ncols = _dynamic_ncols(file)\n    if miniters is None:\n        miniters = 0\n        dynamic_miniters = True\n    else:\n        dynamic_miniters = False\n    if mininterval is None:\n        mininterval = 0\n    if maxinterval is None:\n        maxinterval = 0\n    if ascii is None:\n        ascii = not _supports_unicode(file)\n    if bar_format and (not (ascii is True or _is_ascii(ascii))):\n        bar_format = _unicode(bar_format)\n    if smoothing is None:\n        smoothing = 0\n    self.iterable = iterable\n    self.desc = desc or ''\n    self.total = total\n    self.leave = leave\n    self.fp = file\n    self.ncols = ncols\n    self.mininterval = mininterval\n    self.maxinterval = maxinterval\n    self.miniters = miniters\n    self.dynamic_miniters = dynamic_miniters\n    self.ascii = ascii\n    self.disable = disable\n    self.unit = unit\n    self.unit_scale = unit_scale\n    self.unit_divisor = unit_divisor\n    self.gui = gui\n    self.dynamic_ncols = dynamic_ncols\n    self.smoothing = smoothing\n    self.avg_time = None\n    self._time = time\n    self.bar_format = bar_format\n    self.postfix = None\n    if postfix:\n        try:\n            self.set_postfix(refresh=False, **postfix)\n        except TypeError:\n            self.postfix = postfix\n    self.last_print_n = initial\n    self.n = initial\n    with self._lock:\n        if position is None:\n            self.pos = self._get_free_pos(self)\n        else:\n            self.pos = -position\n    if not gui:\n        self.sp = self.status_printer(self.fp)\n        with self._lock:\n            self.display()\n    self.last_print_t = self._time()\n    self.start_t = self.last_print_t",
                            "def __len__(self):\n    return self.total if self.iterable is None else self.iterable.shape[0] if hasattr(self.iterable, 'shape') else len(self.iterable) if hasattr(self.iterable, '__len__') else getattr(self, 'total', None)",
                            "def __enter__(self):\n    return self",
                            "def __exit__(self, *exc):\n    self.close()\n    return False",
                            "def __del__(self):\n    self.close()",
                            "def __repr__(self):\n    return self.format_meter(**self.format_dict)",
                            "@property\ndef _comparable(self):\n    return abs(getattr(self, 'pos', 1 << 31))",
                            "def __hash__(self):\n    return id(self)",
                            "def __iter__(self):\n    \"\"\"Backward-compatibility to use: for x in tqdm(iterable)\"\"\"\n    iterable = self.iterable\n    if self.disable:\n        for obj in iterable:\n            yield obj\n    else:\n        mininterval = self.mininterval\n        maxinterval = self.maxinterval\n        miniters = self.miniters\n        dynamic_miniters = self.dynamic_miniters\n        last_print_t = self.last_print_t\n        last_print_n = self.last_print_n\n        n = self.n\n        smoothing = self.smoothing\n        avg_time = self.avg_time\n        _time = self._time\n        if not hasattr(self, 'sp'):\n            from textwrap import dedent\n            raise TqdmDeprecationWarning(dedent('                Please use `tqdm_gui(...)` instead of `tqdm(..., gui=True)`\\n                '), fp_write=getattr(self.fp, 'write', sys.stderr.write))\n        for obj in iterable:\n            yield obj\n            n += 1\n            if n - last_print_n >= self.miniters:\n                miniters = self.miniters\n                delta_t = _time() - last_print_t\n                if delta_t >= mininterval:\n                    cur_t = _time()\n                    delta_it = n - last_print_n\n                    if smoothing and delta_t and delta_it:\n                        rate = delta_t / delta_it\n                        avg_time = self.ema(rate, avg_time, smoothing)\n                        self.avg_time = avg_time\n                    self.n = n\n                    with self._lock:\n                        self.display()\n                    if dynamic_miniters:\n                        if maxinterval and delta_t >= maxinterval:\n                            if mininterval:\n                                miniters = delta_it * mininterval / delta_t\n                            else:\n                                miniters = delta_it * maxinterval / delta_t\n                        elif smoothing:\n                            rate = delta_it\n                            if mininterval and delta_t:\n                                rate *= mininterval / delta_t\n                            miniters = self.ema(rate, miniters, smoothing)\n                        else:\n                            miniters = max(miniters, delta_it)\n                    self.n = self.last_print_n = last_print_n = n\n                    self.last_print_t = last_print_t = cur_t\n                    self.miniters = miniters\n        self.last_print_n = last_print_n\n        self.n = n\n        self.miniters = miniters\n        self.close()",
                            "def update(self, n=1):\n    \"\"\"\n    Manually update the progress bar, useful for streams\n    such as reading files.\n    E.g.:\n    >>> t = tqdm(total=filesize) # Initialise\n    >>> for current_buffer in stream:\n    ...    ...\n    ...    t.update(len(current_buffer))\n    >>> t.close()\n    The last line is highly recommended, but possibly not necessary if\n    `t.update()` will be called in such a way that `filesize` will be\n    exactly reached and printed.\n\n    Parameters\n    ----------\n    n  : int, optional\n        Increment to add to the internal counter of iterations\n        [default: 1].\n    \"\"\"\n    if self.disable:\n        return\n    if n < 0:\n        self.last_print_n += n\n    self.n += n\n    if self.n - self.last_print_n >= self.miniters:\n        delta_t = self._time() - self.last_print_t\n        if delta_t >= self.mininterval:\n            cur_t = self._time()\n            delta_it = self.n - self.last_print_n\n            if self.smoothing and delta_t and delta_it:\n                rate = delta_t / delta_it\n                self.avg_time = self.ema(rate, self.avg_time, self.smoothing)\n            if not hasattr(self, 'sp'):\n                from textwrap import dedent\n                raise TqdmDeprecationWarning(dedent('                    Please use `tqdm_gui(...)` instead of `tqdm(..., gui=True)`\\n                    '), fp_write=getattr(self.fp, 'write', sys.stderr.write))\n            with self._lock:\n                self.display()\n            if self.dynamic_miniters:\n                if self.maxinterval and delta_t >= self.maxinterval:\n                    if self.mininterval:\n                        self.miniters = delta_it * self.mininterval / delta_t\n                    else:\n                        self.miniters = delta_it * self.maxinterval / delta_t\n                elif self.smoothing:\n                    self.miniters = self.smoothing * delta_it * (self.mininterval / delta_t if self.mininterval and delta_t else 1) + (1 - self.smoothing) * self.miniters\n                else:\n                    self.miniters = max(self.miniters, delta_it)\n            self.last_print_n = self.n\n            self.last_print_t = cur_t",
                            "def close(self):\n    \"\"\"Cleanup and (if leave=False) close the progressbar.\"\"\"\n    if self.disable:\n        return\n    self.disable = True\n    pos = abs(self.pos)\n    self._decr_instances(self)\n    if not hasattr(self, 'sp'):\n        return\n\n    def fp_write(s):\n        self.fp.write(_unicode(s))\n    try:\n        fp_write('')\n    except ValueError as e:\n        if 'closed' in str(e):\n            return\n        raise\n    with self._lock:\n        if self.leave:\n            if self.last_print_n < self.n:\n                self.avg_time = None\n                self.display(pos=pos)\n            if not max([abs(getattr(i, 'pos', 0)) for i in self._instances] + [pos]):\n                fp_write('\\n')\n        else:\n            self.display(msg='', pos=pos)\n            if not pos:\n                fp_write('\\r')",
                            "def clear(self, nolock=False):\n    \"\"\"Clear current bar display.\"\"\"\n    if self.disable:\n        return\n    if not nolock:\n        self._lock.acquire()\n    self.moveto(abs(self.pos))\n    self.sp('')\n    self.fp.write('\\r')\n    self.moveto(-abs(self.pos))\n    if not nolock:\n        self._lock.release()",
                            "def refresh(self, nolock=False):\n    \"\"\"Force refresh the display of this bar.\"\"\"\n    if self.disable:\n        return\n    if not nolock:\n        self._lock.acquire()\n    self.display()\n    if not nolock:\n        self._lock.release()",
                            "def unpause(self):\n    \"\"\"Restart tqdm timer from last print time.\"\"\"\n    cur_t = self._time()\n    self.start_t += cur_t - self.last_print_t\n    self.last_print_t = cur_t",
                            "def reset(self, total=None):\n    \"\"\"\n    Resets to 0 iterations for repeated use.\n\n    Consider combining with `leave=True`.\n\n    Parameters\n    ----------\n    total  : int, optional. Total to use for the new bar.\n    \"\"\"\n    self.last_print_n = self.n = 0\n    self.last_print_t = self.start_t = self._time()\n    if total is not None:\n        self.total = total\n    self.refresh()",
                            "def set_description(self, desc=None, refresh=True):\n    \"\"\"\n    Set/modify description of the progress bar.\n\n    Parameters\n    ----------\n    desc  : str, optional\n    refresh  : bool, optional\n        Forces refresh [default: True].\n    \"\"\"\n    self.desc = desc + ': ' if desc else ''\n    if refresh:\n        self.refresh()",
                            "def set_description_str(self, desc=None, refresh=True):\n    \"\"\"Set/modify description without ': ' appended.\"\"\"\n    self.desc = desc or ''\n    if refresh:\n        self.refresh()",
                            "def set_postfix(self, ordered_dict=None, refresh=True, **kwargs):\n    \"\"\"\n    Set/modify postfix (additional stats)\n    with automatic formatting based on datatype.\n\n    Parameters\n    ----------\n    ordered_dict  : dict or OrderedDict, optional\n    refresh  : bool, optional\n        Forces refresh [default: True].\n    kwargs  : dict, optional\n    \"\"\"\n    postfix = _OrderedDict([] if ordered_dict is None else ordered_dict)\n    for key in sorted(kwargs.keys()):\n        postfix[key] = kwargs[key]\n    for key in postfix.keys():\n        if isinstance(postfix[key], Number):\n            postfix[key] = self.format_num(postfix[key])\n        elif not isinstance(postfix[key], _basestring):\n            postfix[key] = str(postfix[key])\n    self.postfix = ', '.join((key + '=' + postfix[key].strip() for key in postfix.keys()))\n    if refresh:\n        self.refresh()",
                            "def set_postfix_str(self, s='', refresh=True):\n    \"\"\"\n    Postfix without dictionary expansion, similar to prefix handling.\n    \"\"\"\n    self.postfix = str(s)\n    if refresh:\n        self.refresh()",
                            "def moveto(self, n):\n    self.fp.write(_unicode('\\n' * n + _term_move_up() * -n))\n    self.fp.flush()",
                            "@property\ndef format_dict(self):\n    \"\"\"Public API for read-only member access.\"\"\"\n    return dict(n=self.n, total=self.total, elapsed=self._time() - self.start_t if hasattr(self, 'start_t') else 0, ncols=self.dynamic_ncols(self.fp) if self.dynamic_ncols else self.ncols, prefix=self.desc, ascii=self.ascii, unit=self.unit, unit_scale=self.unit_scale, rate=1 / self.avg_time if self.avg_time else None, bar_format=self.bar_format, postfix=self.postfix, unit_divisor=self.unit_divisor)",
                            "def display(self, msg=None, pos=None):\n    \"\"\"\n    Use `self.sp` to display `msg` in the specified `pos`.\n\n    Consider overloading this function when inheriting to use e.g.:\n    `self.some_frontend(**self.format_dict)` instead of `self.sp`.\n\n    Parameters\n    ----------\n    msg  : str, optional. What to display (default: `repr(self)`).\n    pos  : int, optional. Position to `moveto`\n      (default: `abs(self.pos)`).\n    \"\"\"\n    if pos is None:\n        pos = abs(self.pos)\n    if pos:\n        self.moveto(pos)\n    self.sp(self.__repr__() if msg is None else msg)\n    if pos:\n        self.moveto(-pos)",
                            "def fp_write(s):\n    fp.write(_unicode(s))\n    fp_flush()",
                            "def print_status(s):\n    len_s = len(s)\n    fp_write('\\r' + s + ' ' * max(last_len[0] - len_s, 0))\n    last_len[0] = len_s",
                            "def inner_generator(df_function='apply'):\n\n    def inner(df, func, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        df  : (DataFrame|Series)[GroupBy]\n            Data (may be grouped).\n        func  : function\n            To be applied on the (grouped) data.\n        **kwargs  : optional\n            Transmitted to `df.apply()`.\n        \"\"\"\n        total = tkwargs.pop('total', getattr(df, 'ngroups', None))\n        if total is None:\n            if df_function == 'applymap':\n                total = df.size\n            elif isinstance(df, Series):\n                total = len(df)\n            elif _Rolling_and_Expanding is None or not isinstance(df, _Rolling_and_Expanding):\n                axis = kwargs.get('axis', 0)\n                if axis == 'index':\n                    axis = 0\n                elif axis == 'columns':\n                    axis = 1\n                total = df.size // df.shape[axis]\n        if deprecated_t[0] is not None:\n            t = deprecated_t[0]\n            deprecated_t[0] = None\n        else:\n            t = tclass(*targs, total=total, **tkwargs)\n        if len(args) > 0:\n            TqdmDeprecationWarning('Except func, normal arguments are intentionally' + ' not supported by' + ' `(DataFrame|Series|GroupBy).progress_apply`.' + ' Use keyword arguments instead.', fp_write=getattr(t.fp, 'write', sys.stderr.write))\n\n        def wrapper(*args, **kwargs):\n            t.update(n=1 if not t.total or t.n < t.total else 0)\n            return func(*args, **kwargs)\n        result = getattr(df, df_function)(wrapper, **kwargs)\n        t.close()\n        return result\n    return inner",
                            "def fp_write(s):\n    self.fp.write(_unicode(s))",
                            "def inner(df, func, *args, **kwargs):\n    \"\"\"\n    Parameters\n    ----------\n    df  : (DataFrame|Series)[GroupBy]\n        Data (may be grouped).\n    func  : function\n        To be applied on the (grouped) data.\n    **kwargs  : optional\n        Transmitted to `df.apply()`.\n    \"\"\"\n    total = tkwargs.pop('total', getattr(df, 'ngroups', None))\n    if total is None:\n        if df_function == 'applymap':\n            total = df.size\n        elif isinstance(df, Series):\n            total = len(df)\n        elif _Rolling_and_Expanding is None or not isinstance(df, _Rolling_and_Expanding):\n            axis = kwargs.get('axis', 0)\n            if axis == 'index':\n                axis = 0\n            elif axis == 'columns':\n                axis = 1\n            total = df.size // df.shape[axis]\n    if deprecated_t[0] is not None:\n        t = deprecated_t[0]\n        deprecated_t[0] = None\n    else:\n        t = tclass(*targs, total=total, **tkwargs)\n    if len(args) > 0:\n        TqdmDeprecationWarning('Except func, normal arguments are intentionally' + ' not supported by' + ' `(DataFrame|Series|GroupBy).progress_apply`.' + ' Use keyword arguments instead.', fp_write=getattr(t.fp, 'write', sys.stderr.write))\n\n    def wrapper(*args, **kwargs):\n        t.update(n=1 if not t.total or t.n < t.total else 0)\n        return func(*args, **kwargs)\n    result = getattr(df, df_function)(wrapper, **kwargs)\n    t.close()\n    return result",
                            "def wrapper(*args, **kwargs):\n    t.update(n=1 if not t.total or t.n < t.total else 0)\n    return func(*args, **kwargs)"
                        ],
                        "constructor_variables": [
                            "self.iterable = iterable",
                            "self.disable = disable",
                            "self.pos = self._get_free_pos(self)",
                            "self.n = initial",
                            "self.total = total",
                            "self.disable = True",
                            "self.pos = self._get_free_pos(self)",
                            "self.iterable = iterable",
                            "self.desc = desc or ''",
                            "self.total = total",
                            "self.leave = leave",
                            "self.fp = file",
                            "self.ncols = ncols",
                            "self.mininterval = mininterval",
                            "self.maxinterval = maxinterval",
                            "self.miniters = miniters",
                            "self.dynamic_miniters = dynamic_miniters",
                            "self.ascii = ascii",
                            "self.disable = disable",
                            "self.unit = unit",
                            "self.unit_scale = unit_scale",
                            "self.unit_divisor = unit_divisor",
                            "self.gui = gui",
                            "self.dynamic_ncols = dynamic_ncols",
                            "self.smoothing = smoothing",
                            "self.avg_time = None",
                            "self._time = time",
                            "self.bar_format = bar_format",
                            "self.postfix = None",
                            "self.postfix = postfix",
                            "self.last_print_n = initial",
                            "self.n = initial",
                            "self.pos = self._get_free_pos(self)",
                            "self.pos = -position",
                            "self.sp = self.status_printer(self.fp)",
                            "self.last_print_t = self._time()",
                            "self.start_t = self.last_print_t"
                        ],
                        "class_level_variables": [
                            "monitor_interval = 10",
                            "monitor = None"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "format_sizeof(num, suffix='', divisor=1000)",
                            "format_interval(t)",
                            "format_num(n)",
                            "ema(x, mu=None, alpha=0.3)",
                            "status_printer(file)",
                            "format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None, postfix=None, unit_divisor=1000, **extra_kwargs)",
                            "__new__(cls, *args, **kwargs)",
                            "_get_free_pos(cls, instance=None)",
                            "_decr_instances(cls, instance)",
                            "write(cls, s, file=None, end='\\n', nolock=False)",
                            "external_write_mode(cls, file=None, nolock=False)",
                            "set_lock(cls, lock)",
                            "get_lock(cls)",
                            "pandas(tclass, *targs, **tkwargs)",
                            "__init__(self, iterable=None, desc=None, total=None, leave=True, file=None, ncols=None, mininterval=0.1, maxinterval=10.0, miniters=None, ascii=None, disable=False, unit='it', unit_scale=False, dynamic_ncols=False, smoothing=0.3, bar_format=None, initial=0, position=None, postfix=None, unit_divisor=1000, write_bytes=None, gui=False, **kwargs)",
                            "__len__(self)",
                            "__enter__(self)",
                            "__exit__(self, *exc)",
                            "__del__(self)",
                            "__repr__(self)",
                            "_comparable(self)",
                            "__hash__(self)",
                            "__iter__(self)",
                            "update(self, n=1)",
                            "close(self)",
                            "clear(self, nolock=False)",
                            "refresh(self, nolock=False)",
                            "unpause(self)",
                            "reset(self, total=None)",
                            "set_description(self, desc=None, refresh=True)",
                            "set_description_str(self, desc=None, refresh=True)",
                            "set_postfix(self, ordered_dict=None, refresh=True, **kwargs)",
                            "set_postfix_str(self, s='', refresh=True)",
                            "moveto(self, n)",
                            "format_dict(self)",
                            "display(self, msg=None, pos=None)",
                            "fp_write(s)",
                            "print_status(s)",
                            "inner_generator(df_function='apply')",
                            "fp_write(s)",
                            "inner(df, func, *args, **kwargs)",
                            "wrapper(*args, **kwargs)"
                        ],
                        "class_level_variable_names": [
                            "monitor_interval",
                            "monitor"
                        ],
                        "constructor_variable_names": [
                            "disable",
                            "n",
                            "last_print_n",
                            "sp",
                            "mininterval",
                            "total",
                            "desc",
                            "avg_time",
                            "last_print_t",
                            "unit_scale",
                            "pos",
                            "bar_format",
                            "unit_divisor",
                            "unit",
                            "maxinterval",
                            "_dynamic_ncols",
                            "smoothing",
                            "fp",
                            "gui",
                            "write_bytes",
                            "postfix",
                            "miniters",
                            "dynamic_miniters",
                            "ncols",
                            "iterable",
                            "_time",
                            "start_t",
                            "dynamic_ncols",
                            "file",
                            "ascii",
                            "leave"
                        ]
                    },
                    "used_imports": [],
                    "variable_values": [
                        [
                            {
                                "self.iterable": {
                                    "variable_value": "range(0, 10)",
                                    "variable_type": "range",
                                    "variable_shape": "10"
                                },
                                "self": {
                                    "variable_value": "  0%",
                                    "variable_type": "tqdm",
                                    "variable_shape": "          "
                                },
                                "self.total": {
                                    "variable_value": "10",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self.iterable.shape": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.iterable": {
                                    "variable_value": "range(0, 10)",
                                    "variable_type": "range",
                                    "variable_shape": "10"
                                },
                                "self": {
                                    "variable_value": "  0%",
                                    "variable_type": "tqdm",
                                    "variable_shape": "          "
                                },
                                "self.total": {
                                    "variable_value": "10",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self.iterable.shape": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "self.iterable": {
                                    "variable_value": "range(0, 0)",
                                    "variable_type": "range",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "0it [00:00, ?it/s]",
                                    "variable_type": "tqdm",
                                    "variable_shape": null
                                },
                                "self.total": {
                                    "variable_value": "0",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self.iterable.shape": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.iterable": {
                                    "variable_value": "range(0, 0)",
                                    "variable_type": "range",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "0it [00:00, ?it/s]",
                                    "variable_type": "tqdm",
                                    "variable_shape": null
                                },
                                "self.total": {
                                    "variable_value": "0",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self.iterable.shape": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "self.iterable": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "  0%",
                                    "variable_type": "tqdm",
                                    "variable_shape": "          "
                                },
                                "self.total": {
                                    "variable_value": "10",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self.iterable.shape": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.iterable": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "  0%",
                                    "variable_type": "tqdm",
                                    "variable_shape": "          "
                                },
                                "self.total": {
                                    "variable_value": "10",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self.iterable.shape": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "self.iterable": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "0it [00:00, ?it/s]",
                                    "variable_type": "tqdm",
                                    "variable_shape": null
                                },
                                "self.total": {
                                    "variable_value": "0",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self.iterable.shape": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.iterable": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "0it [00:00, ?it/s]",
                                    "variable_type": "tqdm",
                                    "variable_shape": null
                                },
                                "self.total": {
                                    "variable_value": "0",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self.iterable.shape": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "self.iterable": {
                                    "variable_value": "[]",
                                    "variable_type": "list",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "0it [00:00, ?it/s]",
                                    "variable_type": "tqdm",
                                    "variable_shape": null
                                },
                                "self.total": {
                                    "variable_value": "0",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self.iterable.shape": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.iterable": {
                                    "variable_value": "[]",
                                    "variable_type": "list",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "0it [00:00, ?it/s]",
                                    "variable_type": "tqdm",
                                    "variable_shape": null
                                },
                                "self.total": {
                                    "variable_value": "0",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self.iterable.shape": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "self.iterable": {
                                    "variable_value": "[0]",
                                    "variable_type": "list",
                                    "variable_shape": "1"
                                },
                                "self": {
                                    "variable_value": "  0%",
                                    "variable_type": "tqdm",
                                    "variable_shape": "          "
                                },
                                "self.total": {
                                    "variable_value": "1",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self.iterable.shape": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.iterable": {
                                    "variable_value": "[0]",
                                    "variable_type": "list",
                                    "variable_shape": "1"
                                },
                                "self": {
                                    "variable_value": "  0%",
                                    "variable_type": "tqdm",
                                    "variable_shape": "          "
                                },
                                "self.total": {
                                    "variable_value": "1",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self.iterable.shape": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "self.iterable": {
                                    "variable_value": "<generator object test_bool.<locals>.internal.<locals>.<genexpr> at 0x7fdedd1a83d0>",
                                    "variable_type": "generator",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "0it [00:00, ?it/s]",
                                    "variable_type": "tqdm",
                                    "variable_shape": null
                                },
                                "self.total": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iterable.shape": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.iterable": {
                                    "variable_value": "<generator object test_bool.<locals>.internal.<locals>.<genexpr> at 0x7fdedd1a83d0>",
                                    "variable_type": "generator",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "0it [00:00, ?it/s]",
                                    "variable_type": "tqdm",
                                    "variable_shape": null
                                },
                                "self.total": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.iterable.shape": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)",
                "def __init__(self, msg, fp_write=None, *a, **k):\n    if fp_write is not None:\n        fp_write(\"\\n\" + self.__class__.__name__ + \": \" +\n                 str(msg).rstrip() + '\\n')\n    else:\n        super(TqdmWarning, self).__init__(msg, *a, **k)",
                "def __init__(self):\n    # Create global parallelism locks to avoid racing issues with parallel\n    # bars works only if fork available (Linux/MacOSX, but not Windows)\n    self.create_mp_lock()\n    self.create_th_lock()\n    cls = type(self)\n    self.locks = [lk for lk in [cls.mp_lock, cls.th_lock] if lk is not None]",
                "def acquire(self):\n    for lock in self.locks:\n        lock.acquire()",
                "def release(self):\n    for lock in self.locks[::-1]:  # Release in inverse order of acquisition\n        lock.release()",
                "def __enter__(self):\n    self.acquire()",
                "def __exit__(self, *exc):\n    self.release()",
                "@classmethod\ndef create_mp_lock(cls):\n    if not hasattr(cls, 'mp_lock'):\n        try:\n            cls.mp_lock = mp.RLock()  # multiprocessing lock\n        except ImportError:  # pragma: no cover\n            cls.mp_lock = None\n        except OSError:  # pragma: no cover\n            cls.mp_lock = None",
                "@classmethod\ndef create_th_lock(cls):\n    if not hasattr(cls, 'th_lock'):\n        try:\n            cls.th_lock = th.RLock()  # thread lock\n        except OSError:  # pragma: no cover\n            cls.th_lock = None",
                "@staticmethod\ndef format_sizeof(num, suffix='', divisor=1000):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude\n    prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n    divisor  : float, optionl\n        Divisor between prefixes [default: 1000].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.5:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= divisor\n    return '{0:3.1f}Y'.format(num) + suffix",
                "@staticmethod\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)",
                "@staticmethod\ndef format_num(n):\n    \"\"\"\n    Intelligent scientific notation (.3g).\n\n    Parameters\n    ----------\n    n  : int or float or Numeric\n        A Number.\n\n    Returns\n    -------\n    out  : str\n        Formatted number.\n    \"\"\"\n    f = '{0:.3g}'.format(n).replace('+0', '+').replace('-0', '-')\n    n = str(n)\n    return f if len(f) < len(n) else n",
                "@staticmethod\ndef ema(x, mu=None, alpha=0.3):\n    \"\"\"\n    Exponential moving average: smoothing to give progressively lower\n    weights to older values.\n\n    Parameters\n    ----------\n    x  : float\n        New value to include in EMA.\n    mu  : float, optional\n        Previous EMA value.\n    alpha  : float, optional\n        Smoothing factor in range [0, 1], [default: 0.3].\n        Increase to give more weight to recent values.\n        Ranges from 0 (yields mu) to 1 (yields x).\n    \"\"\"\n    return x if mu is None else (alpha * x) + (1 - alpha) * mu",
                "@staticmethod\ndef status_printer(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place\n    updating may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    fp_flush = getattr(fp, 'flush', lambda: None)  # pragma: no cover\n\n    def fp_write(s):\n        fp.write(_unicode(s))\n        fp_flush()\n\n    last_len = [0]\n\n    def print_status(s):\n        len_s = len(s)\n        fp_write('\\r' + s + (' ' * max(last_len[0] - len_s, 0)))\n        last_len[0] = len_s\n\n    return print_status",
                "@staticmethod\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False, rate=None, bar_format=None,\n                 postfix=None, unit_divisor=1000, **extra_kwargs):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified,\n        dynamically resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress\n        bar + no limit for the iterations counter and statistics. If 0,\n        will not print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n        Use as {desc} in bar_format string.\n    ascii  : bool, optional or str, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters\n        \" 123456789#\".\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool or int or float, optional\n        If 1 or True, the number of iterations will be printed with an\n        appropriate SI metric prefix (k = 10^3, M = 10^6, etc.)\n        [default: False]. If any other non-zero number, will scale\n        `total` and `n`.\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where\n        l_bar='{desc}: {percentage:3.0f}%|' and\n        r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n          '{rate_fmt}{postfix}]'\n        Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n          percentage, rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n          rate_inv, rate_inv_fmt, elapsed, elapsed_s,\n          remaining, remaining_s, desc, postfix, unit.\n        Note that a trailing \": \" is automatically removed after {desc}\n        if the latter is empty.\n    postfix  : *, optional\n        Similar to `prefix`, but placed at the end\n        (e.g. for additional stats).\n        Note: postfix is usually a string (not a dict) for this method,\n        and will if possible be set to postfix = ', ' + postfix.\n        However other types are supported (#382).\n    unit_divisor  : float, optional\n        [default: 1000], ignored unless `unit_scale` is True.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # sanity check: total\n    if total and n > total:\n        total = None\n\n    # apply custom scale if necessary\n    if unit_scale and unit_scale not in (True, 1):\n        if total:\n            total *= unit_scale\n        n *= unit_scale\n        if rate:\n            rate *= unit_scale  # by default rate = 1 / self.avg_time\n        unit_scale = False\n\n    elapsed_str = tqdm.format_interval(elapsed)\n\n    # if unspecified, attempt to use rate = average speed\n    # (we allow manual override since predicting time is an arcane art)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate else None\n    format_sizeof = tqdm.format_sizeof\n    rate_noinv_fmt = ((format_sizeof(rate) if unit_scale else\n                       '{0:5.2f}'.format(rate))\n                      if rate else '?') + unit + '/s'\n    rate_inv_fmt = ((format_sizeof(inv_rate) if unit_scale else\n                     '{0:5.2f}'.format(inv_rate))\n                    if inv_rate else '?') + 's/' + unit\n    rate_fmt = rate_inv_fmt if inv_rate and inv_rate > 1 else rate_noinv_fmt\n\n    if unit_scale:\n        n_fmt = format_sizeof(n, divisor=unit_divisor)\n        total_fmt = format_sizeof(total, divisor=unit_divisor) \\\n            if total is not None else '?'\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total) if total is not None else '?'\n\n    try:\n        postfix = ', ' + postfix if postfix else ''\n    except TypeError:\n        pass\n\n    remaining = (total - n) / rate if rate and total else 0\n    remaining_str = tqdm.format_interval(remaining) if rate else '?'\n\n    # format the stats displayed to the left and right sides of the bar\n    if prefix:\n        # old prefix setup work around\n        bool_prefix_colon_already = (prefix[-2:] == \": \")\n        l_bar = prefix if bool_prefix_colon_already else prefix + \": \"\n    else:\n        l_bar = ''\n\n    r_bar = '| {0}/{1} [{2}<{3}, {4}{5}]'.format(\n        n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt, postfix)\n\n    # Custom bar formatting\n    # Populate a dict with all available progress indicators\n    format_dict = dict(\n        n=n, n_fmt=n_fmt, total=total, total_fmt=total_fmt,\n        rate=inv_rate if inv_rate and inv_rate > 1 else rate,\n        rate_fmt=rate_fmt, rate_noinv=rate,\n        rate_noinv_fmt=rate_noinv_fmt, rate_inv=inv_rate,\n        rate_inv_fmt=rate_inv_fmt,\n        elapsed=elapsed_str, elapsed_s=elapsed,\n        remaining=remaining_str, remaining_s=remaining,\n        l_bar=l_bar, r_bar=r_bar,\n        desc=prefix or '', postfix=postfix, unit=unit,\n        # bar=full_bar,  # replaced by procedure below\n        **extra_kwargs)\n\n    # total is known: we can predict some stats\n    if total:\n        # fractional and percentage progress\n        frac = n / total\n        percentage = frac * 100\n\n        l_bar += '{0:3.0f}%|'.format(percentage)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        if bar_format:\n            format_dict.update(l_bar=l_bar, percentage=percentage)\n            # , bar=full_bar  # replaced by procedure below\n\n            # auto-remove colon for empty `desc`\n            if not prefix:\n                bar_format = bar_format.replace(\"{desc}: \", '')\n\n            # Interpolate supplied bar format with the dict\n            if '{bar}' in bar_format:\n                # Format left/right sides of the bar, and format the bar\n                # later in the remaining space (avoid breaking display)\n                l_bar_user, r_bar_user = bar_format.split('{bar}')\n                l_bar = l_bar_user.format(**format_dict)\n                r_bar = r_bar_user.format(**format_dict)\n            else:\n                # Else no progress bar, we can just format and return\n                return bar_format.format(**format_dict)\n\n        # Formatting progress bar space available for bar's display\n        if ncols:\n            N_BARS = max(1, ncols - len(RE_ANSI.sub('', l_bar + r_bar)))\n        else:\n            N_BARS = 10\n\n        # format bar depending on availability of unicode/ascii chars\n        if ascii is True:\n            ascii = ASCII_FMT\n        elif ascii is False:\n            ascii = UTF_FMT\n        nsyms = len(ascii) - 1\n        bar_length, frac_bar_length = divmod(\n            int(frac * N_BARS * nsyms), nsyms)\n\n        bar = ascii[-1] * bar_length\n        frac_bar = ascii[frac_bar_length]\n\n        # whitespace padding\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ascii[0] * (N_BARS - bar_length - 1)\n        else:\n            full_bar = bar + \\\n                ascii[0] * (N_BARS - bar_length)\n\n        # Piece together the bar parts\n        return l_bar + full_bar + r_bar\n\n    elif bar_format:\n        # user-specified bar_format but no total\n        return bar_format.format(bar='?', **format_dict)\n    else:\n        # no total: no progressbar, ETA, just progress stats\n        return ((prefix + \": \") if prefix else '') + \\\n            '{0}{1} [{2}, {3}{4}]'.format(\n                n_fmt, unit, elapsed_str, rate_fmt, postfix)",
                "def __new__(cls, *args, **kwargs):\n    # Create a new instance\n    instance = object.__new__(cls)\n    # Add to the list of instances\n    if not hasattr(cls, '_instances'):\n        cls._instances = WeakSet()\n    # Construct the lock if it does not exist\n    with cls.get_lock():\n        cls._instances.add(instance)\n    # Create the monitoring thread\n    if cls.monitor_interval and (cls.monitor is None or not\n                                 cls.monitor.report()):\n        try:\n            cls.monitor = TMonitor(cls, cls.monitor_interval)\n        except Exception as e:  # pragma: nocover\n            warn(\"tqdm:disabling monitor support\"\n                 \" (monitor_interval = 0) due to:\\n\" + str(e),\n                 TqdmMonitorWarning)\n            cls.monitor_interval = 0\n    # Return the instance\n    return instance",
                "@classmethod\ndef _get_free_pos(cls, instance=None):\n    \"\"\"Skips specified instance.\"\"\"\n    positions = set(abs(inst.pos) for inst in cls._instances\n                    if inst is not instance and hasattr(inst, \"pos\"))\n    return min(set(range(len(positions) + 1)).difference(positions))",
                "@classmethod\ndef _decr_instances(cls, instance):\n    \"\"\"\n    Remove from list and reposition other bars\n    so that newer bars won't overlap previous bars\n    \"\"\"\n    with cls._lock:\n        try:\n            cls._instances.remove(instance)\n        except KeyError:\n            # if not instance.gui:  # pragma: no cover\n            #     raise\n            pass  # py2: maybe magically removed already\n        # else:\n        if not instance.gui:\n            for inst in cls._instances:\n                # negative `pos` means fixed\n                if hasattr(inst, \"pos\") and inst.pos > abs(instance.pos):\n                    inst.pos -= 1\n                    # TODO: check this doesn't overwrite another fixed bar\n    # Kill monitor if no instances are left\n    if not cls._instances and cls.monitor:\n        try:\n            cls.monitor.exit()\n            del cls.monitor\n        except AttributeError:  # pragma: nocover\n            pass\n        else:\n            cls.monitor = None",
                "@classmethod\ndef write(cls, s, file=None, end=\"\\n\", nolock=False):\n    \"\"\"Print a message via tqdm (without overlap with bars).\"\"\"\n    fp = file if file is not None else sys.stdout\n    with cls.external_write_mode(file=file, nolock=nolock):\n        # Write the message\n        fp.write(s)\n        fp.write(end)",
                "@classmethod\n@contextmanager\ndef external_write_mode(cls, file=None, nolock=False):\n    \"\"\"\n    Disable tqdm within context and refresh tqdm when exits.\n    Useful when writing to standard output stream\n    \"\"\"\n    fp = file if file is not None else sys.stdout\n\n    if not nolock:\n        cls.get_lock().acquire()\n    # Clear all bars\n    inst_cleared = []\n    for inst in getattr(cls, '_instances', []):\n        # Clear instance if in the target output file\n        # or if write output + tqdm output are both either\n        # sys.stdout or sys.stderr (because both are mixed in terminal)\n        if hasattr(inst, \"start_t\") and (inst.fp == fp or all(\n                f in (sys.stdout, sys.stderr) for f in (fp, inst.fp))):\n            inst.clear(nolock=True)\n            inst_cleared.append(inst)\n    yield\n    # Force refresh display of bars we cleared\n    for inst in inst_cleared:\n        inst.refresh(nolock=True)\n    if not nolock:\n        cls._lock.release()",
                "@classmethod\ndef set_lock(cls, lock):\n    \"\"\"Set the global lock.\"\"\"\n    cls._lock = lock",
                "@classmethod\ndef get_lock(cls):\n    \"\"\"Get the global lock. Construct it if it does not exist.\"\"\"\n    if not hasattr(cls, '_lock'):\n        cls._lock = TqdmDefaultWriteLock()\n    return cls._lock",
                "@classmethod\ndef pandas(tclass, *targs, **tkwargs):\n    \"\"\"\n    Registers the given `tqdm` class with\n        pandas.core.\n        ( frame.DataFrame\n        | series.Series\n        | groupby.DataFrameGroupBy\n        | groupby.SeriesGroupBy\n        ).progress_apply\n\n    A new instance will be create every time `progress_apply` is called,\n    and each instance will automatically close() upon completion.\n\n    Parameters\n    ----------\n    targs, tkwargs  : arguments for the tqdm instance\n\n    Examples\n    --------\n    >>> import pandas as pd\n    >>> import numpy as np\n    >>> from tqdm import tqdm, tqdm_gui\n    >>>\n    >>> df = pd.DataFrame(np.random.randint(0, 100, (100000, 6)))\n    >>> tqdm.pandas(ncols=50)  # can use tqdm_gui, optional kwargs, etc\n    >>> # Now you can use `progress_apply` instead of `apply`\n    >>> df.groupby(0).progress_apply(lambda x: x**2)\n\n    References\n    ----------\n    https://stackoverflow.com/questions/18603270/\n    progress-indicator-during-pandas-operations-python\n    \"\"\"\n    from pandas.core.frame import DataFrame\n    from pandas.core.series import Series\n    from pandas import Panel\n    try:\n        # pandas>=0.18.0\n        from pandas.core.window import _Rolling_and_Expanding\n    except ImportError:  # pragma: no cover\n        _Rolling_and_Expanding = None\n    try:\n        # pandas>=0.23.0\n        from pandas.core.groupby.groupby import DataFrameGroupBy, \\\n            SeriesGroupBy, GroupBy, PanelGroupBy\n    except ImportError:\n        from pandas.core.groupby import DataFrameGroupBy, \\\n            SeriesGroupBy, GroupBy, PanelGroupBy\n\n    deprecated_t = [tkwargs.pop('deprecated_t', None)]\n\n    def inner_generator(df_function='apply'):\n        def inner(df, func, *args, **kwargs):\n            \"\"\"\n            Parameters\n            ----------\n            df  : (DataFrame|Series)[GroupBy]\n                Data (may be grouped).\n            func  : function\n                To be applied on the (grouped) data.\n            **kwargs  : optional\n                Transmitted to `df.apply()`.\n            \"\"\"\n\n            # Precompute total iterations\n            total = tkwargs.pop(\"total\", getattr(df, 'ngroups', None))\n            if total is None:  # not grouped\n                if df_function == 'applymap':\n                    total = df.size\n                elif isinstance(df, Series):\n                    total = len(df)\n                elif _Rolling_and_Expanding is None or \\\n                        not isinstance(df, _Rolling_and_Expanding):\n                    # DataFrame or Panel\n                    axis = kwargs.get('axis', 0)\n                    if axis == 'index':\n                        axis = 0\n                    elif axis == 'columns':\n                        axis = 1\n                    # when axis=0, total is shape[axis1]\n                    total = df.size // df.shape[axis]\n\n            # Init bar\n            if deprecated_t[0] is not None:\n                t = deprecated_t[0]\n                deprecated_t[0] = None\n            else:\n                t = tclass(*targs, total=total, **tkwargs)\n\n            if len(args) > 0:\n                # *args intentionally not supported (see #244, #299)\n                TqdmDeprecationWarning(\n                    \"Except func, normal arguments are intentionally\" +\n                    \" not supported by\" +\n                    \" `(DataFrame|Series|GroupBy).progress_apply`.\" +\n                    \" Use keyword arguments instead.\",\n                    fp_write=getattr(t.fp, 'write', sys.stderr.write))\n\n            # Define bar updating wrapper\n            def wrapper(*args, **kwargs):\n                # update tbar correctly\n                # it seems `pandas apply` calls `func` twice\n                # on the first column/row to decide whether it can\n                # take a fast or slow code path; so stop when t.total==t.n\n                t.update(n=1 if not t.total or t.n < t.total else 0)\n                return func(*args, **kwargs)\n\n            # Apply the provided function (in **kwargs)\n            # on the df using our wrapper (which provides bar updating)\n            result = getattr(df, df_function)(wrapper, **kwargs)\n\n            # Close bar and return pandas calculation result\n            t.close()\n            return result\n\n        return inner\n\n    # Monkeypatch pandas to provide easy methods\n    # Enable custom tqdm progress in pandas!\n    Series.progress_apply = inner_generator()\n    SeriesGroupBy.progress_apply = inner_generator()\n    Series.progress_map = inner_generator('map')\n    SeriesGroupBy.progress_map = inner_generator('map')\n\n    DataFrame.progress_apply = inner_generator()\n    DataFrameGroupBy.progress_apply = inner_generator()\n    DataFrame.progress_applymap = inner_generator('applymap')\n\n    Panel.progress_apply = inner_generator()\n    PanelGroupBy.progress_apply = inner_generator()\n\n    GroupBy.progress_apply = inner_generator()\n    GroupBy.progress_aggregate = inner_generator('aggregate')\n    GroupBy.progress_transform = inner_generator('transform')\n\n    if _Rolling_and_Expanding is not None:  # pragma: no cover\n        _Rolling_and_Expanding.progress_apply = inner_generator()",
                "def __init__(self, iterable=None, desc=None, total=None, leave=True,\n             file=None, ncols=None, mininterval=0.1, maxinterval=10.0,\n             miniters=None, ascii=None, disable=False, unit='it',\n             unit_scale=False, dynamic_ncols=False, smoothing=0.3,\n             bar_format=None, initial=0, position=None, postfix=None,\n             unit_divisor=1000, write_bytes=None, gui=False, **kwargs):\n    \"\"\"\n    Parameters\n    ----------\n    iterable  : iterable, optional\n        Iterable to decorate with a progressbar.\n        Leave blank to manually manage the updates.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If unspecified,\n        len(iterable) is used if possible. If float(\"inf\") or as a last\n        resort, only basic progress statistics are displayed\n        (no ETA, no progressbar).\n        If `gui` is True and this parameter needs subsequent updating,\n        specify an initial arbitrary large positive integer,\n        e.g. int(9e9).\n    leave  : bool, optional\n        If [default: True], keeps all traces of the progressbar\n        upon termination of iteration.\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages\n        (default: sys.stderr). Uses `file.write(str)` and `file.flush()`\n        methods.  For encoding, see `write_bytes`.\n    ncols  : int, optional\n        The width of the entire output message. If specified,\n        dynamically resizes the progressbar to stay within this bound.\n        If unspecified, attempts to use environment width. The\n        fallback is a meter width of 10 and no limit for the counter and\n        statistics. If 0, will not print any meter (only stats).\n    mininterval  : float, optional\n        Minimum progress display update interval [default: 0.1] seconds.\n    maxinterval  : float, optional\n        Maximum progress display update interval [default: 10] seconds.\n        Automatically adjusts `miniters` to correspond to `mininterval`\n        after long display update lag. Only works if `dynamic_miniters`\n        or monitor thread is enabled.\n    miniters  : int, optional\n        Minimum progress display update interval, in iterations.\n        If 0 and `dynamic_miniters`, will automatically adjust to equal\n        `mininterval` (more CPU efficient, good for tight loops).\n        If > 0, will skip display of specified number of iterations.\n        Tweak this and `mininterval` to get very efficient loops.\n        If your progress is erratic with both fast and slow iterations\n        (network, skipping items, etc) you should set miniters=1.\n    ascii  : bool or str, optional\n        If unspecified or False, use unicode (smooth blocks) to fill\n        the meter. The fallback is to use ASCII characters \" 123456789#\".\n    disable  : bool, optional\n        Whether to disable the entire progressbar wrapper\n        [default: False]. If set to None, disable on non-TTY.\n    unit  : str, optional\n        String that will be used to define the unit of each iteration\n        [default: it].\n    unit_scale  : bool or int or float, optional\n        If 1 or True, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.) [default: False]. If any other non-zero\n        number, will scale `total` and `n`.\n    dynamic_ncols  : bool, optional\n        If set, constantly alters `ncols` to the environment (allowing\n        for window resizes) [default: False].\n    smoothing  : float, optional\n        Exponential moving average smoothing factor for speed estimates\n        (ignored in GUI mode). Ranges from 0 (average speed) to 1\n        (current/instantaneous speed) [default: 0.3].\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where\n        l_bar='{desc}: {percentage:3.0f}%|' and\n        r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n          '{rate_fmt}{postfix}]'\n        Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n          percentage, rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n          rate_inv, rate_inv_fmt, elapsed, elapsed_s, remaining,\n          remaining_s, desc, postfix, unit.\n        Note that a trailing \": \" is automatically removed after {desc}\n        if the latter is empty.\n    initial  : int, optional\n        The initial counter value. Useful when restarting a progress\n        bar [default: 0].\n    position  : int, optional\n        Specify the line offset to print this bar (starting from 0)\n        Automatic if unspecified.\n        Useful to manage multiple bars at once (eg, from threads).\n    postfix  : dict or *, optional\n        Specify additional stats to display at the end of the bar.\n        Calls `set_postfix(**postfix)` if possible (dict).\n    unit_divisor  : float, optional\n        [default: 1000], ignored unless `unit_scale` is True.\n    write_bytes  : bool, optional\n        If (default: None) and `file` is unspecified,\n        bytes will be written in Python 2. If `True` will also write\n        bytes. In all other cases will default to unicode.\n    gui  : bool, optional\n        WARNING: internal parameter - do not use.\n        Use tqdm_gui(...) instead. If set, will attempt to use\n        matplotlib animations for a graphical output [default: False].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n    if write_bytes is None:\n        write_bytes = file is None and sys.version_info < (3,)\n\n    if file is None:\n        file = sys.stderr\n\n    if write_bytes:\n        # Despite coercing unicode into bytes, py2 sys.std* streams\n        # should have bytes written to them.\n        file = SimpleTextIOWrapper(\n            file, encoding=getattr(file, 'encoding', None) or 'utf-8')\n\n    if disable is None and hasattr(file, \"isatty\") and not file.isatty():\n        disable = True\n\n    if total is None and iterable is not None:\n        try:\n            total = len(iterable)\n        except (TypeError, AttributeError):\n            total = None\n    if total == float(\"inf\"):\n        # Infinite iterations, behave same as unknown\n        total = None\n\n    if disable:\n        self.iterable = iterable\n        self.disable = disable\n        self.pos = self._get_free_pos(self)\n        self._instances.remove(self)\n        self.n = initial\n        self.total = total\n        return\n\n    if kwargs:\n        self.disable = True\n        self.pos = self._get_free_pos(self)\n        self._instances.remove(self)\n        from textwrap import dedent\n        raise (TqdmDeprecationWarning(dedent(\"\"\"\\\n                   `nested` is deprecated and automated.\n                   Use `position` instead for manual control.\n                   \"\"\"), fp_write=getattr(file, 'write', sys.stderr.write))\n               if \"nested\" in kwargs else\n               TqdmKeyError(\"Unknown argument(s): \" + str(kwargs)))\n\n    # Preprocess the arguments\n    if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n            dynamic_ncols:  # pragma: no cover\n        if dynamic_ncols:\n            dynamic_ncols = _environ_cols_wrapper()\n            if dynamic_ncols:\n                ncols = dynamic_ncols(file)\n            # elif ncols is not None:\n            #     ncols = 79\n        else:\n            _dynamic_ncols = _environ_cols_wrapper()\n            if _dynamic_ncols:\n                ncols = _dynamic_ncols(file)\n            # else:\n            #     ncols = 79\n\n    if miniters is None:\n        miniters = 0\n        dynamic_miniters = True\n    else:\n        dynamic_miniters = False\n\n    if mininterval is None:\n        mininterval = 0\n\n    if maxinterval is None:\n        maxinterval = 0\n\n    if ascii is None:\n        ascii = not _supports_unicode(file)\n\n    if bar_format and not ((ascii is True) or _is_ascii(ascii)):\n        # Convert bar format into unicode since terminal uses unicode\n        bar_format = _unicode(bar_format)\n\n    if smoothing is None:\n        smoothing = 0\n\n    # Store the arguments\n    self.iterable = iterable\n    self.desc = desc or ''\n    self.total = total\n    self.leave = leave\n    self.fp = file\n    self.ncols = ncols\n    self.mininterval = mininterval\n    self.maxinterval = maxinterval\n    self.miniters = miniters\n    self.dynamic_miniters = dynamic_miniters\n    self.ascii = ascii\n    self.disable = disable\n    self.unit = unit\n    self.unit_scale = unit_scale\n    self.unit_divisor = unit_divisor\n    self.gui = gui\n    self.dynamic_ncols = dynamic_ncols\n    self.smoothing = smoothing\n    self.avg_time = None\n    self._time = time\n    self.bar_format = bar_format\n    self.postfix = None\n    if postfix:\n        try:\n            self.set_postfix(refresh=False, **postfix)\n        except TypeError:\n            self.postfix = postfix\n\n    # Init the iterations counters\n    self.last_print_n = initial\n    self.n = initial\n\n    # if nested, at initial sp() call we replace '\\r' by '\\n' to\n    # not overwrite the outer progress bar\n    with self._lock:\n        if position is None:\n            self.pos = self._get_free_pos(self)\n        else:  # mark fixed positions as negative\n            self.pos = -position\n\n    if not gui:\n        # Initialize the screen printer\n        self.sp = self.status_printer(self.fp)\n        with self._lock:\n            self.display()\n\n    # Init the time counter\n    self.last_print_t = self._time()\n    # NB: Avoid race conditions by setting start_t at the very end of init\n    self.start_t = self.last_print_t",
                "def __len__(self):\n    return self.total if self.iterable is None else \\\n        (self.iterable.shape[0] if hasattr(self.iterable, \"shape\")\n         else len(self.iterable) if hasattr(self.iterable, \"__len__\")\n         else getattr(self, \"total\", None))",
                "def __enter__(self):\n    return self",
                "def __exit__(self, *exc):\n    self.close()\n    return False",
                "def __del__(self):\n    self.close()",
                "def __repr__(self):\n    return self.format_meter(**self.format_dict)",
                "@property\ndef _comparable(self):\n    return abs(getattr(self, \"pos\", 1 << 31))",
                "def __hash__(self):\n    return id(self)",
                "def __iter__(self):\n    \"\"\"Backward-compatibility to use: for x in tqdm(iterable)\"\"\"\n\n    # Inlining instance variables as locals (speed optimisation)\n    iterable = self.iterable\n\n    # If the bar is disabled, then just walk the iterable\n    # (note: keep this check outside the loop for performance)\n    if self.disable:\n        for obj in iterable:\n            yield obj\n    else:\n        mininterval = self.mininterval\n        maxinterval = self.maxinterval\n        miniters = self.miniters\n        dynamic_miniters = self.dynamic_miniters\n        last_print_t = self.last_print_t\n        last_print_n = self.last_print_n\n        n = self.n\n        smoothing = self.smoothing\n        avg_time = self.avg_time\n        _time = self._time\n\n        if not hasattr(self, 'sp'):\n            from textwrap import dedent\n            raise TqdmDeprecationWarning(dedent(\"\"\"\\\n            Please use `tqdm_gui(...)` instead of `tqdm(..., gui=True)`\n            \"\"\"), fp_write=getattr(self.fp, 'write', sys.stderr.write))\n\n        for obj in iterable:\n            yield obj\n            # Update and possibly print the progressbar.\n            # Note: does not call self.update(1) for speed optimisation.\n            n += 1\n            # check counter first to avoid calls to time()\n            if n - last_print_n >= self.miniters:\n                miniters = self.miniters  # watch monitoring thread changes\n                delta_t = _time() - last_print_t\n                if delta_t >= mininterval:\n                    cur_t = _time()\n                    delta_it = n - last_print_n\n                    # EMA (not just overall average)\n                    if smoothing and delta_t and delta_it:\n                        rate = delta_t / delta_it\n                        avg_time = self.ema(rate, avg_time, smoothing)\n                        self.avg_time = avg_time\n\n                    self.n = n\n                    with self._lock:\n                        self.display()\n\n                    # If no `miniters` was specified, adjust automatically\n                    # to the max iteration rate seen so far between 2 prints\n                    if dynamic_miniters:\n                        if maxinterval and delta_t >= maxinterval:\n                            # Adjust miniters to time interval by rule of 3\n                            if mininterval:\n                                # Set miniters to correspond to mininterval\n                                miniters = delta_it * mininterval / delta_t\n                            else:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                        elif smoothing:\n                            # EMA-weight miniters to converge\n                            # towards the timeframe of mininterval\n                            rate = delta_it\n                            if mininterval and delta_t:\n                                rate *= mininterval / delta_t\n                            miniters = self.ema(rate, miniters, smoothing)\n                        else:\n                            # Maximum nb of iterations between 2 prints\n                            miniters = max(miniters, delta_it)\n\n                    # Store old values for next call\n                    self.n = self.last_print_n = last_print_n = n\n                    self.last_print_t = last_print_t = cur_t\n                    self.miniters = miniters\n\n        # Closing the progress bar.\n        # Update some internal variables for close().\n        self.last_print_n = last_print_n\n        self.n = n\n        self.miniters = miniters\n        self.close()",
                "def update(self, n=1):\n    \"\"\"\n    Manually update the progress bar, useful for streams\n    such as reading files.\n    E.g.:\n    >>> t = tqdm(total=filesize) # Initialise\n    >>> for current_buffer in stream:\n    ...    ...\n    ...    t.update(len(current_buffer))\n    >>> t.close()\n    The last line is highly recommended, but possibly not necessary if\n    `t.update()` will be called in such a way that `filesize` will be\n    exactly reached and printed.\n\n    Parameters\n    ----------\n    n  : int, optional\n        Increment to add to the internal counter of iterations\n        [default: 1].\n    \"\"\"\n    # N.B.: see __iter__() for more comments.\n    if self.disable:\n        return\n\n    if n < 0:\n        self.last_print_n += n  # for auto-refresh logic to work\n    self.n += n\n\n    # check counter first to reduce calls to time()\n    if self.n - self.last_print_n >= self.miniters:\n        delta_t = self._time() - self.last_print_t\n        if delta_t >= self.mininterval:\n            cur_t = self._time()\n            delta_it = self.n - self.last_print_n  # >= n\n            # elapsed = cur_t - self.start_t\n            # EMA (not just overall average)\n            if self.smoothing and delta_t and delta_it:\n                rate = delta_t / delta_it\n                self.avg_time = self.ema(\n                    rate, self.avg_time, self.smoothing)\n\n            if not hasattr(self, \"sp\"):\n                from textwrap import dedent\n                raise TqdmDeprecationWarning(dedent(\"\"\"\\\n                Please use `tqdm_gui(...)` instead of `tqdm(..., gui=True)`\n                \"\"\"), fp_write=getattr(self.fp, 'write', sys.stderr.write))\n\n            with self._lock:\n                self.display()\n\n            # If no `miniters` was specified, adjust automatically to the\n            # maximum iteration rate seen so far between two prints.\n            # e.g.: After running `tqdm.update(5)`, subsequent\n            # calls to `tqdm.update()` will only cause an update after\n            # at least 5 more iterations.\n            if self.dynamic_miniters:\n                if self.maxinterval and delta_t >= self.maxinterval:\n                    if self.mininterval:\n                        self.miniters = delta_it * self.mininterval \\\n                            / delta_t\n                    else:\n                        self.miniters = delta_it * self.maxinterval \\\n                            / delta_t\n                elif self.smoothing:\n                    self.miniters = self.smoothing * delta_it * \\\n                        (self.mininterval / delta_t\n                         if self.mininterval and delta_t\n                         else 1) + \\\n                        (1 - self.smoothing) * self.miniters\n                else:\n                    self.miniters = max(self.miniters, delta_it)\n\n            # Store old values for next call\n            self.last_print_n = self.n\n            self.last_print_t = cur_t",
                "def close(self):\n    \"\"\"Cleanup and (if leave=False) close the progressbar.\"\"\"\n    if self.disable:\n        return\n\n    # Prevent multiple closures\n    self.disable = True\n\n    # decrement instance pos and remove from internal set\n    pos = abs(self.pos)\n    self._decr_instances(self)\n\n    # GUI mode\n    if not hasattr(self, \"sp\"):\n        return\n\n    # annoyingly, _supports_unicode isn't good enough\n    def fp_write(s):\n        self.fp.write(_unicode(s))\n\n    try:\n        fp_write('')\n    except ValueError as e:\n        if 'closed' in str(e):\n            return\n        raise  # pragma: no cover\n\n    with self._lock:\n        if self.leave:\n            if self.last_print_n < self.n:\n                # stats for overall rate (no weighted average)\n                self.avg_time = None\n                self.display(pos=pos)\n            if not max([abs(getattr(i, \"pos\", 0))\n                        for i in self._instances] + [pos]):\n                # only if not nested (#477)\n                fp_write('\\n')\n        else:\n            self.display(msg='', pos=pos)\n            if not pos:\n                fp_write('\\r')",
                "def clear(self, nolock=False):\n    \"\"\"Clear current bar display.\"\"\"\n    if self.disable:\n        return\n\n    if not nolock:\n        self._lock.acquire()\n    self.moveto(abs(self.pos))\n    self.sp('')\n    self.fp.write('\\r')  # place cursor back at the beginning of line\n    self.moveto(-abs(self.pos))\n    if not nolock:\n        self._lock.release()",
                "def refresh(self, nolock=False):\n    \"\"\"Force refresh the display of this bar.\"\"\"\n    if self.disable:\n        return\n\n    if not nolock:\n        self._lock.acquire()\n    self.display()\n    if not nolock:\n        self._lock.release()",
                "def unpause(self):\n    \"\"\"Restart tqdm timer from last print time.\"\"\"\n    cur_t = self._time()\n    self.start_t += cur_t - self.last_print_t\n    self.last_print_t = cur_t",
                "def reset(self, total=None):\n    \"\"\"\n    Resets to 0 iterations for repeated use.\n\n    Consider combining with `leave=True`.\n\n    Parameters\n    ----------\n    total  : int, optional. Total to use for the new bar.\n    \"\"\"\n    self.last_print_n = self.n = 0\n    self.last_print_t = self.start_t = self._time()\n    if total is not None:\n        self.total = total\n    self.refresh()",
                "def set_description(self, desc=None, refresh=True):\n    \"\"\"\n    Set/modify description of the progress bar.\n\n    Parameters\n    ----------\n    desc  : str, optional\n    refresh  : bool, optional\n        Forces refresh [default: True].\n    \"\"\"\n    self.desc = desc + ': ' if desc else ''\n    if refresh:\n        self.refresh()",
                "def set_description_str(self, desc=None, refresh=True):\n    \"\"\"Set/modify description without ': ' appended.\"\"\"\n    self.desc = desc or ''\n    if refresh:\n        self.refresh()",
                "def set_postfix(self, ordered_dict=None, refresh=True, **kwargs):\n    \"\"\"\n    Set/modify postfix (additional stats)\n    with automatic formatting based on datatype.\n\n    Parameters\n    ----------\n    ordered_dict  : dict or OrderedDict, optional\n    refresh  : bool, optional\n        Forces refresh [default: True].\n    kwargs  : dict, optional\n    \"\"\"\n    # Sort in alphabetical order to be more deterministic\n    postfix = _OrderedDict([] if ordered_dict is None else ordered_dict)\n    for key in sorted(kwargs.keys()):\n        postfix[key] = kwargs[key]\n    # Preprocess stats according to datatype\n    for key in postfix.keys():\n        # Number: limit the length of the string\n        if isinstance(postfix[key], Number):\n            postfix[key] = self.format_num(postfix[key])\n        # Else for any other type, try to get the string conversion\n        elif not isinstance(postfix[key], _basestring):\n            postfix[key] = str(postfix[key])\n        # Else if it's a string, don't need to preprocess anything\n    # Stitch together to get the final postfix\n    self.postfix = ', '.join(key + '=' + postfix[key].strip()\n                             for key in postfix.keys())\n    if refresh:\n        self.refresh()",
                "def set_postfix_str(self, s='', refresh=True):\n    \"\"\"\n    Postfix without dictionary expansion, similar to prefix handling.\n    \"\"\"\n    self.postfix = str(s)\n    if refresh:\n        self.refresh()",
                "def moveto(self, n):\n    # TODO: private method\n    self.fp.write(_unicode('\\n' * n + _term_move_up() * -n))\n    self.fp.flush()",
                "@property\ndef format_dict(self):\n    \"\"\"Public API for read-only member access.\"\"\"\n    return dict(\n        n=self.n, total=self.total,\n        elapsed=self._time() - self.start_t\n        if hasattr(self, 'start_t') else 0,\n        ncols=self.dynamic_ncols(self.fp)\n        if self.dynamic_ncols else self.ncols,\n        prefix=self.desc, ascii=self.ascii, unit=self.unit,\n        unit_scale=self.unit_scale,\n        rate=1 / self.avg_time if self.avg_time else None,\n        bar_format=self.bar_format, postfix=self.postfix,\n        unit_divisor=self.unit_divisor)",
                "def display(self, msg=None, pos=None):\n    \"\"\"\n    Use `self.sp` to display `msg` in the specified `pos`.\n\n    Consider overloading this function when inheriting to use e.g.:\n    `self.some_frontend(**self.format_dict)` instead of `self.sp`.\n\n    Parameters\n    ----------\n    msg  : str, optional. What to display (default: `repr(self)`).\n    pos  : int, optional. Position to `moveto`\n      (default: `abs(self.pos)`).\n    \"\"\"\n    if pos is None:\n        pos = abs(self.pos)\n\n    if pos:\n        self.moveto(pos)\n    self.sp(self.__repr__() if msg is None else msg)\n    if pos:\n        self.moveto(-pos)",
                "def fp_write(s):\n    fp.write(_unicode(s))\n    fp_flush()",
                "def print_status(s):\n    len_s = len(s)\n    fp_write('\\r' + s + (' ' * max(last_len[0] - len_s, 0)))\n    last_len[0] = len_s",
                "def inner_generator(df_function='apply'):\n    def inner(df, func, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        df  : (DataFrame|Series)[GroupBy]\n            Data (may be grouped).\n        func  : function\n            To be applied on the (grouped) data.\n        **kwargs  : optional\n            Transmitted to `df.apply()`.\n        \"\"\"\n\n        # Precompute total iterations\n        total = tkwargs.pop(\"total\", getattr(df, 'ngroups', None))\n        if total is None:  # not grouped\n            if df_function == 'applymap':\n                total = df.size\n            elif isinstance(df, Series):\n                total = len(df)\n            elif _Rolling_and_Expanding is None or \\\n                    not isinstance(df, _Rolling_and_Expanding):\n                # DataFrame or Panel\n                axis = kwargs.get('axis', 0)\n                if axis == 'index':\n                    axis = 0\n                elif axis == 'columns':\n                    axis = 1\n                # when axis=0, total is shape[axis1]\n                total = df.size // df.shape[axis]\n\n        # Init bar\n        if deprecated_t[0] is not None:\n            t = deprecated_t[0]\n            deprecated_t[0] = None\n        else:\n            t = tclass(*targs, total=total, **tkwargs)\n\n        if len(args) > 0:\n            # *args intentionally not supported (see #244, #299)\n            TqdmDeprecationWarning(\n                \"Except func, normal arguments are intentionally\" +\n                \" not supported by\" +\n                \" `(DataFrame|Series|GroupBy).progress_apply`.\" +\n                \" Use keyword arguments instead.\",\n                fp_write=getattr(t.fp, 'write', sys.stderr.write))\n\n        # Define bar updating wrapper\n        def wrapper(*args, **kwargs):\n            # update tbar correctly\n            # it seems `pandas apply` calls `func` twice\n            # on the first column/row to decide whether it can\n            # take a fast or slow code path; so stop when t.total==t.n\n            t.update(n=1 if not t.total or t.n < t.total else 0)\n            return func(*args, **kwargs)\n\n        # Apply the provided function (in **kwargs)\n        # on the df using our wrapper (which provides bar updating)\n        result = getattr(df, df_function)(wrapper, **kwargs)\n\n        # Close bar and return pandas calculation result\n        t.close()\n        return result\n\n    return inner",
                "def fp_write(s):\n    self.fp.write(_unicode(s))",
                "def inner(df, func, *args, **kwargs):\n    \"\"\"\n    Parameters\n    ----------\n    df  : (DataFrame|Series)[GroupBy]\n        Data (may be grouped).\n    func  : function\n        To be applied on the (grouped) data.\n    **kwargs  : optional\n        Transmitted to `df.apply()`.\n    \"\"\"\n\n    # Precompute total iterations\n    total = tkwargs.pop(\"total\", getattr(df, 'ngroups', None))\n    if total is None:  # not grouped\n        if df_function == 'applymap':\n            total = df.size\n        elif isinstance(df, Series):\n            total = len(df)\n        elif _Rolling_and_Expanding is None or \\\n                not isinstance(df, _Rolling_and_Expanding):\n            # DataFrame or Panel\n            axis = kwargs.get('axis', 0)\n            if axis == 'index':\n                axis = 0\n            elif axis == 'columns':\n                axis = 1\n            # when axis=0, total is shape[axis1]\n            total = df.size // df.shape[axis]\n\n    # Init bar\n    if deprecated_t[0] is not None:\n        t = deprecated_t[0]\n        deprecated_t[0] = None\n    else:\n        t = tclass(*targs, total=total, **tkwargs)\n\n    if len(args) > 0:\n        # *args intentionally not supported (see #244, #299)\n        TqdmDeprecationWarning(\n            \"Except func, normal arguments are intentionally\" +\n            \" not supported by\" +\n            \" `(DataFrame|Series|GroupBy).progress_apply`.\" +\n            \" Use keyword arguments instead.\",\n            fp_write=getattr(t.fp, 'write', sys.stderr.write))\n\n    # Define bar updating wrapper\n    def wrapper(*args, **kwargs):\n        # update tbar correctly\n        # it seems `pandas apply` calls `func` twice\n        # on the first column/row to decide whether it can\n        # take a fast or slow code path; so stop when t.total==t.n\n        t.update(n=1 if not t.total or t.n < t.total else 0)\n        return func(*args, **kwargs)\n\n    # Apply the provided function (in **kwargs)\n    # on the df using our wrapper (which provides bar updating)\n    result = getattr(df, df_function)(wrapper, **kwargs)\n\n    # Close bar and return pandas calculation result\n    t.close()\n    return result",
                "def wrapper(*args, **kwargs):\n    # update tbar correctly\n    # it seems `pandas apply` calls `func` twice\n    # on the first column/row to decide whether it can\n    # take a fast or slow code path; so stop when t.total==t.n\n    t.update(n=1 if not t.total or t.n < t.total else 0)\n    return func(*args, **kwargs)"
            ],
            "inscope_function_signatures": [
                "trange(*args, **kwargs)",
                "__init__(self, msg, fp_write=None, *a, **k)",
                "__init__(self)",
                "acquire(self)",
                "release(self)",
                "__enter__(self)",
                "__exit__(self, *exc)",
                "create_mp_lock(cls)",
                "create_th_lock(cls)",
                "format_sizeof(num, suffix='', divisor=1000)",
                "format_interval(t)",
                "format_num(n)",
                "ema(x, mu=None, alpha=0.3)",
                "status_printer(file)",
                "format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None, postfix=None, unit_divisor=1000, **extra_kwargs)",
                "__new__(cls, *args, **kwargs)",
                "_get_free_pos(cls, instance=None)",
                "_decr_instances(cls, instance)",
                "write(cls, s, file=None, end='\\n', nolock=False)",
                "external_write_mode(cls, file=None, nolock=False)",
                "set_lock(cls, lock)",
                "get_lock(cls)",
                "pandas(tclass, *targs, **tkwargs)",
                "__init__(self, iterable=None, desc=None, total=None, leave=True, file=None, ncols=None, mininterval=0.1, maxinterval=10.0, miniters=None, ascii=None, disable=False, unit='it', unit_scale=False, dynamic_ncols=False, smoothing=0.3, bar_format=None, initial=0, position=None, postfix=None, unit_divisor=1000, write_bytes=None, gui=False, **kwargs)",
                "__len__(self)",
                "__enter__(self)",
                "__exit__(self, *exc)",
                "__del__(self)",
                "__repr__(self)",
                "_comparable(self)",
                "__hash__(self)",
                "__iter__(self)",
                "update(self, n=1)",
                "close(self)",
                "clear(self, nolock=False)",
                "refresh(self, nolock=False)",
                "unpause(self)",
                "reset(self, total=None)",
                "set_description(self, desc=None, refresh=True)",
                "set_description_str(self, desc=None, refresh=True)",
                "set_postfix(self, ordered_dict=None, refresh=True, **kwargs)",
                "set_postfix_str(self, s='', refresh=True)",
                "moveto(self, n)",
                "format_dict(self)",
                "display(self, msg=None, pos=None)",
                "fp_write(s)",
                "print_status(s)",
                "inner_generator(df_function='apply')",
                "fp_write(s)",
                "inner(df, func, *args, **kwargs)",
                "wrapper(*args, **kwargs)"
            ],
            "variables_in_file": {
                "__author__": [
                    28
                ],
                "__all__": [
                    30
                ],
                "TypeError": [
                    833,
                    36,
                    924,
                    359
                ],
                "KeyError": [
                    40,
                    497
                ],
                "Warning": [
                    44
                ],
                "fp_write": [
                    1158,
                    50,
                    51,
                    1173,
                    1177,
                    250
                ],
                "self.__class__.__name__": [
                    51
                ],
                "self.__class__": [
                    51
                ],
                "self": [
                    1024,
                    1025,
                    1044,
                    1050,
                    1051,
                    1052,
                    1056,
                    1057,
                    1058,
                    1059,
                    51,
                    54,
                    1082,
                    1086,
                    1087,
                    1090,
                    1091,
                    1092,
                    1093,
                    1094,
                    1097,
                    1099,
                    1100,
                    1102,
                    1106,
                    84,
                    85,
                    86,
                    87,
                    1108,
                    1109,
                    90,
                    1116,
                    1117,
                    94,
                    1118,
                    1119,
                    98,
                    1122,
                    1124,
                    101,
                    1125,
                    1127,
                    1126,
                    1129,
                    1131,
                    1134,
                    1135,
                    1139,
                    1143,
                    1146,
                    1147,
                    1150,
                    1155,
                    1164,
                    1165,
                    1166,
                    1168,
                    1169,
                    1171,
                    1175,
                    1181,
                    1185,
                    1186,
                    1187,
                    1188,
                    1189,
                    1191,
                    1195,
                    1199,
                    1200,
                    1202,
                    1206,
                    1207,
                    1208,
                    1220,
                    1221,
                    1223,
                    1224,
                    1236,
                    1238,
                    1242,
                    1244,
                    1266,
                    1272,
                    1275,
                    1281,
                    1283,
                    1287,
                    1288,
                    1294,
                    1295,
                    1296,
                    1297,
                    1298,
                    1299,
                    1300,
                    1301,
                    1302,
                    1303,
                    1319,
                    1322,
                    1323,
                    1325,
                    840,
                    841,
                    842,
                    843,
                    844,
                    845,
                    849,
                    850,
                    851,
                    899,
                    900,
                    901,
                    902,
                    903,
                    904,
                    905,
                    906,
                    907,
                    908,
                    909,
                    910,
                    911,
                    912,
                    913,
                    914,
                    915,
                    916,
                    917,
                    918,
                    919,
                    920,
                    923,
                    925,
                    928,
                    929,
                    933,
                    935,
                    937,
                    941,
                    942,
                    943,
                    946,
                    948,
                    951,
                    952,
                    953,
                    954,
                    957,
                    960,
                    964,
                    967,
                    971,
                    974,
                    980,
                    984,
                    988,
                    989,
                    990,
                    991,
                    992,
                    993,
                    994,
                    995,
                    996,
                    997,
                    999,
                    1003,
                    1011,
                    1012,
                    1020,
                    1021,
                    1023
                ],
                "rstrip": [
                    52
                ],
                "str": [
                    1281,
                    354,
                    355,
                    1160,
                    210,
                    52,
                    1269,
                    858,
                    475
                ],
                "msg": [
                    1323,
                    52,
                    54
                ],
                "__init__": [
                    54
                ],
                "super": [
                    54
                ],
                "TqdmWarning": [
                    62,
                    57,
                    67,
                    54
                ],
                "a": [
                    54
                ],
                "k": [
                    54
                ],
                "FutureWarning": [
                    57
                ],
                "DeprecationWarning": [
                    62
                ],
                "RuntimeWarning": [
                    67
                ],
                "object": [
                    72,
                    461
                ],
                "self.create_mp_lock": [
                    84
                ],
                "self.create_th_lock": [
                    85
                ],
                "cls": [
                    512,
                    516,
                    522,
                    537,
                    540,
                    553,
                    558,
                    563,
                    564,
                    565,
                    461,
                    463,
                    464,
                    466,
                    467,
                    469,
                    86,
                    87,
                    472,
                    470,
                    477,
                    503,
                    484,
                    105,
                    107,
                    109,
                    494,
                    111,
                    496,
                    115,
                    117,
                    119,
                    509,
                    511
                ],
                "type": [
                    86
                ],
                "self.locks": [
                    90,
                    94,
                    87
                ],
                "lk": [
                    87
                ],
                "cls.mp_lock": [
                    107,
                    111,
                    109,
                    87
                ],
                "cls.th_lock": [
                    119,
                    117,
                    87
                ],
                "lock": [
                    558,
                    90,
                    91,
                    94,
                    95
                ],
                "lock.acquire": [
                    91
                ],
                "lock.release": [
                    95
                ],
                "self.acquire": [
                    98
                ],
                "self.release": [
                    101
                ],
                "hasattr": [
                    544,
                    485,
                    999,
                    953,
                    105,
                    1102,
                    463,
                    1296,
                    115,
                    563,
                    952,
                    505,
                    827,
                    1150
                ],
                "mp.RLock": [
                    107
                ],
                "mp": [
                    107
                ],
                "ImportError": [
                    108,
                    613,
                    607
                ],
                "OSError": [
                    118,
                    110
                ],
                "classmethod": [
                    481,
                    518,
                    103,
                    488,
                    555,
                    527,
                    560,
                    113,
                    567
                ],
                "th.RLock": [
                    117
                ],
                "th": [
                    117
                ],
                "TqdmDefaultWriteLock.create_th_lock": [
                    126
                ],
                "TqdmDefaultWriteLock": [
                    564,
                    126
                ],
                "ASCII_FMT": [
                    128,
                    429
                ],
                "UTF_FMT": [
                    129,
                    431
                ],
                "join": [
                    1272,
                    129
                ],
                "map": [
                    129
                ],
                "_unich": [
                    129
                ],
                "range": [
                    129,
                    486
                ],
                "Comparable": [
                    132
                ],
                "monitor_interval": [
                    139
                ],
                "monitor": [
                    140
                ],
                "unit": [
                    162,
                    387,
                    166,
                    167,
                    168,
                    457,
                    911,
                    343,
                    346
                ],
                "abs": [
                    1186,
                    163,
                    484,
                    164,
                    165,
                    1189,
                    1319,
                    971,
                    1170,
                    505,
                    1146
                ],
                "num": [
                    163,
                    164,
                    165,
                    166,
                    167,
                    168,
                    169,
                    170
                ],
                "format": [
                    192,
                    166,
                    167,
                    168,
                    456,
                    170,
                    397,
                    209,
                    373,
                    342,
                    345,
                    190
                ],
                "suffix": [
                    168,
                    170,
                    166,
                    167
                ],
                "divisor": [
                    169
                ],
                "staticmethod": [
                    194,
                    232,
                    172,
                    142,
                    213,
                    255
                ],
                "mins": [
                    187,
                    188
                ],
                "s": [
                    192,
                    1281,
                    1155,
                    524,
                    243,
                    249,
                    250,
                    187,
                    190
                ],
                "divmod": [
                    433,
                    187,
                    188
                ],
                "int": [
                    434,
                    187
                ],
                "t": [
                    672,
                    680,
                    652,
                    655,
                    664,
                    187
                ],
                "h": [
                    188,
                    189,
                    190
                ],
                "m": [
                    192,
                    188,
                    190
                ],
                "f": [
                    209,
                    211,
                    545
                ],
                "replace": [
                    209
                ],
                "n": [
                    1287,
                    394,
                    1050,
                    1057,
                    1085,
                    1086,
                    1087,
                    321,
                    328,
                    209,
                    210,
                    211,
                    338,
                    350,
                    354,
                    994,
                    362,
                    1009,
                    1011,
                    1016,
                    379,
                    1023
                ],
                "len": [
                    832,
                    486,
                    423,
                    432,
                    657,
                    211,
                    249,
                    953,
                    638
                ],
                "mu": [
                    230
                ],
                "x": [
                    230
                ],
                "alpha": [
                    230
                ],
                "fp": [
                    544,
                    545,
                    521,
                    524,
                    525,
                    239,
                    240,
                    243,
                    534
                ],
                "file": [
                    866,
                    903,
                    872,
                    521,
                    522,
                    239,
                    816,
                    818,
                    819,
                    856,
                    534,
                    824,
                    825,
                    827,
                    861,
                    889
                ],
                "fp_flush": [
                    240,
                    244
                ],
                "getattr": [
                    677,
                    971,
                    1003,
                    240,
                    1106,
                    856,
                    1170,
                    825,
                    664,
                    633,
                    954,
                    540
                ],
                "fp.write": [
                    243,
                    524,
                    525
                ],
                "_unicode": [
                    243,
                    1155,
                    893,
                    1287
                ],
                "last_len": [
                    250,
                    251,
                    246
                ],
                "len_s": [
                    249,
                    250,
                    251
                ],
                "max": [
                    423,
                    1131,
                    1170,
                    1047,
                    250
                ],
                "print_status": [
                    253
                ],
                "total": [
                    901,
                    392,
                    648,
                    394,
                    655,
                    830,
                    832,
                    321,
                    322,
                    834,
                    835,
                    837,
                    326,
                    327,
                    1222,
                    1223,
                    845,
                    351,
                    352,
                    355,
                    362,
                    633,
                    634,
                    379,
                    636,
                    638
                ],
                "unit_scale": [
                    325,
                    327,
                    328,
                    330,
                    331,
                    912,
                    341,
                    344,
                    349
                ],
                "rate": [
                    1041,
                    1043,
                    1044,
                    329,
                    330,
                    1098,
                    1100,
                    337,
                    338,
                    339,
                    341,
                    342,
                    343,
                    362,
                    363,
                    380,
                    1019,
                    1020,
                    381
                ],
                "elapsed_str": [
                    384,
                    457,
                    333,
                    374
                ],
                "tqdm.format_interval": [
                    363,
                    333
                ],
                "tqdm": [
                    1333,
                    363,
                    340,
                    333
                ],
                "elapsed": [
                    384,
                    337,
                    338,
                    333
                ],
                "inv_rate": [
                    339,
                    344,
                    345,
                    346,
                    347,
                    380,
                    382
                ],
                "format_sizeof": [
                    340,
                    341,
                    344,
                    350,
                    351
                ],
                "tqdm.format_sizeof": [
                    340
                ],
                "rate_noinv_fmt": [
                    347,
                    341,
                    382
                ],
                "rate_inv_fmt": [
                    344,
                    347,
                    383
                ],
                "rate_fmt": [
                    457,
                    347,
                    381,
                    374
                ],
                "n_fmt": [
                    354,
                    457,
                    374,
                    379,
                    350
                ],
                "unit_divisor": [
                    913,
                    350,
                    351
                ],
                "total_fmt": [
                    379,
                    355,
                    374,
                    351
                ],
                "postfix": [
                    387,
                    1273,
                    358,
                    457,
                    1259,
                    1261,
                    1263,
                    1265,
                    1266,
                    1268,
                    1269,
                    374,
                    1272,
                    921,
                    923,
                    925
                ],
                "remaining": [
                    385,
                    362,
                    363
                ],
                "remaining_str": [
                    385,
                    363,
                    374
                ],
                "prefix": [
                    387,
                    455,
                    366,
                    368,
                    369,
                    407
                ],
                "bool_prefix_colon_already": [
                    368,
                    369
                ],
                "l_bar": [
                    448,
                    386,
                    423,
                    397,
                    400,
                    369,
                    371,
                    403,
                    415
                ],
                "r_bar": [
                    416,
                    448,
                    386,
                    423,
                    400,
                    373
                ],
                "format_dict": [
                    416,
                    419,
                    452,
                    403,
                    378,
                    415
                ],
                "dict": [
                    378,
                    1293
                ],
                "extra_kwargs": [
                    389
                ],
                "frac": [
                    434,
                    394,
                    395
                ],
                "percentage": [
                    395,
                    403,
                    397
                ],
                "ncols": [
                    866,
                    422,
                    423,
                    872,
                    904,
                    399,
                    861
                ],
                "bar_format": [
                    450,
                    419,
                    452,
                    891,
                    402,
                    919,
                    408,
                    411,
                    893,
                    414
                ],
                "format_dict.update": [
                    403
                ],
                "bar_format.replace": [
                    408
                ],
                "l_bar_user": [
                    414,
                    415
                ],
                "r_bar_user": [
                    416,
                    414
                ],
                "bar_format.split": [
                    414
                ],
                "l_bar_user.format": [
                    415
                ],
                "r_bar_user.format": [
                    416
                ],
                "bar_format.format": [
                    419,
                    452
                ],
                "N_BARS": [
                    423,
                    425,
                    434,
                    440,
                    442,
                    445
                ],
                "RE_ANSI.sub": [
                    423
                ],
                "RE_ANSI": [
                    423
                ],
                "ascii": [
                    428,
                    429,
                    430,
                    431,
                    432,
                    909,
                    436,
                    437,
                    888,
                    889,
                    442,
                    891,
                    445
                ],
                "nsyms": [
                    432,
                    434
                ],
                "bar_length": [
                    433,
                    436,
                    440,
                    442,
                    445
                ],
                "frac_bar_length": [
                    433,
                    437
                ],
                "bar": [
                    441,
                    444,
                    436
                ],
                "frac_bar": [
                    441,
                    437
                ],
                "full_bar": [
                    448,
                    441,
                    444
                ],
                "instance": [
                    485,
                    461,
                    496,
                    467,
                    502,
                    505,
                    479
                ],
                "object.__new__": [
                    461
                ],
                "cls._instances": [
                    484,
                    464,
                    496,
                    467,
                    503,
                    509
                ],
                "WeakSet": [
                    464
                ],
                "cls.get_lock": [
                    537,
                    466
                ],
                "cls._instances.add": [
                    467
                ],
                "cls.monitor_interval": [
                    472,
                    477,
                    469
                ],
                "cls.monitor": [
                    512,
                    516,
                    469,
                    470,
                    472,
                    509,
                    511
                ],
                "cls.monitor.report": [
                    470
                ],
                "TMonitor": [
                    472
                ],
                "Exception": [
                    473
                ],
                "warn": [
                    474
                ],
                "e": [
                    1160,
                    475
                ],
                "TqdmMonitorWarning": [
                    476
                ],
                "positions": [
                    484,
                    486
                ],
                "set": [
                    484,
                    486
                ],
                "inst.pos": [
                    505,
                    506,
                    484
                ],
                "inst": [
                    544,
                    545,
                    546,
                    547,
                    484,
                    485,
                    550,
                    551,
                    503,
                    505,
                    506,
                    540
                ],
                "min": [
                    486
                ],
                "difference": [
                    486
                ],
                "cls._lock": [
                    553,
                    558,
                    494,
                    564,
                    565
                ],
                "cls._instances.remove": [
                    496
                ],
                "instance.gui": [
                    502
                ],
                "instance.pos": [
                    505
                ],
                "cls.monitor.exit": [
                    511
                ],
                "AttributeError": [
                    833,
                    513
                ],
                "sys.stdout": [
                    521,
                    861,
                    534,
                    545
                ],
                "sys": [
                    545,
                    521,
                    1003,
                    816,
                    1106,
                    819,
                    856,
                    534,
                    664,
                    861
                ],
                "cls.external_write_mode": [
                    522
                ],
                "nolock": [
                    1184,
                    1190,
                    552,
                    522,
                    1198,
                    1201,
                    536
                ],
                "end": [
                    525
                ],
                "acquire": [
                    537
                ],
                "inst_cleared": [
                    547,
                    539,
                    550
                ],
                "inst.fp": [
                    544,
                    545
                ],
                "all": [
                    544
                ],
                "sys.stderr": [
                    545,
                    1003,
                    1106,
                    819,
                    856,
                    664,
                    861
                ],
                "inst.clear": [
                    546
                ],
                "inst_cleared.append": [
                    547
                ],
                "inst.refresh": [
                    551
                ],
                "cls._lock.release": [
                    553
                ],
                "contextmanager": [
                    528
                ],
                "_Rolling_and_Expanding": [
                    608,
                    704,
                    640,
                    639,
                    703
                ],
                "deprecated_t": [
                    617,
                    651,
                    652,
                    653
                ],
                "tkwargs.pop": [
                    617,
                    633
                ],
                "tkwargs": [
                    617,
                    633,
                    655
                ],
                "df": [
                    640,
                    677,
                    648,
                    633,
                    636,
                    637,
                    638
                ],
                "df_function": [
                    635,
                    677
                ],
                "df.size": [
                    648,
                    636
                ],
                "isinstance": [
                    640,
                    1265,
                    1268,
                    637
                ],
                "Series": [
                    689,
                    637,
                    687
                ],
                "axis": [
                    642,
                    643,
                    644,
                    645,
                    646,
                    648
                ],
                "kwargs.get": [
                    642
                ],
                "kwargs": [
                    673,
                    642,
                    677,
                    1260,
                    1261,
                    848,
                    1333,
                    857,
                    858
                ],
                "df.shape": [
                    648
                ],
                "tclass": [
                    655
                ],
                "targs": [
                    655
                ],
                "args": [
                    657,
                    673,
                    1333
                ],
                "TqdmDeprecationWarning": [
                    1104,
                    1001,
                    659,
                    853
                ],
                "t.fp": [
                    664
                ],
                "sys.stderr.write": [
                    664,
                    1106,
                    856,
                    1003
                ],
                "t.update": [
                    672
                ],
                "t.total": [
                    672
                ],
                "t.n": [
                    672
                ],
                "func": [
                    673
                ],
                "result": [
                    681,
                    677
                ],
                "wrapper": [
                    677
                ],
                "t.close": [
                    680
                ],
                "inner": [
                    683
                ],
                "Series.progress_apply": [
                    687
                ],
                "inner_generator": [
                    704,
                    687,
                    688,
                    689,
                    690,
                    692,
                    693,
                    694,
                    696,
                    697,
                    699,
                    700,
                    701
                ],
                "SeriesGroupBy.progress_apply": [
                    688
                ],
                "SeriesGroupBy": [
                    688,
                    690
                ],
                "Series.progress_map": [
                    689
                ],
                "SeriesGroupBy.progress_map": [
                    690
                ],
                "DataFrame.progress_apply": [
                    692
                ],
                "DataFrame": [
                    692,
                    694
                ],
                "DataFrameGroupBy.progress_apply": [
                    693
                ],
                "DataFrameGroupBy": [
                    693
                ],
                "DataFrame.progress_applymap": [
                    694
                ],
                "Panel.progress_apply": [
                    696
                ],
                "Panel": [
                    696
                ],
                "PanelGroupBy.progress_apply": [
                    697
                ],
                "PanelGroupBy": [
                    697
                ],
                "GroupBy.progress_apply": [
                    699
                ],
                "GroupBy": [
                    699,
                    700,
                    701
                ],
                "GroupBy.progress_aggregate": [
                    700
                ],
                "GroupBy.progress_transform": [
                    701
                ],
                "_Rolling_and_Expanding.progress_apply": [
                    704
                ],
                "write_bytes": [
                    816,
                    821,
                    815
                ],
                "sys.version_info": [
                    816
                ],
                "SimpleTextIOWrapper": [
                    824
                ],
                "disable": [
                    839,
                    841,
                    910,
                    827,
                    828
                ],
                "file.isatty": [
                    827
                ],
                "iterable": [
                    832,
                    899,
                    840,
                    1005,
                    980,
                    985,
                    830
                ],
                "float": [
                    835
                ],
                "self.iterable": [
                    899,
                    840,
                    980,
                    951,
                    952,
                    953
                ],
                "self.disable": [
                    841,
                    1195,
                    910,
                    849,
                    1139,
                    1143,
                    984,
                    1082,
                    1181
                ],
                "self.pos": [
                    1186,
                    1189,
                    935,
                    1319,
                    937,
                    842,
                    850,
                    1146
                ],
                "self._get_free_pos": [
                    842,
                    850,
                    935
                ],
                "self._instances.remove": [
                    851,
                    843
                ],
                "self._instances": [
                    851,
                    843,
                    1171
                ],
                "self.n": [
                    929,
                    994,
                    1057,
                    1090,
                    1220,
                    1094,
                    844,
                    1134,
                    1166,
                    1294,
                    1050,
                    1087,
                    1023
                ],
                "initial": [
                    928,
                    929,
                    844
                ],
                "self.total": [
                    901,
                    1223,
                    845,
                    1294,
                    951
                ],
                "dedent": [
                    1104,
                    1001,
                    853
                ],
                "TqdmKeyError": [
                    858
                ],
                "dynamic_ncols": [
                    864,
                    865,
                    866,
                    915,
                    862,
                    863
                ],
                "_environ_cols_wrapper": [
                    864,
                    870
                ],
                "_dynamic_ncols": [
                    872,
                    870,
                    871
                ],
                "miniters": [
                    1058,
                    1034,
                    907,
                    876,
                    877,
                    1037,
                    1012,
                    1044,
                    1047,
                    1052,
                    990
                ],
                "dynamic_miniters": [
                    1029,
                    908,
                    878,
                    880,
                    991
                ],
                "mininterval": [
                    1032,
                    905,
                    1034,
                    882,
                    883,
                    1042,
                    1043,
                    1014,
                    988
                ],
                "maxinterval": [
                    1030,
                    906,
                    1037,
                    885,
                    886,
                    989
                ],
                "_supports_unicode": [
                    889
                ],
                "_is_ascii": [
                    891
                ],
                "smoothing": [
                    896,
                    995,
                    1038,
                    916,
                    1044,
                    1018,
                    1020,
                    895
                ],
                "self.desc": [
                    1299,
                    1242,
                    1236,
                    900
                ],
                "desc": [
                    1242,
                    1236,
                    900
                ],
                "self.leave": [
                    1165,
                    902
                ],
                "leave": [
                    902
                ],
                "self.fp": [
                    1155,
                    1188,
                    903,
                    1287,
                    1288,
                    1003,
                    941,
                    1297,
                    1106
                ],
                "self.ncols": [
                    904,
                    1298
                ],
                "self.mininterval": [
                    1092,
                    1126,
                    1127,
                    905,
                    988,
                    1118,
                    1119
                ],
                "self.maxinterval": [
                    906,
                    1117,
                    989,
                    1122
                ],
                "self.miniters": [
                    1058,
                    1090,
                    1122,
                    1125,
                    1129,
                    907,
                    1131,
                    1011,
                    1012,
                    1052,
                    990,
                    1119
                ],
                "self.dynamic_miniters": [
                    908,
                    1116,
                    991
                ],
                "self.ascii": [
                    1299,
                    909
                ],
                "self.unit": [
                    1299,
                    911
                ],
                "self.unit_scale": [
                    912,
                    1300
                ],
                "self.unit_divisor": [
                    913,
                    1303
                ],
                "self.gui": [
                    914
                ],
                "gui": [
                    914,
                    939
                ],
                "self.dynamic_ncols": [
                    1297,
                    1298,
                    915
                ],
                "self.smoothing": [
                    995,
                    1124,
                    1125,
                    1097,
                    1129,
                    1100,
                    916
                ],
                "self.avg_time": [
                    996,
                    1099,
                    1100,
                    1168,
                    917,
                    1301,
                    1021
                ],
                "self._time": [
                    1091,
                    1093,
                    997,
                    1221,
                    1295,
                    946,
                    918,
                    1206
                ],
                "time": [
                    918
                ],
                "self.bar_format": [
                    1302,
                    919
                ],
                "self.postfix": [
                    1272,
                    1281,
                    1302,
                    920,
                    925
                ],
                "self.set_postfix": [
                    923
                ],
                "self.last_print_n": [
                    928,
                    993,
                    1056,
                    1090,
                    1220,
                    1094,
                    1134,
                    1166,
                    1050,
                    1086
                ],
                "self._lock": [
                    1024,
                    1185,
                    933,
                    1191,
                    1164,
                    942,
                    1199,
                    1202,
                    1108
                ],
                "position": [
                    937,
                    934
                ],
                "self.sp": [
                    1323,
                    1187,
                    941
                ],
                "self.status_printer": [
                    941
                ],
                "self.display": [
                    1025,
                    943,
                    1200,
                    1169,
                    1109,
                    1175
                ],
                "self.last_print_t": [
                    992,
                    1091,
                    1221,
                    1135,
                    946,
                    948,
                    1207,
                    1208,
                    1051
                ],
                "self.start_t": [
                    948,
                    1221,
                    1295,
                    1207
                ],
                "self.iterable.shape": [
                    952
                ],
                "self.close": [
                    960,
                    1059,
                    964
                ],
                "self.format_meter": [
                    967
                ],
                "self.format_dict": [
                    967
                ],
                "property": [
                    969,
                    1290
                ],
                "id": [
                    974
                ],
                "obj": [
                    985,
                    986,
                    1005,
                    1006
                ],
                "last_print_t": [
                    992,
                    1051,
                    1013
                ],
                "last_print_n": [
                    1056,
                    993,
                    1011,
                    1016,
                    1050
                ],
                "avg_time": [
                    1021,
                    996,
                    1020
                ],
                "_time": [
                    1013,
                    997,
                    1015
                ],
                "delta_t": [
                    1120,
                    1091,
                    1092,
                    1123,
                    1030,
                    1127,
                    1126,
                    1097,
                    1034,
                    1098,
                    1037,
                    1042,
                    1043,
                    1013,
                    1014,
                    1018,
                    1019,
                    1117
                ],
                "cur_t": [
                    1093,
                    1135,
                    1206,
                    1015,
                    1208,
                    1207,
                    1051
                ],
                "delta_it": [
                    1122,
                    1125,
                    1094,
                    1097,
                    1034,
                    1098,
                    1131,
                    1037,
                    1041,
                    1047,
                    1016,
                    1018,
                    1019,
                    1119
                ],
                "self.ema": [
                    1099,
                    1020,
                    1044
                ],
                "pos": [
                    1318,
                    1319,
                    1321,
                    1322,
                    1324,
                    1325,
                    1169,
                    1171,
                    1175,
                    1176,
                    1146
                ],
                "self._decr_instances": [
                    1147
                ],
                "self.fp.write": [
                    1155,
                    1188,
                    1287
                ],
                "ValueError": [
                    1159
                ],
                "i": [
                    1170,
                    1171
                ],
                "self._lock.acquire": [
                    1185,
                    1199
                ],
                "self.moveto": [
                    1186,
                    1325,
                    1322,
                    1189
                ],
                "self._lock.release": [
                    1202,
                    1191
                ],
                "self.refresh": [
                    1283,
                    1224,
                    1238,
                    1275,
                    1244
                ],
                "refresh": [
                    1282,
                    1274,
                    1243,
                    1237
                ],
                "_OrderedDict": [
                    1259
                ],
                "ordered_dict": [
                    1259
                ],
                "key": [
                    1260,
                    1261,
                    1263,
                    1265,
                    1266,
                    1268,
                    1269,
                    1272,
                    1273
                ],
                "sorted": [
                    1260
                ],
                "kwargs.keys": [
                    1260
                ],
                "postfix.keys": [
                    1273,
                    1263
                ],
                "Number": [
                    1265
                ],
                "self.format_num": [
                    1266
                ],
                "_basestring": [
                    1268
                ],
                "strip": [
                    1272
                ],
                "_term_move_up": [
                    1287
                ],
                "self.fp.flush": [
                    1288
                ],
                "self.__repr__": [
                    1323
                ],
                "_range": [
                    1333
                ]
            },
            "filtered_variables_in_file": {
                "__author__": [
                    28
                ],
                "__all__": [
                    30
                ],
                "fp_write": [
                    1158,
                    50,
                    51,
                    1173,
                    1177,
                    250
                ],
                "self.__class__.__name__": [
                    51
                ],
                "self.__class__": [
                    51
                ],
                "self": [
                    1024,
                    1025,
                    1044,
                    1050,
                    1051,
                    1052,
                    1056,
                    1057,
                    1058,
                    1059,
                    51,
                    54,
                    1082,
                    1086,
                    1087,
                    1090,
                    1091,
                    1092,
                    1093,
                    1094,
                    1097,
                    1099,
                    1100,
                    1102,
                    1106,
                    84,
                    85,
                    86,
                    87,
                    1108,
                    1109,
                    90,
                    1116,
                    1117,
                    94,
                    1118,
                    1119,
                    98,
                    1122,
                    1124,
                    101,
                    1125,
                    1127,
                    1126,
                    1129,
                    1131,
                    1134,
                    1135,
                    1139,
                    1143,
                    1146,
                    1147,
                    1150,
                    1155,
                    1164,
                    1165,
                    1166,
                    1168,
                    1169,
                    1171,
                    1175,
                    1181,
                    1185,
                    1186,
                    1187,
                    1188,
                    1189,
                    1191,
                    1195,
                    1199,
                    1200,
                    1202,
                    1206,
                    1207,
                    1208,
                    1220,
                    1221,
                    1223,
                    1224,
                    1236,
                    1238,
                    1242,
                    1244,
                    1266,
                    1272,
                    1275,
                    1281,
                    1283,
                    1287,
                    1288,
                    1294,
                    1295,
                    1296,
                    1297,
                    1298,
                    1299,
                    1300,
                    1301,
                    1302,
                    1303,
                    1319,
                    1322,
                    1323,
                    1325,
                    840,
                    841,
                    842,
                    843,
                    844,
                    845,
                    849,
                    850,
                    851,
                    899,
                    900,
                    901,
                    902,
                    903,
                    904,
                    905,
                    906,
                    907,
                    908,
                    909,
                    910,
                    911,
                    912,
                    913,
                    914,
                    915,
                    916,
                    917,
                    918,
                    919,
                    920,
                    923,
                    925,
                    928,
                    929,
                    933,
                    935,
                    937,
                    941,
                    942,
                    943,
                    946,
                    948,
                    951,
                    952,
                    953,
                    954,
                    957,
                    960,
                    964,
                    967,
                    971,
                    974,
                    980,
                    984,
                    988,
                    989,
                    990,
                    991,
                    992,
                    993,
                    994,
                    995,
                    996,
                    997,
                    999,
                    1003,
                    1011,
                    1012,
                    1020,
                    1021,
                    1023
                ],
                "rstrip": [
                    52
                ],
                "msg": [
                    1323,
                    52,
                    54
                ],
                "__init__": [
                    54
                ],
                "TqdmWarning": [
                    62,
                    57,
                    67,
                    54
                ],
                "a": [
                    54
                ],
                "k": [
                    54
                ],
                "self.create_mp_lock": [
                    84
                ],
                "self.create_th_lock": [
                    85
                ],
                "cls": [
                    512,
                    516,
                    522,
                    537,
                    540,
                    553,
                    558,
                    563,
                    564,
                    565,
                    461,
                    463,
                    464,
                    466,
                    467,
                    469,
                    86,
                    87,
                    472,
                    470,
                    477,
                    503,
                    484,
                    105,
                    107,
                    109,
                    494,
                    111,
                    496,
                    115,
                    117,
                    119,
                    509,
                    511
                ],
                "self.locks": [
                    90,
                    94,
                    87
                ],
                "lk": [
                    87
                ],
                "cls.mp_lock": [
                    107,
                    111,
                    109,
                    87
                ],
                "cls.th_lock": [
                    119,
                    117,
                    87
                ],
                "lock": [
                    558,
                    90,
                    91,
                    94,
                    95
                ],
                "lock.acquire": [
                    91
                ],
                "lock.release": [
                    95
                ],
                "self.acquire": [
                    98
                ],
                "self.release": [
                    101
                ],
                "mp.RLock": [
                    107
                ],
                "mp": [
                    107
                ],
                "th.RLock": [
                    117
                ],
                "th": [
                    117
                ],
                "TqdmDefaultWriteLock.create_th_lock": [
                    126
                ],
                "TqdmDefaultWriteLock": [
                    564,
                    126
                ],
                "ASCII_FMT": [
                    128,
                    429
                ],
                "UTF_FMT": [
                    129,
                    431
                ],
                "join": [
                    1272,
                    129
                ],
                "_unich": [
                    129
                ],
                "Comparable": [
                    132
                ],
                "monitor_interval": [
                    139
                ],
                "monitor": [
                    140
                ],
                "unit": [
                    162,
                    387,
                    166,
                    167,
                    168,
                    457,
                    911,
                    343,
                    346
                ],
                "num": [
                    163,
                    164,
                    165,
                    166,
                    167,
                    168,
                    169,
                    170
                ],
                "suffix": [
                    168,
                    170,
                    166,
                    167
                ],
                "divisor": [
                    169
                ],
                "mins": [
                    187,
                    188
                ],
                "s": [
                    192,
                    1281,
                    1155,
                    524,
                    243,
                    249,
                    250,
                    187,
                    190
                ],
                "t": [
                    672,
                    680,
                    652,
                    655,
                    664,
                    187
                ],
                "h": [
                    188,
                    189,
                    190
                ],
                "m": [
                    192,
                    188,
                    190
                ],
                "f": [
                    209,
                    211,
                    545
                ],
                "replace": [
                    209
                ],
                "n": [
                    1287,
                    394,
                    1050,
                    1057,
                    1085,
                    1086,
                    1087,
                    321,
                    328,
                    209,
                    210,
                    211,
                    338,
                    350,
                    354,
                    994,
                    362,
                    1009,
                    1011,
                    1016,
                    379,
                    1023
                ],
                "mu": [
                    230
                ],
                "x": [
                    230
                ],
                "alpha": [
                    230
                ],
                "fp": [
                    544,
                    545,
                    521,
                    524,
                    525,
                    239,
                    240,
                    243,
                    534
                ],
                "file": [
                    866,
                    903,
                    872,
                    521,
                    522,
                    239,
                    816,
                    818,
                    819,
                    856,
                    534,
                    824,
                    825,
                    827,
                    861,
                    889
                ],
                "fp_flush": [
                    240,
                    244
                ],
                "fp.write": [
                    243,
                    524,
                    525
                ],
                "_unicode": [
                    243,
                    1155,
                    893,
                    1287
                ],
                "last_len": [
                    250,
                    251,
                    246
                ],
                "len_s": [
                    249,
                    250,
                    251
                ],
                "print_status": [
                    253
                ],
                "total": [
                    901,
                    392,
                    648,
                    394,
                    655,
                    830,
                    832,
                    321,
                    322,
                    834,
                    835,
                    837,
                    326,
                    327,
                    1222,
                    1223,
                    845,
                    351,
                    352,
                    355,
                    362,
                    633,
                    634,
                    379,
                    636,
                    638
                ],
                "unit_scale": [
                    325,
                    327,
                    328,
                    330,
                    331,
                    912,
                    341,
                    344,
                    349
                ],
                "rate": [
                    1041,
                    1043,
                    1044,
                    329,
                    330,
                    1098,
                    1100,
                    337,
                    338,
                    339,
                    341,
                    342,
                    343,
                    362,
                    363,
                    380,
                    1019,
                    1020,
                    381
                ],
                "elapsed_str": [
                    384,
                    457,
                    333,
                    374
                ],
                "tqdm.format_interval": [
                    363,
                    333
                ],
                "tqdm": [
                    1333,
                    363,
                    340,
                    333
                ],
                "elapsed": [
                    384,
                    337,
                    338,
                    333
                ],
                "inv_rate": [
                    339,
                    344,
                    345,
                    346,
                    347,
                    380,
                    382
                ],
                "format_sizeof": [
                    340,
                    341,
                    344,
                    350,
                    351
                ],
                "tqdm.format_sizeof": [
                    340
                ],
                "rate_noinv_fmt": [
                    347,
                    341,
                    382
                ],
                "rate_inv_fmt": [
                    344,
                    347,
                    383
                ],
                "rate_fmt": [
                    457,
                    347,
                    381,
                    374
                ],
                "n_fmt": [
                    354,
                    457,
                    374,
                    379,
                    350
                ],
                "unit_divisor": [
                    913,
                    350,
                    351
                ],
                "total_fmt": [
                    379,
                    355,
                    374,
                    351
                ],
                "postfix": [
                    387,
                    1273,
                    358,
                    457,
                    1259,
                    1261,
                    1263,
                    1265,
                    1266,
                    1268,
                    1269,
                    374,
                    1272,
                    921,
                    923,
                    925
                ],
                "remaining": [
                    385,
                    362,
                    363
                ],
                "remaining_str": [
                    385,
                    363,
                    374
                ],
                "prefix": [
                    387,
                    455,
                    366,
                    368,
                    369,
                    407
                ],
                "bool_prefix_colon_already": [
                    368,
                    369
                ],
                "l_bar": [
                    448,
                    386,
                    423,
                    397,
                    400,
                    369,
                    371,
                    403,
                    415
                ],
                "r_bar": [
                    416,
                    448,
                    386,
                    423,
                    400,
                    373
                ],
                "format_dict": [
                    416,
                    419,
                    452,
                    403,
                    378,
                    415
                ],
                "extra_kwargs": [
                    389
                ],
                "frac": [
                    434,
                    394,
                    395
                ],
                "percentage": [
                    395,
                    403,
                    397
                ],
                "ncols": [
                    866,
                    422,
                    423,
                    872,
                    904,
                    399,
                    861
                ],
                "bar_format": [
                    450,
                    419,
                    452,
                    891,
                    402,
                    919,
                    408,
                    411,
                    893,
                    414
                ],
                "format_dict.update": [
                    403
                ],
                "bar_format.replace": [
                    408
                ],
                "l_bar_user": [
                    414,
                    415
                ],
                "r_bar_user": [
                    416,
                    414
                ],
                "bar_format.split": [
                    414
                ],
                "l_bar_user.format": [
                    415
                ],
                "r_bar_user.format": [
                    416
                ],
                "bar_format.format": [
                    419,
                    452
                ],
                "N_BARS": [
                    423,
                    425,
                    434,
                    440,
                    442,
                    445
                ],
                "RE_ANSI.sub": [
                    423
                ],
                "RE_ANSI": [
                    423
                ],
                "nsyms": [
                    432,
                    434
                ],
                "bar_length": [
                    433,
                    436,
                    440,
                    442,
                    445
                ],
                "frac_bar_length": [
                    433,
                    437
                ],
                "bar": [
                    441,
                    444,
                    436
                ],
                "frac_bar": [
                    441,
                    437
                ],
                "full_bar": [
                    448,
                    441,
                    444
                ],
                "instance": [
                    485,
                    461,
                    496,
                    467,
                    502,
                    505,
                    479
                ],
                "object.__new__": [
                    461
                ],
                "cls._instances": [
                    484,
                    464,
                    496,
                    467,
                    503,
                    509
                ],
                "WeakSet": [
                    464
                ],
                "cls.get_lock": [
                    537,
                    466
                ],
                "cls._instances.add": [
                    467
                ],
                "cls.monitor_interval": [
                    472,
                    477,
                    469
                ],
                "cls.monitor": [
                    512,
                    516,
                    469,
                    470,
                    472,
                    509,
                    511
                ],
                "cls.monitor.report": [
                    470
                ],
                "TMonitor": [
                    472
                ],
                "warn": [
                    474
                ],
                "e": [
                    1160,
                    475
                ],
                "TqdmMonitorWarning": [
                    476
                ],
                "positions": [
                    484,
                    486
                ],
                "inst.pos": [
                    505,
                    506,
                    484
                ],
                "inst": [
                    544,
                    545,
                    546,
                    547,
                    484,
                    485,
                    550,
                    551,
                    503,
                    505,
                    506,
                    540
                ],
                "difference": [
                    486
                ],
                "cls._lock": [
                    553,
                    558,
                    494,
                    564,
                    565
                ],
                "cls._instances.remove": [
                    496
                ],
                "instance.gui": [
                    502
                ],
                "instance.pos": [
                    505
                ],
                "cls.monitor.exit": [
                    511
                ],
                "sys.stdout": [
                    521,
                    861,
                    534,
                    545
                ],
                "sys": [
                    545,
                    521,
                    1003,
                    816,
                    1106,
                    819,
                    856,
                    534,
                    664,
                    861
                ],
                "cls.external_write_mode": [
                    522
                ],
                "nolock": [
                    1184,
                    1190,
                    552,
                    522,
                    1198,
                    1201,
                    536
                ],
                "end": [
                    525
                ],
                "acquire": [
                    537
                ],
                "inst_cleared": [
                    547,
                    539,
                    550
                ],
                "inst.fp": [
                    544,
                    545
                ],
                "sys.stderr": [
                    545,
                    1003,
                    1106,
                    819,
                    856,
                    664,
                    861
                ],
                "inst.clear": [
                    546
                ],
                "inst_cleared.append": [
                    547
                ],
                "inst.refresh": [
                    551
                ],
                "cls._lock.release": [
                    553
                ],
                "contextmanager": [
                    528
                ],
                "_Rolling_and_Expanding": [
                    608,
                    704,
                    640,
                    639,
                    703
                ],
                "deprecated_t": [
                    617,
                    651,
                    652,
                    653
                ],
                "tkwargs.pop": [
                    617,
                    633
                ],
                "tkwargs": [
                    617,
                    633,
                    655
                ],
                "df": [
                    640,
                    677,
                    648,
                    633,
                    636,
                    637,
                    638
                ],
                "df_function": [
                    635,
                    677
                ],
                "df.size": [
                    648,
                    636
                ],
                "Series": [
                    689,
                    637,
                    687
                ],
                "axis": [
                    642,
                    643,
                    644,
                    645,
                    646,
                    648
                ],
                "kwargs.get": [
                    642
                ],
                "kwargs": [
                    673,
                    642,
                    677,
                    1260,
                    1261,
                    848,
                    1333,
                    857,
                    858
                ],
                "df.shape": [
                    648
                ],
                "tclass": [
                    655
                ],
                "targs": [
                    655
                ],
                "args": [
                    657,
                    673,
                    1333
                ],
                "TqdmDeprecationWarning": [
                    1104,
                    1001,
                    659,
                    853
                ],
                "t.fp": [
                    664
                ],
                "sys.stderr.write": [
                    664,
                    1106,
                    856,
                    1003
                ],
                "t.update": [
                    672
                ],
                "t.total": [
                    672
                ],
                "t.n": [
                    672
                ],
                "func": [
                    673
                ],
                "result": [
                    681,
                    677
                ],
                "wrapper": [
                    677
                ],
                "t.close": [
                    680
                ],
                "inner": [
                    683
                ],
                "Series.progress_apply": [
                    687
                ],
                "inner_generator": [
                    704,
                    687,
                    688,
                    689,
                    690,
                    692,
                    693,
                    694,
                    696,
                    697,
                    699,
                    700,
                    701
                ],
                "SeriesGroupBy.progress_apply": [
                    688
                ],
                "SeriesGroupBy": [
                    688,
                    690
                ],
                "Series.progress_map": [
                    689
                ],
                "SeriesGroupBy.progress_map": [
                    690
                ],
                "DataFrame.progress_apply": [
                    692
                ],
                "DataFrame": [
                    692,
                    694
                ],
                "DataFrameGroupBy.progress_apply": [
                    693
                ],
                "DataFrameGroupBy": [
                    693
                ],
                "DataFrame.progress_applymap": [
                    694
                ],
                "Panel.progress_apply": [
                    696
                ],
                "Panel": [
                    696
                ],
                "PanelGroupBy.progress_apply": [
                    697
                ],
                "PanelGroupBy": [
                    697
                ],
                "GroupBy.progress_apply": [
                    699
                ],
                "GroupBy": [
                    699,
                    700,
                    701
                ],
                "GroupBy.progress_aggregate": [
                    700
                ],
                "GroupBy.progress_transform": [
                    701
                ],
                "_Rolling_and_Expanding.progress_apply": [
                    704
                ],
                "write_bytes": [
                    816,
                    821,
                    815
                ],
                "sys.version_info": [
                    816
                ],
                "SimpleTextIOWrapper": [
                    824
                ],
                "disable": [
                    839,
                    841,
                    910,
                    827,
                    828
                ],
                "file.isatty": [
                    827
                ],
                "iterable": [
                    832,
                    899,
                    840,
                    1005,
                    980,
                    985,
                    830
                ],
                "self.iterable": [
                    899,
                    840,
                    980,
                    951,
                    952,
                    953
                ],
                "self.disable": [
                    841,
                    1195,
                    910,
                    849,
                    1139,
                    1143,
                    984,
                    1082,
                    1181
                ],
                "self.pos": [
                    1186,
                    1189,
                    935,
                    1319,
                    937,
                    842,
                    850,
                    1146
                ],
                "self._get_free_pos": [
                    842,
                    850,
                    935
                ],
                "self._instances.remove": [
                    851,
                    843
                ],
                "self._instances": [
                    851,
                    843,
                    1171
                ],
                "self.n": [
                    929,
                    994,
                    1057,
                    1090,
                    1220,
                    1094,
                    844,
                    1134,
                    1166,
                    1294,
                    1050,
                    1087,
                    1023
                ],
                "initial": [
                    928,
                    929,
                    844
                ],
                "self.total": [
                    901,
                    1223,
                    845,
                    1294,
                    951
                ],
                "dedent": [
                    1104,
                    1001,
                    853
                ],
                "TqdmKeyError": [
                    858
                ],
                "dynamic_ncols": [
                    864,
                    865,
                    866,
                    915,
                    862,
                    863
                ],
                "_environ_cols_wrapper": [
                    864,
                    870
                ],
                "_dynamic_ncols": [
                    872,
                    870,
                    871
                ],
                "miniters": [
                    1058,
                    1034,
                    907,
                    876,
                    877,
                    1037,
                    1012,
                    1044,
                    1047,
                    1052,
                    990
                ],
                "dynamic_miniters": [
                    1029,
                    908,
                    878,
                    880,
                    991
                ],
                "mininterval": [
                    1032,
                    905,
                    1034,
                    882,
                    883,
                    1042,
                    1043,
                    1014,
                    988
                ],
                "maxinterval": [
                    1030,
                    906,
                    1037,
                    885,
                    886,
                    989
                ],
                "_supports_unicode": [
                    889
                ],
                "_is_ascii": [
                    891
                ],
                "smoothing": [
                    896,
                    995,
                    1038,
                    916,
                    1044,
                    1018,
                    1020,
                    895
                ],
                "self.desc": [
                    1299,
                    1242,
                    1236,
                    900
                ],
                "desc": [
                    1242,
                    1236,
                    900
                ],
                "self.leave": [
                    1165,
                    902
                ],
                "leave": [
                    902
                ],
                "self.fp": [
                    1155,
                    1188,
                    903,
                    1287,
                    1288,
                    1003,
                    941,
                    1297,
                    1106
                ],
                "self.ncols": [
                    904,
                    1298
                ],
                "self.mininterval": [
                    1092,
                    1126,
                    1127,
                    905,
                    988,
                    1118,
                    1119
                ],
                "self.maxinterval": [
                    906,
                    1117,
                    989,
                    1122
                ],
                "self.miniters": [
                    1058,
                    1090,
                    1122,
                    1125,
                    1129,
                    907,
                    1131,
                    1011,
                    1012,
                    1052,
                    990,
                    1119
                ],
                "self.dynamic_miniters": [
                    908,
                    1116,
                    991
                ],
                "self.ascii": [
                    1299,
                    909
                ],
                "self.unit": [
                    1299,
                    911
                ],
                "self.unit_scale": [
                    912,
                    1300
                ],
                "self.unit_divisor": [
                    913,
                    1303
                ],
                "self.gui": [
                    914
                ],
                "gui": [
                    914,
                    939
                ],
                "self.dynamic_ncols": [
                    1297,
                    1298,
                    915
                ],
                "self.smoothing": [
                    995,
                    1124,
                    1125,
                    1097,
                    1129,
                    1100,
                    916
                ],
                "self.avg_time": [
                    996,
                    1099,
                    1100,
                    1168,
                    917,
                    1301,
                    1021
                ],
                "self._time": [
                    1091,
                    1093,
                    997,
                    1221,
                    1295,
                    946,
                    918,
                    1206
                ],
                "time": [
                    918
                ],
                "self.bar_format": [
                    1302,
                    919
                ],
                "self.postfix": [
                    1272,
                    1281,
                    1302,
                    920,
                    925
                ],
                "self.set_postfix": [
                    923
                ],
                "self.last_print_n": [
                    928,
                    993,
                    1056,
                    1090,
                    1220,
                    1094,
                    1134,
                    1166,
                    1050,
                    1086
                ],
                "self._lock": [
                    1024,
                    1185,
                    933,
                    1191,
                    1164,
                    942,
                    1199,
                    1202,
                    1108
                ],
                "position": [
                    937,
                    934
                ],
                "self.sp": [
                    1323,
                    1187,
                    941
                ],
                "self.status_printer": [
                    941
                ],
                "self.display": [
                    1025,
                    943,
                    1200,
                    1169,
                    1109,
                    1175
                ],
                "self.last_print_t": [
                    992,
                    1091,
                    1221,
                    1135,
                    946,
                    948,
                    1207,
                    1208,
                    1051
                ],
                "self.start_t": [
                    948,
                    1221,
                    1295,
                    1207
                ],
                "self.iterable.shape": [
                    952
                ],
                "self.close": [
                    960,
                    1059,
                    964
                ],
                "self.format_meter": [
                    967
                ],
                "self.format_dict": [
                    967
                ],
                "obj": [
                    985,
                    986,
                    1005,
                    1006
                ],
                "last_print_t": [
                    992,
                    1051,
                    1013
                ],
                "last_print_n": [
                    1056,
                    993,
                    1011,
                    1016,
                    1050
                ],
                "avg_time": [
                    1021,
                    996,
                    1020
                ],
                "_time": [
                    1013,
                    997,
                    1015
                ],
                "delta_t": [
                    1120,
                    1091,
                    1092,
                    1123,
                    1030,
                    1127,
                    1126,
                    1097,
                    1034,
                    1098,
                    1037,
                    1042,
                    1043,
                    1013,
                    1014,
                    1018,
                    1019,
                    1117
                ],
                "cur_t": [
                    1093,
                    1135,
                    1206,
                    1015,
                    1208,
                    1207,
                    1051
                ],
                "delta_it": [
                    1122,
                    1125,
                    1094,
                    1097,
                    1034,
                    1098,
                    1131,
                    1037,
                    1041,
                    1047,
                    1016,
                    1018,
                    1019,
                    1119
                ],
                "self.ema": [
                    1099,
                    1020,
                    1044
                ],
                "pos": [
                    1318,
                    1319,
                    1321,
                    1322,
                    1324,
                    1325,
                    1169,
                    1171,
                    1175,
                    1176,
                    1146
                ],
                "self._decr_instances": [
                    1147
                ],
                "self.fp.write": [
                    1155,
                    1188,
                    1287
                ],
                "i": [
                    1170,
                    1171
                ],
                "self._lock.acquire": [
                    1185,
                    1199
                ],
                "self.moveto": [
                    1186,
                    1325,
                    1322,
                    1189
                ],
                "self._lock.release": [
                    1202,
                    1191
                ],
                "self.refresh": [
                    1283,
                    1224,
                    1238,
                    1275,
                    1244
                ],
                "refresh": [
                    1282,
                    1274,
                    1243,
                    1237
                ],
                "_OrderedDict": [
                    1259
                ],
                "ordered_dict": [
                    1259
                ],
                "key": [
                    1260,
                    1261,
                    1263,
                    1265,
                    1266,
                    1268,
                    1269,
                    1272,
                    1273
                ],
                "kwargs.keys": [
                    1260
                ],
                "postfix.keys": [
                    1273,
                    1263
                ],
                "Number": [
                    1265
                ],
                "self.format_num": [
                    1266
                ],
                "_basestring": [
                    1268
                ],
                "strip": [
                    1272
                ],
                "_term_move_up": [
                    1287
                ],
                "self.fp.flush": [
                    1288
                ],
                "self.__repr__": [
                    1323
                ],
                "_range": [
                    1333
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/home/ubuntu/Desktop/bgp_envs_local/repos/tqdm_3/tqdm/tests/tests_tqdm.py",
                "test_function": "test_bool",
                "test_function_code": "@with_setup(pretest, posttest)\ndef test_bool():\n    \"\"\"Test boolean cast\"\"\"\n\n    def internal(our_file, disable):\n        with trange(10, file=our_file, disable=disable) as t:\n            assert t\n        with trange(0, file=our_file, disable=disable) as t:\n            assert not t\n\n        def get_bool_for_tqdm(*args, **kwargs):\n            kwargs['file'] = our_file\n            kwargs['disable'] = disable\n            with tqdm(*args, **kwargs) as t:\n                return bool(t)\n\n        assert get_bool_for_tqdm(total=10)\n        assert not get_bool_for_tqdm(total=0)\n        assert not get_bool_for_tqdm([])\n        assert get_bool_for_tqdm([0])\n        assert get_bool_for_tqdm((x for x in []))\n        assert get_bool_for_tqdm((x for x in [1,2,3]))\n        try:\n            get_bool_for_tqdm()\n        except TypeError:\n            pass\n        else:\n            raise TypeError(\n                \"Expected tqdm() with neither total nor iterable to fail\")\n\n    # test with and without disable\n    with closing(StringIO()) as our_file:\n        internal(our_file, False)\n        internal(our_file, True)",
                "test_error": "TypeError: 'NoneType' object cannot be interpreted as an integer",
                "full_test_error": "@with_setup(pretest, posttest)\n    def test_bool():\n        \"\"\"Test boolean cast\"\"\"\n    \n        def internal(our_file, disable):\n            with trange(10, file=our_file, disable=disable) as t:\n                assert t\n            with trange(0, file=our_file, disable=disable) as t:\n                assert not t\n    \n            def get_bool_for_tqdm(*args, **kwargs):\n                kwargs['file'] = our_file\n                kwargs['disable'] = disable\n                with tqdm(*args, **kwargs) as t:\n                    return bool(t)\n    \n            assert get_bool_for_tqdm(total=10)\n            assert not get_bool_for_tqdm(total=0)\n            assert not get_bool_for_tqdm([])\n            assert get_bool_for_tqdm([0])\n            assert get_bool_for_tqdm((x for x in []))\n            assert get_bool_for_tqdm((x for x in [1,2,3]))\n            try:\n                get_bool_for_tqdm()\n            except TypeError:\n                pass\n            else:\n                raise TypeError(\n                    \"Expected tqdm() with neither total nor iterable to fail\")\n    \n        # test with and without disable\n        with closing(StringIO()) as our_file:\n>           internal(our_file, False)\n\ntqdm/tests/tests_tqdm.py:1742: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntqdm/tests/tests_tqdm.py:1730: in internal\n    assert get_bool_for_tqdm((x for x in []))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (<generator object test_bool.<locals>.internal.<locals>.<genexpr> at 0x7f5b81f81cd0>,)\nkwargs = {'disable': False, 'file': <_io.StringIO object at 0x7f5b81d74cd0>}\nt = 0it [00:00, ?it/s]\n\n    def get_bool_for_tqdm(*args, **kwargs):\n        kwargs['file'] = our_file\n        kwargs['disable'] = disable\n        with tqdm(*args, **kwargs) as t:\n>           return bool(t)\nE           TypeError: 'NoneType' object cannot be interpreted as an integer\n\ntqdm/tests/tests_tqdm.py:1724: TypeError",
                "traceback": "tqdm/tests/tests_tqdm.py:1730: in internal\n    assert get_bool_for_tqdm((x for x in []))",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (<generator object test_bool.<locals>.internal.<locals>.<genexpr> at 0x7f5b81f81cd0>,)\nkwargs = {'disable': False, 'file': <_io.StringIO object at 0x7f5b81d74cd0>}\nt = 0it [00:00, ?it/s]\n\n    def get_bool_for_tqdm(*args, **kwargs):\n        kwargs['file'] = our_file\n        kwargs['disable'] = disable\n        with tqdm(*args, **kwargs) as t:\n>           return bool(t)\nE           TypeError: 'NoneType' object cannot be interpreted as an integer\n\ntqdm/tests/tests_tqdm.py:1724: TypeError",
                "test_function_decorators": [
                    "with_setup(pretest, posttest)"
                ]
            }
        ]
    }
}