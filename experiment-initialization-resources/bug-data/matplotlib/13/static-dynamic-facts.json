{
    "matplotlib:13": {
        "/home/ubuntu/Desktop/bgp_envs_local/repos/matplotlib_13/lib/matplotlib/path.py": {
            "buggy_functions": [
                {
                    "function_name": "make_compound_path",
                    "function_code": "@classmethod\ndef make_compound_path(cls, *args):\n    \"\"\"Make a compound path from a list of Path objects.\"\"\"\n    # Handle an empty list in args (i.e. no args).\n    if not args:\n        return Path(np.empty([0, 2], dtype=np.float32))\n\n    vertices = np.concatenate([x.vertices for x in args])\n    codes = np.empty(len(vertices), dtype=cls.code_type)\n    i = 0\n    for path in args:\n        if path.codes is None:\n            codes[i] = cls.MOVETO\n            codes[i + 1:i + len(path.vertices)] = cls.LINETO\n        else:\n            codes[i:i + len(path.codes)] = path.codes\n        i += len(path.vertices)\n\n    return cls(vertices, codes)\n",
                    "decorators": [
                        "classmethod"
                    ],
                    "docstring": "Make a compound path from a list of Path objects.",
                    "start_line": 326,
                    "end_line": 344,
                    "variables": {
                        "args": [
                            336,
                            330,
                            333
                        ],
                        "Path": [
                            331
                        ],
                        "np.empty": [
                            331,
                            334
                        ],
                        "np": [
                            331,
                            333,
                            334
                        ],
                        "np.float32": [
                            331
                        ],
                        "vertices": [
                            344,
                            333,
                            334
                        ],
                        "np.concatenate": [
                            333
                        ],
                        "x.vertices": [
                            333
                        ],
                        "x": [
                            333
                        ],
                        "codes": [
                            334,
                            338,
                            339,
                            341,
                            344
                        ],
                        "len": [
                            342,
                            339,
                            341,
                            334
                        ],
                        "cls.code_type": [
                            334
                        ],
                        "cls": [
                            344,
                            338,
                            339,
                            334
                        ],
                        "i": [
                            335,
                            338,
                            339,
                            341,
                            342
                        ],
                        "path": [
                            336,
                            337,
                            339,
                            341,
                            342
                        ],
                        "path.codes": [
                            337,
                            341
                        ],
                        "cls.MOVETO": [
                            338
                        ],
                        "path.vertices": [
                            339,
                            342
                        ],
                        "cls.LINETO": [
                            339
                        ],
                        "classmethod": [
                            326
                        ]
                    },
                    "filtered_variables": {
                        "args": [
                            336,
                            330,
                            333
                        ],
                        "Path": [
                            331
                        ],
                        "np.empty": [
                            331,
                            334
                        ],
                        "np": [
                            331,
                            333,
                            334
                        ],
                        "np.float32": [
                            331
                        ],
                        "vertices": [
                            344,
                            333,
                            334
                        ],
                        "np.concatenate": [
                            333
                        ],
                        "x.vertices": [
                            333
                        ],
                        "x": [
                            333
                        ],
                        "codes": [
                            334,
                            338,
                            339,
                            341,
                            344
                        ],
                        "cls.code_type": [
                            334
                        ],
                        "cls": [
                            344,
                            338,
                            339,
                            334
                        ],
                        "i": [
                            335,
                            338,
                            339,
                            341,
                            342
                        ],
                        "path": [
                            336,
                            337,
                            339,
                            341,
                            342
                        ],
                        "path.codes": [
                            337,
                            341
                        ],
                        "cls.MOVETO": [
                            338
                        ],
                        "path.vertices": [
                            339,
                            342
                        ],
                        "cls.LINETO": [
                            339
                        ]
                    },
                    "diff_line_number": 332,
                    "class_data": {
                        "signature": "class Path()",
                        "docstring": "A series of possibly disconnected, possibly closed, line and curve\nsegments.\n\nThe underlying storage is made up of two parallel numpy arrays:\n\n- *vertices*: an Nx2 float array of vertices\n- *codes*: an N-length uint8 array of vertex types, or None\n\nThese two arrays always have the same length in the first\ndimension.  For example, to represent a cubic curve, you must\nprovide three vertices as well as three codes ``CURVE3``.\n\nThe code types are:\n\n- ``STOP``   :  1 vertex (ignored)\n    A marker for the end of the entire path (currently not required and\n    ignored)\n\n- ``MOVETO`` :  1 vertex\n    Pick up the pen and move to the given vertex.\n\n- ``LINETO`` :  1 vertex\n    Draw a line from the current position to the given vertex.\n\n- ``CURVE3`` :  1 control point, 1 endpoint\n    Draw a quadratic Bezier curve from the current position, with the given\n    control point, to the given end point.\n\n- ``CURVE4`` :  2 control points, 1 endpoint\n    Draw a cubic Bezier curve from the current position, with the given\n    control points, to the given end point.\n\n- ``CLOSEPOLY`` : 1 vertex (ignored)\n    Draw a line segment to the start point of the current polyline.\n\nIf *codes* is None, it is interpreted as a ``MOVETO`` followed by a series\nof ``LINETO``.\n\nUsers of Path objects should not access the vertices and codes arrays\ndirectly.  Instead, they should use `iter_segments` or `cleaned` to get the\nvertex/code pairs.  This helps, in particular, to consistently handle the\ncase of *codes* being None.\n\nSome behavior of Path objects can be controlled by rcParams. See the\nrcParams whose keys start with 'path.'.\n\n.. note::\n\n    The vertices and codes arrays should be treated as\n    immutable -- there are a number of optimizations and assumptions\n    made up front in the constructor that will not change when the\n    data changes.",
                        "constructor_docstring": "Create a new path with the given vertices and codes.\n\nParameters\n----------\nvertices : array-like\n    The ``(N, 2)`` float array, masked array or sequence of pairs\n    representing the vertices of the path.\n\n    If *vertices* contains masked values, they will be converted\n    to NaNs which are then handled correctly by the Agg\n    PathIterator and other consumers of path data, such as\n    :meth:`iter_segments`.\ncodes : array-like or None, optional\n    n-length array integers representing the codes of the path.\n    If not None, codes must be the same length as vertices.\n    If None, *vertices* will be treated as a series of line segments.\n_interpolation_steps : int, optional\n    Used as a hint to certain projections, such as Polar, that this\n    path should be linearly interpolated immediately before drawing.\n    This attribute is primarily an implementation detail and is not\n    intended for public use.\nclosed : bool, optional\n    If *codes* is None and closed is True, vertices will be treated as\n    line segments of a closed polygon.  Note that the last vertex will\n    then be ignored (as the corresponding code will be set to\n    CLOSEPOLY).\nreadonly : bool, optional\n    Makes the path behave in an immutable way and sets the vertices\n    and codes as read-only arrays.",
                        "functions": [
                            "def __init__(self, vertices, codes=None, _interpolation_steps=1, closed=False, readonly=False):\n    \"\"\"\n    Create a new path with the given vertices and codes.\n\n    Parameters\n    ----------\n    vertices : array-like\n        The ``(N, 2)`` float array, masked array or sequence of pairs\n        representing the vertices of the path.\n\n        If *vertices* contains masked values, they will be converted\n        to NaNs which are then handled correctly by the Agg\n        PathIterator and other consumers of path data, such as\n        :meth:`iter_segments`.\n    codes : array-like or None, optional\n        n-length array integers representing the codes of the path.\n        If not None, codes must be the same length as vertices.\n        If None, *vertices* will be treated as a series of line segments.\n    _interpolation_steps : int, optional\n        Used as a hint to certain projections, such as Polar, that this\n        path should be linearly interpolated immediately before drawing.\n        This attribute is primarily an implementation detail and is not\n        intended for public use.\n    closed : bool, optional\n        If *codes* is None and closed is True, vertices will be treated as\n        line segments of a closed polygon.  Note that the last vertex will\n        then be ignored (as the corresponding code will be set to\n        CLOSEPOLY).\n    readonly : bool, optional\n        Makes the path behave in an immutable way and sets the vertices\n        and codes as read-only arrays.\n    \"\"\"\n    vertices = _to_unmasked_float_array(vertices)\n    if vertices.ndim != 2 or vertices.shape[1] != 2:\n        raise ValueError(\"'vertices' must be a 2D list or array with shape Nx2\")\n    if codes is not None:\n        codes = np.asarray(codes, self.code_type)\n        if codes.ndim != 1 or len(codes) != len(vertices):\n            raise ValueError(\"'codes' must be a 1D list or array with the same length of 'vertices'\")\n        if len(codes) and codes[0] != self.MOVETO:\n            raise ValueError(\"The first element of 'code' must be equal to 'MOVETO' ({})\".format(self.MOVETO))\n    elif closed and len(vertices):\n        codes = np.empty(len(vertices), dtype=self.code_type)\n        codes[0] = self.MOVETO\n        codes[1:-1] = self.LINETO\n        codes[-1] = self.CLOSEPOLY\n    self._vertices = vertices\n    self._codes = codes\n    self._interpolation_steps = _interpolation_steps\n    self._update_values()\n    if readonly:\n        self._vertices.flags.writeable = False\n        if self._codes is not None:\n            self._codes.flags.writeable = False\n        self._readonly = True\n    else:\n        self._readonly = False",
                            "@classmethod\ndef _fast_from_codes_and_verts(cls, verts, codes, internals_from=None):\n    \"\"\"\n    Creates a Path instance without the expense of calling the constructor.\n\n    Parameters\n    ----------\n    verts : numpy array\n    codes : numpy array\n    internals_from : Path or None\n        If not None, another `Path` from which the attributes\n        ``should_simplify``, ``simplify_threshold``, and\n        ``interpolation_steps`` will be copied.  Note that ``readonly`` is\n        never copied, and always set to ``False`` by this constructor.\n    \"\"\"\n    pth = cls.__new__(cls)\n    pth._vertices = _to_unmasked_float_array(verts)\n    pth._codes = codes\n    pth._readonly = False\n    if internals_from is not None:\n        pth._should_simplify = internals_from._should_simplify\n        pth._simplify_threshold = internals_from._simplify_threshold\n        pth._interpolation_steps = internals_from._interpolation_steps\n    else:\n        pth._should_simplify = True\n        pth._simplify_threshold = mpl.rcParams['path.simplify_threshold']\n        pth._interpolation_steps = 1\n    return pth",
                            "def _update_values(self):\n    self._simplify_threshold = mpl.rcParams['path.simplify_threshold']\n    self._should_simplify = self._simplify_threshold > 0 and mpl.rcParams['path.simplify'] and (len(self._vertices) >= 128) and (self._codes is None or np.all(self._codes <= Path.LINETO))",
                            "@property\ndef vertices(self):\n    \"\"\"\n    The list of vertices in the `Path` as an Nx2 numpy array.\n    \"\"\"\n    return self._vertices",
                            "@vertices.setter\ndef vertices(self, vertices):\n    if self._readonly:\n        raise AttributeError(\"Can't set vertices on a readonly Path\")\n    self._vertices = vertices\n    self._update_values()",
                            "@property\ndef codes(self):\n    \"\"\"\n    The list of codes in the `Path` as a 1-D numpy array.  Each\n    code is one of `STOP`, `MOVETO`, `LINETO`, `CURVE3`, `CURVE4`\n    or `CLOSEPOLY`.  For codes that correspond to more than one\n    vertex (`CURVE3` and `CURVE4`), that code will be repeated so\n    that the length of `self.vertices` and `self.codes` is always\n    the same.\n    \"\"\"\n    return self._codes",
                            "@codes.setter\ndef codes(self, codes):\n    if self._readonly:\n        raise AttributeError(\"Can't set codes on a readonly Path\")\n    self._codes = codes\n    self._update_values()",
                            "@property\ndef simplify_threshold(self):\n    \"\"\"\n    The fraction of a pixel difference below which vertices will\n    be simplified out.\n    \"\"\"\n    return self._simplify_threshold",
                            "@simplify_threshold.setter\ndef simplify_threshold(self, threshold):\n    self._simplify_threshold = threshold",
                            "@cbook.deprecated('3.1', alternative='not np.isfinite(self.vertices).all()')\n@property\ndef has_nonfinite(self):\n    \"\"\"\n    `True` if the vertices array has nonfinite values.\n    \"\"\"\n    return not np.isfinite(self._vertices).all()",
                            "@property\ndef should_simplify(self):\n    \"\"\"\n    `True` if the vertices array should be simplified.\n    \"\"\"\n    return self._should_simplify",
                            "@should_simplify.setter\ndef should_simplify(self, should_simplify):\n    self._should_simplify = should_simplify",
                            "@property\ndef readonly(self):\n    \"\"\"\n    `True` if the `Path` is read-only.\n    \"\"\"\n    return self._readonly",
                            "def __copy__(self):\n    \"\"\"\n    Returns a shallow copy of the `Path`, which will share the\n    vertices and codes with the source `Path`.\n    \"\"\"\n    import copy\n    return copy.copy(self)",
                            "def __deepcopy__(self, memo=None):\n    \"\"\"\n    Returns a deepcopy of the `Path`.  The `Path` will not be\n    readonly, even if the source `Path` is.\n    \"\"\"\n    try:\n        codes = self.codes.copy()\n    except AttributeError:\n        codes = None\n    return self.__class__(self.vertices.copy(), codes, _interpolation_steps=self._interpolation_steps)",
                            "@classmethod\ndef make_compound_path_from_polys(cls, XY):\n    \"\"\"\n    Make a compound path object to draw a number\n    of polygons with equal numbers of sides XY is a (numpolys x\n    numsides x 2) numpy array of vertices.  Return object is a\n    :class:`Path`\n\n    .. plot:: gallery/misc/histogram_path.py\n\n    \"\"\"\n    (numpolys, numsides, two) = XY.shape\n    if two != 2:\n        raise ValueError(\"The third dimension of 'XY' must be 2\")\n    stride = numsides + 1\n    nverts = numpolys * stride\n    verts = np.zeros((nverts, 2))\n    codes = np.full(nverts, cls.LINETO, dtype=cls.code_type)\n    codes[0::stride] = cls.MOVETO\n    codes[numsides::stride] = cls.CLOSEPOLY\n    for i in range(numsides):\n        verts[i::stride] = XY[:, i]\n    return cls(verts, codes)",
                            "@classmethod\ndef make_compound_path(cls, *args):\n    \"\"\"Make a compound path from a list of Path objects.\"\"\"\n    if not args:\n        return Path(np.empty([0, 2], dtype=np.float32))\n    vertices = np.concatenate([x.vertices for x in args])\n    codes = np.empty(len(vertices), dtype=cls.code_type)\n    i = 0\n    for path in args:\n        if path.codes is None:\n            codes[i] = cls.MOVETO\n            codes[i + 1:i + len(path.vertices)] = cls.LINETO\n        else:\n            codes[i:i + len(path.codes)] = path.codes\n        i += len(path.vertices)\n    return cls(vertices, codes)",
                            "def __repr__(self):\n    return 'Path(%r, %r)' % (self.vertices, self.codes)",
                            "def __len__(self):\n    return len(self.vertices)",
                            "def iter_segments(self, transform=None, remove_nans=True, clip=None, snap=False, stroke_width=1.0, simplify=None, curves=True, sketch=None):\n    \"\"\"\n    Iterates over all of the curve segments in the path.  Each iteration\n    returns a 2-tuple ``(vertices, code)``, where ``vertices`` is a\n    sequence of 1-3 coordinate pairs, and ``code`` is a `Path` code.\n\n    Additionally, this method can provide a number of standard cleanups and\n    conversions to the path.\n\n    Parameters\n    ----------\n    transform : None or :class:`~matplotlib.transforms.Transform`\n        If not None, the given affine transformation will be applied to the\n        path.\n    remove_nans : bool, optional\n        Whether to remove all NaNs from the path and skip over them using\n        MOVETO commands.\n    clip : None or (float, float, float, float), optional\n        If not None, must be a four-tuple (x1, y1, x2, y2)\n        defining a rectangle in which to clip the path.\n    snap : None or bool, optional\n        If True, snap all nodes to pixels; if False, don't snap them.\n        If None, perform snapping if the path contains only segments\n        parallel to the x or y axes, and no more than 1024 of them.\n    stroke_width : float, optional\n        The width of the stroke being drawn (used for path snapping).\n    simplify : None or bool, optional\n        Whether to simplify the path by removing vertices\n        that do not affect its appearance.  If None, use the\n        :attr:`should_simplify` attribute.  See also :rc:`path.simplify`\n        and :rc:`path.simplify_threshold`.\n    curves : bool, optional\n        If True, curve segments will be returned as curve segments.\n        If False, all curves will be converted to line segments.\n    sketch : None or sequence, optional\n        If not None, must be a 3-tuple of the form\n        (scale, length, randomness), representing the sketch parameters.\n    \"\"\"\n    if not len(self):\n        return\n    cleaned = self.cleaned(transform=transform, remove_nans=remove_nans, clip=clip, snap=snap, stroke_width=stroke_width, simplify=simplify, curves=curves, sketch=sketch)\n    NUM_VERTICES_FOR_CODE = self.NUM_VERTICES_FOR_CODE\n    STOP = self.STOP\n    vertices = iter(cleaned.vertices)\n    codes = iter(cleaned.codes)\n    for (curr_vertices, code) in zip(vertices, codes):\n        if code == STOP:\n            break\n        extra_vertices = NUM_VERTICES_FOR_CODE[code] - 1\n        if extra_vertices:\n            for i in range(extra_vertices):\n                next(codes)\n                curr_vertices = np.append(curr_vertices, next(vertices))\n        yield (curr_vertices, code)",
                            "@cbook._delete_parameter('3.3', 'quantize')\ndef cleaned(self, transform=None, remove_nans=False, clip=None, quantize=False, simplify=False, curves=False, stroke_width=1.0, snap=False, sketch=None):\n    \"\"\"\n    Return a new Path with vertices and codes cleaned according to the\n    parameters.\n\n    See Also\n    --------\n    Path.iter_segments : for details of the keyword arguments.\n    \"\"\"\n    (vertices, codes) = _path.cleanup_path(self, transform, remove_nans, clip, snap, stroke_width, simplify, curves, sketch)\n    pth = Path._fast_from_codes_and_verts(vertices, codes, self)\n    if not simplify:\n        pth._should_simplify = False\n    return pth",
                            "def transformed(self, transform):\n    \"\"\"\n    Return a transformed copy of the path.\n\n    See Also\n    --------\n    matplotlib.transforms.TransformedPath\n        A specialized path class that will cache the transformed result and\n        automatically update when the transform changes.\n    \"\"\"\n    return Path(transform.transform(self.vertices), self.codes, self._interpolation_steps)",
                            "def contains_point(self, point, transform=None, radius=0.0):\n    \"\"\"\n    Return whether the (closed) path contains the given point.\n\n    Parameters\n    ----------\n    point : (float, float)\n        The point (x, y) to check.\n    transform : `matplotlib.transforms.Transform`, optional\n        If not ``None``, *point* will be compared to ``self`` transformed\n        by *transform*; i.e. for a correct check, *transform* should\n        transform the path into the coordinate system of *point*.\n    radius : float, default: 0\n        Add an additional margin on the path in coordinates of *point*.\n        The path is extended tangentially by *radius/2*; i.e. if you would\n        draw the path with a linewidth of *radius*, all points on the line\n        would still be considered to be contained in the area. Conversely,\n        negative values shrink the area: Points on the imaginary line\n        will be considered outside the area.\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    if transform is not None:\n        transform = transform.frozen()\n    if transform and (not transform.is_affine):\n        self = transform.transform_path(self)\n        transform = None\n    return _path.point_in_path(point[0], point[1], radius, self, transform)",
                            "def contains_points(self, points, transform=None, radius=0.0):\n    \"\"\"\n    Return whether the (closed) path contains the given point.\n\n    Parameters\n    ----------\n    points : (N, 2) array\n        The points to check. Columns contain x and y values.\n    transform : `matplotlib.transforms.Transform`, optional\n        If not ``None``, *points* will be compared to ``self`` transformed\n        by *transform*; i.e. for a correct check, *transform* should\n        transform the path into the coordinate system of *points*.\n    radius : float, default: 0.\n        Add an additional margin on the path in coordinates of *points*.\n        The path is extended tangentially by *radius/2*; i.e. if you would\n        draw the path with a linewidth of *radius*, all points on the line\n        would still be considered to be contained in the area. Conversely,\n        negative values shrink the area: Points on the imaginary line\n        will be considered outside the area.\n\n    Returns\n    -------\n    length-N bool array\n    \"\"\"\n    if transform is not None:\n        transform = transform.frozen()\n    result = _path.points_in_path(points, radius, self, transform)\n    return result.astype('bool')",
                            "def contains_path(self, path, transform=None):\n    \"\"\"\n    Returns whether this (closed) path completely contains the given path.\n\n    If *transform* is not ``None``, the path will be transformed before\n    performing the test.\n    \"\"\"\n    if transform is not None:\n        transform = transform.frozen()\n    return _path.path_in_path(self, None, path, transform)",
                            "def get_extents(self, transform=None):\n    \"\"\"\n    Returns the extents (*xmin*, *ymin*, *xmax*, *ymax*) of the path.\n\n    Unlike computing the extents on the *vertices* alone, this\n    algorithm will take into account the curves and deal with\n    control points appropriately.\n    \"\"\"\n    from .transforms import Bbox\n    path = self\n    if transform is not None:\n        transform = transform.frozen()\n        if not transform.is_affine:\n            path = self.transformed(transform)\n            transform = None\n    return Bbox(_path.get_path_extents(path, transform))",
                            "def intersects_path(self, other, filled=True):\n    \"\"\"\n    Returns *True* if this path intersects another given path.\n\n    *filled*, when True, treats the paths as if they were filled.\n    That is, if one path completely encloses the other,\n    :meth:`intersects_path` will return True.\n    \"\"\"\n    return _path.path_intersects_path(self, other, filled)",
                            "def intersects_bbox(self, bbox, filled=True):\n    \"\"\"\n    Returns whether this path intersects a given `~.transforms.Bbox`.\n\n    *filled*, when True, treats the path as if it was filled.\n    That is, if the path completely encloses the bounding box,\n    :meth:`intersects_bbox` will return True.\n\n    The bounding box is always considered filled.\n    \"\"\"\n    return _path.path_intersects_rectangle(self, bbox.x0, bbox.y0, bbox.x1, bbox.y1, filled)",
                            "def interpolated(self, steps):\n    \"\"\"\n    Returns a new path resampled to length N x steps.  Does not\n    currently handle interpolating curves.\n    \"\"\"\n    if steps == 1:\n        return self\n    vertices = simple_linear_interpolation(self.vertices, steps)\n    codes = self.codes\n    if codes is not None:\n        new_codes = np.full((len(codes) - 1) * steps + 1, Path.LINETO, dtype=self.code_type)\n        new_codes[0::steps] = codes\n    else:\n        new_codes = None\n    return Path(vertices, new_codes)",
                            "def to_polygons(self, transform=None, width=0, height=0, closed_only=True):\n    \"\"\"\n    Convert this path to a list of polygons or polylines.  Each\n    polygon/polyline is an Nx2 array of vertices.  In other words,\n    each polygon has no ``MOVETO`` instructions or curves.  This\n    is useful for displaying in backends that do not support\n    compound paths or Bezier curves.\n\n    If *width* and *height* are both non-zero then the lines will\n    be simplified so that vertices outside of (0, 0), (width,\n    height) will be clipped.\n\n    If *closed_only* is `True` (default), only closed polygons,\n    with the last point being the same as the first point, will be\n    returned.  Any unclosed polylines in the path will be\n    explicitly closed.  If *closed_only* is `False`, any unclosed\n    polygons in the path will be returned as unclosed polygons,\n    and the closed polygons will be returned explicitly closed by\n    setting the last point to the same as the first point.\n    \"\"\"\n    if len(self.vertices) == 0:\n        return []\n    if transform is not None:\n        transform = transform.frozen()\n    if self.codes is None and (width == 0 or height == 0):\n        vertices = self.vertices\n        if closed_only:\n            if len(vertices) < 3:\n                return []\n            elif np.any(vertices[0] != vertices[-1]):\n                vertices = [*vertices, vertices[0]]\n        if transform is None:\n            return [vertices]\n        else:\n            return [transform.transform(vertices)]\n    return _path.convert_path_to_polygons(self, transform, width, height, closed_only)",
                            "@classmethod\ndef unit_rectangle(cls):\n    \"\"\"\n    Return a `Path` instance of the unit rectangle from (0, 0) to (1, 1).\n    \"\"\"\n    if cls._unit_rectangle is None:\n        cls._unit_rectangle = cls([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]], closed=True, readonly=True)\n    return cls._unit_rectangle",
                            "@classmethod\ndef unit_regular_polygon(cls, numVertices):\n    \"\"\"\n    Return a :class:`Path` instance for a unit regular polygon with the\n    given *numVertices* and radius of 1.0, centered at (0, 0).\n    \"\"\"\n    if numVertices <= 16:\n        path = cls._unit_regular_polygons.get(numVertices)\n    else:\n        path = None\n    if path is None:\n        theta = 2 * np.pi / numVertices * np.arange(numVertices + 1) + np.pi / 2\n        verts = np.column_stack((np.cos(theta), np.sin(theta)))\n        path = cls(verts, closed=True, readonly=True)\n        if numVertices <= 16:\n            cls._unit_regular_polygons[numVertices] = path\n    return path",
                            "@classmethod\ndef unit_regular_star(cls, numVertices, innerCircle=0.5):\n    \"\"\"\n    Return a :class:`Path` for a unit regular star with the given\n    numVertices and radius of 1.0, centered at (0, 0).\n    \"\"\"\n    if numVertices <= 16:\n        path = cls._unit_regular_stars.get((numVertices, innerCircle))\n    else:\n        path = None\n    if path is None:\n        ns2 = numVertices * 2\n        theta = 2 * np.pi / ns2 * np.arange(ns2 + 1)\n        theta += np.pi / 2.0\n        r = np.ones(ns2 + 1)\n        r[1::2] = innerCircle\n        verts = (r * np.vstack((np.cos(theta), np.sin(theta)))).T\n        path = cls(verts, closed=True, readonly=True)\n        if numVertices <= 16:\n            cls._unit_regular_stars[numVertices, innerCircle] = path\n    return path",
                            "@classmethod\ndef unit_regular_asterisk(cls, numVertices):\n    \"\"\"\n    Return a :class:`Path` for a unit regular asterisk with the given\n    numVertices and radius of 1.0, centered at (0, 0).\n    \"\"\"\n    return cls.unit_regular_star(numVertices, 0.0)",
                            "@classmethod\ndef unit_circle(cls):\n    \"\"\"\n    Return the readonly :class:`Path` of the unit circle.\n\n    For most cases, :func:`Path.circle` will be what you want.\n    \"\"\"\n    if cls._unit_circle is None:\n        cls._unit_circle = cls.circle(center=(0, 0), radius=1, readonly=True)\n    return cls._unit_circle",
                            "@classmethod\ndef circle(cls, center=(0.0, 0.0), radius=1.0, readonly=False):\n    \"\"\"\n    Return a `Path` representing a circle of a given radius and center.\n\n    Parameters\n    ----------\n    center : (float, float), default: (0, 0)\n        The center of the circle.\n    radius : float, default: 1\n        The radius of the circle.\n    readonly : bool\n        Whether the created path should have the \"readonly\" argument\n        set when creating the Path instance.\n\n    Notes\n    -----\n    The circle is approximated using 8 cubic Bezier curves, as described in\n\n      Lancaster, Don.  `Approximating a Circle or an Ellipse Using Four\n      Bezier Cubic Splines <http://www.tinaja.com/glib/ellipse4.pdf>`_.\n    \"\"\"\n    MAGIC = 0.2652031\n    SQRTHALF = np.sqrt(0.5)\n    MAGIC45 = SQRTHALF * MAGIC\n    vertices = np.array([[0.0, -1.0], [MAGIC, -1.0], [SQRTHALF - MAGIC45, -SQRTHALF - MAGIC45], [SQRTHALF, -SQRTHALF], [SQRTHALF + MAGIC45, -SQRTHALF + MAGIC45], [1.0, -MAGIC], [1.0, 0.0], [1.0, MAGIC], [SQRTHALF + MAGIC45, SQRTHALF - MAGIC45], [SQRTHALF, SQRTHALF], [SQRTHALF - MAGIC45, SQRTHALF + MAGIC45], [MAGIC, 1.0], [0.0, 1.0], [-MAGIC, 1.0], [-SQRTHALF + MAGIC45, SQRTHALF + MAGIC45], [-SQRTHALF, SQRTHALF], [-SQRTHALF - MAGIC45, SQRTHALF - MAGIC45], [-1.0, MAGIC], [-1.0, 0.0], [-1.0, -MAGIC], [-SQRTHALF - MAGIC45, -SQRTHALF + MAGIC45], [-SQRTHALF, -SQRTHALF], [-SQRTHALF + MAGIC45, -SQRTHALF - MAGIC45], [-MAGIC, -1.0], [0.0, -1.0], [0.0, -1.0]], dtype=float)\n    codes = [cls.CURVE4] * 26\n    codes[0] = cls.MOVETO\n    codes[-1] = cls.CLOSEPOLY\n    return Path(vertices * radius + center, codes, readonly=readonly)",
                            "@classmethod\ndef unit_circle_righthalf(cls):\n    \"\"\"\n    Return a `Path` of the right half of a unit circle.\n\n    See `Path.circle` for the reference on the approximation used.\n    \"\"\"\n    if cls._unit_circle_righthalf is None:\n        MAGIC = 0.2652031\n        SQRTHALF = np.sqrt(0.5)\n        MAGIC45 = SQRTHALF * MAGIC\n        vertices = np.array([[0.0, -1.0], [MAGIC, -1.0], [SQRTHALF - MAGIC45, -SQRTHALF - MAGIC45], [SQRTHALF, -SQRTHALF], [SQRTHALF + MAGIC45, -SQRTHALF + MAGIC45], [1.0, -MAGIC], [1.0, 0.0], [1.0, MAGIC], [SQRTHALF + MAGIC45, SQRTHALF - MAGIC45], [SQRTHALF, SQRTHALF], [SQRTHALF - MAGIC45, SQRTHALF + MAGIC45], [MAGIC, 1.0], [0.0, 1.0], [0.0, -1.0]], float)\n        codes = np.full(14, cls.CURVE4, dtype=cls.code_type)\n        codes[0] = cls.MOVETO\n        codes[-1] = cls.CLOSEPOLY\n        cls._unit_circle_righthalf = cls(vertices, codes, readonly=True)\n    return cls._unit_circle_righthalf",
                            "@classmethod\ndef arc(cls, theta1, theta2, n=None, is_wedge=False):\n    \"\"\"\n    Return the unit circle arc from angles *theta1* to *theta2* (in\n    degrees).\n\n    *theta2* is unwrapped to produce the shortest arc within 360 degrees.\n    That is, if *theta2* > *theta1* + 360, the arc will be from *theta1* to\n    *theta2* - 360 and not a full circle plus some extra overlap.\n\n    If *n* is provided, it is the number of spline segments to make.\n    If *n* is not provided, the number of spline segments is\n    determined based on the delta between *theta1* and *theta2*.\n\n       Masionobe, L.  2003.  `Drawing an elliptical arc using\n       polylines, quadratic or cubic Bezier curves\n       <http://www.spaceroots.org/documents/ellipse/index.html>`_.\n    \"\"\"\n    halfpi = np.pi * 0.5\n    eta1 = theta1\n    eta2 = theta2 - 360 * np.floor((theta2 - theta1) / 360)\n    if theta2 != theta1 and eta2 <= eta1:\n        eta2 += 360\n    (eta1, eta2) = np.deg2rad([eta1, eta2])\n    if n is None:\n        n = int(2 ** np.ceil((eta2 - eta1) / halfpi))\n    if n < 1:\n        raise ValueError('n must be >= 1 or None')\n    deta = (eta2 - eta1) / n\n    t = np.tan(0.5 * deta)\n    alpha = np.sin(deta) * (np.sqrt(4.0 + 3.0 * t * t) - 1) / 3.0\n    steps = np.linspace(eta1, eta2, n + 1, True)\n    cos_eta = np.cos(steps)\n    sin_eta = np.sin(steps)\n    xA = cos_eta[:-1]\n    yA = sin_eta[:-1]\n    xA_dot = -yA\n    yA_dot = xA\n    xB = cos_eta[1:]\n    yB = sin_eta[1:]\n    xB_dot = -yB\n    yB_dot = xB\n    if is_wedge:\n        length = n * 3 + 4\n        vertices = np.zeros((length, 2), float)\n        codes = np.full(length, cls.CURVE4, dtype=cls.code_type)\n        vertices[1] = [xA[0], yA[0]]\n        codes[0:2] = [cls.MOVETO, cls.LINETO]\n        codes[-2:] = [cls.LINETO, cls.CLOSEPOLY]\n        vertex_offset = 2\n        end = length - 2\n    else:\n        length = n * 3 + 1\n        vertices = np.empty((length, 2), float)\n        codes = np.full(length, cls.CURVE4, dtype=cls.code_type)\n        vertices[0] = [xA[0], yA[0]]\n        codes[0] = cls.MOVETO\n        vertex_offset = 1\n        end = length\n    vertices[vertex_offset:end:3, 0] = xA + alpha * xA_dot\n    vertices[vertex_offset:end:3, 1] = yA + alpha * yA_dot\n    vertices[vertex_offset + 1:end:3, 0] = xB - alpha * xB_dot\n    vertices[vertex_offset + 1:end:3, 1] = yB - alpha * yB_dot\n    vertices[vertex_offset + 2:end:3, 0] = xB\n    vertices[vertex_offset + 2:end:3, 1] = yB\n    return cls(vertices, codes, readonly=True)",
                            "@classmethod\ndef wedge(cls, theta1, theta2, n=None):\n    \"\"\"\n    Return the unit circle wedge from angles *theta1* to *theta2* (in\n    degrees).\n\n    *theta2* is unwrapped to produce the shortest wedge within 360 degrees.\n    That is, if *theta2* > *theta1* + 360, the wedge will be from *theta1*\n    to *theta2* - 360 and not a full circle plus some extra overlap.\n\n    If *n* is provided, it is the number of spline segments to make.\n    If *n* is not provided, the number of spline segments is\n    determined based on the delta between *theta1* and *theta2*.\n\n    See `Path.arc` for the reference on the approximation used.\n    \"\"\"\n    return cls.arc(theta1, theta2, n, True)",
                            "@staticmethod\n@lru_cache(8)\ndef hatch(hatchpattern, density=6):\n    \"\"\"\n    Given a hatch specifier, *hatchpattern*, generates a Path that\n    can be used in a repeated hatching pattern.  *density* is the\n    number of lines per unit square.\n    \"\"\"\n    from matplotlib.hatch import get_path\n    return get_path(hatchpattern, density) if hatchpattern is not None else None",
                            "def clip_to_bbox(self, bbox, inside=True):\n    \"\"\"\n    Clip the path to the given bounding box.\n\n    The path must be made up of one or more closed polygons.  This\n    algorithm will not behave correctly for unclosed paths.\n\n    If *inside* is `True`, clip to the inside of the box, otherwise\n    to the outside of the box.\n    \"\"\"\n    verts = _path.clip_path_to_rect(self, bbox, inside)\n    paths = [Path(poly) for poly in verts]\n    return self.make_compound_path(*paths)"
                        ],
                        "constructor_variables": [
                            "self._vertices = vertices",
                            "self._codes = codes",
                            "self._interpolation_steps = _interpolation_steps",
                            "self._readonly = True",
                            "self._readonly = False"
                        ],
                        "class_level_variables": [
                            "code_type = np.uint8",
                            "STOP = code_type(0)",
                            "MOVETO = code_type(1)",
                            "LINETO = code_type(2)",
                            "CURVE3 = code_type(3)",
                            "CURVE4 = code_type(4)",
                            "CLOSEPOLY = code_type(79)",
                            "NUM_VERTICES_FOR_CODE = {STOP: 1, MOVETO: 1, LINETO: 1, CURVE3: 2, CURVE4: 3, CLOSEPOLY: 1}",
                            "copy = __copy__",
                            "deepcopy = __deepcopy__",
                            "_unit_rectangle = None",
                            "_unit_regular_polygons = WeakValueDictionary()",
                            "_unit_regular_stars = WeakValueDictionary()",
                            "_unit_circle = None",
                            "_unit_circle_righthalf = None"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "__init__(self, vertices, codes=None, _interpolation_steps=1, closed=False, readonly=False)",
                            "_fast_from_codes_and_verts(cls, verts, codes, internals_from=None)",
                            "_update_values(self)",
                            "vertices(self)",
                            "vertices(self, vertices)",
                            "codes(self)",
                            "codes(self, codes)",
                            "simplify_threshold(self)",
                            "simplify_threshold(self, threshold)",
                            "has_nonfinite(self)",
                            "should_simplify(self)",
                            "should_simplify(self, should_simplify)",
                            "readonly(self)",
                            "__copy__(self)",
                            "__deepcopy__(self, memo=None)",
                            "make_compound_path_from_polys(cls, XY)",
                            "make_compound_path(cls, *args)",
                            "__repr__(self)",
                            "__len__(self)",
                            "iter_segments(self, transform=None, remove_nans=True, clip=None, snap=False, stroke_width=1.0, simplify=None, curves=True, sketch=None)",
                            "cleaned(self, transform=None, remove_nans=False, clip=None, quantize=False, simplify=False, curves=False, stroke_width=1.0, snap=False, sketch=None)",
                            "transformed(self, transform)",
                            "contains_point(self, point, transform=None, radius=0.0)",
                            "contains_points(self, points, transform=None, radius=0.0)",
                            "contains_path(self, path, transform=None)",
                            "get_extents(self, transform=None)",
                            "intersects_path(self, other, filled=True)",
                            "intersects_bbox(self, bbox, filled=True)",
                            "interpolated(self, steps)",
                            "to_polygons(self, transform=None, width=0, height=0, closed_only=True)",
                            "unit_rectangle(cls)",
                            "unit_regular_polygon(cls, numVertices)",
                            "unit_regular_star(cls, numVertices, innerCircle=0.5)",
                            "unit_regular_asterisk(cls, numVertices)",
                            "unit_circle(cls)",
                            "circle(cls, center=(0.0, 0.0), radius=1.0, readonly=False)",
                            "unit_circle_righthalf(cls)",
                            "arc(cls, theta1, theta2, n=None, is_wedge=False)",
                            "wedge(cls, theta1, theta2, n=None)",
                            "hatch(hatchpattern, density=6)",
                            "clip_to_bbox(self, bbox, inside=True)"
                        ],
                        "class_level_variable_names": [
                            "code_type",
                            "STOP",
                            "MOVETO",
                            "LINETO",
                            "CURVE3",
                            "CURVE4",
                            "CLOSEPOLY",
                            "NUM_VERTICES_FOR_CODE",
                            "copy",
                            "deepcopy",
                            "_unit_rectangle",
                            "_unit_regular_polygons",
                            "_unit_regular_stars",
                            "_unit_circle",
                            "_unit_circle_righthalf"
                        ],
                        "constructor_variable_names": [
                            "vertices",
                            "_vertices",
                            "_codes",
                            "codes",
                            "_interpolation_steps",
                            "_readonly"
                        ]
                    },
                    "used_imports": [
                        "import numpy as np"
                    ],
                    "variable_values": [
                        [
                            {
                                "args": {
                                    "variable_value": "(Path(array([[0., 0.],\n       [0., 0.]]), array([1, 0], dtype=uint8)), Path(array([[0., 0.],\n       [0., 0.]]), array([1, 0], dtype=uint8)), Path(array([[0., 0.],\n       [0., 0.]]), array([1, 0], dtype=uint8)))",
                                    "variable_type": "tuple",
                                    "variable_shape": "3"
                                },
                                "Path": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.empty": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.float32": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "vertices": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.concatenate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "x.vertices": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "x": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "codes": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls.code_type": {
                                    "variable_value": "<class 'numpy.uint8'>",
                                    "variable_type": "type",
                                    "variable_shape": "<attribute 'shape' of 'numpy.generic' objects>"
                                },
                                "cls": {
                                    "variable_value": "<class 'matplotlib.path.Path'>",
                                    "variable_type": "type",
                                    "variable_shape": null
                                },
                                "i": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "path": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "path.codes": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls.MOVETO": {
                                    "variable_value": "1",
                                    "variable_type": "uint8",
                                    "variable_shape": "()"
                                },
                                "path.vertices": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls.LINETO": {
                                    "variable_value": "2",
                                    "variable_type": "uint8",
                                    "variable_shape": "()"
                                }
                            },
                            {
                                "args": {
                                    "variable_value": "(Path(array([[0., 0.],\n       [0., 0.]]), array([1, 0], dtype=uint8)), Path(array([[0., 0.],\n       [0., 0.]]), array([1, 0], dtype=uint8)), Path(array([[0., 0.],\n       [0., 0.]]), array([1, 0], dtype=uint8)))",
                                    "variable_type": "tuple",
                                    "variable_shape": "3"
                                },
                                "Path": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.empty": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.float32": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "vertices": {
                                    "variable_value": "array([[0., 0.],\n       [0., 0.],\n       [0., 0.],\n       [0., 0.],\n       [0., 0.],\n       [0., 0.]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(6, 2)"
                                },
                                "np.concatenate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "x.vertices": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "x": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "codes": {
                                    "variable_value": "array([1, 0, 1, 0, 1, 0], dtype=uint8)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(6,)"
                                },
                                "cls.code_type": {
                                    "variable_value": "<class 'numpy.uint8'>",
                                    "variable_type": "type",
                                    "variable_shape": "<attribute 'shape' of 'numpy.generic' objects>"
                                },
                                "cls": {
                                    "variable_value": "<class 'matplotlib.path.Path'>",
                                    "variable_type": "type",
                                    "variable_shape": null
                                },
                                "i": {
                                    "variable_value": "6",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "path": {
                                    "variable_value": "Path(array([[0., 0.],\n       [0., 0.]]), array([1, 0], dtype=uint8))",
                                    "variable_type": "Path",
                                    "variable_shape": null
                                },
                                "path.codes": {
                                    "variable_value": "array([1, 0], dtype=uint8)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2,)"
                                },
                                "cls.MOVETO": {
                                    "variable_value": "1",
                                    "variable_type": "uint8",
                                    "variable_shape": "()"
                                },
                                "path.vertices": {
                                    "variable_value": "array([[0., 0.],\n       [0., 0.]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2)"
                                },
                                "cls.LINETO": {
                                    "variable_value": "2",
                                    "variable_type": "uint8",
                                    "variable_shape": "()"
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "args": {
                                    "variable_value": "(Path(array([[0., 0.],\n       [0., 0.]]), array([1, 0], dtype=uint8)), Path(array([[0., 0.],\n       [0., 0.]]), array([1, 0], dtype=uint8)), Path(array([[0., 0.],\n       [0., 0.]]), array([1, 0], dtype=uint8)))",
                                    "variable_type": "tuple",
                                    "variable_shape": "3"
                                },
                                "Path": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.empty": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.float32": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "vertices": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.concatenate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "x.vertices": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "x": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "codes": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls.code_type": {
                                    "variable_value": "<class 'numpy.uint8'>",
                                    "variable_type": "type",
                                    "variable_shape": "<attribute 'shape' of 'numpy.generic' objects>"
                                },
                                "cls": {
                                    "variable_value": "<class 'matplotlib.path.Path'>",
                                    "variable_type": "type",
                                    "variable_shape": null
                                },
                                "i": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "path": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "path.codes": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls.MOVETO": {
                                    "variable_value": "1",
                                    "variable_type": "uint8",
                                    "variable_shape": "()"
                                },
                                "path.vertices": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls.LINETO": {
                                    "variable_value": "2",
                                    "variable_type": "uint8",
                                    "variable_shape": "()"
                                },
                                "last_vert": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "codes.size": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls.STOP": {
                                    "variable_value": "0",
                                    "variable_type": "uint8",
                                    "variable_shape": "()"
                                },
                                "np.append": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "args": {
                                    "variable_value": "(Path(array([[0., 0.],\n       [0., 0.]]), array([1, 0], dtype=uint8)), Path(array([[0., 0.],\n       [0., 0.]]), array([1, 0], dtype=uint8)), Path(array([[0., 0.],\n       [0., 0.]]), array([1, 0], dtype=uint8)))",
                                    "variable_type": "tuple",
                                    "variable_shape": "3"
                                },
                                "Path": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.empty": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.float32": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "vertices": {
                                    "variable_value": "array([[0., 0.],\n       [0., 0.],\n       [0., 0.],\n       [0., 0.]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(4, 2)"
                                },
                                "np.concatenate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "x.vertices": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "x": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "codes": {
                                    "variable_value": "array([1, 1, 1, 0], dtype=uint8)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(4,)"
                                },
                                "cls.code_type": {
                                    "variable_value": "<class 'numpy.uint8'>",
                                    "variable_type": "type",
                                    "variable_shape": "<attribute 'shape' of 'numpy.generic' objects>"
                                },
                                "cls": {
                                    "variable_value": "<class 'matplotlib.path.Path'>",
                                    "variable_type": "type",
                                    "variable_shape": null
                                },
                                "i": {
                                    "variable_value": "6",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "path": {
                                    "variable_value": "Path(array([[0., 0.],\n       [0., 0.]]), array([1, 0], dtype=uint8))",
                                    "variable_type": "Path",
                                    "variable_shape": null
                                },
                                "path.codes": {
                                    "variable_value": "array([1, 0], dtype=uint8)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2,)"
                                },
                                "cls.MOVETO": {
                                    "variable_value": "1",
                                    "variable_type": "uint8",
                                    "variable_shape": "()"
                                },
                                "path.vertices": {
                                    "variable_value": "array([[0., 0.],\n       [0., 0.]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2, 2)"
                                },
                                "cls.LINETO": {
                                    "variable_value": "2",
                                    "variable_type": "uint8",
                                    "variable_shape": "()"
                                },
                                "last_vert": {
                                    "variable_value": "array([0., 0.])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2,)"
                                },
                                "codes.size": {
                                    "variable_value": "4",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "cls.STOP": {
                                    "variable_value": "0",
                                    "variable_type": "uint8",
                                    "variable_shape": "()"
                                },
                                "np.append": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def get_path_collection_extents(\n        master_transform, paths, transforms, offsets, offset_transform):\n    r\"\"\"\n    Given a sequence of `Path`\\s, `~.Transform`\\s objects, and offsets, as\n    found in a `~.PathCollection`, returns the bounding box that encapsulates\n    all of them.\n\n    Parameters\n    ----------\n    master_transform : `~.Transform`\n        Global transformation applied to all paths.\n    paths : list of `Path`\n    transform : list of `~.Affine2D`\n    offsets : (N, 2) array-like\n    offset_transform : `~.Affine2D`\n        Transform applied to the offsets before offsetting the path.\n\n    Notes\n    -----\n    The way that *paths*, *transforms* and *offsets* are combined\n    follows the same method as for collections:  Each is iterated over\n    independently, so if you have 3 paths, 2 transforms and 1 offset,\n    their combinations are as follows:\n\n        (A, A, A), (B, B, A), (C, A, A)\n    \"\"\"\n    from .transforms import Bbox\n    if len(paths) == 0:\n        raise ValueError(\"No paths provided\")\n    return Bbox.from_extents(*_path.get_path_collection_extents(\n        master_transform, paths, np.atleast_3d(transforms),\n        offsets, offset_transform))",
                "def __init__(self, vertices, codes=None, _interpolation_steps=1,\n             closed=False, readonly=False):\n    \"\"\"\n    Create a new path with the given vertices and codes.\n\n    Parameters\n    ----------\n    vertices : array-like\n        The ``(N, 2)`` float array, masked array or sequence of pairs\n        representing the vertices of the path.\n\n        If *vertices* contains masked values, they will be converted\n        to NaNs which are then handled correctly by the Agg\n        PathIterator and other consumers of path data, such as\n        :meth:`iter_segments`.\n    codes : array-like or None, optional\n        n-length array integers representing the codes of the path.\n        If not None, codes must be the same length as vertices.\n        If None, *vertices* will be treated as a series of line segments.\n    _interpolation_steps : int, optional\n        Used as a hint to certain projections, such as Polar, that this\n        path should be linearly interpolated immediately before drawing.\n        This attribute is primarily an implementation detail and is not\n        intended for public use.\n    closed : bool, optional\n        If *codes* is None and closed is True, vertices will be treated as\n        line segments of a closed polygon.  Note that the last vertex will\n        then be ignored (as the corresponding code will be set to\n        CLOSEPOLY).\n    readonly : bool, optional\n        Makes the path behave in an immutable way and sets the vertices\n        and codes as read-only arrays.\n    \"\"\"\n    vertices = _to_unmasked_float_array(vertices)\n    if vertices.ndim != 2 or vertices.shape[1] != 2:\n        raise ValueError(\n            \"'vertices' must be a 2D list or array with shape Nx2\")\n\n    if codes is not None:\n        codes = np.asarray(codes, self.code_type)\n        if codes.ndim != 1 or len(codes) != len(vertices):\n            raise ValueError(\"'codes' must be a 1D list or array with the \"\n                             \"same length of 'vertices'\")\n        if len(codes) and codes[0] != self.MOVETO:\n            raise ValueError(\"The first element of 'code' must be equal \"\n                             \"to 'MOVETO' ({})\".format(self.MOVETO))\n    elif closed and len(vertices):\n        codes = np.empty(len(vertices), dtype=self.code_type)\n        codes[0] = self.MOVETO\n        codes[1:-1] = self.LINETO\n        codes[-1] = self.CLOSEPOLY\n\n    self._vertices = vertices\n    self._codes = codes\n    self._interpolation_steps = _interpolation_steps\n    self._update_values()\n\n    if readonly:\n        self._vertices.flags.writeable = False\n        if self._codes is not None:\n            self._codes.flags.writeable = False\n        self._readonly = True\n    else:\n        self._readonly = False",
                "@classmethod\ndef _fast_from_codes_and_verts(cls, verts, codes, internals_from=None):\n    \"\"\"\n    Creates a Path instance without the expense of calling the constructor.\n\n    Parameters\n    ----------\n    verts : numpy array\n    codes : numpy array\n    internals_from : Path or None\n        If not None, another `Path` from which the attributes\n        ``should_simplify``, ``simplify_threshold``, and\n        ``interpolation_steps`` will be copied.  Note that ``readonly`` is\n        never copied, and always set to ``False`` by this constructor.\n    \"\"\"\n    pth = cls.__new__(cls)\n    pth._vertices = _to_unmasked_float_array(verts)\n    pth._codes = codes\n    pth._readonly = False\n    if internals_from is not None:\n        pth._should_simplify = internals_from._should_simplify\n        pth._simplify_threshold = internals_from._simplify_threshold\n        pth._interpolation_steps = internals_from._interpolation_steps\n    else:\n        pth._should_simplify = True\n        pth._simplify_threshold = mpl.rcParams['path.simplify_threshold']\n        pth._interpolation_steps = 1\n    return pth",
                "def _update_values(self):\n    self._simplify_threshold = mpl.rcParams['path.simplify_threshold']\n    self._should_simplify = (\n        self._simplify_threshold > 0 and\n        mpl.rcParams['path.simplify'] and\n        len(self._vertices) >= 128 and\n        (self._codes is None or np.all(self._codes <= Path.LINETO))\n    )",
                "@property\ndef vertices(self):\n    \"\"\"\n    The list of vertices in the `Path` as an Nx2 numpy array.\n    \"\"\"\n    return self._vertices",
                "@vertices.setter\ndef vertices(self, vertices):\n    if self._readonly:\n        raise AttributeError(\"Can't set vertices on a readonly Path\")\n    self._vertices = vertices\n    self._update_values()",
                "@property\ndef codes(self):\n    \"\"\"\n    The list of codes in the `Path` as a 1-D numpy array.  Each\n    code is one of `STOP`, `MOVETO`, `LINETO`, `CURVE3`, `CURVE4`\n    or `CLOSEPOLY`.  For codes that correspond to more than one\n    vertex (`CURVE3` and `CURVE4`), that code will be repeated so\n    that the length of `self.vertices` and `self.codes` is always\n    the same.\n    \"\"\"\n    return self._codes",
                "@codes.setter\ndef codes(self, codes):\n    if self._readonly:\n        raise AttributeError(\"Can't set codes on a readonly Path\")\n    self._codes = codes\n    self._update_values()",
                "@property\ndef simplify_threshold(self):\n    \"\"\"\n    The fraction of a pixel difference below which vertices will\n    be simplified out.\n    \"\"\"\n    return self._simplify_threshold",
                "@simplify_threshold.setter\ndef simplify_threshold(self, threshold):\n    self._simplify_threshold = threshold",
                "@cbook.deprecated(\n    \"3.1\", alternative=\"not np.isfinite(self.vertices).all()\")\n@property\ndef has_nonfinite(self):\n    \"\"\"\n    `True` if the vertices array has nonfinite values.\n    \"\"\"\n    return not np.isfinite(self._vertices).all()",
                "@property\ndef should_simplify(self):\n    \"\"\"\n    `True` if the vertices array should be simplified.\n    \"\"\"\n    return self._should_simplify",
                "@should_simplify.setter\ndef should_simplify(self, should_simplify):\n    self._should_simplify = should_simplify",
                "@property\ndef readonly(self):\n    \"\"\"\n    `True` if the `Path` is read-only.\n    \"\"\"\n    return self._readonly",
                "def __copy__(self):\n    \"\"\"\n    Returns a shallow copy of the `Path`, which will share the\n    vertices and codes with the source `Path`.\n    \"\"\"\n    import copy\n    return copy.copy(self)",
                "def __deepcopy__(self, memo=None):\n    \"\"\"\n    Returns a deepcopy of the `Path`.  The `Path` will not be\n    readonly, even if the source `Path` is.\n    \"\"\"\n    try:\n        codes = self.codes.copy()\n    except AttributeError:\n        codes = None\n    return self.__class__(\n        self.vertices.copy(), codes,\n        _interpolation_steps=self._interpolation_steps)",
                "@classmethod\ndef make_compound_path_from_polys(cls, XY):\n    \"\"\"\n    Make a compound path object to draw a number\n    of polygons with equal numbers of sides XY is a (numpolys x\n    numsides x 2) numpy array of vertices.  Return object is a\n    :class:`Path`\n\n    .. plot:: gallery/misc/histogram_path.py\n\n    \"\"\"\n\n    # for each poly: 1 for the MOVETO, (numsides-1) for the LINETO, 1 for\n    # the CLOSEPOLY; the vert for the closepoly is ignored but we still\n    # need it to keep the codes aligned with the vertices\n    numpolys, numsides, two = XY.shape\n    if two != 2:\n        raise ValueError(\"The third dimension of 'XY' must be 2\")\n    stride = numsides + 1\n    nverts = numpolys * stride\n    verts = np.zeros((nverts, 2))\n    codes = np.full(nverts, cls.LINETO, dtype=cls.code_type)\n    codes[0::stride] = cls.MOVETO\n    codes[numsides::stride] = cls.CLOSEPOLY\n    for i in range(numsides):\n        verts[i::stride] = XY[:, i]\n\n    return cls(verts, codes)",
                "@classmethod\ndef make_compound_path(cls, *args):\n    \"\"\"Make a compound path from a list of Path objects.\"\"\"\n    # Handle an empty list in args (i.e. no args).\n    if not args:\n        return Path(np.empty([0, 2], dtype=np.float32))\n\n    vertices = np.concatenate([x.vertices for x in args])\n    codes = np.empty(len(vertices), dtype=cls.code_type)\n    i = 0\n    for path in args:\n        if path.codes is None:\n            codes[i] = cls.MOVETO\n            codes[i + 1:i + len(path.vertices)] = cls.LINETO\n        else:\n            codes[i:i + len(path.codes)] = path.codes\n        i += len(path.vertices)\n\n    return cls(vertices, codes)",
                "def __repr__(self):\n    return \"Path(%r, %r)\" % (self.vertices, self.codes)",
                "def __len__(self):\n    return len(self.vertices)",
                "def iter_segments(self, transform=None, remove_nans=True, clip=None,\n                  snap=False, stroke_width=1.0, simplify=None,\n                  curves=True, sketch=None):\n    \"\"\"\n    Iterates over all of the curve segments in the path.  Each iteration\n    returns a 2-tuple ``(vertices, code)``, where ``vertices`` is a\n    sequence of 1-3 coordinate pairs, and ``code`` is a `Path` code.\n\n    Additionally, this method can provide a number of standard cleanups and\n    conversions to the path.\n\n    Parameters\n    ----------\n    transform : None or :class:`~matplotlib.transforms.Transform`\n        If not None, the given affine transformation will be applied to the\n        path.\n    remove_nans : bool, optional\n        Whether to remove all NaNs from the path and skip over them using\n        MOVETO commands.\n    clip : None or (float, float, float, float), optional\n        If not None, must be a four-tuple (x1, y1, x2, y2)\n        defining a rectangle in which to clip the path.\n    snap : None or bool, optional\n        If True, snap all nodes to pixels; if False, don't snap them.\n        If None, perform snapping if the path contains only segments\n        parallel to the x or y axes, and no more than 1024 of them.\n    stroke_width : float, optional\n        The width of the stroke being drawn (used for path snapping).\n    simplify : None or bool, optional\n        Whether to simplify the path by removing vertices\n        that do not affect its appearance.  If None, use the\n        :attr:`should_simplify` attribute.  See also :rc:`path.simplify`\n        and :rc:`path.simplify_threshold`.\n    curves : bool, optional\n        If True, curve segments will be returned as curve segments.\n        If False, all curves will be converted to line segments.\n    sketch : None or sequence, optional\n        If not None, must be a 3-tuple of the form\n        (scale, length, randomness), representing the sketch parameters.\n    \"\"\"\n    if not len(self):\n        return\n\n    cleaned = self.cleaned(transform=transform,\n                           remove_nans=remove_nans, clip=clip,\n                           snap=snap, stroke_width=stroke_width,\n                           simplify=simplify, curves=curves,\n                           sketch=sketch)\n\n    # Cache these object lookups for performance in the loop.\n    NUM_VERTICES_FOR_CODE = self.NUM_VERTICES_FOR_CODE\n    STOP = self.STOP\n\n    vertices = iter(cleaned.vertices)\n    codes = iter(cleaned.codes)\n    for curr_vertices, code in zip(vertices, codes):\n        if code == STOP:\n            break\n        extra_vertices = NUM_VERTICES_FOR_CODE[code] - 1\n        if extra_vertices:\n            for i in range(extra_vertices):\n                next(codes)\n                curr_vertices = np.append(curr_vertices, next(vertices))\n        yield curr_vertices, code",
                "@cbook._delete_parameter(\"3.3\", \"quantize\")\ndef cleaned(self, transform=None, remove_nans=False, clip=None,\n            quantize=False, simplify=False, curves=False,\n            stroke_width=1.0, snap=False, sketch=None):\n    \"\"\"\n    Return a new Path with vertices and codes cleaned according to the\n    parameters.\n\n    See Also\n    --------\n    Path.iter_segments : for details of the keyword arguments.\n    \"\"\"\n    vertices, codes = _path.cleanup_path(\n        self, transform, remove_nans, clip, snap, stroke_width, simplify,\n        curves, sketch)\n    pth = Path._fast_from_codes_and_verts(vertices, codes, self)\n    if not simplify:\n        pth._should_simplify = False\n    return pth",
                "def transformed(self, transform):\n    \"\"\"\n    Return a transformed copy of the path.\n\n    See Also\n    --------\n    matplotlib.transforms.TransformedPath\n        A specialized path class that will cache the transformed result and\n        automatically update when the transform changes.\n    \"\"\"\n    return Path(transform.transform(self.vertices), self.codes,\n                self._interpolation_steps)",
                "def contains_point(self, point, transform=None, radius=0.0):\n    \"\"\"\n    Return whether the (closed) path contains the given point.\n\n    Parameters\n    ----------\n    point : (float, float)\n        The point (x, y) to check.\n    transform : `matplotlib.transforms.Transform`, optional\n        If not ``None``, *point* will be compared to ``self`` transformed\n        by *transform*; i.e. for a correct check, *transform* should\n        transform the path into the coordinate system of *point*.\n    radius : float, default: 0\n        Add an additional margin on the path in coordinates of *point*.\n        The path is extended tangentially by *radius/2*; i.e. if you would\n        draw the path with a linewidth of *radius*, all points on the line\n        would still be considered to be contained in the area. Conversely,\n        negative values shrink the area: Points on the imaginary line\n        will be considered outside the area.\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    if transform is not None:\n        transform = transform.frozen()\n    # `point_in_path` does not handle nonlinear transforms, so we\n    # transform the path ourselves.  If *transform* is affine, letting\n    # `point_in_path` handle the transform avoids allocating an extra\n    # buffer.\n    if transform and not transform.is_affine:\n        self = transform.transform_path(self)\n        transform = None\n    return _path.point_in_path(point[0], point[1], radius, self, transform)",
                "def contains_points(self, points, transform=None, radius=0.0):\n    \"\"\"\n    Return whether the (closed) path contains the given point.\n\n    Parameters\n    ----------\n    points : (N, 2) array\n        The points to check. Columns contain x and y values.\n    transform : `matplotlib.transforms.Transform`, optional\n        If not ``None``, *points* will be compared to ``self`` transformed\n        by *transform*; i.e. for a correct check, *transform* should\n        transform the path into the coordinate system of *points*.\n    radius : float, default: 0.\n        Add an additional margin on the path in coordinates of *points*.\n        The path is extended tangentially by *radius/2*; i.e. if you would\n        draw the path with a linewidth of *radius*, all points on the line\n        would still be considered to be contained in the area. Conversely,\n        negative values shrink the area: Points on the imaginary line\n        will be considered outside the area.\n\n    Returns\n    -------\n    length-N bool array\n    \"\"\"\n    if transform is not None:\n        transform = transform.frozen()\n    result = _path.points_in_path(points, radius, self, transform)\n    return result.astype('bool')",
                "def contains_path(self, path, transform=None):\n    \"\"\"\n    Returns whether this (closed) path completely contains the given path.\n\n    If *transform* is not ``None``, the path will be transformed before\n    performing the test.\n    \"\"\"\n    if transform is not None:\n        transform = transform.frozen()\n    return _path.path_in_path(self, None, path, transform)",
                "def get_extents(self, transform=None):\n    \"\"\"\n    Returns the extents (*xmin*, *ymin*, *xmax*, *ymax*) of the path.\n\n    Unlike computing the extents on the *vertices* alone, this\n    algorithm will take into account the curves and deal with\n    control points appropriately.\n    \"\"\"\n    from .transforms import Bbox\n    path = self\n    if transform is not None:\n        transform = transform.frozen()\n        if not transform.is_affine:\n            path = self.transformed(transform)\n            transform = None\n    return Bbox(_path.get_path_extents(path, transform))",
                "def intersects_path(self, other, filled=True):\n    \"\"\"\n    Returns *True* if this path intersects another given path.\n\n    *filled*, when True, treats the paths as if they were filled.\n    That is, if one path completely encloses the other,\n    :meth:`intersects_path` will return True.\n    \"\"\"\n    return _path.path_intersects_path(self, other, filled)",
                "def intersects_bbox(self, bbox, filled=True):\n    \"\"\"\n    Returns whether this path intersects a given `~.transforms.Bbox`.\n\n    *filled*, when True, treats the path as if it was filled.\n    That is, if the path completely encloses the bounding box,\n    :meth:`intersects_bbox` will return True.\n\n    The bounding box is always considered filled.\n    \"\"\"\n    return _path.path_intersects_rectangle(\n        self, bbox.x0, bbox.y0, bbox.x1, bbox.y1, filled)",
                "def interpolated(self, steps):\n    \"\"\"\n    Returns a new path resampled to length N x steps.  Does not\n    currently handle interpolating curves.\n    \"\"\"\n    if steps == 1:\n        return self\n\n    vertices = simple_linear_interpolation(self.vertices, steps)\n    codes = self.codes\n    if codes is not None:\n        new_codes = np.full((len(codes) - 1) * steps + 1, Path.LINETO,\n                            dtype=self.code_type)\n        new_codes[0::steps] = codes\n    else:\n        new_codes = None\n    return Path(vertices, new_codes)",
                "def to_polygons(self, transform=None, width=0, height=0, closed_only=True):\n    \"\"\"\n    Convert this path to a list of polygons or polylines.  Each\n    polygon/polyline is an Nx2 array of vertices.  In other words,\n    each polygon has no ``MOVETO`` instructions or curves.  This\n    is useful for displaying in backends that do not support\n    compound paths or Bezier curves.\n\n    If *width* and *height* are both non-zero then the lines will\n    be simplified so that vertices outside of (0, 0), (width,\n    height) will be clipped.\n\n    If *closed_only* is `True` (default), only closed polygons,\n    with the last point being the same as the first point, will be\n    returned.  Any unclosed polylines in the path will be\n    explicitly closed.  If *closed_only* is `False`, any unclosed\n    polygons in the path will be returned as unclosed polygons,\n    and the closed polygons will be returned explicitly closed by\n    setting the last point to the same as the first point.\n    \"\"\"\n    if len(self.vertices) == 0:\n        return []\n\n    if transform is not None:\n        transform = transform.frozen()\n\n    if self.codes is None and (width == 0 or height == 0):\n        vertices = self.vertices\n        if closed_only:\n            if len(vertices) < 3:\n                return []\n            elif np.any(vertices[0] != vertices[-1]):\n                vertices = [*vertices, vertices[0]]\n\n        if transform is None:\n            return [vertices]\n        else:\n            return [transform.transform(vertices)]\n\n    # Deal with the case where there are curves and/or multiple\n    # subpaths (using extension code)\n    return _path.convert_path_to_polygons(\n        self, transform, width, height, closed_only)",
                "@classmethod\ndef unit_rectangle(cls):\n    \"\"\"\n    Return a `Path` instance of the unit rectangle from (0, 0) to (1, 1).\n    \"\"\"\n    if cls._unit_rectangle is None:\n        cls._unit_rectangle = cls([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]],\n                                  closed=True, readonly=True)\n    return cls._unit_rectangle",
                "@classmethod\ndef unit_regular_polygon(cls, numVertices):\n    \"\"\"\n    Return a :class:`Path` instance for a unit regular polygon with the\n    given *numVertices* and radius of 1.0, centered at (0, 0).\n    \"\"\"\n    if numVertices <= 16:\n        path = cls._unit_regular_polygons.get(numVertices)\n    else:\n        path = None\n    if path is None:\n        theta = ((2 * np.pi / numVertices) * np.arange(numVertices + 1)\n                 # This initial rotation is to make sure the polygon always\n                 # \"points-up\".\n                 + np.pi / 2)\n        verts = np.column_stack((np.cos(theta), np.sin(theta)))\n        path = cls(verts, closed=True, readonly=True)\n        if numVertices <= 16:\n            cls._unit_regular_polygons[numVertices] = path\n    return path",
                "@classmethod\ndef unit_regular_star(cls, numVertices, innerCircle=0.5):\n    \"\"\"\n    Return a :class:`Path` for a unit regular star with the given\n    numVertices and radius of 1.0, centered at (0, 0).\n    \"\"\"\n    if numVertices <= 16:\n        path = cls._unit_regular_stars.get((numVertices, innerCircle))\n    else:\n        path = None\n    if path is None:\n        ns2 = numVertices * 2\n        theta = (2*np.pi/ns2 * np.arange(ns2 + 1))\n        # This initial rotation is to make sure the polygon always\n        # \"points-up\"\n        theta += np.pi / 2.0\n        r = np.ones(ns2 + 1)\n        r[1::2] = innerCircle\n        verts = (r * np.vstack((np.cos(theta), np.sin(theta)))).T\n        path = cls(verts, closed=True, readonly=True)\n        if numVertices <= 16:\n            cls._unit_regular_stars[(numVertices, innerCircle)] = path\n    return path",
                "@classmethod\ndef unit_regular_asterisk(cls, numVertices):\n    \"\"\"\n    Return a :class:`Path` for a unit regular asterisk with the given\n    numVertices and radius of 1.0, centered at (0, 0).\n    \"\"\"\n    return cls.unit_regular_star(numVertices, 0.0)",
                "@classmethod\ndef unit_circle(cls):\n    \"\"\"\n    Return the readonly :class:`Path` of the unit circle.\n\n    For most cases, :func:`Path.circle` will be what you want.\n    \"\"\"\n    if cls._unit_circle is None:\n        cls._unit_circle = cls.circle(center=(0, 0), radius=1,\n                                      readonly=True)\n    return cls._unit_circle",
                "@classmethod\ndef circle(cls, center=(0., 0.), radius=1., readonly=False):\n    \"\"\"\n    Return a `Path` representing a circle of a given radius and center.\n\n    Parameters\n    ----------\n    center : (float, float), default: (0, 0)\n        The center of the circle.\n    radius : float, default: 1\n        The radius of the circle.\n    readonly : bool\n        Whether the created path should have the \"readonly\" argument\n        set when creating the Path instance.\n\n    Notes\n    -----\n    The circle is approximated using 8 cubic Bezier curves, as described in\n\n      Lancaster, Don.  `Approximating a Circle or an Ellipse Using Four\n      Bezier Cubic Splines <http://www.tinaja.com/glib/ellipse4.pdf>`_.\n    \"\"\"\n    MAGIC = 0.2652031\n    SQRTHALF = np.sqrt(0.5)\n    MAGIC45 = SQRTHALF * MAGIC\n\n    vertices = np.array([[0.0, -1.0],\n\n                         [MAGIC, -1.0],\n                         [SQRTHALF-MAGIC45, -SQRTHALF-MAGIC45],\n                         [SQRTHALF, -SQRTHALF],\n\n                         [SQRTHALF+MAGIC45, -SQRTHALF+MAGIC45],\n                         [1.0, -MAGIC],\n                         [1.0, 0.0],\n\n                         [1.0, MAGIC],\n                         [SQRTHALF+MAGIC45, SQRTHALF-MAGIC45],\n                         [SQRTHALF, SQRTHALF],\n\n                         [SQRTHALF-MAGIC45, SQRTHALF+MAGIC45],\n                         [MAGIC, 1.0],\n                         [0.0, 1.0],\n\n                         [-MAGIC, 1.0],\n                         [-SQRTHALF+MAGIC45, SQRTHALF+MAGIC45],\n                         [-SQRTHALF, SQRTHALF],\n\n                         [-SQRTHALF-MAGIC45, SQRTHALF-MAGIC45],\n                         [-1.0, MAGIC],\n                         [-1.0, 0.0],\n\n                         [-1.0, -MAGIC],\n                         [-SQRTHALF-MAGIC45, -SQRTHALF+MAGIC45],\n                         [-SQRTHALF, -SQRTHALF],\n\n                         [-SQRTHALF+MAGIC45, -SQRTHALF-MAGIC45],\n                         [-MAGIC, -1.0],\n                         [0.0, -1.0],\n\n                         [0.0, -1.0]],\n                        dtype=float)\n\n    codes = [cls.CURVE4] * 26\n    codes[0] = cls.MOVETO\n    codes[-1] = cls.CLOSEPOLY\n    return Path(vertices * radius + center, codes, readonly=readonly)",
                "@classmethod\ndef unit_circle_righthalf(cls):\n    \"\"\"\n    Return a `Path` of the right half of a unit circle.\n\n    See `Path.circle` for the reference on the approximation used.\n    \"\"\"\n    if cls._unit_circle_righthalf is None:\n        MAGIC = 0.2652031\n        SQRTHALF = np.sqrt(0.5)\n        MAGIC45 = SQRTHALF * MAGIC\n\n        vertices = np.array(\n            [[0.0, -1.0],\n\n             [MAGIC, -1.0],\n             [SQRTHALF-MAGIC45, -SQRTHALF-MAGIC45],\n             [SQRTHALF, -SQRTHALF],\n\n             [SQRTHALF+MAGIC45, -SQRTHALF+MAGIC45],\n             [1.0, -MAGIC],\n             [1.0, 0.0],\n\n             [1.0, MAGIC],\n             [SQRTHALF+MAGIC45, SQRTHALF-MAGIC45],\n             [SQRTHALF, SQRTHALF],\n\n             [SQRTHALF-MAGIC45, SQRTHALF+MAGIC45],\n             [MAGIC, 1.0],\n             [0.0, 1.0],\n\n             [0.0, -1.0]],\n\n            float)\n\n        codes = np.full(14, cls.CURVE4, dtype=cls.code_type)\n        codes[0] = cls.MOVETO\n        codes[-1] = cls.CLOSEPOLY\n\n        cls._unit_circle_righthalf = cls(vertices, codes, readonly=True)\n    return cls._unit_circle_righthalf",
                "@classmethod\ndef arc(cls, theta1, theta2, n=None, is_wedge=False):\n    \"\"\"\n    Return the unit circle arc from angles *theta1* to *theta2* (in\n    degrees).\n\n    *theta2* is unwrapped to produce the shortest arc within 360 degrees.\n    That is, if *theta2* > *theta1* + 360, the arc will be from *theta1* to\n    *theta2* - 360 and not a full circle plus some extra overlap.\n\n    If *n* is provided, it is the number of spline segments to make.\n    If *n* is not provided, the number of spline segments is\n    determined based on the delta between *theta1* and *theta2*.\n\n       Masionobe, L.  2003.  `Drawing an elliptical arc using\n       polylines, quadratic or cubic Bezier curves\n       <http://www.spaceroots.org/documents/ellipse/index.html>`_.\n    \"\"\"\n    halfpi = np.pi * 0.5\n\n    eta1 = theta1\n    eta2 = theta2 - 360 * np.floor((theta2 - theta1) / 360)\n    # Ensure 2pi range is not flattened to 0 due to floating-point errors,\n    # but don't try to expand existing 0 range.\n    if theta2 != theta1 and eta2 <= eta1:\n        eta2 += 360\n    eta1, eta2 = np.deg2rad([eta1, eta2])\n\n    # number of curve segments to make\n    if n is None:\n        n = int(2 ** np.ceil((eta2 - eta1) / halfpi))\n    if n < 1:\n        raise ValueError(\"n must be >= 1 or None\")\n\n    deta = (eta2 - eta1) / n\n    t = np.tan(0.5 * deta)\n    alpha = np.sin(deta) * (np.sqrt(4.0 + 3.0 * t * t) - 1) / 3.0\n\n    steps = np.linspace(eta1, eta2, n + 1, True)\n    cos_eta = np.cos(steps)\n    sin_eta = np.sin(steps)\n\n    xA = cos_eta[:-1]\n    yA = sin_eta[:-1]\n    xA_dot = -yA\n    yA_dot = xA\n\n    xB = cos_eta[1:]\n    yB = sin_eta[1:]\n    xB_dot = -yB\n    yB_dot = xB\n\n    if is_wedge:\n        length = n * 3 + 4\n        vertices = np.zeros((length, 2), float)\n        codes = np.full(length, cls.CURVE4, dtype=cls.code_type)\n        vertices[1] = [xA[0], yA[0]]\n        codes[0:2] = [cls.MOVETO, cls.LINETO]\n        codes[-2:] = [cls.LINETO, cls.CLOSEPOLY]\n        vertex_offset = 2\n        end = length - 2\n    else:\n        length = n * 3 + 1\n        vertices = np.empty((length, 2), float)\n        codes = np.full(length, cls.CURVE4, dtype=cls.code_type)\n        vertices[0] = [xA[0], yA[0]]\n        codes[0] = cls.MOVETO\n        vertex_offset = 1\n        end = length\n\n    vertices[vertex_offset:end:3, 0] = xA + alpha * xA_dot\n    vertices[vertex_offset:end:3, 1] = yA + alpha * yA_dot\n    vertices[vertex_offset+1:end:3, 0] = xB - alpha * xB_dot\n    vertices[vertex_offset+1:end:3, 1] = yB - alpha * yB_dot\n    vertices[vertex_offset+2:end:3, 0] = xB\n    vertices[vertex_offset+2:end:3, 1] = yB\n\n    return cls(vertices, codes, readonly=True)",
                "@classmethod\ndef wedge(cls, theta1, theta2, n=None):\n    \"\"\"\n    Return the unit circle wedge from angles *theta1* to *theta2* (in\n    degrees).\n\n    *theta2* is unwrapped to produce the shortest wedge within 360 degrees.\n    That is, if *theta2* > *theta1* + 360, the wedge will be from *theta1*\n    to *theta2* - 360 and not a full circle plus some extra overlap.\n\n    If *n* is provided, it is the number of spline segments to make.\n    If *n* is not provided, the number of spline segments is\n    determined based on the delta between *theta1* and *theta2*.\n\n    See `Path.arc` for the reference on the approximation used.\n    \"\"\"\n    return cls.arc(theta1, theta2, n, True)",
                "@staticmethod\n@lru_cache(8)\ndef hatch(hatchpattern, density=6):\n    \"\"\"\n    Given a hatch specifier, *hatchpattern*, generates a Path that\n    can be used in a repeated hatching pattern.  *density* is the\n    number of lines per unit square.\n    \"\"\"\n    from matplotlib.hatch import get_path\n    return (get_path(hatchpattern, density)\n            if hatchpattern is not None else None)",
                "def clip_to_bbox(self, bbox, inside=True):\n    \"\"\"\n    Clip the path to the given bounding box.\n\n    The path must be made up of one or more closed polygons.  This\n    algorithm will not behave correctly for unclosed paths.\n\n    If *inside* is `True`, clip to the inside of the box, otherwise\n    to the outside of the box.\n    \"\"\"\n    # Use make_compound_path_from_polys\n    verts = _path.clip_path_to_rect(self, bbox, inside)\n    paths = [Path(poly) for poly in verts]\n    return self.make_compound_path(*paths)"
            ],
            "inscope_function_signatures": [
                "get_path_collection_extents(master_transform, paths, transforms, offsets, offset_transform)",
                "__init__(self, vertices, codes=None, _interpolation_steps=1, closed=False, readonly=False)",
                "_fast_from_codes_and_verts(cls, verts, codes, internals_from=None)",
                "_update_values(self)",
                "vertices(self)",
                "vertices(self, vertices)",
                "codes(self)",
                "codes(self, codes)",
                "simplify_threshold(self)",
                "simplify_threshold(self, threshold)",
                "has_nonfinite(self)",
                "should_simplify(self)",
                "should_simplify(self, should_simplify)",
                "readonly(self)",
                "__copy__(self)",
                "__deepcopy__(self, memo=None)",
                "make_compound_path_from_polys(cls, XY)",
                "make_compound_path(cls, *args)",
                "__repr__(self)",
                "__len__(self)",
                "iter_segments(self, transform=None, remove_nans=True, clip=None, snap=False, stroke_width=1.0, simplify=None, curves=True, sketch=None)",
                "cleaned(self, transform=None, remove_nans=False, clip=None, quantize=False, simplify=False, curves=False, stroke_width=1.0, snap=False, sketch=None)",
                "transformed(self, transform)",
                "contains_point(self, point, transform=None, radius=0.0)",
                "contains_points(self, points, transform=None, radius=0.0)",
                "contains_path(self, path, transform=None)",
                "get_extents(self, transform=None)",
                "intersects_path(self, other, filled=True)",
                "intersects_bbox(self, bbox, filled=True)",
                "interpolated(self, steps)",
                "to_polygons(self, transform=None, width=0, height=0, closed_only=True)",
                "unit_rectangle(cls)",
                "unit_regular_polygon(cls, numVertices)",
                "unit_regular_star(cls, numVertices, innerCircle=0.5)",
                "unit_regular_asterisk(cls, numVertices)",
                "unit_circle(cls)",
                "circle(cls, center=(0.0, 0.0), radius=1.0, readonly=False)",
                "unit_circle_righthalf(cls)",
                "arc(cls, theta1, theta2, n=None, is_wedge=False)",
                "wedge(cls, theta1, theta2, n=None)",
                "hatch(hatchpattern, density=6)",
                "clip_to_bbox(self, bbox, inside=True)"
            ],
            "variables_in_file": {
                "code_type": [
                    78,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86
                ],
                "np.uint8": [
                    78
                ],
                "np": [
                    136,
                    652,
                    655,
                    144,
                    656,
                    789,
                    792,
                    414,
                    676,
                    679,
                    680,
                    682,
                    815,
                    317,
                    318,
                    576,
                    197,
                    840,
                    331,
                    843,
                    333,
                    78,
                    334,
                    848,
                    977,
                    852,
                    857,
                    858,
                    860,
                    733,
                    861,
                    862,
                    736,
                    614,
                    876,
                    877,
                    885,
                    886,
                    252
                ],
                "STOP": [
                    408,
                    81,
                    90,
                    403
                ],
                "MOVETO": [
                    82,
                    91
                ],
                "LINETO": [
                    83,
                    92
                ],
                "CURVE3": [
                    84,
                    93
                ],
                "CURVE4": [
                    85,
                    94
                ],
                "CLOSEPOLY": [
                    86,
                    95
                ],
                "NUM_VERTICES_FOR_CODE": [
                    90,
                    410,
                    402
                ],
                "vertices": [
                    896,
                    897,
                    130,
                    131,
                    899,
                    776,
                    137,
                    143,
                    144,
                    149,
                    405,
                    407,
                    792,
                    414,
                    429,
                    432,
                    819,
                    573,
                    581,
                    333,
                    334,
                    207,
                    211,
                    344,
                    736,
                    610,
                    612,
                    614,
                    615,
                    618,
                    620,
                    876,
                    878,
                    885,
                    887,
                    892,
                    893,
                    894,
                    895
                ],
                "_to_unmasked_float_array": [
                    178,
                    130
                ],
                "vertices.ndim": [
                    131
                ],
                "vertices.shape": [
                    131
                ],
                "ValueError": [
                    132,
                    138,
                    141,
                    975,
                    854,
                    314
                ],
                "codes": [
                    899,
                    773,
                    774,
                    135,
                    136,
                    137,
                    775,
                    776,
                    140,
                    144,
                    145,
                    146,
                    147,
                    150,
                    406,
                    407,
                    413,
                    288,
                    290,
                    292,
                    429,
                    815,
                    432,
                    816,
                    817,
                    179,
                    819,
                    318,
                    319,
                    320,
                    574,
                    575,
                    576,
                    324,
                    578,
                    334,
                    338,
                    339,
                    341,
                    344,
                    226,
                    230,
                    877,
                    879,
                    880,
                    886,
                    888
                ],
                "np.asarray": [
                    136
                ],
                "self.code_type": [
                    136,
                    577,
                    144
                ],
                "self": [
                    259,
                    263,
                    136,
                    392,
                    395,
                    140,
                    523,
                    142,
                    270,
                    144,
                    145,
                    146,
                    147,
                    402,
                    149,
                    150,
                    151,
                    152,
                    278,
                    403,
                    155,
                    156,
                    157,
                    158,
                    534,
                    160,
                    288,
                    538,
                    291,
                    292,
                    293,
                    550,
                    430,
                    942,
                    432,
                    944,
                    563,
                    571,
                    573,
                    574,
                    447,
                    192,
                    193,
                    194,
                    448,
                    196,
                    197,
                    577,
                    205,
                    209,
                    211,
                    212,
                    347,
                    603,
                    350,
                    224,
                    481,
                    609,
                    483,
                    228,
                    610,
                    230,
                    231,
                    239,
                    625,
                    243,
                    252,
                    511
                ],
                "codes.ndim": [
                    137
                ],
                "len": [
                    576,
                    196,
                    612,
                    392,
                    137,
                    140,
                    334,
                    143,
                    144,
                    974,
                    339,
                    341,
                    342,
                    603,
                    350
                ],
                "self.MOVETO": [
                    145,
                    140,
                    142
                ],
                "format": [
                    141
                ],
                "closed": [
                    143
                ],
                "np.empty": [
                    144,
                    331,
                    885,
                    334
                ],
                "self.LINETO": [
                    146
                ],
                "self.CLOSEPOLY": [
                    147
                ],
                "self._vertices": [
                    196,
                    205,
                    211,
                    149,
                    155,
                    252
                ],
                "self._codes": [
                    224,
                    197,
                    230,
                    150,
                    156,
                    157
                ],
                "self._interpolation_steps": [
                    448,
                    293,
                    151
                ],
                "_interpolation_steps": [
                    151
                ],
                "self._update_values": [
                    152,
                    212,
                    231
                ],
                "readonly": [
                    776,
                    154
                ],
                "self._vertices.flags.writeable": [
                    155
                ],
                "self._vertices.flags": [
                    155
                ],
                "self._codes.flags.writeable": [
                    157
                ],
                "self._codes.flags": [
                    157
                ],
                "self._readonly": [
                    160,
                    228,
                    270,
                    209,
                    158
                ],
                "pth": [
                    432,
                    177,
                    178,
                    179,
                    180,
                    434,
                    182,
                    183,
                    184,
                    435,
                    186,
                    187,
                    188,
                    189
                ],
                "cls.__new__": [
                    177
                ],
                "cls": [
                    899,
                    773,
                    774,
                    775,
                    648,
                    657,
                    659,
                    787,
                    917,
                    671,
                    683,
                    685,
                    815,
                    816,
                    177,
                    817,
                    819,
                    820,
                    694,
                    318,
                    319,
                    320,
                    705,
                    706,
                    324,
                    708,
                    334,
                    338,
                    339,
                    344,
                    877,
                    879,
                    880,
                    886,
                    888,
                    634,
                    635,
                    637
                ],
                "pth._vertices": [
                    178
                ],
                "verts": [
                    322,
                    324,
                    682,
                    683,
                    942,
                    943,
                    656,
                    657,
                    178,
                    317
                ],
                "pth._codes": [
                    179
                ],
                "pth._readonly": [
                    180
                ],
                "internals_from": [
                    184,
                    181,
                    182,
                    183
                ],
                "pth._should_simplify": [
                    434,
                    186,
                    182
                ],
                "internals_from._should_simplify": [
                    182
                ],
                "pth._simplify_threshold": [
                    187,
                    183
                ],
                "internals_from._simplify_threshold": [
                    183
                ],
                "pth._interpolation_steps": [
                    184,
                    188
                ],
                "internals_from._interpolation_steps": [
                    184
                ],
                "mpl.rcParams": [
                    192,
                    187,
                    195
                ],
                "mpl": [
                    192,
                    187,
                    195
                ],
                "classmethod": [
                    641,
                    162,
                    901,
                    326,
                    710,
                    297,
                    780,
                    688,
                    629,
                    822,
                    664,
                    698
                ],
                "self._simplify_threshold": [
                    192,
                    194,
                    243,
                    239
                ],
                "self._should_simplify": [
                    193,
                    259,
                    263
                ],
                "np.all": [
                    197
                ],
                "Path.LINETO": [
                    576,
                    197
                ],
                "Path": [
                    576,
                    197,
                    581,
                    776,
                    331,
                    943,
                    432,
                    447
                ],
                "property": [
                    200,
                    233,
                    265,
                    214,
                    247,
                    254
                ],
                "AttributeError": [
                    289,
                    210,
                    229
                ],
                "vertices.setter": [
                    207
                ],
                "codes.setter": [
                    226
                ],
                "threshold": [
                    243
                ],
                "simplify_threshold.setter": [
                    241
                ],
                "simplify_threshold": [
                    241
                ],
                "all": [
                    252
                ],
                "np.isfinite": [
                    252
                ],
                "cbook.deprecated": [
                    245
                ],
                "cbook": [
                    417,
                    245
                ],
                "should_simplify": [
                    261,
                    263
                ],
                "should_simplify.setter": [
                    261
                ],
                "copy.copy": [
                    278
                ],
                "copy": [
                    280,
                    278
                ],
                "__copy__": [
                    280
                ],
                "self.codes.copy": [
                    288
                ],
                "self.codes": [
                    288,
                    609,
                    347,
                    574,
                    447
                ],
                "self.__class__": [
                    291
                ],
                "self.vertices.copy": [
                    292
                ],
                "self.vertices": [
                    610,
                    292,
                    603,
                    347,
                    573,
                    350,
                    447
                ],
                "deepcopy": [
                    295
                ],
                "__deepcopy__": [
                    295
                ],
                "numpolys": [
                    312,
                    316
                ],
                "numsides": [
                    312,
                    320,
                    315,
                    321
                ],
                "two": [
                    312,
                    313
                ],
                "XY.shape": [
                    312
                ],
                "XY": [
                    312,
                    322
                ],
                "stride": [
                    320,
                    322,
                    315,
                    316,
                    319
                ],
                "nverts": [
                    316,
                    317,
                    318
                ],
                "np.zeros": [
                    876,
                    317
                ],
                "np.full": [
                    576,
                    877,
                    815,
                    886,
                    318
                ],
                "cls.LINETO": [
                    880,
                    339,
                    318,
                    879
                ],
                "cls.code_type": [
                    877,
                    334,
                    815,
                    886,
                    318
                ],
                "cls.MOVETO": [
                    774,
                    879,
                    816,
                    338,
                    888,
                    319
                ],
                "cls.CLOSEPOLY": [
                    320,
                    817,
                    880,
                    775
                ],
                "i": [
                    321,
                    322,
                    335,
                    338,
                    339,
                    341,
                    342,
                    412
                ],
                "range": [
                    321,
                    412
                ],
                "args": [
                    336,
                    330,
                    333
                ],
                "np.float32": [
                    331
                ],
                "np.concatenate": [
                    333
                ],
                "x.vertices": [
                    333
                ],
                "x": [
                    333
                ],
                "path": [
                    648,
                    650,
                    523,
                    651,
                    657,
                    659,
                    660,
                    534,
                    538,
                    540,
                    671,
                    673,
                    674,
                    683,
                    685,
                    686,
                    336,
                    337,
                    339,
                    341,
                    342
                ],
                "path.codes": [
                    337,
                    341
                ],
                "path.vertices": [
                    339,
                    342
                ],
                "cleaned": [
                    395,
                    405,
                    406
                ],
                "self.cleaned": [
                    395
                ],
                "transform": [
                    521,
                    522,
                    395,
                    523,
                    535,
                    536,
                    537,
                    538,
                    539,
                    540,
                    430,
                    447,
                    474,
                    475,
                    606,
                    607,
                    480,
                    481,
                    482,
                    483,
                    617,
                    620,
                    625,
                    509,
                    510,
                    511
                ],
                "remove_nans": [
                    396,
                    430
                ],
                "clip": [
                    396,
                    430
                ],
                "snap": [
                    397,
                    430
                ],
                "stroke_width": [
                    397,
                    430
                ],
                "simplify": [
                    433,
                    430,
                    398
                ],
                "curves": [
                    398,
                    431
                ],
                "sketch": [
                    431,
                    399
                ],
                "self.NUM_VERTICES_FOR_CODE": [
                    402
                ],
                "self.STOP": [
                    403
                ],
                "iter": [
                    405,
                    406
                ],
                "cleaned.vertices": [
                    405
                ],
                "cleaned.codes": [
                    406
                ],
                "curr_vertices": [
                    415,
                    414,
                    407
                ],
                "code": [
                    408,
                    415,
                    410,
                    407
                ],
                "zip": [
                    407
                ],
                "extra_vertices": [
                    410,
                    411,
                    412
                ],
                "next": [
                    413,
                    414
                ],
                "np.append": [
                    414
                ],
                "_path.cleanup_path": [
                    429
                ],
                "_path": [
                    483,
                    550,
                    523,
                    429,
                    942,
                    624,
                    976,
                    562,
                    540,
                    511
                ],
                "Path._fast_from_codes_and_verts": [
                    432
                ],
                "cbook._delete_parameter": [
                    417
                ],
                "transform.transform": [
                    620,
                    447
                ],
                "transform.frozen": [
                    522,
                    536,
                    475,
                    510,
                    607
                ],
                "transform.is_affine": [
                    480,
                    537
                ],
                "transform.transform_path": [
                    481
                ],
                "_path.point_in_path": [
                    483
                ],
                "point": [
                    483
                ],
                "radius": [
                    776,
                    483,
                    511
                ],
                "result": [
                    512,
                    511
                ],
                "_path.points_in_path": [
                    511
                ],
                "points": [
                    511
                ],
                "result.astype": [
                    512
                ],
                "_path.path_in_path": [
                    523
                ],
                "self.transformed": [
                    538
                ],
                "Bbox": [
                    976,
                    540
                ],
                "_path.get_path_extents": [
                    540
                ],
                "_path.path_intersects_path": [
                    550
                ],
                "other": [
                    550
                ],
                "filled": [
                    563,
                    550
                ],
                "_path.path_intersects_rectangle": [
                    562
                ],
                "bbox.x0": [
                    563
                ],
                "bbox": [
                    563,
                    942
                ],
                "bbox.y0": [
                    563
                ],
                "bbox.x1": [
                    563
                ],
                "bbox.y1": [
                    563
                ],
                "steps": [
                    576,
                    578,
                    861,
                    570,
                    860,
                    573,
                    862
                ],
                "simple_linear_interpolation": [
                    573
                ],
                "new_codes": [
                    576,
                    578,
                    580,
                    581
                ],
                "width": [
                    609,
                    625
                ],
                "height": [
                    609,
                    625
                ],
                "closed_only": [
                    625,
                    611
                ],
                "np.any": [
                    614
                ],
                "_path.convert_path_to_polygons": [
                    624
                ],
                "_unit_rectangle": [
                    627
                ],
                "cls._unit_rectangle": [
                    634,
                    635,
                    637
                ],
                "_unit_regular_polygons": [
                    639
                ],
                "WeakValueDictionary": [
                    662,
                    639
                ],
                "numVertices": [
                    675,
                    647,
                    648,
                    652,
                    684,
                    685,
                    658,
                    659,
                    694,
                    670,
                    671
                ],
                "cls._unit_regular_polygons.get": [
                    648
                ],
                "cls._unit_regular_polygons": [
                    648,
                    659
                ],
                "theta": [
                    676,
                    679,
                    682,
                    652,
                    656
                ],
                "np.pi": [
                    676,
                    679,
                    840,
                    652,
                    655
                ],
                "np.arange": [
                    676,
                    652
                ],
                "np.column_stack": [
                    656
                ],
                "np.cos": [
                    656,
                    682,
                    861
                ],
                "np.sin": [
                    656,
                    682,
                    858,
                    862
                ],
                "_unit_regular_stars": [
                    662
                ],
                "cls._unit_regular_stars.get": [
                    671
                ],
                "cls._unit_regular_stars": [
                    685,
                    671
                ],
                "innerCircle": [
                    681,
                    685,
                    671
                ],
                "ns2": [
                    680,
                    675,
                    676
                ],
                "r": [
                    680,
                    681,
                    682
                ],
                "np.ones": [
                    680
                ],
                "T": [
                    682
                ],
                "np.vstack": [
                    682
                ],
                "cls.unit_regular_star": [
                    694
                ],
                "_unit_circle": [
                    696
                ],
                "cls._unit_circle": [
                    705,
                    706,
                    708
                ],
                "cls.circle": [
                    706
                ],
                "MAGIC": [
                    800,
                    738,
                    803,
                    743,
                    808,
                    746,
                    751,
                    754,
                    788,
                    790,
                    759,
                    762,
                    795,
                    732,
                    734,
                    767
                ],
                "SQRTHALF": [
                    789,
                    790,
                    796,
                    797,
                    799,
                    804,
                    805,
                    807,
                    733,
                    734,
                    739,
                    740,
                    742,
                    747,
                    748,
                    750,
                    755,
                    756,
                    758,
                    763,
                    764,
                    766
                ],
                "np.sqrt": [
                    789,
                    858,
                    733
                ],
                "MAGIC45": [
                    739,
                    804,
                    742,
                    807,
                    747,
                    750,
                    766,
                    755,
                    758,
                    790,
                    763,
                    796,
                    734,
                    799
                ],
                "np.array": [
                    736,
                    792
                ],
                "float": [
                    885,
                    771,
                    876,
                    813
                ],
                "cls.CURVE4": [
                    877,
                    773,
                    886,
                    815
                ],
                "center": [
                    776
                ],
                "_unit_circle_righthalf": [
                    778
                ],
                "cls._unit_circle_righthalf": [
                    819,
                    787,
                    820
                ],
                "halfpi": [
                    840,
                    852
                ],
                "eta1": [
                    842,
                    846,
                    848,
                    852,
                    856,
                    860
                ],
                "theta1": [
                    842,
                    843,
                    917,
                    846
                ],
                "eta2": [
                    843,
                    846,
                    847,
                    848,
                    852,
                    856,
                    860
                ],
                "theta2": [
                    843,
                    917,
                    846
                ],
                "np.floor": [
                    843
                ],
                "np.deg2rad": [
                    848
                ],
                "n": [
                    875,
                    851,
                    852,
                    853,
                    884,
                    917,
                    856,
                    860
                ],
                "int": [
                    852
                ],
                "np.ceil": [
                    852
                ],
                "deta": [
                    856,
                    857,
                    858
                ],
                "t": [
                    857,
                    858
                ],
                "np.tan": [
                    857
                ],
                "alpha": [
                    858,
                    892,
                    893,
                    894,
                    895
                ],
                "np.linspace": [
                    860
                ],
                "cos_eta": [
                    864,
                    869,
                    861
                ],
                "sin_eta": [
                    865,
                    870,
                    862
                ],
                "xA": [
                    864,
                    867,
                    878,
                    887,
                    892
                ],
                "yA": [
                    865,
                    866,
                    878,
                    887,
                    893
                ],
                "xA_dot": [
                    866,
                    892
                ],
                "yA_dot": [
                    867,
                    893
                ],
                "xB": [
                    872,
                    896,
                    869,
                    894
                ],
                "yB": [
                    897,
                    895,
                    870,
                    871
                ],
                "xB_dot": [
                    894,
                    871
                ],
                "yB_dot": [
                    872,
                    895
                ],
                "is_wedge": [
                    874
                ],
                "length": [
                    875,
                    876,
                    877,
                    882,
                    884,
                    885,
                    886,
                    890
                ],
                "vertex_offset": [
                    896,
                    897,
                    881,
                    889,
                    892,
                    893,
                    894,
                    895
                ],
                "end": [
                    896,
                    897,
                    882,
                    890,
                    892,
                    893,
                    894,
                    895
                ],
                "cls.arc": [
                    917
                ],
                "hatchpattern": [
                    928,
                    929
                ],
                "get_path": [
                    928
                ],
                "density": [
                    928
                ],
                "staticmethod": [
                    919
                ],
                "lru_cache": [
                    920
                ],
                "_path.clip_path_to_rect": [
                    942
                ],
                "inside": [
                    942
                ],
                "paths": [
                    944,
                    977,
                    974,
                    943
                ],
                "poly": [
                    943
                ],
                "self.make_compound_path": [
                    944
                ],
                "Bbox.from_extents": [
                    976
                ],
                "_path.get_path_collection_extents": [
                    976
                ],
                "master_transform": [
                    977
                ],
                "np.atleast_3d": [
                    977
                ],
                "transforms": [
                    977
                ],
                "offsets": [
                    978
                ],
                "offset_transform": [
                    978
                ]
            },
            "filtered_variables_in_file": {
                "code_type": [
                    78,
                    81,
                    82,
                    83,
                    84,
                    85,
                    86
                ],
                "np.uint8": [
                    78
                ],
                "np": [
                    136,
                    652,
                    655,
                    144,
                    656,
                    789,
                    792,
                    414,
                    676,
                    679,
                    680,
                    682,
                    815,
                    317,
                    318,
                    576,
                    197,
                    840,
                    331,
                    843,
                    333,
                    78,
                    334,
                    848,
                    977,
                    852,
                    857,
                    858,
                    860,
                    733,
                    861,
                    862,
                    736,
                    614,
                    876,
                    877,
                    885,
                    886,
                    252
                ],
                "STOP": [
                    408,
                    81,
                    90,
                    403
                ],
                "MOVETO": [
                    82,
                    91
                ],
                "LINETO": [
                    83,
                    92
                ],
                "CURVE3": [
                    84,
                    93
                ],
                "CURVE4": [
                    85,
                    94
                ],
                "CLOSEPOLY": [
                    86,
                    95
                ],
                "NUM_VERTICES_FOR_CODE": [
                    90,
                    410,
                    402
                ],
                "vertices": [
                    896,
                    897,
                    130,
                    131,
                    899,
                    776,
                    137,
                    143,
                    144,
                    149,
                    405,
                    407,
                    792,
                    414,
                    429,
                    432,
                    819,
                    573,
                    581,
                    333,
                    334,
                    207,
                    211,
                    344,
                    736,
                    610,
                    612,
                    614,
                    615,
                    618,
                    620,
                    876,
                    878,
                    885,
                    887,
                    892,
                    893,
                    894,
                    895
                ],
                "_to_unmasked_float_array": [
                    178,
                    130
                ],
                "vertices.ndim": [
                    131
                ],
                "vertices.shape": [
                    131
                ],
                "codes": [
                    899,
                    773,
                    774,
                    135,
                    136,
                    137,
                    775,
                    776,
                    140,
                    144,
                    145,
                    146,
                    147,
                    150,
                    406,
                    407,
                    413,
                    288,
                    290,
                    292,
                    429,
                    815,
                    432,
                    816,
                    817,
                    179,
                    819,
                    318,
                    319,
                    320,
                    574,
                    575,
                    576,
                    324,
                    578,
                    334,
                    338,
                    339,
                    341,
                    344,
                    226,
                    230,
                    877,
                    879,
                    880,
                    886,
                    888
                ],
                "np.asarray": [
                    136
                ],
                "self.code_type": [
                    136,
                    577,
                    144
                ],
                "self": [
                    259,
                    263,
                    136,
                    392,
                    395,
                    140,
                    523,
                    142,
                    270,
                    144,
                    145,
                    146,
                    147,
                    402,
                    149,
                    150,
                    151,
                    152,
                    278,
                    403,
                    155,
                    156,
                    157,
                    158,
                    534,
                    160,
                    288,
                    538,
                    291,
                    292,
                    293,
                    550,
                    430,
                    942,
                    432,
                    944,
                    563,
                    571,
                    573,
                    574,
                    447,
                    192,
                    193,
                    194,
                    448,
                    196,
                    197,
                    577,
                    205,
                    209,
                    211,
                    212,
                    347,
                    603,
                    350,
                    224,
                    481,
                    609,
                    483,
                    228,
                    610,
                    230,
                    231,
                    239,
                    625,
                    243,
                    252,
                    511
                ],
                "codes.ndim": [
                    137
                ],
                "self.MOVETO": [
                    145,
                    140,
                    142
                ],
                "closed": [
                    143
                ],
                "np.empty": [
                    144,
                    331,
                    885,
                    334
                ],
                "self.LINETO": [
                    146
                ],
                "self.CLOSEPOLY": [
                    147
                ],
                "self._vertices": [
                    196,
                    205,
                    211,
                    149,
                    155,
                    252
                ],
                "self._codes": [
                    224,
                    197,
                    230,
                    150,
                    156,
                    157
                ],
                "self._interpolation_steps": [
                    448,
                    293,
                    151
                ],
                "_interpolation_steps": [
                    151
                ],
                "self._update_values": [
                    152,
                    212,
                    231
                ],
                "readonly": [
                    776,
                    154
                ],
                "self._vertices.flags.writeable": [
                    155
                ],
                "self._vertices.flags": [
                    155
                ],
                "self._codes.flags.writeable": [
                    157
                ],
                "self._codes.flags": [
                    157
                ],
                "self._readonly": [
                    160,
                    228,
                    270,
                    209,
                    158
                ],
                "pth": [
                    432,
                    177,
                    178,
                    179,
                    180,
                    434,
                    182,
                    183,
                    184,
                    435,
                    186,
                    187,
                    188,
                    189
                ],
                "cls.__new__": [
                    177
                ],
                "cls": [
                    899,
                    773,
                    774,
                    775,
                    648,
                    657,
                    659,
                    787,
                    917,
                    671,
                    683,
                    685,
                    815,
                    816,
                    177,
                    817,
                    819,
                    820,
                    694,
                    318,
                    319,
                    320,
                    705,
                    706,
                    324,
                    708,
                    334,
                    338,
                    339,
                    344,
                    877,
                    879,
                    880,
                    886,
                    888,
                    634,
                    635,
                    637
                ],
                "pth._vertices": [
                    178
                ],
                "verts": [
                    322,
                    324,
                    682,
                    683,
                    942,
                    943,
                    656,
                    657,
                    178,
                    317
                ],
                "pth._codes": [
                    179
                ],
                "pth._readonly": [
                    180
                ],
                "internals_from": [
                    184,
                    181,
                    182,
                    183
                ],
                "pth._should_simplify": [
                    434,
                    186,
                    182
                ],
                "internals_from._should_simplify": [
                    182
                ],
                "pth._simplify_threshold": [
                    187,
                    183
                ],
                "internals_from._simplify_threshold": [
                    183
                ],
                "pth._interpolation_steps": [
                    184,
                    188
                ],
                "internals_from._interpolation_steps": [
                    184
                ],
                "mpl.rcParams": [
                    192,
                    187,
                    195
                ],
                "mpl": [
                    192,
                    187,
                    195
                ],
                "self._simplify_threshold": [
                    192,
                    194,
                    243,
                    239
                ],
                "self._should_simplify": [
                    193,
                    259,
                    263
                ],
                "np.all": [
                    197
                ],
                "Path.LINETO": [
                    576,
                    197
                ],
                "Path": [
                    576,
                    197,
                    581,
                    776,
                    331,
                    943,
                    432,
                    447
                ],
                "vertices.setter": [
                    207
                ],
                "codes.setter": [
                    226
                ],
                "threshold": [
                    243
                ],
                "simplify_threshold.setter": [
                    241
                ],
                "simplify_threshold": [
                    241
                ],
                "np.isfinite": [
                    252
                ],
                "cbook.deprecated": [
                    245
                ],
                "cbook": [
                    417,
                    245
                ],
                "should_simplify": [
                    261,
                    263
                ],
                "should_simplify.setter": [
                    261
                ],
                "copy.copy": [
                    278
                ],
                "copy": [
                    280,
                    278
                ],
                "__copy__": [
                    280
                ],
                "self.codes.copy": [
                    288
                ],
                "self.codes": [
                    288,
                    609,
                    347,
                    574,
                    447
                ],
                "self.__class__": [
                    291
                ],
                "self.vertices.copy": [
                    292
                ],
                "self.vertices": [
                    610,
                    292,
                    603,
                    347,
                    573,
                    350,
                    447
                ],
                "deepcopy": [
                    295
                ],
                "__deepcopy__": [
                    295
                ],
                "numpolys": [
                    312,
                    316
                ],
                "numsides": [
                    312,
                    320,
                    315,
                    321
                ],
                "two": [
                    312,
                    313
                ],
                "XY.shape": [
                    312
                ],
                "XY": [
                    312,
                    322
                ],
                "stride": [
                    320,
                    322,
                    315,
                    316,
                    319
                ],
                "nverts": [
                    316,
                    317,
                    318
                ],
                "np.zeros": [
                    876,
                    317
                ],
                "np.full": [
                    576,
                    877,
                    815,
                    886,
                    318
                ],
                "cls.LINETO": [
                    880,
                    339,
                    318,
                    879
                ],
                "cls.code_type": [
                    877,
                    334,
                    815,
                    886,
                    318
                ],
                "cls.MOVETO": [
                    774,
                    879,
                    816,
                    338,
                    888,
                    319
                ],
                "cls.CLOSEPOLY": [
                    320,
                    817,
                    880,
                    775
                ],
                "i": [
                    321,
                    322,
                    335,
                    338,
                    339,
                    341,
                    342,
                    412
                ],
                "args": [
                    336,
                    330,
                    333
                ],
                "np.float32": [
                    331
                ],
                "np.concatenate": [
                    333
                ],
                "x.vertices": [
                    333
                ],
                "x": [
                    333
                ],
                "path": [
                    648,
                    650,
                    523,
                    651,
                    657,
                    659,
                    660,
                    534,
                    538,
                    540,
                    671,
                    673,
                    674,
                    683,
                    685,
                    686,
                    336,
                    337,
                    339,
                    341,
                    342
                ],
                "path.codes": [
                    337,
                    341
                ],
                "path.vertices": [
                    339,
                    342
                ],
                "cleaned": [
                    395,
                    405,
                    406
                ],
                "self.cleaned": [
                    395
                ],
                "transform": [
                    521,
                    522,
                    395,
                    523,
                    535,
                    536,
                    537,
                    538,
                    539,
                    540,
                    430,
                    447,
                    474,
                    475,
                    606,
                    607,
                    480,
                    481,
                    482,
                    483,
                    617,
                    620,
                    625,
                    509,
                    510,
                    511
                ],
                "remove_nans": [
                    396,
                    430
                ],
                "clip": [
                    396,
                    430
                ],
                "snap": [
                    397,
                    430
                ],
                "stroke_width": [
                    397,
                    430
                ],
                "simplify": [
                    433,
                    430,
                    398
                ],
                "curves": [
                    398,
                    431
                ],
                "sketch": [
                    431,
                    399
                ],
                "self.NUM_VERTICES_FOR_CODE": [
                    402
                ],
                "self.STOP": [
                    403
                ],
                "cleaned.vertices": [
                    405
                ],
                "cleaned.codes": [
                    406
                ],
                "curr_vertices": [
                    415,
                    414,
                    407
                ],
                "code": [
                    408,
                    415,
                    410,
                    407
                ],
                "extra_vertices": [
                    410,
                    411,
                    412
                ],
                "np.append": [
                    414
                ],
                "_path.cleanup_path": [
                    429
                ],
                "_path": [
                    483,
                    550,
                    523,
                    429,
                    942,
                    624,
                    976,
                    562,
                    540,
                    511
                ],
                "Path._fast_from_codes_and_verts": [
                    432
                ],
                "cbook._delete_parameter": [
                    417
                ],
                "transform.transform": [
                    620,
                    447
                ],
                "transform.frozen": [
                    522,
                    536,
                    475,
                    510,
                    607
                ],
                "transform.is_affine": [
                    480,
                    537
                ],
                "transform.transform_path": [
                    481
                ],
                "_path.point_in_path": [
                    483
                ],
                "point": [
                    483
                ],
                "radius": [
                    776,
                    483,
                    511
                ],
                "result": [
                    512,
                    511
                ],
                "_path.points_in_path": [
                    511
                ],
                "points": [
                    511
                ],
                "result.astype": [
                    512
                ],
                "_path.path_in_path": [
                    523
                ],
                "self.transformed": [
                    538
                ],
                "Bbox": [
                    976,
                    540
                ],
                "_path.get_path_extents": [
                    540
                ],
                "_path.path_intersects_path": [
                    550
                ],
                "other": [
                    550
                ],
                "filled": [
                    563,
                    550
                ],
                "_path.path_intersects_rectangle": [
                    562
                ],
                "bbox.x0": [
                    563
                ],
                "bbox": [
                    563,
                    942
                ],
                "bbox.y0": [
                    563
                ],
                "bbox.x1": [
                    563
                ],
                "bbox.y1": [
                    563
                ],
                "steps": [
                    576,
                    578,
                    861,
                    570,
                    860,
                    573,
                    862
                ],
                "simple_linear_interpolation": [
                    573
                ],
                "new_codes": [
                    576,
                    578,
                    580,
                    581
                ],
                "width": [
                    609,
                    625
                ],
                "height": [
                    609,
                    625
                ],
                "closed_only": [
                    625,
                    611
                ],
                "np.any": [
                    614
                ],
                "_path.convert_path_to_polygons": [
                    624
                ],
                "_unit_rectangle": [
                    627
                ],
                "cls._unit_rectangle": [
                    634,
                    635,
                    637
                ],
                "_unit_regular_polygons": [
                    639
                ],
                "WeakValueDictionary": [
                    662,
                    639
                ],
                "numVertices": [
                    675,
                    647,
                    648,
                    652,
                    684,
                    685,
                    658,
                    659,
                    694,
                    670,
                    671
                ],
                "cls._unit_regular_polygons.get": [
                    648
                ],
                "cls._unit_regular_polygons": [
                    648,
                    659
                ],
                "theta": [
                    676,
                    679,
                    682,
                    652,
                    656
                ],
                "np.pi": [
                    676,
                    679,
                    840,
                    652,
                    655
                ],
                "np.arange": [
                    676,
                    652
                ],
                "np.column_stack": [
                    656
                ],
                "np.cos": [
                    656,
                    682,
                    861
                ],
                "np.sin": [
                    656,
                    682,
                    858,
                    862
                ],
                "_unit_regular_stars": [
                    662
                ],
                "cls._unit_regular_stars.get": [
                    671
                ],
                "cls._unit_regular_stars": [
                    685,
                    671
                ],
                "innerCircle": [
                    681,
                    685,
                    671
                ],
                "ns2": [
                    680,
                    675,
                    676
                ],
                "r": [
                    680,
                    681,
                    682
                ],
                "np.ones": [
                    680
                ],
                "T": [
                    682
                ],
                "np.vstack": [
                    682
                ],
                "cls.unit_regular_star": [
                    694
                ],
                "_unit_circle": [
                    696
                ],
                "cls._unit_circle": [
                    705,
                    706,
                    708
                ],
                "cls.circle": [
                    706
                ],
                "MAGIC": [
                    800,
                    738,
                    803,
                    743,
                    808,
                    746,
                    751,
                    754,
                    788,
                    790,
                    759,
                    762,
                    795,
                    732,
                    734,
                    767
                ],
                "SQRTHALF": [
                    789,
                    790,
                    796,
                    797,
                    799,
                    804,
                    805,
                    807,
                    733,
                    734,
                    739,
                    740,
                    742,
                    747,
                    748,
                    750,
                    755,
                    756,
                    758,
                    763,
                    764,
                    766
                ],
                "np.sqrt": [
                    789,
                    858,
                    733
                ],
                "MAGIC45": [
                    739,
                    804,
                    742,
                    807,
                    747,
                    750,
                    766,
                    755,
                    758,
                    790,
                    763,
                    796,
                    734,
                    799
                ],
                "np.array": [
                    736,
                    792
                ],
                "cls.CURVE4": [
                    877,
                    773,
                    886,
                    815
                ],
                "center": [
                    776
                ],
                "_unit_circle_righthalf": [
                    778
                ],
                "cls._unit_circle_righthalf": [
                    819,
                    787,
                    820
                ],
                "halfpi": [
                    840,
                    852
                ],
                "eta1": [
                    842,
                    846,
                    848,
                    852,
                    856,
                    860
                ],
                "theta1": [
                    842,
                    843,
                    917,
                    846
                ],
                "eta2": [
                    843,
                    846,
                    847,
                    848,
                    852,
                    856,
                    860
                ],
                "theta2": [
                    843,
                    917,
                    846
                ],
                "np.floor": [
                    843
                ],
                "np.deg2rad": [
                    848
                ],
                "n": [
                    875,
                    851,
                    852,
                    853,
                    884,
                    917,
                    856,
                    860
                ],
                "np.ceil": [
                    852
                ],
                "deta": [
                    856,
                    857,
                    858
                ],
                "t": [
                    857,
                    858
                ],
                "np.tan": [
                    857
                ],
                "alpha": [
                    858,
                    892,
                    893,
                    894,
                    895
                ],
                "np.linspace": [
                    860
                ],
                "cos_eta": [
                    864,
                    869,
                    861
                ],
                "sin_eta": [
                    865,
                    870,
                    862
                ],
                "xA": [
                    864,
                    867,
                    878,
                    887,
                    892
                ],
                "yA": [
                    865,
                    866,
                    878,
                    887,
                    893
                ],
                "xA_dot": [
                    866,
                    892
                ],
                "yA_dot": [
                    867,
                    893
                ],
                "xB": [
                    872,
                    896,
                    869,
                    894
                ],
                "yB": [
                    897,
                    895,
                    870,
                    871
                ],
                "xB_dot": [
                    894,
                    871
                ],
                "yB_dot": [
                    872,
                    895
                ],
                "is_wedge": [
                    874
                ],
                "length": [
                    875,
                    876,
                    877,
                    882,
                    884,
                    885,
                    886,
                    890
                ],
                "vertex_offset": [
                    896,
                    897,
                    881,
                    889,
                    892,
                    893,
                    894,
                    895
                ],
                "end": [
                    896,
                    897,
                    882,
                    890,
                    892,
                    893,
                    894,
                    895
                ],
                "cls.arc": [
                    917
                ],
                "hatchpattern": [
                    928,
                    929
                ],
                "get_path": [
                    928
                ],
                "density": [
                    928
                ],
                "lru_cache": [
                    920
                ],
                "_path.clip_path_to_rect": [
                    942
                ],
                "inside": [
                    942
                ],
                "paths": [
                    944,
                    977,
                    974,
                    943
                ],
                "poly": [
                    943
                ],
                "self.make_compound_path": [
                    944
                ],
                "Bbox.from_extents": [
                    976
                ],
                "_path.get_path_collection_extents": [
                    976
                ],
                "master_transform": [
                    977
                ],
                "np.atleast_3d": [
                    977
                ],
                "transforms": [
                    977
                ],
                "offsets": [
                    978
                ],
                "offset_transform": [
                    978
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/home/ubuntu/Desktop/bgp_envs_local/repos/matplotlib_13/lib/matplotlib/tests/test_path.py",
                "test_function": "test_make_compound_path_stops",
                "test_function_code": "def test_make_compound_path_stops():\n    zero = [0, 0]\n    paths = 3*[Path([zero, zero], [Path.MOVETO, Path.STOP])]\n    compound_path = Path.make_compound_path(*paths)\n    assert np.sum(compound_path.codes == Path.STOP) == 1",
                "test_error": "assert 3 == 1\n +  where 3 = <function sum at 0x7f957ae991f0>(array([1, 0, 1, 0, 1, 0], dtype=uint8) == 0)\n +    where <function sum at 0x7f957ae991f0> = np.sum\n +    and   array([1, 0, 1, 0, 1, 0], dtype=uint8) = Path(array([[0., 0.],\\n       [0., 0.],\\n       [0., 0.],\\n       [0., 0.],\\n       [0., 0.],\\n       [0., 0.]]), array([1, 0, 1, 0, 1, 0], dtype=uint8)).codes\n +    and   0 = Path.STOP",
                "full_test_error": "def test_make_compound_path_stops():\n        zero = [0, 0]\n        paths = 3*[Path([zero, zero], [Path.MOVETO, Path.STOP])]\n        compound_path = Path.make_compound_path(*paths)\n>       assert np.sum(compound_path.codes == Path.STOP) == 1\nE       assert 3 == 1\nE        +  where 3 = <function sum at 0x7f957ae991f0>(array([1, 0, 1, 0, 1, 0], dtype=uint8) == 0)\nE        +    where <function sum at 0x7f957ae991f0> = np.sum\nE        +    and   array([1, 0, 1, 0, 1, 0], dtype=uint8) = Path(array([[0., 0.],\\n       [0., 0.],\\n       [0., 0.],\\n       [0., 0.],\\n       [0., 0.],\\n       [0., 0.]]), array([1, 0, 1, 0, 1, 0], dtype=uint8)).codes\nE        +    and   0 = Path.STOP\n\nlib/matplotlib/tests/test_path.py:154: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            }
        ]
    }
}