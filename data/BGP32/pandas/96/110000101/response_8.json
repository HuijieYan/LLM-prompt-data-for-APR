{
    "pandas": [
        {
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.2.1": 1,
                "1.4.2": 0,
                "1.2.2": 1,
                "1.5.1": 0,
                "1.5.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.2.1": 0,
                "2.2.2": 0,
                "2.3.1": 1,
                "2.3.2": 1,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 1
            },
            "strata": {
                "1": 1,
                "2": 1,
                "3": 0,
                "4": 0,
                "5": 0,
                "6": 0,
                "7": 1,
                "8": 0,
                "9": 1
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 0,
                "1.3.1": 1,
                "1.3.2": 0,
                "1.4.1": 0,
                "1.2.1": 1,
                "1.4.2": 0,
                "1.2.2": 1,
                "1.5.1": 0,
                "1.5.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.2.1": 0,
                "2.2.2": 0,
                "2.3.1": 1,
                "2.3.2": 1,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 1
            },
            "available_strata": {
                "1": 1,
                "2": 1,
                "3": 0,
                "4": 0,
                "5": 0,
                "6": 0,
                "7": 1,
                "8": 0,
                "9": 1
            },
            "bugID": 96,
            "start_line": 857,
            "file_name": "pandas/tseries/offsets.py",
            "replace_code": "def apply(self, other):\n        if isinstance(other, datetime):\n            n = self.n\n            start_time = self.start[0]\n            end_time = self.end[0]\n            business_hours = self._get_business_hours_by_sec(start_time, end_time)\n            total_seconds = abs(n * 60 * business_hours)\n            \n            new_date = other\n            if n >= 0:\n                while total_seconds > 0:\n                    current_time = new_date.time()\n                    if current_time >= end_time or not self._is_on_offset(new_date):\n                        new_date = self._next_opening_time(new_date)\n                    else:\n                        next_opening = self._next_opening_time(new_date)\n                        time_diff = next_opening - new_date\n                        if time_diff.total_seconds() <= total_seconds:\n                            total_seconds -= time_diff.total_seconds()\n                            new_date = next_opening\n                        else:\n                            new_date += timedelta(seconds=total_seconds)\n                            total_seconds = 0\n            else:\n                while total_seconds > 0:\n                    current_time = new_date.time()\n                    if current_time <= start_time:\n                        new_date -= timedelta(seconds=1)\n                    if not self._is_on_offset(new_date):\n                        new_date = self._next_opening_time(new_date)\n                        new_date = self._get_closing_time(new_date)\n                    next_opening = self._next_opening_time(new_date)\n                    time_diff = next_opening - new_date\n                    if time_diff.total_seconds() <= total_seconds:\n                        total_seconds -= time_diff.total_seconds()\n                        new_date = next_opening\n                    else:\n                        new_date += timedelta(seconds=total_seconds)\n                        total_seconds = 0\n            \n            return new_date\n        else:\n            raise ApplyTypeError(\"Only know how to combine business hour with datetime\")",
            "import_list": []
        }
    ]
}