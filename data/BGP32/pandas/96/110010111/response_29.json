{
    "pandas": [
        {
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.2.1": 1,
                "1.4.2": 0,
                "1.2.2": 1,
                "1.5.1": 0,
                "1.5.2": 0,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.2.1": 0,
                "2.2.2": 0,
                "2.3.1": 1,
                "2.3.2": 1,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 1
            },
            "strata": {
                "1": 1,
                "2": 1,
                "3": 0,
                "4": 0,
                "5": 1,
                "6": 0,
                "7": 1,
                "8": 1,
                "9": 1
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 0,
                "1.3.1": 1,
                "1.3.2": 0,
                "1.4.1": 0,
                "1.2.1": 1,
                "1.4.2": 0,
                "1.2.2": 1,
                "1.5.1": 0,
                "1.5.2": 0,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.2.1": 0,
                "2.2.2": 0,
                "2.3.1": 1,
                "2.3.2": 1,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 1
            },
            "available_strata": {
                "1": 1,
                "2": 1,
                "3": 0,
                "4": 0,
                "5": 1,
                "6": 0,
                "7": 1,
                "8": 1,
                "9": 1
            },
            "bugID": 96,
            "start_line": 857,
            "file_name": "pandas/tseries/offsets.py",
            "replace_code": "def apply(self, other):\n    if isinstance(other, datetime):\n        bhour_remain = self.n * 60\n        if self.n < 0:\n            flipped_start = tuple(map(lambda t: datetime.time(24-t.hour, 60-t.minute, 60-t.second), self.start))\n            flipped_end = tuple(map(lambda t: datetime.time(24-t.hour, 60-t.minute, 60-t.second), self.end))\n            self.start = flipped_end\n            self.end = flipped_start\n\n        if other.time() in self.end or not self._is_on_offset(other):\n            before_hour = False\n            if other.time() in self.start:\n                other = other.replace(second=0, microsecond=0)\n                before_hour = True\n\n            if self.holidays and other.date() in self.holidays:\n                while np.busday_count(other.date(), other.date()) == 0 or other.weekday() > 4:\n                    other += timedelta(days=1)\n                other = datetime(other.year, other.month, other.day, 0, 0, 0)\n\n            business_hours = 0\n            for st, en in zip(self.start, self.end):\n                business_hours += (en.hour + en.minute / 60) - (st.hour + st.minute / 60)\n\n            bd, r = divmod(abs(bhour_remain), business_hours)\n\n            if self.n < 0:\n                bd = -bd\n                r = -r\n\n            if bd != 0:\n                other = self.next_bday.apply(other, bd, roll)\n                bhour_remain -= 60 * 24 * bd\n\n            if r != 0:\n                remain_seconds = r * 60\n                if r > 0:\n                    adjust_func = self._next_opening_time if before_hour else self._prev_opening_time\n                else:\n                    adjust_func = self._get_closing_time\n                while remain_seconds > 0:\n                    other = adjust_func(other)\n                    bhour_remain -= (other - adjust_func(other)).seconds\n                    if r > 0:\n                        bhour_remain = max(0, bhour_remain)\n                    elif r < 0:\n                        bhour_remain = min(0, bhour_remain)\n                    r, remain_seconds = divmod(bhour_remain, 60)\n        return other\n    else:\n        raise ApplyTypeError(\"Only know how to combine business hour with datetime\")",
            "import_list": []
        }
    ]
}