### Analysis:
The bug is related to the `apply` function within the `BusinessHourMixin` class in the `pandas/tseries/offsets.py` file. The function is responsible for applying business hours to a given datetime, but it seems to be incorrectly calculating business days and hours which leads to unexpected behavior when adding holidays.

### Error Location:
The bug seems to be related to the calculation of business days and hours within the `apply` function. Specifically, the adjustment of business days and remaining hours after factoring in holidays is likely causing the mismatch in the number of periods generated by `date_range`.

### Cause of the Bug:
The bug seems to be caused by incorrect adjustment of the datetime object `other` after considering holidays. This leads to an incorrect count of periods when calling `date_range` with a frequency based on the adjusted business hours.

### Fix Strategy:
To fix the bug, we need to adjust the logic of how business days and remaining hours are calculated after factoring in holidays. This adjustment should ensure the correct alignment of business hours without skipping or adding extra hours due to holidays.

### Corrected Version:
```python
# Import necessary packages

# Define the corrected apply function
@apply_wraps
def apply(self, other):
    if isinstance(other, datetime):
        if isinstance(other, date):
            raise ApplyTypeError("Only know how to combine business hour with datetime")

        n = self.n

        businesshours = sum(
            self._get_business_hours_by_sec(st, en)
            for st, en in zip(self.start, self.end)
        )

        adjustment = 0
        if self._is_on_offset(other):
            adjustment = 1

        total_minutes = abs(n * 60) - adjustment
        businessdays, remaining_minutes = divmod(total_minutes, businesshours // 60)

        if n < 0:
            businessdays = -businessdays
            remaining_minutes = -remaining_minutes

        # Adjust by business days first
        if businessdays != 0:
            other = self.next_bday(other, start=businessdays < 0, n=businessdays)

        # Remaining business hours to adjust
        bhour_remain = timedelta(minutes=remaining_minutes)

        while bhour_remain != timedelta(0):
            bhour = self._next_business_time_interval(other) - other
            if bhour_remain < bhour:
                other += bhour_remain
                bhour_remain = timedelta(0)
            else:
                bhour_remain -= bhour
                other = self._next_business_time_interval(other + bhour)

        return other
    else:
        raise ApplyTypeError("Only know how to combine business hour with datetime")
```

In the corrected version, the logic for adjusting business days and remaining business hours has been revised to ensure correct alignment and handling of holidays. This should resolve the issue reported on GitHub related to the unexpected behavior when using `date_range` with a frequency based on business hours and holidays.