The bug in the `_get_with` function arises from the incorrect handling of different key types, leading to incorrect inference of key types and subsequent incorrect indexing. The function fails to correctly identify the key type in various cases, leading to unexpected behavior.

To fix the bug:
1. Ensure that the key is correctly identified and its type is inferred accurately.
2. Handle different key types appropriately to enable correct indexing.

Here is the corrected version of the `_get_with` function:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)
    
    if not is_list_like(key):
        return self.loc[key]

    if not isinstance(key, (list, np.ndarray, ExtensionArray, Series, Index)):
        key = list(key)

    key_type = lib.infer_dtype(key, skipna=False)

    if key_type == "int":
        if not self.index._should_fallback_to_positional():
            return self.loc[key]
        else:
            return self.iloc[key]

    if isinstance(key, list):
        return self.loc[key]

    return self.reindex(key)
```

This corrected version ensures that the key type is correctly inferred and the indexing is done appropriately based on the key type. Make sure to test this corrected function with different input scenarios to validate its correctness.