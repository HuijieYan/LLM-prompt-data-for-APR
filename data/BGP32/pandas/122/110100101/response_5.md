The bug in the `equals` function arises due to the sorting logic based on the blocks' types and locations. The bug causes the function to erroneously return `False` in cases where the dataframes should be considered equal.

The strategy to fix the bug is to modify the `canonicalize` function to include the block's location information when generating the tuple for sorting. This will ensure that unconsolidated blocks are properly distinguished during sorting.

Here is the corrected version of the `equals` function:

```python
def equals(self, other):
    self_axes, other_axes = self.axes, other.axes
    if len(self_axes) != len(other_axes):
        return False
    if not all(ax1.equals(ax2) for ax1, ax2 in zip(self_axes, other_axes)):
        return False
    self._consolidate_inplace()
    other._consolidate_inplace()
    if len(self.blocks) != len(other.blocks):
        return False

    # canonicalize block order, using a tuple combining the type
    # name and then mgr_locs because there might be unconsolidated
    # blocks (say, Categorical) which can only be distinguished by
    # the iteration order
    def canonicalize(block):
        return (type(block).__name__, block.mgr_locs.as_array.tobytes())

    self_blocks = sorted(self.blocks, key=canonicalize)
    other_blocks = sorted(other.blocks, key=canonicalize)
    return all(
        block.equals(oblock) for block, oblock in zip(self_blocks, other_blocks)
    )
```

By incorporating the block's location information into the sorting tuple, the function will now correctly handle unconsolidated blocks and provide the expected result for the failing test.