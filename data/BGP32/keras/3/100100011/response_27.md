### Analysis:
The buggy function `_clone_functional_model` is responsible for cloning a functional Keras model. The bug occurs when the function tries to compute the output tensors of the model. The failing test case `test_clone_functional_model_with_multi_outputs` creates a complex model with multiple layers and outputs, which triggers the bug in the `_clone_functional_model` function.

### Identified Issue:
The issue lies in how the function handles multiple outputs from a layer that does not support masks. Specifically, when computing the output tensors and masks, the function assumes that all layers support masks, leading to an incorrect handling of the output masks.

### Cause of the Bug:
The bug is triggered when a layer that does not support masks is used in the model, resulting in None values being passed as output masks. This inconsistency in handling output masks causes the function to fail when trying to compute the output tensors.

### Bug Fix Strategy:
To fix the bug, the function `_clone_functional_model` needs to be modified to properly handle layers that do not support masks. This can be achieved by checking if the layer supports masks before attempting to compute the masks. If the layer does not support masks, the function should handle the situation without expecting valid masks.

### Bug Fixed Version:
```python
def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)
    if isinstance(model, Sequential):
        raise ValueError('Expected `model` argument to be a functional `Model` instance, got a `Sequential` instance instead:', model)

    layer_map = {}  
    tensor_map = {}  

    if input_tensors is None:
        input_layers = []
        input_tensors = []
        for layer in model._input_layers:
            input_tensor = Input(batch_shape=layer.batch_input_shape, dtype=layer.dtype, sparse=layer.sparse, name=layer.name)
            input_tensors.append(input_tensor)
            newly_created_input_layer = input_tensor._keras_history[0]
            layer_map[layer] = newly_created_input_layer

        for _original, _cloned in zip(model._input_layers, input_tensors):
            layer_map[_original] = _cloned
    else:
        input_tensors = to_list(input_tensors)
        _input_tensors = []
        for i, x in enumerate(input_tensors):
            if not K.is_keras_tensor(x):
                name = model._input_layers[i].name
                input_tensor = Input(tensor=x, name='input_wrapper_for_' + name)
                _input_tensors.append(input_tensor)
                original_input_layer = x._keras_history[0]
                newly_created_input_layer = input_tensor._keras_history[0]
                layer_map[original_input_layer] = newly_created_input_layer
            else:
                _input_tensors.append(x)
        input_tensors = _input_tensors

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)

    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            layer = node.outbound_layer

            if layer not in layer_map:
                new_layer = layer.__class__.from_config(layer.get_config())
                layer_map[layer] = new_layer
                layer = new_layer
            else:
                layer = layer_map[layer]
                if isinstance(layer, InputLayer):
                    continue

            reference_input_tensors = node.input_tensors
            reference_output_tensors = node.output_tensors

            computed_data = []
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                if node.arguments:
                    kwargs = node.arguments
                else:
                    kwargs = {}
                computed_tensors = [x[0] for x in computed_data]
                output_tensors = to_list(layer(computed_tensors, **kwargs))

                for x, y in zip(reference_output_tensors, output_tensors):
                    tensor_map[x] = (y, None)

    output_tensors = []
    for x in model.outputs:
        assert x in tensor_map, 'Could not compute output ' + str(x)
        tensor, _ = tensor_map[x]
        output_tensors.append(tensor)
    return Model(input_tensors, output_tensors, name=model.name)
```

By updating the `_clone_functional_model` function as shown above, the bug related to computing output tensors with multiple outputs and layers that do not support masks should be resolved. This corrected version should now pass the failing test case `test_clone_functional_model_with_multi_outputs` and address the issue reported on GitHub.