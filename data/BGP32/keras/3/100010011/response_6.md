### Analysis:
Based on the error message and the information from the GitHub issue, the problem seems to be related to the handling of models with multiple outputs which don't support masks. The error occurs when trying to clone a model with a layer that has multiple outputs where mask support is missing.

### Bug Cause:
1. The `assert` statement in the `_clone_functional_model` function raises an error when trying to compute the output tensor of a layer that doesn't support masks.

### Fix Strategy:
1. Modify the code to ignore the computation of masks if the layer doesn't support masks when handling multiple inputs.
2. Handle the case where multiple outputs are generated by a layer without mask support.

### Corrected Version:
```python
from keras.engine.topology import Layer
from keras.models import Model
from keras.layers import Input

def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)
    if isinstance(model, Sequential):
        raise ValueError('Expected `model` argument to be a functional `Model` instance, got a `Sequential` instance instead:', model)

    layer_map = {}
    tensor_map = {}

    if input_tensors is None:
        # Create placeholders
        input_tensors = [Input(batch_shape=layer.batch_input_shape,
                                dtype=layer.dtype,
                                sparse=layer.sparse,
                                name=layer.name)
                         for layer in model._input_layers]

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)

    for depth in sorted(model._nodes_by_depth.keys(), reverse=True):
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            layer = node.outbound_layer

            if layer not in layer_map:
                new_layer = layer.__class__.from_config(layer.get_config())
                layer_map[layer] = new_layer
                layer = new_layer
            else:
                layer = layer_map[layer]
                if isinstance(layer, Layer):
                    continue

            reference_input_tensors = node.input_tensors
            reference_output_tensors = node.output_tensors

            computed_data = []
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                kwargs = node.arguments if node.arguments is not None else {}
                computed_tensors = [x[0] for x in computed_data]
                output_tensors = to_list(layer(computed_tensors, **kwargs))
                for x, y in zip(reference_output_tensors, output_tensors):
                    tensor_map[x] = (y, None)

    output_tensors = []
    for x in model.outputs:
        assert x in tensor_map, 'Could not compute output ' + str(x)
        tensor, _ = tensor_map[x]
        output_tensors.append(tensor)

    return Model(input_tensors, output_tensors, name=model.name)
``` 

With this corrected version of the `_clone_functional_model` function, the issue of failing to clone a model with layers that have multiple outputs without mask support should be resolved.