The bug in the provided function seems to be related to the conditionals for checking if the table exists in the specified database.

The potential error locations within the function are:
1. The condition `return stdout and table in stdout` might not work as expected, especially if the table name is not unique or if the stdout contains other similar table names.

2. The condition `if stdout:` and `else` statement for returning `True` or `False` might not properly handle the stdout response from the `run_hive_cmd` function.

The cause of the bug is the incorrect handling of the stdout response from the external `run_hive_cmd` function, and the ambiguity in determining if the table exists based on the stdout content.

A strategy for fixing the bug is to modify the conditionals to more accurately check for the existence of the table based on the stdout response. Also, parsing the stdout response to accurately determine if the table exists is necessary.

Here's the corrected version of the function:

```python
def table_exists(self, table, database='default', partition=None):
    if partition is None:
        stdout = run_hive_cmd('use {0}; show tables like "{1}";'.format(database, table))
        tables = stdout.split('\n')
        return table in tables

    else:
        stdout = run_hive_cmd("""use %s; show partitions %s partition
                            (%s)""" % (database, table, self.partition_spec(partition)))
        partitions = stdout.split('\n')
        return bool(partitions)
```

In the corrected version, for the case where `partition` is `None`, the stdout response is split into individual table names, and the existence of the specified table is determined using `table in tables`. For the case where `partition` is not `None`, the stdout response is split into individual partition names, and the existence of any partitions is checked using `bool(partitions)`.