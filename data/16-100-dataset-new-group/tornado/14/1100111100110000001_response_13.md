The bug in the given function lies in the way it handles the 'make_current' parameter in the initialize function of the IOLoop class. The specific issue is with the comparison `if IOLoop.current(instance=False) is None`. If 'make_current' is True, then there is an incorrect comparison, leading to the RuntimeError "current IOLoop already exists".

A potential strategy for fixing this bug is to change the comparison condition for 'make_current' and ensure that the correct method is called based on the value of 'make_current'.

Here's the corrected version of the function:

```python
class IOLoop(Configurable):
    def initialize(self, make_current=None):
        if make_current is None:
            if IOLoop.current(instance=False) is None:
                self.make_current()
        elif make_current is True:
            if IOLoop.current(instance=False) is not None:
                raise RuntimeError("current IOLoop already exists")
            self.make_current()
```

In the corrected version, the condition for `make_current` has been changed to `elif make_current is True` and the comparison inside the block has been updated to check if the current IOLoop is not None. This will ensure that the make_current method is correctly called based on the value of the 'make_current' parameter.