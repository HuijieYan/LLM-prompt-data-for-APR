The issue seems to be related to the behavior of the `initialize` function in the `IOLoop` class. The problem is that the function is checking if the current `IOLoop` instance is None, and if it is not None, it raises an error. This behavior seems contradictory and is causing confusion.

The `initialize` function is supposed to set the current `IOLoop` instance, and the `make_current` argument is used to control whether the new `IOLoop` should become the current one or not.

The issue arises because the function first checks if the current `IOLoop` instance is None, and then based on the value of `make_current`, it either sets the current `IOLoop` or raises an error. However, if the current value is not None, then the function should not raise an error, regardless of the value of `make_current`.

To fix this issue, we should remove the check for the current `IOLoop` instance being None and only raise an error if `make_current` is True and there is already a current instance.

Below is the corrected version of the `initialize` function:

```python
class IOLoop(Configurable):

    # ... (other class methods)

    def initialize(self, make_current=None):
        if make_current is None:
            self.make_current()
        elif make_current:
            if IOLoop.current(instance=False) is not None:
                raise RuntimeError("current IOLoop already exists")
            else:
                self.make_current()
```

In the corrected version, we removed the check for the current `IOLoop` instance being None and always call `self.make_current()`. If `make_current` is True, we then check if the current instance is not None and only then raise an error. This should resolve the issue reported in the GitHub thread.