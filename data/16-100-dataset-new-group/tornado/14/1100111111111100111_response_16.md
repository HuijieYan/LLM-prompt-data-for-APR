### Bug Explanation:
The `initialize` function of the `IOLoop` class is designed to initialize the IOLoop and set it as the current IOLoop if `make_current` is set to `True`. However, the bug causes the function to erroneously raise a `RuntimeError` even when the current IOLoop does not exist.

The issue relates to the incorrect handling of `make_current` and the condition to raise a `RuntimeError`.

### Bug Location:
The bug is located in the `initialize` function of the `IOLoop` class, particularly in the conditional statements that handle the `make_current` parameter.

### Bug Cause:
The cause of the bug is an incorrect condition in the `initialize` function. The condition checks whether the current IOLoop is None when `make_current` is True, and if so, raises a `RuntimeError`. However, it should only raise a `RuntimeError` if the current IOLoop exists and `make_current` is True. This is the cause of the incorrect behavior observed in the failing test.

### Bug Fix Strategy:
The bug can be fixed by updating the conditional statements in the `initialize` function to accurately handle the `make_current` parameter and the state of the current IOLoop.

### Corrected Version:
```python
class IOLoop(Configurable):
    # other functions...

    # Corrected initialize function
    def initialize(self, make_current=None):
        if make_current is None:
            if IOLoop.current(instance=False) is None:
                self.make_current()
        elif make_current:
            if IOLoop.current(instance=False) is not None:  # Check if current IOLoop exists
                raise RuntimeError("current IOLoop already exists")
            self.make_current()
```

In the corrected version, the condition for raising a `RuntimeError` has been updated to check if the current IOLoop exists when `make_current` is True, which resolves the bug and ensures the function behaves as intended.