### Explanation
The buggy function `initialize` is used to initialize the `IOLoop` instance. The issue arises when the `make_current` parameter is set to `True` and `IOLoop.current(instance=False)` is `None`, it still raises a runtime error "current IOLoop already exists".

The cause of the bug is that when `make_current` is set to `True`, it should first check if `IOLoop.current(instance=False)` is `None` or not. If it is `None`, then it should make the current `IOLoop` using `self.make_current()`, otherwise raise the runtime error.

### Bug Fix Strategy
To fix this bug, we need to modify the conditional statements in the `initialize` function. If `make_current` is `True`, it should first check if the current `IOLoop` exists by calling `IOLoop.current(instance=False)`. If it does not exist, then `self.make_current()` can be called to make it the current `IOLoop`. If it does exist, then raise the runtime error.

### Corrected Version
```python
def initialize(self, make_current=None):
    if make_current is None:
        if IOLoop.current(instance=False) is None:
            self.make_current()
    elif make_current:
        if IOLoop.current(instance=False) is not None:
            raise RuntimeError("current IOLoop already exists")
        self.make_current()
```