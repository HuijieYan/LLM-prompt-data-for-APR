The buggy function `initialize` in the `IOLoop` class is causing a `RuntimeError` because the condition to check if the current IOLoop already exists is not being handled correctly. When calling `IOLoop.make_current()`, it is not authenticating the current loop before attempting to create a new one, leading to the `RuntimeError` as the current IOLoop already exists.

To fix this bug, we need to properly check for the existence of the current IOLoop before making a new one. We should also pass the `self` instance when calling the `IOLoop.current()` and `IOLoop.make_current()` methods.

Here's the corrected version of the function:

```python
def initialize(self, make_current=None):
    if make_current is None:
        if IOLoop.current(self) is None:
            self.make_current()
    elif make_current:
        if IOLoop.current(self) is not None:
            raise RuntimeError("current IOLoop already exists")
        self.make_current()
```

With this modified `initialize` function, it checks if the current loop exists before making a new one, and it authenticates the current loop before attempting to create a new one. This fix should ensure that the failing test case `test_force_current` will pass successfully.