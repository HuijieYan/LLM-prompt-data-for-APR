To fix the bug in the `initialize` function of the `IOLoop` class, we need to ensure that the check for the current instance is done correctly. Based on the error message and the failing test, it seems that the condition to check if the current IOLoop already exists is not functioning as expected.

Looking at the code, it appears that the issue might be with the logic inside the `initialize` function. It checks whether the current instance is None, and if it is not None, it raises a `RuntimeError` indicating that the current IOLoop already exists. This is contradictory to the actual intention of the condition.

The failing test `test_force_current` passes `make_current=True` as an argument, indicating that the IOLoop instance should be made the current one. However, the current logic is incorrectly raising an error even when `make_current=True`.

To fix this bug, we need to ensure that when `make_current=True`, the instance should become the current instance without raising an error.

Here's the corrected version of the `initialize` function:

```python
def initialize(self, make_current=None):
    if make_current is None:
        if IOLoop.current(instance=False) is None:
            self.make_current()
    elif make_current:
        self.make_current()
```

In this corrected version, we remove the check for `IOLoop.current(instance=False) is None` inside the `elif` block, and we simply call `self.make_current()` when `make_current` is `True` without raising an error. This will ensure that when `make_current=True`, the instance becomes the current IOLoop without any issues.

This correction should resolve the bug and make the failing test pass.

Also, this correction addresses the issue reported on GitHub where the discrepancy between the check for the current IOLoop and the raised error is observed.