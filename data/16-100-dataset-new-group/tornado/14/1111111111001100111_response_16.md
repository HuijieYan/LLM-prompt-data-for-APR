## Bug Explanation
The buggy function `initialize` is intended to initialize an IOLoop instance and optionally make it the current instance. The issue arises when the `make_current` argument is set to `True`, but the `IOLoop.current` is already not None, causing the function to incorrectly throw a `RuntimeError`.

The bug is in the conditional logic inside the `initialize` function. When `make_current` is set to `True`, the function should check if a current IOLoop instance exists and then make the new IOLoop instance the current one. However, the current implementation fails to handle this scenario correctly, resulting in the `RuntimeError` being raised when it is not supposed to.

## Bug Fix Strategy
To fix the bug in the `initialize` function, the logic for handling the `make_current` argument needs to be adjusted. Specifically, when `make_current` is `True`, the function should only raise a `RuntimeError` if there is already a current IOLoop instance. Otherwise, it should proceed to make the new instance the current one.

The fixed version of the `initialize` function should properly handle the scenario where `make_current` is `True` and a current IOLoop instance already exists.

## Corrected Code
```python
def initialize(self, make_current=None):
    current_instance = IOLoop.current(instance=False)
    if make_current is None:
        if current_instance is None:
            self.make_current()
    elif make_current:
        if current_instance is not None:
            raise RuntimeError("current IOLoop already exists")
        self.make_current()
```

With this corrected logic, the `initialize` function properly checks for the existence of a current IOLoop instance and raises a `RuntimeError` only when appropriate.