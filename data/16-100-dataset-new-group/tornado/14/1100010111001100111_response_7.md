## Explanation
The buggy function `initialize` checks if the current IOLoop instance exists and then either calls `make_current()` or raises a `RuntimeError`. The failing test `test_force_current` creates an IOLoop instance with `make_current=True`, and then attempts to create another IOLoop instance with `make_current=True`, expecting a `RuntimeError` to be raised. However, the test fails, indicating a bug in the `initialize` function.

The bug occurs because the `initialize` function does not correctly handle the case when `make_current=True` and an IOLoop instance already exists.

## Bug Fix Strategy
To fix the bug, the `initialize` function needs to be modified to properly handle the case when `make_current=True` and an IOLoop instance already exists. This can be achieved by checking if an instance already exists before attempting to make it current. If it already exists, then a `RuntimeError` should be raised.

## The corrected version of the function
```python
def initialize(self, make_current=None):
    current_instance = IOLoop.current(instance=False)
    if make_current is None:
        if current_instance is None:
            self.make_current()
    elif make_current:
        if current_instance is not None:
            raise RuntimeError("current IOLoop already exists")
        self.make_current()
```

With this corrected version, the `initialize` function should correctly handle the case when `make_current=True` and an IOLoop instance already exists, and the failing test `test_force_current` should pass.