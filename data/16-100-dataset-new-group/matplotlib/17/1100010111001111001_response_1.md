The bug in the function seems to be related to the conditions for determining whether to expand the input range and the swapping of the vmin and vmax values. Based on the failing tests, the bug appears to arise from the inconsistencies in how the function handles input values and calculates the maxabsvalue.

To fix the bug, we should adjust the condition for determining when to expand the input range and ensure that the swapping process is consistent. 

Here's the corrected version of the function which should satisfy all the failing test cases:

```python
def nonsingular(vmin, vmax, expander=0.001, tiny=1e-15, increasing=True):
    if (not np.isfinite(vmin)) or (not np.isfinite(vmax)):
        return -expander, expander
    
    swapped = False
    if increasing and vmax < vmin:
        vmin, vmax = vmax, vmin
        swapped = True
    elif not increasing and vmin < vmax:
        vmin, vmax = vmax, vmin
        swapped = True

    maxabsvalue = max(abs(vmin), abs(vmax))
    if (not increasing and vmax - vmin <= maxabsvalue * tiny) or (increasing and vmax - vmin < maxabsvalue * tiny):
        if vmax == 0 and vmin == 0:
            vmin = -expander
            vmax = expander
        else:
            vmin -= expander*abs(vmin)
            vmax += expander*abs(vmax)

    if swapped:
        vmin, vmax = vmax, vmin

    return vmin, vmax
```