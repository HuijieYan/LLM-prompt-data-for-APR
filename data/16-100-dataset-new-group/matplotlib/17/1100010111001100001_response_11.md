The issue with the given `nonsingular` function is that it fails to adjust the endpoints correctly, which results in failing the test cases. The problem arises from the condition checks and the improper handling of swapped endpoints.

The bug arises from incorrect condition checks and handling of swapped values. The function should ensure that `vmin` and `vmax` never become too close or go beyond the interval, which it currently fails to do.

To fix the issue, the following changes should be made to the `nonsingular` function:
- Swap `vmin` and `vmax` regardless of `increasing` when `vmin` is greater than `vmax`.
- Update the condition checks for when the interval is smaller than the set threshold, to ensure that both endpoints are appropriately adjusted.

Here's the corrected version of the `nonsingular` function:

```python
def nonsingular(vmin, vmax, expander=0.001, tiny=1e-15, increasing=True):
    if (not np.isfinite(vmin)) or (not np.isfinite(vmax)):
        return -expander, expander

    swapped = False
    if vmin > vmax:
        vmin, vmax = vmax, vmin
        swapped = True

    maxabsvalue = max(abs(vmin), abs(vmax))
    if maxabsvalue < (1e6 / tiny) * np.finfo(float).tiny:
        vmin = -expander
        vmax = expander

    elif vmax - vmin <= maxabsvalue * tiny:
        # Adjust the endpoints to ensure they are not too close
        vmin = vmin - expander
        vmax = vmax + expander

    if swapped:
        # Swap back the values irrespective of increasing
        vmin, vmax = vmax, vmin

    return vmin, vmax
```

With these changes, the `nonsingular` function should now handle the endpoints and swapped values correctly for the given test cases.