The issue with the `nonsingular` function is that it does not correctly handle the input parameters and fails to avoid singularities as intended. Specifically, the function returns the original unmodified endpoints instead of expanding them when the interval is too small.

The strategy to fix the bug will be to modify the logic in the `nonsingular` function to properly handle scenarios where the interval is too small or when the inputs are inf or NaN. Additionally, we need to ensure that the function correctly handles the scenarios where the endpoints need to be swapped and that the scaling is performed appropriately.

Here's the corrected version of the `nonsingular` function:

```python
def nonsingular(vmin, vmax, expander=0.001, tiny=1e-15, increasing=True):
    if (not np.isfinite(vmin)) or (not np.isfinite(vmax)) or (vmin == vmax) or (vmin == -vmax):
        if (vmin == 0 and vmax == 0) or (vmin == -vmax):
            return -expander, expander

    if increasing and vmin > vmax:
        vmin, vmax = vmax, vmin

    maxabsvalue = max(abs(vmin), abs(vmax))
    if maxabsvalue < (1e6 / tiny) * np.finfo(float).tiny:
        vmin = -expander
        vmax = expander

    elif vmax - vmin <= maxabsvalue * tiny:
        vmin -= expander*abs(vmin)
        vmax += expander*abs(vmax)

    return vmin, vmax
```

In the corrected version, we first check for cases where the inputs are not finite, or when the endpoints are equal or opposite. If any of these conditions are met, we return the expanded range as required.

We also handle the case where the increasing parameter is True and the vmin is greater than vmax. In such a scenario, the vmin and vmax are swapped.

Finally, we perform the necessary expansion on the vmin and vmax based on the tiny and expander values.

The corrected `nonsingular` function should now pass the failing test cases provided.