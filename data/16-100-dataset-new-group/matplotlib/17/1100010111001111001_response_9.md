To fix the buggy function, we will address the discrepancies between the buggy function's calculations and the expected outcomes. 
The issue in the function results from the incorrect handling of comparisons and adjustments of *vmin* and *vmax*. Based on the runtime inputs and outputs, it is clear that the `nonsingular` function mishandles the expansion and swapping of the endpoints, leading to incorrect results. 

Here is the corrected version of the `nonsingular` function:

```python
def nonsingular(vmin, vmax, expander=0.001, tiny=1e-15, increasing=True):
    if (not np.isfinite(vmin)) or (not np.isfinite(vmax)):
        return -expander, expander

    if increasing:
        if vmin > vmax:
            vmin, vmax = vmax, vmin

        if abs(vmax - vmin) < max(abs(vmin), abs(vmax)) * tiny:
            if vmax == 0 and vmin == 0:
                return -expander, expander
            else:
                vmin -= expander * abs(vmin)
                vmax += expander * abs(vmax)
    else:
        if vmin < vmax:
            vmin, vmax = vmax, vmin

        if abs(vmax - vmin) < max(abs(vmin), abs(vmax)) * tiny:
            if vmax == 0 and vmin == 0:
                return -expander, expander
            else:
                vmin -= expander * abs(vmin)
                vmax += expander * abs(vmax)
    return vmin, vmax
```

Now the corrected `nonsingular` function should pass the provided failing test cases and satisfy the expected input/output values.