The issue with the current `nonsingular` function is that it fails to correctly handle the given input values, especially when dealing with very large or very small values. 

To fix this, we can make the following adjustments:
- When the inputs are infinite (`inf` or `-inf`), we should return (-expander, expander).
- If the difference between `vmax` and `vmin` is less than a specific threshold (`tiny`), then we should expand both `vmin` and `vmax` by adding `expander` to `vmax` and subtracting `expander` from `vmin`. However, if both inputs are zero or very close to zero, we should return (-expander, expander).
- We also need to handle the case where `vmax` is less than `vmin` by swapping their values.
- Finally, we need to check if `increasing` is `False` and if so, swap `vmin` and `vmax`.

Here's the corrected version of the `nonsingular` function:

```python
def nonsingular(vmin, vmax, expander=0.001, tiny=1e-15, increasing=True):
    if (not np.isfinite(vmin)) or (not np.isfinite(vmax)):
        return -expander, expander

    swapped = False
    if vmax < vmin:
        vmin, vmax = vmax, vmin
        swapped = True

    if vmax - vmin <= tiny:
        if vmax == 0 and vmin == 0:
            return -expander, expander
        else:
            vmin -= expander*abs(vmin)
            vmax += expander*abs(vmax)
            
    if swapped and not increasing:
        vmin, vmax = vmax, vmin
    return vmin, vmax
```

This corrected function should now handle all the edge cases mentioned and should pass the failing tests.