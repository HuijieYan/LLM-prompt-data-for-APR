To address the reported bugs, the `nonsingular` function needs a fix. The mentioned error message "RuntimeWarning: overflow encountered in scalar subtract" and "RuntimeWarning: overflow encountered in scalar absolute" indicate that the function is encountering an overflow due to certain calculations. The problem appears to be in the computation of `maxabsvalue = max(abs(vmin), abs(vmax))` with the input values causing issues when computing the absolute value of `int16` variables. 

The primary strategy would be to convert the input parameters, `vmin` and `vmax`, to floats before applying any arithmetic operations. This approach would resolve the issue of attempting to take the absolute value of an integer type that leads to overflow. Also, there is no need to swap `vmin` and `vmax` when making these transformations.

Below is the corrected version of the `nonsingular` function:

```python
def nonsingular(vmin, vmax, expander=0.001, tiny=1e-15, increasing=True):
    if (not np.isfinite(vmin)) or (not np.isfinite(vmax)):
        return -expander, expander

    vmin, vmax = float(vmin), float(vmax)

    maxabsvalue = max(abs(vmin), abs(vmax))
    if maxabsvalue < (1e6 / tiny) * np.finfo(float).tiny:
        vmin = -expander
        vmax = expander
    elif vmax - vmin <= maxabsvalue * tiny:
        if vmax == 0.0 and vmin == 0.0:
            vmin = -expander
            vmax = expander
        else:
            vmin -= expander*abs(vmin)
            vmax += expander*abs(vmax)

    return vmin, vmax
```
After making these adjustments, the `nonsingular` function should no longer encounter overflows, and it will correctly handle both float and int16 types as inputs.