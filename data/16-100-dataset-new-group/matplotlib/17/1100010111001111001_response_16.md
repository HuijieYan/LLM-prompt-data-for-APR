The bug seems to be in the logic that modifies the endpoints `vmin` and `vmax`. When modifying the endpoints, the condition to check if the interval is too small and needs to be expanded might not be working correctly. Additionally, the swapping logic when `vmax` is less than `vmin` may be incorrect in some cases.

The function should be fixed by adjusting the condition that checks for too small intervals and updating the swap condition logic. Here's the corrected version of the function:

```python
def nonsingular(vmin, vmax, expander=0.001, tiny=1e-15, increasing=True):
    if (not np.isfinite(vmin)) or (not np.isfinite(vmax)):
        return -expander, expander

    swapped = False
    if vmax < vmin and increasing:
        vmin, vmax = vmax, vmin
        swapped = True

    maxabsvalue = max(abs(vmin), abs(vmax))
    if vmax - vmin <= maxabsvalue * tiny:
        if vmax == 0 and vmin == 0:
            vmin = -expander
            vmax = expander
        else:
            vmin -= expander
            vmax += expander

    if swapped and not increasing:
        vmin, vmax = vmax, vmin
    return vmin, vmax
```

This corrected version should pass all the failing test cases provided and should satisfy the expected input/output values.