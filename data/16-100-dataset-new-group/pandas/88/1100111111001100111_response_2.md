The issue seems to be caused by the _pivot_table_ function when handling multi-index columns. It encounters an _AttributeError_ when trying to access _table.columns_ with _table_ being a _Series_ object instead of a _DataFrame_.

The bug may be due to the generation of a _Series_ object instead of a _DataFrame_ when handling multi-index columns, leading to the failure.

To fix this bug, a conditional check can be introduced to determine whether the output should be transposed to make it consistent in all cases. Additionally, within the conditional check, table should be handled as a _Series_ correctly, and in the following conditional checks for multi-level constructors, the data may be inadvertently manipulated when it should not be.

Here's the corrected version of the _pivot_table_ function:

```python
# Corrected pivot_table function
from pandas import MultiIndex, Index
from pandas.core.reshape.util import CartesianProduct
from pandas.core.reshape.concat import _concat, _concat_same_type
from pandas._typing import Axis, DType

def pivot_table(
    data,
    values=None,
    index=None,
    columns=None,
    aggfunc="mean",
    fill_value=None,
    margins=False,
    dropna=True,
    margins_name="All",
    observed=False,
) -> "DataFrame":
    ...
    # (existing code)
    ...

    if len(index) == 0 and len(columns) > 0:
        table = table.T

    if isinstance(table, ABCDataFrame):
        if fill_value is not None:
            filled = table.fillna(fill_value, downcast="infer")
            table = filled._ensure_type(filled)
    
        if margins:
            if dropna:
                data = data[data.notna().all(axis=1)]
            table = _add_margins(
                table,
                data,
                values,
                rows=index,
                cols=columns,
                aggfunc=aggfunc,
                observed=observed,
                margins_name=margins_name,
                fill_value=fill_value,
            )
        
        if dropna:
            table = table.dropna(how="all", axis=1)

        table = table.sort_index(axis=1)

    else:  # Handle symmetric cases
        if dropna:
            keys_levels = cartesian_product([index, columns], traverse_column=False)
            table = pivot_table(
                data,
                values=values,
                index=Index(keys_levels[1]),
                columns=MultiIndex.from_arrays(keys_levels[:2], names=index + columns),
                aggfunc=aggfunc,
                fill_value=fill_value,
                margins=margins,
                dropna=dropna,
                margins_name=margins_name,
                observed=observed,
            )

    return table
```

With this corrected version, the logic to handle _Series_ and _DataFrames_ is separated and managed accordingly. Additionally, it accounts for the symmetric cases with multi-index columns, facilitating consistent handling across all scenarios.