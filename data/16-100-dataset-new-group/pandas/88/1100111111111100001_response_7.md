The root cause of the bug seems to be that the function is recursively calling itself without updating the input parameters. This recursive call is unnecessary and leads to incorrect output. The function should instead utilize a loop over the `aggfunc` list to compute the required pivot tables and concatenate them at the end.

To fix the bug, we should eliminate the unnecessary recursive call within the `if isinstance(aggfunc, list):` block and replace it with a loop over `aggfunc` to compute the separate pivot tables and then concatenate these tables using `concat` function.

Here's the corrected version of the `pivot_table` function:

```python
import pandas as pd
from pandas import DataFrame
from typing import List

def pivot_table(
    data: DataFrame,
    values=None,
    index=None,
    columns=None,
    aggfunc="mean",
    fill_value=None,
    margins=False,
    dropna=True,
    margins_name="All",
    observed=False
) -> "DataFrame":
    index = _convert_by(index)
    columns = _convert_by(columns)

    if isinstance(aggfunc, list):
        pieces: List[DataFrame] = []
        keys = []
        for func in aggfunc:
            grouped = data.groupby(keys, observed=observed)
            agged = grouped.agg(func)

            if dropna and isinstance(agged, pd.DataFrame) and len(agged.columns):
                agged = agged.dropna(how="all")

                for v in values:
                    if (
                        v in data
                        and is_integer_dtype(data[v])
                        and v in agged
                        and not is_integer_dtype(agged[v])
                    ):
                        agged[v] = maybe_downcast_to_dtype(agged[v], data[v].dtype)

            table = agged
            if table.index.nlevels > 1:
                index_names = agged.index.names[: len(index)]
                to_unstack = []
                for i in range(len(index), len(keys)):
                    name = agged.index.names[i]
                    if name is None or name in index_names:
                        to_unstack.append(i)
                    else:
                        to_unstack.append(name)
                table = agged.unstack(to_unstack)

            pieces.append(table)
            keys.append(func)

        return pd.concat(pieces, keys=keys, axis=1)

    # ... original code for non-list aggfunc

    return table
```

In the corrected version, the function no longer calls itself. Instead, it initializes a list `pieces` to store the separate pivot tables and a list `keys` to store the names of the aggregation functions. Inside the loop over `aggfunc`, it computes the separate pivot tables and appends them to the `pieces` list with the corresponding key. Finally, it concatenates the tables using `pd.concat` and returns the result.