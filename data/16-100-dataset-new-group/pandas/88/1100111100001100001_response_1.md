The cause of the bug in the `pivot_table` function is that it recursively calls itself within a loop to calculate the pivot tables for each function in the `aggfunc` list. This recursive call does not account for the effect of the previous calls, leading to incorrect results.

To fix the bug, we need to refactor the code to handle the aggregation functions in a non-recursive way, ensuring that the dataframe is appropriately updated after each function call.

Below is the corrected version of the `pivot_table` function:

```python
def pivot_table(
    data,
    values=None,
    index=None,
    columns=None,
    aggfunc="mean",
    fill_value=None,
    margins=False,
    dropna=True,
    margins_name="All",
    observed=False,
) -> "DataFrame":
    if isinstance(aggfunc, list):
        agg_results = {}
        for func in aggfunc:
            grouped = data.groupby(index + columns, observed=observed)
            agged = grouped.agg(func)
            if dropna and isinstance(agged, ABCDataFrame) and len(agged.columns):
                agged = agged.dropna(how="all")
            agg_results[func.__name__] = agged

        result_table = DataFrame(agg_results)
        if margins:
            if dropna:
                data = data[data.notna().all(axis=1)]
            result_table = _add_margins(
                result_table,
                data,
                values,
                rows=index,
                cols=columns,
                aggfunc=aggfunc,
                observed=observed,
                margins_name=margins_name,
                fill_value=fill_value,
            )
    else:
        grouped = data.groupby(index + columns, observed=observed)
        result_table = grouped.agg(aggfunc)
        if dropna and isinstance(result_table, ABCDataFrame) and len(result_table.columns):
            result_table = result_table.dropna(how="all")
        if margins:
            if dropna:
                data = data[data.notna().all(axis=1)]
            result_table = _add_margins(
                result_table,
                data,
                values,
                rows=index,
                cols=columns,
                aggfunc=aggfunc,
                observed=observed,
                margins_name=margins_name,
                fill_value=fill_value,
            )

    return result_table
```

In this corrected version, I removed the recursive call and aggregated the results for each function in the `aggfunc` list separately. This ensures that each function is applied to the original `data` and the results are then combined into a single dataframe `result_table`.