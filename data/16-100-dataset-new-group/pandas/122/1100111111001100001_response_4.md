The bug in the provided equals function is that it is not correctly comparing the blocks of two BlockManagers. The function is supposed to check for equality of axes and blocks between self and other BlockManagers, but it is not correctly implementing the comparison logic.

The strategy for fixing the bug would be to ensure that the comparison logic for axes and blocks is correctly implemented. This would involve checking the equality of axes, consolidating the BlockManagers, and then comparing the blocks one by one.

Here is the corrected version of the buggy function:

```python
def equals(self, other):
    self_axes, other_axes = self.axes, other.axes
    if len(self_axes) != len(other_axes):
        return False
    if not all(ax1.equals(ax2) for ax1, ax2 in zip(self_axes, other_axes)):
        return False
    
    self._consolidate_inplace()
    other._consolidate_inplace()
    
    if len(self.blocks) != len(other.blocks):
        return False

    self_blocks = sorted(self.blocks, key=lambda block: (block.dtype.name, block.mgr_locs.as_array))
    other_blocks = sorted(other.blocks, key=lambda block: (block.dtype.name, block.mgr_locs.as_array))

    return all(block.equals(oblock) for block, oblock in zip(self_blocks, other_blocks))
```

This corrected version properly checks the equality of axes and then compares the sorted blocks of the two BlockManagers.

With this corrected version, the provided test function `test_dataframe_not_equal` should pass.