The error message indicates that the `equals` method is returning True when it should be returning False. This occurs in the `test_dataframe_not_equal` function, where we expect `df1.equals(df2)` to be False, but it's evaluating to True.

The bug is likely in the `canonicalize` function, where it is trying to compare the block types and locations, but the comparison might not be handling certain cases properly, resulting in incorrect evaluations. 

To fix the bug, we can modify the `canonicalize` function to remove the comparison of block locations and only compare the block types. This will make the equal function work correctly for the given test case.

Here's the corrected version of the function:

```python
def equals(self, other):
    self_axes, other_axes = self.axes, other.axes
    if len(self_axes) != len(other_axes):
        return False
    if not all(ax1.equals(ax2) for ax1, ax2 in zip(self_axes, other_axes)):
        return False
    self._consolidate_inplace()
    other._consolidate_inplace()
    if len(self.blocks) != len(other.blocks):
        return False

    # canonicalize block order, using the type name only
    def canonicalize(block):
        return block.dtype.name

    self_blocks = sorted(self.blocks, key=canonicalize)
    other_blocks = sorted(other.blocks, key=canonicalize)
    return all(
        block.equals(oblock) for block, oblock in zip(self_blocks, other_blocks)
    )
```

The `canonicalize` function now only compares the type name of the block, and the sorted blocks are used for the final comparison, which should resolve the bug.