The bug in the `equals` function seems to be related to the comparison of the `self.blocks` and `other.blocks` tuples. The comparison is not taking into account the order of the blocks, which is causing the function to return incorrect results.

The strategy for fixing this bug would be to sort the blocks in both `self.blocks` and `other.blocks` tuples based on their type names and `mgr_locs`, and then compare them. This will ensure that the comparison takes into account the order of the blocks.

Here's the corrected version of the `equals` function:

```python
def equals(self, other):
    self_axes, other_axes = self.axes, other.axes
    if len(self_axes) != len(other_axes):
        return False
    if not all(ax1.equals(ax2) for ax1, ax2 in zip(self_axes, other_axes)):
        return False
    self._consolidate_inplace()
    other._consolidate_inplace()
    if len(self.blocks) != len(other.blocks):
        return False

    # Sorting the blocks based on type name and mgr_locs
    def block_key(block):
        return block.dtype.name, block.mgr_locs.as_array.tolist()

    self_blocks = sorted(self.blocks, key=block_key)
    other_blocks = sorted(other.blocks, key=block_key)
    
    return all(
        block.equals(oblock) for block, oblock in zip(self_blocks, other_blocks)
    )
```

This correction ensures that the comparison of blocks takes into account their order, thus resolving the issue reported on GitHub.