The issue in the `equals` function is that it mistakenly concludes that two dataframes are equal, even if their blocks are in different locations. This is because the function only compares the contents of the blocks without considering their locations, resulting in a false positive for equality.

To fix this bug, the `equals` function logic needs to be updated to consider the block locations as well while comparing the dataframes.

Here's the corrected version of the `equals` function:

```python
def equals(self, other):
    self_axes, other_axes = self.axes, other.axes
    if len(self_axes) != len(other_axes):
        return False
    if not all(ax1.equals(ax2) for ax1, ax2 in zip(self_axes, other_axes)):
        return False
    self._consolidate_inplace()
    other._consolidate_inplace()
    if len(self.blocks) != len(other.blocks):
        return False

    # compare block contents and locations
    for i, block in enumerate(self.blocks):
        if not block.equals(other.blocks[i]):
            return False
        if not block.mgr_locs.equals(other.blocks[i].mgr_locs):
            return False

    return True
```

With this correction, the `equals` function will properly compare the block contents and their locations, ensuring that identical blocks with different locations are not mistakenly labeled as equal.

This correction will address the issue reported on GitHub, and the function will now return the expected result of `False` for the failing test `test_dataframe_not_equal()`.