The `equals` function is failing the test `test_dataframe_not_equal` and returning `True` instead of `False` when comparing two identical DataFrames with different locations. The failing test is causing an assertion error, where `True is False` is being asserted.

The cause of the bug is that the `canonicalize` function used to sort the blocks in the DataFrames is not considering the values of the blocks, resulting in inconsistencies when comparing DataFrames.

To fix the bug, the `canonicalize` function for sorting the blocks should be modified to include the values of the blocks in addition to the type name and manager locations. This will ensure that identical blocks with different locations are correctly identified as not equal.

Here's the corrected version of the `equals` function:

```python
def equals(self, other):
    self_axes, other_axes = self.axes, other.axes
    if len(self_axes) != len(other_axes):
        return False
    if not all(ax1.equals(ax2) for ax1, ax2 in zip(self_axes, other_axes)):
        return False
    self._consolidate_inplace()
    other._consolidate_inplace()
    if len(self.blocks) != len(other.blocks):
        return False

    # canonicalize block order, using a tuple combining the type name, values, and mgr_locs
    def canonicalize(block):
        return (block.dtype.name, block.values, block.mgr_locs.as_array.tolist())

    self_blocks = sorted(self.blocks, key=canonicalize)
    other_blocks = sorted(other.blocks, key=canonicalize)
    return all(
        block.equals(oblock) for block, oblock in zip(self_blocks, other_blocks)
    )
```

With this correction, the `equals` function should pass the failing test and resolve the issue posted in GitHub.