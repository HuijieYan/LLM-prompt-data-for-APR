The bug in the `equals` function seems to be related to the order of the blocks. When comparing the blocks, the function is not considering the order of the blocks, leading to incorrect results.

To fix this bug, we can modify the `equals` function to compare the blocks in a consistent order, ensuring that the comparison is based on the block values rather than their locations.

Here's the corrected version of the `equals` function:

```python
def equals(self, other):
    self_axes, other_axes = self.axes, other.axes
    if len(self_axes) != len(other_axes):
        return False
    if not all(ax1.equals(ax2) for ax1, ax2 in zip(self_axes, other_axes)):
        return False
    self._consolidate_inplace()
    other._consolidate_inplace()
    if len(self.blocks) != len(other.blocks):
        return False

    # Sort the blocks based on their content
    self_blocks = sorted(self.blocks, key=lambda block: block.values.to_numpy().tobytes())
    other_blocks = sorted(other.blocks, key=lambda block: block.values.to_numpy().tobytes())

    # Compare the sorted blocks
    return all(
        block.equals(oblock) for block, oblock in zip(self_blocks, other_blocks)
    )
```

With this modification, the function sorts the blocks based on their content before comparing them, ensuring a consistent order for comparison.

This corrected version of the `equals` function should fix the bug and make the failing test `test_dataframe_not_equal` pass.