The bug in the `equals` function seems to be related to how it compares the block locations when checking for equality between two DataFrames. In the failing test, `df1` and `df2` have the same data but with columns swapped, which should result in `df1.equals(df2)` returning `False`, but it wrongly returns `True`. This is due to the comparison between the blocks' locations being incorrect.

The fix involves implementing a better comparison strategy for the block locations. One possible approach is to compare the blocks considering their content, rather than their location. This can be achieved by iterating through the blocks and comparing their contents directly.

Here's the corrected version of the `equals` function:

```python
def equals(self, other):
    self_axes, other_axes = self.axes, other.axes
    if len(self_axes) != len(other_axes):
        return False
    if not all(ax1.equals(ax2) for ax1, ax2 in zip(self_axes, other_axes)):
        return False
    self._consolidate_inplace()
    other._consolidate_inplace()
    if len(self.blocks) != len(other.blocks):
        return False

    self_blocks = [(block.values, block.mgr_locs) for block in self.blocks]
    other_blocks = [(block.values, block.mgr_locs) for block in other.blocks]

    return all(block in other_blocks for block in self_blocks) and all(block in self_blocks for block in other_blocks)
```

With this correction, the `equals` function now compares the block contents and ensures that they are present in both DataFrames, regardless of their location. This change should address the bug and make the function return the expected result in the failing test case.