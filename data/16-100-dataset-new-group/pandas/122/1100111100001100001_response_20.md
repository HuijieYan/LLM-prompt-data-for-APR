The bug in the `equals` function seems to be related to the sorting and comparison of `self.blocks` and `other.blocks`. The function is checking the equality of the blocks based on their names and locations, but the comparison is not being performed correctly.

To fix this bug, we need to ensure that the comparison is based on the correct attributes of the blocks. We can directly compare the `dtype` and `mgr_locs` attributes of the blocks to determine if they are equal.

Here's the corrected version of the function:

```python
def equals(self, other):
    self_axes, other_axes = self.axes, other.axes
    if len(self_axes) != len(other_axes):
        return False
    if not all(ax1.equals(ax2) for ax1, ax2 in zip(self_axes, other_axes)):
        return False
    self._consolidate_inplace()
    other._consolidate_inplace()
    if len(self.blocks) != len(other.blocks):
        return False

    self_blocks = sorted(self.blocks, key=lambda block: (block.dtype, block.mgr_locs))
    other_blocks = sorted(other.blocks, key=lambda block: (block.dtype, block.mgr_locs))

    return all(
        block.equals(oblock) for block, oblock in zip(self_blocks, other_blocks)
    )
```

In this corrected version, we use the `sorted` function to sort the `self.blocks` and `other.blocks` based on the tuple `(block.dtype, block.mgr_locs)`. This ensures that the comparison of blocks is based on their data types and locations.

By making this change, the function should now correctly compare the blocks and return the expected result.