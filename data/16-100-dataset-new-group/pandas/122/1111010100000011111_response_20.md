## Bug Fix
The bug in the equals function is likely caused by comparing blocks with different locations but identical content. The current implementation of the equals function does not consider the possibility of comparing blocks with different locations.

To fix the bug, we need to modify the equals function to consider the content of the blocks regardless of their location. We can achieve this by comparing the values within the blocks instead of the block objects themselves.

Here's the corrected version of the equals function:

```python
def equals(self, other):
    self_axes, other_axes = self.axes, other.axes
    if len(self_axes) != len(other_axes):
        return False
    if not all(ax1.equals(ax2) for ax1, ax2 in zip(self_axes, other_axes)):
        return False
    self._consolidate_inplace()
    other._consolidate_inplace()
    if len(self.blocks) != len(other.blocks):
        return False
    
    # Create a function to retrieve the values within a block
    def get_block_values(block):
        return block.values
    
    self_block_values = [get_block_values(block) for block in self.blocks]
    other_block_values = [get_block_values(block) for block in other.blocks]
    
    return all(
        np.array_equal(block_values, other_block_values[i]) 
        for i, block_values in enumerate(self_block_values)
    )
```

This corrected version of the equals function ensures that the content of the blocks is compared regardless of their location. This should resolve the issue reported on GitHub and provide the expected output.

By comparing the block values instead of the block objects themselves, we can accurately identify cases where identical blocks are located differently within the data structure.