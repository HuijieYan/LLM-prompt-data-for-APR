The bug in the `equals` function occurs because it is not comparing the data correctly. The comparison between `df1.equals(df2)` is expected to return False, as the values in both dataframes are not equal, but it currently returns True. This is due to the way the function is consolidating and comparing the blocks of data.

To fix this, we need to modify the `equals` function to correctly compare the contents of the two dataframes. Specifically, we need to ensure that the blocks of data are properly consolidated and then iterate through each block to compare their contents.

Here's the corrected version of the `equals` function:

```python
def equals(self, other):
    self_axes, other_axes = self.axes, other.axes
    if len(self_axes) != len(other_axes):
        return False
    if not all(ax1.equals(ax2) for ax1, ax2 in zip(self_axes, other_axes)):
        return False

    self._consolidate_inplace()
    other._consolidate_inplace()
    
    if len(self.blocks) != len(other.blocks):
        return False

    for block in self.blocks:
        for oblock in other.blocks:
            if block.equals(oblock):
                return True
    return False
```

By iterating through each block and comparing their contents, as shown in the corrected version of the `equals` function above, we can ensure that the function returns the correct result when comparing the two dataframes.