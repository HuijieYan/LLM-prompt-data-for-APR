The bug in the `equals` function seems to be caused by the inconsistency of the block sorting due to unconsolidated block locations. One way to fix this is to consolidate the blocks before sorting.

Here's the corrected version of the `equals` function:

```python
def equals(self, other):
    self._consolidate_inplace()  # Consolidate the blocks
    other._consolidate_inplace()  # Consolidate the blocks
    self_axes, other_axes = self.axes, other.axes
    if len(self_axes) != len(other_axes):
        return False
    if not all(ax1.equals(ax2) for ax1, ax2 in zip(self_axes, other_axes)):
        return False
    if len(self.blocks) != len(other.blocks):
        return False

    # canonicalize block order, using a tuple combining the type
    # name and then mgr_locs because there might be unconsolidated
    # blocks (say, Categorical) which can only be distinguished by
    # the iteration order
    def canonicalize(block):
        block._consolidate_inplace()  # Consolidate the block
        return (block.dtype.name, block.mgr_locs.as_array.tolist())

    self_blocks = sorted(self.blocks, key=canonicalize)
    other_blocks = sorted(other.blocks, key=canonicalize)
    return all(
        block.equals(oblock) for block, oblock in zip(self_blocks, other_blocks)
    )
```

This corrected version consolidates the blocks of `self` and `other` before any comparison, preventing any inconsistency due to unconsolidated block locations. This should fix the bug and make the failing test pass.