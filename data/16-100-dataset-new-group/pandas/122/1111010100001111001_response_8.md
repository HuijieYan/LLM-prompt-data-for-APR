The bug in the function `equals` is likely caused by the incorrect comparison of `self.blocks` and `other.blocks` due to the order of blocks. The bug seems to arise when there are unconsolidated blocks, such as Categorical blocks, which are not properly distinguished during the comparison.

To fix the bug, a strategy could be to sort the `self.blocks` and `other.blocks` to have the same order before comparing them. This will ensure that the comparison is not affected by the order of the blocks.

Here's the corrected version of the `equals` function:
```python
def equals(self, other):
    self_axes, other_axes = self.axes, other.axes
    if len(self_axes) != len(other_axes):
        return False
    if not all(ax1.equals(ax2) for ax1, ax2 in zip(self_axes, other_axes)):
        return False
    self._consolidate_inplace()
    other._consolidate_inplace()
    if len(self.blocks) != len(other.blocks):
        return False

    def canonicalize(block):
        return (block.mgr_locs.as_array.tolist(), block.values)

    self_blocks = sorted(self.blocks, key=canonicalize)
    other_blocks = sorted(other.blocks, key=canonicalize)
    return all(
        block.equals(oblock) for block, oblock in zip(self_blocks, other_blocks)
    )
```
In the corrected version, the `canonicalize` function now uses both `mgr_locs.as_array.tolist()` and `block.values` to create a unique representation for each block, and the blocks are sorted based on this representation for comparison. This ensures that the unconsolidated blocks are correctly distinguished, and the comparison does not depend on the order of the blocks.