The buggy function `equals` appears to fail when comparing DataFrames with identical blocks but different locations. The issue is related to the way the function handles block consolidation and order, leading to incorrect equality checks.

To fix the bug, we need to appropriately handle the block consolidation and order to ensure that identical blocks with different locations are correctly identified as unequal.

Here's the corrected version of the `equals` function:

```python
def equals(self, other):
    self_axes, other_axes = self.axes, other.axes
    if len(self_axes) != len(other_axes):
        return False
    if not all(ax1.equals(ax2) for ax1, ax2 in zip(self_axes, other_axes)):
        return False
    self._consolidate_inplace()
    other._consolidate_inplace()
    if len(self.blocks) != len(other.blocks):
        return False
    return self.blocks.equals(other.blocks)
```

This corrected version directly compares the blocks of the DataFrames, which should appropriately handle the equality checks for identical blocks with different locations.

This should resolve the reported GitHub issue and pass the failing test `test_dataframe_not_equal`.