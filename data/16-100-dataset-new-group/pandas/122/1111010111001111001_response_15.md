To fix the issue, we need to sort the block managers based on the block content rather than the block type. This will ensure that the two block managers are equal even if their blocks are in a different order.

The corrected version of the function would be:

```python
def equals(self, other):
    self_axes, other_axes = self.axes, other.axes
    if len(self_axes) != len(other_axes):
        return False
    if not all(ax1.equals(ax2) for ax1, ax2 in zip(self_axes, other_axes)):
        return False
    self._consolidate_inplace()
    other._consolidate_inplace()
    if len(self.blocks) != len(other.blocks):
        return False

    # canonicalize block order, using a tuple combining the block content
    def canonicalize(block):
        return block.values.tostring()

    self_blocks = sorted(self.blocks, key=canonicalize)
    other_blocks = sorted(other.blocks, key=canonicalize)
    return all(
        block.equals(oblock) for block, oblock in zip(self_blocks, other_blocks)
    )
```

This version of the function sorts the blocks based on their content, ensuring that the order of the blocks does not affect the comparison result.

With this corrected version, the failing test case should pass, as it accounts for the block contents rather than their types or order.