The bug in the equals() function seems to be related to the comparison of the self_blocks and other_blocks. The comparison is failing when the blocks are sorted and then iterated over to check for equality. This could be due to the inconsistency in the sorting logic based on block types and mgr_locs.

To fix the bug, we can modify the sorting logic to include both the block type and the mgr_locs. This should ensure that the blocks are properly sorted and compared for equality.

Here's the corrected version of the equals() function:

```python
def equals(self, other):
    self_axes, other_axes = self.axes, other.axes
    if len(self_axes) != len(other_axes):
        return False
    if not all(ax1.equals(ax2) for ax1, ax2 in zip(self_axes, other_axes)):
        return False
    self._consolidate_inplace()
    other._consolidate_inplace()
    if len(self.blocks) != len(other.blocks):
        return False

    def canonicalize(block):
        return (type(block).__name__, block.mgr_locs.as_array.tolist())

    self_blocks = sorted(self.blocks, key=canonicalize)
    other_blocks = sorted(other.blocks, key=canonicalize)
    return all(
        block.equals(oblock) for block, oblock in zip(self_blocks, other_blocks)
    )
```

In this version, the `canonicalize` function now generates a tuple containing the block type name and the mgr_locs, which is used for sorting the blocks.

This should fix the bug and ensure that the blocks are correctly compared for equality.