The issue with the current implementation of the `equals` method is that it doesn't properly take into account the order of the blocks, resulting in incorrect comparisons and ultimately returning True when it should return False. The method compares the blocks of the two BlockManager instances, but the sorting of the blocks is not consistent, leading to incorrect evaluation.

To fix this issue, we can modify the `equals` method to properly sort and compare the blocks of both BlockManager instances.

Here's the corrected version of the `equals` method:

```python
def equals(self, other):
        self_axes, other_axes = self.axes, other.axes
        if len(self_axes) != len(other_axes):
            return False
        if not all(ax1.equals(ax2) for ax1, ax2 in zip(self_axes, other_axes)):
            return False
        self._consolidate_inplace()
        other._consolidate_inplace()
        if len(self.blocks) != len(other.blocks):
            return False
        
        # Sort the blocks by type name and manager locations
        def canonicalize(block):
            return (block.__class__.__name__, block.mgr_locs.as_array.tolist())
        self_blocks = sorted(self.blocks, key=canonicalize)
        other_blocks = sorted(other.blocks, key=canonicalize)
        
        # Check for block equality
        return all(
            block.equals(oblock) for block, oblock in zip(self_blocks, other_blocks)
        )
```

With this corrected implementation, the `equals` method should now properly compare the BlockManager instances and return the expected results, resolving the issue reported on GitHub.