The bug in the `_cython_agg_blocks` function is causing it to return incorrect outputs, which is causing the provided failing tests to fail. The `try` clause within the `for` loop is catching the `NotImplementedError`, which is causing the code to continue execution with incorrect data. The handling of the "ohlc" operation in the code is also skipping the `alt` function invalidating the result.

Here's a corrected version of the `_cython_agg_blocks` function:

```python
def _cython_agg_blocks(self, how: str, alt=None, numeric_only: bool = True, min_count: int = -1) -> "Tuple[List[Block], Index]":
    # TODO: the actual managing of mgr_locs is a PITA
    # here, it should happen via BlockManager.combine
    data: BlockManager = self._get_data_to_aggregate()

    if numeric_only:
        data = data.get_numeric_data(copy=False)

    agg_blocks: List[Block] = []
    new_items: List[np.ndarray] = []
    split_items: List[np.ndarray] = []

    no_result = object()
    for block in data.blocks:
        result = no_result  # Avoid inheriting result from earlier in the loop
        locs = block.mgr_locs.as_array
        try:
            result, _ = self.grouper.aggregate(block.values, how, axis=1, min_count=min_count)
        except NotImplementedError:
            result = no_result

        if result is no_result and alt is not None:
            obj = self.obj[data.items[locs]]
            if obj.shape[1] == 1:
                obj = obj.iloc[:, 0]

            s = get_groupby(obj, self.grouper)
            result = s.aggregate(lambda x: alt(x, axis=self.axis))

        if result is not no_result:
            if not isinstance(result, DataFrame):
                result = maybe_downcast_numeric(result, block.dtype)
                result = result if block.is_extension else result.reshape(1, -1)
                agg_block = block.make_block(result)
                new_items.append(locs)
                agg_blocks.append(agg_block)

        elif result is no_result:
            split_items.append(locs)

    # Handling split blocks
    if split_items:
        for locs in split_items:
            result = self.obj[data.items[locs]].groupby(self.grouper).apply(alt)
            agg_blocks.extend(block.make_block(result[loc, :]) for loc in locs)
            new_items.extend([loc] for loc in locs)

    if not (agg_blocks or split_items):
        raise DataError("No numeric types to aggregate")

    # reset the locs in the blocks to correspond to our current ordering
    indexer = np.concatenate(new_items)
    agg_items = data.items.take(np.sort(indexer))

    # There is no need to adjust the indexer
    offset = 0
    for blk in agg_blocks:
        loc = len(blk.mgr_locs)
        blk.mgr_locs = indexer[offset : (offset + loc)]
        offset += loc

    return agg_blocks, agg_items
```

In the corrected version of the function, the handling of the exceptional cases has been improved. Additionally, the code has been updated to ensure correct data manipulation for proper aggregation.

By replacing the function with the implementation provided, the failing tests should pass.