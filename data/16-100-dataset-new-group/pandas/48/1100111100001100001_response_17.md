Based on the runtime values and types of variables for each case, we can conclude that the `_cython_agg_blocks` function is not correctly handling the `_get_data_to_aggregate` function. The `self._get_data_to_aggregate()` method returns a `BlockManager` object, which is then used in the function to get numeric data and calculate aggregation, but the process is not consistent and resulting in incorrect outputs.

The problem seems to be with how the numeric data is extracted and aggregated from the `BlockManager` object. Additionally, the handling of exceptions and alternate calculations seems to be flawed, leading to incorrect outputs.

To fix the bug in the function, the method of extracting and processing numeric data from the `BlockManager` should be thoroughly reviewed. Proper exception handling and alternate calculations in case of errors should also be revised and improved.

Here's a corrected version of the function:

```python
def _cython_agg_blocks(
    self, how: str, alt=None, numeric_only: bool = True, min_count: int = -1
) -> "Tuple[List[Block], Index]":

    data: BlockManager = self._get_data_to_aggregate()

    if numeric_only:
        data = data.get_numeric_data(copy=False)

    if alt is None:
        agg_blocks = data._agg(how, min_count=min_count)
    else:
        agg_blocks = data._agg_alternate(alt, min_count=min_count)
    
    return agg_blocks
```

In this corrected version, the Numeric data extraction and aggregation has been simplified by leveraging the internal `_agg` and `_agg_alternate` methods of the `BlockManager` object to handle the aggregation process and alternate calculations in a consistent manner.

Please test this corrected version with different inputs to ensure its correctness.