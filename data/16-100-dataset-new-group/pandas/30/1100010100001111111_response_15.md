The issue here is that the function `_try_convert_to_date` is incorrectly converting boolean values to datetime objects. This is causing an inconsistent output and also raising a TypeError in newer versions of Pandas.

The cause of the bug is that the function is incorrectly checking and converting boolean values to datetime using the `to_datetime` function.

To fix the bug, we need to modify the function to handle boolean values without converting them to datetime, and only perform the date conversion on other data types.

Here's the corrected version of the function:

```python
def _try_convert_to_date(self, data):
    """
    Try to parse a ndarray-like object into a date column.
    
    Try to coerce object in epoch/iso formats and integer/float in epoch
    formats. Return a boolean if parsing was successful.
    """
    # no conversion on empty
    if not len(data):
        return data, False

    if data.dtype == "object":
        try:
            new_data = data.astype("int64")
            date_units = (self.date_unit,) if self.date_unit else self._STAMP_UNITS
            for date_unit in date_units:
                try:
                    new_data = to_datetime(new_data, errors="raise", unit=date_unit)
                except (ValueError, OverflowError):
                    continue
            return new_data, True
        except (TypeError, ValueError, OverflowError):
            return data, False
    elif issubclass(data.dtype.type, np.number):
        in_range = (
            isna(data._values)
            | (data > self.min_stamp)
            | (data._values == iNaT)
        )
        if not in_range.all():
            return data, False
        new_data = to_datetime(data, errors="raise", unit=self.date_unit)
        return new_data, True
    else:
        return data, False
``` 

This corrected version will correctly handle boolean values and only perform the date conversion on other data types, which should resolve the issue reported on GitHub.