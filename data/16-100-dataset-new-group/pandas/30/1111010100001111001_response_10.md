The bug in the `_try_convert_to_date` function is caused by the incorrect handling of the data type. In the first case, when `new_data.dtype` is checked against "object", the dtype is incorrectly determined to be "int64" and an unnecessary conversion is attempted. In the second case, when `new_data.dtype` is a boolean datatype, the function incorrectly goes on to handle it as a date.

To fix the bug, we can modify the function to correctly handle different data types and remove unnecessary conversions and checks. A corrected version of the function is as follows:

```python
class Parser():
    def _try_convert_to_date(self, data):
        if not len(data):
            return data, False
        
        new_data = data
        if new_data.dtype == "object":
            try:
                new_data = to_datetime(new_data, errors="coerce")
            except ValueError:
                pass

        if isinstance(new_data, (int, float, np.integer)):
            in_range = (
                isna(new_data)
                | (new_data > self.min_stamp)
                | (new_data == iNaT)
            )
            if not in_range:
                return data, False

        date_units = (self.date_unit,) if self.date_unit else self._STAMP_UNITS
        try:
            new_data = to_datetime(new_data, errors="raise", unit=date_units)
            return new_data, True
        except (ValueError, OverflowError):
            return data, False
```