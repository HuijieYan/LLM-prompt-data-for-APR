## Correction: 

The cause of the bug is that the `_try_convert_to_date` function is incorrectly converting boolean values to datetime. This is occurring due to the code not correctly handling boolean values when trying to convert them to datetime.

To correct this, we need to add an additional check to handle boolean values separately in the `_try_convert_to_date` function. We should ensure that boolean values are not being converted to datetime and retain their original type.

```python
def _try_convert_to_date(self, data):
    if not len(data):
        return data, False

    new_data = data
    if new_data.dtype == "object":
        try:
            new_data = data.astype("int64")
        except (TypeError, ValueError, OverflowError):
            pass
    elif new_data.dtype == "bool":
        return data, False
    
    if issubclass(new_data.dtype.type, np.number):
        in_range = (
            isna(new_data._values)
            | (new_data > self.min_stamp)
            | (new_data._values == iNaT)
        )
        if not in_range.all():
            return data, False

    date_units = (self.date_unit,) if self.date_unit else self._STAMP_UNITS
    for date_unit in date_units:
        try:
            new_data = to_datetime(new_data, errors="raise", unit=date_unit)
        except (ValueError, OverflowError):
            continue
        return new_data, True
    return data, False

```

With this correction, boolean values will be correctly handled, and the function will return a Series of boolean values as expected instead of converting them to datetime. This will resolve the issue reported in GitHub.