The bug in the provided function is that it incorrectly handles the data conversion to date and the check for in-range numbers. The function also lacks proper error handling and does not return the correct values.

The bug occurs due to incorrect handling of the data type conversion and the in-range check. Additionally, the function is not properly returning the new_data and the in_range values.

One strategy for fixing this bug is to ensure that the data type conversion is handled correctly and that the in-range check returns the appropriate boolean values.

Here's the corrected version of the function:

```python
class Parser():
    def _try_convert_to_date(self, data):

        if not len(data):
            return data, False

        new_data = data
        if new_data.dtype == "object":
            try:
                new_data = pd.to_numeric(data, errors='coerce')
            except (ValueError, TypeError):
                pass

        if new_data.dtype.kind in 'biuf':
            in_range = (
                isna(new_data)
                | (new_data > self.min_stamp)
                | (new_data == iNaT._d)
            )
            if not in_range.all():
                return new_data, False

        date_units = (self.date_unit,) if self.date_unit else self._STAMP_UNITS
        for date_unit in date_units:
            try:
                new_data = pd.to_datetime(new_data, errors="raise", unit=date_unit)
                return new_data, True
            except (ValueError, OverflowError):
                continue
        return data, False
```

In the above corrected version:
- We use `pd.to_numeric` to convert the 'object' type data to numeric values.
- Use `pd.to_datetime` for converting the data into datetime format with proper error handling.
- Fix the in-range check to correctly handle numeric values.

This corrected version should now satisfy the expected input/output values.