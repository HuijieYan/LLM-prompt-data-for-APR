The issue with the buggy function `_engine` lies in the use of the `@cache_readonly` decorator. The `@cache_readonly` decorator is used to cache the result of a property method so that it is only computed once and then reused on subsequent calls. However, the `_engine` function is attempting to return the `self._engine_type` and `len(self)` inside a weak reference, which is causing the caching to be ineffective.

To fix this bug, the strategy will be to remove the `@cache_readonly` decorator from the `_engine` function and use a manual caching technique to store the result of `self._engine_type(period, len(self))` so that it is only computed once.

Here's the corrected version of the `_engine` function:
```python
def _engine(self):
    if not hasattr(self, '_cached_engine'):
        period = weakref.ref(self)
        self._cached_engine = self._engine_type(period, len(self))
    return self._cached_engine
```

With this modification, the `_engine` function will now cache the result of `self._engine_type(period, len(self))` and return the cached result on subsequent calls. This should fix the caching issue and the failing test.