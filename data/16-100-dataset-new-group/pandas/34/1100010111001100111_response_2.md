In the given case, the issue arises from the behavior of the `pd.Grouper` function when dealing with a long clock-change day in Cuba, causing ambiguous timestamp errors when trying to group the data. The test case `test_downsample_dst_at_midnight` illustrates this problem. When executed, it raises an `AmbiguousTimeError` because the function is not handling the ambiguous timestamp correctly for the long clock-change day.

The cause of the bug appears to be related to how the `pd.Grouper` function handles the conversion of timestamps on long clock-change days, causing it to incorrectly group the data.

To fix this bug, you can update the `_get_time_bins` function to correctly handle the behavior of the `pd.Grouper` function when dealing with ambiguous timestamps, especially on long clock-change days.

Here's a corrected version of the `_get_time_bins` function that should resolve the issue:
```python
def _get_time_bins(self, ax):
    if not isinstance(ax, DatetimeIndex):
        raise TypeError(
            "axis must be a DatetimeIndex, but got "
            f"an instance of {type(ax).__name__}"
        )

    if len(ax) == 0:
        binner = labels = DatetimeIndex(data=[], freq=self.freq, name=ax.name)
        return binner, [], labels

    first = ax.tz_localize(None).normalize().min()
    last = ax.tz_localize(None).normalize().max()
    binner = labels = date_range(
        freq=self.freq,
        start=first,
        end=last,
        tz=ax.tz,
        name=ax.name,
        ambiguous="infer",
        nonexistent="shift_forward",
    )

    ax_values = ax.asi8
    binner, bin_edges = self._adjust_bin_edges(binner, ax_values)

    # general version, knowing nothing about relative frequencies
    bins = lib.generate_bins_dt64(
        ax_values, bin_edges, self.closed, hasnans=ax.hasnans
    )

    if self.closed == "right":
        labels = binner
        if self.label == "right":
            labels = labels[1:]
    elif self.label == "right":
        labels = labels[1:]

    if ax.hasnans:
        binner = binner.insert(0, NaT)
        labels = labels.insert(0, NaT)

    # if we end up with more labels than bins
    # adjust the labels
    # GH4076
    if len(bins) < len(labels):
        labels = labels[: len(bins)]

    return binner, bins, labels
```
In the corrected version, there is a change in the calculation of `first` and `last` timestamps to handle the ambiguity properly. The `tz_localize(None).normalize()` method is used to first remove the timezone, then normalize the timestamp, ensuring that the ambiguous timestamp is handled correctly.

With this fix, the function should correctly handle the ambiguous time on clock-change days in Cuba, resolving the issue reported on GitHub.