## Explanation:
The buggy function `_get_time_bins` is trying to handle time binning, but it fails to account for ambiguous timestamps during clock changes. The failing test `test_downsample_dst_at_midnight` tries to downsample data with a timezone change in the middle, and this fails due to the bug in the `_get_time_bins` function. The error message from the failing test indicates an `AmbiguousTimeError`, which matches the issue described in GitHub.

## Fix Strategy:
The bug in the `_get_time_bins` function can be fixed by adjusting how it handles ambiguous timestamps during clock changes in certain timezones. This can be done by handling the timestamps properly within the `_get_time_bins` function.

## The corrected version:
```python
from pandas._libs import lib
from pandas._libs.tslibs import NaT, Period, Timestamp
from pandas.core.indexes.datetimes import DatetimeIndex, date_range

def _get_time_bins(self, ax):
    if not isinstance(ax, DatetimeIndex):
        raise TypeError(
            "axis must be a DatetimeIndex, but got "
            f"an instance of {type(ax).__name__}"
        )

    if len(ax) == 0:
        binner = labels = DatetimeIndex(data=[], freq=self.freq, name=ax.name)
        return binner, [], labels

    first, last = _get_timestamp_range_edges(
        ax.min(), ax.max(), self.freq, closed=self.closed, base=self.base
    )
    # GH #12037
    # use first/last directly instead of call replace() on them
    # because replace() will swallow the nanosecond part
    # thus last bin maybe slightly before the end if the end contains
    # nanosecond part and lead to `Values falls after last bin` error
    binner = labels = date_range(
        freq=self.freq,
        start=first,
        end=last,
        tz=ax.tz,
        name=ax.name,
        ambiguous="infer",
        nonexistent="shift_forward",
    )

    ax_values = ax.asi8
    binner, bin_edges = self._adjust_bin_edges(binner, ax_values)

    # general version, knowing nothing about relative frequencies
    bins = lib.generate_bins_dt64(
        ax_values, bin_edges, self.closed, hasnans=ax.hasnans
    )

    if self.closed == "right":
        labels = binner
        if self.label == "right":
            labels = labels[1:]
    elif self.label == "right":
        labels = labels[1:]

    if ax.hasnans:
        binner = binner.insert(0, NaT)
        labels = labels.insert(0, NaT)

    # if we end up with more labels than bins
    # adjust the labels
    # GH4076
    if len(bins) < len(labels):
        labels = labels[: len(bins)]

    # Handle ambiguous timestamps
    if ax.tz is not None and ax.tz._utc_transition_times is not None:
        ambiguous_times = ax.tz._utc_transition_times
        ambiguous_index = binner.isin(ambiguous_times)
        if any(ambiguous_index):
            binner = binner.tz_localize(None)
            binner[ambiguous_index] = ambiguous_times
            binner = binner.tz_localize(ax.tz)
            labels = binner

    return binner, bins, labels
```

In the corrected version, the function now correctly handles ambiguous timestamps during clock changes by adjusting the timestamps before creating bins and labels. This should resolve the issue reported in GitHub and make the failing test pass.