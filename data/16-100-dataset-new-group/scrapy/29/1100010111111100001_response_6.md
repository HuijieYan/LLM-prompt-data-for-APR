The bug in the `request_httprepr` function is causing it to fail when processing non-HTTP requests. The `to_bytes(parsed.hostname)` call fails with a `TypeError` because `parsed.hostname` is `None`. This occurs when the URL scheme is not 'http' or 'https', which results in the `netloc` component being parsed as the hostname, causing `parsed.hostname` to be `None`.

To fix the bug, we need to handle non-HTTP requests by checking for the presence of a valid hostname before constructing the HTTP representation. We can use the `netloc` attribute of the `ParseResult` object to check for the presence of a hostname.

Here's the corrected version of the function:

```python
def request_httprepr(request):
    parsed = urlparse_cached(request)
    
    if parsed.scheme in ['http', 'https'] and parsed.netloc:
        hostname = parsed.netloc.split(':')[0]  # extract hostname from netloc
        path = urlunparse(('', '', parsed.path or '/', parsed.params, parsed.query, ''))

        s = to_bytes(request.method) + b" " + to_bytes(path) + b" HTTP/1.1\r\n"
        s += b"Host: " + to_bytes(hostname) + b"\r\n"
        if request.headers:
            s += request.headers.to_string() + b"\r\n"
        s += b"\r\n"
        s += request.body
        return s

    # If the request is not http(s) or the netloc is empty, return an empty byte string
    return b""
```

With this fix, the function will check if the request is for an HTTP(S) URL and has a valid hostname before constructing the HTTP representation. If the request is not for an HTTP(S) URL or the hostname is not present, it will return an empty byte string as requested. This corrected version of the function should pass the failing test.