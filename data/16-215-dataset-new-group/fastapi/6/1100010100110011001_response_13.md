## Bug Analysis
The function `request_body_to_args` is designed to retrieve values from a received request body and validate them against given parameters, returning the values and any validation errors. The failing test cases indicate that the function is not correctly retrieving the input data from the received request.

The failing test cases are attempting to send a list, set, and tuple as form data, but the function does not correctly handle these non-typing sequences.

The function logic uses various nested conditions and checks for shapes of fields, all of which can lead to unexpected behavior, especially with non-typing sequences.

The bugs are caused by the function's logic not accounting for non-typing sequences (list, set, and tuple) as form data.

## Bug Fixing Strategy
To fix the bugs in the `request_body_to_args` function, I will modify the logic to correctly process the received form data, especially when the input field is a non-typing sequence.

I will ensure that the function retrieves and handles values correctly for non-typing sequences (lists, sets, and tuples) when received as form data, ensuring that it properly validates the values and returns any errors.

I will also simplify the logic for handling form data and sequence shapes to make the code more readable and maintainable.

## The corrected function

```python
async def request_body_to_args(
    required_params: List[ModelField],
    received_body: Optional[Union[Dict[str, Any], FormData]],
) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:
    values = {}
    errors = []
    for field in required_params:
        field_info = get_field_info(field)
        value: Any = None
        if received_body is not None:
            if field.shape in sequence_shapes and isinstance(received_body, FormData):
                # if the field shape is a sequence and the received body is FormData, always use getlist
                value = received_body.getlist(field.alias)
            else:
                # otherwise, use get
                value = received_body.get(field.alias)
        if (
            value is None
            or (
                isinstance(field_info, params.Form)
                and field.shape in sequence_shapes
                and len(value) == 0
            )
        ):
            if field.required:
                errors.append(
                    ErrorWrapper(MissingError(), loc=("body", field.alias))
                )
            else:
                values[field.name] = deepcopy(field.default)
        else:
            # handle the sequence shapes separately
            if field.shape in sequence_shapes:
                if isinstance(value, sequence_types):
                    # if the value is a sequence of the expected type, convert it to a list
                    value = list(value)
                else:
                    # otherwise, create a list with the single value
                    value = [value]
            if (
                isinstance(field_info, params.File)
                and lenient_issubclass(field.type_, bytes)
                and isinstance(value, UploadFile)
            ):
                value = await value.read()
            v_, errors_ = field.validate(value, values, loc=("body", field.alias))
            if isinstance(errors_, ErrorWrapper):
                errors.append(errors_)
            elif isinstance(errors_, list):
                errors.extend(errors_)
            else:
                values[field.name] = v_
    return values, errors
```

The corrected function simplifies the logic, explicitly handling non-typing sequences and ensuring that the form data is retrieved and processed correctly. It simplifies the checks for form data and sequence shapes, ensuring that the function behaves consistently in handling various input types.