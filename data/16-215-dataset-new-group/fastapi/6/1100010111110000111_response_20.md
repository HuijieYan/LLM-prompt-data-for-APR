The issue with the `request_body_to_args` function seems to be related to the handling of form data with repeated keys, which is supported by the FastAPI framework. The failing tests are attempting to handle repeated keys in form data but are returning a 422 status code instead of the expected 200 status code.

The cause of the bug is likely related to the handling of repeated keys in form data within the `request_body_to_args` function. The failing tests indicate that the function fails to handle form data with repeated keys properly, leading to the incorrect 422 status code.

To fix the bug, the `request_body_to_args` function should be modified to handle repeated keys in form data by collecting them into a list before validation happens. The function should also correctly validate and return the expected status code for the given test cases.

Here is the corrected version of the `request_body_to_args` function:

```python
async def request_body_to_args(
    required_params: List[ModelField],
    received_body: Optional[Union[Dict[str, Any], FormData]],
) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:
    values = {}
    errors = []
    if required_params:
        for field in required_params:
            value: Any = None
            if received_body is not None:
                if field.shape in sequence_shapes and isinstance(
                    received_body, FormData
                ):
                    if field.alias in received_body.keys():
                        if field.shape == "set":
                            value = set(received_body.getlist(field.alias))
                        elif field.shape == "list":
                            value = received_body.getlist(field.alias)
                        elif field.shape == "tuple":
                            value = tuple(received_body.getlist(field.alias))
                        else:
                            value = received_body.getlist(field.alias)
                    else:
                        value = None
                else:
                    value = received_body.get(field.alias)
            if (
                value is None
                or (isinstance(field_info, params.Form) and value == "")
                or (
                    isinstance(field_info, params.Form)
                    and field.shape in sequence_shapes
                    and len(value) == 0
                )
            ):
                if field.required:
                    if PYDANTIC_1:
                        errors.append(
                            ErrorWrapper(MissingError(), loc=("body", field.alias))
                        )
                    else:  # pragma: nocover
                        errors.append(
                            ErrorWrapper(  # type: ignore
                                MissingError(),
                                loc=("body", field.alias),
                                config=BaseConfig,
                            )
                        )
                else:
                    values[field.name] = deepcopy(field.default)
                continue
            if (
                isinstance(field_info, params.File)
                and lenient_issubclass(field.type_, bytes)
                and isinstance(value, UploadFile)
            ):
                value = await value.read()
            elif (
                field.shape in sequence_shapes
                and isinstance(field_info, params.File)
                and lenient_issubclass(field.type_, bytes)
                and isinstance(value, sequence_types)
            ):
                awaitables = [sub_value.read() for sub_value in value]
                contents = await asyncio.gather(*awaitables)
                value = sequence_shape_to_type[field.shape](contents)
            v_, errors_ = field.validate(value, values, loc=("body", field.alias))
            if isinstance(errors_, ErrorWrapper):
                errors.append(errors_)
            elif isinstance(errors_, list):
                errors.extend(errors_)
            else:
                values[field.name] = v_
    return values, errors
```

In the corrected version of the function, the form data with repeated keys is properly handled by collecting them into a list or set based on the shape specified in the field. The function should now be able to pass the failing tests and resolve the issue posted in GitHub regarding support for repeated key=value in form data.