The bug in the `request_body_to_args` function is that it only adds the received_body as a key-value pair to `values` when it is not None, which causes the validation to fail in some cases. Additionally, the error messages appended to the `errors` list are incorrect and should be fixed to match the expected behavior of the function.

To fix the bug, we need to restructure the function to correctly handle the values and error messages for the different field types. We also need to ensure that appropriate error messages are added to the `errors` list when the received_body does not meet the expectations based on the required_params.

```python
import asyncio
from copy import deepcopy
from typing import Any, Dict, List, Optional, Tuple, Union
from fastapi import params
from pydantic.error_wrappers import ErrorWrapper
from pydantic.fields import ModelField
from pydantic import Form
from starlette.datastructures import FormData, UploadFile

sequence_shapes = {2, 3}
sequence_types = (list, set, tuple)
sequence_shape_to_type = {
    2: list,
    3: tuple,
}

async def request_body_to_args(
    required_params: List[ModelField],
    received_body: Optional[Union[Dict[str, Any], FormData]],
) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:
    values = {}
    errors = []
    for field in required_params:
        fld_key = field.alias
        field_info = get_field_info(field)
        value = None
        if received_body is not None:
            if field.shape in sequence_shapes and isinstance(received_body, FormData):
                value = received_body.getlist(fld_key)
            else:
                value = received_body.get(fld_key)
        if value is None or (value == "" and isinstance(field_info, Form)):
            if field.required:
                errors.append(ErrorWrapper(MissingError(), loc=("body", fld_key)))
            else:
                values[field.name] = deepcopy(field.default)
            continue
        if isinstance(field_info, params.File) and field.type_ is bytes and isinstance(value, UploadFile):
            value = await value.read()
        elif (
            field.shape in sequence_shapes
            and isinstance(field_info, params.File)
            and lenient_issubclass(field.type_, bytes)
            and isinstance(value, sequence_types)
        ):
            awaitables = [sub_value.read() for sub_value in value]
            contents = await asyncio.gather(*awaitables)
            value = sequence_shape_to_type[field.shape](contents)
        v_, errors_ = field.validate(value, values, loc=("body", fld_key))
        if isinstance(errors_, ErrorWrapper):
            errors.append(errors_)
        elif isinstance(errors_, list):
            errors.extend(errors_)

        values[field.name] = v_
    return values, errors
```
In this corrected version of the function, we iterate over the required_params list and perform the required processing for each field, adding values and error messages to their respective lists as needed based on the input field type and required conditions. This ensures the function logic aligns with the expected behavior for the input/field types and satisfies the given use cases.