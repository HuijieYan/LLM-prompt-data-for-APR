### Bug Explanation
The bug occurs in the `request_body_to_args` function when handling repeated keys in form data, such as with lists, sets, or tuples. The function fails to properly process the repeated keys, leading to incorrect values being returned.

The failing test for a Python list parameter as form data posted in the GitHub issue is:
```python
response = client.post("/form/python-list", data={"items": ["first", "second", "third"]})
assert response.status_code == 200
assert response.json() == ["first", "second", "third"]
```
This test fails because the function is not correctly handling the list of items in the form data.

Similarly, there are failing tests for a Python set parameter as form data and a Python tuple parameter as form data. These tests fail for the same reason, as the function does not properly handle repeated keys when processing the form data.

### Bug Fix Strategy
To fix the bug, the `request_body_to_args` function needs to be modified to correctly handle repeated keys in form data and assign those values as a list to the same key before validation happens. This fix will address the issue mentioned in the GitHub report by ensuring that the function can collect repeated keys in the form data and process them as lists.

### The Corrected Version
```python
async def request_body_to_args(
    required_params: List[ModelField],
    received_body: Optional[Union[Dict[str, Any], FormData]],
) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:
    values = {}
    errors = []
    if required_params:
        for field in required_params:
            if received_body is not None and field.alias in received_body:
                value = received_body.getlist(field.alias)
                if field.required and not value:
                    errors.append(ErrorWrapper(MissingError(), loc=("body", field.alias)))
                else:
                    v_, errors_ = field.validate(value, values, loc=("body", field.alias))
                    if isinstance(errors_, ErrorWrapper):
                        errors.append(errors_)
                    elif isinstance(errors_, list):
                        errors.extend(errors_)
                    else:
                        values[field.name] = v_
            else:
                if field.required:
                    errors.append(ErrorWrapper(MissingError(), loc=("body", field.alias)))
                else:
                    values[field.name] = deepcopy(field.default)
    return values, errors
```
In the corrected version, the function checks if the `field.alias` exists in the `received_body`. If it does, it uses `received_body.getlist(field.alias)` to get the list of values and then validates and processes them accordingly. This ensures that repeated keys in form data are processed and validated correctly, addressing the issue raised in the GitHub report.