The buggy function `request_body_to_args` seems to be having issues when handling non-typing sequences like lists, sets, and tuples. It fails to properly handle the received data and raise corresponding errors.

Upon analysis, it seems that the bug is due to incorrect handling of the `embed` attribute and the value of the received body when dealing with non-typing sequences. Additionally, the validation and error handling for these sequences are not being handled correctly.

To fix this issue, the correct approach would be to handle non-typing sequences separately and ensure that their validation and errors are raised appropriately.

Here's a corrected version of the `request_body_to_args` function:

```python
async def request_body_to_args(
    required_params: List[ModelField],
    received_body: Optional[Union[Dict[str, Any], FormData]],
) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:
    values = {}
    errors = []
    if required_params:
        for field in required_params:
            value: Any = None
            if received_body is not None:
                if isinstance(received_body, FormData):
                    value = received_body.getlist(field.alias) if field.shape in sequence_shapes else received_body.get(field.alias)
                else:
                    value = received_body.get(field.alias)
                    
                if field.required and value is None:
                    errors.append(ErrorWrapper(MissingError(), loc=("body", field.alias)))
                else:
                    v_, errors_ = field.validate(value, values, loc=("body", field.alias))
                    if isinstance(errors_, ErrorWrapper):
                        errors.append(errors_)
                    elif isinstance(errors_, list):
                        errors.extend(errors_)
                    else:
                        values[field.name] = v_
            else:
                if field.required:
                    errors.append(ErrorWrapper(MissingError(), loc=("body", field.alias)))
                else:
                    values[field.name] = deepcopy(field.default)

    return values, errors
```

In this corrected version, we've made sure to handle non-typing sequences separately by checking for `FormData` and applying the appropriate logic based on the shape of the field. We've also fixed the validation and error handling for the non-typing sequences. Additionally, we've removed the unnecessary attributes `field_info` and `embed`.

This corrected version should pass the failing tests and satisfy the expected input/output values for the given cases.