The bug in the `request_body_to_args` function is related to the handling of sequence shapes such as list, set, and tuple in the `received_body`.

The potential error locations are:
1. Incorrectly setting the `embed` variable for the first element in the `required_params` list to `True`.
2. Incorrectly converting the `value` to a list when `field.shape` is not equivalent to 1.
3. Incorrectly handling sequence shapes such as list, set, and tuple in the `received_body`.

The cause of the bug is that the function assumes a single element for sequence shapes in the `received_body`, leading to incorrect handling of the `received_body` for sequence shapes.

To fix the bug, we need to correctly handle the sequence shapes in the `received_body`. Also, we should check the `field.shape` to appropriately handle non-1 elements in the sequence.

Here's the corrected version of the function:

```python
async def request_body_to_args(
    required_params: List[ModelField],
    received_body: Optional[Union[Dict[str, Any], FormData]],
) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:
    values = {}
    errors = []

    for field in required_params:
        value: Any = None
        field_info = get_field_info(field)
        if received_body is not None:
            if field.shape in sequence_shapes and isinstance(received_body, FormData):
                value = received_body.getlist(field.alias)
            else:
                value = getattr(received_body, field.alias, None)
        if value is None:
            if field.required:
                errors.append(ErrorWrapper(MissingError(), loc=("body", field.alias)))
            else:
                values[field.name] = deepcopy(field.default)
            continue
        if (
            isinstance(field_info, params.File)
            and lenient_issubclass(field.type_, bytes)
            and isinstance(value, UploadFile)
        ):
            value = await value.read()
        elif (
            field.shape in sequence_shapes
            and isinstance(field_info, params.File)
            and lenient_issubclass(field.type_, bytes)
            and isinstance(value, sequence_types)
        ):
            awaitables = [sub_value.read() for sub_value in value]
            contents = await asyncio.gather(*awaitables)
            value = sequence_shape_to_type[field.shape](contents)
        v, errors_ = field.validate(value, values, loc=("body", field.alias))
        if isinstance(errors_, ErrorWrapper):
            errors.append(errors_)
        elif isinstance(errors_, list):
            errors.extend(errors_)
        else:
            values[field.name] = v

    return values, errors
```

In the corrected version, we have removed the unnecessary logic related to checking `embed` and handling `field.shape`. We use `getattr` to retrieve the field value from the `received_body`. We also directly check the `value` for `None` and handle it accordingly. This approach will effectively handle the sequence shapes in the `received_body` and fix the bug.