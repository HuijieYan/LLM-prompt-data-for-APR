Based on the detected error location and the failed test cases, the issue seems to be caused by the `request_body_to_args` function not handling multiple form fields with the same name correctly. The function incorrectly assigns received body values to a single field alias, causing the values to be overwritten. This results in only the last value being used, as observed in the failing tests.

To fix the bug, the function needs to handle repeated keys in form data by collecting them into a list and assigning those values to the same key before validation occurs. This will ensure that all values for the same key are included and validated.

Here's the corrected version of the `request_body_to_args` function:

```python
async def request_body_to_args(
    required_params: List[ModelField],
    received_body: Optional[Union[Dict[str, Any], FormData]],
) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:
    values = {}
    errors = []
    if received_body is None:
        received_body = {}

    for field in required_params:
        field_info = get_field_info(field)
        embed = getattr(field_info, "embed", None)

        if field.alias in received_body:
            value = received_body.getlist(field.alias) if isinstance(received_body, FormData) else received_body.get(field.alias)
        else:
            value = None

        if value is None or (isinstance(field_info, params.Form) and value == "") or (
            isinstance(field_info, params.Form)
            and field.shape in sequence_shapes
            and len(value) == 0
        ):
            if field.required:
                if PYDANTIC_1:
                    errors.append(ErrorWrapper(MissingError(), loc=("body", field.alias)))
                else:  # pragma: nocover
                    errors.append(ErrorWrapper(MissingError(), loc=("body", field.alias), config=BaseConfig))
            else:
                values[field.name] = deepcopy(field.default)
        else:
            if (
                isinstance(field_info, params.File)
                and lenient_issubclass(field.type_, bytes)
                and isinstance(value, UploadFile)
            ):
                value = await value.read()
            elif (
                field.shape in sequence_shapes
                and isinstance(field_info, params.File)
                and lenient_issubclass(field.type_, bytes)
                and isinstance(value, sequence_types)
            ):
                awaitables = [sub_value.read() for sub_value in value]
                contents = await asyncio.gather(*awaitables)
                value = sequence_shape_to_type[field.shape](contents)

            v_, errors_ = field.validate(value, values, loc=("body", field.alias))
            if isinstance(errors_, ErrorWrapper):
                errors.append(errors_)
            elif isinstance(errors_, list):
                errors.extend(errors_)
            else:
                values[field.name] = v_

    return values, errors
```

In the corrected version, the function checks if the field alias is present in the received body and then retrieves the values using `getlist` if the received body is a `FormData`. This change ensures that all values for the same field alias are collected into a list before validation.

This fix should address the issue reported in the GitHub issue and allow the function to handle repeated key-value pairs in form data correctly.