The bug in the `request_body_to_args` function seems to be related to the handling of repeated keys in form data. The function does not handle the case where multiple values are associated with the same key in the FormData. This leads to the values being overwritten, and only the last one being considered.

The bug is likely causing issues in cases where the input data has repeated keys, such as `FormData([('items', 'first'), ('items', 'second'), ('items', 'third')])`, where 'items' appears multiple times with different values.

To fix this bug, the function should be modified to correctly handle repeated keys in FormData. Instead of overwriting the values associated with the same key, the function should collect all the values into a list and associate the list with the key, as suggested in the GitHub issue.

Here's the corrected version of the function:

```python
async def request_body_to_args(
    required_params: List[ModelField],
    received_body: Optional[Union[Dict[str, Any], FormData]],
) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:
    values = {}
    errors = []
    for field in required_params:
        value: Any = None
        if received_body is not None:
            if field.shape in sequence_shapes and isinstance(
                    received_body, FormData):
                value = received_body.getlist(field.alias)
            else:
                value = received_body.get(field.alias)

        if value is not None:
            if field.shape in sequence_shapes and not isinstance(value, sequence_types):
                value = [value]

            if isinstance(field_info, params.File) and lenient_issubclass(field.type_, bytes) and isinstance(value, UploadFile):
                value = await value.read()
            elif field.shape in sequence_shapes and isinstance(field_info, params.File) and lenient_issubclass(field.type_, bytes) and isinstance(value, sequence_types):
                awaitables = [sub_value.read() for sub_value in value]
                contents = await asyncio.gather(*awaitables)
                value = sequence_shape_to_type[field.shape](contents)

            v_, errors_ = field.validate(value, values, loc=("body", field.alias))
            if isinstance(errors_, ErrorWrapper):
                errors.append(errors_)
            elif isinstance(errors_, list):
                errors.extend(errors_)
            else:
                values[field.name] = v_
        else:
            if field.required:
                if PYDANTIC_1:
                    errors.append(
                        ErrorWrapper(MissingError(), loc=("body", field.alias))
                    )
                else:  # pragma: nocover
                    errors.append(
                        ErrorWrapper(  # type: ignore
                            MissingError(),
                            loc=("body", field.alias),
                            config=BaseConfig,
                        )
                    )
            else:
                values[field.name] = deepcopy(field.default)

    return values, errors
```

In the corrected version:
1. When retrieving the value from `received_body`, the function specifically checks if the value is a list and collects all the values associated with the same key into a list. This ensures that all the values are considered when processing the input data.
2. The function then proceeds with the validation and error handling logic as before.

This corrected version of the function should address the bug and support repeated key=value pairs in form data as requested in the GitHub issue.