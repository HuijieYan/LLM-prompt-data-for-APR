The bug in the provided function `request_body_to_args` is likely due to the incorrect logic for handling non-typing sequences. 

To fix the bug, consider restructuring the logic to correctly handle the required parameters and received body. Additionally, the conditional checks for specific field types and shapes should be modified to accurately validate the input data.

Here's a corrected version of the function that should pass the failing test:

```python
async def request_body_to_args(
    required_params: List[ModelField],
    received_body: Optional[Union[Dict[str, Any], FormData]],
) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:
    values = {}
    errors = []
    for field in required_params:
        value: Union[List[Any], Set[Any], Tuple[Any, ...], Any] = None
        if received_body is not None:
            if field.shape == 1 and not isinstance(received_body, FormData):
                value = received_body.get(field.alias)
            elif field.shape > 1 and isinstance(received_body, FormData):
                value = received_body.getlist(field.alias)
        
        if value is None or (isinstance(field_info, params.Form) and value in ("", [])):
            if field.required:
                errors.append(ErrorWrapper(MissingError(), loc=("body", field.alias)))
            else:
                values[field.name] = deepcopy(field.default)
        else:
            v_, errors_ = field.validate(value, values, loc=("body", field.alias))
            if isinstance(errors_, ErrorWrapper):
                errors.append(errors_)
            elif isinstance(errors_, list):
                errors.extend(errors_)
            else:
                values[field.name] = v_
                
    return values, errors
```

In the corrected version, the conditionals for handling the different shapes and types of the input data are restructured to correctly validate the parameters. This version should address the underlying issue and pass the failing test cases.