The root cause of the bug in the `request_body_to_args` function is the incorrect processing of non-typing sequences in conjunction with the detection of param types such as list, set, and tuple. It fails to validate and process the received data properly, leading to the function to return incorrect values and trash the expected input/output values.

The expected behavior of the function is to correctly validate the input data, assign and process the received values, and generate the expected errors when validation fails.

The fix for this bug involves changes to how the function processes the received body and validates the data against the required fields and respective types.

Here's the corrected version of the `request_body_to_args` function:

```python
async def request_body_to_args(
    required_params: List[ModelField],
    received_body: Optional[Union[Dict[str, Any], FormData]],
) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:
    values = {}
    errors = []
    if required_params:
        for field in required_params:
            value: Any = None
            if received_body is not None and field.alias in received_body:
                value = received_body.get(field.alias)
                
                if value is None:
                    if field.required:
                        errors.append(ErrorWrapper(MissingError(), loc=("body", field.alias), config=BaseConfig))
                    else:
                        values[field.name] = field.default
                else:
                    v_, errors_ = field.validate(value, values, loc=("body", field.alias))
                    if isinstance(errors_, ErrorWrapper):
                        errors.append(errors_)
                    elif isinstance(errors_, list):
                        errors.extend(errors_)
                    else:
                        values[field.name] = v_
    return values, errors
```

In this fix:
1. The loop over `required_params` correctly checks if the alias exists in the `received_body`.
2. If a value exists for the alias, it is then validated against the required fields, generating errors if needed, and then the value is assigned to the `values` dictionary.

With these changes, the function should now pass the failing tests and satisfy the expected input/output values.