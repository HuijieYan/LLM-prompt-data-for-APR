## Bug Explanation
The `request_body_to_args` function is intended to process the required parameters and received body and return a dictionary of values and a list of errors. However, the function has several issues that are causing it to return incorrect values.

1. The function does not correctly handle the case when the received body is a single value and is not embedded.
2. The function does not correctly handle the case when the received body is a FormData with a list of values for a field.

## Bug Fix Strategy
To fix the bug in the `request_body_to_args` function, the following changes need to be made:
1. The function needs to ensure that it correctly handles the case when the received body is a single value and is not embedded.
2. The function needs to correctly handle the case when the received body is a FormData with a list of values for a field.

Additionally, the function should be tested with multiple cases to ensure that it returns the expected values and types for the given input parameters.

## The corrected function
```python
async def request_body_to_args(
    required_params: List[ModelField],
    received_body: Optional[Union[Dict[str, Any], FormData]],
) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:
    values = {}
    errors = []
    for field in required_params:
        field_info = get_field_info(field)
        if len(required_params) == 1 and getattr(field_info, "embed", None) is None:
            received_body = {field.alias: received_body}
        value = None
        if received_body is not None:
            if field.shape in sequence_shapes and isinstance(received_body, FormData):
                value = received_body.getlist(field.alias)
            else:
                value = received_body.get(field.alias)
        if value in (None, ""):
            if field.required:
                errors.append(ErrorWrapper(MissingError(), loc=("body", field.alias)))
            else:
                values[field.name] = deepcopy(field.default)
        else:
            if (
                isinstance(field_info, params.File)
                and lenient_issubclass(field.type_, bytes)
                and isinstance(value, UploadFile)
            ):
                value = await value.read()
            elif (
                field.shape in sequence_shapes
                and isinstance(field_info, params.File)
                and lenient_issubclass(field.type_, bytes)
                and isinstance(value, sequence_types)
            ):
                awaitables = [sub_value.read() for sub_value in value]
                contents = await asyncio.gather(*awaitables)
                value = sequence_shape_to_type[field.shape](contents)
            v_, errors_ = field.validate(value, values, loc=("body", field.alias))
            if isinstance(errors_, ErrorWrapper):
                errors.append(errors_)
            elif isinstance(errors_, list):
                errors.extend(errors_)
            else:
                values[field.name] = v_
    return values, errors
```