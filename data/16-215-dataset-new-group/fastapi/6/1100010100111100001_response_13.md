The issue here is that when the received_body is a FormData and the field has a shape of 1 (i.e., it is a list, set, or tuple), the logic for extracting the value from the FormData is incorrect, leading to the test failures.

The fix strategy involves modifying the logic for extracting the values from the FormData when the field has a shape of 1.

Here is the corrected version of the function:

```python
async def request_body_to_args(
    required_params: List[ModelField],
    received_body: Optional[Union[Dict[str, Any], FormData]],
) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:
    values = {}
    errors = []
    if required_params:
        for field in required_params:
            if received_body is not None:
                field_name = field.alias
                field_info = get_field_info(field)
                value: Any = None
                if field.shape == 1 and isinstance(received_body, FormData):
                    value = received_body.getlist(field_name)
                    if field.sub_fields:
                        sub_field = field.sub_fields[0]
                        sub_values = []
                        for sub_value in value:
                            v, e = sub_field.validate(sub_value, values, loc=("body", field_name))
                            values[field.name] = v
                            errors.extend(e)
                    else:
                        if field.type_ in {list, set}:
                            value = field_info.parse(value)
                            values[field.name] = value
                        elif lenient_issubclass(field.type_, str):
                            value = ', '.join(value)
                            values[field.name] = value
                else:
                    value = received_body.get(field_name)
                    if (
                        value is None
                        or (isinstance(field_info, params.Form) and value == "")
                        or (
                            isinstance(field_info, params.Form)
                            and field.shape in sequence_shapes
                            and len(value) == 0
                        )
                    ):
                        if field.required:
                            if PYDANTIC_1:
                                errors.append(
                                    ErrorWrapper(MissingError(), loc=("body", field_name))
                                )
                            else:  # pragma: nocover
                                errors.append(
                                    ErrorWrapper(  # type: ignore
                                        MissingError(),
                                        loc=("body", field_name),
                                        config=BaseConfig,
                                    )
                                )
                        else:
                            values[field.name] = deepcopy(field.default)
                    else:
                        if (
                            isinstance(field_info, params.File)
                            and lenient_issubclass(field.type_, bytes)
                            and isinstance(value, UploadFile)
                        ):
                            value = await value.read()
                        v_, errors_ = field.validate(value, values, loc=("body", field_name))
                        if isinstance(errors_, ErrorWrapper):
                            errors.append(errors_)
                        elif isinstance(errors_, list):
                            errors.extend(errors_)
                        else:
                            values[field.name] = v_
    return values, errors
```

This corrected version should address the issues with extracting the values from FormData and should pass the failing tests.