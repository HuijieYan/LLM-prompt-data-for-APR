The bug in the given function is that it does not handle the input data correctly when the received_body is a FormData object. The function incorrectly processes list, set, and tuple types of single primitive values, and hence generates validation errors and status code 422 instead of the expected 200.

To fix the bug, the following changes need to be made:
1. When handling list, set, and tuple types, the function should map received_body to the key of the corresponding field.alias and assign the value accordingly.
2. For single values, the function should convert them to the appropriate primitive type.
3. The function should handle discrepancies in type handling between ModelField and field_info.

Here's the corrected version of the buggy function:

```python
async def request_body_to_args(
    required_params: List[ModelField],
    received_body: Optional[Union[Dict[str, Any], FormData]],
) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:
    values = {}
    errors = []
    if required_params:
        for field in required_params:
            field_info = get_field_info(field)
            value: Any = None
            if received_body is not None:
                if field.shape in sequence_shapes and isinstance(received_body, FormData):
                    value = received_body.getlist(field.alias)
                    if len(value) == 1:
                        value = value[0]
                else:
                    value = received_body.get(field.alias)
            if (value is None) or (isinstance(field_info, params.Form) and value == ""):
                if field.required:
                    errors.append(
                        ErrorWrapper(MissingError(), loc=("body", field.alias))
                    )
                else:
                    values[field.name] = deepcopy(field.default)
                continue
            if (
                field.shape in sequence_shapes
                and isinstance(value, sequence_types)  # Validate value type
            ):
                value = sequence_shape_to_type[field.shape](value)
            v_, errors_ = field.validate(value, values, loc=("body", field.alias))
            if isinstance(errors_, ErrorWrapper):
                errors.append(errors_)
            elif isinstance(errors_, list):
                errors.extend(errors_)
            else:
                values[field.name] = v_
    return values, errors
```

With the corrected function, the failing tests should now pass, and the expected input/output values should be satisfied.