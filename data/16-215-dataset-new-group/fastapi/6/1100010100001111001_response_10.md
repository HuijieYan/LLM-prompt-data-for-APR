The bug in the function `request_body_to_args` occurs because of the logic used to handle the `required_params` and `received_body`. In particular, the bug seems to be due to the way it handles the `required_params` list and the conditional statements when converting the `received_body` into the final `values` dictionary.

It appears that the `required_params` are not being handled correctly when iterating over the list. Additionally, the conditional logic inside the loop and the subsequent assignment to the `values` dictionary based on field names might not be functioning as expected.

To fix the bug, the conditional logic that handles different field types and shapes should be revised. The loop over the `required_params` list should be reviewed to ensure that each parameter is processed correctly. Additionally, the process of handling the received body and populating the `values` dictionary should be reviewed to ensure correctness.

Here's the corrected version of the function:

```python
async def request_body_to_args(
    required_params: List[ModelField],
    received_body: Optional[Union[Dict[str, Any], FormData]],
) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:
    values = {}
    errors = []
    if required_params and received_body:
        for field in required_params:
            value = None
            if field.alias in received_body:
                value = received_body.get(field.alias)
                
                if value is None and field.required:
                    errors.append(ErrorWrapper(MissingError(), loc=("body", field.alias)))
                else:
                    v_, errors_ = field.validate(value, values, loc=("body", field.alias))
                    if isinstance(errors_, ErrorWrapper):
                        errors.append(errors_)
                    elif isinstance(errors_, list):
                        errors.extend(errors_)
                    else:
                        values[field.name] = v_
            else:
                if field.required:
                    errors.append(ErrorWrapper(MissingError(), loc=("body", field.alias)))
                else:
                    values[field.name] = deepcopy(field.default)
    return values, errors
```

In the corrected version, the conditional logic is simplified to handle each case individually. The `required_params` are iterated over, and the `received_body` is properly checked for the presence of the field alias. The values are then added to the `values` dictionary or errors are appended based on the conditions.