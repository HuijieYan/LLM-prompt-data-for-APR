The bug in the `request_body_to_args` function seems to stem from the incorrect handling of the request body for different data shapes and types, resulting in errors and incorrect handling of values. Here's a strategy for fixing the bug:
1. Check if the received_body parameter is a dictionary or a FormData object and handle the values accordingly.
2. Validate the field type and shape based on the parameter's properties and handle the values appropriately.
3. Use the correct field information (field_info) for validation of values and include it in the error handling process.

A fixed and corrected version of the `request_body_to_args` function is provided below:

```python
async def request_body_to_args(
    required_params: List[ModelField],
    received_body: Optional[Union[Dict[str, Any], FormData]],
) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:
    values = {}
    errors = []
    if required_params:
        for field in required_params:
            field_info = get_field_info(field)
            value: Any = None
            if received_body is not None:
                if isinstance(received_body, FormData):
                    if field.shape in sequence_shapes:
                        value = received_body.getlist(field.alias)
                    else:
                        value = received_body.get(field.alias)
                else:
                    value = received_body.get(field.alias)
            if field.required and value is None:
                errors.append(
                    ErrorWrapper(MissingError(), loc=("body", field.alias))
                )
            elif isinstance(field_info, params.File) and lenient_issubclass(field.type_, bytes) and isinstance(value, UploadFile):
                value = await value.read()
            elif field.shape in sequence_shapes and isinstance(field_info, params.File) and lenient_issubclass(field.type_, bytes) and isinstance(value, sequence_types):
                awaitables = [sub_value.read() for sub_value in value]
                contents = await asyncio.gather(*awaitables)
                value = sequence_shape_to_type[field.shape](contents)
            
            if PYDANTIC_1:
                v_, errors_ = field.validate(value, values, loc=("body", field.alias))
            else:
                v_, errors_ = field.validate(value, values, loc=("body", field.alias), config=BaseConfig)

            if isinstance(errors_, ErrorWrapper):
                errors.append(errors_)
            elif isinstance(errors_, list):
                errors.extend(errors_)
            else:
                values[field.name] = v_
    return values, errors
```

The input and output types of the function should be defined according to the provided typing and import statements. Make sure to replace any variable or shape-specific values with the actual values based on the input parameters and their properties.