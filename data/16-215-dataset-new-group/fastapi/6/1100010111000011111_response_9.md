The buggy function `request_body_to_args` is intended to convert the received body parameters into a dictionary format and validate them against the required parameters. However, the function has a bug related to handling non-typing sequences such as lists, sets, and tuples in form data.

The bug arises due to how the function handles non-typing sequences when passed as form data. The function incorrectly processes the received body and does not properly handle the case where the same key appears multiple times with different values in the form data.

To fix the bug, the function needs to properly handle non-typing sequences in the form data and ensure that it captures all values for the same key and returns them as a list.

Here's a corrected version of the function:

```python
async def request_body_to_args(
    required_params: List[ModelField],
    received_body: Optional[Union[Dict[str, Any], FormData]],
) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:
    values = {}
    errors = []

    if received_body is not None:
        for field in required_params:
            value: Any = None
            if field.shape in sequence_shapes and isinstance(
                received_body, FormData
            ):
                # Get all values for the same key as a list
                values[field.alias] = received_body.getlist(field.alias)
            else:
                value = received_body.get(field.alias)

                if (
                    value is None
                    or (isinstance(field_info, params.Form) and value == "")
                    or (
                        isinstance(field_info, params.Form)
                        and field.shape in sequence_shapes
                        and len(value) == 0
                    )
                ):
                    if field.required:
                        if PYDANTIC_1:
                            errors.append(
                                ErrorWrapper(MissingError(), loc=("body", field.alias))
                            )
                        else:  # pragma: nocover
                            errors.append(
                                ErrorWrapper(  # type: ignore
                                    MissingError(),
                                    loc=("body", field.alias),
                                    config=BaseConfig,
                                )
                            )
                    else:
                        values[field.alias] = deepcopy(field.default)

        for field in required_params:
            if field.alias in values:
                v_, errors_ = field.validate(values[field.alias], values, loc=("body", field.alias))
                if isinstance(errors_, ErrorWrapper):
                    errors.append(errors_)
                elif isinstance(errors_, list):
                    errors.extend(errors_)
                else:
                    values[field.name] = v_

    return values, errors
```

In this corrected version, when the received body is a FormData and the field's shape corresponds to a sequence type, the function uses `getlist` to retrieve all values for the same key and adds them to the `values` dictionary as a list. This ensures that the function properly captures all values for the same key in the form data.

By implementing this correction, the function will properly handle non-typing sequences in the form data and address the issue reported on GitHub about supporting repeated key=value in form data.