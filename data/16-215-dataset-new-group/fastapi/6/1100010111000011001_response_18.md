The bug in the `request_body_to_args` function is likely due to the incorrect handling of non-typing sequences in the received body, resulting in validation errors and incorrect return values.

To fix the bug, we need to modify the function to correctly handle non-typing sequences such as lists, sets, and tuples. This involves updating the logic for extracting values from the received body, handling different sequence shapes, and validating the values.

Here's the corrected version of the function that should pass the failing test cases and satisfy the expected input/output values:

```python
async def request_body_to_args(
    required_params: List[ModelField],
    received_body: Optional[Union[Dict[str, Any], FormData]],
) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:
    values = {}
    errors = []

    for field in required_params:
        value: Any = None
        if received_body is not None:
            if isinstance(received_body, FormData):
                if field.alias in received_body:
                    value = received_body.getlist(field.alias) if field.shape in sequence_shapes else received_body.get(field.alias)
            else:
                value = received_body.get(field.alias)

        if value is None or (isinstance(field_info, params.Form) and value == "") or (
            isinstance(field_info, params.Form) and field.shape in sequence_shapes and len(value) == 0
        ):
            if field.required:
                errors.append(ErrorWrapper(MissingError(), loc=("body", field.alias)))
            else:
                values[field.name] = deepcopy(field.default)
            continue
        
        if isinstance(field_info, params.File) and lenient_issubclass(field.type_, bytes) and isinstance(value, UploadFile):
            value = await value.read()
        elif (
            field.shape in sequence_shapes
            and isinstance(field_info, params.File)
            and lenient_issubclass(field.type_, bytes)
            and isinstance(value, sequence_types)
        ):
            awaitables = [sub_value.read() for sub_value in value]
            contents = await asyncio.gather(*awaitables)
            value = sequence_shape_to_type[field.shape](contents)

        v_, errors_ = field.validate(value, values, loc=("body", field.alias))
        if isinstance(errors_, ErrorWrapper):
            errors.append(errors_)
        elif isinstance(errors_, list):
            errors.extend(errors_)
        else:
            values[field.name] = v_

    return values, errors
```

This corrected version addresses the issues related to extracting and validating values from non-typing sequences, and it should now pass the failing test cases and satisfy the expected input/output values.