The issue with the `DataFrame.quantile()` function is that it is not handling datetime data correctly and is producing unexpected results for DataFrames containing datetime data. The current implementation does not consider the case when the `numeric_only` parameter is set to `False`, which is needed to include datetime and timedelta data in the quantile computation.

To fix the bug, we need to update the `self._get_numeric_data()` call to consider the `numeric_only` parameter and include non-numeric data (like datetime and timedelta) when `numeric_only` is set to `False`.

Here is the corrected version of the `quantile` function:

```python
def quantile(self, q=0.5, axis=0, numeric_only=True, interpolation="linear"):
    self._check_percentile(q)

    if numeric_only:
        data = self._get_numeric_data()
    else:
        data = self

    axis = self._get_axis_number(axis)
    is_transposed = axis == 1

    if is_transposed:
        data = data.T

    result = data._data.quantile(
        qs=q, axis=1, interpolation=interpolation, transposed=is_transposed
    )

    if result.ndim == 2:
        if len(q) > 1:
            result = self._constructor(result, index=q, columns=data.columns)
        else:
            result = self._constructor_sliced(result, name=q[0], index=data.index)
    else:
        result = self._constructor_sliced(result, name=q)

    if is_transposed:
        result = result.T

    return result
```

This corrected version handles the `numeric_only` parameter correctly to include non-numeric data in the quantile computation when needed. It ensures that the output matches the expected results for DataFrames containing datetime data.

This updated implementation will resolve the issue posted on GitHub and ensure that the `DataFrame.quantile()` function works as expected for both numeric and non-numeric data types.