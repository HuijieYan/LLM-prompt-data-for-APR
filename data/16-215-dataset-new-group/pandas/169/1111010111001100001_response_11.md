The bug seems to be in the way the function handles the input data when calculating the quantile. When the input DataFrame contains only datetime values, the function fails to handle the data correctly and returns unexpected results.

To fix the bug, the function needs to handle cases where the input data contains only datetime values appropriately.

Here's the corrected version of the function:

```python
def quantile(self, q=0.5, axis=0, numeric_only=True, interpolation="linear"):
    self._check_percentile(q)

    if not numeric_only:
        data = self.select_dtypes(include='number')
    else:
        data = self._get_numeric_data()

    axis = self._get_axis_number(axis)

    if axis in (1, 'columns'):
        data = data.T

    result = data._data.quantile(qs=q, axis=1, interpolation=interpolation, transposed=(axis in (1, 'columns')))

    if result.ndim == 2:
        result = self._constructor(result)
    else:
        result = self._constructor_sliced(result, name=q)

    if axis in (1, 'columns'):
        result = result.T

    return result
```

This corrected version of the function first checks if the `numeric_only` parameter is set to False. If it is, then it selects only the numeric columns from the DataFrame using the `select_dtypes` method. Otherwise, it proceeds with the original logic to get the numeric data.

This modification ensures that the function correctly handles cases where the input data contains only datetime values.