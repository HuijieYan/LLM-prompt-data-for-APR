The bug appears to be related to the use of `pd.date_range` resulting in an empty DataFrame, causing a concatenation error when applying the quantile function.

The cause of the bug is that `pd.DataFrame(pd.date_range('1/1/18', periods=5)).quantile()` raises a ValueError, while `pd.Series(pd.date_range('1/1/18', periods=5)).quantile()` works fine. The failing test `test_quantile_empty_no_columns` also demonstrates the issue when an empty DataFrame with a column name is used to calculate quantile.

One potential strategy to fix the bug is to modify the behavior of the quantile function when encountering an empty DataFrame with datetime data. Instead of raising an error, it should return an appropriate output, preferably consistent with how a Series with the same data would behave.

Here's the corrected version of the quantile function:

```python
def quantile(self, q=0.5, axis=0, numeric_only=True, interpolation="linear"):
    """
    Return values at the given quantile over requested axis.

    Parameters
    ----------
    q : float or array-like, default 0.5 (50% quantile)
        Value between 0 <= q <= 1, the quantile(s) to compute.
    axis : {0, 1, 'index', 'columns'} (default 0)
        Equals 0 or 'index' for row-wise, 1 or 'columns' for column-wise.
    numeric_only : bool, default True
        If False, the quantile of datetime and timedelta data will be
        computed as well.
    interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}
        This optional parameter specifies the interpolation method to use,
        when the desired quantile lies between two data points `i` and `j`:
        ...
    Returns
    -------
    Series or DataFrame
        ...

    See Also
    --------
    ...

    Examples
    --------
    ...

    """
    self._check_percentile(q)

    if self.empty and not self._is_mixed_type:
        return self._constructor(data=[], index=self.columns, name=q)

    data = self._get_numeric_data() if numeric_only else self
    axis = self._get_axis_number(axis)
    is_transposed = axis == 1

    if is_transposed:
        data = data.T

    result = data._data.quantile(
        qs=q, axis=1, interpolation=interpolation, transposed=is_transposed
    )

    if result.ndim == 2:
        result = self._constructor(result)
    else:
        result = self._constructor_sliced(result, name=q)

    if is_transposed:
        result = result.T

    return result
```

In the corrected version, we added a conditional check for an empty DataFrame with a single type (datetime). If the DataFrame is empty and not of a mixed type, we return a new DataFrame with the associated column names and quantile value. This should handle the specific case encountered in the failing test and the GitHub issue.