## Bug explanation
The `quantile` function in the `DataFrame` class of the `pandas` library fails to obtain the quantile value when called on a DataFrame of datetime data. The bug is triggered by the following cases:
- When `numeric_only` is set to `True`.
- When a singular or list of quantiles is given.

The failed cases reflect incorrect output, and it is indicated that the issue is primarily related to the concatenation of the datetime data for quantiles. The error message "ValueError: need at least one array to concatenate" suggests a concatenation error when the function attempts to compute the quantile for datetime data.

## Bug location
The bug appears to be located in the internal code of the `_get_numeric_data` method when the function tries to obtain numeric data for computing quantiles. The `quantile` function does not consider datetime data, which leads to a concatenation error due to non-numeric data types.

## Strategy for fixing the bug
To address the bug, the `quantile` function needs to be updated to handle datetime data appropriately, rather than just assuming all data is numeric. This will likely involve modifying the internal logic for obtaining the data to ensure it includes datetime data when `numeric_only` is `False`.

## Corrected version of the function
```python
def quantile(self, q=0.5, axis=0, numeric_only=True, interpolation="linear"):
    self._check_percentile(q)

    if numeric_only:
        if self._get_numeric_data().empty:
            data = self._data
        else:
            data = self._get_numeric_data()
    else:
        data = self._data

    axis = self._get_axis_number(axis)
    is_transposed = axis == 1

    if is_transposed:
        data = data.T

    result = data.quantile(q=q, axis=axis, interpolation=interpolation, transposed=is_transposed)

    if result.ndim == 2:
        result = self._constructor(result)
    else:
        result = self._constructor_sliced(result, name=q)

    if is_transposed:
        result = result.T

    return result
```
The corrected version of the function includes a check for `numeric_only` before obtaining the data, ensuring that data includes datetime data if `numeric_only` is `False`. Then, it calls the `quantile` method directly on the data to compute the quantile values, thus correctly handling both numeric and datetime data.