# Analysis
The error occurs when passing a DataFrame of datetime data to the `quantile()` method. The issue seems to originate from the `_get_numeric_data()` method, which may result in an empty DataFrame when called with `numeric_only=True`, and this leads to errors during subsequent operations.

# Bug Cause
The cause of the bug is that the `quantile` function calls the `_get_numeric_data` method, which may result in an empty DataFrame due to the nature of datetime data. When the result is an empty DataFrame, operations on this empty DataFrame lead to errors later and result in the ValueError when concatenating arrays.

# Strategy for Fixing the Bug
The fix should involve identifying whether the DataFrame is empty due to the nature of the data. If the DataFrame is empty, then the quantile operation should be performed directly on the original DataFrame, avoiding unnecessary transformations and operations on an empty DataFrame.

# Corrected Version
```python
def quantile(self, q=0.5, axis=0, numeric_only=True, interpolation="linear"):
    """
    Return values at the given quantile over requested axis.

    <<remaining docstring...>>

    """
  
    if numeric_only:
        if self.empty or self.select_dtypes(include=np.datetime64).empty:
            data = self
        else:
            data = self._get_numeric_data()
    else:
        data = self
  
    <<remaining code...>>
```

In this corrected version of the function, a check is made to see if the DataFrame is empty or if it consists only of datetime data. If either condition is true, the operation is performed on the original DataFrame. Otherwise, the `_get_numeric_data()` method is called as before. This change will help avoid the errors encountered previously.