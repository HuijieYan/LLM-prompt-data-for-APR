The issue in the `quantile` function seems to be related to how the function handles datetime data in a DataFrame, causing a `ValueError` when trying to concatenate the result.

## Bug analysis and potential error location
The bug is likely caused by the DataFrame `_get_numeric_data()` method, which returns an empty DataFrame in the case of datetime data. This causes the downstream code to attempt concatenation with no valid arrays, leading to the `ValueError`.

## Proposed bug fix
One possible strategy to fix the bug is to modify the `_get_numeric_data()` method to handle datetime data properly.

## Corrected version of the function
```python
def quantile(self, q=0.5, axis=0, numeric_only=True, interpolation="linear"):
    self._check_percentile(q)
    
    if numeric_only:
        data = self._get_numeric_data().select_dtypes(exclude=['datetime', 'timedelta'])
    else:
        data = self
    
    axis = self._get_axis_number(axis)
    is_transposed = axis == 1

    if is_transposed:
        data = data.T

    result = data._data.quantile(
        qs=q, axis=1, interpolation=interpolation, transposed=is_transposed
    )

    if result.ndim == 2:
        result = self._constructor(result)
    else:
        result = self._constructor_sliced(result, name=q)

    if is_transposed:
        result = result.T

    return result
```

In this corrected version, the `select_dtypes` method is used to filter out datetime and timedelta data when `numeric_only` is `True`, ensuring that the `quantile` function does not attempt to perform calculations on non-numeric data.

This fix should address the issue with datetime data in the DataFrame `quantile` method as reported in the GitHub issue.