{
    "pandas": [
        {
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 1,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.3.3": 1,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 1
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 1,
                "5": 1,
                "6": 1,
                "7": 0,
                "8": 0,
                "9": 1
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.3.3": 1,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 1
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 1,
                "5": 1,
                "6": 1,
                "7": 0,
                "8": 0,
                "9": 1
            },
            "bugID": 168,
            "start_line": 425,
            "file_name": "pandas/core/groupby/grouper.py",
            "replace_code": "def _get_grouper(\n    obj,\n    key=None,\n    axis=0,\n    level=None,\n    sort=True,\n    observed=False,\n    mutated=False,\n    validate=True,\n):\n    # create and return a BaseGrouper, which is an internal\n    # mapping of how to create the grouper indexers.\n    # This may be composed of multiple Grouping objects, indicating\n    # multiple groupers\n\n    # Groupers are ultimately index mappings. They can originate as:\n    # index mappings, keys to columns, functions, or Groupers\n    group_axis = obj._get_axis(axis)\n\n    if level is not None:\n        if len(group_axis) > 1 and is_list_like(level) or (is_scalar(level) and obj.index.name != level):\n            key = group_axis.get_level_values(level)\n            level = None\n        if isinstance(level, str):\n            if level != obj.index.name:\n                raise ValueError(\"level name {} is not the name of the index\".format(level))\n        elif level > 0 or level < -1:\n            raise ValueError(\"level > 0 or level < -1 only valid with MultiIndex\")\n    \n    if isinstance(key, Grouper):\n        binner, grouper, obj = key._get_grouper(obj, validate=False)\n        if key.key is None:\n            return grouper, [], obj\n        else:\n            return grouper, {key.key}, obj\n    elif isinstance(key, BaseGrouper):\n        return key, [], obj\n    elif isinstance(key, tuple) and not isinstance(obj, dict):\n        key = list(key)\n        msg = (\n            \"Interpreting tuple 'by' as a list of keys, rather than \"\n            \"a single key. Use 'by=[...]' instead of 'by=(...)'. In \"\n            \"the future, a tuple will always mean a single key.\"\n        )\n        warnings.warn(msg, FutureWarning, stacklevel=5)\n    \n    keys = [key] if not isinstance(key, list) else key\n\n    if all(isinstance(g, Grouper) for g in keys):\n        return BaseGrouper(group_axis, keys, sort=sort, mutated=mutated), [], obj\n\n    if len(keys) == len(group_axis):\n        if all(callable(g) or isinstance(g, dict) for g in keys):\n            pass\n        elif all(\n            isinstance(g, (list, tuple, Series, Index, np.ndarray)) for g in keys\n        ):\n            keys = [com.asarray_tuplesafe(keys)]\n        elif any(isinstance(key, (str, int, float)) for key in group_axis):\n            if all(\n                key in group_axis or key in obj.index.names or key in obj.columns\n                for key in keys\n            ):\n                pass\n        else:\n            raise KeyError('Some keys are not found')\n    else:\n        raise ValueError(\"No group keys passed!\")\n\n    groupings = []\n\n    for g in keys:\n        if isinstance(g, Grouping):\n            groupings.append(g)\n        else:\n            ping = Grouping(\n                group_axis, g, obj=obj, name=None, level=level, sort=sort, observed=observed\n            )\n            groupings.append(ping)\n\n    return BaseGrouper(group_axis, groupings, sort=sort, mutated=mutated), [], obj",
            "import_list": []
        }
    ]
}