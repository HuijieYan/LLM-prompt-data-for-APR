```python
def _get_grouper(
    obj,
    key=None,
    axis=0,
    level=None,
    sort=True,
    observed=False,
    mutated=False,
    validate=True,
):
    """
    create and return a BaseGrouper, which is an internal
    mapping of how to create the grouper indexers.
    This may be composed of multiple Grouping objects, indicating
    multiple groupers

    Groupers are ultimately index mappings. They can originate as:
    index mappings, keys to columns, functions, or Groupers

    Groupers enable local references to axis,level,sort, while
    the passed in axis, level, and sort are 'global'.

    This routine tries to figure out what the passing in references
    are and then creates a Grouping for each one, combined into
    a BaseGrouper.

    If observed & we have a categorical grouper, only show the observed
    values

    If validate, then check for key/level overlaps

    """
    group_axis = obj._get_axis(axis)

    # validate that the passed single level is compatible with the passed
    # axis of the object
    if level is not None:
        if isinstance(group_axis, MultiIndex):
            if is_list_like(level) and len(level) == 1:
                level = level[0]

            if key is None and is_scalar(level):
                # Get the level values from group_axis
                key = group_axis.get_level_values(level)
                level = None
        else:
            if is_list_like(level):
                nlevels = len(level)
                if nlevels == 1:
                    level = level[0]
                elif nlevels == 0:
                    raise ValueError("No group keys passed!")
                else:
                    raise ValueError("multiple levels only valid with MultiIndex")

            if (
                isinstance(level, str)
                or level > 0
                or level < -1
                or (is_list_like(level) and len(level) != 1)
            ):
                raise ValueError("level must be a single label with MultiIndex")

            if isinstance(level, str) and obj.index.name != level:
                raise KeyError(f"level name {level} is not the name of the index")

    # a passed-in Grouper, directly convert
    if isinstance(key, Grouper):
        binner, grouper, obj = key._get_grouper(obj, validate=False)
        if key.key is None:
            return grouper, [], obj
        else:
            return grouper, {key.key}, obj

    # already have a BaseGrouper, just return it
    elif isinstance(key, BaseGrouper):
        return key, [], obj

    if not isinstance(key, list):
        keys = [key]
        match_axis_length = False
    else:
        keys = key
        match_axis_length = len(keys) == len(group_axis)

    any_callable = any(callable(g) or isinstance(g, (dict, Grouper)) for g in keys)
    any_arraylike = any(
        isinstance(g, (list, tuple, Series, Index, np.ndarray)) for g in keys
    )

    if not any_callable and any_arraylike and match_axis_length and level is None:
        valid_column_names = (
            [col for col in obj.columns if col in keys] if isinstance(obj, DataFrame) else []
        )
        keys = [com.asarray_tuplesafe(valid_column_names)]

    exclusions = []
    groupings = []

    for i, (gpr, level) in enumerate(zip(keys, [level] * len(keys)):
        # if the actual grouper should be obj[key]
        in_axis = not is_list_like(gpr) and gpr in group_axis
        raise_error = False
        if not in_axis:
            for col_title, unique_col in obj.items():
                if (is_list_like(gpr) and set(gpr) <= set(col_title)) or gpr == col_title:
                    in_axis = (
                        in_axis or not all(not is_list_like(gpr) or i in group_axis for i in gpr)
                    )
                    break
            if (
                not in_axis
                and isinstance(obj, DataFrame)
                and not all(gpr in group_axis or gpr in obj.columns for gpr in keys)
            ):
                exclusions.append(gpr)
                raise_error = True

        if isinstance(gpr, Grouper) and gpr.key is not None:
            exclusions.append(gpr.key)
        elif raise_error:
            raise KeyError(gpr)

        if is_categorical_dtype(obj[gpr]) and len(obj[gpr]) != len(obj):
            raise ValueError(f"Length of grouper and axis must be same length")

        # create the Grouping
        ping = Grouping(
            group_axis,
            gpr,
            name=gpr,
            level=level,
            sort=sort,
            observed=observed,
            in_axis=in_axis,
        )
        groupings.append(ping)

    if len(groupings) == 0 and len(obj):
        raise ValueError("No group keys passed!")

    grouper = BaseGrouper(group_axis, groupings, sort=sort, mutated=mutated)
    return grouper, exclusions, obj
```