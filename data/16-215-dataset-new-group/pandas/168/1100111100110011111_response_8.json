{
    "pandas": [
        {
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 1,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.3.3": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.5": 0,
                "2.1.6": 0,
                "2.1.3": 1,
                "2.1.4": 1,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 1
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 1,
                "6": 0,
                "7": 1,
                "8": 1,
                "9": 1
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.3.3": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.5": 0,
                "2.1.6": 0,
                "2.1.3": 1,
                "2.1.4": 1,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 1
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 1,
                "6": 0,
                "7": 1,
                "8": 1,
                "9": 1
            },
            "bugID": 168,
            "start_line": 425,
            "file_name": "pandas/core/groupby/grouper.py",
            "replace_code": "def _get_grouper(\n    obj,\n    key=None,\n    axis=0,\n    level=None,\n    sort=True,\n    observed=False,\n    mutated=False,\n    validate=True,\n):\n    group_axis = obj._get_axis(axis)\n    \n    if is_categorical_dtype(key):\n        if len(key) != obj.shape[axis]:\n            raise ValueError(\n                (\"Length of grouper ({len_gpr}) and axis ({len_axis})\"\n                \" must be same length\".format(\n                    len_gpr=len(key), len_axis=obj.shape[axis]\n                ))\n            )\n\n    if isinstance(key, Grouper):\n        if key.key is None:\n            binner, grouper, obj = key._get_grouper(obj, validate=False)\n            return grouper, [], obj\n        else:\n            binner, grouper, obj = key._get_grouper(obj, validate=False)\n            return grouper, {key.key}, obj\n\n    elif isinstance(key, BaseGrouper):\n        return key, [], obj\n\n    if isinstance(key, tuple):\n        is_hashable = all(isinstance(k, str) for k in key)\n        if is_hashable and not set(key).difference(obj.columns) and all(k in obj for k in key):\n            msg = (\"Interpreting tuple 'by' as a list of keys, rather than \"\n                   \"a single key. Use 'by=[...]' instead of 'by=(...)'. In \"\n                   \"the future, a tuple will always mean a single key.\")\n            warnings.warn(msg, FutureWarning, stacklevel=5)\n            key = list(key)\n\n    if not isinstance(key, list):\n        keys = [key]\n    else:\n        keys = key\n\n    any_callable = any(callable(g) or isinstance(g, dict) for g in keys)\n    any_groupers = any(isinstance(g, Grouper) for g in keys)\n    any_arraylike = any(\n        isinstance(g, (list, tuple, Series, Index, np.ndarray)) for g in keys\n    )\n\n    match_axis_length = len(keys) == len(group_axis) and not level\n\n    if match_axis_length and not (any_callable or any_arraylike or any_groupers):\n        all_in_columns_index = all(g in obj.columns or g in obj.index.names for g in keys)\n\n        if not all_in_columns_index:\n            keys = [com.asarray_tuplesafe(keys)]\n\n    if isinstance(level, (tuple, list)):\n        if key is None:\n            keys = [None] * len(level)\n        levels = level\n    else:\n        levels = [level] * len(keys)\n\n    groupings = []\n    exclusions = []\n\n    for gpr, lev in zip(keys, levels):\n        # Validation of key\n        # i.e. check if gpr is part of index or is a level\n        if isinstance(gpr, Grouper) and gpr.key is not None:\n            exclusions.append(gpr.key)\n        elif is_hashable and gpr in obj.columns:\n            obj._check_label_or_level_ambiguity(gpr)\n            exclusions.append(gpr)\n        elif lev is not None:\n            raise ValueError(\"Categorical groupers must be sorted\")\n        else:\n            raise KeyError(gpr)\n\n        groupings.append(Grouping(group_axis, gpr, obj=obj, level=lev, sort=sort, observed=observed))\n\n    if len(groupings) == 0 and len(obj):\n        raise ValueError(\"No group keys passed!\")\n\n    grouper = BaseGrouper(group_axis, groupings, sort=sort, mutated=mutated)\n    return grouper, exclusions, obj",
            "import_list": []
        }
    ]
}