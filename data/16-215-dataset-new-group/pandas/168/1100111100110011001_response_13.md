```python
def _get_grouper(
    obj,
    key=None,
    axis=0,
    level=None,
    sort=True,
    observed=False,
    mutated=False,
    validate=True,
):
    """
    create and return a BaseGrouper, which is an internal
    mapping of how to create the grouper indexers.
    This may be composed of multiple Grouping objects, indicating
    multiple groupers.

    Groupers are ultimately index mappings. They can originate as:
    index mappings, keys to columns, functions, or Groupers.

    Groupers enable local references to axis, level, sort, while
    the passed-in axis, level, and sort are 'global'.

    This routine tries to figure out what the passing-in references
    are and then creates a Grouping for each one, combined into
    a BaseGrouper.

    If observed and we have a categorical grouper, only show the observed
    values.

    If validate, then check for key/level overlaps.

    """
    group_axis = obj._get_axis(axis)

    if isinstance(key, Grouper):
        binner, grouper, obj = key._get_grouper(obj, validate=False)
        if key.key is None:
            return grouper, [], obj
        else:
            return grouper, {key.key}, obj

    elif isinstance(key, BaseGrouper):
        return key, [], obj

    is_tuple = isinstance(key, tuple)
    all_hashable = is_tuple and all(map(is_hashable, key))

    if is_tuple and (all_hashable or set(key).issubset(obj)):
        # Convert tuple 'by' as a list of keys
        msg = (
            "Interpreting tuple 'by' as a list of keys, rather than "
            "a single key. Use 'by=[...]' instead of 'by=(...)'. In "
            "the future, a tuple will always mean a single key."
        )
        warnings.warn(msg, FutureWarning, stacklevel=5)
        key = list(key)

    if not isinstance(key, list):
        keys = [key]
    else:
        keys = key

    match_axis_length = len(keys) == len(group_axis)

    # Create groupings based on the keys
    groupings = []
    exclusions = []

    # Iterate over keys and create Grouping objects
    for i, k in enumerate(keys):
        if k in obj or k in obj.index.names:
            in_axis = True
            name = k
            exclusions.append(k)
        else:
            in_axis = False
            name = None

        # Create Grouping for each key
        groupings.append(
            Grouping(group_axis, k, obj=obj, name=name, level=level, sort=sort, observed=observed, in_axis=in_axis)
        )

    if len(groupings) == 0:
        raise ValueError("No group keys passed!")

    # Create and return the BaseGrouper
    grouper = BaseGrouper(group_axis, groupings, sort=sort, mutated=mutated)
    return grouper, exclusions, obj
```