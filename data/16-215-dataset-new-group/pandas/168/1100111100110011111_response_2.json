{
    "pandas": [
        {
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 1,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.3.3": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.5": 0,
                "2.1.6": 0,
                "2.1.3": 1,
                "2.1.4": 1,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 1
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 1,
                "6": 0,
                "7": 1,
                "8": 1,
                "9": 1
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.3.3": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.5": 0,
                "2.1.6": 0,
                "2.1.3": 1,
                "2.1.4": 1,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 1
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 1,
                "6": 0,
                "7": 1,
                "8": 1,
                "9": 1
            },
            "bugID": 168,
            "start_line": 425,
            "file_name": "pandas/core/groupby/grouper.py",
            "replace_code": "def _get_grouper(\n    obj,\n    key=None,\n    axis=0,\n    level=None,\n    sort=True,\n    observed=False,\n    mutated=False,\n    validate=True,\n):\n    group_axis = obj._get_axis(axis)\n\n    if level is not None:\n        if obj.index.nlevels > 1:\n            if isinstance(level, str):\n                level = [level]\n            elif not is_list_like(level):\n                level = [level]\n\n            level = [obj.index._get_level_number(lev) for lev in level]\n            level = [lev if lev != -1 else obj.index.nlevels - 1 for lev in level]\n        else:\n            if isinstance(level, (list, tuple)):\n                level = level[0] if len(level) == 1 else None\n            else:\n                level = None\n\n        key = obj.index.get_level_values(level)\n\n    if isinstance(key, Grouper):\n        binner, grouper, obj = key._get_grouper(obj, validate=False)\n        if key.key is None:\n            return grouper, [], obj\n        else:\n            return grouper, {key.key}, obj\n    elif isinstance(key, BaseGrouper):\n        return key, [], obj\n\n    if isinstance(key, tuple):\n        if not is_hashable(key) or (set(key) - set(obj.columns)):\n            msg = (\n                \"Interpreting tuple 'by' as a list of keys, rather than a single key.\"\n                \" Use 'by=[...]' instead of 'by=(...)'.\"\n            )\n            warnings.warn(msg, FutureWarning, stacklevel=5)\n            key = list(key)\n\n    if not isinstance(key, list):\n        keys = [key]\n    else:\n        keys = key\n\n    result = []\n    for gpr in keys:\n        if is_scalar(gpr) and is_categorical_dtype(gpr):\n            raise TypeError(\"Categorical dtypes not supported, use values\")\n        if is_scalar(gpr):\n            xrange = grouper = obj[gpr]\n        else:\n            mask = obj.columns.isin(obj.columns.intersection(gpr))\n            if not mask.all():\n                bad = gpr[~mask]\n                raise KeyError(\"{} not in index\".format(bad))\n            xrange = grouper = obj.loc[:, gpr]\n        result.append(grouper)\n\n    return result, [], obj",
            "import_list": []
        }
    ]
}