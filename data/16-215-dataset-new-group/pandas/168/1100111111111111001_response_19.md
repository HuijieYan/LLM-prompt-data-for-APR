```python
from pandas.core.groupby import Grouper, Grouping
import pandas as pd
from pandas.testing import assert_frame_equal
from pandas import MultiIndex

def _get_grouper(
    obj,
    key=None,
    axis=0,
    level=None,
    sort=True,
    observed=False,
    mutated=False,
    validate=True,
):
    group_axis = obj._get_axis(axis)
    key_name = key.name if isinstance(key, Grouper) else None

    level_values = None
    if level is not None:
        value = None
        if isinstance(level, (list, tuple)):
            value = level[0]
        elif isinstance(level, str):
            if level != obj.index.name:
                raise ValueError(f"level name {level} is not the name of the index")
        elif level > 0 or level < -1:
            raise ValueError("level > 0 or level < -1 only valid with MultiIndex")
        if value is not None:
            if isinstance(group_axis, MultiIndex):
                level_values = group_axis.get_level_values(value) 
                level = None  # reset level if present

    if isinstance(key, BaseGrouper):
        return key, [], obj

    elif isinstance(key, Grouper):
        # extract the grouper to avoid retrieving the groups again
        if key.get_grouper(obj).key is None:
            return key, [], obj
        else:
            return key, {key.get_grouper(obj).key}, obj
        
    elif isinstance(key, tuple):
        if key not in obj and set(key).issubset(obj):
            key = list(key)
            warnings.warn(("Interpreting tuple 'by' as a list of keys, rather than "
                           "a single key. Use 'by=[...]' instead of 'by=(...)'. In "
                           "the future, a tuple will always mean a single key."), 
                           FutureWarning, stacklevel=5)

    if not isinstance(key, list):
        key = [key]

    match_axis_length = len(key) == len(group_axis)
    any_callable = any(callable(g) or isinstance(g, dict) for g in key)
    any_arraylike = any(
        isinstance(g, (list, tuple, Series, Index, np.ndarray)) for g in key
    )

    all_in_columns_index = all(
        g in obj.columns or g in obj.index.names for g in key
    )
    if not all_in_columns_index and match_axis_length and not any_callable and not any_arraylike:
        key = [key]

    for i, k in enumerate(key):
        name_arg, groups = None, level_values
        if is_in_obj(k):
            exclusions.append(k.name)
        elif is_in_axis(k):
            name_arg = k
            if validate:
                obj._check_label_or_level_ambiguity(k)
            groups = obj[k]
            exclusions.append(name_arg)
        elif isinstance(k, Grouper) and k.key is not None:
            exclusions.add(k.key)

        g = Grouping(
            group_axis,
            k,
            name=name_arg,
            level=groups,
            sort=sort,
            observed=observed
        )
        groupings.append(g)
    
    # if no group keys were passed
    if not groupings and len(obj):
        raise ValueError("No group keys passed!")
    
    grouper = BaseGrouper(group_axis, groupings, sort=sort, mutated=mutated)
    return grouper, exclusions, obj
```