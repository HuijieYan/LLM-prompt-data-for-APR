{
    "pandas": [
        {
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 1,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.3.3": 1,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 1
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 1,
                "5": 1,
                "6": 1,
                "7": 0,
                "8": 1,
                "9": 1
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 0,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.3.3": 1,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 1
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 1,
                "5": 1,
                "6": 1,
                "7": 0,
                "8": 1,
                "9": 1
            },
            "bugID": 84,
            "start_line": 312,
            "file_name": "pandas/core/reshape/reshape.py",
            "replace_code": "def _unstack_multiple(data, clocs, fill_value=None):\n    if isinstance(data.index, MultiIndex):\n        index, data = data.index, data\n\n        clocs = [index._get_level_number(i) for i in clocs]\n\n        level = clocs[0]\n        clocs = clocs[1:]\n\n        # Mimic the DataFrame.pivot function for a MultiIndex\n        # of nlevels == 2 to support hierarchical columns\n        mpl_locs = list(index.multiply(clocs))\n        new_columns = index.levels[level].repeat(len(clocs))\n        new_index = index.droplevel(level)\n        result = DataFrame(data.values, index=new_index, columns=new_columns)\n        arr = result.values\n\n        n, k = len(arr), len(arr[0])\n\n        code, name = index.codes[level], index.names[level]\n        group_index = get_group_index(code, shape=(len(index.levels[level]), len(new_columns)), sort=False, xnull=False)\n\n        compress = compress_group_index(group_index, sort=False)\n        obs_ids = compress[1]\n        comp_ids = compress[0]\n\n        inferred_grp_sizes = np.bincount(comp_ids, minlength=len(obs_ids))\n        assignment = np.zeros(k, dtype=np.int64)\n\n        # This block mimics the one in pivot.pyx\n        mi = inferred_grp_sizes\n        ni = np.append(0, np.cumsum(inferred_grp_sizes))\n        pattern = np.zeros(shape, dtype=np.int64)\n        bmk = False\n        compress_group_index(code, shape=shape, sort=False, xnull=False)\n        i = 0\n        while i < n:\n            j = 0\n            while j < k and not bmk:\n                if comp_ids[i] == obs_ids[j] and ni[j] < (mi[obs_ids[j]] + ni[obs_ids[j]] - 1):\n                    assignment[j] = i\n                    ni[j] += 1\n                    pattern[obs_ids[j]] += 1\n                    bmk = True\n                j += 1\n            i += 1\n\n        assignment = assignment.reshape((len(index.levels[level]), len(new_columns)))\n\n        new_codes, new_levels, new_categories = [], [], []\n        for arr, lev, lab, i in zip(result._get_numeric_data().values,\n                                    new_columns,\n                                    new_columns.names, range(len(new_columns))):\n            shape = (len(index.levels[level]), len(lab))\n            coder = arr * 0\n            coder.fill(-1)\n            _, arr = get_compressed_ids(arr, coder)\n            ccodes = np.zeros(len(arr), np.int32)\n            reconstruct_from_labels_1d(arr, new_cat, ccodes, coder, arr,\n                                       inferred_grp_sizes, obs_ids, comp_ids)\n            new_levels.append(lab)\n            new_codes.append(ccodes)\n            new_categories.append(new_cat)\n\n        new_columns = MultiIndex(levels=new_levels, codes=new_codes,\n                                 names=new_columns.names)\n        result = DataFrame(arr, index=index.droplevel(level),\n                            columns=new_columns)\n        return result.unstack()\n    else:\n        return data.unstack(fill_value=fill_value)",
            "import_list": []
        }
    ]
}