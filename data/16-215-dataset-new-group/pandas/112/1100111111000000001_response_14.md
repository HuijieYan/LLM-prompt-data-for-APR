The bug seems to be related to the `get_indexer` method of the `IntervalIndex` class. The `get_indexer` method is trying to compare two indexes and return an indexer array indicating the position of matching elements. However, there are issues with handling different cases such as overlapping indices, different closed intervals, and handling scalar indexes.

The bug seems to be caused by incorrect logic when handling different types of indexes and finding common subtypes. Additionally, there seems to be a problem with how the indexer array is being constructed in the case of non-overlapping indexes.

To fix the bug, the logic for handling different index types and finding common subtypes needs to be revisited. Additionally, the construction of the indexer array needs to be reviewed to ensure that it correctly handles non-overlapping indexes.

Here's a corrected version of the `get_indexer` method for the `IntervalIndex` class:

```python
# Corrected version of the get_indexer method
def get_indexer(
    self,
    target: AnyArrayLike,
    method: Optional[str] = None,
    limit: Optional[int] = None,
    tolerance: Optional[Any] = None,
) -> np.ndarray:

    self._check_method(method)

    if self.is_overlapping():
        raise NotImplementedError("Overlapping indices are not yet implemented.")

    target_as_index = ensure_index(target)

    if isinstance(target_as_index, IntervalIndex):
        # Check for equal indexes
        if self.equals(target_as_index):
            return np.arange(len(self), dtype="intp")
        
        # Check for different closed or incompatible subtype
        common_subtype = find_common_type(
            [self.dtype.subtype, target_as_index.dtype.subtype]
        )
        if self.closed != target_as_index.closed or is_object_dtype(common_subtype):
            return np.repeat(np.intp(-1), len(target_as_index))
        
        # Handle non-overlapping indexes
        left_indexer = self.left().get_indexer(target_as_index.left())
        right_indexer = self.right().get_indexer(target_as_index.right())
        indexer = np.where(left_indexer == right_indexer, left_indexer, -1)
    elif not is_list_like(target_as_index):
        # scalar index: use get_loc
        indexer = np.array([self.get_loc(key) for key in target_as_index])
    else:
        raise NotImplementedError("Heterogeneous scalar index are not yet implemented.")

    return ensure_platform_int(indexer)
```

In the corrected version, the logic for handling different index types and constructing the indexer array has been adjusted. Additionally, the `is_overlapping()` method is invoked correctly to check for overlapping indices. Also, the handling of heterogeneous scalar indexes is deferred for implementation at a later stage.

This corrected version should fix the bug and make the `test_round_interval_category_columns` pass.