The bug in the `_get_with` function seems to be caused by the incorrect handling of the `key_type` variable. The variable `key_type` is being incorrectly inferred as `'string'`, which is not correct. This leads to unexpected behavior and errors when the function later tries to use `key_type`. 

To fix the bug, we should ensure that the `key_type` is correctly inferred based on the input `key`. Specifically, for the failing test cases, the `key_type` should be inferred as something like `'object'` or `'string'`.

Here is the corrected version of the `_get_with` function:

```python
def _get_with(self, key):
        if isinstance(key, slice):
            slobj = self.index._convert_slice_indexer(key, kind="getitem")
            return self._slice(slobj)
        elif isinstance(key, (ABCDataFrame, ABCSeries, MultiIndex)):
            raise TypeError(
                "Indexing a Series with DataFrame/Series/MultiIndex is not "
                "supported, use the appropriate DataFrame column"
            )
        elif isinstance(key, tuple):
            return self._get_values_tuple(key)
        
        if not is_list_like(key):
            return self.loc[key]
        
        if isinstance(key, (list, np.ndarray, ExtensionArray, Index)):
            key = list(key)
        
        key_type = lib.infer_dtype(key, skipna=False)
        
        if key_type in ['integer', 'mixed-integer']:
            if not self.index._should_fallback_to_positional():
                return self.loc[key]
            else:
                return self.iloc[key]
        
        if isinstance(key, list):
            return self.loc[key]
        
        return self.reindex(key)
```

By using `lib.infer_dtype(key, skipna=False)` to infer the `key_type`, we ensure that the `key_type` is correctly determined based on the input `key`. This should fix the bug and make the function pass the failing test.