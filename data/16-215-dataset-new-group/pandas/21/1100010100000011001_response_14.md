The bug in the function seems to be related to how the key_type is being determined and handled. It appears that the code may not be correctly identifying the type of the key and executing the appropriate logic based on that type.

To fix the bug, the function should directly determine the type of the key and execute the corresponding logic. We can also simplify the code by removing unnecessary checks and redundant type conversions.

Here's the corrected version of the function:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not "
            "supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)

    if isinstance(key, (list, np.ndarray, ExtensionArray, Series, Index)):
        return self.reindex(key)

    if not is_list_like(key):
        return self.loc[key]

    key_type = lib.infer_dtype(key, skipna=False)

    if key_type == "integer":
        if not self.index._should_fallback_to_positional():
            return self.loc[key]
        else:
            return self.iloc[key]

    if key_type == "boolean":
        # The boolean case should be caught by the com.is_bool_indexer check in __getitem__
        raise TypeError("Boolean indexing is not supported")

    # handle the dup indexing case GH#4246
    return self.loc[key]
```

This corrected version directly determines the key_type and executes the appropriate logic based on that type. It also removes redundant type checks and simplifies the code.

With this correction, the function should satisfy all the expected input/output values for the given test cases.