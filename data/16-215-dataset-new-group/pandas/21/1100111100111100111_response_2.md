To fix the bug in the `_get_with` function, we need to address the inconsistent behavior for list indexers compared to array-like indexers. The issue points out that `ser.loc[key]` raises an error for all cases, so we need to ensure consistent behavior across all types of indexers.

Based on the runtime values and types of the input parameters and variables, it seems that the `key_type` is incorrectly set to `'string'` in all cases, which indicates that the logic for inferring the key type is faulty.

To fix the bug, we can modify the logic for inferring the key type and ensure consistent behavior for all indexers.

Here's the corrected version of the `_get_with` function:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not "
            "supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)
    
    if not is_list_like(key):
        return self.loc[key]
    
    if isinstance(key, (Index, list, np.ndarray, ExtensionArray, Series)):
        key_type = lib.infer_dtype(key, skipna=False)
        
        if key_type == "integer":
            if not self.index._should_fallback_to_positional():
                return self.loc[key]
            else:
                return self.iloc[key]
    
    return self.reindex(key)
```

By updating the logic to infer the `key_type` based on the type of `key`, we ensure that the behavior is consistent for all types of indexers. This should resolve the issue reported on GitHub, and the corrected function should pass the failing tests.