The bug in the function `_get_with` seems to be in the logic that handles different types of keys. Based on the provided input values and types, the key type is always inferred as a string, even when it should be a list or ndarray, which causes the wrong behavior.

To fix the bug, we should update the logic for inferring the key type and handling different key types before the function's return.

Here's the corrected version of the function:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not "
            "supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)

    if not is_list_like(key):
        return self.loc[key]

    if not isinstance(key, (list, np.ndarray, ExtensionArray, Series, Index)):
        key = [key]

    if isinstance(key, Index):
        key_type = 'index'
    elif isinstance(key, np.ndarray):
        key_type = 'ndarray'
    else:
        key_type = lib.infer_dtype(key, skipna=False)

    if key_type == "integer":
        if not self.index._should_fallback_to_positional():
            return self.loc[key]
        else:
            return self.iloc[key]

    if isinstance(key, list):
        return self.loc[key]

    return self.reindex(key)
```

In this corrected version, we added a check for the type of the key and updated the logic to handle different key types properly. This approach should fix the bug and make the function pass the failing tests.