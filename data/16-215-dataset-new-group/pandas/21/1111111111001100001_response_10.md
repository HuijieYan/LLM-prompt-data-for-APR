The bug in the `_get_with` function seems to be related to the handling of the `key` parameter, as we can see inconsistent types and values for the `key_type` variable at the function's return.

The `_get_with` function checks the type of the `key` parameter and then processes it accordingly. However, in the provided test case, the key is always a single value, but the function seems to handle lists, tuples, and other types differently. This inconsistency in the handling of different types of keys could be the cause of the bug.

To fix the bug, we should ensure that the function handles single values consistently regardless of their specific type.

Here's a corrected version of the `_get_with` function:
```python
def _get_with(self, key):
        if isinstance(key, (list, np.ndarray, ExtensionArray, Series, Index)):
            key = list(key)
            key_type = lib.infer_dtype(key, skipna=False)

            if key_type == "integer":
                if not self.index._should_fallback_to_positional():
                    return self.loc[key]
                else:
                    return self.iloc[key]

            # handle the dup indexing case
            return self.loc[key]

        elif isinstance(key, ABCDataFrame):
            raise TypeError(
                "Indexing a Series with DataFrame is not "
                "supported, use the appropriate DataFrame column"
            )

        elif not is_list_like(key):
            return self.loc[key]
    
        else:
            return self.loc[key]
```
This corrected version treats all types of keys consistently by converting them to a list and then checking their type and processing them accordingly.

This should fix the bug and make the function behave as expected.