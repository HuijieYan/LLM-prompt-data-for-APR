Based on the input parameters and the runtime values and types of variables inside the buggy function, it seems that the issue lies in the handling of the key type. The key type is incorrectly inferred as `'string'` in all cases, leading to inconsistent behavior.

To fix the bug, we can modify the `_get_with` function to correctly infer the type of the key and handle the different cases accordingly. Specifically, we need to ensure that the list indexers are treated the same as array-like indexers, and that the appropriate error is raised when there are no matches.

Here's the corrected version of the `_get_with` function:

```python
def _get_with(self, key):
    # other: fancy integer or otherwise
    if isinstance(key, (list, np.ndarray, ExtensionArray, Series, Index)):
        if not is_list_like(key):
            # e.g. scalars that aren't recognized by lib.is_scalar, GH#32684
            return self.loc[key]
        
        key = list(key)

        if isinstance(key, Index):
            key_type = key.inferred_type
        else:
            key_type = lib.infer_dtype(key, skipna=False)

        if key_type == "integer":
            # We need to decide whether to treat this as a positional indexer
            #  (i.e. self.iloc) or label-based (i.e. self.loc)
            if not self.index._should_fallback_to_positional():
                return self.loc[key]
            else:
                return self.iloc[key]

    else:
        raise TypeError(f"Unsupported type for indexing: {type(key)}")

    if isinstance(key, list):
        # handle the dup indexing case GH#4246
        return self.loc[key]

    raise KeyError(f"None of {key} are in the index")
```

In this corrected version, we handle the different cases of key types and ensure that the appropriate actions are taken for each case. We also raise the correct error when there are no matches in the index.

This should resolve the inconsistency and address the GitHub issue as well.