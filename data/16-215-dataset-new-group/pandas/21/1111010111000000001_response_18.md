There are a couple of parts in the `_get_with` function that need fixing. 

1. The logic within the `if not is_list_like(key)` block should be modified in order to handle the scalar cases correctly. The current implementation directly calls `self.loc[key]`, but it should first convert the scalar to a list-like object and then perform the operation.

2. The `if isinstance(key, Index)` block should compare `key_type` to the inferred type of the key when the key is an Index.

Additionally, the last `if` condition of the function may need to be revisited to ensure that the correct reindexing behavior is implemented.

Here's a corrected version of the `_get_with` function:

```python
def _get_with(self, key):
    # other: fancy integer or otherwise
    if isinstance(key, slice):
        # _convert_slice_indexer to determine if this slice is positional
        # or label-based, and if the latter, convert to positional
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)

    if not is_list_like(key):
        # Wrap the scalar key in a list-like object
        key = [key]

    if isinstance(key, Index):
        # Compare the inferred type of the key when it's an Index
        key_type = key.inferred_type
    else:
        key_type = lib.infer_dtype(key, skipna=False)

    # Convert key to a list if it's not a list, numpy array, ExtensionArray, Series, or Index
    if not isinstance(key, (list, np.ndarray, ExtensionArray, Series, Index)):
        key = list(key)

    if key_type == "integer":
        # We need to decide whether to treat this as a positional indexer
        # (i.e. self.iloc) or label-based (i.e. self.loc)
        if not self.index._should_fallback_to_positional():
            return self.loc[key]
        else:
            return self.iloc[key]

    # handle the dup indexing case GH#4246
    return self.reindex(key)
```

This corrected version of the function should now handle scalar values correctly, compare the inferred type of the key when it's an Index, and consistently handle all other types of keys.