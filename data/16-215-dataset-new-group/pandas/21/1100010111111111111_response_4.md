The issue arises from the discrepancy in how different types of indexers are handled by the `_get_with` function. It leads to inconsistent behavior in handling list indexers compared to array-like indexers.

To fix the bug, we need to ensure that all types of indexers are handled consistently within the `_get_with` function.

Here's the corrected version of the `_get_with` function:

```python
def _get_with(self, key):
    # other: fancy integer or otherwise
    if isinstance(key, slice):
        # _convert_slice_indexer to determine if this slice is positional
        #  or label based, and if the latter, convert to positional
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not "
            "supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, (tuple, list, np.ndarray, Index)):
        return self._get_values_tuple(key)
    else:
        # handle the case where key is not list-like
        return self.loc[key]
```

In the corrected version, we've removed the unnecessary type checks and instead treated all indexers consistently. This should ensure that the function behaves uniformly for all types of indexers and address the inconsistency issue reported in the GitHub thread.