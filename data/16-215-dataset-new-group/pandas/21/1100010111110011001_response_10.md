To fix the bug in the `_get_with` function, we need to address the issue with the incorrect checking of the key type and the return value based on the key type.

The bug occurs because the function incorrectly handles the key as a list or an ndarray, causing it to not raise a `KeyError` as expected. Additionally, there is an issue with the way key types are being determined and handled.

Here's the corrected version of the function:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not "
            "supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)

    # Check if the key is a scalar
    if is_scalar(key):
        return self.loc[key]

    if not is_list_like(key):
        raise TypeError("Key must be list-like or ndarray")

    # If key is an Index or a Series, convert it to a list
    if isinstance(key, (Index, Series)):
        key = key.tolist()

    # Determine key_type based on the type of key
    if is_bool(key):
        key_type = "boolean"
    elif is_integer(key):
        key_type = "integer"
    else:
        key_type = "string"

    if key_type == "integer" and not self.index._should_fallback_to_positional():
        return self.loc[key]
    else:
        return self.iloc[key]
```

In the corrected version, we first check if the key is a scalar using the `is_scalar` function. If it is a scalar, we return the result of `self.loc[key]` as it would handle scalar keys appropriately.

Next, we check if the key is not list-like, and if so, we raise a `TypeError` to indicate that the key must be list-like or an ndarray.

We then handle the case where the key is an instance of `Index` or `Series`, converting it to a list using the `tolist()` method.

Afterwards, we determine the `key_type` based on the type of the key, distinguishing between boolean, integer, and string types. Finally, based on the `key_type`, we use `self.loc[key]` or `self.iloc[key]` to return the result accordingly.

This corrected version of the function should now pass the failing test cases and satisfy all the expected input/output values.