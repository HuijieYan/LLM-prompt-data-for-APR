The bug in the `_get_with` function is caused by the incorrect handling of the list indexer. When a list indexer is used, the function should return `self.loc[key]` for consistency with other array-like indexers. However, the code mistakenly uses `self.reindex(key)` when a list indexer is encountered.

To fix this bug, the function needs to be updated to handle list indexers correctly by returning `self.loc[key]` for list-like keys. Here's the corrected version of the function:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not "
            "supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)
    elif not is_list_like(key):
        return self.loc[key]
    if not isinstance(key, (list, np.ndarray, ExtensionArray, Series, Index)):
        key = list(key)
    if isinstance(key, Index):
        key_type = key.inferred_type
    else:
        key_type = lib.infer_dtype(key, skipna=False)
    if key_type == "integer":
        if not self.index._should_fallback_to_positional():
            return self.loc[key]
        else:
            return self.iloc[key]
    if isinstance(key, list):
        return self.loc[key]
    return self.loc[key]
```

This corrected version of the function ensures that list-like keys are handled correctly by returning `self.loc[key]`. This will resolve the inconsistency in behavior when using list, array, Index, and Series indexers, which caused the failing test cases.

By making this change, the corrected function will align with the expected behavior described in the GitHub issue, and the tests will pass without raising a KeyError.