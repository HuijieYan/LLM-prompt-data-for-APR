The issue seems to be related to the inconsistency in behavior when using different types of indexers, such as a list, ndarray, Index, or Series. The failing tests and the provided bug description indicate that there is an inconsistency in how these indexers are handled in the `Series` class, especially when accessing non-existent keys.

Based on the provided information, it seems that the bug is in the handling of the non-existent keys when using a list as an indexer, as it results in a KeyError instead of returning NaN as it does with other types of indexers.

To fix the bug, we need to handle the case of a non-existent key when a list is used as an indexer and make it consistent with the behavior of other indexers.

Here is the corrected version of the function:

```python
def _get_with(self, key):
    # other: fancy integer or otherwise
    if isinstance(key, slice):
        # _convert_slice_indexer to determin if this slice is positional
        #  or label based, and if the latter, convert to positional
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not "
            "supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)

    # Handle different types of non-existent keys in a consistent manner
    try:
        return self.loc[key]
    except KeyError:
        return self.reindex(key)
```

In the corrected version, the non-existent key when using a list as an indexer is now handled by catching the KeyError and falling back to reindexing the key.

This should address the inconsistency and fix the bug, ensuring that all types of indexers behave consistently when accessing non-existent keys.

After making this change, the function should pass the failing tests and satisfy the expected input/output values.