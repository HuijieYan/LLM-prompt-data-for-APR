The bug in the `_get_with` function seems to be the incorrect handling of the key type, as well as the inconsistency in handling different types of keys. It also seems that the inferred key type is not always being captured correctly.

A possible strategy for fixing the bug would be to standardize the handling of different key types, ensuring that the key type is correctly identified, and then applying the appropriate logic based on the type. Additionally, the logic for inferred key type should be consistent and accurate.

Here's the corrected version of the `_get_with` function:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not "
            "supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)
    
    # Handle different types of keys
    if isinstance(key, (list, np.ndarray, ExtensionArray, Series, Index)):
        key_type = lib.infer_dtype(key, skipna=False)
        
        if key_type == "integer":
            if not self.index._should_fallback_to_positional():
                return self.loc[key]
            else:
                return self.iloc[key]
        elif key_type == "boolean":
            # The key_type == "boolean" case should be caught by the com.is_bool_indexer check in __getitem__
            raise ValueError("Boolean indexing is not supported")
        else:
            return self.reindex(key)
    else:
        return self.loc[key]
```

This revised version addresses the inconsistencies in handling different key types, applies correct logic based on the type, and ensures the inferred key type is captured accurately. This approach should resolve the identified bug and align with the expected input/output values.