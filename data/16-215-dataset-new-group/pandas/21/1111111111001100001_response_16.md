The bug in the `_get_with` function seems to be related to the handling of the `key` parameter, which leads to an incorrect `key_type` being assigned in each case. The function incorrectly tries to identify the type of the key and choose the appropriate action based on that type. This results in the wrong type being assigned to `key_type` in each case, leading to incorrect behavior.

To fix this bug, we can modify the logic for identifying the type of `key` and choosing the appropriate action based on that type.

Here's the corrected version of the `_get_with` function:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not "
            "supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)
    
    # Check if key is a scalar or not
    if is_scalar(key):
        return self.loc[key]
    
    # Check if key is a list, ndarray, ExtensionArray, Series, or Index
    elif is_list_like(key):
        # Check if key is of type Index
        if isinstance(key, Index):
            key_type = key.inferred_type
        else:
            key_type = lib.infer_dtype(key, skipna=False)

        if key_type == "integer":
            if not self.index._should_fallback_to_positional():
                return self.loc[key]
            else:
                return self.iloc[key]
        else:
            return self.reindex(key)
```

This revised code checks the type of `key` using the `is_scalar` and `is_list_like` functions, and then correctly determines the appropriate action based on the type of `key`. This should ensure that the function works correctly for the failing test cases provided.