The bug in the `_get_with` function seems to be related to the type checking and handling of the index in the `key` parameter. When running the failing tests, the `KeyError` exception is not correctly raised, indicating that there might be a problem with the type checking and indexing related to the `key` parameter.

Given the context and input cases, the issue seems to be with the comparison of key types and their handling. It's possible that the function is not correctly identifying the type of the `key` parameter and therefore, not performing the indexing operations as expected.

To fix the bug, we can modify the type checking logic and improve the handling of different types of `key` parameters.

Here's the corrected version of the `_get_with` function:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)
    elif is_scalar(key):
        return self.loc[key]
    elif isinstance(key, (list, np.ndarray, ExtensionArray, Series, Index)):
        return self.loc[key]
    else:
        return self.reindex(key)
```

In the corrected version, we've added an additional check for scalar values using the `is_scalar` function. This should address the issue with handling scalar indices. We've also simplified the conditional statements to improve readability and maintain consistency in type handling.

This corrected version should address the issues with type checking and indexing, allowing the function to correctly handle different types of `key` parameters and raise the `KeyError` where appropriate.