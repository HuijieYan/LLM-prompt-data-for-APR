The bug in the `_get_with` function might be related to how different types of indexers are treated. The failing test indicates that there is inconsistency in how a list indexer is handled compared to other types of indexers. The error message also suggests that the problem may be related to how the key is being processed. The expected behavior is that the function should handle list indexers the same way it handles other types of indexers.

To fix this bug:
1. We need to standardize the handling of different types of indexers within the `_get_with` function.
2. Ensure that the key_type is properly determined and used to determine the indexing behavior.

Here's the corrected version of the `_get_with` function:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not "
            "supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)
    
    if is_list_like(key):
        key = list(key)
    
    if not isinstance(key, (list, np.ndarray, ExtensionArray, Series, Index)):
        key = list(key)

    key_type = lib.infer_dtype(key, skipna=False)
    
    if key_type == "integer":
        if not self.index._should_fallback_to_positional():
            return self.loc[key]
        else:
            return self.iloc[key]

    if isinstance(key, list):
        return self.loc[key]

    return self.reindex(key)
```

With these corrections, the `_get_with` function should handle different types of indexers consistently and pass the failing test cases. It should also satisfy the expected input/output variable values and resolve the issue posted in GitHub.