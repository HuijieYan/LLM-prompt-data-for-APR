There seems to be an issue in the `_get_with` function where the key_type variable is assigned a value of "string" regardless of the input type. This results in an incorrect branch being taken and the KeyError exception is not raised as expected.

To fix this issue, we need to properly infer the type of the key and handle the different input conditions accordingly.

Here's the corrected version of the `_get_with` function:

```python
def _get_with(self, key):
    # other: fancy integer or otherwise
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not "
            "supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)

    if is_scalar(key):
        return self.loc[key]

    if is_list_like(key):
        key = list(key)
    else:
        key = [key]

    key_type = lib.infer_dtype(key, skipna=False)

    if key_type == "integer":
        if not self.index._should_fallback_to_positional():
            return self.loc[key]
        else:
            return self.iloc[key]

    if isinstance(key, list):
        return self.loc[key]

    return self.reindex(key)
```

In this corrected version, we first handle the case where the key is a scalar using `is_scalar()`. Then, we check if the key is list-like and convert it to a list if necessary. Finally, we infer the type of the key and execute the appropriate logic based on the type.

This should fix the issue and ensure that the function behaves as expected in all test cases.