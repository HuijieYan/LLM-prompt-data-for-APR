There are a few issues with the `_get_with` function. The main issue appears to be when determining the `key_type`. It seems that the function incorrectly determines the `key_type` when dealing with the input `key`. It consistently identifies it as a string when it should have determined it correctly as an integer.

Additionally, the logic for handling different types of `key` (list-like, tuple, Index, etc.) could be simplified to avoid unnecessary branches.

To fix the bug, we should:
- Correctly determine the `key_type` based on the type and content of `key`.
- Simplify the logic for handling different types of `key` to make the function more readable.
- Ensure that the function handles the given cases correctly.

Here's a corrected version of the `_get_with` function:

```python
def _get_with(self, key):
    # Handling different types of key
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)

    if isinstance(key, (ABCDataFrame, tuple)):
        raise TypeError("Indexing a Series with DataFrame or tuple is not supported")

    # Convert key to list if it's not list-like
    if not is_list_like(key):
        key = [key]

    # Determine key_type based on the type and content of key
    if isinstance(key, Series):
        key_type = key.inferred_type
    elif isinstance(key, (list, np.ndarray)):
        key_type = lib.infer_dtype(key, skipna=False)
    else:
        key_type = 'integer' if all(isinstance(k, (int, np.integer)) for k in key) else 'string'

    # Handle key_type based on its value
    if key_type == "integer":
        return self.iloc[key]  # Use iloc for integer keys
    elif key_type == "string":
        return self.loc[key]   # Use loc for string keys
    else:
        return self.reindex(key)
```

This corrected version should handle different types of inputs correctly and pass the failing tests.