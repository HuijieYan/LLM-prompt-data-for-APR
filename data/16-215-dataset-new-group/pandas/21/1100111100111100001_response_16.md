The bug in the `_get_with` function seems to be related to the handling of the `key` parameter. When the `key` is a list or an ndarray, the code attempts to infer the type of the key, but it always defaults to `'string'`, which is likely incorrect and leads to the failing test cases.

To fix the bug, we need to adjust the logic for inferring the type of the key and the subsequent handling based on the type of the key.

Below is the corrected version of the `_get_with` function:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not "
            "supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)

    if is_scalar(key):
        return self.loc[key]

    if isinstance(key, (list, np.ndarray, ExtensionArray, Series, Index)):
        key = list(key)

    if isinstance(key, Index):
        key_type = key.inferred_type
    else:
        key_type = lib.infer_dtype(key, skipna=False)

    if key_type == "integer":
        if not self.index._should_fallback_to_positional():
            return self.loc[key]
        else:
            return self.iloc[key]

    # handle the dup indexing case GH#4246
    if isinstance(key, list):
        return self.loc[key]

    return self.reindex(key)
```

This version addresses the infer_dtype method used to determine the type of the `key` parameter and adds an additional check for scalar types, which are handled separately from iterable types. Additionally, the code checks if the `key` is a list before reindexing it.

By modifying the logic for inferring the type of the key and handling different key input types, the corrected version of the function should now pass the failing test cases.