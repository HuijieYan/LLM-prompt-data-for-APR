The bug in the `_get_with` function is that it is not handling list indexers correctly, leading to inconsistencies in behavior when indexing a Series with different types of indexers.

The issue seems to stem from the `key_type` variable, which is incorrectly inferred as `'string'` in all cases. This may be causing the function to behave incorrectly when handling list-like indexers.

To fix the bug, we need to make sure that the `key_type` is correctly inferred and that the function handles list-like indexers consistently with other types of indexers.

Here's a corrected version of the `_get_with` function:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        # _convert_slice_indexer to determine if this slice is positional or label based,
        # and if the latter, convert to positional
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)

    if not is_list_like(key):
        return self.loc[key]

    if isinstance(key, Index):
        key_type = key.inferred_type
    else:
        key_type = lib.infer_dtype(key, skipna=False)

    if key_type == "integer":
        # We need to decide whether to treat this as a positional indexer
        # (i.e. self.iloc) or label-based (i.e. self.loc)
        if not self.index._should_fallback_to_positional():
            return self.loc[key]
        else:
            return self.iloc[key]

    return self.reindex(key)
```

In this corrected version, we ensure that the `key_type` variable is correctly inferred based on the type of the indexer, and then handle the indexing accordingly.

This fix should address the inconsistencies in behavior when using different types of indexers and should resolve the issue reported on GitHub.