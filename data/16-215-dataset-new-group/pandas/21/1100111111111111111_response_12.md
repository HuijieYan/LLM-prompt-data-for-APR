The bug in the _get_with function is causing inconsistent behavior when using different types of indexers. The bug causes the function to raise a KeyError when using a list indexer, while other indexers behave differently.

The cause of the bug is related to the handling of the key_type variable, which is expected to determine the type of the key being indexed. It seems that the key_type variable is incorrectly identified as 'string' in all cases, leading to incorrect processing of the indexer type.

To fix the bug, we need to modify the key_type detection logic and ensure that it correctly identifies the type of the key being used for indexing. Then, based on the type of the key, we need to apply the appropriate indexing method to retrieve the values from the Series.

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not "
            "supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)

    key = ensure_index(key)

    if is_list_like(key) and not isinstance(key, (ABCDataFrame, Series)):
        key_type = lib.infer_dtype(key, skipna=False)
    else:
        key_type = key.inferred_type

    if key_type == "integer":
        # We need to decide whether to treat this as a positional indexer
        #  (i.e. self.iloc) or label-based (i.e. self.loc)
        if not self.index._should_fallback_to_positional():
            return self.loc[key]
        else:
            return self.iloc[key]

    return self.reindex(key)
```

By making these changes, the function now correctly identifies the type of the key being used for indexing and applies the appropriate indexing method, resolving the inconsistent behavior and passing the failing test cases.