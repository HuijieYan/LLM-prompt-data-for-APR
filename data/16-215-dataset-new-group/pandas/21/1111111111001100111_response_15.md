The bug in the `_get_with` function seems to be caused by the inconsistent treatment of list indexers compared to array-like indexers. The failing test cases show that when using a list indexer, the function raises a `KeyError`, while it returns `NaN` for other types of indexers.

To fix the bug, the function should treat all types of indexers consistently and not raise a `KeyError` for list indexers. Instead, it should handle list indexers in the same way as other types of indexers.

Here's the corrected version of the `_get_with` function:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not "
            "supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)

    if not is_list_like(key):
        return self.loc[key]

    if isinstance(key, Index):
        key_type = key.inferred_type
    else:
        key_type = lib.infer_dtype(key, skipna=False)

    if key_type == "integer":
        if not self.index._should_fallback_to_positional():
            return self.loc[key]
        else:
            return self.iloc[key]

    # handle the dup indexing case GH#4246
    return self.loc[key]
```

In the corrected version, the function checks if the `key` is list-like, and if it is, it directly uses `self.loc[key]` to handle list indexers in the same way as other types of indexers. This change ensures consistent behavior for all types of indexers.

This fix should address the GitHub issue and make the `_get_with` function behave consistently for different types of indexers, resolving the bug.