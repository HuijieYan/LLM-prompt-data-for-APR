To fix the bug in the `_get_with` function, we need to adjust the logic to handle different types of indexers consistently. Based on the failing tests and the expected behavior, it seems that the issue lies in how different types of indexers are handled and how the error is raised for list indexers specifically.

Here's the corrected version of the `_get_with` function:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not "
            "supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)
  
    # Handle list indexers consistently with other types
    if isinstance(key, list):
        key = np.asarray(key)

    if is_list_like(key):
        if not len(key):
            raise KeyError(f"None of {key} are in the index")
    else:
        key = [key]

    if isinstance(key, Index):
        key_type = key.inferred_type
    else:
        key_type = lib.infer_dtype(key, skipna=False)

    if key_type == "integer":
        if not self.index._should_fallback_to_positional():
            return self.loc[key]
        else:
            return self.iloc[key]

    return self.reindex(key)
```

In the corrected version, we first handle the case of list indexers by converting them into numpy arrays to ensure consistency. Then we check the type of the key and handle it accordingly, ensuring that an appropriate error is raised if the indexer does not match any values in the index.

This version should pass the failing tests and satisfy the expected input/output values. It also addresses the inconsistency mentioned in the GitHub issue.