The bug in the `_get_with` function seems to be related to the different treatment of indexers depending on their type. The issue description on GitHub also highlights this inconsistency.

The cause of the bug seems to be in the handling of different types of indexers (list, array-like, Index) and the inconsistent behavior when trying to access non-existent items. The key_type is being inferred incorrectly as 'string' in all cases, leading to the incorrect behavior when trying to access non-existent items.

To fix the bug, we should update the `_get_with` function to ensure that different types of indexers are handled consistently, and the key_type is inferred correctly to determine the type of validation required for accessing items. Additionally, handling the case of non-existent items should be consistent across different indexer types.

Here's the corrected version of the `_get_with` function:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not "
            "supported, use the appropriate DataFrame column"
        )
    
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)

    # Checking if the key is not list-like and is not a DataFrame
    elif not is_list_like(key):
        return self.loc[key]

    # Handling the case of non-existent items consistently for all indexer types
    try:
        return self.loc[key]
    except KeyError:
        return self.reindex(key)
```

In this corrected version, we have added a try-except block to handle the KeyError when trying to access non-existent items. This ensures consistent behavior for all types of indexers.

This should address the bug and make the `_get_with` function behave consistently for different types of indexers, satisfying the expected input/output values and resolving the issue posted in GitHub.