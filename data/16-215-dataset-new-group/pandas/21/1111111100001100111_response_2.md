The bug in the `_get_with` function is causing inconsistent behavior when using different types of indexers. The issue on GitHub highlights the inconsistency in the behavior of the function when using list indexers compared to array-like indexers.

The problem arises from the inconsistency in how the function handles different types of indexers, leading to unexpected KeyErrors and inconsistent behavior between list indexers and other types of indexers.

To fix the bug, the `_get_with` function should be updated to handle indexers consistently, treating list indexers in the same way as array-like indexers. Additionally, the bug causing the unexpected KeyErrors needs to be addressed.

Here's the corrected version of the `_get_with` function:

```python
def _get_with(self, key):
    # other: fancy integer or otherwise
    if isinstance(key, slice):
        # _convert_slice_indexer to determine if this slice is positional
        #  or label-based, and if the latter, convert to positional
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, (ABCDataFrame, Index)):
        return self.reindex(key)
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)
    elif not is_list_like(key):
        return self.loc[key]

    key = list(key)
    if not isinstance(key, (list, np.ndarray, ExtensionArray, Series)):
        key = list(key)

    if isinstance(key, Index):
        key_type = key.inferred_type
    else:
        key_type = lib.infer_dtype(key, skipna=False)

    if key_type in ["integer", "boolean"]:
        return self.iloc[key]
    elif key_type in ["string", "mixed-integer"]:
        return self.loc[key]
    else:
        return self.reindex(key)
```

This updated version handles different types of indexers consistently, ensuring that list indexers are treated in the same way as array-like indexers and fixing the unexpected KeyErrors.

With this corrected version, the function should no longer exhibit inconsistent behavior and should resolve the issue reported on GitHub.