To fix the bug in the `_get_with` function, we can modify the logic to handle the case when the key is a list-like object and ensure it behaves consistently with other array-like indexers. We will also address the inconsistency with the `ser.loc[key]` behavior.

Here's the corrected version of the `_get_with` function:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not "
            "supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)
    
    if not is_list_like(key):
        return self.loc[key]

    key_array = np.asarray(key)
    
    key_type = lib.infer_dtype(key_array, skipna=False)
    
    if key_type == "integer":
        if not self.index._should_fallback_to_positional():
            return self.loc[key]
        else:
            return self.iloc[key]
    
    return self.loc[key]
```

In this corrected version, we handle the list-like key by converting it to a numpy array using `np.asarray(key)`. We then infer the key type using `lib.infer_dtype` to determine if it's an integer key. Finally, we return the result based on the inferred key type and whether it should fallback to positional indexing.

This corrected function should now handle the list-like key consistently with other array-like indexers and resolve the issue reported in the GitHub discussion.

The corrected function should then pass the failing test case provided.