The issue with the `_get_with` function is that it is treating list indexers differently from array-like indexers, leading to inconsistent behavior and different error messages when accessing a non-existent index.

To fix this bug, we need to ensure consistent behavior for all types of indexers and handle the case when the index does not exist. We can modify the `_get_with` function to achieve this.

Here's the corrected version of the `_get_with` function:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)

    if not isinstance(key, (np.ndarray, ExtensionArray, Series, Index)):
        key = np.asarray(key)

    if isinstance(key, Index):
        key_type = key.inferred_type
    else:
        key_type = lib.infer_dtype(key, skipna=False)

    if key_type == "integer":
        if not self.index._should_fallback_to_positional():
            return self.loc[key]
        else:
            return self.iloc[key]

    return self.reindex(key)
```

This corrected version of the function ensures consistent handling of different types of indexers and addresses the issue reported on GitHub.

By making these changes, the `_get_with` function should behave consistently for all types of indexers and address the reported issue.

Let me know if there is anything else that I can help you with!