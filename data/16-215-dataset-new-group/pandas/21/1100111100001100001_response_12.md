The bug in the function `_get_with` seems to be related to the identification of the type of the `key`. The function incorrectly identifies the type, which leads to the incorrect return values.

The key types in all the test cases are identified as 'string', regardless of the actual type of the key.

To fix this bug, we should revise the type identification process for the `key`, ensuring that it correctly identifies the type of the key. We should also handle the different types of keys appropriately to return the desired output.

Here's a corrected version of the `_get_with` function that addresses the bug:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not "
            "supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)
    
    # Handle scalars
    if is_scalar(key):
        return self.loc[key]
    
    # Handle list-like keys
    if is_list_like(key):
        key_type = lib.infer_dtype(key, skipna=False)
        if key_type == "integer":
            if not self.index._should_fallback_to_positional():
                return self.loc[key]
            else:
                return self.iloc[key]
        elif key_type == "boolean":
            return self.loc[key]
        else:
            return self.reindex(key)
    
    if isinstance(key, Index):
        key_type = key.inferred_type
    else:
        key_type = lib.infer_dtype(key, skipna=False)
        if key_type == "integer":
            if not self.index._should_fallback_to_positional():
                return self.loc[key]
            else:
                return self.iloc[key]
        else:
            return self.reindex(key)
```

This corrected version identifies the key type correctly using `is_scalar` and `is_list_like` functions and returns the appropriate values for each type of key. This should fix the bug and ensure that the function returns the expected values for different types of keys.