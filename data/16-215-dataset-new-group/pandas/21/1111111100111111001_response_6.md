The bug in the function `_get_with` appears to stem from the incorrect handling of the `key` variable. The function should return the correct values for the different types of keys supplied. It seems that the issue arises due to the misclassification of the key type as a string, while it needs to be handled as a list or ndarray.

To fix this bug, the function needs to correctly identify and handle the different types of keys provided. It should properly evaluate the type of the key and handle it accordingly.

Here's a corrected version of the `_get_with` function:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)

    # Correctly handle different types of keys
    if isinstance(key, (np.ndarray, list, Series, Index)):
        key_type = "list-like"
    elif not is_list_like(key):
        return self.loc[key]
    elif not is_scalar(key):
        key = list(key)

    if isinstance(key, Index):
        key_type = key.inferred_type
    else:
        key_type = lib.infer_dtype(key, skipna=False)

    if key_type == "integer":
        if not self.index._should_fallback_to_positional():
            return self.loc[key]
        else:
            return self.iloc[key]
    elif key_type == "string":
        return self.loc[key]

    return self.reindex(key)
```

This corrected version should properly handle the different types of keys and ensure that the function returns the expected values for the failing tests.