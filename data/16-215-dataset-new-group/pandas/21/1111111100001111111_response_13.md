The bug in the `_get_with` function seems to be related to how list indexers are being treated differently from array-like indexers. The function checks the type of the `key` parameter and performs different operations based on its type. There are inconsistencies in how the function handles list indexers, which is causing the tests to fail.

It appears that the function is not handling list indexers properly and is raising an error when using `ser[list(key)]`. This behavior is inconsistent with how the function handles other types of indexers, such as array-like indexers.

To fix the bug, the function needs to handle list indexers in a consistent manner with other types of indexers. This may require modifying the conditional statements and the logic for handling different types of indexers.

Here is the corrected version of the `_get_with` function:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not "
            "supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)

    # Handle list-like indexers in a consistent manner
    if is_list_like(key):
        key = list(key)

    if isinstance(key, Index):
        key_type = key.inferred_type
    else:
        key_type = lib.infer_dtype(key, skipna=False)

    if key_type == "integer":
        if not self.index._should_fallback_to_positional():
            return self.loc[key]
        else:
            return self.iloc[key]

    if isinstance(key, list):
        return self.loc[key]

    return self.reindex(key)
```

This corrected version handles list indexers consistently with other types of indexers and should resolve the issue reported on GitHub.