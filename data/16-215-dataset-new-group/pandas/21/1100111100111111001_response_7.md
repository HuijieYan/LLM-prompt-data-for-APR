The bug in the `_get_with` function is caused by incorrect type checking and handling of the `key` variable. The function incorrectly checks for the type of `key` and processes it based on the conditional blocks, leading to incorrect behavior in some cases.

We can fix this bug by updating the type checking logic to correctly identify the type of `key` and process it accordingly.

Here's the corrected version of the `_get_with` function:

```python
def _get_with(self, key):
    # other: fancy integer or otherwise
    if isinstance(key, slice):
        # _convert_slice_indexer to determine if this slice is positional
        # or label based, and if the latter, convert to positional
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not "
            "supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)
    elif is_scalar(key) and not isinstance(key, (bool, float)):
        return self.loc[key]
    else:
        return self.reindex(key)
```

In the corrected version:
1. I replaced the `not is_list_like(key)` condition with `is_scalar(key) and not isinstance(key, (bool, float))`. This change ensures that scalar values like strings are correctly handled.
2. Removed the unnecessary type checks for list, ndarray, ExtensionArray, Series, and Index types, as they are not relevant for the logic of this function. Instead, the function uses the `is_scalar` function to check for scalar values and processes them appropriately.
3. Updated the last conditional block to directly return `self.reindex(key)`, as this can handle all other cases including list-like objects.

By making these changes, the function will now correctly handle various types of `key` inputs and should pass the failing tests.