The issue seems to be related to the inconsistency in how different types of indexers are handled in the `ser[key]` operation. The specific problem is related to the list indexer (`ser[list(key)]`) not behaving the same way as the other indexers.

Based on the failing test cases and the provided information, it seems that the bug is related to the detection and handling of the indexer type and the subsequent reindexing operation.

To fix the bug, it is necessary to ensure that the list indexer behaves the same way as the other indexers, such as array-like and index-like. Additionally, it may be necessary to revisit the handling of different indexer types to ensure consistency across the board.

Here's the corrected version of the function:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not "
            "supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)

    if isinstance(key, (Index, list, np.ndarray, ExtensionArray, Series)):
        return self.reindex(key)

    if is_scalar(key):
        return self.loc[key]

    msg = f"Unsupported indexer type: {type(key)}"
    raise TypeError(msg)
```

In the corrected version, we handle all index-like and array-like indexers with a call to `reindex(key)`. Additionally, we handle scalar indexers with `loc[key]`. For any unsupported indexer type, we raise a `TypeError` with a descriptive message.

With this correction, the function should behave consistently for all types of indexers, resolving the inconsistency and passing the failing test cases.