The bug in the `apply` function is causing `pd.date_range` to produce more periods than expected when adding holidays. This is due to the incorrect adjustments made in the `apply` function, resulting in incorrect business hours calculation and adjustments.

The bug is caused by the incorrect calculation of business days and remaining business hours. The adjustment logic in the `apply` function does not handle holidays and non-business hours correctly, leading to unexpected results in the `pd.date_range` output.

To fix the bug, the logic for adjusting business days and hours needs to be modified and enhanced to properly handle holidays and non-business hours.

Here's the corrected version of the `apply` function:

```python
@apply_wraps
def apply(self, other):
    if isinstance(other, datetime):
        # reset timezone and nanosecond
        other = datetime(
            other.year,
            other.month,
            other.day,
            other.hour,
            other.minute,
            other.second,
            other.microsecond,
        )
        n = self.n

        business_hours = list(zip(self.start, self.end))

        curr_date = other.date()
        total_business_hours = 0

        for start_hr, end_hr in business_hours:
            start_datetime = datetime.combine(curr_date, start_hr)
            end_datetime = datetime.combine(curr_date, end_hr)
            total_business_hours += (end_datetime - start_datetime).total_seconds() / 60  # in minutes

        # adjust for holidays
        holidays = [holiday.date() for holiday in self.holidays]
        if other.date() in holidays or not self._is_on_offset(other):
            other = self._next_opening_time(other)

        # adjust for business days and remaining business hours
        if n >= 0:
            business_days_needed, remaining_hours = divmod(n * 60, total_business_hours)
        else:
            business_days_needed, remaining_hours = divmod((-n) * 60, total_business_hours)
            business_days_needed *= -1
            remaining_hours *= -1

        while business_days_needed != 0:
            if n >= 0:
                other += timedelta(days=1)
            else:
                other -= timedelta(days=1)
            if self._is_on_offset(other) and other.date() not in holidays:
                business_days_needed -= 1

        # adjust for remaining business hours within the same day
        business_hour_index = 0
        start_time, end_time = business_hours[business_hour_index]
        while remaining_hours > 0:
            start_datetime = datetime.combine(other.date(), start_time)
            end_datetime = datetime.combine(other.date(), end_time)
            business_duration = (end_datetime - other).total_seconds() / 60  # in minutes
            if remaining_hours < business_duration:
                other += timedelta(minutes=remaining_hours)
                remaining_hours = 0
            else:
                remaining_hours -= business_duration
                business_hour_index += 1
                if business_hour_index < len(business_hours):
                    start_time, end_time = business_hours[business_hour_index]
                    other = datetime.combine(other.date(), start_time)
                    if remaining_hours > 0:
                        other += timedelta(days=1)  # move to the next business day

        return other
    else:
        raise ApplyTypeError("Only know how to combine business hour with datetime")
```

With this corrected version, the adjustments for holidays, business days, and remaining business hours have been improved to produce the expected results in the `pd.date_range` function and resolve the issue reported in the GitHub thread.