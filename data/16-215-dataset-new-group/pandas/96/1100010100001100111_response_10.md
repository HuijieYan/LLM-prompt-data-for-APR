The bug in the `apply` function is causing the unexpected behavior in the `date_range` function when using periods and adding holidays. The cause of the bug is related to the calculation of business hours and the adjustment of the datetime value based on the business hours. The incorrect adjustment results in the unexpected output in the `date_range`.

To fix the bug, the adjustment logic within the `apply` function needs to be revised to correctly handle the addition of holidays and the calculation of business hours.

One approach to fixing the bug is to adjust the logic for handling holidays and the calculation of business hours within the `apply` function. This may involve updating the conditional statements and the calculation of the adjusted datetime value.

Here is the corrected version of the `apply` function:

```python
@apply_wraps
def apply(self, other):
    if isinstance(other, datetime):
        n = self.n

        # adjust other to reduce number of cases to handle
        if n >= 0:
            if other.time() in self.end or not self._is_on_offset(other):
                other = self._next_opening_time(other)
        else:
            if other.time() in self.start:
                # adjustment to move to previous business day
                other = other - timedelta(seconds=1)
            if not self._is_on_offset(other):
                other = self._next_opening_time(other)
                other = self._get_closing_time(other)

        # get total business hours by sec in one business day
        businesshours = sum(
            self._get_business_hours_by_sec(st, en)
            for st, en in zip(self.start, self.end)
        )

        if self.holidays:
            for holiday in self.holidays:
                holiday = as_datetime(holiday)
                if holiday == other.date():
                    other = self._next_opening_time(other)

        bd, r = divmod(abs(n * 60), businesshours // 60)
        if n < 0:
            bd, r = -bd, -r

        # adjust by business days first
        if bd != 0:
            skip_bd = BusinessDay(n=bd)
            other = other + skip_bd

        # remaining business hours to adjust
        bhour_remain = timedelta(minutes=r)

        if n >= 0:
            while bhour_remain != timedelta(0):
                # business hour left in this business time interval
                bhour = (
                    self._get_closing_time(self._prev_opening_time(other)) - other
                )
                if bhour_remain < bhour:
                    # finish adjusting if possible
                    other += bhour_remain
                    bhour_remain = timedelta(0)
                else:
                    # go to next business time interval
                    bhour_remain -= bhour
                    other = self._next_opening_time(other + bhour)
        else:
            while bhour_remain != timedelta(0):
                # business hour left in this business time interval
                bhour = self._next_opening_time(other) - other
                if bhour_remain > bhour:
                    # finish adjusting if possible
                    other += bhour_remain
                    bhour_remain = timedelta(0)
                else:
                    # go to next business time interval
                    bhour_remain -= bhour
                    other = self._get_closing_time(
                        self._next_opening_time(
                            other + bhour - timedelta(seconds=1)
                        )
                    )

        return other
    else:
        raise ApplyTypeError("Only know how to combine business hour with datetime")
```

In the corrected version, the logic for adjusting the datetime value based on holidays and business hours has been revised to handle the scenarios where holidays are present. This fix should address the issue reported on GitHub and resolve the unexpected behavior in the `date_range` function when using periods and adding holidays.