The issue in the buggy function seems to be related to the incorrect calculation of business days and hours, leading to unexpected behavior when adding holidays with periods. To fix the bug and address the issue reported in GitHub, we need to review the logic that accounts for holidays and periods in the `apply` function. It's likely that adjustments in the holiday handling logic and period calculations are needed.

Here's the fixed version of the `apply` function:

```python
def apply(self, other):
    if isinstance(other, datetime):
        n = self.n
        holidays = self.holidays
        business_hours = sum(
            self._get_business_hours_by_sec(start, end)
            for start, end in zip(self.start, self.end)
        )

        if n >= 0:
            if not self._is_on_offset(other) or other in holidays:
                other = self._next_opening_time(other)
        else:
            if other.time() in self.start and other not in holidays:
                other -= timedelta(seconds=1)
            if self._is_on_offset(other) and other not in holidays:
                other = self._prev_opening_time(other)
            else:
                other = self._next_opening_time(other)

        delta_minutes = n * 60
        if n < 0:
            delta_minutes = -delta_minutes

        # Adjust by business days first
        if abs(delta_minutes) >= business_hours:
            bd = delta_minutes // business_hours  # Number of business days
            delta_minutes %= business_hours  # Remaining minutes after adjusting business days
            if delta_minutes < 0:
                bd -= 1

            skip_bd = pd.offsets.CustomBusinessDay(n=bd, holidays=holidays)
            if not self._is_on_offset(other):
                prev_open = self._prev_opening_time(other)
                remain = other - prev_open
                other = prev_open + skip_bd + remain
            else:
                other += skip_bd

        # Adjusting remaining business hours
        bhour_remain = timedelta(minutes=delta_minutes)
        while bhour_remain:
            next_opening_time = self._next_opening_time(other)
            if n >= 0:
                bhour = next_opening_time - other
            else:
                bhour = self._get_closing_time(other) - other
            if n < 0 and bhour > bhour_remain:
                bhour = bhour_remain
            other += bhour
            bhour_remain -= bhour

        return other
    else:
        raise ApplyTypeError("Only know how to combine business hour with datetime")
```

In the fixed function, the logic for adjusting business days and remaining business hours has been updated. Additionally, the holiday handling logic has been improved to correctly account for holidays and their impact on the period calculation.

This updated function should resolve the issue reported in the GitHub post and pass the failing tests.