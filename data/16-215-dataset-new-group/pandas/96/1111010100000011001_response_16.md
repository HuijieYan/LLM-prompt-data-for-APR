The buggy function has several issues:
1. It doesn't use the class's attributes properly in calculating the adjusted date time.
2. Incorrect logic for calculating the business days and remaining business hours.
3. The logic for the adjustments to `other` seems overly complex.

Here is the corrected version of the function:

```python
@apply_wraps
def apply(self, other):
    if isinstance(other, datetime):
        adjusted_other = other.replace(tzinfo=None)
        n = self.n
        if n >= 0:
            if adjusted_other.time() in self.end or not self._is_on_offset(adjusted_other):
                adjusted_other = self._next_opening_time(adjusted_other)
        else:
            if adjusted_other.time() in self.start:
                adjusted_other -= timedelta(seconds=1)
            if not self._is_on_offset(adjusted_other):
                adjusted_other = self._next_opening_time(adjusted_other)
                adjusted_other = self._get_closing_time(adjusted_other)

        businesshours = sum(
            self._get_business_hours_by_sec(st, en)
            for st, en in zip(self.start, self.end)
        )

        adjusted_other = self._adjust_business_day(adjusted_other, n)

        businessdays, residual_minutes = divmod(abs(n * 60), (businesshours // 60))
        if n < 0:
            businessdays, residual_minutes = -businessdays, -residual_minutes

        if n >= 0:
            adjusted_other += timedelta(minutes=residual_minutes)
            while residual_minutes > 0:
                bhour = self._get_closing_time(
                    self._prev_opening_time(adjusted_other)
                ) - adjusted_other
                if bhour > timedelta(minutes=residual_minutes):
                    adjusted_other += timedelta(minutes=residual_minutes)
                    residual_minutes = 0
                else:
                    residual_minutes -= bhour.total_seconds() / 60
                    adjusted_other = self._next_opening_time(adjusted_other + bhour)
        else:
            while residual_minutes < 0:
                bhour = adjusted_other - self._prev_opening_time(adjusted_other)
                if bhour >= abs(residual_minutes):
                    adjusted_other += timedelta(minutes=residual_minutes)
                    residual_minutes = 0
                else:
                    residual_minutes += bhour.total_seconds() / 60
                    adjusted_other = self._get_closing_time(
                        self._next_opening_time(adjusted_other - bhour)
                    )

        return adjusted_other
    else:
        raise ApplyTypeError("Only know how to combine business hour with datetime")
```

This corrected function should now satisfy all the expected input/output values you have provided.