Based on the failing test and the described issue, the bug seems to be related to adding holidays in the frequency object when using the `pd.date_range()` function. The error seems to be caused by an incorrect calculation of business hours when holidays are involved.

To fix the bug, we should ensure that the correct business day calculation is applied when adding holidays, and the total number of business hours is calculated accurately considering the holidays.

Here's the corrected version of the buggy function:

```python
class BusinessHourMixin(BusinessMixin):

    # Previous code remains unchanged

    @apply_wraps
    def apply(self, other):
        if isinstance(other, datetime):
            # Used for detecting edge condition
            nanosecond = getattr(other, "nanosecond", 0)
            # Reset timezone and nanosecond
            # Other may be a Timestamp, thus not use replace
            other = datetime(
                other.year,
                other.month,
                other.day,
                other.hour,
                other.minute,
                other.second,
                other.microsecond,
            )
            n = self.n

            # Existing adjustment code remains unchanged

            # Get total business hours by sec in one business day taking into account the holidays
            business_hours = sum(
                self._get_business_hours_by_sec(st, en)
                for st, en in zip(self.start, self.end)
            )

            # Additional code for handling holidays and business days
            holidays = getattr(self, 'holidays', [])
            if holidays:
                for holiday in holidays:
                    holiday_datetime = datetime.strptime(holiday, "%Y-%m-%d")
                    if holiday_datetime.date() == other.date():
                        other = self._next_opening_time(other)

            # Rest of the code remains unchanged

            return other
        else:
            raise ApplyTypeError("Only know how to combine business hour with datetime")
```

In the corrected code, we added a block for handling holidays. We fetch the holidays attribute from the object and check whether the date of the datetime object matches any of the holidays. If it does, we adjust the time accordingly using `_next_opening_time()` method. This should prevent the issue with incorrect calculation of business hours when holidays are added and resolve the problem described in the GitHub issue.

The corrected function should now pass the failing test and resolve the reported issue.