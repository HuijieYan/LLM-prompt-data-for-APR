The bug in the `apply` function is causing the dates generated by the `pd.date_range` function to overshoot the expected number of periods when using custom business hours and holidays. The buggy function fails to handle the adjustment of business days and remaining business hours correctly, resulting in an incorrect output.

The cause of the bug is that the `apply` function does not properly adjust the business days and remaining business hours, leading to an incorrect datetime return. This is evident in the failing test where the generated dates exceed the expected number of periods, as reported in the GitHub issue.

To fix the bug, the adjustment logic in the `apply` function needs to be modified to correctly handle business days and remaining business hours while respecting the holidays.

Here's the corrected `apply` function:

```python
# Corrected version of the apply function
@apply_wraps
def apply(self, other):
    if isinstance(other, datetime):
        # adjust the start and end times
        start_time = datetime(other.year, other.month, other.day, *self.start[0].utctimetuple()[3:6])
        end_time = datetime(other.year, other.month, other.day, *self.end[0].utctimetuple()[3:6])

        # get the total business hours within a single day
        businesshours = sum((e.hour - s.hour) * 60 + (e.minute - s.minute) for s, e in zip(self.start, self.end))

        # adjust the other time to the next open time if applicable
        if other.time() < start_time.time():
            other = start_time
        elif other.time() > end_time.time() or not self._is_on_offset(other):
            other = self._next_opening_time(other)

        # calculate the number of business days and remaining business hours
        period = (other - start_time).seconds / 60
        businessdays, remaining_hours = divmod(period, businesshours)

        # check for holidays within the range
        for _ in range(int(businessdays)):
            if not self.next_bday.is_on_offset(other):
                other = self._next_opening_time(other)
            else:
                other += BusinessDay(n=1)

        # adjust the remaining business hours to the next open time
        while remaining_hours > 0:
            if other.time() < end_time.time():
                hours_needed = (other - start_time).seconds / 60 - sum(bd * businesshours for bd in range(int(businessdays)))
                if hours_needed > remaining_hours:
                    break
                else:
                    other = self._next_opening_time(other) + timedelta(minutes=remaining_hours)
                    break
            else:
                break

        return other
    else:
        raise ApplyTypeError("Only know how to combine business hour with datetime")
```

By updating the `apply` function with the revised logic as shown above, the issue with the overshooting of dates when using custom business hours and holidays can be resolved.