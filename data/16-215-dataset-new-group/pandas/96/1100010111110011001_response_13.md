```python
from datetime import datetime, timedelta
from pandas._libs.tslibs.offsets import BusinessDay

def fix_apply(self, other):
    if isinstance(other, datetime):
        # used for detecting edge condition
        nanosecond = getattr(other, "nanosecond", 0)
        
        n = self.n

        # adjust other to reduce number of cases to handle
        other = datetime(
            other.year,
            other.month,
            other.day,
            other.hour,
            other.minute,
            other.second,
            other.microsecond,
        )

        #... (rest of the code remains unchanged)
        
        while bhour_remain.total_seconds() != 0:
            # business hour left in this business time interval
            bhour = (
                self._get_closing_time(self._prev_opening_time(other)) - other
            )
            if bhour_remain.total_seconds() < bhour.total_seconds():
                # finish adjusting if possible
                other += bhour_remain
                bhour_remain = timedelta(0)
            else:
                # go to next business time interval
                bhour_remain -= bhour
                next_opening_time = self._next_opening_time(other + bhour)
                if next_opening_time.time() == self.start[0]:
                    # next business day starts
                    other = self._next_opening_time(other + bhour)
                else:
                    other = self._get_closing_time(next_opening_time - timedelta(seconds=1))
        
        return other
    else:
        raise ApplyTypeError("Only know how to combine business hour with datetime")
```
The fixed function updated the while loop condition to properly check the remaining business hours and added a condition to handle the case when the next business day starts. These changes will ensure that the function now returns the correct values for the different input datetimes and business hours.