The bug in the `apply` function seems to be related to adjusting the datetime according to business hours and holidays. The failing test `test_date_range_with_custom_holidays` and the cases have the same pattern of producing incorrect results when the holidays are involved.

The issue seems to stem from incorrect adjustments to the `other` parameter when calculating business days and remaining business hours. The adjustment based on the number of business days and the remaining business hours may result in inaccurate datetime values.

To fix this bug:
1. Ensure that the adjustment of the `other` parameter based on business days and remaining business hours is accurate and correctly reflects the business hours and holidays.
2. Verify that the conditions for checking holidays and business hours are accurately implemented.

Here's a corrected version of the `apply` function:

```python
@apply_wraps
def apply(self, other):
    if isinstance(other, datetime):
        n = self.n
        start = self.start[0]
        end = self.end[0]
        
        if n < 0:
            start, end = end, start
        
        current_hour = datetime.combine(other.date(), datetime.min.time())
        
        business_days = 0
        remaining_hours = n * 60
        
        while business_days != abs(n) or remaining_hours > 0:
            # Consider the holiday and increment the current time if the day is a holiday
            while current_hour.date() in self.holidays:
                if n >= 0:
                    current_hour = self._next_opening_time(current_hour)
                else:
                    current_hour = self._get_closing_time(self._prev_opening_time(current_hour - timedelta(seconds=1)))
            
            if (current_hour.time() < start or current_hour.time() >= end) or current_hour.date() in self.holidays:
                if n >= 0:
                    current_hour = self._next_opening_time(current_hour)
                    business_days += 1
                else:
                    current_hour = self._next_opening_time(current_hour)
                    business_days += 1
                    current_hour = self._get_closing_time(current_hour)
            else:
                minutes_until_closing = (end.hour - current_hour.hour) * 60 - current_hour.minute
                if minutes_until_closing <= remaining_hours:
                    current_hour += timedelta(minutes=minutes_until_closing)
                    remaining_hours -= minutes_until_closing
                else:
                    current_hour += timedelta(minutes=remaining_hours)
                    remaining_hours = 0
        
        return current_hour
    else:
        raise ApplyTypeError("Only know how to combine business hour with datetime")
```

This corrected version performs accurate adjustments based on business days, remaining business hours, and holidays to ensure the datetime values are calculated correctly. This should resolve the issue reported on GitHub and ensure that the tests pass accordingly.