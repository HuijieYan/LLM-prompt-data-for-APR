{
    "pandas": [
        {
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 0,
                "1.3.3": 1,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "2.1.3": 1,
                "2.1.4": 1,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 1
            },
            "strata": {
                "1": 1,
                "2": 1,
                "3": 0,
                "4": 1,
                "5": 0,
                "6": 0,
                "7": 1,
                "8": 0,
                "9": 1
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 0,
                "1.2.1": 1,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 0,
                "1.3.3": 1,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "2.1.3": 1,
                "2.1.4": 1,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 1
            },
            "available_strata": {
                "1": 1,
                "2": 1,
                "3": 0,
                "4": 1,
                "5": 0,
                "6": 0,
                "7": 1,
                "8": 0,
                "9": 1
            },
            "bugID": 96,
            "start_line": 857,
            "file_name": "pandas/tseries/offsets.py",
            "replace_code": "def apply(self, other):\n    if isinstance(other, datetime):\n        # Ensure that the timezone and nanosecond are reset\n        other = other.replace(tzinfo=None, microsecond=0)\n\n        # Business days adjustment\n        if self.n > 0:\n            other = self._next_opening_time(self._get_closing_time(other))\n        elif self.n < 0:\n            other = self._get_closing_time(self._prev_opening_time(other))\n\n        # Business hours adjustment\n        businesshours = sum(\n            self._get_business_hours_by_sec(st, en)\n            for st, en in zip(self.start, self.end)\n        )\n        total_seconds = abs(self.n) * 60 * businesshours\n\n        if self.n < 0:\n            total_seconds = -total_seconds\n\n        days, seconds = divmod(abs(total_seconds), 86400)\n        if days:\n            other += timedelta(days=days)\n\n        remaining_seconds = timedelta(seconds=seconds)\n        curr_time = other.time()\n\n        while remaining_seconds.total_seconds() > 0:\n            if self.n > 0:\n                next_day_opening = self._next_opening_time(other)\n                next_day_closing = self._get_closing_time(next_day_opening)\n\n                if curr_time < self.start[0]:\n                    diff_to_start = datetime.combine(other.date(), self.start[0]) - other\n                    if diff_to_start.total_seconds() <= remaining_seconds.total_seconds():\n                        other = datetime.combine(other.date(), self.start[0]) + remaining_seconds\n                        remaining_seconds = timedelta(0)\n                    else:\n                        other += remaining_seconds\n                        remaining_seconds = timedelta(0)\n                elif (next_day_closing - other).total_seconds() <= remaining_seconds.total_seconds():\n                    other = next_day_closing\n                    remaining_seconds -= next_day_closing - other\n                else:\n                    other += remaining_seconds\n                    remaining_seconds = timedelta(0)\n            else:\n                prev_day_closing = self._get_closing_time(other)\n                prev_day_opening = self._prev_opening_time(prev_day_closing)\n\n                if curr_time > self.end[0]:\n                    diff_to_end = other - datetime.combine(other.date(), self.end[0])\n                    if diff_to_end.total_seconds() <= remaining_seconds.total_seconds():\n                        other = datetime.combine(other.date(), self.end[0]) - remaining_seconds\n                        remaining_seconds = timedelta(0)\n                    else:\n                        other -= remaining_seconds\n                        remaining_seconds = timedelta(0)\n                elif (other - prev_day_opening).total_seconds() <= remaining_seconds.total_seconds():\n                    other = prev_day_opening\n                    remaining_seconds -= other - prev_day_opening\n                else:\n                    other -= remaining_seconds\n                    remaining_seconds = timedelta(0)\n\n        return other\n    else:\n        raise ApplyTypeError(\"Only know how to combine business hour with datetime\")",
            "import_list": []
        }
    ]
}