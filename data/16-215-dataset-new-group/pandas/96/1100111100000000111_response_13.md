There are several issues in the `apply` function provided. The main cause of the bug can be linked to the incorrect calculation of the business hours when adjusting the datetime, which then leads to incorrect number generation for the periods. This is why the first test is not passing. 

A strategy for fixing the bug:
1. Calculate the business hours correctly and efficiently when adjusting the datetime.
2. Make sure that the adjustments for business days are handled accurately before moving onto the next business time interval.

Here's the corrected version of the `apply` function:

```python
# existing import statement...
# ... (import statements are the same as mentioned at the top)

# The declaration of the class containing the corrected function
class BusinessHourMixin(BusinessMixin):
    # existing functions implementations...

    # corrected apply function
    @apply_wraps
    def apply(self, other):
        if isinstance(other, datetime):
            # reset timezone and nanosecond
            other = datetime(
                other.year,
                other.month,
                other.day,
                other.hour,
                other.minute,
                other.second,
                other.microsecond,
            )
            n = self.n
    
            # adjust other to reduce number of cases to handle
            if n >= 0:
                if other.time() in self.end or not self._is_on_offset(other):
                    other = self._next_opening_time(other)
            else:
                if other.time() in self.start:
                    other = other - timedelta(seconds=1)
                if not self._is_on_offset(other):
                    other = self._next_opening_time(other)
                    other = self._get_closing_time(other)
    
            # get total business hours by sec in one business day
            businesshours = sum(
                self._get_business_hours_by_sec(st, en)
                for st, en in zip(self.start, self.end)
            )
    
            bd, r = divmod(abs(n * 60), businesshours // 60)
            if n < 0:
                bd, r = -bd, -r
    
            # adjust by business days first
            if bd != 0:
                skip_bd = BusinessDay(n=bd)
                if not self.is_on_offset(other):
                    other = self.next_bday.apply(other)
                other = other + skip_bd
    
            # remaining business hours to adjust
            bhour_remain = timedelta(minutes=r)
    
            time_diff = timedelta(0)
            if n < 0:
                order = -1
                start_time = self._get_closing_time(self._prev_opening_time(other))
                end_time = self._next_opening_time(other)
            else:
                order = 1
                start_time = other
                end_time = self._get_closing_time(self._prev_opening_time(start_time + timedelta(days=1)))
    
            while bhour_remain.total_seconds() > 0:
                business_interval = end_time - start_time
                if bhour_remain >= business_interval:
                    time_diff += business_interval * order
                    bhour_remain -= business_interval
                    start_time = end_time
                    end_time = self._next_opening_time(start_time + timedelta(days=1))
                else:
                    time_diff += bhour_remain * order
                    bhour_remain = timedelta(0)
    
            return other + time_diff
        else:
            raise ApplyTypeError("Only know how to combine business hour with datetime")
```

This corrected version of the `apply` function should address the calculation issues and ensure accurate generation of dates with the given periods and holidays.