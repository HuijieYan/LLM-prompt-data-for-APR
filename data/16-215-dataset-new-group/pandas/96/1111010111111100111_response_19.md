The issue lies in the `apply` function of the `BusinessHourMixin` class. The function is not correctly handling the adjustment of business hours when there are holidays involved, leading to unexpected behavior in the `pd.date_range` function when periods and holidays are used together.

The key problem appears to be in the adjustment of business days (`skip_bd` computation and adjustment). This is causing the unexpected increase in periods in the `pd.date_range` function.

Given the detailed cases and the failed test case, it seems that the adjustments for business days and remaining business hours are not performed correctly when there are holidays involved.

To fix this bug, we need to review and revise the logic for adjusting business days and business hours in the `apply` function.

Here's the corrected version of the `apply` function:

```python
@apply_wraps
def apply(self, other):
    if isinstance(other, datetime):
        # ... (existing code)
        # Adjust other to reduce the number of cases to handle

        # Calculate the total business hours in a day
        business_hours_per_day = sum(
            self._get_business_hours_by_sec(st, en)
            for st, en in zip(self.start, self.end)
        )

        # Compute the adjustment required for business days and remaining business hours
        business_days_adjustment, remainder_minutes = divmod(abs(self.n * 60), business_hours_per_day // 60)
        if self.n < 0:
            business_days_adjustment, remainder_minutes = -business_days_adjustment, -remainder_minutes

        # Adjust by business days first
        if business_days_adjustment != 0:
            skip_business_days = CustomBusinessDay(n=business_days_adjustment)
            other = other + skip_business_days

        # Adjust remaining business hours
        business_hour_remainder = timedelta(minutes=remainder_minutes)

        while business_hour_remainder > timedelta(0):
            next_opening_time = self._next_opening_time(other)
            closing_time = self._get_closing_time(next_opening_time)

            if self.n >= 0:
                business_hours_interval = closing_time - other
                if business_hour_remainder < business_hours_interval:
                    other += business_hour_remainder
                    business_hour_remainder = timedelta(0)
                else:
                    business_hour_remainder -= business_hours_interval
                    other = self._next_opening_time(other + business_hours_interval)
            else:
                business_hours_interval = next_opening_time - other
                if business_hour_remainder > business_hours_interval:
                    other += business_hour_remainder
                    business_hour_remainder = timedelta(0)
                else:
                    business_hour_remainder -= business_hours_interval
                    other = self._get_closing_time(next_opening_time - timedelta(seconds=1))

        return other
    else:
        raise ApplyTypeError("Only know how to combine business hour with datetime")
```

This corrected version of the `apply` function should now handle the adjustment of business days and remaining business hours correctly, even when holidays are involved. It should resolve the issue reported on GitHub and provide the correct behavior for the `pd.date_range` function when using periods and holidays together.