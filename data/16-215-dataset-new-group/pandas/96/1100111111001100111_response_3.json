{
    "pandas": [
        {
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 1,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.3.3": 1,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.5": 1,
                "2.1.6": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 1
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 1,
                "5": 0,
                "6": 1,
                "7": 0,
                "8": 1,
                "9": 1
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 0,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 1,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.3.3": 1,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.5": 1,
                "2.1.6": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 1
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 1,
                "5": 0,
                "6": 1,
                "7": 0,
                "8": 1,
                "9": 1
            },
            "bugID": 96,
            "start_line": 857,
            "file_name": "pandas/tseries/offsets.py",
            "replace_code": "def apply(self, other):\n    if isinstance(other, datetime):\n        n = self.n\n        working_time_intervals = [(start, end) for start, end in zip(self.start, self.end)]\n        other = datetime(other.year, other.month, other.day, other.hour, other.minute, other.second, other.microsecond)\n\n        if n >= 0:\n            for start, end in working_time_intervals:\n                if other.time() in end or not self._is_on_offset(other):\n                    other = self._get_closing_time(self._next_opening_time(other))\n                    break\n        else:\n            for start, end in working_time_intervals:\n                if other.time() in start:\n                    other = other - timedelta(seconds=1)\n                    break\n                elif not self._is_on_offset(other):\n                    other = self._get_closing_time(self._next_opening_time(other))\n                    break\n\n        holiday_adjustment = 0\n        skip_days = abs(n) // len(working_time_intervals)\n\n        for i in range(skip_days):\n            if not self.next_bday.is_on_offset(other):\n                other = self.next_bday.rollback(other)\n                holiday_adjustment += 1\n                if holiday_adjustment > 5:  # All weekdays are holidays\n                    raise ValueError(\"No working days available\")  # Adjust the error message according to the requirement\n            else:\n                other = self.next_bday.rollforward(other)\n\n        if n < 0:\n            other = working_time_intervals[0][0]  # Set to the beginning of the working time interval\n\n        remaining_minutes = abs(n) - skip_days * len(working_time_intervals)\n        current_index = 0 if n >= 0 else len(working_time_intervals) - 1\n        while remaining_minutes > 0:\n            start, end = working_time_intervals[current_index]\n            hours, minutes = divmod(remaining_minutes * 60, len(working_time_intervals))\n            current_time = datetime.combine(other.date(), start) if current_index == 0 else datetime.combine(other.date(), end)\n            adjusted_time = current_time + timedelta(hours=hours, minutes=minutes)\n\n            if n >= 0:\n                if adjusted_time <= datetime.combine(other.date(), end):\n                    other = other.replace(hour=adjusted_time.hour, minute=adjusted_time.minute, second=0, microsecond=0)\n                    remaining_minutes = 0  # Done adjusting\n                else:\n                    remaining_minutes -= int((end.hour - other.hour) * 60 + end.minute - other.minute)\n            else:\n                if adjusted_time >= datetime.combine(other.date(), start):\n                    other = other.replace(hour=adjusted_time.hour, minute=adjusted_time.minute, second=0, microsecond=0)\n                    remaining_minutes = 0  # Done adjusting\n                else:\n                    remaining_minutes -= int((other.hour - start.hour) * 60 + other.minute - start.minute)\n\n            current_index = current_index + 1 if n >= 0 else current_index - 1\n\n        return other\n    else:\n        raise ApplyTypeError(\"Only know how to combine business hour with datetime\")",
            "import_list": []
        }
    ]
}