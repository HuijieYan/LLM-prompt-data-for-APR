## Correction of the buggy function

```python
class BusinessHourMixin(BusinessMixin):
    @apply_wraps
    def apply(self, other):
        if isinstance(other, datetime):
            n = self.n
            bd, r = divmod(abs(n), 8)

            if n < 0:  # adjust sign
                bd, r = -bd, -r

            other_time = other.time()

            if n > 0:  # move to next business hour
                if other_time in self.end or not self._is_on_offset(other):
                    other = self._next_opening_time(other)
            else:
                if other_time in self.start:  # move to previous business day
                    other = other - timedelta(seconds=1)
                if not self._is_on_offset(other):
                    other = self._next_opening_time(other)
                    other = self._get_closing_time(other)

            businesshours_per_day = []
            for st, en in zip(self.start, self.end):
                businesshours_per_day.append(self._get_business_hours_by_sec(st, en))

            if n != 0:  # adjust by business days first
                skip_bd = BusinessDay(n=bd)
                if not self.next_bday.is_on_offset(other):  # midnight business hour may not be on BusinessDay
                    prev_open = self._prev_opening_time(other)
                    remain = other - prev_open
                    other = prev_open + skip_bd + remain
                else:
                    other = other + skip_bd

            bhour_remain = timedelta(minutes=r)

            if n > 0:  # for positive n
                while bhour_remain != timedelta(0):
                    prev_open = self._prev_opening_time(other)
                    closing_time = self._get_closing_time(prev_open)
                    bhour = closing_time - other
                    if bhour_remain <= bhour:  # finish adjusting if possible
                        other += bhour_remain
                        bhour_remain = timedelta(0)
                    else:  # go to next business time interval
                        bhour_remain -= bhour
                        other = self._next_opening_time(closing_time + timedelta(seconds=1))
            else:  # for non-positive n
                while bhour_remain != timedelta(0):
                    next_open = self._next_opening_time(other)
                    bhour = next_open - other
                    if bhour_remain > bhour or (bhour_remain == bhour and other.nanosecond != 0):  # finish adjusting if possible
                        other += bhour_remain
                        bhour_remain = timedelta(0)
                    else:  # go to next business time interval
                        bhour_remain -= bhour
                        other = self._get_closing_time(next_open - timedelta(seconds=1))

            return other
        else:
            raise ApplyTypeError("Only know how to combine business hour with datetime")
```

The corrected version of the `apply` function includes changes to handle the holiday issue encountered in the failing test case. The main changes involve updating the logic for adjusting the business days and calculating the remaining business hours. The adjusted code should pass the failing test and satisfy the expected input/output values.