The problem stems from the CustomBusinessHour class's apply function which incorrectly calculates the next business hours. This leads to an incorrect assignment of the time for the next business day when holidays are involved. The issue was reported on GitHub with a detailed explanation of the problem.

To fix the bug, we need to rework the logic in the apply function to properly handle the calculation of business hours and the adjustments for holidays. 

Here's the corrected version of the apply function:

```python
def apply(self, other):
    if isinstance(other, pd.Timestamp):
        nanosecond = getattr(other, "nanosecond", 0)
        n = self.n

        start_time = datetime.combine(other, self.start[0])
        end_time = datetime.combine(other, self.end[0])

        adjusted_time = start_time + timedelta(minutes=n * 60)

        if isinstance(other, pd.Timestamp):
            if other.time() > self.end[0] or not self._is_on_offset(other):
                adjusted_time = self._next_opening_time(other)

        return adjusted_time
    else:
        raise ApplyTypeError("Only know how to combine business hour with a datetime")
```

In this corrected version, we use the datetime.combine method to merge the date part of the other timestamp with the start time and end time attributes of the CustomBusinessHour object. Then we calculate the adjusted time based on the value of 'n' and other business hour attributes. Additionally, we handle the holiday conditions properly in the if-else block.

This implementation should resolve the issue reported on GitHub and ensure that the test case provided will pass.