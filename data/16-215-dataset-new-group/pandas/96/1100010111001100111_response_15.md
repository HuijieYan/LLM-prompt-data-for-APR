The issue appears to be related to the calculation of holiday periods within the `CustomBusinessHour` class, which is causing unexpected output in the `pd.date_range` function when periods are specified. This is likely due to incorrect holiday adjustment within the `apply` method of the `CustomBusinessHour` class.

To fix this bug, the adjustment of the `other` variable in relation to the holiday needs to be properly managed within the `apply` function. Specifically, the handling of holidays and their impact on the business hour calculation needs to be reviewed and potentially corrected to ensure that the desired behavior is achieved when determining periods in the `pd.date_range` function.

Here's the corrected version of the `apply` function:

```python
@apply_wraps
def apply(self, other):
    if isinstance(other, datetime):
        # used for detecting edge condition
        nanosecond = getattr(other, "nanosecond", 0)

        # Check if the current date falls on a holiday
        if other.date() in self.holidays:
            # Move the date to the next business day after the holiday
            other = self.next_bday.rollforward(other)

        # Get the total business hours by sec in one business day
        businesshours = sum(
            self._get_business_hours_by_sec(st, en)
            for st, en in zip(self.start, self.end)
        )

        # Compute the total business days and remaining business hours to adjust
        total_mins = self._calc_business_duration(other, businesshours)
        bd, r = divmod(abs(total_mins), businesshours // 60)

        if self.n < 0:
            # Adjust for negative business days and hours
            bd, r = -bd, -r

        if bd != 0:
            # Adjust based on business days first
            other = self._adjust_for_business_days(bd, other)

        # Adjust remaining business hours
        other = self._adjust_for_remaining_hours(r, nanosecond, other)

        return other
    else:
        raise ApplyTypeError("Only know how to combine business hour with datetime")
```

In the corrected version, the `apply` function explicitly checks for holidays and adjusts the `other` variable accordingly. Additionally, business days and remaining business hours are adjusted separately, ensuring accurate calculations in both positive and negative scenarios.

This correction should address the issue reported on GitHub and ensure that the `pd.date_range` function works as intended, even when holidays and periods are specified.