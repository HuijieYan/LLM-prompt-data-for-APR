{
    "pandas": [
        {
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 0,
                "1.3.3": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.5": 0,
                "2.1.6": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 1
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 0,
                "4": 0,
                "5": 1,
                "6": 0,
                "7": 0,
                "8": 1,
                "9": 1
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 0,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 0,
                "1.3.3": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.5": 0,
                "2.1.6": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 1
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 0,
                "4": 0,
                "5": 1,
                "6": 0,
                "7": 0,
                "8": 1,
                "9": 1
            },
            "bugID": 96,
            "start_line": 857,
            "file_name": "pandas/tseries/offsets.py",
            "replace_code": "def apply(self, other):\n    # ... existing code\n\n    # adjust other to reduce number of cases\n    # potential bug location\n    other = as_datetime(other)\n\n    # existing code ...\n\n    if isinstance(other, datetime):\n        if self._is_on_offset(other):\n            return other\n\n        mapped = other.date()\n\n        if not self.call(start_or_end=True, dt=mapped) and not self.start <= other.time() < self.end:\n            if n > 0:\n                other = datetime(other.year, other.month, other.day, self.start.hour)\n                other = other + timedelta(days=1) if self.start == self.end else other\n            elif start == end:\n                return other\n            else:\n                other = datetime(other.year, other.month, other.day, self.end.hour)\n\n        # business hours by sec in one business day\n        business_hours = sum(self._get_business_hours_by_sec(st, en) for st, en in zip(self.start, self.end))\n\n        # adjust\n        if apply_index_wraps(mapped, self.start, self.end, n, Span(start=self.start, end=self.end)):\n            if nanosecond != 0:\n                other = other + timedelta(microseconds=(1 * 1000))\n            return other\n\n        bd, r = divmod(n * 60, business_hours // 60)\n        sign = 1 if r > 0 else -1\n\n        if bd != 0:\n            # adjust business days first\n            other = self.next_minute + timedelta(minutes=self.start.minute + self.start.second / 60 + sign)\n            bd -= 1  # remove first adjustment\n            periods = self(n=bd) if n < 0 else -self(n=bd)\n            diff = periods.apply(other, sided=\"right\" if n < 0 else \"left\") - other\n            return diff + other\n\n        # remaining business hours to adjust\n        remaining = timedelta(minutes=r % 60)\n        bases = timedelta(minutes=r) // sign\n        while remaining != timedelta(0):\n            close = self._get_closing_time(other)\n            adjustment = close - other\n            if remaining >= abs(adjustment) or (remaining == abs(adjustment) and nanosecond != 0):\n                other += adjustment\n                remaining -= abs(adjustment)\n                continue\n            return other + remaining\n        return other",
            "import_list": []
        }
    ]
}