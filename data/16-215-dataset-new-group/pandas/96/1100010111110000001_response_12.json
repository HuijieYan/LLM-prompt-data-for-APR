{
    "pandas": [
        {
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 0,
                "1.3.3": 1,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.5": 0,
                "2.1.6": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 1
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 0,
                "4": 1,
                "5": 1,
                "6": 0,
                "7": 0,
                "8": 0,
                "9": 1
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 0,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 0,
                "1.3.3": 1,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.5": 0,
                "2.1.6": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 1
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 0,
                "4": 1,
                "5": 1,
                "6": 0,
                "7": 0,
                "8": 0,
                "9": 1
            },
            "bugID": 96,
            "start_line": 857,
            "file_name": "pandas/tseries/offsets.py",
            "replace_code": "def apply(self, other):\n    if isinstance(other, datetime):\n        n = self.n\n        openings = self._parse_custom_start()\n        closes = self._parse_custom_end()\n        start_day = other.replace(hour=0, minute=0, second=0, microsecond=0)\n        if n >= 0:\n            days, remainder = divmod(n, len(openings))\n            if remainder == 0:\n                days -= 1\n                remainder = len(openings)\n            current = start_day\n            for i in range(days):\n                next_opening = self._next_opening_time(current)\n                current = next_opening\n            idx = remainder - 1\n            opening = openings[idx]\n            if current.time() >= opening:\n                current = self._next_opening_time(current)\n            if current.date() == start_day.date():\n                idx = (idx + 1) % len(openings)\n                current = current.replace(hour=openings[idx].hour, minute=openings[idx].minute, second=0)\n            else:\n                current = current.replace(hour=openings[idx].hour, minute=openings[idx].minute, second=0)\n        else:\n            days, remainder = divmod(abs(n), len(closes))\n            if remainder == 0 and days != 0:\n                days -= 1\n                remainder = len(closes)\n            current = start_day\n            for i in range(days):\n                prev_closing = self._get_closing_time(current)\n                current = prev_closing\n            idx = remainder - 1\n            closing = closes[idx]\n            if current.time() <= closing:\n                current = self._get_closing_time(self._prev_opening_time(current) - pd.Timedelta(seconds=1))\n                if current.date() in self.holidays:\n                    current = self._prev_opening_time(current)\n            else:\n                current = current.replace(hour=closes[idx].hour, minute=closes[idx].minute, second=0)\n        return current\n    else:\n        raise ApplyTypeError(\"Only know how to combine business hour with datetime\")",
            "import_list": []
        }
    ]
}