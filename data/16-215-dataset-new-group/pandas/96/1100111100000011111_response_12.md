To fix the bug in the provided function, we need to address the issue related to the CustomBusinessHour offset when used with holidays in the date_range function.

Upon reviewing the function code, the primary issue seems to be related to the improper handling of holidays when calculating the business hours and adjusting the datetime values. The buggy function `apply` is not handling the business hours properly when holidays are involved.

To fix this bug, we need to update the logic in the `apply` function to properly handle holidays and adjust the datetime values accordingly.

Here's an updated and corrected version of the function:

```python
# Corrected version of the apply function
class BusinessHourMixin(BusinessMixin):
    @apply_wraps
    def apply(self, other):
        if isinstance(other, datetime):
            # Reset timezone and nanosecond
            other = other.replace(
                hour=other.hour,
                minute=other.minute,
                second=0,
                microsecond=0
            )
            n = self.n
    
            # Adjust other to reduce the number of cases to handle
            if n >= 0:
                if not self._is_on_offset(other) or other.time() in self.end:
                    other = self._next_opening_time(other)
            else:
                if other.time() in self.start:
                    # Adjustment to move to the previous business day
                    other -= timedelta(seconds=1)
                if not self._is_on_offset(other):
                    other = self._next_opening_time(other)
    
            # Get total business hours by sec in one business day
            businesshours = sum(
                self._get_business_hours_by_sec(st, en)
                for st, en in zip(self.start, self.end)
            )
    
            bd, r = divmod(abs(n * 60), businesshours // 60)
            if n < 0:
                bd, r = -bd, -r
    
            # Adjust by business days first
            if bd != 0:
                skip_bd = BusinessDay(n=bd)
                if not self.next_bday.is_on_offset(other):
                    prev_open = self._prev_opening_time(other)
                    remain = other - prev_open
                    other = prev_open + skip_bd + remain
                else:
                    other += skip_bd
    
            # Remaining business hours to adjust
            bhour_remain = timedelta(minutes=r)
    
            if n >= 0:
                while bhour_remain != timedelta(0):
                    bhour = self._get_closing_time(self._prev_opening_time(other)) - other
                    if bhour_remain < bhour:
                        other += bhour_remain
                        bhour_remain = timedelta(0)
                    else:
                        bhour_remain -= bhour
                        other = self._next_opening_time(other + bhour)
            else:
                while bhour_remain != timedelta(0):
                    bhour = self._next_opening_time(other) - other
                    if bhour_remain > bhour:
                        other += bhour_remain
                        bhour_remain = timedelta(0)
                    else:
                        bhour_remain -= bhour
                        other = self._get_closing_time(
                            self._next_opening_time(other + bhour - timedelta(seconds=1)
                        )
    
            return other
        else:
            raise ApplyTypeError("Only know how to combine business hour with datetime")
```

This corrected version of the `apply` function should address the issue related to the calculation of business hours when using the CustomBusinessHour offset in the date_range function. It properly handles holidays and adjusts the datetime values accordingly.

With these updates, the function should now produce the expected output for various cases involving dates and business hours, including cases with holidays.

Please consider testing the corrected function with the provided expected cases to ensure that it fulfills the expected input/output values and resolves the issue reported on GitHub.