The issue seems to be related to the behavior of the `pd.date_range` function with custom business hours and holidays. It fails to produce the expected number of periods when adding holidays to the frequency. The bug is located in the `apply` function of the `CustomBusinessHour` class in the `pandas/tseries/offsets.py` file.

The issue arises because the `apply` function has incorrect logic for adjusting datetime with business hours when holidays are involved. This results in an unexpected number of periods being returned by the `pd.date_range` function when using a custom business hour and adding holidays.

To fix the bug, we need to refactor the logic in the `apply` function of the `CustomBusinessHour` class to correctly handle the adjustment of datetimes with business hours and holidays.

Here's the corrected version of the `apply` function:
```python
@apply_wraps
def apply(self, other):
    if isinstance(other, datetime):
        n = self.n

        # Check if other is a holiday
        if np.datetime64(other) in self.holidays:
            raise ApplyTypeError("Specified date is a holiday")

        # Adjust the other datetime based on the business hour start time
        adjusted = datetime(other.year, other.month, other.day, self.start[0].hour, self.start[0].minute)        

        # If the adjusted time is after the other time, increment to the next business hour
        if adjusted <= other:
            other = adjusted
        else:
            other = self._next_opening_time(other)

        # Handle positive and negative n differently
        if n >= 0:
            while n > 0:
                other = self._next_opening_time(other)
                n -= 1
        else:
            while n < 0:
                other -= timedelta(hours=1)
                if isinstance(self, CustomBusinessHour) or self._is_on_offset(other):
                    other = self._prev_opening_time(other)
                n += 1

        return other
    else:
        raise ApplyTypeError("Only know how to combine business hour with datetime")
```

In the corrected version, we properly handle holidays by checking if the `other` datetime falls on a holiday and raise an exception if so. We also adjusted the datetime based on the business hour start time and handle positive and negative `n` values separately. This should resolve the issue reported on GitHub and ensure that the `pd.date_range` function works as expected with custom business hours and holidays.