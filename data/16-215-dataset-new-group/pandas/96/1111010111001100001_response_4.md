The buggy function `apply` is failing because it is not correctly adjusting the datetime based on the business hours and holidays. It is also not handling the case where the given datetime is already a business hour. 

The cause of the bug is that the function does not properly calculate the number of business days to adjust for and does not correctly handle the remaining business hours to adjust.

To fix the bug, the function should first check if the given datetime is already a business hour. Then it should calculate the number of business days to adjust for using the given input `n` and then handle the remaining business hours to adjust, taking care of potential edge cases. 

Below is the corrected version of the `apply` function:

```python
@apply_wraps
def apply(self, other):
    if isinstance(other, datetime):
        if other.time() in self.start:
            return other

        n = self.n
    
        # adjust other to reduce number of cases to handle
        if n >= 0:
            if other.time() in self.end or not self._is_on_offset(other):
                other = self._next_opening_time(other)
        else:
            if other.time() in self.start:
                other = other - timedelta(seconds=1)
                if other.time() not in self.start or not self._is_on_offset(other):
                    other = self._next_opening_time(other)
                    other = self._get_closing_time(other)

        # remaining business hours to adjust
        bhour_remain = timedelta(minutes=n * 60)

        # handle adjusting business days if needed
        if abs(n) // len(self.weekmask) > 0:
            other = self.next_bday.rollforward(other)
        
        businesshours = sum(self._get_business_hours_by_sec(st, en) for st, en in zip(self.start, self.end))

        # adjust timing based on business hours
        while bhour_remain != timedelta(0):
            if n > 0:
                interval_closing = self._get_closing_time(other)
                bhour = interval_closing - other
            else:
                interval_opening = self._next_opening_time(other)
                bhour = interval_opening - other - timedelta(seconds=1)

            if bhour_remain < bhour:
                other += bhour_remain
                bhour_remain = timedelta(0)
            else:
                bhour_remain -= bhour
                if n > 0:
                    other = self._next_opening_time(other) + bhour_remain
                else:
                    other = self._get_closing_time(self._next_opening_time(other + bhour_remain) - timedelta(seconds=1))

        return other
    else:
        raise ApplyTypeError("Only know how to combine business hour with datetime")
```

With this corrected version, the failing test case provided should now pass successfully.