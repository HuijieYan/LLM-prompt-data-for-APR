The bug in the `astype_nansafe` function is causing an error when attempting to cast a Categorical or CategoricalIndex containing NaNs to an integer dtype.

The issue is caused by inconsistent behavior when converting from categorical to int. When converting a categorical series back into an Int column, it converts NaN to an incorrect integer negative value. This behavior is unexpected and leads to the test failure.

To fix the bug, we need to update the `astype_nansafe` function to handle NaN values when casting to an integer dtype.

### Corrected Version of the Function

```python
def astype_nansafe(arr, dtype, copy: bool = True, skipna: bool = False):
    """
    Cast the elements of an array to a given dtype in a nan-safe manner.

    Parameters
    ----------
    arr : ndarray
    dtype : np.dtype
    copy : bool, default True
        If False, a view will be attempted but may fail, if
        e.g. the item sizes don't align.
    skipna: bool, default False
        Whether or not we should skip NaN when casting as a string-type.

    Raises
    ------
    ValueError
        The dtype was a datetime64/timedelta64 dtype, but it had no unit.
    """

    # ... (other parts of the function remain unchanged)

    elif np.issubdtype(arr.dtype, np.floating) and np.issubdtype(dtype, np.integer):

        if not np.isfinite(arr).all():
            raise ValueError("Cannot convert non-finite values (NA or inf) to integer")
        
        # Handle NaN values by casting to a float dtype
        result = arr.astype(dtype, copy=copy)
        result[np.isnan(arr)] = np.nan
        return result

    # ... (other parts of the function remain unchanged)

    return arr.view(dtype)
```

By updating the behavior of the function to handle NaN values when casting to an integer dtype, the test function `test_astype_nansafe` should pass without raising an error. This change will also address the issue reported on GitHub related to converting from categorical to int ignoring NaNs.