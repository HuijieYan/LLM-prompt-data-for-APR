## Fixing the bug

The issue seems to involve converting categorical data with NaN values to integer dtype, which results in unexpected behavior. To fix the bug, we need to ensure that NaN values are handled correctly during the conversion process.

### Strategy for fixing the bug
1. Identify the specific condition where NaN values are not handled correctly.
2. Modify the conversion process to handle NaN values appropriately when converting categorical data to an integer dtype.
3. Ensure that the corrected function satisfies the expected input/output values and types for the provided test cases.

### Corrected version of the function
```python
def astype_nansafe(arr, dtype, copy: bool = True, skipna: bool = False):
    """
    Cast the elements of an array to a given dtype in a nan-safe manner.

    Parameters
    ----------
    arr : ndarray
    dtype : np.dtype
    copy : bool, default True
        If False, a view will be attempted but may fail, if
        e.g. the item sizes don't align.
    skipna: bool, default False
        Whether or not we should skip NaN when casting as a string-type.

    Raises
    ------
    ValueError
        The dtype was a datetime64/timedelta64 dtype, but it had no unit.
    """

    # dispatch on extension dtype if needed
    if is_extension_array_dtype(dtype):
        return dtype.construct_array_type()._from_sequence(arr, dtype=dtype, copy=copy)

    if not isinstance(dtype, np.dtype):
        dtype = pandas_dtype(dtype)

    if issubclass(dtype.type, str):
        return lib.astype_str(arr.ravel(), skipna=skipna).reshape(arr.shape)

    elif is_datetime64_dtype(arr):
        if is_object_dtype(dtype):
            return tslib.ints_to_pydatetime(arr.view(np.int64))
        elif dtype == np.int64:
            return arr.view(dtype)

        # allow frequency conversions
        if dtype.kind == "M":
            return arr.astype(dtype)

        raise TypeError(f"cannot astype a datetimelike from [{arr.dtype}] to [{dtype}]")

    elif is_timedelta64_dtype(arr):
        if is_object_dtype(dtype):
            return tslibs.ints_to_pytimedelta(arr.view(np.int64))
        elif dtype == np.int64:
            return arr.view(dtype)

        if dtype not in [_INT64_DTYPE, _TD_DTYPE]:

            # allow frequency conversions
            # we return a float here!
            if dtype.kind == "m":
                mask = isna(arr)
                result = arr.astype(dtype).astype(np.float64)
                result[mask] = np.nan
                return result
        elif dtype == _TD_DTYPE:
            return arr.astype(_TD_DTYPE, copy=copy)

        raise TypeError(f"cannot astype a timedelta from [{arr.dtype}] to [{dtype}]")

    elif np.issubdtype(arr.dtype, np.floating) and np.issubdtype(dtype, np.integer):
        if not np.isfinite(arr).all():
            raise ValueError("Cannot convert non-finite values (NA or inf) to integer")

        mask = isna(arr)
        if np.any(mask):
            result = arr.astype(dtype)
            result[mask] = np.nan
            return result
        else:
            return arr.astype(dtype)

    # ... (rest of the function remains unchanged)
    # (No changes made to the code that does not directly relate to the issue)
```

The key modification in the corrected function is in the condition that handles converting from floating to integer dtype. We handle the NaN values explicitly to convert them as expected when converting categorical data to an integer type.

Please test the corrected function with the provided test cases to ensure that it now satisfies the expected input/output values and resolves the issue reported on GitHub.