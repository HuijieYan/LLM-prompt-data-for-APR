The bug in the `astype_nansafe` function is causing an error when trying to cast NaN values to an integer type. This is evident from the failing test, which attempts to cast NaN to an integer and expects a ValueError to be raised, but the function does not raise the expected error.

The cause of the bug is that the function is not handling the conversion of NaN values to integer types correctly. The failing test is designed to catch this specific error case, and the error message indicates that the function is failing to raise a ValueError when it should.

To fix this bug, the function needs to be modified to correctly handle the casting of NaN values to integer types, and ensure that it raises a ValueError in this scenario.

Here is a corrected version of the `astype_nansafe` function that should resolve the issue:

```python
def astype_nansafe(arr, dtype, copy: bool = True, skipna: bool = False):
    """
    Cast the elements of an array to a given dtype a nan-safe manner.

    Parameters
    ----------
    arr : ndarray
    dtype : np.dtype
    copy : bool, default True
        If False, a view will be attempted but may fail, if
        e.g. the item sizes don't align.
    skipna: bool, default False
        Whether or not we should skip NaN when casting as a string-type.

    Raises
    ------
    ValueError
        The dtype was a datetime64/timedelta64 dtype, but it had no unit.
    ValueError
        Cannot convert NaN values to integer.
    """

    # dispatch on extension dtype if needed
    if is_extension_array_dtype(dtype):
        return dtype.construct_array_type()._from_sequence(arr, dtype=dtype, copy=copy)

    if not isinstance(dtype, np.dtype):
        dtype = pandas_dtype(dtype)

    if issubclass(dtype.type, str):
        return lib.astype_str(arr.ravel(), skipna=skipna).reshape(arr.shape)

    elif is_datetime64_dtype(arr):
        if is_object_dtype(dtype):
            return tslib.ints_to_pydatetime(arr.view(np.int64))
        elif dtype == np.int64:
            return arr.view(dtype)

        # allow frequency conversions
        if dtype.kind == "M":
            return arr.astype(dtype)

        raise TypeError(f"cannot astype a datetimelike from [{arr.dtype}] to [{dtype}]")

    elif is_timedelta64_dtype(arr):
        if is_object_dtype(dtype):
            return tslibs.ints_to_pytimedelta(arr.view(np.int64))
        elif dtype == np.int64:
            return arr.view(dtype)

        if dtype not in [_INT64_DTYPE, _TD_DTYPE]:

            # allow frequency conversions
            # we return a float here!
            if dtype.kind == "m":
                mask = isna(arr)
                result = arr.astype(dtype).astype(np.float64)
                result[mask] = np.nan
                return result
        elif dtype == _TD_DTYPE:
            return arr.astype(_TD_DTYPE, copy=copy)

        raise TypeError(f"cannot astype a timedelta from [{arr.dtype}] to [{dtype}]")

    # Check for NaN values when casting to integer
    if np.issubdtype(arr.dtype, np.floating) and np.issubdtype(dtype, np.integer) and isna(arr).any():
        raise ValueError("Cannot convert NaN values to integer")

    elif np.issubdtype(arr.dtype, np.floating) and np.issubdtype(dtype, np.integer):
        if not np.isfinite(arr).all():
            raise ValueError("Cannot convert non-finite values (NA or inf) to integer")

    # ... rest of the function remains unchanged ...

    return arr.view(dtype)
```

With this corrected version of the `astype_nansafe` function, it should now correctly handle the casting of NaN values to integer types and raise a ValueError when encountering NaN values during the conversion process. This should resolve the issue reported in the GitHub bug report and allow the failing test to pass.