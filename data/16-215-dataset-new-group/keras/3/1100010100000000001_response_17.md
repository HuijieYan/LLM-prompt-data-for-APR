The bug in this function is that the input_layers list is not defined when initializing input Layers. The depth keys are not sorted correctly, and the nodes in a single depth layer need to be initialized as a child of a Dense layer for it to work properly. It also reuses previously cloned layers in the wrong way.

To fix the bug, we need to define input_layers, sort the depth_keys correctly, and change the way it reuses previously cloned layers.


```python
def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)

    layer_map = {}  
    tensor_map = {}  

    if input_tensors is None:
        input_tensors = [Input(batch_shape=layer.batch_input_shape[1:]) for layer in model._input_layers]
    else:
        input_tensors = to_list(input_tensors)
        for i, x in enumerate(input_tensors):
            if not K.is_keras_tensor(x):
                name = model._input_layers[i].name
                input_tensor = Input(tensor=x, name='input_wrapper_for_' + name)
                input_tensors[i] = input_tensor

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort()
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            layer = node.outbound_layer
            if layer not in layer_map:
                new_layer = layer.__class__.from_config(layer.get_config())
                layer_map[layer] = new_layer
                layer = new_layer
            else:
                layer = layer_map[layer]
                if isinstance(layer, InputLayer):
                    continue

            reference_input_tensors = [tensor_map[x] for x in node.inbound_layers]
            computed_tensors = layer(reference_input_tensors[0][0])
            for x in reference_input_tensors[1:]:
              computed_tensors = layer(x[0])

            for x, tensor in zip(node.output_tensors, computed_tensors):
                tensor_map[x] = (tensor, None)

    output_tensors = [tensor_map[x][0] for x in model.outputs]
    return Model(input_tensors, output_tensors, name=model.name)
```