Based on the bug report and the failing test, it appears that the issue arises when using `clone_model` with a model that contains a `Lambda` layer with multiple outputs. The failing test demonstrated this issue with a `Lambda` layer and a model with multiple outputs.

The error message also indicates that the problem occurs when trying to compute the output tensor for the `SwapLayer` in the failing test.

The cause of the bug is likely due to the `compute_mask` method being called on the `Lambda` layer, but as the bug report indicates, the `Lambda` layer doesn't support using masks. This leads to the `output_masks` always being [None], which does not match the expected [None, None].

To fix the bug, we need to modify the `_clone_functional_model` function to handle the case where the `Lambda` layer's `compute_mask` returns None.

Here's the corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    # similar functionality to the original function
    
    # existing code...

    for node in nodes:
        # existing code...
        
        computed_tensors = []
        computed_masks = []
        for x in reference_input_tensors:
            if x in tensor_map:
                computed_data.append(tensor_map[x])

        if len(computed_data) == len(reference_input_tensors):
            # Call layer.
            if node.arguments:
                kwargs = node.arguments
            else:
                kwargs = {}

            computed_tensors = [x[0] for x in computed_data]
            computed_masks = [x[1] for x in computed_data]

            # checking for None and replacing it with None
            computed_masks = [mask if mask is not None else None for mask in computed_masks]

            output_tensors = to_list(layer(computed_tensors, **kwargs))
            output_masks = to_list(layer.compute_mask(computed_tensors, computed_masks))

            # handle the case where the output_masks is always [None]
            if all(mask is None for mask in output_masks):
                output_masks = [None] * len(output_tensors)

            for x, y, mask in zip(reference_output_tensors, output_tensors, output_masks):
                tensor_map[x] = (y, mask)

    # existing code...
```

In this version, we handle the case where the `Lambda` layer's `compute_mask` always returns None, by explicitly setting `output_masks` to [None] * len(output_tensors) if all masks are None.

This fix should address the issue reported in the GitHub bug and make the failing test pass.