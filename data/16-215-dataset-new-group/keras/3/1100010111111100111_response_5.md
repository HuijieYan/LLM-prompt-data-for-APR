To fix the bug, we need to address the issue with the `clone_model` function not being able to compute the output tensor correctly for models with layers that have multiple outputs and no mask support. 

The problem occurs when the output_masks are expected but are always None due to the layers not supporting masks. This causes the assertion error when attempting to compute the model outputs.

To resolve this issue, we need to modify the `_clone_functional_model` function to handle such cases by checking for layers without mask support and using appropriate logic to deal with multiple outputs.

Here's the corrected version of the `_clone_functional_model` function:

```python
from keras.models import Model
from keras.layers import Input

def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)
    layer_map = {}  # Cache for created layers
    tensor_map = {}  # Map {reference_tensor: (corresponding_tensor, mask)}

    if input_tensors is None:
        input_tensors = [Input(batch_shape=layer.input_shape, dtype=layer.dtype) for layer in model.layers if getattr(layer, '_keras_history', None)]

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    for layer in model.layers:
        if layer not in layer_map:
            new_layer = layer.__class__.from_config(layer.get_config())
            layer_map[layer] = new_layer
            layer = new_layer
        else:
            layer = layer_map[layer]

        if len(layer._output_layers) > 1 and layer.supports_masking:
            # Layer with multiple outputs
            reference_output_tensors = layer._inbound_nodes[0].input_tensors
            computed_data = [tensor_map[x] for x in reference_output_tensors if x in tensor_map]
            if len(computed_data) == len(reference_output_tensors):
                kwargs = layer._inbound_nodes[0].arguments if layer._inbound_nodes else {}
                if len(computed_data) == 1:
                    computed_tensor, computed_mask = computed_data[0]
                    if getattr(layer.call, 'mask', None) and 'mask' not in kwargs:
                        kwargs['mask'] = computed_mask
                    output_tensors = to_list(layer(computed_tensor, **kwargs))
                    computed_tensors = to_list(computed_tensor)
                    computed_masks = to_list(computed_mask)
                else:
                    computed_tensors = [x[0] for x in computed_data]
                    computed_masks = [x[1] for x in computed_data]
                    if getattr(layer.call, 'mask', None) and 'mask' not in kwargs:
                        kwargs['mask'] = computed_masks
                    output_tensors = to_list(layer(computed_tensors, **kwargs))
                
                for x, y, mask in zip(layer.output, output_tensors, to_list(layer.compute_mask(computed_tensors, computed_masks))):
                    tensor_map[x] = (y, mask)
                    
    output_tensors = [tensor_map[x][0] for x in model.outputs]
    
    return Model(input_tensors, output_tensors, name=model.name)
```

This revised version of the function handles models with layers that have multiple outputs and no mask support. It checks for such cases and correctly computes the output tensors. This should resolve the issue with `clone_model` failing for models with multiple outputs and layers with no mask support.