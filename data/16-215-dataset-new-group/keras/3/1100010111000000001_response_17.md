The bug in the `_clone_functional_model` function stems from incorrectly creating and handling input layers when input tensors are not provided. This results in incorrect mapping of input and output tensors during the cloning process. To fix this, we need to update the logic for creating input layers and handling input tensors.

Here's the corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (rest of the function code remains unchanged)

    if input_tensors is None:
        # Create placeholders to build the model on top of.
        input_layers = []
        input_tensors = []
        for layer in model._input_layers:
            input_tensor = Input(batch_shape=layer.batch_input_shape,
                                 dtype=layer.dtype,
                                 sparse=layer.sparse,
                                 name=layer.name)
            input_tensors.append(input_tensor)
            # Cache newly created input layer.
            newly_created_input_layer = input_tensor._keras_history[0]
            layer_map[layer] = newly_created_input_layer
            input_layers.append(newly_created_input_layer)  # Cache the input layer
        # Update the input_layers attribute of the cloned model
        new_model = Model(input_layers, model.outputs, name=model.name)
        for _original, _cloned in zip(model._input_layers, input_layers):
            layer_map[_original] = _cloned
    else:
        # ... (rest of the code for handling input tensors)
        new_model = Model(input_tensors, model.outputs, name=model.name)  # Create the model with provided input tensors

    # ... (rest of the function code remains unchanged)
    
    return new_model
```

In the corrected version, we ensure that when input_tensors are not provided, we create input layers and use these input layers to create the new model. We also update the `input_layers` attribute of the new model to include the newly created input layers.

With these changes, the corrected function should now pass the failing test provided.