### Bug Explanation
The bug is caused by the code's failure to correctly compute the model's outputs. When the function `_clone_functional_model` is called with a model that has multiple inputs and outputs, it fails to properly map the input and output tensors, resulting in the assertion error `Could not compute output`.

The bug arises from the incorrect mapping of input and output tensors in the `tensor_map` dictionary.

### Bug Fix Strategy
To fix the bug, we need to ensure that the function `_clone_functional_model` correctly processes and maps the input and output tensors of the model when cloning the functional `Model`. This involves debugging and updating the code to ensure that all input tensors are correctly mapped to the corresponding outputs, and that the cloned layer instances are properly created and reused.

We also need to ensure that the cloned model's output tensors are correctly computed and added to the `tensor_map`, so that the assertion error does not occur.

### The corrected version of the function
```python
def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)
    if isinstance(model, Sequential):
        raise ValueError('Expected `model` argument to be a functional `Model` instance, got a `Sequential` instance instead:', model)

    layer_map = {}  # Cache for created layers
    tensor_map = {}  # Map {reference_tensor: (corresponding_tensor, mask)}

    layer_map[model.layers[0]] = Input(batch_shape=model.input_shape)

    if input_tensors is None:
        input_tensors = [Input(batch_shape=layer.get_input_shape_at(0)) for layer in model.layers]
    else:
        input_tensors = to_list(input_tensors)

    for original_tensor, input_tensor in zip(model.inputs, input_tensors):
        tensor_map[original_tensor] = input_tensor

    for layer in model.layers:
        if layer not in layer_map:
            layer_config = layer.get_config()
            cloned_layer = layer.__class__.from_config(layer_config)
            layer_map[layer] = cloned_layer

    for layer in model.layers:
        new_input_tensors = [tensor_map[t] for t in layer.get_input_at(0)]
        kwargs = {}
        if hasattr(layer, 'arguments'):
            kwargs = layer.arguments
        new_output_tensors = to_list(layer(new_input_tensors, **kwargs))
        for original_tensor, new_tensor in zip(layer.get_output_at(0), new_output_tensors):
            tensor_map[original_tensor] = new_tensor

    output_tensors = [tensor_map[out] for out in model.outputs]

    return Model(input_tensors, output_tensors, name=model.name)
```

The corrected version of the function makes use of the model's layers and their input and output shapes to correctly map the input and output tensors. It ensures proper creation, mapping, and reuse of layers, as well as the computation of output tensors so that the cloned model's behavior is reproduced accurately. The corrected version is designed to handle models with multiple inputs and outputs without raising an assertion error.