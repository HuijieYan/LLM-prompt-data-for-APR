To fix the bug in the `_clone_functional_model` function, we need to address the issue with output masks being always None when using a functional model with a layer that has multiple outputs without mask support. This issue is causing the "Could not compute output Tensor" error when using `clone_model()`.

The cause of the bug:
The bug is caused by the `Lambda` layer not supporting masks and always returning None for output_masks. This leads to the error when trying to compute the output tensors in the `_clone_functional_model` function.

Strategy for fixing the bug:
We need to modify the code in the `_clone_functional_model` function to handle the case where a layer does not support using masks. Specifically, we need to ensure that the output_masks list contains the correct number of entries even if the layer does not support masks.

Here's the corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... existing code ...

    # Iterated over every node in the reference model, in depth order.
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)

    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # ... existing code ...

            if len(computed_data) == len(reference_input_tensors):
                # Call layer.

                # ... existing code ...

                # Modify to handle masks for single and multiple outputs
                if has_arg(layer.call, 'mask'):
                    if len(computed_data) == 1:
                        if 'mask' not in kwargs:
                            kwargs['mask'] = computed_masks[0]
                    else:
                        if 'mask' not in kwargs:
                            kwargs['mask'] = computed_masks

                # ... existing code ...
    
    # ... existing code ...

    return Model(input_tensors, output_tensors, name=model.name)
```

With these modifications, the function should now handle the case where a layer does not support using masks, and the output_masks list will contain the correct number of entries.

This corrected version should pass the failing test and resolve the issue posted in GitHub.