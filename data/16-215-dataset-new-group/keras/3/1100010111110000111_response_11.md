The buggy function `_clone_functional_model` is failing to properly handle the cloning of a model with multiple outputs, resulting in the error "Could not compute output Tensor". The issue reported on GitHub also describes a similar problem when using `clone_model` with a model containing a layer that has more outputs without mask support.

To fix this bug, we need to ensure that the function properly handles layers with multiple outputs and does not rely on the `compute_mask` method if it is not supported by the layer.

Here's the corrected version of the function:

```python
def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)
    if isinstance(model, Sequential):
        raise ValueError('Expected `model` argument to be a functional `Model` instance, got a `Sequential` instance instead:', model)

    if input_tensors is None:
        input_tensors = [Input(shape=input_layer.shape[1:]) for input_layer in model._input_layers]

    layer_map = {}  # Cache for created layers.
    tensor_map = {}  # Map {reference_tensor: (corresponding_tensor, mask)}

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    for layer in model.layers:
        if layer not in layer_map:
            # Clone layer.
            new_layer = layer.__class__.from_config(layer.get_config())
            layer_map[layer] = new_layer

        reference_input_tensors = layer.input
        reference_output_tensors = layer.output

        computed_data = []
        for x in reference_input_tensors:
            computed_data.append(tensor_map[x])

        if all(data is not None for data in computed_data):
            kwargs = getattr(layer, 'arguments', {})
            computed_tensors = [data[0] for data in computed_data]

            output_tensors = to_list(layer(computed_tensors, **kwargs))

            for x, y in zip(reference_output_tensors, output_tensors):
                tensor_map[x] = (y, None)

    output_tensors = [tensor_map[x][0] for x in model.outputs]
    return Model(inputs=input_tensors, outputs=output_tensors, name=model.name)
```

This corrected version is more robust and handles the cloning of a model with multiple outputs while avoiding reliance on the `compute_mask` method if it is not supported by the layer.

This corrected version should pass the failing test and resolve the issue reported on GitHub.