The bug in the `_clone_functional_model` function seems to be related to the incorrect handling of output masks when calling `layer.compute_mask` in the cloning process. The GitHub issue description also provides an example that reproduces the error, along with an explanation that the error appears when using a functional model with a layer that has more than one output without mask support.

To fix this bug, we need to modify the code to handle the case where the layer doesn't support masks and ensure that the output masks are correctly handled in the cloning process.

Here's a corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (existing function code)

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # initialize with None as mask

    # iterate over every node in the reference model, in depth order
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # Recover the corresponding layer
            layer = node.outbound_layer
            # Get or create layer
            if layer not in layer_map:
                # Clone layer
                new_layer = layer.__class__.from_config(layer.get_config())
                layer_map[layer] = new_layer
                layer = new_layer
            else:
                # Reuse previously cloned layer
                layer = layer_map[layer]
                if isinstance(layer, InputLayer):
                    continue
            # ... (existing code)

                output_tensors = to_list(
                    layer.compute_mask(computed_tensors, computed_masks))
                # if the output_masks is None, create a list of None values
                if output_tensors and not output_masks:
                    output_masks = [None] * len(output_tensors)
                for x, y, mask in zip(reference_output_tensors, 
                                      output_tensors, 
                                      output_masks):
                    tensor_map[x] = (y, mask)

    # Check that we did compute the model outputs,
    # then instantiate a new model from inputs and outputs
    output_tensors = []
    for x in model.outputs:
        assert x in tensor_map, 'Could not compute output ' + str(x)
        tensor, mask = tensor_map[x]
        output_tensors.append(tensor)
    return Model(input_tensors, output_tensors, name=model.name)
```

In the corrected code, we handle the case where the output masks are None by creating a list of None values if the output_tensors exist. This change ensures that the output masks are correctly handled before updating the `tensor_map`.

This fix should address the issue reported in the GitHub thread and handle the case where the model has multiple outputs without mask support.