The bug in the `_clone_functional_model` function is causing an assertion error in the test case `test_clone_functional_model_with_multi_outputs`. The error message indicates that the function was unable to compute the output for a specific tensor.

The bug seems to be related to the logic for computing the output tensors and the corresponding error is likely due to an issue in the logic for computing output tensors and masks during the cloning process.

One suggestion for fixing the bug is to carefully review the logic for computing output tensors and masks, ensuring that the tensors are correctly mapped and computed.

Here's a corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got {}'.format(type(model)))
    if isinstance(model, Sequential):
        raise ValueError('Expected `model` argument to be a functional `Model` instance, got a `Sequential` instance instead: {}'.format(type(model)))

    if input_tensors is None:
        input_tensors = [Input(batch_shape=layer.batch_input_shape, dtype=layer.dtype, sparse=layer.sparse, name=layer.name) for layer in model._input_layers]

    layer_map = {}  # Cache for created layers.
    tensor_map = {}  # Map {reference_tensor: (corresponding_tensor, mask)}
    for original, cloned in zip(model._input_layers, input_tensors):
        layer_map[original] = cloned
        tensor_map[original.output] = (cloned, None)

    def compute_outputs(node):
        layer = node.outbound_layer
        if layer not in layer_map:
            new_layer = layer.__class__.from_config(layer.get_config())
            layer_map[layer] = new_layer
            layer = new_layer
        else:
            layer = layer_map[layer]
            if isinstance(layer, InputLayer):
                return
        input_tensors = [tensor_map[x][0] for x in node.input_tensors if x in tensor_map]
        if len(input_tensors) == len(node.input_tensors):
            output_tensors = to_list(layer(input_tensors))
            output_tensors = [output_tensors] if not isinstance(output_tensors, list) else output_tensors
            for x, y in zip(node.output_tensors, output_tensors):
                tensor_map[x] = (y, None)

    for depth in sorted(model._nodes_by_depth.keys(), reverse=True):
        for node in model._nodes_by_depth[depth]:
            compute_outputs(node)

    output_tensors = [tensor_map[x][0] for x in model.outputs]
    return Model(input_tensors, output_tensors, name=model.name)
```

In the corrected version, the function iterates over the nodes in the model and calls the `compute_outputs` function to compute the output tensors. Each node's input tensors are checked to ensure they are in the `tensor_map`, and then the output tensors are computed and updated in the `tensor_map`.

This corrected version should pass the failing test case.