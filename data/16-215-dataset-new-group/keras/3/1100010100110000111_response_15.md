The bug in the `_clone_functional_model` function is causing an assertion error during the `clone_model` operation. The bug appears to be related to the handling of layers with multiple outputs and a lack of support for masks in certain layer types such as Lambda.

The cause of the bug is that the function is failing to properly handle layers with multiple outputs when there is no mask support. This is resulting in a failure to compute the model outputs, leading to the assertion error.

To fix the bug, a strategy would be to modify the function to handle layers with multiple outputs without mask support by checking for 'None' values in the output_masks and adapting the behavior accordingly.

Here's the corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (existing code)

    # Check for layers with no mask support and adapt behavior
    for x, y, mask in zip(reference_output_tensors, output_tensors, output_masks):
        if y is not None and x in tensor_map:
            tensor_map[x] = (y, mask)

    # Check that we did compute the model outputs,
    # then instantiate a new model from inputs and outputs.
    output_tensors = []
    for x in model.outputs:
        if x in tensor_map and tensor_map[x][0] is not None:
            tensor, _ = tensor_map[x]
            output_tensors.append(tensor)
        else:
            raise ValueError('Could not compute output ', str(x))

    return Model(input_tensors, output_tensors, name=model.name)
```

In the corrected version, we check for 'None' values in the output_masks and adapt the behavior accordingly when updating the tensor_map. We also handle the cases where the output tensor is not computed properly, raising a ValueError with a meaningful error message.

This corrected version of the function should resolve the issue and pass the failing test.