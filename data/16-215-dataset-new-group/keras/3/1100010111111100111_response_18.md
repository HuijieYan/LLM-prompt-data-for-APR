The bug in the `_clone_functional_model` function is likely causing the failing test. Based on the provided information, the bug seems to stem from the inherited base denoising layer. The failing test is attempting to clone a functional model with multiple outputs and is encountering an error related to computing the output tensors due to the way the `_clone_functional_model` function handles the creation and mapping of new layers and tensors. The assertion failure indicates that the output tensor could not be computed, pointing to a potential issue with the cloning process.

To fix the bug, the `_clone_functional_model` function should be modified to correctly handle the creation and mapping of new layers and tensors, ensuring that the model outputs are properly computed and present in the tensor map.

Here is a corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)
    if isinstance(model, Sequential):
        raise ValueError('Expected `model` argument to be a functional `Model` instance, got a `Sequential` instance instead:', model)

    layer_map = {}
    tensor_map = {}
    if input_tensors is None:
        input_tensors = [Input(batch_shape=(None,)+tensor_shape[1:]) for tensor_shape in model.input_shape]

    for original_input, new_input in zip(model.inputs, input_tensors):
        tensor_map[original_input] = (new_input, None)

    for depth, nodes in model._nodes_by_depth.items():
        for node in nodes:
            layer = node.outbound_layer
            if layer not in layer_map:
                layer_config = layer.get_config()
                cloned_layer = layer.__class__.from_config(layer_config)
                layer_map[layer] = cloned_layer
            else:
                cloned_layer = layer_map[layer]

            reference_input_tensors = node.input_tensors
            reference_output_tensors = node.output_tensors
            computed_data = []
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                kwargs = node.arguments if node.arguments else {}
                computed_tensors = [x[0] for x in computed_data]
                computed_masks = [x[1] for x in computed_data]
                if has_arg(cloned_layer.call, 'mask') and 'mask' not in kwargs:
                    kwargs['mask'] = computed_masks
                output_tensors = cloned_layer(computed_tensors, **kwargs)
                output_masks = cloned_layer.compute_mask(computed_tensors, computed_masks)
                
                if isinstance(output_tensors, list):
                    output_tensors = to_list(output_tensors)
                else:
                    output_tensors = [output_tensors]

                if isinstance(output_masks, list):
                    output_masks = to_list(output_masks)
                else:
                    output_masks = [output_masks]

                for x, y, mask in zip(reference_output_tensors, output_tensors, output_masks):
                    tensor_map[x] = (y, mask)

    output_tensors = [tensor_map[x][0] for x in model.outputs]
    return Model(input_tensors, output_tensors, name=model.name)
```

In this corrected version, the process of cloning layers and mapping tensors is improved to ensure that the model's outputs are properly computed and present in the tensor map, resolving the issue encountered in the failing test. This should allow the `test_clone_functional_model_with_multi_outputs` test to pass without encountering the previous assertion failure.