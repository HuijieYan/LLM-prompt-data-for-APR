The issue here is with the computation of the `output_masks` in the given model. When using `clone_model` for a functional model with a layer that has multiple outputs without mask support (in this case, a Lambda layer), it results in the `output_masks` being set to `None`. This triggers the `AssertionError: Could not compute output` when calling `clone_model`.

To fix this, the code needs to be modified to handle the scenario where the layer does not support masks, such as the Lambda layer in the provided scenario.

Here's the corrected version of the function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (existing function code)

    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # Recover the corresponding layer.
            layer = node.outbound_layer

            # Get or create layer.
            if layer not in layer_map:
                # Clone layer.
                new_layer = layer.__class__.from_config(layer.get_config())
                layer_map[layer] = new_layer
                layer = new_layer
            else:
                # Reuse previously cloned layer.
                layer = layer_map[layer]
                # Don't call InputLayer multiple times.
                if isinstance(layer, InputLayer):
                    continue

            # Gather inputs to call the new layer.
            reference_input_tensors = node.input_tensors
            reference_output_tensors = node.output_tensors

            # If all previous input tensors are available in tensor_map,
            # then call node.inbound_layer on them.
            computed_data = []  # List of tuples (input, mask).
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                # Call layer.
                if node.arguments:
                    kwargs = node.arguments
                else:
                    kwargs = {}
                if len(computed_data) == 1:
                    computed_tensor, computed_mask = computed_data[0]
                    if has_arg(layer.call, 'mask'):
                        if 'mask' not in kwargs:
                            kwargs['mask'] = computed_mask
                    # Update: Check if layer supports masking before calling compute_mask
                    if has_arg(layer, 'mask') and layer.supports_masking:
                        output_masks = to_list(layer.compute_mask(computed_tensor, computed_mask))
                    else:
                        output_masks = [None] * len(reference_output_tensors)
                        
                    output_tensors = to_list(layer(computed_tensor, **kwargs))
                    computed_tensors = [computed_tensor]
                else:
                    computed_tensors = [x[0] for x in computed_data]
                    computed_masks = [x[1] for x in computed_data]
                    if has_arg(layer.call, 'mask'):
                        if 'mask' not in kwargs:
                            kwargs['mask'] = computed_masks
                    # Update: Check if layer supports masking before calling compute_mask
                    if has_arg(layer, 'mask') and layer.supports_masking:
                        output_masks = to_list(layer.compute_mask(computed_tensors, computed_masks))
                    else:
                        output_masks = [None] * len(reference_output_tensors)
                        
                    output_tensors = to_list(layer(computed_tensors, **kwargs))

                # Update tensor_map.
                for x, y, mask in zip(reference_output_tensors, output_tensors, output_masks):
                    tensor_map[x] = (y, mask)

    # ... (existing function code)
```

In the above code correction, we added checks to see if the layer supports masking before calling `compute_mask` and setting the `output_masks` accordingly. If the layer does not support masking, we set the `output_masks` to a list of `None` values. This will prevent the `AssertionError` from occurring when using `clone_model` in a scenario where the layer does not support masks.