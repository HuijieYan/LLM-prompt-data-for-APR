The bug in the `_clone_functional_model` function is causing it to fail when trying to clone a functional model with multiple outputs.

The root cause of the bug is that the `layer_map` dictionary is not being properly populated with the input layers, which leads to the failure to compute the output tensors. This is likely due to an issue in the implementation when creating the input layers and their corresponding placeholders because the code contains an error in the portion of the function that handles input tensors or input layers that do not come directly from a Keras layer.

To fix the bug, the implementation for creating input layers and populating the `layer_map` dictionary needs to be revised. The input tensors or input layers that do not come directly from a Keras layer need to be handled properly and cached in the `layer_map` dictionary.

Here's the corrected version of the function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... [Unchanged code above]

    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)
    if isinstance(model, Sequential):
        raise ValueError('Expected `model` argument to be a functional `Model` instance, got a `Sequential` instance instead:', model)

    layer_map = {}  # Cache for created layers
    tensor_map = {}  # Map {reference_tensor: (corresponding_tensor, mask)}
    
    if input_tensors is None:
        # Create placeholders to build the model on top of
        input_layers = []
        input_tensors = []
        for layer in model._input_layers:
            input_tensor = Input(batch_shape=layer.batch_input_shape,
                                 dtype=layer.dtype,
                                 sparse=layer.sparse,
                                 name=layer.name)
            input_tensors.append(input_tensor)
            # Cache newly created input layer
            input_layer = input_tensor._keras_history[0]
            layer_map[layer] = input_layer
    else:
        # Handle input tensors or input layers that do not come directly from a Keras layer
        input_tensors = to_list(input_tensors)
        for i, x in enumerate(input_tensors):
            if not K.is_keras_tensor(x):
                name = 'input_' + str(i)
                input_tensor = Input(tensor=x, name=name)
                input_tensors[i] = input_tensor
                # Cache newly created input layer
                input_layer = input_tensor._keras_history[0]
                layer_map[model._input_layers[i]] = input_layer

    # Continue with the rest of the function

    # ... [Unchanged code below]
```

By making the above modification, the function should now correctly handle the input tensors or input layers that do not come directly from a Keras layer and populate the `layer_map` dictionary accordingly. This should address the error experienced in the failing test case.

After making the above adjustment, re-run the failing test to ensure that the corrected function resolves the issue. If the test passes after making this change, then the bug has been successfully fixed.