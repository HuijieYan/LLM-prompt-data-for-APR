The bug in the `_clone_functional_model` function appears to be related to incorrect handling of the input tensors during the cloning process, leading to incorrect mappings in the `tensor_map` and failed computations of the model outputs.

Based on the GitHub Issue, it seems that the issue arises when using `clone_model` with a model that has multiple outputs and some of the layers do not support masking.

To fix this issue, the cloning process should correctly handle the input tensors and ensure that the mapping in the `tensor_map` is accurate, especially when dealing with multiple outputs and layers that do not support masking.

Here's the corrected version of the function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (same docstring as the original function)

    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)
    if isinstance(model, Sequential):
        raise ValueError('Expected `model` argument to be a functional `Model` instance, got a `Sequential` instance instead:', model)

    layer_map = {}  # Cache for created layers.
    tensor_map = {}  # Map {reference_tensor: (corresponding_tensor, mask)}
    if input_tensors is None:
        # Create placeholders to build the model on top of.
        input_layers = []
        input_tensors = []
        for layer in model._input_layers:
            input_tensor = Input(batch_shape=layer.batch_input_shape,
                                 dtype=layer.dtype,
                                 sparse=layer.sparse,
                                 name=layer.name)
            input_tensors.append(input_tensor)
            # Cache newly created input layer.
            newly_created_input_layer = input_tensor
            layer_map[layer] = newly_created_input_layer
    else:
        input_tensors = to_list(input_tensors)

    # Rest of the function remains the same
```

In this corrected version:
1. The input tensors are handled correctly, and there's no attempt to create a new layer object with the `._keras_history` attribute.
2. The mapping of the input tensors is simplified and handled correctly based on the input scenario.

This should resolve the issue reported in the GitHub thread.