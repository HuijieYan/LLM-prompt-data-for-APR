The bug in the `_clone_functional_model` function is that it fails to correctly create the newly instantiated `Model` using the provided `Model` instance. The error message indicates that the output tensors are not successfully computed, leading to an `AssertionError` when checking if the model outputs are in the `tensor_map`.

To fix this bug, we need to ensure that the input tensors are properly mapped to the new layers and that the output tensors are correctly computed and added to the `tensor_map`.

Here's the corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)
    if isinstance(model, Sequential):
        raise ValueError('Expected `model` argument to be a functional `Model` instance, got a `Sequential` instance instead:', model)

    layer_map = {}
    tensor_map = {}
    
    if input_tensors is None:
        input_layers = []
        input_tensors = []
        for layer in model._input_layers:
            input_tensor = Input(batch_shape=layer.batch_input_shape,
                                 dtype=layer.dtype,
                                 sparse=layer.sparse,
                                 name=layer.name)
            input_tensors.append(input_tensor)
            layer_map[layer] = input_tensor
    
    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    nodes = model._nodes_by_depth
    for depth in sorted(nodes.keys(), reverse=True):
        for node in nodes[depth]:
            layer = node.outbound_layer

            if layer not in layer_map:
                new_layer = layer.__class__.from_config(layer.get_config())
                layer_map[layer] = new_layer

            reference_input_tensors = node.input_tensors
            reference_output_tensors = node.output_tensors

            computed_data = []
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                kwargs = node.arguments if node.arguments else {}
                computed_tensors = [x[0] for x in computed_data]
                computed_masks = [x[1] for x in computed_data]

                output_tensors = to_list(
                    layer(computed_tensors, **kwargs))
                output_masks = to_list(
                    layer.compute_mask(computed_tensors, computed_masks))

                for x, y, mask in zip(reference_output_tensors, output_tensors, output_masks):
                    tensor_map[x] = (y, mask)

    output_tensors = [tensor_map[x][0] for x in model.outputs]
    return Model(input_tensors, output_tensors, name=model.name)
```

In the corrected version, the `layer_map` is used to store the newly created layers and the `tensor_map` is used to map the input and output tensors. The nodes are iterated over and the input and output tensors are properly computed, ensuring that the model outputs are successfully computed and added to the `tensor_map`.

This corrected version should pass the failing test.