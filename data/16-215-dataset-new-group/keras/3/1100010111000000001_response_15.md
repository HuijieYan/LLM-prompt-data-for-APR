The buggy function `_clone_functional_model` has a bug that causes it to fail when trying to clone a functional model with multiple outputs. The bug is likely in the section where it iterates over every node in the reference model, in depth order, and attempts to clone the layers. The bug causes the cloned model to produce incorrect results when compared to the original model.

The strategy for fixing the bug is to ensure that the cloning process correctly handles models with multiple outputs. The bug may be related to how the references to output tensors are being stored and processed during the cloning procedure.

Here's a corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ' + str(type(model)))

    if isinstance(model, Sequential):
        raise ValueError('Expected `model` argument to be a functional `Model` instance, got a `Sequential` instance instead')

    input_layers = model._input_layers
    input_tensors = input_tensors or [Input(batch_shape=layer.input_shape) for layer in input_layers]

    layers_map = {}
    
    for layer in model.layers:
        layers_map[layer] = layer.__class__.from_config(layer.get_config())  # Clone the layer
    
    for o_node in model.outputs:
        node = model.outbound_nodes.get(o_node._keras_history)
        cloned_node = Node(node.inbound_layers, node.node_indices, node.tensor_indices, node.inbound_tensors, node.output_tensors)
        layers_map[o_node] = cloned_node  # Entry for output layer in map
    
    input_tensors_map = dict(zip(model.inputs, input_tensors))

    # Iterate over every node in the reference model
    for depth, nodes in model._nodes_by_depth.items():

        for node in nodes:
            outbound_layer = node.outbound_layer
            if outbound_layer not in layers_map:
                cloned_layer = Layer.__new__(outbound_layer.__class__)
                cloned_layer.__dict__ = outbound_layer.__dict__.copy() # Clone layer
                layers_map[outbound_layer] = cloned_layer
            else:
                cloned_layer = layers_map[outbound_layer]

            ref_input_tensors = []
            ref_output_tensors = node.output_tensors
            for t in node.input_tensors:
                if t in input_tensors_map:
                    ref_input_tensors.append(input_tensors_map[t])

            if len(ref_input_tensors) == len(node.input_tensors):
                kwargs = node.arguments if node.arguments else {}
                output = cloned_layer(ref_input_tensors, **kwargs)

                for t, o in zip(node.output_tensors, output):
                    layers_map[t] = o

    output_tensors = [layers_map[o_node] for o_node in model.outputs]

    return Model(input_tensors, output_tensors, name=model.name)
```

The corrected version of the function takes into account the multiple outputs of the model and ensures that the cloning process is handled correctly. It addresses the issue of mapping and processing the output tensors during the cloning procedure. This corrected version should pass the failing test provided.