The bug in the `_clone_functional_model` function is causing an error when trying to clone a model with multiple outputs. The error message indicates that the function is failing to compute the output tensor for a specific layer. The GitHub issue also provides insight into the issue, mentioning that the error is related to using a functional model with a layer that has multiple outputs without mask support.

The cause of the bug is related to the usage of mask support in layers without proper handling. The function is failing to handle the case where a layer does not support masks, and as a result, it is unable to compute the output tensors for the model.

To fix the bug, the `_clone_functional_model` function needs to be modified to handle the scenario where a layer does not support masks. This can be achieved by checking if the layer has a mask property, and if not, handling the computation of output tensors accordingly.

Here's the corrected version of the function:

```python
def _clone_functional_model(model, input_tensors=None):
    # (Existing code)

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)

    # (Existing code)

    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # (Existing code)

            computed_data = []
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                if node.arguments:
                    kwargs = node.arguments
                else:
                    kwargs = {}
                
                computed_tensors = [x[0] for x in computed_data]
                if has_arg(layer.call, 'mask'):
                    computed_masks = [x[1] for x in computed_data]
                    kwargs['mask'] = computed_masks
                else:
                    computed_masks = [None] * len(computed_tensors)

                output_tensors = to_list(
                    layer(computed_tensors, **kwargs))

                for x, y, mask in zip(reference_output_tensors,
                                      output_tensors,
                                      computed_masks):
                    tensor_map[x] = (y, mask)

    # (Existing code)

    output_tensors = []
    for x in model.outputs:
        assert x in tensor_map, 'Could not compute output ' + str(x)
        tensor, mask = tensor_map[x]
        output_tensors.append(tensor)
    return Model(input_tensors, output_tensors, name=model.name)
```

In the corrected version, we handle the mask support in layers by checking if the layer has a mask property, and if not, using `None` as the mask. This modification allows the function to compute the output tensors even for layers without mask support.

This fix should address the issue described in the failing test and the GitHub issue.