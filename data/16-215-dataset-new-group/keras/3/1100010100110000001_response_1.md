The main issue with the `_clone_functional_model` function is that it's not correctly handling models that have multiple outputs. The function is failing to correctly compute the model outputs in case of multiple outputs, which is causing the assertion error in the failing test.

The strategy for fixing the bug would be to modify the function to correctly handle models with multiple outputs and ensure that the output tensors are correctly computed and added to the `tensor_map` to avoid the AssertionError.

Here's the corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (other parts of the function remain the same)

    # Iterate over every node in the reference model, in depth order
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # Recover the corresponding layer
            layer = node.outbound_layer

            # Get or create layer
            if layer not in layer_map:
                # Clone layer
                new_layer = layer.__class__.from_config(layer.get_config())
                layer_map[layer] = new_layer
                layer = new_layer
            else:
                # Reuse previously cloned layer
                layer = layer_map[layer]
                # Don't call InputLayer multiple times
                if isinstance(layer, InputLayer):
                    continue

            # Gather inputs to call the new layer
            reference_input_tensors = node.input_tensors
            reference_output_tensors = node.output_tensors

            # If all previous input tensors are available in tensor_map,
            # then call node.inbound_layer on them
            computed_data = []  # List of tuples (input, mask)
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                # Call layer
                if node.arguments:
                    kwargs = node.arguments
                else:
                    kwargs = {}
                computed_tensors = [x[0] for x in computed_data]
                computed_masks = [x[1] for x in computed_data]
                if has_arg(layer.call, 'mask'):
                    if 'mask' not in kwargs:
                        kwargs['mask'] = computed_masks
                output_tensors = to_list(layer(computed_tensors, **kwargs))
                output_masks = to_list(layer.compute_mask(computed_tensors, computed_masks))
                # Update tensor_map
                for x, y, mask in zip(reference_output_tensors, output_tensors, output_masks):
                    tensor_map[x] = (y, mask)

    # Instantiate a new model from inputs and outputs
    output_tensors = [tensor_map[x][0] for x in model.outputs]  # get the output tensors from tensor_map
    output_masks = [tensor_map[x][1] for x in model.outputs] if None in tensor_map.values() else None  # get the output masks
    return Model(input_tensors, output_tensors, name=model.name)
```

This corrected version ensures that the output tensors are correctly computed and added to the `tensor_map`, resolving the AssertionError in the failing test.