The bug in the `_clone_functional_model` function is caused by incorrect behavior when cloning a model with multiple outputs that don't support using masks. This bug leads to the error "Could not compute output Tensor" when using `clone_model`. It seems to be related to the fact that the `Lambda` layer doesn't support using masks, which leads to the `output_masks` being always set to `None`. 

To fix this bug, the code should be updated in the following way:

1. Instead of setting `output_masks` to `None` when the layer doesn't support masks, the clone function should handle the case where `output_masks` is `None` for these layers.

2. Model cloning should support layers with multiple outputs even if they don't support using masks.

Here's the corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (existing implementation for input creation and initializations)
    
    # Iteration over every node in the reference model, in depth order.
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # Recover the corresponding layer.
            layer = node.outbound_layer

            # Get or create layer.
            if layer not in layer_map:
                # Clone layer.
                new_layer = layer.__class__.from_config(layer.get_config())
                layer_map[layer] = new_layer
                layer = new_layer
            else:
                # Reuse previously cloned layer.
                layer = layer_map[layer]
                # Don't call InputLayer multiple times.
                if isinstance(layer, InputLayer):
                    continue

            # Gather inputs to call the new layer.
            reference_input_tensors = node.input_tensors

            # Call layer.
            if node.arguments:
                kwargs = node.arguments
            else:
                kwargs = {}
            output_tensors = to_list(layer(reference_input_tensors, **kwargs))

            # Update tensor_map.
            for x, y in zip(node.output_tensors, output_tensors):
                tensor_map[x] = (y, None)

    # Check that we did compute the model outputs, then instantiate a new model from inputs and outputs.
    output_tensors = []
    for x in model.outputs:
        assert x in tensor_map, 'Could not compute output ' + str(x)
        tensor, _ = tensor_map[x]
        output_tensors.append(tensor)
    return Model(input_tensors, output_tensors, name=model.name)
```

This updated version of the function properly handles layers with multiple outputs and deals with the case where a layer doesn't support using masks. The `output_masks` attribute has been removed from the code, and the function no longer depends on it. This should resolve the issue reported in the GitHub thread and prevent the error from occurring when using `clone_model` with a functional model containing layers that don't support using masks.