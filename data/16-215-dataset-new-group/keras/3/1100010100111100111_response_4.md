The bug in the `_clone_functional_model` function is causing the `AssertionError` when attempting to compute the output tensor. The issue on GitHub provides useful information about the behavior of the failing script and the expected outcome. It also hints at a potential cause of the error related to layers with multiple outputs and a lack of mask support.

The function incorrectly processes multi-output layers and does not handle the case where the layer's `compute_mask` method returns `None`, which then fails the assertion check when computing the output tensors. To address this bug, the code inside the function should be modified to handle multiple outputs and the absence of mask support for certain layers.

To fix the bug, the function should be updated to account for layers with multiple outputs and mask support. This can be achieved by checking the available masks for each output and handling the case where the mask is not available.

Here's the corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (other parts of the function remain unchanged)

    # Iterated over every node in the reference model, in depth order.
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # ... (other parts of the for loop remain unchanged)

            output_tensors = to_list(layer(computed_tensors, **kwargs))
            if isinstance(output_tensors, list):
                for i, output_tensor in enumerate(output_tensors):
                    mask = None if output_masks is None else output_masks[i]
                    tensor_map[reference_output_tensors[i]] = (output_tensor, mask)
            else:
                mask = None if output_masks is None else output_masks
                tensor_map[reference_output_tensors[0]] = (output_tensors, mask)

    # ... (the remaining part of the function remains unchanged)

    return Model(input_tensors, [tensor_map[x][0] for x in model.outputs], name=model.name)
```

In the updated function, after calling the layer, the code now correctly processes the output tensors and masks, handling the case where multiple output tensors are produced. The corrected function also ensures that the tensor map is updated accordingly based on the masks provided by the layer.

This should resolve the issue reported on GitHub and allow the failing test to pass.