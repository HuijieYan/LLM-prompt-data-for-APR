The issue is due to an error inside the `clone_model` method, which is throwing an assertion error "Could not compute output Tensor" when using multi_gpu_model with cpu_relocation=True. This error is being caused by the fact that `output_masks` is always [None] while [None, None] is expected. This issue is occurring specifically when using a functional model with a layer that has multiple outputs without mask support.

The cause of the bug appears to be a problem in handling the output_masks when layers with multiple outputs and no mask support are involved. These issues arise due to the `clone_functional_model` method in the `keras.models` file, specifically at line 157 and 153. So, a solution to this problem would involve modifying the handling of `output_masks` in these lines within the `clone_functional_model` function.

To fix this bug, the handling of output_masks needs to be adjusted in the `clone_functional_model` method. 

Below is the corrected version of the function:

```python
def _clone_functional_model(model, input_tensors=None):
    # existing lines of code

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    # existing lines of code

    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:

            # existing lines of code

            # If all previous input tensors are available in tensor_map,
            # then call node.inbound_layer on them.
            computed_data = []  # List of tuples (input, mask).
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                # Call layer.
                if node.arguments:
                    kwargs = node.arguments
                else:
                    kwargs = {}
                if len(computed_data) == 1:
                    computed_tensor, computed_mask = computed_data[0]
                    if has_arg(layer.call, 'mask'):
                        if 'mask' not in kwargs:
                            if computed_mask is not None:  # Check for mask availability
                                kwargs['mask'] = computed_mask
                    output_tensors = to_list(
                        layer(computed_tensor, **kwargs))
                    # Only handle output masks if available
                    if computed_mask is not None:
                        output_masks = to_list(
                            layer.compute_mask(computed_tensor,
                                               computed_mask))
                    else:
                        output_masks = [None for _ in to_list(output_tensors)]

                    computed_tensors = [computed_tensor]
                    computed_masks = [computed_mask]
                else:
                    computed_tensors = [x[0] for x in computed_data]
                    computed_masks = [x[1] for x in computed_data]
                    if has_arg(layer.call, 'mask'):
                        if 'mask' not in kwargs:
                            if all(mask is not None for mask in computed_masks):  # Check for mask availability
                                kwargs['mask'] = computed_masks
                    output_tensors = to_list(
                        layer(computed_tensors, **kwargs))
                    # Only handle output masks if available
                    if all(mask is not None for mask in computed_masks):
                        output_masks = to_list(
                            layer.compute_mask(computed_tensors,
                                               computed_masks))
                    else:
                        output_masks = [None for _ in to_list(output_tensors)]
                # Update tensor_map.
                for x, y, mask in zip(reference_output_tensors,
                                      output_tensors,
                                      output_masks):
                    tensor_map[x] = (y, mask)

    # existing lines of code
```

In the corrected version, the handling of `output_masks` is adjusted to only process masks if they are not None, and to generate [None] if no masks are available for the output tensors. This should ensure that the `clone_functional_model` method works as expected, resolving the GitHub issue.