The bug in the `_clone_functional_model` function appears to be related to the incorrect handling of multiple outputs in the `clone_model` function. This can be identified from the failing test `test_clone_functional_model_with_multi_outputs` as well as the issue reported on GitHub, where it is mentioned that using a functional model with a layer which has more outputs without mask support can cause the error.

To fix the bug, one strategy would be to modify the `_clone_functional_model` function to properly handle cases where a layer has multiple outputs without mask support.

Here's the corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (the rest of the function remains the same)

    output_masks = [None] * len(reference_output_tensors)

    # If all previous input tensors are available in tensor_map,
    # then call node.inbound_layer on them.
    computed_data = []  # List of tuples (input, mask).
    for x in reference_input_tensors:
        if x in tensor_map:
            computed_data.append(tensor_map[x])

    if len(computed_data) == len(reference_input_tensors):
        # Call layer.
        if node.arguments:
            kwargs = node.arguments
        else:
            kwargs = {}
        if len(computed_data) == 1:
            computed_tensor, computed_mask = computed_data[0]
            if has_arg(layer.call, 'mask') and computed_mask is not None:
                if 'mask' not in kwargs:
                    kwargs['mask'] = computed_mask
            output_tensors = to_list(
                layer(computed_tensor, **kwargs))
            if len(output_masks) == 1 and output_masks[0] is not None:
                output_masks = to_list(
                layer.compute_mask(computed_tensor,
                                   computed_mask))
            computed_tensors = [computed_tensor]
            computed_masks = [computed_mask] if computed_mask is not None else [None]
        else:
            computed_tensors = [x[0] for x in computed_data]
            computed_masks = [x[1] for x in computed_data]
            if has_arg(layer.call, 'mask') and all(mask is not None for mask in computed_masks):
                if 'mask' not in kwargs:
                    kwargs['mask'] = computed_masks
            output_tensors = to_list(
                layer(computed_tensors, **kwargs))
            if all(mask is not None for mask in computed_masks):
                output_masks = to_list(
                layer.compute_mask(computed_tensors,
                                   computed_masks))

    # ... (the rest of the function remains the same)
```

By updating the logic related to handling multiple outputs and masks, this corrected version should address the bug and allow the `clone_model` function to work properly with functional models with multiple outputs. This should resolve the issue reported on GitHub as well.