The bug in the `_clone_functional_model` function results in the incorrect computation of the output tensors, leading to the issue reported on GitHub with the error message "Could not compute output Tensor". The bug occurs when the model has multiple outputs, and a layer without mask support is used. This triggers the creation of output masks with a value of `None`, causing the function to raise an error when it expects a list of output masks.

To fix this bug, the function should be modified to handle layers without mask support correctly, ensuring that the output masks are derived correctly when there are multiple output tensors.

Here's the corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    # Existing code remains unchanged

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    # ... (unchanged code)

    # Check that we did compute the model outputs, then instantiate a new model from inputs and outputs.
    output_tensors = []
    output_masks = []  # Initialize a list to store output masks
    for x in model.outputs:
        assert x in tensor_map, 'Could not compute output ' + str(x)
        tensor, mask = tensor_map[x]  # Retrieve the computed mask
        output_tensors.append(tensor)
        output_masks.append(mask)  # Store the computed mask
    return Model(input_tensors, output_tensors, name=model.name, output_masks)  # Include the list of output masks in the model instantiation
```

In the corrected version, the function now maintains a separate list `output_masks` to store the computed masks for each output tensor. The modified function will be able to handle layers without mask support correctly and prevent the error reported on GitHub.

This fix should address the reported GitHub issue and improve the functionality of the `_clone_functional_model` method.