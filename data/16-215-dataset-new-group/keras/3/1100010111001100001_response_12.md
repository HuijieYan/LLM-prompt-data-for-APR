The bug in the _clone_functional_model lies in the logic for handling the input tensors and input layers when cloning a model. This is causing the failing test to not pass.

The strategy for fixing the bug is to correct the logic for handling input tensors and input layers, ensuring that the new model is cloned accurately.

Here is the corrected version of the _clone_functional_model function:

```python
def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)
    if isinstance(model, Sequential):
        raise ValueError('Expected `model` argument to be a functional `Model` instance, got a `Sequential` instance instead:', model)

    layer_map = {}  
    tensor_map = {} 
    if input_tensors is None:
        input_tensors = [Input(batch_shape=layer.input.shape) for layer in model.layers if isinstance(layer, InputLayer)]
        
    for original, new_input in zip(model.inputs, input_tensors):
        layer_map[original] = new_input
        
    for layer in model.layers:
        if layer not in layer_map:
            new_layer = layer.__class__.from_config(layer.get_config())
            layer_map[layer] = new_layer

    for node in model._nodes_by_depth:
        for connection in node.inbound_layers:
            reference_input_tensors = node.input_tensors
            reference_output_tensors = node.output_tensors
            computed_data = []  
            
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                if node.arguments:
                    kwargs = node.arguments
                else:
                    kwargs = {}
                    
                computed_tensors = [x[0] for x in computed_data]
                
                output_tensors = to_list(layer(computed_tensors, **kwargs))
                tensor_map[node.output] = output_tensors

    output_tensors = [tensor_map[output] for output in model.outputs]
    
    return Model(input_tensors, output_tensors, name=model.name)
```

By correcting the handling of input tensors and input layers, the function should now pass the failing test.