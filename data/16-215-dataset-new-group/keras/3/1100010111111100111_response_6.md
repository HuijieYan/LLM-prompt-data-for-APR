The bug is in the `_clone_functional_model` function which is used to clone a functional `Model` instance. The function should create new layers and weights instead of sharing them with the original model. The bug causes an "AssertionError: Could not compute output Tensor" when using `clone_model()`.

The bug is likely caused by the `reference_output_tensors` where `output_masks` are expected to be `[None, None]`, but the Lambda layer doesn't support masks, so it always returns `None`. This leads to the error message in the failing test.

A strategy for fixing the bug is to modify how the masks are handled in the `_clone_functional_model` function. Since the Lambda layer doesn't support masks, the function needs to handle this case differently.

Here's a corrected version of the function that handles the Lambda layer's lack of mask support:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (other parts of the function remain unchanged)

    for x, y, mask in zip(reference_output_tensors, output_tensors, output_masks):
        if has_arg(layer.call, 'mask'):
            tensor_map[x] = (y, mask)
        else:
            tensor_map[x] = (y, None)

    # ... (remaining code remains unchanged)
```

With this change, the function will handle the Lambda layer's lack of mask support by setting the mask to `None` if the layer doesn't support it.

This should resolve the issue mentioned in the failing test and the corresponding GitHub issue.