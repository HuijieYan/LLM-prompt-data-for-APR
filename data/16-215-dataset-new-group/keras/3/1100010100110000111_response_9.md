### Analysis:
The failing test is expecting the `clone_model` method to work with a model that has multiple outputs, but it's currently failing with an assertion error related to not being able to compute the output tensor during the model cloning process. This is in line with the issue reported on GitHub, where the user encountered a similar error when working with a model with multiple outputs and using the `clone_model` method.

The bug in the `_clone_functional_model` function is likely caused by the handling of multiple output tensors, especially when dealing with layers that have more than one output and do not support masks. This leads to mismatched output masks, causing the assertion error.

### Bug Cause:
The bug is primarily caused by the inability to properly handle layers with multiple outputs and the absence of mask support for those layers. This leads to inaccurate processing of output tensors and masks during the model cloning process.

### Fix Strategy:
To fix this bug, the `_clone_functional_model` function needs to be updated to properly handle layers with multiple outputs, especially those without mask support. This may require re-evaluating the computation of output tensors and masks during the cloning process to ensure accurate replication of the original model's behavior.

### Bug Fix - Updated Function:
```python
def _clone_functional_model(model, input_tensors=None):
    # ... (same function signature and initial checks)

    # # Iterate over every node in the reference model, in depth order.
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            layer = node.outbound_layer

            if layer not in layer_map:
                new_layer = layer.__class__.from_config(layer.get_config())
                layer_map[layer] = new_layer
                layer = new_layer
            else:
                layer = layer_map[layer]
                if isinstance(layer, InputLayer):
                    continue

            reference_input_tensors = node.input_tensors
            reference_output_tensors = node.output_tensors

            computed_data = []
            mask_support = has_arg(layer.call, 'mask')  # Check mask support
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                kwargs = node.arguments if node.arguments else {}

                # Logic to handle multiple outputs and mask support
                computed_tensors = [x[0] for x in computed_data]
                computed_masks = [x[1] for x in computed_data] if mask_support else [None] * len(computed_data)

                if mask_support and 'mask' not in kwargs:
                    kwargs['mask'] = computed_masks

                output_tensors = to_list(layer(computed_tensors, **kwargs))
                output_masks = to_list(layer.compute_mask(computed_tensors, computed_masks)) if mask_support else [None] * len(output_tensors)

                for x, y, mask in zip(reference_output_tensors, output_tensors, output_masks):
                    tensor_map[x] = (y, mask)

    output_tensors = []
    for x in model.outputs:
        assert x in tensor_map, 'Could not compute output ' + str(x)
        tensor, mask = tensor_map[x]
        output_tensors.append(tensor)
    return Model(input_tensors, output_tensors, name=model.name)
```
In the updated function:
1. The mask support for the layer is checked using `has_arg(layer.call, 'mask')`.
2. Proper handling of multiple outputs and their associated masks is added, considering the mask support for the layer to avoid assertion errors.
3. The correct output tensors and associated masks are computed and updated in the `tensor_map`.
4. The final model with new inputs and outputs, using the newly computed tensors, is returned.

This updated function is expected to handle models with multiple outputs and ensure accurate cloning of the original model's behavior, addressing the reported bug.