The buggy function `_clone_functional_model` creates new layers and new weights, instead of sharing the weights of the existing layers when cloning a functional Model instance. However, it fails to correctly handle multiple tensors returned by certain layers, resulting in a "Could not compute output Tensor" error. This issue was reported on GitHub as a bug in the `clone_model` function where the `clone_model` function fails when using `multi_gpu_model` with `cpu_relocation=True` because of a bug inside `clone_model`. The error occurs when a layer returns multiple output tensors without mask support, causing the `output_masks` to be `None` when it should be `[None, None]`. The error is traced back to the way `output_masks` are extracted using the `layer.compute_mask()` method. 

To fix this bug, we can modify the `_clone_functional_model` function to correctly handle layers that return multiple output tensors without mask support. We should update the logic for extracting `output_masks` using the `layer.compute_mask()` method so that it doesn't always return `None` in cases where mask support is not available.

Here is the corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (previous code remains unchanged)

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    # Iterated over every node in the reference model, in depth order.
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # ... (previous code remains unchanged)

            # Call layer and compute output tensors and masks
            output_tensors, output_masks = layer.call(computed_tensors, **kwargs), layer.compute_mask(computed_tensors, computed_masks)

            # Update tensor_map with output tensors and masks
            for x, y, mask in zip(reference_output_tensors, output_tensors, output_masks):
                tensor_map[x] = (y, mask)

    # ... (remaining code remains unchanged)

    return Model(input_tensors, output_tensors, name=model.name)
```

In the corrected version, we use the `layer.call` method to compute the output tensors, and then extract the `output_masks` using the `layer.compute_mask` method. This ensures that the `output_masks` are correctly populated even when mask support is not available.

With this fix, the `clone_model` function should no longer encounter the "Could not compute output Tensor" error when used with `multi_gpu_model` and `cpu_relocation=True`, resolving the issue reported on GitHub.