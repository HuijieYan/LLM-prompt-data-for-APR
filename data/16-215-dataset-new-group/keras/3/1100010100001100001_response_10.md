The bug in the `_clone_functional_model` function is likely caused by incorrect handling of input tensors and input layers when cloning a functional `Model` instance. The function is not correctly creating input layers and input tensors, leading to unexpected behavior and errors.

To fix the bug, we can revise the logic for creating input layers and input tensors, handling the mapping of input tensors, and ensuring that the cloned model's outputs are correctly computed.

Here's the corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got {}'.format(type(model)))

    if isinstance(model, Sequential):
        raise ValueError('Expected `model` argument to be a functional `Model` instance, got a `Sequential` instance instead: {}'.format(type(model)))

    layer_map = {}  # Cache for created layers.
    tensor_map = {}  # Map {reference_tensor: (corresponding_tensor, mask)}
    if input_tensors is None:
        # Create placeholders to build the model on top of.
        input_tensors = [Input(batch_shape=layer.input.shape, dtype=layer.input.dtype) for layer in model._input_layers]
    else:
        # Make sure that all input tensors come from a Keras layer.
        input_tensors = to_list(input_tensors)
        for i, x in enumerate(input_tensors):
            if not K.is_keras_tensor(x):
                raise ValueError('Input tensor at index {} is not a Keras tensor'.format(i))

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    # Iterated over every node in the reference model, in depth order.
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # Recover the corresponding layer.
            layer = node.outbound_layer

            # Get or create layer.
            if layer not in layer_map:
                # Clone layer.
                new_layer = layer.__class__.from_config(layer.get_config())
                layer_map[layer] = new_layer
                layer = new_layer
            else:
                # Reuse previously cloned layer.
                layer = layer_map[layer]
                # Don't call InputLayer multiple times.
                if isinstance(layer, InputLayer):
                    continue

            # Gather inputs to call the new layer.
            reference_input_tensors = node.input_tensors
            reference_output_tensors = node.output_tensors

            # If all previous input tensors are available in tensor_map,
            # then call node.inbound_layer on them.
            computed_data = []  # List of tuples (input, mask).
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                # Call layer.
                if node.arguments:
                    kwargs = node.arguments
                else:
                    kwargs = {}
                computed_tensors, computed_masks = [], []
                for computed_tensor, computed_mask in computed_data:
                    if computed_mask is not None:
                        kwargs['mask'] = computed_mask
                    output_tensors = layer(computed_tensor, **kwargs)
                    computed_tensors.append(computed_tensor)
                    computed_masks.append(computed_mask)
                # Update tensor_map.
                for x, y, mask in zip(reference_output_tensors, output_tensors, computed_masks):
                    tensor_map[x] = (y, mask)

    # Check that we did compute the model outputs,
    # then instantiate a new model from inputs and outputs.
    output_tensors = []
    for x in model.outputs:
        if x not in tensor_map:
            raise ValueError('Could not compute output {}'.format(x))
        tensor, _ = tensor_map[x]
        output_tensors.append(tensor)
    return Model(input_tensors, output_tensors, name=model.name)
```

In this corrected version, we have updated the logic for creating input layers and input tensors, handling the mapping of input tensors, and ensuring that the cloned model's outputs are correctly computed. This should address the issues with input handling and model cloning.

By using the corrected version, we aim to resolve the issues related to the incorrect handling of input layers and input tensors, ensuring that the cloned model is created accurately with the correct inputs and outputs.