The bug in the function `_clone_functional_model` is causing issues when using `clone_model`. The function should create a new model with newly instantiated weights rather than sharing weights from the existing layers. The function is not handling the case when a layer does not support masks, which causes the "Could not compute output Tensor" error when using `clone_model`.

To fix the bug, the function should be modified to ensure that the layers without mask support are handled properly. The function should also handle the case of multiple output tensors correctly.

Here's the corrected version of the function:

```python
def _clone_functional_model(model, input_tensors=None):
    # unchanged code...
    
    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask
        
    # unchanged code...
    
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # unchanged code...
            
            # Gather inputs to call the new layer.
            reference_input_tensors = node.input_tensors
            reference_output_tensors = node.output_tensors

            # If all previous input tensors are available in tensor_map,
            # then call node.inbound_layer on them.
            computed_data = []  # List of tuples (input, mask).
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                # Call layer.
                if node.arguments:
                    kwargs = node.arguments
                else:
                    kwargs = {}
                computed_tensors = [x[0] for x in computed_data]

                # Update tensor_map.
                for x, y in zip(reference_output_tensors, computed_tensors):
                    tensor_map[x] = (y, None)

    # Check that we did compute the model outputs,
    # then instantiate a new model from inputs and outputs.
    output_tensors = [tensor_map[x][0] for x in model.outputs]
    return Model(input_tensors, output_tensors, name=model.name)
```

This version of the function ensures that the layers without mask support are handled properly and also handles the case of multiple output tensors correctly.

This should resolve the issue reported in the GitHub post.