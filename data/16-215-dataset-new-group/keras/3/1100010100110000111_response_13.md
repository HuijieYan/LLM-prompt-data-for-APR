The bug in the `_clone_functional_model` function occurs when the "clone" model has multiple outputs from a layer that doesn't support masks (as indicated by the GitHub issue provided). This causes the cloning process to fail when trying to compute the output masks, resulting in the assertion error during the model clone.

To fix the bug, we need to modify the `_clone_functional_model` function to handle the case of multiple outputs from a layer without mask support, especially when cloning models with layers such as `Lambda` which has multiple outputs and does not support masks.

Here is the corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ' + str(model))

    if isinstance(model, Sequential):
        raise ValueError('Expected `model` argument to be a functional `Model` instance, got a `Sequential` instance instead: ' + str(model))
    
    # Initialize the layer_map and tensor_map
    layer_map = {}
    tensor_map = {}

    if input_tensors is None:
        # Create placeholders to build the model on top of.
        input_tensors = [Input(batch_shape=layer.batch_input_shape, dtype=layer.dtype, sparse=layer.sparse, name=layer.name) for layer in model._input_layers]
    else:
        input_tensors = to_list(input_tensors)
        for i, x in enumerate(input_tensors):
            if not K.is_keras_tensor(x):
                name = model._input_layers[i].name
                input_tensor = Input(tensor=x, name='input_wrapper_for_' + name)
                input_tensors[i] = input_tensor

    for x, y in zip(model._input_layers, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    for depth in range(max(model._nodes_by_depth.keys()), -1, -1):
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            layer = node.outbound_layer
            
            if layer not in layer_map:
                # Clone layer with no mask support
                new_layer = layer.__class__.from_config(layer.get_config())
                layer_map[layer] = new_layer

            reference_input_tensors = node.input_tensors
            reference_output_tensors = node.output_tensors
            
            computed_data = []
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                kwargs = node.arguments if node.arguments else {}
                output_tensors = layer(computed_data[0][0]) if len(computed_data) == 1 else layer([x[0] for x in computed_data])

                output_tensors = to_list(output_tensors)
                for x, y in zip(reference_output_tensors, output_tensors):
                    tensor_map[x] = (y, None)

    output_tensors = [tensor_map[x][0] for x in model.outputs]
    return Model(input_tensors, output_tensors, name=model.name)
```

With this correction, the function will ensure that the cloning process makes use of the correct input tensors and handles multiple outputs from layers that do not support masks. Therefore, the script that previously raised an assertion error should now execute without errors.