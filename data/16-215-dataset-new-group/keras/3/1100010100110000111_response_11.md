## Potential Error Locations
1. The `layer.compute_mask` function call on line 153 may be returning `None` in cases where it's not supposed to, leading to an incorrect assertion failure.

2. The use of `assert` statements for error checking could be leading to false positives.

3. The value of `output_masks` on line 153 may be incorrect due to the absence of mask support for certain layers.

## Cause of the Bug
The issue appears to be related to the `clone_model` function failing with an assertion error due to computation errors while handling multi-output layers. The GitHub issue highlights that the `output_masks` are always `[None]` when `[None, None]` is expected, resulting in the failure of the assert statement on line 166 of the `clone_model` function.

This lack of support for output masks in certain layers, specifically for the `Lambda` layer, is causing the computation of the model outputs to fail.

## Strategy for Fixing the Bug
1. Remove the assert statement and handle the case where computed data and output tensors are not of the expected shape or type.

2. Check for mask support before attempting to compute masks, and handle the case where the layer does not support masks.

3. Implement a more robust error handling mechanism that can handle cases where the output masks might be `None` or unexpected shapes.

### Corrected Version of the Function
```python
def _clone_functional_model(model, input_tensors=None):
    # ... (rest of the function remains the same)
    
    # Iterated over every node in the reference model, in depth order.
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # Recover the corresponding layer.
            layer = node.outbound_layer

            # Get or create layer.
            if layer not in layer_map:
                # Clone layer.
                new_layer = layer.__class__.from_config(layer.get_config())
                layer_map[layer] = new_layer
                layer = new_layer
            else:
                # Reuse previously cloned layer.
                layer = layer_map[layer]
                # Don't call InputLayer multiple times.
                if isinstance(layer, InputLayer):
                    continue

            # Gather inputs to call the new layer.
            reference_input_tensors = node.input_tensors
            reference_output_tensors = node.output_tensors

            # If all previous input tensors are available in tensor_map,
            # then call node.inbound_layer on them.
            computed_data = []  # List of tuples (input, mask).
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                # Call layer.
                if node.arguments:
                    kwargs = node.arguments
                else:
                    kwargs = {}
                if len(computed_data) == 1:
                    computed_tensor, computed_mask = computed_data[0]
                    if has_arg(layer.call, 'mask'):
                        if 'mask' not in kwargs:
                            kwargs['mask'] = computed_mask
                    output_tensors = to_list(
                        layer(computed_tensor, **kwargs))
                    if has_arg(layer, 'compute_mask'):
                        output_masks = to_list(
                            layer.compute_mask(computed_tensor,
                                               computed_mask))
                    else:
                        output_masks = [None] * len(output_tensors)
                    computed_tensors = [computed_tensor]
                    computed_masks = [computed_mask]
                else:
                    computed_tensors = [x[0] for x in computed_data]
                    computed_masks = [x[1] for x in computed_data]
                    if has_arg(layer.call, 'mask'):
                        if 'mask' not in kwargs:
                            kwargs['mask'] = computed_masks
                    output_tensors = to_list(
                        layer(computed_tensors, **kwargs))
                    output_masks = to_list(
                        layer.compute_mask(computed_tensors,
                                           computed_masks))
                # Update tensor_map.
                for x, y, mask in zip(reference_output_tensors,
                                      output_tensors,
                                      output_masks):
                    tensor_map[x] = (y, mask)
                    
    # Instantiate a new model from inputs and outputs.
    output_tensors = []
    for x in model.outputs:
        if x in tensor_map:
            tensor, mask = tensor_map[x]
            output_tensors.append(tensor)
        else:
            # Handle the case where the output tensor is not computed
            raise ValueError('Could not compute output ' + str(x))
            
    return Model(input_tensors, output_tensors, name=model.name)
```

In the corrected version, the assert statement has been replaced with a `ValueError` that handles cases where the output tensor is not computed. Additionally, the code now checks for mask support before computing masks, preventing the assertion error reported in the GitHub issue.