The bug in the `_clone_functional_model` function arises from the incorrect handling of input tensors when the model has multiple inputs and outputs. The error causes the `clone_model` function to fail when called on a model with multiple outputs. The `clone_model` function ultimately relies on the `_clone_functional_model` function, so fixing the issues in the latter function will resolve the problem with the former.

To fix the issue, the handling of input and output tensors needs to be revised. Specifically, the code that creates new layers and input tensors should be modified to properly handle multiple inputs and outputs, as well as handle the issue with masks for outputs from layers that don't support using masks.

Here is a corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)
    if isinstance(model, Sequential):
        raise ValueError('Expected `model` argument to be a functional `Model` instance, got a `Sequential` instance instead:', model)

    layer_map = {}
    tensor_map = {}
    
    # Process input tensors
    if input_tensors is None:
        input_tensors = [Input(batch_shape=layer.batch_input_shape,
                               dtype=layer.dtype,
                               sparse=layer.sparse,
                               name=layer.name) for layer in model._input_layers]
    else:
        input_tensors = to_list(input_tensors)

    for x, input_tensor in zip(model.inputs, input_tensors):
        tensor_map[x] = (input_tensor, None)  # input tensor, mask
    
    # Clone layers and build the model
    output_tensors = []
    for layer in model.layers:
        new_layer = layer.__class__.from_config(layer.get_config())
        layer_map[layer] = new_layer
        for input_node, output_node in zip(layer._inbound_nodes, layer._outbound_nodes):
            input_tensors = [tensor_map[x][0] for x in input_node.input_tensors]
            computed_tensors = new_layer(input_tensors)
            output_tensors.extend(computed_tensors)
            for x, y in zip(output_node.output_tensors, computed_tensors):
                tensor_map[x] = (y, None)  # output tensor, mask

    return Model(input_tensors, output_tensors, name=model.name)
```

This corrected version fixes the issues with handling input tensors and input layers. It also ensures that the output tensors are properly computed and mapped in the `tensor_map` dictionary. By making these changes, the function should now correctly handle models with multiple inputs and outputs.

Once the function is corrected, the `clone_model` function should work properly, resolving the issue reported on GitHub.