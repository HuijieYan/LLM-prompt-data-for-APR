The bug in the `_clone_functional_model` function is related to the incorrect handling of input tensors and output masks when cloning a model. The problem leads to the error "Could not compute output Tensor" when using the `clone_model` function.

The issue is specifically related to a Lambda layer not supporting the use of masks, which causes the `layer.compute_mask` to always return `None`. This results in the `output_masks` being set to `[None]`, which is incorrect when the Lambda layer has multiple outputs.

To fix the bug, the function should be modified to check for layers that do not support masks, and handle the output masks accordingly.

Here's the corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    # existing code...

    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # existing code...

            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                # Call layer.
                if node.arguments:
                    kwargs = node.arguments
                else:
                    kwargs = {}
                if len(computed_data) == 1:
                    computed_tensor, computed_mask = computed_data[0]
                else:
                    computed_tensors = [x[0] for x in computed_data]
                    computed_masks = [x[1] for x in computed_data]

                # Check for layers that do not support masks (e.g., Lambda)
                if hasattr(layer, 'compute_mask') and computed_masks[0] is not None:
                    output_masks = to_list(layer.compute_mask(computed_tensors, computed_masks))
                else:
                    output_masks = [None for _ in computed_tensors]

                # Update tensor_map
                for x, y, mask in zip(reference_output_tensors, output_tensors, output_masks):
                    tensor_map[x] = (y, mask)

    # existing code...

    return Model(input_tensors, output_tensors, name=model.name)
```

This modification ensures that the output masks are correctly handled for layers that do not support masks, such as the Lambda layer in the provided failing test case. The corrected function should now pass the failing test and resolve the issue posted on GitHub.