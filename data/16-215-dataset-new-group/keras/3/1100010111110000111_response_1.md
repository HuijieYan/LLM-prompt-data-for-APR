The bug in the `_clone_functional_model` function is causing it to raise an AssertionError when attempting to compute the output tensor. This is evident from the failing test function, the corresponding error message, and the GitHub issue which provides a similar error situation.

The bug seems to be related to the handling of the layer's output masks. The GitHub issue also mentions that output_masks will always be [None] if the layer does not support masks, which is causing the error.

To fix the bug, we should modify the code to handle the case where the layer does not support masks by checking if the output masks are None and applying appropriate logic.

Here's the corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (existing code)

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    # ... (existing code)

    for x in model.outputs:
        if x in tensor_map and tensor_map[x][1] is not None:
            output_tensors.append(tensor_map[x][0])
        else:
            raise ValueError('Could not compute output ' + str(x))

    return Model(input_tensors, output_tensors, name=model.name)
```

In this corrected version, we check if the output mask is not None before adding it to the output_tensors list. If the mask is none, it will raise a ValueError indicating that the output could not be computed.

With this fix, the `_clone_functional_model` function should pass the failing test and resolve the issue reported on GitHub.