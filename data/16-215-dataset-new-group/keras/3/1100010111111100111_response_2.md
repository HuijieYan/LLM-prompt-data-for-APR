Based on the provided information, it seems that the issue with the `_clone_functional_model` function lies in the part where it computes the outputs of the model. The issue occurs when there are multiple output tensors and the `computed_masks` are `None` due to the Lambda layer not supporting masks. This leads to the assertion error "Could not compute output" when trying to clone the model.

To fix the bug, I would suggest modifying the function to handle cases where the output masks are `None` for layers that do not support masks.

Here's the corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (other parts of the function remain unchanged)

    for x, y, mask in zip(reference_output_tensors, output_tensors, output_masks):
        if mask is not None:
            tensor_map[x] = (y, mask)
        else:
            tensor_map[x] = (y, None)

    # Check that we did compute the model outputs,
    # then instantiate a new model from inputs and outputs.
    output_tensors = []
    for x in model.outputs:
        if x in tensor_map:
            tensor, mask = tensor_map[x]
            output_tensors.append(tensor)
        else:
            raise AssertionError('Could not compute output ' + str(x))
            
    return Model(input_tensors, output_tensors, name=model.name)
```

This revised version of the function specifically handles the case where the output masks are `None`. If the mask is not `None`, it is added to the `tensor_map`. If the mask is `None`, it is still accepted, and the output tensor is added to the `output_tensors`. Finally, at the end of the function, it checks if all the model outputs were computed, and raises an assertion error if any output was not computed.

This solution should address the issue reported in the GitHub bug and ensure that the function works correctly in cases where some layers do not support masks.