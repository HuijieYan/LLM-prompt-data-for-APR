The bug in the `_clone_functional_model` function is causing the `clone_model` method to fail when handling a model with multiple outputs. The buggy function fails to properly create the cloned model when a layer does not support masks.

The bug occurs because the function does not handle layers without mask support, ultimately causing the assertion failure when it tries to compute the output tensors.

To fix this bug, the function needs to be modified to properly handle layers that do not support masks. This can be achieved by updating the logic that deals with layer masks within the function.

Here's the corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected model argument to be a Model instance, got ', model)
    if isinstance(model, Sequential):
        raise ValueError('Expected model argument to be a functional Model instance, got a Sequential instance instead:', model)

    layer_map = {}  # Cache for created layers.
    tensor_map = {}  # Map {reference_tensor: (corresponding_tensor, mask)}
    if input_tensors is None:
        input_layers = []
        input_tensors = []
        for layer in model._input_layers:
            shape = K.int_shape(layer.input)
            input_layer = Input(shape=shape[1:], dtype=layer.dtype, sparse=layer.sparse, name=layer.name)
            input_tensors.append(input_layer)
            layer_map[layer] = input_layer
        for _original, _cloned in zip(model._input_layers, input_tensors):
            layer_map[_original] = _cloned
    else:
        input_tensors = to_list(input_tensors)
        _input_tensors = []
        for i, x in enumerate(input_tensors):
            if not K.is_keras_tensor(x):
                name = model._input_layers[i].name
                input_layer = Input(tensor=x, name='input_wrapper_for_' + name)
                _input_tensors.append(input_layer)
                original_input_layer = x._keras_history[0]
                newly_created_input_layer = input_layer._keras_history[0]
                layer_map[original_input_layer] = newly_created_input_layer
            else:
                _input_tensors.append(x)
        input_tensors = _input_tensors

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)

    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            layer = node.outbound_layer
            if layer not in layer_map:
                new_layer = layer.__class__.from_config(layer.get_config())
                layer_map[layer] = new_layer
                layer = new_layer
            else:
                layer = layer_map[layer]
                if isinstance(layer, InputLayer):
                    continue
            reference_input_tensors = node.input_tensors
            reference_output_tensors = node.output_tensors
            computed_data = [(tensor_map[x] if x in tensor_map else None) for x in reference_input_tensors]
            if all(computed_data):
                computed_tensors, computed_masks = zip(*computed_data)
                if any(computed_masks):
                    computed_masks = list(computed_masks)
                kwargs = node.arguments if node.arguments else {}
                output_tensors = to_list(layer(computed_tensors, **kwargs))
                output_masks = to_list(layer.compute_mask(computed_tensors, computed_masks))
                for x, y, mask in zip(reference_output_tensors, output_tensors, output_masks):
                    tensor_map[x] = (y, mask)

    output_tensors = []
    for x in model.outputs:
        assert x in tensor_map, 'Could not compute output ' + str(x)
        tensor, _ = tensor_map[x]
        output_tensors.append(tensor)
    return Model(input_tensors, output_tensors, name=model.name)
```

With the corrected version, the `_clone_functional_model` function should now properly handle layers that do not support masks, and the `clone_model` method should work as expected for models with multiple outputs. This should resolve the issue reported on GitHub, and the failing test should now pass.