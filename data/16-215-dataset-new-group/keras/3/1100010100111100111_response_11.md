The bug in the `_clone_functional_model` function is likely causing the failing test, as indicated by the assertion error that the model output tensor could not be computed. Based on the provided runtime values, it is likely that the issue is related to the computation of the model's output tensors.

The `clone_model` function is encountering an issue when trying to compute the output tensor of a layer that lacks mask support, resulting in an assertion error. This can be seen in the GitHub issue, where it's mentioned that Lambda layers do not support masks and may cause the error when used in a functional model with multiple outputs.

To solve this bug, the function must be updated to handle layers without mask support when cloning a functional model. This could involve bypassing the mask-related computation and directly handling the output tensors of these layers.

Below is a corrected version of the `_clone_functional_model` function that addresses the issues raised in the failing tests and the GitHub issue:

```python
def _clone_functional_model(model, input_tensors=None):
    # existing code...
    # (No need to change validations at the beginning of the function)

    layer_map = {}  # Cache for created layers.
    tensor_map = {}  # Map {reference_tensor: (corresponding_tensor, mask)}
    if input_tensors is None:
        # existing code...
    else:
        # existing code...

    # existing code...

    # Iterated over every node in the reference model, in depth order.
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # existing code...
            computed_data = []  # List of tuples (input, mask).
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                # Call layer, omitting mask-related computations for layers without mask support
                if node.arguments:
                    args = node.arguments
                else:
                    args = {}
                computed_tensors = [x[0] for x in computed_data]
                output_tensors = layer(computed_tensors, **args)

                # Update tensor_map
                for x, y in zip(reference_output_tensors, output_tensors):
                    tensor_map[x] = (y, None)  # Mask is set to None for layers without mask support

    # Check that we did compute the model outputs,
    # then instantiate a new model from inputs and outputs.
    output_tensors = []
    for x in model.outputs:
        assert x in tensor_map, 'Could not compute output ' + str(x)
        tensor, _ = tensor_map[x]
        output_tensors.append(tensor)
    return Model(input_tensors, output_tensors, name=model.name)
```

In this corrected version, the `lambda`-type layers and other layers lacking mask support are handled appropriately during the computation of output tensors. The mask-related computations are bypassed for these layers, ensuring that the model can be cloned without encountering the mentioned assertion error.