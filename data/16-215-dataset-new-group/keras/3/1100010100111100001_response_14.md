The buggy function `_clone_functional_model` is not properly handling the case when the model has multiple outputs and is failing to clone the model correctly. The error message indicates that the function is unable to compute the output tensor for one of the layers in the model.

To fix the bug, you need to ensure that the function properly handles models with multiple outputs and computes the output tensors correctly.

Here's a corrected version of the function:

```python
def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got', model)
    
    layer_map = {}  # Cache for created layers
    tensor_map = {}  # Map {reference_tensor: (corresponding_tensor, mask)}
    
    for layer in model._input_layers:
        input_tensor = Input(batch_shape=layer.batch_input_shape, dtype=layer.dtype, sparse=layer.sparse, name=layer.name)
        layer_map[layer] = input_tensor
        tensor_map[layer] = (input_tensor, None)  # tensor, mask
    
    if input_tensors is not None:
        for i, x in enumerate(input_tensors):
            if not K.is_keras_tensor(x):
                name = model._input_layers[i].name
                input_tensor = Input(tensor=x, name='input_wrapper_for_' + name)
                layer_map[model._input_layers[i]] = input_tensor
                tensor_map[model._input_layers[i]] = (input_tensor, None)  # tensor, mask
            else:
                tensor_map[model._input_layers[i]] = (x, None)  # tensor, mask
    
    for depth in range(len(model._nodes_by_depth)):
        nodes = model._nodes_by_depth.get(depth, [])
        for node in nodes:
            layer = node.outbound_layer
            if layer not in layer_map:
                new_layer = layer.__class__.from_config(layer.get_config())
                layer_map[layer] = new_layer
            else:
                layer = layer_map[layer]
                if isinstance(layer, InputLayer):
                    continue
    
            reference_input_tensors = node.input_tensors
            computed_tensors = []
            computed_masks = []
            for x in reference_input_tensors:
                computed_data = tensor_map.get(x)
                if computed_data:
                    computed_tensors.append(computed_data[0])
                    computed_masks.append(computed_data[1])
    
            kwargs = node.arguments if node.arguments else {}
            output_tensors = to_list(layer(computed_tensors, **kwargs))
            output_masks = to_list(layer.compute_mask(computed_tensors, computed_masks))
    
            for x, y, mask in zip(node.output_tensors, output_tensors, output_masks):
                tensor_map[x] = (y, mask)
    
    output_tensors = [tensor_map[x][0] for x in model.outputs]
    
    return Model([tensor_map[x][0] for x in model.inputs], output_tensors, name=model.name)
```

This corrected function addresses the issues related to handling multiple output tensors and properly computes the output tensors for the new model. This should resolve the failing test and properly clone the functional model.