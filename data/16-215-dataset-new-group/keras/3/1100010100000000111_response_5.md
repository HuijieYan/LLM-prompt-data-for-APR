The bug in the code seems to be related to the incorrect handling of the output masks when using the `clone_model` function. The GitHub issue provides a specific scenario where the bug is encountered, and it highlights the root cause as the `layer.compute_mask` always returning `None` since `Lambda` doesn't support using masks.

To fix the bug, one approach could be to modify the logic of handling output masks in the `clone_model` function for layers that do not support masks, such as the `Lambda` layer. This can be achieved by checking if the layer supports masks and only calling `layer.compute_mask` if it does.

Here's the corrected version of the `_clone_functional_model` function:

```python
# The relative path of the corrected file: keras/models.py

def _clone_functional_model(model, input_tensors=None):
    # ... rest of the function remains unchanged

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    # ... rest of the function remains unchanged

    # Iterated over every node in the reference model, in depth order.
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # ... rest of the loop remains unchanged

            if len(computed_data) == len(reference_input_tensors):
                # Call layer.
                if node.arguments:
                    kwargs = node.arguments
                else:
                    kwargs = {}
                if len(computed_data) == 1:
                    computed_tensor, computed_mask = computed_data[0]
                    if has_arg(layer.call, 'mask') and hasattr(layer, 'compute_mask'):
                        if 'mask' not in kwargs:
                            kwargs['mask'] = computed_mask
                    output_tensors = to_list(
                        layer(computed_tensor, **kwargs))
                    output_masks = to_list(
                        layer.compute_mask(computed_tensor,
                                           computed_mask)) if hasattr(layer, 'compute_mask') else [None]
                    computed_tensors = [computed_tensor]
                    computed_masks = [computed_mask]
                else:
                    computed_tensors = [x[0] for x in computed_data]
                    computed_masks = [x[1] for x in computed_data]
                    if has_arg(layer.call, 'mask') and hasattr(layer, 'compute_mask'):
                        if 'mask' not in kwargs:
                            kwargs['mask'] = computed_masks
                    output_tensors = to_list(
                        layer(computed_tensors, **kwargs))
                    output_masks = to_list(
                        layer.compute_mask(computed_tensors,
                                           computed_masks)) if hasattr(layer, 'compute_mask') else [None]
                # Update tensor_map.
                for x, y, mask in zip(reference_output_tensors,
                                      output_tensors,
                                      output_masks):
                    tensor_map[x] = (y, mask)

    # ... rest of the function remains unchanged

```

In the corrected version, we've added explicit checks to see if the layer supports masks using the `hasattr(layer, 'compute_mask')`, and only then calling `layer.compute_mask` to calculate the masks for the output tensors. If the layer does not support masks, we set the `output_masks` to `[None]`.

This approach should address the issue where the `Lambda` layer with multiple outputs and no mask support was causing the `clone_model` function to raise the error.