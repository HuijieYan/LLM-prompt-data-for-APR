## Analysis:
The `_clone_functional_model` function is supposed to clone a functional `Model` instance by creating new layers and weights instead of sharing them. However, it contains a bug that causes the output tensors to not be computed correctly in certain cases where multiple outputs are involved. This bug has been reported in the GitHub issue titled 'Could not compute output Tensor' when using `clone_model()`.

The bug seems to be related to the handling of output masks when a layer does not support masks, leading to the computed output masks always being None. This results in the error appearing when using a functional model with a layer that has multiple outputs without mask support.

## Bug Location:
The bug seems to be located in the handling of output masks within the `_clone_functional_model` function.

## Cause of the Bug:
The cause of the bug is related to the `output_masks` being set to None when the layer does not support masks, causing the error when expecting multiple output masks.

## Fix Strategy:
To fix the bug, we can modify the logic for handling output masks to ensure that the correct masks are computed and used when cloning the model.

## The corrected version:

```python
def _clone_functional_model(model, input_tensors=None):
    # <existing code>

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    for depth in range(len(model._nodes_by_depth) - 1, -1, -1):
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # <existing code>

            if len(computed_data) == len(reference_input_tensors):
                # Call layer.
                if node.arguments:
                    kwargs = node.arguments
                else:
                    kwargs = {}

                if len(computed_data) == 1:
                    computed_tensor, computed_mask = computed_data[0]
                    if has_arg(layer.call, 'mask'):
                        if 'mask' not in kwargs:
                            kwargs['mask'] = computed_mask
                    output_tensors = to_list(layer(computed_tensor, **kwargs))
                    computed_tensors = [computed_tensor]
                else:
                    computed_tensors = [x[0] for x in computed_data]
                    computed_masks = [x[1] for x in computed_data]
                    if has_arg(layer.call, 'mask'):
                        if 'mask' not in kwargs:
                            kwargs['mask'] = computed_masks
                    output_tensors = to_list(layer(computed_tensors, **kwargs))

                # Update tensor_map.
                for x, y in zip(reference_output_tensors, output_tensors):
                    tensor_map[x] = (y, None)  # Updated to use None as mask

    # Check that we did compute the model outputs,
    # then instantiate a new model from inputs and outputs.
    output_tensors = []
    for x in model.outputs:
        assert x in tensor_map, 'Could not compute output ' + str(x)
        tensor, _ = tensor_map[x]
        output_tensors.append(tensor)
    return Model(input_tensors, output_tensors, name=model.name)
```

With this corrected version, the bug related to the handling of output masks should be fixed, and the function should now be able to properly compute the output tensors and masks for the cloned model. This should resolve the issue reported on GitHub.