The bug in the `_clone_functional_model` function is causing an error when using the `clone_model` function, as reported in the GitHub issue. The error appears to be related to the handling of masks for layers that do not support masks, such as the `Lambda` layer.

The bug is specifically in the area where it computes the output masks for the cloned layers. It sets the output_masks to `None` for layers that do not support masks, which triggers the assertion error when attempting to compute the model outputs.

To fix the bug, we should modify the code to handle layers that do not support masks by setting the output_masks to an empty list `[]` in those cases.

Here's the corrected version of the `_clone_functional_model` function:

```python
# The relative path of the corrected file: keras/models.py

def _clone_functional_model(model, input_tensors=None):
    # ... (rest of the function remains the same)

    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # ... (rest of the code remains the same)

            # If all previous input tensors are available in tensor_map,
            # then call node.inbound_layer on them.
            computed_data = []  # List of tuples (input, mask).
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                # Call layer.
                if node.arguments:
                    kwargs = node.arguments
                else:
                    kwargs = {}
                if len(computed_data) == 1:
                    computed_tensor, computed_mask = computed_data[0]
                    output_tensors = to_list(
                        layer(computed_tensor, **kwargs))
                    output_masks = to_list(
                        layer.compute_mask(computed_tensor, computed_mask))
                    computed_tensors = [computed_tensor]
                    computed_masks = [computed_mask]
                else:
                    computed_tensors = [x[0] for x in computed_data]
                    computed_masks = [x[1] for x in computed_data]
                    output_tensors = to_list(
                        layer(computed_tensors, **kwargs))
                    output_masks = to_list(
                        layer.compute_mask(computed_tensors, computed_masks))

                # Handling layers that do not support masks
                if output_masks is None:
                    output_masks = []
                
                # Update tensor_map.
                for x, y, mask in zip(reference_output_tensors,
                                      output_tensors,
                                      output_masks):
                    tensor_map[x] = (y, mask)

    # Check that we did compute the model outputs,
    # then instantiate a new model from inputs and outputs.
    output_tensors = []
    for x in model.outputs:
        assert x in tensor_map, 'Could not compute output ' + str(x)
        tensor, _ = tensor_map[x]
        output_tensors.append(tensor)
    
    return Model(input_tensors, output_tensors, name=model.name)
```

This corrected version specifically handles the case where layers do not support masks by setting the `output_masks` to an empty list `[]` when necessary. This should resolve the error reported in the GitHub issue.