The bug in the `_clone_functional_model` function is causing an "AssertionError: Could not compute output Tensor" as reported in the GitHub issue. The issue appears to be related to a model with a layer that has multiple outputs without mask support. It seems that the `Lambda` layer in the failing test does not support masks and always returns a `None` for `output_masks`. This results in the error when using `clone_model`.

To fix the bug, a strategy can be to modify the `_clone_functional_model` function to handle cases where a layer does not support masks. One such approach can be to check if the layer supports masking and, if not, treat it as if it always returns `None` for the mask. This would involve updating the logic around handling input and output tensors under different conditions.

Here's the corrected version of the `_clone_functional_model` function that should resolve the bug:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (existing code)

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    # Iterated over every node in the reference model, in depth order.
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # ... (existing code)

            if len(computed_data) == len(reference_input_tensors):
                # Call layer.
                if node.arguments:
                    kwargs = node.arguments
                else:
                    kwargs = {}
                if len(computed_data) == 1:
                    computed_tensor, computed_mask = computed_data[0]
                    output_tensors = [layer(computed_tensor, **kwargs)]
                    computed_tensors = [computed_tensor]
                else:
                    computed_tensors = [x[0] for x in computed_data]
                    output_tensors = [layer(computed_tensors, **kwargs)]

                # Update tensor_map.
                for x, y in zip(reference_output_tensors, output_tensors):
                    tensor_map[x] = (y, None)  # Treat layers without mask support as always returning None for mask

    # ... (existing code)

    return Model(input_tensors, [t[0] for t in tensor_map.values()], name=model.name)
```
In the corrected version, the `output_masks` are removed in cases where the layer does not support masks. This aligns with the behavior where layers without mask support always return `None` for the mask.

By modifying the logic around handling input and output tensors and considering the mask support for layers, the function should now be able to handle cases where layers do not support masks, which should resolve the bug and make the failing test pass.