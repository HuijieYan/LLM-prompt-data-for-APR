The bug in the `_clone_functional_model` function seems to be related to the way the input layers and tensors are handled for the model cloning process. It is not correctly creating and mapping the input layers and tensors, leading to the failure of the subsequent layers and outputs to be computed properly.

The cause of the bug is likely due to the mishandling of input tensors and layers when creating new models. It seems that the function fails to correctly map the input tensors to the output tensors during model cloning.

To fix this bug, the function needs to be revised to ensure that the input layers and tensors are properly created and mapped, and that the model's output tensors are processed correctly.

Here is a corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)
    if isinstance(model, Sequential):
        raise ValueError('Expected `model` argument to be a functional `Model` instance, got a `Sequential` instance instead:', model)

    if input_tensors is None:
        input_tensors = [Input(batch_shape=layer.input_shape, dtype=layer.dtype) for layer in model.layers if isinstance(layer, InputLayer)]
    
    # Map input layers and tensors
    layer_map = {layer: Input(batch_shape=layer.batch_input_shape, dtype=layer.dtype, name=layer.name) for layer in model._input_layers}
    layer_map.update({layer: layer.__class__.from_config(layer.get_config()) for layer in model.layers if not isinstance(layer, InputLayer)})
    tensor_map = {original: newly_created for original, newly_created in zip(model.inputs, input_tensors)}

    for layer in model.layers:
        if layer not in layer_map:
            new_layer = layer.__class__.from_config(layer.get_config())
            layer_map[layer] = new_layer
    
    for node in model._nodes_by_depth:
        layer = node.outbound_layer
        if layer not in layer_map:
            new_layer = layer.__class__.from_config(layer.get_config())
            layer_map[layer] = new_layer
    
    # Create output tensors
    output_tensors = [layer(tensor_map[x]) for x in model.outputs]
    
    return Model(input_tensors, output_tensors, name=model.name)
```

This revised version should properly handle the input layers and tensors, as well as correctly process the output tensors during model cloning. It ensures that the correct input tensors are created and mapped to the input layers, and that the output tensors are computed based on the input tensors.