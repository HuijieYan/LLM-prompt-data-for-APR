The bug in the `_clone_functional_model` is in the handling of multi-output layers without mask support, which causes the error to appear.

To fix the bug, we should handle the case of multi-output layers without mask support by setting `None` for the output masks.

Here's the corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (same function definition)

    for x in reference_output_tensors:
        if x not in tensor_map:
            tensor_map[x] = (None, None)  # Set output tensor and mask to None for layers without mask support

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    # Iterated over every node in the reference model, in depth order.
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # (same code as before)

    # Check that we did compute the model outputs,
    # then instantiate a new model from inputs and outputs.
    output_tensors = []
    for x in model.outputs:
        tensor, _ = tensor_map[x]  # unpack the tensor and its mask (which may be None)
        assert tensor is not None, 'Could not compute output ' + str(x)  # Check if the tensor is None
        output_tensors.append(tensor)
    return Model(input_tensors, output_tensors, name=model.name)
```

With this fix, the `assert` statement checks if the tensor is `None` and raises an error if it is. We also set the output tensor and mask to `None` for layers without mask support before processing the nodes.

This fix addresses the issue reported on GitHub and updates the function to handle the case of multi-output layers without mask support.