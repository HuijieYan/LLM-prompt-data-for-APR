The bug seems to be related to the `_clone_functional_model` method which is supposed to clone a functional Model instance but is failing to do so. The error message indicates that the output tensor of the model could not be computed.

Upon analyzing the function, it seems that the issue may be related to the handling of layers and input tensors. Additionally, there are several places where the code tries to clone layers and the use of the `tensor_map` may not be handled correctly.

To fix the bug, we need to ensure that the layers and input tensors are handled properly throughout the function. One approach to achieve this is to review the handling of input tensors, layer cloning, and the `tensor_map` to make sure that the output tensors are correctly computed and added to the `tensor_map`.

Here is the corrected version of the function:

```python
def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)
    if isinstance(model, Sequential):
        raise ValueError('Expected `model` argument to be a functional `Model` instance, got a `Sequential` instance instead:', model)

    input_map = {}
    for layer in model._input_layers:
        if input_tensors is None:
            new_input = Input(batch_shape=layer.batch_input_shape, dtype=layer.dtype, sparse=layer.sparse, name=layer.name)
            input_map[layer.name] = new_input

    layers_map = {}
    for layer in model.layers:
        new_layer = layer.__class__.from_config(layer.get_config())
        layers_map[layer.name] = new_layer

    for node in model._nodes_by_depth:
        for layer in model._nodes_by_depth[node]:
            inbound_layers = model._network_nodes[layer]
            if len(inbound_layers) == 0:
                input_tensors = input_map[model._input_layers[0].name]
            else:
                input_tensors = [layers_map[name] for name in inbound_layers]
            
            if len(input_tensors) == 1:
                output_tensors = layers_map[layer.name](input_tensors[0])
            else:
                output_tensors = layers_map[layer.name](input_tensors)
                
            if not isinstance(output_tensors, list):
                output_tensors = [output_tensors]
                
            for i, output in enumerate(output_tensors):
                layers_map[layer.outbound_nodes[i].id] = output

    inputs = [input_map[name] for name in model.input_names]
    outputs = [layers_map[name] for name in model.output_names]
    return Model(inputs, outputs, name=model.name)

```

This corrected version should address the issues with handling layers, input tensors, and output tensors, and it should pass the failing test.