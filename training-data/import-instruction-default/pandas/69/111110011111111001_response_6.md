The issue with the function `_convert_key` seems to be related to the conditional check for whether the index is of integer type or not. The current implementation is raising a `ValueError` if the index type doesn't match the given key, however, it is not able to handle the case where the key itself is of float type even if the index is an integer type. 

To fix this bug, we will update the logic to handle the case where the key is a float while the index is an integer type. We will also incorporate the correct handling for cases where the index is not of integer type.

Here is the corrected code for the `_convert_key` function:

```python
    def _convert_key(self, key, is_setter: bool = False):
        """
        Require they keys to be the same type as the index. (so we don't fallback)
        """
        # allow arbitrary setting
        if is_setter:
            return list(key)

        for ax, i in zip(self.obj.axes, key):
            if ax.is_integer():
                if not (is_integer(i) or is_float(i)):
                    raise ValueError(
                        "At based indexing on an integer index "
                        "can only have integer or float indexers"
                    )
            else:
                if is_integer(i) and not ax.holds_integer():
                    raise ValueError(
                        "At based indexing on an non-integer "
                        "index can only have non-integer "
                        "indexers"
                    )
        return key
```

This corrected function should address the issue by allowing both integer and float keys when the index is of an integer type, and raising appropriate exceptions for other cases. This should resolve the failing tests and error messages provided.