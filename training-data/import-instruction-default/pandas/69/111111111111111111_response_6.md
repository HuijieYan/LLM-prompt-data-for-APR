The issue is occurring in the `_convert_key` function in the `_AtIndexer` class within the file `pandas/core/indexing.py`. The function checks if the key and index types are matching, and if not, it raises a ValueError.

The bug is caused by the incorrect comparison between the axis type and the key type. The function is checking if the key is an integer, but it should be checking if it's numeric. This is causing the ValueError to be incorrectly raised.

To fix the bug, we need to update the comparison logic to check if the key is numeric rather than specifically an integer.

Here's the corrected code for the `_convert_key` function in the `_AtIndexer` class:

```python
# The relative path of the buggy file: pandas/core/indexing.py

# The declaration of the class containing the buggy function
@Appender(IndexingMixin.at.__doc__)
class _AtIndexer(_ScalarAccessIndexer):

    def _convert_key(self, key, is_setter: bool = False):
        """
        Require they keys to be the same type as the index. (so we don't
        fallback)
        """
        # allow arbitrary setting
        if is_setter:
            return list(key)
    
        for ax, i in zip(self.obj.axes, key):
            if ax.is_numeric():
                if not is_numeric_dtype(i):
                    raise ValueError(
                        "At based indexing on a numeric index can only have numeric indexers"
                    )
            else:
                if is_numeric_dtype(i) and not ax.is_numeric():
                    raise ValueError(
                        "At based indexing on a non-numeric index can only have non-numeric indexers"
                    )
        return key
```

This corrected version of the `_convert_key` function should resolve the issue and pass the failing test cases. The comparison now correctly checks for numeric types rather than specifically integer types, which aligns with the expected behavior and resolves the problem identified in the GitHub issue.