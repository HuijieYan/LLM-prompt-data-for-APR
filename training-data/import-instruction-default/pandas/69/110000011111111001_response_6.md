The issue in the function `_convert_key` is that it's not properly handling the case where a key for indexing has a different type than the index. This is causing a ValueError to be raised in the failing test cases because the `key` and the `ax` are of different types (integer vs. float).

The bugs cause is that the function is checking if the index axis is integer using `ax.is_integer()`, but the correct method to use here is `is_numeric_dtype(ax)`. The function also incorrectly checks if the key is an integer using `is_integer(i)`, whereas it should check if it's a float. 

To fix the bug, the code of the `_convert_key` function should be corrected as follows:

```python
def _convert_key(self, key, is_setter: bool = False):
    """
    Require they keys to be the same type as the index. (so we don't
    fallback)
    """
    # allow arbitrary setting
    if is_setter:
        return list(key)

    for ax, i in zip(self.obj.axes, key):
        if is_numeric_dtype(ax):
            if not is_float(i):
                raise ValueError(
                    "At based indexing on a numeric index "
                    "can only have floating point indexers"
                )
        else:
            if is_float(i) and not is_numeric_dtype(ax):
                raise ValueError(
                    "At based indexing on a non-numeric "
                    "index can only have non-numeric "
                    "indexers"
                )
    return key
```

The corrected function uses the `is_numeric_dtype` function to check if the index is numeric and the `is_float` function to check if the indexer is a float. This will handle the cases with floating point or integer indexers correctly.

By using this corrected function, the failing test cases should pass, and it should also match the expected input/output variable information.