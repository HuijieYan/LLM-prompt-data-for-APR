The issue originates from the `_convert_key` function, where it checks if the key is of the same type as the index. It incorrectly checks for integer and non-integer types without considering the float types, leading to the `ValueError` being raised in the failing tests.

The error message specifically states that "At based indexing on a non-integer index can only have non-integer indexers," indicating that the function is not handling float values properly.

The expected variable values show that the function should handle float types correctly for both `DateTimeIndex` and `TimedeltaIndex`.

To fix the bug, we need to modify the `_convert_key` function to handle float types as well, so that it can correctly check for the type of index and key.

Here's the corrected code for the problematic function:

```python
def _convert_key(self, key, is_setter: bool = False):
    """
    Require the keys to be the same type as the index. (so we don't fallback)
    """
    # allow arbitrary setting
    if is_setter:
        return list(key)

    for ax, i in zip(self.obj.axes, key):
        if is_float(i) and not ax.is_numeric():
            raise ValueError(
                "At based indexing on a non-numeric index can only have non-numeric indexers"
            )
        elif is_integer(i) and not ax.is_numeric():
            raise ValueError(
                "At based indexing on a non-numeric index can only have non-numeric indexers"
            )
    return key
```

This corrected code checks for float values using the `is_float` function and then ensures that the index is numeric before allowing float or integer indexers. This change should resolve the issue and pass the failing test cases.

The corrected code satisfies the expected input/output variable information provided and should successfully resolve the issue posted in the GitHub repository.