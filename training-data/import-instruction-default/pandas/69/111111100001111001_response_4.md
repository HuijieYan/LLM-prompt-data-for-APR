The problem is occurring in the `_convert_key` function. It takes a key and checks if it's compatible with the index values. The bug is likely happening in the "for" loop where it checks if the index is an integer. It seems to be checking the index of the axes instead of the type of the index.

To fix this bug, we will modify the function to check the type of the index value instead of the index itself.

Here's the corrected version of the function:

```python
def _convert_key(self, key, is_setter: bool = False):
    """
    Require they keys to be the same type as the index. (so we don't
    fallback)
    """
    # allow arbitrary setting
    if is_setter:
        return list(key)

    for ax, i in zip(self.obj.axes, key):
        if is_numeric_dtype(ax):
            if not is_scalar(i) and not is_list_like(i):
                raise ValueError(
                    "At based indexing on an integer index can only have integer indexers"
                )
        else:
            if not is_numeric_dtype(ax) and (is_sequence(i) or is_iterator(i)):
                raise ValueError(
                    "At based indexing on an non-integer index can only have non-integer indexers"
                )
    return key
```

This corrected code should now handle the cases as expected.