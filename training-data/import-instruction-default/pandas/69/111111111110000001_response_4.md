The `_convert_key` function in the `_AtIndexer` class is intended to handle indexing by converting the key to the same type as the index. The bug seems to be related to handling non-integer indexes. When the code encounters a non-integer index, it is expected to only accept non-integer indexers, but it currently raises a `ValueError` instead.

The bug is located in the `for` loop within the `_convert_key` function, where it checks if `is_integer(i)` and `not ax.holds_integer()`. The intention is to limit integer indexers when `ax` does not hold integer. However, the check is not correctly reflected in the subsequent logic, leading to the incorrect `ValueError` being raised when an non-integer index is encountered.

To fix the bug, we need to refactor the logic within the `for` loop to correctly handle integer and non-integer indexers based on the type of the index. We should also ensure that the function returns a valid key at the end.

Below is the corrected version of the `_convert_key` function:

```python
def _convert_key(self, key, is_setter: bool = False):
    """
    Require the keys to be the same type as the index (so we don't fallback).
    """
    # allow arbitrary setting
    if is_setter:
        return list(key)

    for ax, i in zip(self.obj.axes, key):
        if ax.is_integer():
            if not is_integer(i):
                raise ValueError(
                    "At based indexing on an integer index can only have integer indexers"
                )
        else:
            if is_integer(i) or (ax.holds_integer() and not is_integer(i)):
                raise ValueError(
                    "At based indexing on a non-integer index can only have non-integer indexers"
                )
    return key
```

This corrected code ensures that if an index is non-integer, it only allows non-integer indexers and raises a `ValueError` otherwise.

You can drop this corrected `convert_key` function into the `_AtIndexer` class to fix the bug.