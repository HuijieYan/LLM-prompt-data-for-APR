```python
from typing import List, Tuple
import pandas as pd
import numpy as np
from pandas.core.groupby.groupby import DataError
from pandas.core.frame import DataFrame
from pandas.core.indexes.base import Index
from pandas.core.internals.blocks import Block
from pandas.core.internals.managers import BlockManager

def _cython_agg_blocks(
    self, how: str, alt=None, numeric_only: bool = True, min_count: int = -1
) -> Tuple[List[Block], Index]:
    
    data: BlockManager = self._get_data_to_aggregate()

    if numeric_only:
        data = data.select_dtypes(include='number')

    agg_blocks: List[Block] = []
    new_items: List[np.ndarray] = []
    deleted_items: List[np.ndarray] = []
    split_items: List[np.ndarray] = []
    split_frames: List[DataFrame] = []
    
    for block in data.blocks:
        result = no_result = object()
        locs = block.mgr_locs.as_array
        try:
            result, _ = self.grouper.aggregate(
                block.values, how, axis=1, min_count=min_count
            )
        except NotImplementedError:
            if alt is None:
                if how == "ohlc":
                    deleted_items.append(locs)
                    continue
                else:
                    raise
            obj = self.obj[data.items[locs]]
            if obj.shape[1] == 1:
                obj = obj.iloc[:, 0]
            if alt.__name__ == 'var':
                result = alt(obj)
            else:
                result = alt(obj)
                          
        if not isinstance(result, DataFrame):
            if result is not no_result:
                result = pd.DataFrame(result).T

        if result is not no_result:
            result = result._data.blocks[0].values

        agg_block = block.make_block(result)
        new_items.append(locs)
        agg_blocks.append(agg_block)

    if not (agg_blocks or split_frames):
        raise DataError("No numeric types to aggregate")

    if split_items:
        
        # Clean up the mess left over from split blocks.
        for locs, result in zip(split_items, split_frames):
            assert len(locs) == result.shape[1]
            for i, loc in enumerate(locs):
                new_items.append(np.array([loc], dtype=locs.dtype))
                agg_blocks.append(result.iloc[:, i]._data.blocks[0])

    # reset the locs in the blocks to correspond to our
    # current ordering
    new_items = np.concatenate(new_items)
    agg_items = data.items.take(new_items)

    if deleted_items:
        deleted = np.concatenate(deleted_items)
        ai = np.arange(len(data))
        mask = np.zeros(len(data))
        mask[deleted] = 1
        new_items = (ai - mask.cumsum())[new_items]
        
    for blk in agg_blocks:
        loc = len(blk.mgr_locs)
        blk.mgr_locs = new_items[0:loc]
        new_items = new_items[loc:]
   
    return agg_blocks, agg_items
```