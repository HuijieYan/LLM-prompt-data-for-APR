{
    "pandas": [
        {
            "bugID": 112,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 0,
                "4": 0,
                "5": 0,
                "6": 1,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 0,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 0,
                "4": 0,
                "5": 0,
                "6": 1,
                "7": 0
            },
            "start_line": 907,
            "file_name": "pandas/core/indexes/interval.py",
            "replace_code": "def get_indexer(\n    self,\n    target: ExtensionArray,\n    method: Optional[str] = None,\n    limit: Optional[int] = None,\n    tolerance: Optional[Any] = None,\n) -> np.ndarray:\n    self._check_method(method)\n\n    if self.is_overlapping:\n        msg = (\n            \"cannot handle overlapping indices; use \"\n            \"IntervalIndex.get_indexer_non_unique\"\n        )\n        raise InvalidIndexError(msg)\n\n    target_as_index = ensure_index(target)\n\n    if isinstance(target_as_index, IntervalIndex):\n        # equal indexes -> 1:1 positional match\n        if self.equals(target_as_index):\n            return np.arange(len(self), dtype=\"intp\")\n\n        # different closed or incompatible subtype -> no matches\n        common_subtype = find_common_type(\n            [self.dtype.subtype, target_as_index.dtype.subtype]\n        )\n        if self.closed != target_as_index.closed or is_object_dtype(common_subtype):\n            return np.repeat(np.intp(-1), len(target_as_index))\n\n        # non-overlapping -> at most one match per interval in target_as_index\n        # want exact matches -> need both left/right to match, so defer to\n        # left/right get_indexer, compare elementwise, equality -> match\n        left_indexer = self.left.get_indexer(target_as_index.left)\n        right_indexer = self.right.get_indexer(target_as_index.right)\n        indexer = np.where(left_indexer == right_indexer, left_indexer, -1)\n    elif not is_object_dtype(target_as_index):\n        # homogeneous scalar index: use IntervalTree\n        target_as_index = self._maybe_convert_i8(target_as_index)\n        indexer = self._engine.get_indexer(target_as_index.values)\n    else:\n        # heterogeneous scalar index: defer elementwise to get_loc\n        # (non-overlapping so get_loc guarantees scalar of KeyError)\n        indexer = []\n        for key in target_as_index:\n            try:\n                loc = self.get_loc(key)\n            except KeyError:\n                loc = -1\n            indexer.append(loc)\n\n    return ensure_platform_int(indexer)",
            "import_list": [
                "import textwrap",
                "import numpy as np",
                "from pandas.core.indexes.category import CategoricalIndex",
                "from pandas.core.indexes.interval import IntervalIndex",
                "from pandas.core.indexes.base import ensure_platform_int",
                "from pandas.core.indexers import convert_to_index_sliceable",
                "from pandas.api.types import is_object_dtype",
                "from pandas.core.arrays.base import ExtensionArray",
                "from pandas.core.indexes.base import ensure_index",
                "from pandas.core.indexes.common import InvalidIndexError",
                "from pandas.core.indexes.datetimes import DatetimeIndex",
                "from pandas.core.indexes.timedeltas import TimedeltaIndex",
                "from pandas.core.indexes.numeric import Float64Index, Int64Index, UInt64Index",
                "from pandas.core.arrays.integer import IntegerArray",
                "from pandas.core.indexes.frozen import FrozenList",
                "from pandas.core.indexes.range import RangeIndex",
                "from pandas.core.indexes.multi import MultiIndex",
                "from pandas.core.arrays.masked import BaseMaskedArray",
                "from pandas.core.algorithms import isin",
                "from pandas.core.indexes import DatetimeIndex, ensure_index",
                "from pandas.core.common import ensure_str, is_integer",
                "from pandas.core.na import notna",
                "from pandas.core.indexes.frozen import FrozenList",
                "from pandas.core.indexes.multi import MultiIndex",
                "from pandas.core.indexes.extension import ExtensionIndex",
                "from pandas.core.api import ensure_object",
                "from pandas.core.indexes.base import (Index, _new_Index, _ensure_index,\n                                      _get_codes, _level_index, _ensure_index_from_sequences,\n                                      _ensure_index_from_range, _ensure_index_length, _ensure_index_recursive)",
                "from pandas.io.formats.printing import adjoin, justify, pprint_thing",
                "from pandas.core.indexes.timedeltas import TimedeltaIndex",
                "from pandas.core.indexes.datetimes import DatetimeIndex",
                "from pandas._libs.lib import can_convert_to_arrow, conversion",
                "from pandas.core.algorithms import unique1d",
                "from pandas._libs import tslib",
                "from pandas.core import algorithms",
                "from pandas.core.common import is_list_like, is_timedelta64_ns_dtype, is_datetime64_any_dtype, is_bool_dtype, is_categorical_dtype",
                "from pandas.compat import long",
                "from pandas.core.algorithms import factorize",
                "from pandas.core.generic import NDFrame",
                "from pandas._libs.missing import interpolate_2d",
                "from pandas.core import algorithms",
                "from pandas.io.formats.printing import adjoin",
                "from pandas.core.indexers import check_array_indexer",
                "from pandas._typing import ArrayLike",
                "from pandas.core.indexes.api import ensure_index",
                "from pandas.core.array_algos.masked_reductions import getmask",
                "from pandas.core.groupby import SeriesGroupBy, DataFrameGroupBy",
                "from pandas.io.formats.format import to_str"
            ]
        }
    ]
}