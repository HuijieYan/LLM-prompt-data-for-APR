The issue in the buggy function is that it is not properly checking for overlapping indices and handling the comparison between IntervalIndex objects. 

Here is the corrected version of the buggy function:

```python
@Substitution(
    **dict(
        _index_doc_kwargs,
        **{
            "raises_section": textwrap.dedent(
                """
    Raises
    ------
    NotImplementedError
        If any method argument other than the default of
        None is specified as these are not yet implemented.
    """
            )
        },
    )
)
@Appender(_index_shared_docs["get_indexer"])
def get_indexer(
    self,
    target: AnyArrayLike,
    method: Optional[str] = None,
    limit: Optional[int] = None,
    tolerance: Optional[Any] = None,
) -> np.ndarray:

    self._check_method(method)

    if method is not None:  # Check for method argument other than the default of None
        raise NotImplementedError("Method argument other than None is not yet implemented")

    if self.is_overlapping():  # Call the is_overlapping method to check for overlapping indices
        msg = (
            "cannot handle overlapping indices; use "
            "IntervalIndex.get_indexer_non_unique"
        )
        raise InvalidIndexError(msg)

    target_as_index = ensure_index(target)

    if isinstance(target_as_index, IntervalIndex):
        # Compare the attributes of the IntervalIndex objects for equality
        if self.equals(target_as_index):
            return np.arange(len(self), dtype="intp")
        
        # Handle the case where the indices are not equal
        indexer = np.repeat(np.intp(-1), len(target_as_index))
    elif not is_object_dtype(target_as_index):
        # Handle the case of a homogeneous scalar index using IntervalTree
        target_as_index = self._maybe_convert_i8(target_as_index)
        indexer = self._engine.get_indexer(target_as_index.values)
    else:
        # Handle the case of a heterogeneous scalar index
        indexer = np.array([self.get_loc(key) if key in self else -1 for key in target_as_index], dtype='intp')

    return indexer
```

In this corrected version, I have made the following changes:

1. Added a check for the `method` argument to see if it is `None`. If it is not `None`, raise a NotImplementedError as specified in the docstring.

2. Modified the condition for checking for overlapping indices to call the `is_overlapping()` method and added the parentheses.

3. Improved the comparison and handling of different types of indices by correctly comparing the attributes of IntervalIndex objects for equality and handling the cases of homogeneous scalar index and heterogeneous scalar index.

By making these changes, the function should now handle different cases of input indices and properly handle overlapping indices.