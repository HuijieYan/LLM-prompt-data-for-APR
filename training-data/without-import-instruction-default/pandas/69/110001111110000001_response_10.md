The bug is caused by the function `_convert_key` which is checking if the index is of an integer type and then casting to an integer if the index type is not integer. This is causing it to fail for non-integer values. The failing test is testing lookups for non-integer indices.

To fix the bug, we can modify the `_convert_key` function to handle non-integer values appropriately.

Here's the corrected code for the problematic function:

```python
def _convert_key(self, key, is_setter: bool = False):
    """
    Require the keys to be of the same type as the index. (so we don't
    fallback)
    """
    # allow arbitrary setting
    if is_setter:
        return list(key)

    for ax, i in zip(self.obj.axes, key):
        if ax.is_integer():
            if not isinstance(i, (int, np.int_)):
                raise ValueError(
                    "At based indexing on an integer index "
                    "can only have integer indexers"
                )
        else:
            if isinstance(i, (int, np.int_)) and not ax.holds_integer():
                raise ValueError(
                    "At based indexing on a non-integer "
                    "index can only have non-integer "
                    "indexers"
                )
    return key
```

With this correction, the function should now pass the failing test.