The issue seems to be with the `_convert_key` function in the `_AtIndexer` class in the file pandas/core/indexing.py. This function is supposed to require keys to be the same type as the index, but it is currently raising a ValueError when it encounters non-integer indexers on a non-integer index.

The failing test is related to the `get_value` method of the Float64Index, which is being used with non-integer indexers. The error message indicates that the ValueError is being raised within the `_convert_key` function.

To fix this bug, we need to modify the `_convert_key` function to handle non-integer indexers on a non-integer index in a different way, without raising a ValueError.

One possible approach to fix the bug is to modify the `_convert_key` function to handle non-integer indexers on a non-integer index by casting them to the appropriate type or performing some other transformation. This will allow the function to work correctly with non-integer indexers on a non-integer index without raising a ValueError.

Here's the corrected code for the `_convert_key` function:

```python
def _convert_key(self, key, is_setter: bool = False):
    """
    Require the keys to be the same type as the index.
    """
    # allow arbitrary setting
    if is_setter:
        return list(key)

    for ax, i in zip(self.obj.axes, key):
        if not ax.is_integer() and is_integer(i):
            # Handle non-integer indexers on a non-integer index
            i = float(i)
        elif ax.is_integer() and not is_integer(i):
            raise ValueError(
                "At based indexing on an integer index "
                "can only have integer indexers"
            )
    return key
```

This corrected code should handle non-integer indexers on a non-integer index properly, allowing the failing test to pass and resolving the issue reported on GitHub.