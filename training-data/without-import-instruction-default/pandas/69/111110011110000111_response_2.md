The buggy function is `_convert_key` in the `_AtIndexer` class. This function is throwing a ValueError when it encounters a non-integer index with an integer indexer.

The failing test `test_lookups_datetimelike_values` is using `ser.at[4]`, which is raising a ValueError in the `_convert_key` function.

The GitHub issue title is "BUG: corner cases in DTI.get_value, Float64Index.get_value" and it describes that Series lookups are affected for the Float64Index case.

To fix the bug, we can modify the `_convert_key` function to handle non-integer indexes with integer indexers and vice versa.

Here is the corrected code for the `_convert_key` function:

```python
    def _convert_key(self, key, is_setter: bool = False):
        """
        Require they keys to be the same type as the index. (so we don't
        fallback)
        """
        # allow arbitrary setting
        if is_setter:
            return list(key)

        for ax, i in zip(self.obj.axes, key):
            if ax.is_integer(): 
                if not is_integer(i):
                    raise ValueError(
                        "At based indexing on an integer index "
                        "can only have integer indexers"
                    )
            else:
                if not is_integer(i):
                    raise ValueError(
                        "At based indexing on a non-integer "
                        "index can only have non-integer "
                        "indexers"
                    )
        return key
```

With this correction, the `_convert_key` function will now handle both non-integer indexes with integer indexers and vice versa. This should resolve the ValueError issue and pass the failing test.

This correction also aligns with the GitHub issue, as it addresses the corner cases in `Float64Index.get_value`.