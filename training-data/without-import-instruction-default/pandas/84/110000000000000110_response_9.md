```python
# The corrected version of the buggy function

def _unstack_multiple(data, levels, fill_value=None):
    if len(levels) == 0:
        return data

    # this doesn't deal with hierarchical columns yet
    index = data.index

    rlocs = [i for i in range(index.nlevels) if i not in levels]

    rlevels = [index.levels[i] for i in rlocs]
    rcodes = [index.codes[i] for i in rlocs]
    rnames = [index.names[i] for i in rlocs]

    # everything is in levels, so the dummy df has a regular index
    dummy_index = pd.Index(levels[0], name='__placeholder__')

    if isinstance(data, pd.Series):
        dummy = data.copy()
        dummy.index = dummy_index

        unstacked = dummy.unstack('__placeholder__', fill_value=fill_value)
        new_levels = levels
        new_names = [data.name]
        new_codes = rcodes
    else:
        dummy = data.copy()
        dummy.index = dummy_index

        unstacked = dummy.unstack('__placeholder__', fill_value=fill_value)
        if isinstance(unstacked, pd.Series):
            unstcols = unstacked.index
        else:
            unstcols = unstacked.columns
        new_levels = [unstcols.levels[0]] + levels
        new_names = [data.columns.name] + [level for level in index.names if level in levels]

        new_codes = [unstcols.codes[0]]
        for rec in rcodes:
            new_codes.append(rec.take(unstcols.codes[-1]))
    
    new_columns = pd.MultiIndex(
        levels=new_levels, codes=new_codes, names=new_names, verify_integrity=False
    )

    if isinstance(unstacked, pd.Series):
        unstacked.index = new_columns
    else:
        unstacked.columns = new_columns
        
    return unstacked
```