```python
def _unstack_multiple(data, clocs, fill_value=None):
    if len(clocs) == 0:
        return data

    # NOTE: This doesn't deal with hierarchical columns yet

    index = data.index

    clocs = [index._get_level_number(i) if isinstance(i, tuple) else index._get_level_number([i]) for i in clocs]

    rlocs = [i for i in range(index.nlevels) if i not in clocs]

    clevels = [index.levels[i] for i in clocs]
    ccodes = [index.codes[i] for i in clocs]
    cnames = [index.names[i] for i in clocs]
    rlevels = [index.levels[i] for i in rlocs]
    rcodes = [index.codes[i] for i in rlocs]
    rnames = [index.names[i] for i in rlocs]

    current_idx = np.arange(data.index.size)

    for i in range(len(clocs)):
        idx = current_idx
        val = clocs[i]
        hlevel = index.get_level_values(val)

        codes, level_kinds = coerce_indexer_dtype(idx)
        mask = ~isna(hlevel)._values
        idx = idx[mask]
        if len(level_kinds) == 1 and clocs[0] != val:
            mask = True
        else:
            mask = ~isna(hlevel._view(codes._ndarray_values))._ndarray_values

        idx = idx[mask]
        lev = hlevel._take(indexer=idx)
        idx = get_group_index(lev, sort=False)
        current_idx = idx

    multi_codes = idx
    unstack_index = MultiIndex(
        levels=clevels+[obs_idx],
        codes=ccodes + [multi_codes],
        names=cnames + [None]
    )

    if isinstance(data, Series):
        result.index = unstack_index if unstack else unstack_index.droplevel(-1)
        result = result._constructor(result._values.copy(), index=result.index, name=result.name)
    else:
        return result.unstack(level=ccodes[-1], fill_value=fill_value)

    return unstacked
```