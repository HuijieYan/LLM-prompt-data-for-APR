{
    "pandas": [
        {
            "bugID": 88,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 1,
                "2.1.4": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 1
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 0,
                "4": 0,
                "5": 1,
                "6": 0,
                "7": 1
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 0,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 1
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 0,
                "4": 0,
                "5": 1,
                "6": 0,
                "7": 1
            },
            "start_line": 25,
            "file_name": "pandas/core/reshape/pivot.py",
            "replace_code": "def pivot_table(\n    data,\n    values=None,\n    index=None,\n    columns=None,\n    aggfunc=\"mean\",\n    fill_value=None,\n    margins=False,\n    dropna=True,\n    margins_name=\"All\",\n    observed=False,\n) -> \"DataFrame\":\n    index = _convert_by(index)\n    columns = _convert_by(columns)\n\n    if isinstance(aggfunc, list):\n        pieces: List[DataFrame] = []\n        keys = []\n        for func in aggfunc:\n            table = pivot_table(\n                data,\n                values=values,\n                index=index,\n                columns=columns,\n                fill_value=fill_value,\n                aggfunc=func,\n                margins=margins,\n                dropna=dropna,\n                margins_name=margins_name,\n                observed=observed,\n            )\n            pieces.append(table)\n            keys.append(getattr(func, \"__name__\", func))\n\n        return concat(pieces, keys=keys, axis=1)\n\n    keys = index + columns\n\n    values_passed = values is not None\n    if values_passed:\n        if is_list_like(values):\n            values_multi = True\n            values = list(values)\n        else:\n            values_multi = False\n            values = [values]\n\n        # GH14938 Make sure value labels are in data\n        for i in values:\n            if i not in data:\n                raise KeyError(i)\n\n        to_filter = []\n        for x in keys + values:\n            if isinstance(x, Grouper):\n                x = x.key\n            try:\n                if x in data:\n                    to_filter.append(x)\n            except TypeError:\n                pass\n        if len(to_filter) < len(data.columns):\n            data = data[to_filter]\n\n    else:\n        values = data.columns\n        for key in keys:\n            try:\n                values = values.drop(key)\n            except (TypeError, ValueError, KeyError):\n                pass\n        values = list(values)\n\n    grouped = data.groupby(keys, observed=observed)\n    agged = grouped.agg(aggfunc)\n    if dropna and isinstance(agged, ABCDataFrame) and len(agged.columns):\n        agged = agged.dropna(how=\"all\")\n\n        # gh-21133\n        # we want to down cast if\n        # the original values are ints\n        # as we grouped with a NaN value\n        # and then dropped, coercing to floats\n        for v in values:\n            if (\n                v in data\n                and is_integer_dtype(data[v])\n                and v in agged\n                and not is_integer_dtype(agged[v])\n            ):\n                agged[v] = maybe_downcast_to_dtype(agged[v], data[v].dtype)\n\n    table = agged\n    if table.index.nlevels > 1:\n        # Related GH #17123\n        # If index_names are integers, determine whether the integers refer\n        # to the level position or name.\n        index_names = agged.index.names[: len(index)]\n        to_unstack = []\n        for i in range(len(index), len(keys)):\n            name = agged.index.names[i]\n            if name is None or name in index_names:\n                to_unstack.append(i)\n            else:\n                to_unstack.append(name)\n        table = agged.unstack(to_unstack)\n\n    if not dropna:\n        if table.index.nlevels > 1:\n            m = MultiIndex.from_arrays(\n                cartesian_product(table.index.levels), names=table.index.names\n            )\n            table = table.reindex(m, axis=0)\n\n        if table.columns.nlevels > 1:\n            m = MultiIndex.from_arrays(\n                cartesian_product(table.columns.levels), names=table.columns.names\n            )\n            table = table.reindex(m, axis=1)\n\n    if isinstance(table, ABCDataFrame):\n        table = table.sort_index(axis=1)\n\n    if fill_value is not None:\n        table = table._ensure_type(table.fillna(fill_value, downcast=\"infer\"))\n\n    if margins:\n        if dropna:\n            data = data[data.notna().all(axis=1)]\n        table = _add_margins(\n            table,\n            data,\n            values,\n            rows=index,\n            cols=columns,\n            aggfunc=aggfunc,\n            observed=dropna,\n            margins_name=margins_name,\n            fill_value=fill_value,\n        )\n\n    # discard the top level\n    if (\n        values_passed\n        and not values_multi\n        and not table.empty\n        and (table.columns.nlevels > 1)\n    ):\n        table = table[values[0]]\n\n    if len(index) == 0 and len(columns) > 0:\n        table = table.T\n\n    # GH 15193 Make sure empty columns are removed if dropna=True\n    if isinstance(table, ABCDataFrame) and dropna:\n        table = table.dropna(how=\"all\", axis=1)\n\n    return table",
            "import_list": [
                "import pandas as pd",
                "from pandas import DataFrame, Series, MultiIndex, Index",
                "from pandas.core.groupby.generic import DataFrameGroupBy",
                "from pandas.core.indexes.api import _shallow_copy",
                "from pandas.core.dtypes.cast import maybe_downcast_to_dtype",
                "from pandas.core.dtypes.common import is_integer_dtype",
                "from pandas.core.algorithms import is_list_like, cartesian_product",
                "from pandas.core.common import is_bool, is_bool_indexer",
                "from pandas.core.arrays.categorical import Categorical",
                "from pandas.core.dtypes.generic import ABCDataFrame, ABCSeries, ABCIndexClass, ABCMultiIndex",
                "from pandas.core.groupby.grouper import Grouper",
                "from pandas.tseries.frequencies import to_offset",
                "from pandas.tseries.offsets import DateOffset",
                "from pandas.io.formats.printing import pprint_thing",
                "from pandas.io.formats.printing import pprint_thing",
                "from pandas.tseries.offsets import DateOffset",
                "from decimal import Decimal",
                "from datetime import datetime",
                "from datetime import timedelta",
                "from typing import List",
                "import copy",
                "from textwrap import fill",
                "from numpy import ndarray, array, sort",
                "from pandas.core.frame import DataFrame",
                "from pandas.core.frame import DataFrame",
                "from pandas.core.generic import NDFrame",
                "from pandas.io.formats.printing import pprint_thing",
                "from pandas.tseries.offsets import DateOffset",
                "from numpy import Info",
                "from pandas.core.frame import DataFrame",
                "from pandas.core.generic import NDFrame",
                "from pandas.core.frame import DataFrame",
                "from pandas.core.arrays.categorical import Categorical",
                "from pandas.core.arrays.string_ import StringDtype",
                "from pandas.core.dtypes.common import is_datetimelike",
                "from pandas.core.frame import DataFrame",
                "from pandas.core.indexes.base import Index",
                "from pandas.core.indexers import convert_to_index_sliceable",
                "from pandas.core.indexes.range import RangeIndex",
                "from pandas.core.masking import ensure_str",
                "from pandas.core.series import Series",
                "from pandas.core.strings.accessor import StringMethods",
                "from pandas.core.tools.numeric import to_numeric",
                "from pandas.core.series import Series",
                "from pandas.core.tools.numeric import to_numeric",
                "from pandas.core.generic import NDFrame",
                "from pandas.core.indexes.base import Index",
                "from pandas.core.indexes.range import RangeIndex",
                "from pandas.core.indexes.base import ensure_index",
                "from pandas.core.indexes.range import RangeIndex",
                "from pandas.core.indexes.base import ensure_index",
                "from pandas.core.indexes.datetimes import DatetimeIndex",
                "from pandas.core.indexes.numeric import Int64Index",
                "from pandas.core.series import Series",
                "from pandas.core.series import Series",
                "from pandas.core.internals.blocks import TupleBlock",
                "from pandas.core.internals.concat import _concat_compat",
                "from pandas.core.internals.managers import BlockManager",
                "from pandas.core.window.indexers import BaseIndexer",
                "from pandas.core.arrays import ExtensionArray",
                "from pandas.core.indexes.api import _update_inplace",
                "from pandas.tseries.offsets import DateOffset",
                "from pandas.tseries.offsets import DateOffset",
                "from pandas.tseries.offsets import DateOffset",
                "from numpy import ndarray",
                "from pandas._libs.properties import cache_readonly",
                "from pandas._typing import Label, Level, Dtype",
                "from pandas._libs.properties import cache_readonly",
                "from pandas._typing import Label, Level, Dtype",
                "from pandas.core.frame import DataFrame",
                "from pandas.core.frame import DataFrame",
                "from pandas.core.indexes.base import ensure_index",
                "from pandas.core.indexes.base import ensure_index",
                "from pandas.core.series import Series",
                "from pandas.core.tools.timedeltas import to_timedelta",
                "from pandas.tseries.frequencies import to_offset",
                "from pandas.core.indexes.base import ensure_index",
                "from pandas.core.base import PandasObject",
                "from pandas.util._decorators import Appender, Substitution, cache_readonly",
                "from pandas.core.algorithms import factorize",
                "from pandas.core.sorting import lexsort_indexer",
                "from pandas._libs.properties import cache_readonly",
                "from pandas.core.indexes.extension import ExtensionIndex",
                "from pandas.core.indexes.numeric import Int64Index",
                "from pandas.core.indexes.datetimes import DatetimeIndex",
                "from pandas._libs.properties import cache_readonly",
                "from pandas._typing import Dtype, Label",
                "from pandas.core.indexes.extension import ExtensionIndex",
                "from pandas.core.indexes.numeric import Int64Index"
            ]
        }
    ]
}