The main cause of the bug is that the `pivot_table` function calls itself recursively when `aggfunc` is a list. This leads to incorrect behavior and the wrong return type. 

To fix this bug, we need to remove the recursive call and replace it with a loop to aggregate the data for each `aggfunc`.

Here's the corrected code for the `pivot_table` function:

```python
from pandas.core.reshape.pivot import pivot_table as original_pivot_table

@functools.wraps(original_pivot_table)
def pivot_table(data, values=None, index=None, columns=None, aggfunc="mean", fill_value=None, margins=False, dropna=True, margins_name="All", observed=False) -> "DataFrame":
    if isinstance(aggfunc, list):
        pieces: List[DataFrame] = []
        keys = []
        for func in aggfunc:
            table = original_pivot_table(data, values=values, index=index, columns=columns, fill_value=fill_value, aggfunc=func, margins=margins, dropna=dropna, margins_name=margins_name, observed=observed)
            pieces.append(table)
            keys.append(getattr(func, "__name__", func))

        return concat(pieces, keys=keys, axis=1)

    else:
        return original_pivot_table(data, values=values, index=index, columns=columns, fill_value=fill_value, aggfunc=aggfunc, margins=margins, dropna=dropna, margins_name=margins_name, observed=observed)
```

This corrected version of the `pivot_table` function removes the recursive call when `aggfunc` is a list and instead uses a loop to aggregate the data for each function in the list. This should fix the issue and ensure that the function returns the expected results.

This fix should address the bug and ensure that the function passes the failing test cases.