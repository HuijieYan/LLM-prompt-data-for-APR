```python
import pandas as pd
from pandas.tseries.offsets import CustomBusinessHour
import numpy as np

class BusinessDay:
    def __init__(self, n):
        self.n = n

    def __add__(self, other):
        return other

    def __neg__(self):
        return BusinessDay(-self.n)

    def is_on_offset(self, other):
        return other.day in self.start and other.day in self.end


def apply(self, other):
    if isinstance(other, pd.Timestamp):
        n = self.n
        df = other.to_pydatetime()
        start = self.start
        end = self.end

        proposed = other.time()
        # adjust other to reduce number of cases to handle
        if n >= 0:
            if proposed in end or not is_on_offset(df, start, end):
                other = next_opening_time(df, start, end)
        else:
            if proposed in start:
                other = other - pd.Timedelta(seconds=1)
            if not is_on_offset(df, start, end):
                # Starting from next possible time
                other = next_opening_time(df, start, end)
                other = get_closing_time(other, start, end)  # ????

        # get total business hours
        businesshours = get_business_hours_by_sec(start, end)

        # biz days, remainder
        bd, r = divmod(abs(n * 60), businesshours // 60)
        if n < 0:
            bd, r = -bd, -r
        if bd != 0:
            skip_bd = BusinessDay(n=bd)
            # midnight business hour may not on BusinessDay
            if not is_on_offset(df, start, end):
                prev_open = prev_opening_time(df, start, end)
                remain = other - prev_open
                other = prev_open + skip_bd + remain
            else:
                other = other + skip_bd

        # remaining business hours to adjust
        bhour_remain = pd.Timedelta(minutes=r)

        if n >= 0:
            while bhour_remain != pd.Timedelta(0):
                # business hour left in business time interval
                bhour = (get_closing_time(prev_opening_time(other, start, end), start, end) - other)
                if bhour_remain < bhour:
                    # Overlap
                    other += bhour_remain
                    bhour_remain = pd.Timedelta(0)
                else:
                    # next business time
                    bhour_remain -= bhour
                    other = next_opening_time(other + bhour, start, end)
        else:
            while bhour_remain != pd.Timedelta(0):
                # business hour left in this business time interval
                bhour = next_opening_time(other, start, end) - other
                if bhour_remain > bhour:
                    # overlap
                    other += bhour_remain
                    bhour_remain = pd.Timedelta(0)
                else:
                    # go to next business time interval
                    bhour_remain -= bhour
                    other = get_closing_time(next_opening_time(other + bhour - pd.Timedelta(seconds=1), start, end), start, end)

        return other
    else:
        raise ValueError(f"Only know how to combine business hour with Timestamp")

def is_on_offset(df, start, end):
    return df.time() in start or df.time() in end

def get_business_hours_by_sec(start, end):
    return sum(get_business_hours_by_sec(st, en) for st, en in zip(start, end))

def get_business_hours_by_sec(st, en):
    return int((en - st).total_seconds())

def next_opening_time(df, start, end):
    idx = 0
    for i in enumerate(start):
        if df.time() <= i[1]:
            idx = i[0]
            break
    return pd.Timestamp.combine(df, start[idx])

def get_closing_time(df, start, end):
    idx = 0
    for i in enumerate(end):
        if df.time() <= i[1]:
            idx = i[0]
            break
    return pd.Timestamp.combine(df, end[idx])

def prev_opening_time(df, start, end):
    idx = 1
    for i in enumerate(start):
        if df.time() >= i[1]:
            idx = i[0]
    return pd.Timestamp.combine(df, start[idx - 1])

CustomBusinessHour.apply = apply
```