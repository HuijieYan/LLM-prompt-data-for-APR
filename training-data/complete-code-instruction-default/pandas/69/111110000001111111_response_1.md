The issue seems to be with the type checking in the function `_convert_key`. Based on the given cases and the GitHub issue, it looks like the function is not handling the type checking correctly for the index and key values.

The problem seems to be with the type checking logic in the loop that iterates over the axes and key. It is not handling the cases where the index is a Float64Index or a DatetimeIndex properly. The function is not correctly identifying the types of index and key and raising incorrect value errors.

To fix the bug, we need to modify the type checking logic to properly handle the cases where the index is a Float64Index or a DatetimeIndex and also take into account the type of the key being passed.

Here's the corrected code for the `_convert_key` function:

```python
def _convert_key(self, key, is_setter: bool = False):
    """
    Require they keys to be the same type as the index. (so we don't
    fallback)
    """
    # allow arbitrary setting
    if is_setter:
        return list(key)

    for ax, i in zip(self.obj.axes, key):
        if isinstance(ax, pd.core.indexes.numeric.Float64Index):
            if not isinstance(i, (int, float)):
                raise ValueError(
                    "Float64Index based indexing can only have integer or float indexers"
                )
        elif isinstance(ax, pd.core.indexes.datetimes.DatetimeIndex):
            if not isinstance(i, (pd.Timestamp, pd.Timedelta, str)):
                raise ValueError(
                    "DatetimeIndex based indexing can only have datetime indexers"
                )
        else:
            raise ValueError("Unsupported index type")

    return key
```

This corrected function includes proper type checking for the index and key, as well as handling different types of indexes such as Float64Index and DatetimeIndex. This should address the issue reported on GitHub and also satisfy the expected input/output variable information provided.