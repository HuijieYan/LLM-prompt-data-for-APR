The issue lies in the `_convert_key` function, where it fails to handle cases where the index is of type `float`. In cases where the input `key` value is a float and `ax` is not an integer, the function raises a `ValueError`.

To fix the bug, we need to modify the logic in the `_convert_key` function to handle floating point index values accordingly. This can be done by updating the condition to check if the index value is an integer, and if not, whether it is a float. If the key is a float and axis is not an integer, the function should proceed without raising a ValueError.

Here is the corrected function:

```python
def _convert_key(self, key, is_setter: bool = False):
    """
    Require the keys to be the same type as the index. (so we don't
    fallback)
    """
    # allow arbitrary setting
    if is_setter:
        return list(key)

    for ax, i in zip(self.obj.axes, key):
        if ax.is_integer():
            if not is_integer(i):
                raise ValueError(
                    "At based indexing on an integer index "
                    "can only have integer indexers"
                )
        elif not is_integer(i) and not is_float(i):
            raise ValueError(
                "At based indexing on a non-integer "
                "index can only have non-integer "
                "indexers"
            )
    return key

def is_integer(i):
    return isinstance(i, int)

def is_float(i):
    return isinstance(i, float)
```

With the above fix, the `_convert_key` function will now handle both integer and floating point index values correctly, and the failing tests should pass.