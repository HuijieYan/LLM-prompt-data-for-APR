The bug appears to be caused by incorrect logic in the _convert_key function. The function is attempting to compare the type of the keys with the index, but is using the is_integer method instead of checking the type directly. Additionally, the function does not handle the case of a non-integer value with an integer index correctly.

To fix the bug, we need to modify the _convert_key function to directly check the type of the index and the keys, and handle the non-integer value with an integer index case properly.

Here's the corrected code for the _convert_key function:

```python
def _convert_key(self, key, is_setter: bool = False):
    """
    Require they keys to be the same type as the index. (so we don't
    fallback)
    """
    # allow arbitrary setting
    if is_setter:
        return list(key)

    for ax, i in zip(self.obj.axes, key):
        if isinstance(i, int) and not isinstance(ax, pd.Int64Index):
            raise ValueError(
                "At based indexing on a non-integer index "
                "can only have non-integer indexers"
            )
        if isinstance(i, float) and not isinstance(ax, pd.Float64Index):
            raise ValueError(
                "At based indexing on a non-float index "
                "can only have non-float indexers"
            )
        if isinstance(i, pd.Timestamp) and not isinstance(ax, pd.DatetimeIndex):
            raise ValueError(
                "At based indexing on a non-datetime index "
                "can only have non-datetime indexers"
            )
        if isinstance(i, pd.Timedelta) and not isinstance(ax, pd.TimedeltaIndex):
            raise ValueError(
                "At based indexing on a non-timedelta index "
                "can only have non-timedelta indexers"
            )
    return key
```

This corrected function directly checks the type of the index and the key, and raises a ValueError if the types are incompatible. It also properly handles cases where a non-integer value is used with an integer index. These changes should ensure that the function behaves as expected for all input cases.