```python
import numpy as np
import pandas as pd
from pandas.tseries.frequencies import to_offset
from pandas.tseries.offsets import apply_standard, Nano
from pandas.tseries.frequencies import get_base_alias

def _get_time_bins(self, ax):
    if not isinstance(ax, pd.DatetimeIndex):
        raise TypeError(
            "axis must be a DatetimeIndex, but got "
            f"an instance of {type(ax).__name__}"
        )

    if len(ax) == 0:
        binner = labels = pd.DatetimeIndex(data=[], freq=self.freq, name=ax.name, tz=ax.tz)
        return binner, np.array([]), labels

    first, last = ax.min(), ax.max()
    
    if ax.tz is not None:
        first = first.tz_convert(ax.tz)
        last = last.tz_convert(ax.tz)
    
    first = apply_standard(first, self.freq)
    last = apply_standard(last, self.freq)
    
    binner, bins, labels = self._generate_range(ax, first, last)

    return binner, bins, labels

def _generate_range(self, ax, start, end):
    start = start.normalize()
    end = end + Nano(999_999_999)  # One nanosecond less than next day because freq='D' is closed on the right
    
    binner = labels = pd.date_range(
        start=start, end=end, freq=self.freq, name=ax.name, tz=ax.tz, ambiguous="infer", nonexistent="shift_forward"
    )

    ax_values = ax.to_numpy().astype('datetime64[ns]')
    bin_edges = self._compute_bin_edges(ax_values, binner.freq)
    
    # general version, knowing nothing about relative frequencies
    bins = lib.generate_bins_dt64(
        ax_values, bin_edges, self.closed, hasnans=ax.hasnans
    )

    labels = self._adjust_labels(bins, labels, bin_edges, right=self.label=='right')
    
    return binner, bins, labels

def _compute_bin_edges(self, ax_values, freq):
    if isinstance(freq, to_offset('D')):
        # Ensure edges are computed correctly regardless of whether freq is 'D' or '<Day>'
        freq_alias = get_base_alias(freq)
        freq = to_offset(freq_alias)

    return np.arange(
        np.datetime64(np.nanmin(ax_values, initial=pd.Timedelta('1D')), 'D'),
        np.datetime64(np.nanmax(ax_values, initial=pd.Timedelta('1D')) + np.timedelta64(1, 'ms'), 'D'),
        freq, dtype='datetime64'
    )

def _adjust_labels(self, bins, labels, bin_edges, right):
    if right:
        labels = labels[1:]
        if len(bins) < 2:
            labels = labels[:len(bins)]
    else:
        if len(bins) != len(labels):
            labels = labels[:len(bins)]

    if np.isnan(bins[0]):
        binner = labels.insert(0, np.datetime64('NaT'))
    else:
        binner = labels
        
    return binner, bins, labels
```