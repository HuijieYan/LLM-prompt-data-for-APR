The issue in the `_try_convert_to_date` function is related to the boolean values being incorrectly converted to datetime. The function is trying to convert boolean values into datetime, which is causing the TypeError.

To fix the bug, the function needs to handle boolean values separately and return a Series of booleans instead of trying to convert them to datetime.

Here's the corrected function:

```python
import numpy as np
import pandas as pd

def _try_convert_to_date(self, data):
    """
    Try to parse a ndarray like into a date column.

    Try to coerce object in epoch/iso formats and integer/float in epoch
    formats. Return a boolean if parsing was successful.
    """
    # no conversion on empty
    if not len(data):
        return data, False

    if data.dtype == "object":
        try:
            new_data = pd.to_numeric(data, errors='coerce')
        except (TypeError, ValueError, OverflowError):
            new_data = data
    else:
        new_data = data

    if issubclass(new_data.dtype.type, np.number):
        in_range = (
            np.isnan(new_data)
            | (new_data > self.min_stamp)
        )
        if not in_range.all():
            return data, False
        else:
            return new_data, True
    elif new_data.dtype == 'bool':
        return new_data, False
    else:
        try:
            return pd.to_datetime(new_data, errors="raise", unit=self.date_unit), True
        except (ValueError, OverflowError):
            return data, False
```

This corrected function handles the boolean values separately, and instead of trying to convert them to datetime, it returns the boolean values as is. It also utilizes the `pd.to_numeric` function to convert object types to numeric if possible.

This should fix the issue and ensure that the function returns the expected type and value for the provided test cases, thus resolving the problem reported in the GitHub issue.