The bug in the given function is caused by incorrect handling of the 'new_data' variable. When the 'new_data' variable is modified to an integer type, the subsequent operations such as checking for range and date conversion are not handled correctly.

To fix the bug, we need to ensure that the 'new_data' variable is properly converted to an integer type and then perform the range check and date conversion operations on it.

Here is the corrected code for the problematic function:

```python
import numpy as np
from pandas import isna, iNaT, to_datetime

class Parser():
    def _try_convert_to_date(self, data):
        if not len(data):
            return data, False

        new_data = data
        if new_data.dtype == "object":
            try:
                new_data = data.astype("int64")
            except (TypeError, ValueError, OverflowError):
                pass
        
        if new_data.dtype == "int64":
            in_range = (
                isna(new_data._values)
                | (new_data > self.min_stamp)
                | (new_data._values == iNaT)
            )
            if not in_range.all():
                return new_data, False

            date_units = (self.date_unit,) if self.date_unit else self._STAMP_UNITS
            for date_unit in date_units:
                try:
                    new_data = to_datetime(new_data, errors="raise", unit=date_unit)
                except (ValueError, OverflowError):
                    continue
                return new_data, True
        return data, False
```

The corrected function will now properly handle the conversion of 'new_data' to an integer type and perform the range check and date conversion operations as expected. This should resolve the issues with the failing test cases and satisfy the expected input/output variable values provided.