Potential error location:

The bug may be caused by the inability of the function to handle layers without mask support, resulting in `output_masks` always being `[None]` instead of `[None, None]`.

Bug's cause:

The bug is caused by the incorrect handling of layers without mask support in the `clone_model` function. The function does not properly handle the case where a layer does not support masks, leading to the incorrect `output_masks`.

Approaches to fixing the bug:

1. Modify the function to check if the layer supports masking before attempting to compute the masks.
2. Handle the case where the layer does not support masks by setting the `output_masks` to `[None]` for each output tensor.

Code for the corrected function:

```python
def _clone_functional_model(model, input_tensors=None):
    # [Previous function code]

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    # [Previous function code]

    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # [Previous function code]

            computed_data = []  # List of tuples (input, mask).
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                # Call layer.
                if layer.supports_masking:  # Check if layer supports masking
                    if node.arguments:
                        kwargs = node.arguments
                    else:
                        kwargs = {}
                    if len(computed_data) == 1:
                        computed_tensor, computed_mask = computed_data[0]
                        output_tensors = to_list(
                            layer(computed_tensor, **kwargs))
                    else:
                        computed_tensors = [x[0] for x in computed_data]
                        output_tensors = to_list(
                            layer(computed_tensors, **kwargs))
                    # Update tensor_map.
                    for x, y in zip(reference_output_tensors, output_tensors):
                        tensor_map[x] = (y, None)  # Output masks are set to None

    # Check that we did compute the model outputs,
    # then instantiate a new model from inputs and outputs.
    output_tensors = []
    for x in model.outputs:
        assert x in tensor_map, 'Could not compute output ' + str(x)
        tensor, _ = tensor_map[x]
        output_tensors.append(tensor)
    return Model(input_tensors, output_tensors, name=model.name)
```

This corrected code includes a modification to check if the layer supports masking before attempting to compute the masks. If the layer does not support masking, the output masks are set to `None` for each output tensor. This should fix the issue reported in the GitHub thread.