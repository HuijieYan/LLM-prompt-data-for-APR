```python
def _clone_functional_model(model, input_tensors=None):
    """Clone a functional `Model` instance.

    Model cloning is similar to calling a model on new inputs,
    except that it creates new layers (and thus new weights) instead
    of sharing the weights of the existing layers.

    # Arguments
        model: Instance of `Model`.
        input_tensors: optional list of input tensors
            to build the model upon. If not provided,
            placeholders will be created.

    # Returns
        An instance of `Model` reproducing the behavior
        of the original model, on top of new inputs tensors,
        using newly instantiated weights.

    # Raises
        ValueError: in case of invalid `model` argument value.
    """
    from keras.engine.network import Network
    if not isinstance(model, Network):
        raise ValueError('Expected `model` argument '
                         'to be a `Model` instance, got ', model)
    if model._is_graph_network:
        raise ValueError('Expected `model` argument '
                         'to be a functional `Model` instance, '
                         'got a `Sequential` instance instead:', model)

    # Clean validation and changes from here

    if input_tensors is None:
        input_tensors = [None] * len(model.inputs)

    print('Cloning model.')
    cloned_model = model.__class__.from_config(model.get_config())

    if input_tensors is not None:
	    model_inputs = []
	    for x in input_tensors:
	        if x is None:
	            input_layer = Input(batch_shape=(None,) + (model.input_shape[1:]))
	            model_inputs.append(input_layer)
	        else:
	            if K.is_keras_tensor(x):
	                model_inputs.append(x)
	            else:
	                input_layer = Input(tensor=x)
	                model_inputs.append(input_layer)
	    outputs = cloned_model(model_inputs)
    else:
	    outputs = cloned_model(model.inputs)

    print('Cloned model.')
    return Network(model_inputs, outputs, name='cloned_'+model.name)
```