The bug in the function `_clone_functional_model` seems to be caused by incorrect handling of input tensors and layers when creating a new model instance. The error message indicates that the output tensors of the new model were not computed correctly.

To fix the bug, we need to modify the function to properly handle input tensors and layers when creating the new model instance.

One possible approach to fixing the bug is to rewrite the logic for creating new layers and input tensors to ensure that they are properly mapped and used when computing the output tensors.

Here's the corrected code for the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)

    if isinstance(model, Sequential):
        raise ValueError('Expected `model` argument to be a functional `Model` instance, got a `Sequential` instance instead:', model)

    layer_map = {}  
    tensor_map = {}  
    
    if input_tensors is None:
        input_layers = []
        input_tensors = []
        for layer in model._input_layers:
            input_tensor = Input(batch_shape=layer.batch_input_shape,
                                 dtype=layer.dtype,
                                 sparse=layer.sparse,
                                 name=layer.name)
            input_tensors.append(input_tensor)
            layer_map[layer] = input_tensor

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  
    
    for layer in model.layers:
        new_layer = layer.__class__.from_config(layer.get_config())
        layer_map[layer] = new_layer

    for layer in model.layers:
        inbound_nodes = layer._inbound_nodes
        if not inbound_nodes:
            continue

        for node in inbound_nodes:
            reference_input_tensors = node.input_tensors
            reference_output_tensors = node.output_tensors
            
            computed_data = []  

            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                computed_tensors = [x[0] for x in computed_data]
                computed_masks = [x[1] for x in computed_data]
                kwargs = node.arguments if node.arguments else {}

                if len(computed_tensors) == 1:
                    computed_tensor, computed_mask = computed_data[0]
                    if has_arg(layer.call, 'mask'):
                        if 'mask' not in kwargs:
                            kwargs['mask'] = computed_mask
                    output_tensors = to_list(layer(computed_tensor, **kwargs))
                    output_masks = to_list(layer.compute_mask(computed_tensor, computed_mask))
                else:
                    if has_arg(layer.call, 'mask'):
                        if 'mask' not in kwargs:
                            kwargs['mask'] = computed_masks
                    output_tensors = to_list(layer(computed_tensors, **kwargs))
                    output_masks = to_list(layer.compute_mask(computed_tensors, computed_masks))

                for x, y, mask in zip(reference_output_tensors, output_tensors, output_masks):
                    tensor_map[x] = (y, mask)

    # Instantiate a new model from inputs and outputs.
    output_tensors = [tensor_map[x][0] for x in model.outputs]
    return Model(input_tensors, output_tensors, name=model.name)
```

In this corrected code, we iterate through all the layers and create new layers, updating the `layer_map`. Then, we iterate through the inbound nodes of each layer, compute the output tensors based on the input tensors, and update the `tensor_map`. Finally, we use the `tensor_map` to instantiate the new model from inputs and outputs.

With these modifications, the function should now properly handle input tensors and layers when creating a new model instance, and it should pass the failing test.