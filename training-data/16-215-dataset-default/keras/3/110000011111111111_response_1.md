**Bug Analysis:**

The error occurs when the `clone_model` function is called and the `assert` statement inside the `_clone_functional_model` function fails because it cannot find a computed output tensor in the `tensor_map`. This indicates that the code for computing the output tensors isn't functioning correctly.

The failing test involves a model with multiple inputs and outputs, including a Lambda layer and a custom SwapLayer. The failing test is related to the issue reported on GitHub, where the user encountered a similar error with a Lambda layer and multiple outputs.

The failing execution also provides values for `input_tensors`, `layer_map`, `tensor_map`, and other relevant variables, which can be compared with the code logic to identify discrepancies.

The GitHub issue describes a similar error involving a Lambda layer, indicating that the issue might be related to the handling of layers with multiple outputs and no mask support.

**Bug Cause:**

The cause of the bug is likely related to the handling of layers with multiple outputs and no mask support in the `_clone_functional_model` function. When processing these layers, the logic for computing output tensors and masks is not correctly accounting for layers without mask support, leading to the inability to compute output tensors.

**Approach for Fixing the Bug:**

To fix the bug, the `_clone_functional_model` function needs to be updated to properly handle layers with multiple outputs and no mask support. This may involve revising the logic for computing output tensors and masks to accommodate such layers.

**Corrected Code:**

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (existing function implementation)
    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask
    
    # Iterated over every node in the reference model, in depth order.
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # Recover the corresponding layer.
            layer = node.outbound_layer

            # Get or create layer.
            if layer not in layer_map:
                # Clone layer.
                new_layer = layer.__class__.from_config(layer.get_config())
                layer_map[layer] = new_layer
                layer = new_layer
            else:
                # Reuse previously cloned layer.
                layer = layer_map[layer]
                # Don't call InputLayer multiple times.
                if isinstance(layer, InputLayer):
                    continue

            # Gather inputs to call the new layer.
            reference_input_tensors = node.input_tensors
            reference_output_tensors = node.output_tensors

            computed_data = []
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                # Call layer.
                kwargs = node.arguments if node.arguments else {}
                computed_tensors = [x[0] for x in computed_data]
                if has_arg(layer.call, 'mask') and all(x[1] is not None for x in computed_data):
                    kwargs['mask'] = [x[1] for x in computed_data]

                output_tensors = to_list(layer(computed_tensors, **kwargs))
                output_masks = to_list(layer.compute_mask(computed_tensors, [x[1] for x in computed_data]) if has_arg(layer.call, 'mask') else None)

                for x, y, mask in zip(reference_output_tensors, output_tensors, output_masks):
                    tensor_map[x] = (y, mask)

    output_tensors = [tensor_map[x][0] for x in model.outputs]
    return Model(input_tensors, output_tensors, name=model.name)
```

The corrected code updates the logic for computing output tensors and masks to properly handle layers with multiple outputs and no mask support. Now the function should be able to handle multi-output layers correctly.

With this correction, the `clone_model` function should work as expected and pass the failing test. Additionally, it addresses the issue reported on the GitHub by providing proper handling for layers without mask support.