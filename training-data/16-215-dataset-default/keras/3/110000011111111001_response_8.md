The bug in the function seems to be related to the creation and mapping of input layers and tensors. The failing test is trying to clone a functional model with multiple outputs, and the error message indicates that the function is unable to compute the output tensor.

The issue appears to be with the creation and mapping of input layers and tensors. The function is not correctly handling the input_tensors when they are provided. Additionally, the creation and mapping of input layers and tensors within the function are causing the failure to compute the output tensor.

To fix the bug, the function needs to properly handle the input_tensors when they are provided and ensure that the input layers and tensors are correctly created and mapped.

Here's the corrected code for the problematic function:

```python
def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)
    if isinstance(model, Sequential):
        raise ValueError('Expected `model` argument to be a functional `Model` instance, got a `Sequential` instance instead:', model)

    layer_map = {}  # Cache for created layers.
    tensor_map = {}  # Map {reference_tensor: (corresponding_tensor, mask)}
    input_layers = model._input_layers
    if input_tensors is not None:
        input_tensors = to_list(input_tensors)
        for i, x in enumerate(input_tensors):
            if not K.is_keras_tensor(x):
                name = input_layers[i].name
                input_tensor = Input(tensor=x, name='input_wrapper_for_' + name)
                input_layers[i] = input_tensor
                layer_map[input_layers[i]] = input_tensor
            else:
                layer_map[input_layers[i]] = x

    for x, y in zip(input_layers, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    # Iterated over every node in the reference model, in depth order.
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # Recover the corresponding layer.
            layer = node.outbound_layer

            # Get or create layer.
            if layer not in layer_map:
                # Clone layer.
                new_layer = layer.__class__.from_config(layer.get_config())
                layer_map[layer] = new_layer
            layer = layer_map[layer]

            # Gather inputs to call the new layer.
            reference_input_tensors = node.input_tensors
            reference_output_tensors = node.output_tensors

            # If all previous input tensors are available in tensor_map,
            # then call node.inbound_layer on them.
            computed_data = []  # List of tuples (input, mask).
            for x in reference_input_tensors:
                computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                # Call layer.
                kwargs = node.arguments if node.arguments else {}
                computed_tensors = [x[0] for x in computed_data]
                computed_masks = [x[1] for x in computed_data]
                output_tensors = to_list(layer(computed_tensors, **kwargs))
                output_masks = to_list(layer.compute_mask(computed_tensors, computed_masks))
                # Update tensor_map.
                for x, y, mask in zip(reference_output_tensors, output_tensors, output_masks):
                    tensor_map[x] = (y, mask)

    # Check that we did compute the model outputs,
    # then instantiate a new model from inputs and outputs.
    output_layers = []
    for x in model.outputs:
        assert x in tensor_map, 'Could not compute output ' + str(x)
        tensor, _ = tensor_map[x]
        output_layers.append(tensor)

    return Model(input_layers, output_layers, name=model.name)
```

With these changes, the function should now correctly handle input tensors and map input layers and tensors. This should ensure that the output tensor can be computed successfully and the failing test should pass.