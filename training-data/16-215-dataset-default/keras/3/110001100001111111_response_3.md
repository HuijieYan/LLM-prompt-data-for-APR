The problem seems to be occurring due to the incorrect computation of output masks in the provided `clone_functional_model` function. This is leading to the "Could not compute output Tensor" error when the `clone_model` function is used with `cpu_relocation=True`.

The issue seems to stem from the fact that the `Layer.compute_mask` method is always returning `None` due to the Lambda layer not supporting masks. This in turn causes the `output_masks` to always be `[None]` instead of the expected `[None, None]`. This discrepancy in the output masks leads to the erroneous assertion error at line 157.

To fix this issue, the `clone_functional_model` function needs to be modified to handle the case where the `Layer.compute_mask` method returns `None` due to lack of mask support, and appropriately handle the output masks.

One possible approach to fix the bug is to check if the layer supports masking before attempting to compute masks, and only compute the masks if the layer supports it.

Below is the corrected code for the `clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... Other parts of the function remain unchanged

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    # Iterated over every node in the reference model, in depth order.
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # ... Other parts of the loop remain unchanged

            if has_arg(layer.call, 'mask'):
                # Call layer to compute masks only if it supports masking
                output_masks = to_list(
                    layer.compute_mask(computed_tensors, computed_masks))
            else:
                output_masks = [None] * len(reference_output_tensors)

            # Update tensor_map.
            for x, y, mask in zip(reference_output_tensors, output_tensors, output_masks):
                tensor_map[x] = (y, mask)

    # ... Remaining parts of the function remain unchanged

    return Model(input_tensors, output_tensors, name=model.name)
```

By making the above change, the `clone_functional_model` function will now handle the case where the layer does not support masking, and will correctly compute and handle the output masks. This should resolve the issue reported in the GitHub post and ensure the function works as expected for clone models.