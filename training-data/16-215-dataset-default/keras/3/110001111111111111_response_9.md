The bug in the function `_clone_functional_model` is causing an assertion error when trying to compute the output tensors. The error is occurring because the `output_tensors` are not being properly updated in the `tensor_map`. This is due to the fact that when a layer does not support masking, the `layer.compute_mask` function returns `None`, but the code expects it to be a list with the same length as the input tensors.

To fix the bug, we need to update the `output_tensors` and `output_masks` with `None` if the layer does not support masking. Additionally, we need to handle the case when there is only a single input tensor to the layer.

The corrected version of the function is as follows:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (other parts of the function remain unchanged)

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    # Iterated over every node in the reference model, in depth order.
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # Recover the corresponding layer.
            layer = node.outbound_layer

            if layer not in layer_map:
                new_layer = layer.__class__.from_config(layer.get_config())
                layer_map[layer] = new_layer
                layer = new_layer
            else:
                layer = layer_map[layer]
                if isinstance(layer, InputLayer):
                    continue

            reference_input_tensors = node.input_tensors
            reference_output_tensors = node.output_tensors

            computed_data = []  # List of tuples (input, mask).
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                kwargs = node.arguments if node.arguments else {}
                if len(computed_data) == 1:
                    computed_tensor, computed_mask = computed_data[0]
                    if has_arg(layer.call, 'mask'):
                        kwargs['mask'] = computed_mask
                    output_tensors = to_list(layer(computed_tensor, **kwargs))
                else:
                    computed_tensors = [x[0] for x in computed_data]
                    computed_masks = [x[1] for x in computed_data]
                    if has_arg(layer.call, 'mask'):
                        kwargs['mask'] = computed_masks
                    output_tensors = to_list(layer(computed_tensors, **kwargs))

                for x, y in zip(reference_output_tensors, output_tensors):
                    tensor_map[x] = (y, None)  # Update tensor_map with output_tensors

    output_tensors = [tensor_map[x][0] for x in model.outputs]
    return Model(input_tensors, output_tensors, name=model.name)
```

With these changes, the function should now handle layers without mask support and properly update the `tensor_map` with the output tensors. This corrected version should resolve the assertion error and pass the failing test.

Be sure to test the corrected function with the provided failing test to ensure that it now passes. Once confirmed, it can be submitted as a fix for the GitHub issue.