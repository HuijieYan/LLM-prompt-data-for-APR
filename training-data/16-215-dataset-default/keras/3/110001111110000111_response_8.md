The potential error location within the problematic function is in the section where it checks for computed output masks using the layer.compute_mask method, especially for layers like Lambda which do not support masks.

The bug is caused by the fact that the layer.compute_mask method always returns None for layers like Lambda that do not support masks. This results in the erroneous assertion error 'Could not compute output Tensor'.

To fix the bug, we can modify the code to handle cases where the layer does not support masks by checking for None values in the output_masks list.

Here's the corrected code for the problematic function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (previous code remains the same)

    for depth in reversed(range(len(model._nodes_by_depth))):
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            layer = node.outbound_layer

            if layer not in layer_map:
                new_layer = layer.__class__.from_config(layer.get_config())
                layer_map[layer] = new_layer
                layer = new_layer
            else:
                layer = layer_map[layer]
                if isinstance(layer, InputLayer):
                    continue

            reference_input_tensors = node.input_tensors
            reference_output_tensors = node.output_tensors

            computed_data = []  # List of tuples (input, mask)
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                kwargs = node.arguments if node.arguments else {}

                computed_tensors = [x[0] for x in computed_data]
                computed_masks = [x[1] for x in computed_data]

                output_tensors = to_list(layer(computed_tensors, **kwargs))

                if has_arg(layer.call, 'mask'):
                    if computed_masks and not all(mask is None for mask in computed_masks):
                        kwargs['mask'] = computed_masks
                    output_masks = to_list(layer.compute_mask(computed_tensors, computed_masks))
                else:
                    output_masks = [None] * len(output_tensors)

                for x, y, mask in zip(reference_output_tensors, output_tensors, output_masks):
                    tensor_map[x] = (y, mask)

    output_tensors = []
    for x in model.outputs:
        assert x in tensor_map, 'Could not compute output ' + str(x)
        tensor, mask = tensor_map[x]
        output_tensors.append(tensor)
    return Model([x for x in input_tensors], output_tensors, name=model.name)
```

By making these changes, the corrected function should now pass the failing test, and also resolve the issue posted in the GitHub thread about 'Could not compute output Tensor' error when using clone_model().