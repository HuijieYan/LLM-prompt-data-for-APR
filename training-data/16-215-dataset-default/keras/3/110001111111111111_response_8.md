Based on the error message, failing test, and the input/output variable information, it seems that the issue is caused by the `layer.compute_mask` method always returning `None` due to the Lambda layer not supporting masks. This causes the assertion error when trying to compute the output tensors.

To fix the bug, we need to handle the case where the output_masks are None in the `_clone_functional_model` function. We need to modify the code to not rely on the output_masks when they are not available, and instead handle them appropriately.

Here's the corrected version of the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (other parts of the function remain unchanged)

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    # Iterated over every node in the reference model, in depth order.
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # ... (other parts of the for loop remain unchanged)

            if len(computed_data) == len(reference_input_tensors):
                # Call layer.
                if node.arguments:
                    kwargs = node.arguments
                else:
                    kwargs = {}
                if len(computed_data) == 1:
                    computed_tensor, computed_mask = computed_data[0]
                    if has_arg(layer.call, 'mask'):
                        if 'mask' not in kwargs and computed_mask is not None:
                            kwargs['mask'] = computed_mask
                    output_tensors = to_list(
                        layer(computed_tensor, **kwargs))
                    output_masks = to_list(
                        layer.compute_mask(computed_tensor, computed_mask)) if has_arg(layer.call, 'mask') else [None]
                else:
                    computed_tensors = [x[0] for x in computed_data]
                    computed_masks = [x[1] for x in computed_data]
                    if has_arg(layer.call, 'mask') and all(mask is not None for mask in computed_masks):
                        if 'mask' not in kwargs:
                            kwargs['mask'] = computed_masks
                    output_tensors = to_list(
                        layer(computed_tensors, **kwargs))
                    output_masks = to_list(
                        layer.compute_mask(computed_tensors, computed_masks)) if has_arg(layer.call, 'mask') else [None]
                # Update tensor_map.
                for x, y, mask in zip(reference_output_tensors,
                                      output_tensors,
                                      output_masks):
                    tensor_map[x] = (y, mask)

    # Check that we did compute the model outputs,
    # then instantiate a new model from inputs and outputs.
    output_tensors = []
    for x in model.outputs:
        if x not in tensor_map:
            raise AssertionError('Could not compute output ' + str(x))
        tensor, mask = tensor_map[x]
        output_tensors.append(tensor)
    return Model(input_tensors, output_tensors, name=model.name)
```

In the corrected version, we added additional checks to handle cases where the computed masks are None. We also added conditions to update the output_masks appropriately depending on whether the layer supports masks.

With these changes, the updated function should resolve the issue and pass the failing test. It will also address the problem raised in the GitHub issue.