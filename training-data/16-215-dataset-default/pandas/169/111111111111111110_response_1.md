The issue is due to the empty DataFrame in the `quantile` function. It seems that `self._get_numeric_data()` is returning an empty DataFrame in both test cases. This causes further issues when trying to compute the quantile on an empty DataFrame.

To fix this, you need to handle the case where `self._get_numeric_data()` returns an empty DataFrame by returning an appropriate result without trying to compute the quantile. Here's the corrected version of the `quantile` function:

```python
def quantile(self, q=0.5, axis=0, numeric_only=True, interpolation="linear"):
    """
    Return values at the given quantile over requested axis.
    ...
    """

    self._check_percentile(q)

    data = self._get_numeric_data() if numeric_only else self
    if data.empty:
        return pd.DataFrame() if isinstance(q, list) else pd.Series()

    axis = self._get_axis_number(axis)
    is_transposed = axis == 1

    if is_transposed:
        data = data.T

    result = data._data.quantile(
        qs=q, axis=1, interpolation=interpolation, transposed=is_transposed
    )

    if result.ndim == 2:
        result = self._constructor(result)
    else:
        result = self._constructor_sliced(result, name=q)

    if is_transposed:
        result = result.T

    return result
```

In this corrected version, the function checks if the `data` DataFrame is empty, and if so, returns either an empty DataFrame or an empty Series based on the input `q`. This will prevent the function from trying to compute the quantile on an empty DataFrame, resolving the ValueError raised in the failing tests.