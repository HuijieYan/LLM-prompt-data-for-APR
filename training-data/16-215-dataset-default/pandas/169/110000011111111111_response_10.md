The problem lies in the `_get_numeric_data` method being used to filter the dataframe and possibly removing all columns when dealing with datetime data. This causes the `data` variable to be an empty DataFrame, leading to the `ValueError: need at least one array to concatenate` error.

To fix this issue, the `_get_numeric_data` method should be improved to handle datetime data appropriately and not remove all columns. Additionally, in the `quantile` method, the logic to check for `numeric_only` should also be revised to handle both numeric and datetime data properly.

Lastly, the corrected version of the `quantile` function is provided below:

```python
def quantile(self, q=0.5, axis=0, numeric_only=True, interpolation="linear"):
    """
    Return values at the given quantile over requested axis.

    Parameters
    ----------
    q : float or array-like, default 0.5 (50% quantile)
        Value between 0 <= q <= 1, the quantile(s) to compute.
    axis : {0, 1, 'index', 'columns'} (default 0)
        Equals 0 or 'index' for row-wise, 1 or 'columns' for column-wise.
    numeric_only : bool, default True
        If False, the quantile of datetime and timedelta data will be
        computed as well.
    interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}
        This optional parameter specifies the interpolation method to use,
        when the desired quantile lies between two data points `i` and `j`:
  
        * linear: `i + (j - i) * fraction`, where `fraction` is the
          fractional part of the index surrounded by `i` and `j`.
        * lower: `i`.
        * higher: `j`.
        * nearest: `i` or `j` whichever is nearest.
        * midpoint: (`i` + `j`) / 2.

    Returns
    -------
    Series or DataFrame

        If ``q`` is an array, a DataFrame will be returned where the
          index is ``q``, the columns are the columns of self, and the
          values are the quantiles.
        If ``q`` is a float, a Series will be returned where the
          index is the columns of self and the values are the quantiles.
    """
    if isinstance(q, (int, float)):
        q = [q]

    if not numeric_only:
        axis = self._get_axis_number(axis)
        data = self
    else:
        data = self._get_numeric_data()

    result = pd.concat([data[col].quantile(q, interpolation=interpolation) for col in data], axis=1)
  
    if len(q) == 1:
        result = result.iloc[:, 0]  # Convert to Series
  
    return result
```

By restructuring the `quantile` function to handle both numeric and datetime data, and using `pd.concat` to calculate the quantile values, we can ensure that the function works for all types of data within the DataFrame. This should resolve the issue and the failing test, as well as satisfy the GitHub issue.