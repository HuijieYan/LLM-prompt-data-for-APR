```python
import numpy as np
import pandas as pd
import pandas.core.common as com
from pandas.core.ops import lib
import pandas.core.dtypes.common as com
from pandas.core.construction import ops
import pandas.core.computation.expressions as expressions
from typing import Any, Dict
from pandas.core import frame as ABCDataFrame
from pandas.core import generic as ABMDataFrame
from pandas.core import generic as ABMSeries
from pandas.core.indexing import IndexingError


def dispatch_to_series(left: "ABMDataFrame", right: Any, func, str_rep: str = None, axis: Any = None) -> "ABMDataFrame":
    """
    Evaluate the frame operation func(left, right) by evaluating
    column-by-column, dispatching to the Series implementation.

    Parameters
    ----------
    left : DataFrame
    right : scalar or DataFrame
    func : arithmetic or comparison operator
    str_rep : str or None, default None
    axis : {None, 0, 1, "index", "columns"}

    Returns
    -------
    DataFrame
    """
    # Note: we use iloc to access columns for compat with cases
    #       with non-unique columns.
    right = lib.item_from_zerodim(right)
    if lib.is_scalar(right) or np.ndim(right) == 0:
        def column_op(a, b):
            return {i: func(a.iloc[:, i], b) for i in range(len(a.columns))}
    elif isinstance(right, ABCDataFrame.ABCDataFrame):
        try:
            assert isinstance(right, ABCDataFrame) and right.index.equals(left.index)
        except AssertionError as e:
            raise IndexingError("DataFrame with different index is not relevant for this operation")
        def column_op(a: ABMDataFrame, b: ABMDataFrame) -> Dict:
            a_shape = a.shape
            b_shape = b.shape
            if a_shape != b_shape:
                raise ValueError(f"Shapes of DataFrame's are not aligned: {a_shape}, {b_shape}")
            return {i: func(a.iloc[:, i], b.iloc[:, i]) for i in range(len(a.columns))}
    elif isinstance(right, ABMSeries.ABSeries) and axis == "columns":
        try:
            assert right.index.equals(left.columns)
        except AssertionError as e:
            raise IndexingError("Index of the Series is not aligned with the columns of the DataFrame")
        def column_op(a: ABMDataFrame, b: ABMSeries) -> Dict:
            try:
                return {i: func(a.iloc[:, i], b) for i in range(len(a.columns))}
            except Exception as e:
                return e
    elif isinstance(right, ABMSeries.ABSeries):
        try:
            assert right.index.equals(left.index)
        except AssertionError as e:
            raise IndexingError("Indices of the Series are not aligned with the DataFrame")
        def column_op(a: ABMDataFrame, b: ABMSeries) -> Dict:
            return {i: func(a.iloc[:, i], b) for i in range(len(a.columns))}
    else:
        raise NotImplementedError(f"Unsupported type for right operand: {type(right).__name__}")

    new_data = expressions.evaluate(column_op, str_rep, left, right)
    return new_data
```