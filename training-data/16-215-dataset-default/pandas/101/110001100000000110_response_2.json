{
    "pandas": [
        {
            "bugID": 101,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 0,
                "6": 1,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 0,
                "6": 1,
                "7": 0
            },
            "start_line": 792,
            "file_name": "pandas/core/dtypes/cast.py",
            "replace_code": "def astype_nansafe(\n    values,\n    dtype,\n    copy: bool = True,\n    errors: str = \"raise\",\n    impute: bool = False,\n):\n    \"\"\"\n    Cast the elements of a Series to a specified dtype, at the same time\n    handling np.nan and None in an appropriate nullable dtype.\n    \"\"\"\n\n    if is_object_dtype(dtype) and (ptypes.is_nullable(values.dtype) or \"{datetime\" in values.dtype.name):\n        if is_scalar(values):\n            values = [values]\n\n        return maybe_convert_objects(values, copy=copy)\n\n    if is_extension_array_dtype(dtype):\n        if is_scalar(values):\n            values = [values]\n        return dtype.construct_array_type()._from_sequence(\n            values, dtype=dtype, copy=copy\n        )\n\n    if not isinstance(dtype, np.dtype):\n        dtype = pandas_dtype(dtype)\n\n    if np.issubdtype(dtype, np.integer) and not impute:\n        ensure_numeric(values)\n    elif is_datetime64_dtype(dtype) or is_timedelta64_dtype(dtype):\n        ensure_datetime64ns_values_only(values)\n    elif is_categorical(values) and not is_categorical_dtype(dtype):\n        if impute:\n            raise TypeError(\n                \"Cannot convert a Categorical to another category dtype\"\n            )\n        return lib.maybe_convert_categorical(values, copy)\n    elif isinstance(values, list) and not is_list_like(\n        values\n    ) and not is_dtype_equal(\n        values, dtype\n    ):\n        if impute:\n            raise TypeError(\n                \"Cannot convert float with which has no value to \"\n                \"int, please use 'Int64' or convert to nullable int using 'float'\"\n            )\n    elif isinstance(values, (ABCDataFrame, ABCSeries)) and isinstance(\n        dtype, CategoricalDtype\n    ):\n        for i, col in values.iteritems():\n            if errors == \"skip\":\n                cat = ensure_categorical(\n                    col, dtype.categories, dtype.ordered, errors=\"skip\"\n                )\n            else:\n                cat = ensure_categorical(col, dtype.categories)\n\n            if i == 0:\n                out = cat\n            else:\n                out = out.copy()\n                out.cat.combine_first(cat)\n        return out\n    elif isinstance(values, ABCSeries) and isinstance(dtype, ExtensionDtype):\n        from pandas.core.arrays.sparse.array_ import SparseArray\n\n        if isinstance(values.array, SparseArray) and dtype.construct_array_type() != SparseArray:\n            raise TypeError(\n                \"Cannot convert with sparse index dtype. Please use \"\n                \"ExtensionArray sparse methods.\"\n            )\n        if values.array.dtype != dtype:\n            from pandas.core.arrays.sparse.dtype import SparseDtype\n\n            if isinstance(dtype, SparseDtype):\n                raise TypeError(\n                    \"Cannot convert with sparse index dtype. Please use \"\n                    \"ExtensionArray sparse methods.\"\n                )\n            if is_categorical(values) and dtype != values.dtype:\n                raise TypeError(\n                    \"Cannot convert via .astype if a Categorical is passed. \"\n                    \"Please use 'CategoricalDtype'\"\n                )\n            raise TypeError(\n                \"Cannot convert extension arrays only \" f\"{values.dtype} to \" f\"{dtype}\"\n            )\n        return dtype.construct_array_type()(values)\n    if is_datetime64_dtype(values):\n        raise TypeError(\"Cannot convert with no date-like in series to datetime\")\n\n    if is_timedelta64_dtype(values):\n        raise TypeError(\"Cannot convert with no timedelta-like in series\")\n\n    return cast(values, dtype, copy)",
            "import_list": [
                "import numpy as np",
                "import pandas._libs.lib as lib",
                "import pandas.api.types as ptypes",
                "from pandas.api.types import is_extension_array_dtype",
                "from pandas.core.dtypes.common import (\n    is_datetime64_dtype,\n    is_timedelta64_dtype,\n    is_scalar,\n    is_object_dtype,\n    pandas_dtype,\n)",
                "from pandas.core.dtypes.dtypes import _TD_DTYPE, _INT64_DTYPE",
                "from pandas.core.dtypes.generic import ABCDatetimeArray, ABCTimedeltaArray",
                "from pandas.core.dtypes.concat import union_categoricals",
                "from pandas.core.tools.timedeltas import (\n    ints_to_pytimedelta,\n    to_timedelta,\n    ints_to_pydatetime,\n    to_datetime,\n)",
                "from pandas.core.algorithms import (\n    factorize,\n)",
                "from pandas.core.arrays import ExtensionArray",
                "from pandas.core.dtypes.base import ExtensionDtype",
                "from pandas.core.arrays.integer import (\n    Int8Dtype,\n    UInt16Dtype,\n    Int64Dtype,\n    UInt64Dtype,\n    UInt8Dtype,\n    UInt16Dtype,\n)",
                "from pandas.core.dtypes.concat import union_categoricals",
                "from pandas.core.indexes.api import ensure_index",
                "from pandas.core.dtypes.dtypes import CategoricalDtype",
                "from pandas.core.arrays.sparse.array_ import SparseArray",
                "from pandas.core.arrays.sparse.dtype import SparseDtype"
            ]
        }
    ]
}