{
    "tornado": [
        {
            "bugID": 4,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 1
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 0,
                "6": 0,
                "7": 1
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 0,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 1
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 0,
                "6": 0,
                "7": 1
            },
            "start_line": 2577,
            "file_name": "tornado/web.py",
            "replace_code": "def get(self, path: str, include_body: bool = True) -> None:\n    # Set up our path instance variables.\n\n    self.path = self.parse_url_path(path)\n    del path  # make sure we don't refer to path instead of self.path again\n    absolute_path = self.get_absolute_path(self.root, self.path)\n    self.absolute_path = self.validate_absolute_path(self.root, absolute_path)\n    if self.absolute_path is None:\n        return\n    \n    self.modified = self.get_modified_time()\n    self.set_headers()\n    \n    if self.should_return_304():\n        self.set_status(304)\n        return\n    \n    request_range = None\n    range_header = self.request.headers.get(\"Range\")\n    if range_header:\n        # As per RFC 2616 14.16, if an invalid Range header is specified,\n        # the request will be treated as if the header didn't exist.\n        request_range = httputil._parse_request_range(range_header)\n    \n    size = self.get_content_size()\n    if request_range:\n        start, end = request_range\n        if (start is not None and start >= size) or end == 0:\n            # As per RFC 2616 14.35.1, a range is not satisfiable only: if\n            # the first requested byte is equal to or greater than the\n            # content, or when a suffix with length 0 is specified\n            self.set_status(416)  # Range Not Satisfiable\n            self.set_header(\"Content-Type\", \"text/plain\")\n            self.set_header(\"Content-Range\", \"bytes */%s\" % (size,))\n            return\n        if start is not None and start < 0:\n            start += size\n        if end is not None and end > size:\n            # Clients sometimes blindly use a large range to limit their\n            # download size; cap the endpoint at the actual file size.\n            end = size\n        # Note: only return HTTP 206 if less than the entire range has been\n        # requested. Not only is this semantically correct, but Chrome\n        # refuses to play audio if it gets an HTTP 206 in response to\n        # ``Range: bytes=0-``.\n        if size != (end or size) - (start or 0):\n            self.set_status(206)  # Partial Content\n            self.set_header(\n                \"Content-Range\", httputil._get_content_range(start, end, size)\n            )\n    else:\n        start = end = None\n    \n    if start is not None and end is not None:\n        content_length = end - start\n    elif end is not None:\n        content_length = end\n    elif start is not None:\n        content_length = size - start\n    else:\n        content_length = size\n    self.set_header(\"Content-Length\", content_length)\n    \n    if include_body:\n        content = self.get_content(self.absolute_path, start, end)\n        if isinstance(content, bytes):\n            content = [content]\n        for chunk in content:\n            try:\n                self.write(chunk)\n                await self.flush()\n            except iostream.StreamClosedError:\n                return\n    else:\n        assert self.request.method == \"HEAD\""
        }
    ]
}