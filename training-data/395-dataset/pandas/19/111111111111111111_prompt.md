Please fix the function/method provided below and provide the corrected function/method as the output.


# Buggy function source code
```python
# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_19/pandas/core/indexing.py

# relative function's signature in this file
def is_nested_tuple(tup, labels) -> bool:
    # ... omitted code ...
    pass

# relative function's signature in this file
def iloc(self) -> '_iLocIndexer':
    # ... omitted code ...
    pass

# relative function's signature in this file
def _validate_key(self, key, axis: int):
    # ... omitted code ...
    pass

# relative function's signature in this file
def _getbool_axis(self, key, axis: int):
    # ... omitted code ...
    pass

# relative function's signature in this file
def _validate_key(self, key, axis: int):
    # ... omitted code ...
    pass

# relative function's signature in this file
def _getitem_iterable(self, key, axis: int):
    # ... omitted code ...
    pass

# relative function's signature in this file
def _get_label(self, label, axis: int):
    # ... omitted code ...
    pass

# relative function's signature in this file
def _get_slice_axis(self, slice_obj: slice, axis: int):
    # ... omitted code ...
    pass

# relative function's signature in this file
def _validate_key(self, key, axis: int):
    # ... omitted code ...
    pass

# relative function's signature in this file
def _get_slice_axis(self, slice_obj: slice, axis: int):
    # ... omitted code ...
    pass

# class declaration containing the buggy function
@doc(IndexingMixin.loc)
class _LocIndexer(_LocationIndexer):
    # ... omitted code ...


    # signature of a relative function in this class
    def _validate_key(self, key, axis: int):
        # ... omitted code ...
        pass

    # signature of a relative function in this class
    def _getitem_iterable(self, key, axis: int):
        # ... omitted code ...
        pass

    # signature of a relative function in this class
    def _get_label(self, label, axis: int):
        # ... omitted code ...
        pass

    # signature of a relative function in this class
    def _get_slice_axis(self, slice_obj: slice, axis: int):
        # ... omitted code ...
        pass



    # this is the buggy function you need to fix
    def _getitem_axis(self, key, axis: int):
        key = item_from_zerodim(key)
        if is_iterator(key):
            key = list(key)
    
        labels = self.obj._get_axis(axis)
        key = labels._get_partial_string_timestamp_match_key(key)
    
        if isinstance(key, slice):
            self._validate_key(key, axis)
            return self._get_slice_axis(key, axis=axis)
        elif com.is_bool_indexer(key):
            return self._getbool_axis(key, axis=axis)
        elif is_list_like_indexer(key):
    
            # convert various list-like indexers
            # to a list of keys
            # we will use the *values* of the object
            # and NOT the index if its a PandasObject
            if isinstance(labels, ABCMultiIndex):
    
                if isinstance(key, (ABCSeries, np.ndarray)) and key.ndim <= 1:
                    # Series, or 0,1 ndim ndarray
                    # GH 14730
                    key = list(key)
                elif isinstance(key, ABCDataFrame):
                    # GH 15438
                    raise NotImplementedError(
                        "Indexing a MultiIndex with a "
                        "DataFrame key is not "
                        "implemented"
                    )
                elif hasattr(key, "ndim") and key.ndim > 1:
                    raise NotImplementedError(
                        "Indexing a MultiIndex with a "
                        "multidimensional key is not "
                        "implemented"
                    )
    
                if (
                    not isinstance(key, tuple)
                    and len(key)
                    and not isinstance(key[0], tuple)
                ):
                    key = tuple([key])
    
            # an iterable multi-selection
            if not (isinstance(key, tuple) and isinstance(labels, ABCMultiIndex)):
    
                if hasattr(key, "ndim") and key.ndim > 1:
                    raise ValueError("Cannot index with multidimensional key")
    
                return self._getitem_iterable(key, axis=axis)
    
            # nested tuple slicing
            if is_nested_tuple(key, labels):
                locs = labels.get_locs(key)
                indexer = [slice(None)] * self.ndim
                indexer[axis] = locs
                return self.obj.iloc[tuple(indexer)]
    
        # fall thru to straight lookup
        self._validate_key(key, axis)
        return self._get_label(key, axis=axis)
    
```

# Variable runtime value and type inside buggy function
## Buggy case 1
### input parameter runtime value and type for buggy function
key, value: `[2, 4]`, type: `list`

self.obj, value: `             2                   4
            6         8         10
4 8   0.513856  0.394161  0.198294
  10 -0.243232  0.978980  0.223799
8 12  1.861835  0.183575 -1.576461`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1166e0e00>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([(4,  8),
            (4, 10),
            (8, 12)],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(4,  8),
            (4, 10),
            (8, 12)],
           )>`, type: `method`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([(4,  8),
            (4, 10),
            (8, 12)],
           )>`, type: `method`

## Buggy case 2
### input parameter runtime value and type for buggy function
key, value: `[2]`, type: `list`

self.obj, value: `             2                   4
            6         8         10
4 8  -1.431157  0.060275  0.146345
  10 -2.387835 -0.150634 -0.821127
8 12  1.097211  1.160184  1.591412`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x116811c70>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([(4,  8),
            (4, 10),
            (8, 12)],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(4,  8),
            (4, 10),
            (8, 12)],
           )>`, type: `method`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([(4,  8),
            (4, 10),
            (8, 12)],
           )>`, type: `method`

## Buggy case 3
### input parameter runtime value and type for buggy function
key, value: `[2, 3]`, type: `list`

self.obj, value: `             2                   4
            6         8         10
4 8  -1.355982 -0.987792 -0.871567
  10  0.622677  0.420918 -1.282030
8 12  0.223348 -0.141610 -0.081980`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x11681d040>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([(4,  8),
            (4, 10),
            (8, 12)],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(4,  8),
            (4, 10),
            (8, 12)],
           )>`, type: `method`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([(4,  8),
            (4, 10),
            (8, 12)],
           )>`, type: `method`

## Buggy case 4
### input parameter runtime value and type for buggy function
key, value: `(slice('A1', 'A3', None), slice(None, None, None), ['C1', 'C3'])`, type: `tuple`

self.obj, value: `               0
A0 B0 C0 D0    0
         D1    1
      C1 D0    2
         D1    3
      C2 D0    4
...          ...
A4 B6 C1 D1  275
      C2 D0  276
         D1  277
      C3 D0  278
         D1  279

[280 rows x 1 columns]`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x116834ae0>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `array of shape (280,)`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_ ... D1')],
           length=280)>`, type: `method`

locs, value: `array([ 58,  59,  62,  63,  66,  67,  70,  71,  74,  75,  78,  79,  82,
        83,  86,  87,  90,  91,  94,  95,  98,  99, 102, 103, 106, 107,
       110, 111, 114, 115, 118, 119, 122, 123, 126, 127, 130, 131, 134,
       135, 138, 139, 142, 143, 146, 147, 150, 151, 154, 155, 158, 159,
       162, 163, 166, 167, 170, 171, 174, 175, 178, 179, 182, 183, 186,
       187, 190, 191, 194, 195, 198, 199, 202, 203, 206, 207, 210, 211,
       214, 215, 218, 219, 222, 223])`, type: `ndarray`

labels.get_locs, value: `<bound method MultiIndex.get_l ... D1')],
           length=280)>`, type: `method`

indexer, value: `[array([ 58,  59,  62,  63,  66,  67,  70,  71,  74,  75,  78,  79,  82,
        83,  86,  87,  90,  91,  94,  95,  98,  99, 102, 103, 106, 107,
       110, 111, 114, 115, 118, 119, 122, 123, 126, 127, 130, 131, 134,
       135, 138, 139, 142, 143, 146, 147, 150, 151, 154, 155, 158, 159,
       162, 163, 166, 167, 170, 171, 174, 175, 178, 179, 182, 183, 186,
       187, 190, 191, 194, 195, 198, 199, 202, 203, 206, 207, 210, 211,
       214, 215, 218, 219, 222, 223]), slice(None, None, None)]`, type: `list`

## Buggy case 5
### input parameter runtime value and type for buggy function
key, value: `array of shape 84`, type: `list`

self.obj, value: `               0
A0 B0 C0 D0    0
         D1    1
      C1 D0    2
         D1    3
      C2 D0    4
...          ...
A4 B6 C1 D1  275
      C2 D0  276
         D1  277
      C3 D0  278
         D1  279

[280 rows x 1 columns]`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x116834a40>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `array of shape (280,)`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_ ... D1')],
           length=280)>`, type: `method`

labels.get_locs, value: `<bound method MultiIndex.get_l ... D1')],
           length=280)>`, type: `method`

## Buggy case 6
### input parameter runtime value and type for buggy function
key, value: `array of shape 126`, type: `list`

self.obj, value: `               0
A0 B0 C0 D0    0
         D1    1
      C1 D0    2
         D1    3
      C2 D0    4
...          ...
A4 B6 C1 D1  275
      C2 D0  276
         D1  277
      C3 D0  278
         D1  279

[280 rows x 1 columns]`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1167e6e00>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `array of shape (280,)`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_ ... D1')],
           length=280)>`, type: `method`

labels.get_locs, value: `<bound method MultiIndex.get_l ... D1')],
           length=280)>`, type: `method`

## Buggy case 7
### input parameter runtime value and type for buggy function
key, value: `(slice('A1', 'A3', None), slice(None, None, None), slice('C1', 'C3', None))`, type: `tuple`

self.obj, value: `               0
A0 B0 C0 D0    0
         D1    1
      C1 D0    2
         D1    3
      C2 D0    4
...          ...
A4 B6 C1 D1  275
      C2 D0  276
         D1  277
      C3 D0  278
         D1  279

[280 rows x 1 columns]`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x11682dd60>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `array of shape (280,)`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_ ... D1')],
           length=280)>`, type: `method`

locs, value: `array of shape (126,)`, type: `ndarray`

labels.get_locs, value: `<bound method MultiIndex.get_l ... D1')],
           length=280)>`, type: `method`

indexer, value: `array of shape 2`, type: `list`

## Buggy case 8
### input parameter runtime value and type for buggy function
key, value: `(slice(None, None, None), slice(None, None, None))`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x11682d9f0>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

locs, value: `array([0, 1, 2, 3])`, type: `ndarray`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

indexer, value: `[array([0, 1, 2, 3]), slice(None, None, None)]`, type: `list`

## Buggy case 9
### input parameter runtime value and type for buggy function
key, value: `(slice(None, None, None), slice(None, None, None))`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x11682dd60>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

locs, value: `array([0, 1, 2, 3])`, type: `ndarray`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

indexer, value: `[array([0, 1, 2, 3]), slice(None, None, None)]`, type: `list`

## Buggy case 10
### input parameter runtime value and type for buggy function
key, value: `(slice(None, None, None), slice(None, None, None))`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x11682dd60>`, type: `_LocIndexer`

axis, value: `1`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

locs, value: `array([0, 1, 2, 3])`, type: `ndarray`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

indexer, value: `[slice(None, None, None), array([0, 1, 2, 3])]`, type: `list`

## Buggy case 11
### input parameter runtime value and type for buggy function
key, value: `(slice(None, None, None), slice(None, None, None))`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x116865f90>`, type: `_LocIndexer`

axis, value: `1`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

locs, value: `array([0, 1, 2, 3])`, type: `ndarray`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

indexer, value: `[slice(None, None, None), array([0, 1, 2, 3])]`, type: `list`

## Buggy case 12
### input parameter runtime value and type for buggy function
key, value: `(slice(None, None, None), [1])`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x116865ae0>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

locs, value: `array([0, 3])`, type: `ndarray`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

indexer, value: `[array([0, 3]), slice(None, None, None)]`, type: `list`

## Buggy case 13
### input parameter runtime value and type for buggy function
key, value: `(slice(None, None, None), 1)`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1168635e0>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

locs, value: `array([0, 3])`, type: `ndarray`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

indexer, value: `[array([0, 3]), slice(None, None, None)]`, type: `list`

## Buggy case 14
### input parameter runtime value and type for buggy function
key, value: `(slice(None, None, None), ['foo'])`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x116863400>`, type: `_LocIndexer`

axis, value: `1`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

locs, value: `array([1, 3])`, type: `ndarray`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

indexer, value: `[slice(None, None, None), array([1, 3])]`, type: `list`

## Buggy case 15
### input parameter runtime value and type for buggy function
key, value: `(slice(None, None, None), 1)`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1168349f0>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

locs, value: `array([0, 3])`, type: `ndarray`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

indexer, value: `[array([0, 3]), slice(None, None, None)]`, type: `list`

## Buggy case 16
### input parameter runtime value and type for buggy function
key, value: `(slice(None, None, None), ['foo'])`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1168349f0>`, type: `_LocIndexer`

axis, value: `1`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

locs, value: `array([1, 3])`, type: `ndarray`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

indexer, value: `[slice(None, None, None), array([1, 3])]`, type: `list`

## Buggy case 17
### input parameter runtime value and type for buggy function
key, value: `'A'`, type: `str`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1168529f0>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

## Buggy case 18
### input parameter runtime value and type for buggy function
key, value: `'a'`, type: `str`

self.obj, value: `lvl0   a       b    
lvl1 bar foo bah foo
two                 
1      1   0   3   2
2      5   4   7   6
3      9   8  11  10`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x116868040>`, type: `_LocIndexer`

axis, value: `1`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

## Buggy case 19
### input parameter runtime value and type for buggy function
key, value: `(slice(None, None, None), [1, 2])`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1167c9040>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

locs, value: `array([0, 1, 3])`, type: `ndarray`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

indexer, value: `[array([0, 1, 3]), slice(None, None, None)]`, type: `list`

## Buggy case 20
### input parameter runtime value and type for buggy function
key, value: `(slice('A1', 'A3', None), slice(None, None, None), ['C1', 'C3'])`, type: `tuple`

self.obj, value: `A0  B0  C0  D0      0
            D1      1
        C1  D0      2
            D1      3
        C2  D0      4
                 ... 
A4  B6  C1  D1    275
        C2  D0    276
            D1    277
        C3  D0    278
            D1    279
Length: 280, dtype: int64`, type: `Series`

self, value: `<pandas.core.indexing._LocIndexer object at 0x116862db0>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `1`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `array of shape (280,)`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_ ... D1')],
           length=280)>`, type: `method`

locs, value: `array([ 58,  59,  62,  63,  66,  67,  70,  71,  74,  75,  78,  79,  82,
        83,  86,  87,  90,  91,  94,  95,  98,  99, 102, 103, 106, 107,
       110, 111, 114, 115, 118, 119, 122, 123, 126, 127, 130, 131, 134,
       135, 138, 139, 142, 143, 146, 147, 150, 151, 154, 155, 158, 159,
       162, 163, 166, 167, 170, 171, 174, 175, 178, 179, 182, 183, 186,
       187, 190, 191, 194, 195, 198, 199, 202, 203, 206, 207, 210, 211,
       214, 215, 218, 219, 222, 223])`, type: `ndarray`

labels.get_locs, value: `<bound method MultiIndex.get_l ... D1')],
           length=280)>`, type: `method`

indexer, value: `[array([ 58,  59,  62,  63,  66,  67,  70,  71,  74,  75,  78,  79,  82,
        83,  86,  87,  90,  91,  94,  95,  98,  99, 102, 103, 106, 107,
       110, 111, 114, 115, 118, 119, 122, 123, 126, 127, 130, 131, 134,
       135, 138, 139, 142, 143, 146, 147, 150, 151, 154, 155, 158, 159,
       162, 163, 166, 167, 170, 171, 174, 175, 178, 179, 182, 183, 186,
       187, 190, 191, 194, 195, 198, 199, 202, 203, 206, 207, 210, 211,
       214, 215, 218, 219, 222, 223])]`, type: `list`

## Buggy case 21
### input parameter runtime value and type for buggy function
key, value: `array of shape 84`, type: `list`

self.obj, value: `A0  B0  C0  D0      0
            D1      1
        C1  D0      2
            D1      3
        C2  D0      4
                 ... 
A4  B6  C1  D1    275
        C2  D0    276
            D1    277
        C3  D0    278
            D1    279
Length: 280, dtype: int64`, type: `Series`

self, value: `<pandas.core.indexing._LocIndexer object at 0x116865b30>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `1`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `array of shape (280,)`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_ ... D1')],
           length=280)>`, type: `method`

labels.get_locs, value: `<bound method MultiIndex.get_l ... D1')],
           length=280)>`, type: `method`

## Buggy case 22
### input parameter runtime value and type for buggy function
key, value: `('a', 'bar')`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x11684e4f0>`, type: `_LocIndexer`

axis, value: `1`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

## Buggy case 23
### input parameter runtime value and type for buggy function
key, value: `(slice(None, None, None), one  two
A    1      False
     2      False
     3       True
B    1       True
Name: (a, bar), dtype: bool)`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x116865b30>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

locs, value: `array([2, 3])`, type: `ndarray`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

indexer, value: `[array([2, 3]), slice(None, None, None)]`, type: `list`

## Buggy case 24
### input parameter runtime value and type for buggy function
key, value: `[1]`, type: `list`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x116842810>`, type: `_LocIndexer`

axis, value: `1`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

## Buggy case 25
### input parameter runtime value and type for buggy function
key, value: `(slice(None, None, None), [1])`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x116964c70>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

locs, value: `array([0, 3])`, type: `ndarray`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

indexer, value: `[array([0, 3]), slice(None, None, None)]`, type: `list`

## Buggy case 26
### input parameter runtime value and type for buggy function
key, value: `('a', 'bar')`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
B   1    13  12  15  14
A   2     5   4   7   6
    3     9   8  11  10`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x116845c70>`, type: `_LocIndexer`

axis, value: `1`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

## Buggy case 27
### input parameter runtime value and type for buggy function
key, value: `(slice(None, None, None), one  two
A    1      False
B    1       True
A    2      False
     3       True
Name: (a, bar), dtype: bool)`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
B   1    13  12  15  14
A   2     5   4   7   6
    3     9   8  11  10`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1168621d0>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([('A', 1),
            ('B', 1),
            ('A', 2),
            ('A', 3)],
           names=['one', 'two'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('A', 1),
            ('B', 1),
            ('A', 2),
            ('A', 3)],
           names=['one', 'two'])>`, type: `method`

locs, value: `array([1, 3])`, type: `ndarray`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([('A', 1),
            ('B', 1),
            ('A', 2),
            ('A', 3)],
           names=['one', 'two'])>`, type: `method`

indexer, value: `[array([1, 3]), slice(None, None, None)]`, type: `list`

## Buggy case 28
### input parameter runtime value and type for buggy function
key, value: `[5]`, type: `list`

self.obj, value: `0  2000-01-03    11
   2000-01-04    10
   2000-01-05     9
1  2000-01-03     8
   2000-01-04     7
   2000-01-05     6
2  2000-01-03     5
   2000-01-04     4
   2000-01-05     3
3  2000-01-03     2
   2000-01-04     1
   2000-01-05     0
dtype: int64`, type: `Series`

self, value: `<pandas.core.indexing._LocIndexer object at 0x11684ec20>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `1`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`

## Buggy case 29
### input parameter runtime value and type for buggy function
key, value: `array([5])`, type: `ndarray`

self.obj, value: `0  2000-01-03    11
   2000-01-04    10
   2000-01-05     9
1  2000-01-03     8
   2000-01-04     7
   2000-01-05     6
2  2000-01-03     5
   2000-01-04     4
   2000-01-05     3
3  2000-01-03     2
   2000-01-04     1
   2000-01-05     0
dtype: int64`, type: `Series`

self, value: `<pandas.core.indexing._LocIndexer object at 0x116850d10>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

key.ndim, value: `1`, type: `int`

self.ndim, value: `1`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`

## Buggy case 30
### input parameter runtime value and type for buggy function
key, value: `Int64Index([5], dtype='int64')`, type: `Int64Index`

self.obj, value: `0  2000-01-03    11
   2000-01-04    10
   2000-01-05     9
1  2000-01-03     8
   2000-01-04     7
   2000-01-05     6
2  2000-01-03     5
   2000-01-04     4
   2000-01-05     3
3  2000-01-03     2
   2000-01-04     1
   2000-01-05     0
dtype: int64`, type: `Series`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1168624f0>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

key.ndim, value: `1`, type: `int`

self.ndim, value: `1`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`

## Buggy case 31
### input parameter runtime value and type for buggy function
key, value: `[5]`, type: `list`

self.obj, value: `0.0  2000-01-03    11
     2000-01-04    10
     2000-01-05     9
1.0  2000-01-03     8
     2000-01-04     7
     2000-01-05     6
2.0  2000-01-03     5
     2000-01-04     4
     2000-01-05     3
3.0  2000-01-03     2
     2000-01-04     1
     2000-01-05     0
dtype: int64`, type: `Series`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1168623b0>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `1`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([(0.0, '2000-01-03'),
            (0.0, '2000-01-04'),
            (0.0, '2000-01-05'),
            (1.0, '2000-01-03'),
            (1.0, '2000-01-04'),
            (1.0, '2000-01-05'),
            (2.0, '2000-01-03'),
            (2.0, '2000-01-04'),
            (2.0, '2000-01-05'),
            (3.0, '2000-01-03'),
            (3.0, '2000-01-04'),
            (3.0, '2000-01-05')],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(0.0, '2000-01-03'),
            (0.0, '2000-01-04'),
            (0.0, '2000-01-05'),
            (1.0, '2000-01-03'),
            (1.0, '2000-01-04'),
            (1.0, '2000-01-05'),
            (2.0, '2000-01-03'),
            (2.0, '2000-01-04'),
            (2.0, '2000-01-05'),
            (3.0, '2000-01-03'),
            (3.0, '2000-01-04'),
            (3.0, '2000-01-05')],
           )>`, type: `method`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([(0.0, '2000-01-03'),
            (0.0, '2000-01-04'),
            (0.0, '2000-01-05'),
            (1.0, '2000-01-03'),
            (1.0, '2000-01-04'),
            (1.0, '2000-01-05'),
            (2.0, '2000-01-03'),
            (2.0, '2000-01-04'),
            (2.0, '2000-01-05'),
            (3.0, '2000-01-03'),
            (3.0, '2000-01-04'),
            (3.0, '2000-01-05')],
           )>`, type: `method`

## Buggy case 32
### input parameter runtime value and type for buggy function
key, value: `array([5])`, type: `ndarray`

self.obj, value: `0.0  2000-01-03    11
     2000-01-04    10
     2000-01-05     9
1.0  2000-01-03     8
     2000-01-04     7
     2000-01-05     6
2.0  2000-01-03     5
     2000-01-04     4
     2000-01-05     3
3.0  2000-01-03     2
     2000-01-04     1
     2000-01-05     0
dtype: int64`, type: `Series`

self, value: `<pandas.core.indexing._LocIndexer object at 0x11684ec20>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

key.ndim, value: `1`, type: `int`

self.ndim, value: `1`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([(0.0, '2000-01-03'),
            (0.0, '2000-01-04'),
            (0.0, '2000-01-05'),
            (1.0, '2000-01-03'),
            (1.0, '2000-01-04'),
            (1.0, '2000-01-05'),
            (2.0, '2000-01-03'),
            (2.0, '2000-01-04'),
            (2.0, '2000-01-05'),
            (3.0, '2000-01-03'),
            (3.0, '2000-01-04'),
            (3.0, '2000-01-05')],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(0.0, '2000-01-03'),
            (0.0, '2000-01-04'),
            (0.0, '2000-01-05'),
            (1.0, '2000-01-03'),
            (1.0, '2000-01-04'),
            (1.0, '2000-01-05'),
            (2.0, '2000-01-03'),
            (2.0, '2000-01-04'),
            (2.0, '2000-01-05'),
            (3.0, '2000-01-03'),
            (3.0, '2000-01-04'),
            (3.0, '2000-01-05')],
           )>`, type: `method`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([(0.0, '2000-01-03'),
            (0.0, '2000-01-04'),
            (0.0, '2000-01-05'),
            (1.0, '2000-01-03'),
            (1.0, '2000-01-04'),
            (1.0, '2000-01-05'),
            (2.0, '2000-01-03'),
            (2.0, '2000-01-04'),
            (2.0, '2000-01-05'),
            (3.0, '2000-01-03'),
            (3.0, '2000-01-04'),
            (3.0, '2000-01-05')],
           )>`, type: `method`

## Buggy case 33
### input parameter runtime value and type for buggy function
key, value: `Int64Index([5], dtype='int64')`, type: `Int64Index`

self.obj, value: `0.0  2000-01-03    11
     2000-01-04    10
     2000-01-05     9
1.0  2000-01-03     8
     2000-01-04     7
     2000-01-05     6
2.0  2000-01-03     5
     2000-01-04     4
     2000-01-05     3
3.0  2000-01-03     2
     2000-01-04     1
     2000-01-05     0
dtype: int64`, type: `Series`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1168626d0>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

key.ndim, value: `1`, type: `int`

self.ndim, value: `1`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([(0.0, '2000-01-03'),
            (0.0, '2000-01-04'),
            (0.0, '2000-01-05'),
            (1.0, '2000-01-03'),
            (1.0, '2000-01-04'),
            (1.0, '2000-01-05'),
            (2.0, '2000-01-03'),
            (2.0, '2000-01-04'),
            (2.0, '2000-01-05'),
            (3.0, '2000-01-03'),
            (3.0, '2000-01-04'),
            (3.0, '2000-01-05')],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(0.0, '2000-01-03'),
            (0.0, '2000-01-04'),
            (0.0, '2000-01-05'),
            (1.0, '2000-01-03'),
            (1.0, '2000-01-04'),
            (1.0, '2000-01-05'),
            (2.0, '2000-01-03'),
            (2.0, '2000-01-04'),
            (2.0, '2000-01-05'),
            (3.0, '2000-01-03'),
            (3.0, '2000-01-04'),
            (3.0, '2000-01-05')],
           )>`, type: `method`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([(0.0, '2000-01-03'),
            (0.0, '2000-01-04'),
            (0.0, '2000-01-05'),
            (1.0, '2000-01-03'),
            (1.0, '2000-01-04'),
            (1.0, '2000-01-05'),
            (2.0, '2000-01-03'),
            (2.0, '2000-01-04'),
            (2.0, '2000-01-05'),
            (3.0, '2000-01-03'),
            (3.0, '2000-01-04'),
            (3.0, '2000-01-05')],
           )>`, type: `method`

## Buggy case 34
### input parameter runtime value and type for buggy function
key, value: `[5]`, type: `list`

self.obj, value: `0  2000-01-03    11
   2000-01-04    10
   2000-01-05     9
1  2000-01-03     8
   2000-01-04     7
   2000-01-05     6
2  2000-01-03     5
   2000-01-04     4
   2000-01-05     3
3  2000-01-03     2
   2000-01-04     1
   2000-01-05     0
dtype: int64`, type: `Series`

self, value: `<pandas.core.indexing._LocIndexer object at 0x116862400>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `1`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`

## Buggy case 35
### input parameter runtime value and type for buggy function
key, value: `array([5])`, type: `ndarray`

self.obj, value: `0  2000-01-03    11
   2000-01-04    10
   2000-01-05     9
1  2000-01-03     8
   2000-01-04     7
   2000-01-05     6
2  2000-01-03     5
   2000-01-04     4
   2000-01-05     3
3  2000-01-03     2
   2000-01-04     1
   2000-01-05     0
dtype: int64`, type: `Series`

self, value: `<pandas.core.indexing._LocIndexer object at 0x11694f310>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

key.ndim, value: `1`, type: `int`

self.ndim, value: `1`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`

## Buggy case 36
### input parameter runtime value and type for buggy function
key, value: `Int64Index([5], dtype='int64')`, type: `Int64Index`

self.obj, value: `0  2000-01-03    11
   2000-01-04    10
   2000-01-05     9
1  2000-01-03     8
   2000-01-04     7
   2000-01-05     6
2  2000-01-03     5
   2000-01-04     4
   2000-01-05     3
3  2000-01-03     2
   2000-01-04     1
   2000-01-05     0
dtype: int64`, type: `Series`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1168621d0>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

key.ndim, value: `1`, type: `int`

self.ndim, value: `1`, type: `int`

### variable runtime value and type before buggy function return
labels, value: `MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`

labels.get_locs, value: `<bound method MultiIndex.get_locs of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`



# Expected variable value and type in tests
## Expected case 1
### Input parameter value and type
key, value: `[2, 4]`, type: `list`

self.obj, value: `             2                   4
            6         8         10
4 8  -0.915624 -0.800096 -1.165471
  10  0.456463 -0.538957 -1.824972
8 12 -0.049943 -0.385960 -0.956430`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1153371d0>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### Expected variable value and type before function return
key, expected value: `([2, 4],)`, type: `tuple`

labels, expected value: `MultiIndex([(4,  8),
            (4, 10),
            (8, 12)],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(4,  8),
            (4, 10),
            (8, 12)],
           )>`, type: `method`

locs, expected value: `array([0, 1])`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([(4,  8),
            (4, 10),
            (8, 12)],
           )>`, type: `method`

indexer, expected value: `[array([0, 1]), slice(None, None, None)]`, type: `list`

## Expected case 2
### Input parameter value and type
key, value: `[2]`, type: `list`

self.obj, value: `             2                   4
            6         8         10
4 8   1.285106 -0.802538 -1.461331
  10  0.436357 -0.236523 -1.065813
8 12 -1.283179  0.466606  1.633564`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1152ac950>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### Expected variable value and type before function return
key, expected value: `([2],)`, type: `tuple`

labels, expected value: `MultiIndex([(4,  8),
            (4, 10),
            (8, 12)],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(4,  8),
            (4, 10),
            (8, 12)],
           )>`, type: `method`

locs, expected value: `array([], dtype=int64)`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([(4,  8),
            (4, 10),
            (8, 12)],
           )>`, type: `method`

indexer, expected value: `[array([], dtype=int64), slice(None, None, None)]`, type: `list`

## Expected case 3
### Input parameter value and type
key, value: `[2, 3]`, type: `list`

self.obj, value: `             2                   4
            6         8         10
4 8   0.573617  0.808506  0.953831
  10 -1.176943 -0.219339  0.257522
8 12  1.686174  0.421958  0.739802`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x11530af90>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### Expected variable value and type before function return
key, expected value: `([2, 3],)`, type: `tuple`

labels, expected value: `MultiIndex([(4,  8),
            (4, 10),
            (8, 12)],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(4,  8),
            (4, 10),
            (8, 12)],
           )>`, type: `method`

locs, expected value: `array([], dtype=int64)`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([(4,  8),
            (4, 10),
            (8, 12)],
           )>`, type: `method`

indexer, expected value: `[array([], dtype=int64), slice(None, None, None)]`, type: `list`

## Expected case 4
### Input parameter value and type
key, value: `(slice('A1', 'A3', None), slice(None, None, None), ['C1', 'C3'])`, type: `tuple`

self.obj, value: `               0
A0 B0 C0 D0    0
         D1    1
      C1 D0    2
         D1    3
      C2 D0    4
...          ...
A4 B6 C1 D1  275
      C2 D0  276
         D1  277
      C3 D0  278
         D1  279

[280 rows x 1 columns]`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1152c2540>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### Expected variable value and type before function return
labels, expected value: `array of shape (280,)`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_ ... D1')],
           length=280)>`, type: `method`

locs, expected value: `array([ 58,  59,  62,  63,  66,  67,  70,  71,  74,  75,  78,  79,  82,
        83,  86,  87,  90,  91,  94,  95,  98,  99, 102, 103, 106, 107,
       110, 111, 114, 115, 118, 119, 122, 123, 126, 127, 130, 131, 134,
       135, 138, 139, 142, 143, 146, 147, 150, 151, 154, 155, 158, 159,
       162, 163, 166, 167, 170, 171, 174, 175, 178, 179, 182, 183, 186,
       187, 190, 191, 194, 195, 198, 199, 202, 203, 206, 207, 210, 211,
       214, 215, 218, 219, 222, 223])`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_l ... D1')],
           length=280)>`, type: `method`

indexer, expected value: `[array([ 58,  59,  62,  63,  66,  67,  70,  71,  74,  75,  78,  79,  82,
        83,  86,  87,  90,  91,  94,  95,  98,  99, 102, 103, 106, 107,
       110, 111, 114, 115, 118, 119, 122, 123, 126, 127, 130, 131, 134,
       135, 138, 139, 142, 143, 146, 147, 150, 151, 154, 155, 158, 159,
       162, 163, 166, 167, 170, 171, 174, 175, 178, 179, 182, 183, 186,
       187, 190, 191, 194, 195, 198, 199, 202, 203, 206, 207, 210, 211,
       214, 215, 218, 219, 222, 223]), slice(None, None, None)]`, type: `list`

## Expected case 5
### Input parameter value and type
key, value: `array of shape 84`, type: `list`

self.obj, value: `               0
A0 B0 C0 D0    0
         D1    1
      C1 D0    2
         D1    3
      C2 D0    4
...          ...
A4 B6 C1 D1  275
      C2 D0  276
         D1  277
      C3 D0  278
         D1  279

[280 rows x 1 columns]`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1152c24a0>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### Expected variable value and type before function return
labels, expected value: `array of shape (280,)`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_ ... D1')],
           length=280)>`, type: `method`

labels.get_locs, expected value: `<bound method MultiIndex.get_l ... D1')],
           length=280)>`, type: `method`

## Expected case 6
### Input parameter value and type
key, value: `array of shape 126`, type: `list`

self.obj, value: `               0
A0 B0 C0 D0    0
         D1    1
      C1 D0    2
         D1    3
      C2 D0    4
...          ...
A4 B6 C1 D1  275
      C2 D0  276
         D1  277
      C3 D0  278
         D1  279

[280 rows x 1 columns]`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x11550ed60>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### Expected variable value and type before function return
labels, expected value: `array of shape (280,)`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_ ... D1')],
           length=280)>`, type: `method`

labels.get_locs, expected value: `<bound method MultiIndex.get_l ... D1')],
           length=280)>`, type: `method`

## Expected case 7
### Input parameter value and type
key, value: `(slice('A1', 'A3', None), slice(None, None, None), slice('C1', 'C3', None))`, type: `tuple`

self.obj, value: `               0
A0 B0 C0 D0    0
         D1    1
      C1 D0    2
         D1    3
      C2 D0    4
...          ...
A4 B6 C1 D1  275
      C2 D0  276
         D1  277
      C3 D0  278
         D1  279

[280 rows x 1 columns]`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1155182c0>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### Expected variable value and type before function return
labels, expected value: `array of shape (280,)`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_ ... D1')],
           length=280)>`, type: `method`

locs, expected value: `array of shape (126,)`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_l ... D1')],
           length=280)>`, type: `method`

indexer, expected value: `array of shape 2`, type: `list`

## Expected case 8
### Input parameter value and type
key, value: `(slice(None, None, None), slice(None, None, None))`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x115513950>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### Expected variable value and type before function return
labels, expected value: `MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

locs, expected value: `array([0, 1, 2, 3])`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

indexer, expected value: `[array([0, 1, 2, 3]), slice(None, None, None)]`, type: `list`

## Expected case 9
### Input parameter value and type
key, value: `(slice(None, None, None), slice(None, None, None))`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1155176d0>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### Expected variable value and type before function return
labels, expected value: `MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

locs, expected value: `array([0, 1, 2, 3])`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

indexer, expected value: `[array([0, 1, 2, 3]), slice(None, None, None)]`, type: `list`

## Expected case 10
### Input parameter value and type
key, value: `(slice(None, None, None), slice(None, None, None))`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1155176d0>`, type: `_LocIndexer`

axis, value: `1`, type: `int`

self.ndim, value: `2`, type: `int`

### Expected variable value and type before function return
labels, expected value: `MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

locs, expected value: `array([0, 1, 2, 3])`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

indexer, expected value: `[slice(None, None, None), array([0, 1, 2, 3])]`, type: `list`

## Expected case 11
### Input parameter value and type
key, value: `(slice(None, None, None), slice(None, None, None))`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x115520720>`, type: `_LocIndexer`

axis, value: `1`, type: `int`

self.ndim, value: `2`, type: `int`

### Expected variable value and type before function return
labels, expected value: `MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

locs, expected value: `array([0, 1, 2, 3])`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

indexer, expected value: `[slice(None, None, None), array([0, 1, 2, 3])]`, type: `list`

## Expected case 12
### Input parameter value and type
key, value: `(slice(None, None, None), [1])`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x115520ea0>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### Expected variable value and type before function return
labels, expected value: `MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

locs, expected value: `array([0, 3])`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

indexer, expected value: `[array([0, 3]), slice(None, None, None)]`, type: `list`

## Expected case 13
### Input parameter value and type
key, value: `(slice(None, None, None), 1)`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x11550e220>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### Expected variable value and type before function return
labels, expected value: `MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

locs, expected value: `array([0, 3])`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

indexer, expected value: `[array([0, 3]), slice(None, None, None)]`, type: `list`

## Expected case 14
### Input parameter value and type
key, value: `(slice(None, None, None), ['foo'])`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1152c2450>`, type: `_LocIndexer`

axis, value: `1`, type: `int`

self.ndim, value: `2`, type: `int`

### Expected variable value and type before function return
labels, expected value: `MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

locs, expected value: `array([1, 3])`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

indexer, expected value: `[slice(None, None, None), array([1, 3])]`, type: `list`

## Expected case 15
### Input parameter value and type
key, value: `(slice(None, None, None), 1)`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x115517950>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### Expected variable value and type before function return
labels, expected value: `MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

locs, expected value: `array([0, 3])`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

indexer, expected value: `[array([0, 3]), slice(None, None, None)]`, type: `list`

## Expected case 16
### Input parameter value and type
key, value: `(slice(None, None, None), ['foo'])`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x115517950>`, type: `_LocIndexer`

axis, value: `1`, type: `int`

self.ndim, value: `2`, type: `int`

### Expected variable value and type before function return
labels, expected value: `MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

locs, expected value: `array([1, 3])`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

indexer, expected value: `[slice(None, None, None), array([1, 3])]`, type: `list`

## Expected case 17
### Input parameter value and type
key, value: `'A'`, type: `str`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x11550e220>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### Expected variable value and type before function return
labels, expected value: `MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

## Expected case 18
### Input parameter value and type
key, value: `'a'`, type: `str`

self.obj, value: `lvl0   a       b    
lvl1 bar foo bah foo
two                 
1      1   0   3   2
2      5   4   7   6
3      9   8  11  10`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1152c2450>`, type: `_LocIndexer`

axis, value: `1`, type: `int`

self.ndim, value: `2`, type: `int`

### Expected variable value and type before function return
labels, expected value: `MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

## Expected case 19
### Input parameter value and type
key, value: `(slice(None, None, None), [1, 2])`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1152c2450>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### Expected variable value and type before function return
labels, expected value: `MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

locs, expected value: `array([0, 1, 3])`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

indexer, expected value: `[array([0, 1, 3]), slice(None, None, None)]`, type: `list`

## Expected case 20
### Input parameter value and type
key, value: `(slice('A1', 'A3', None), slice(None, None, None), ['C1', 'C3'])`, type: `tuple`

self.obj, value: `A0  B0  C0  D0      0
            D1      1
        C1  D0      2
            D1      3
        C2  D0      4
                 ... 
A4  B6  C1  D1    275
        C2  D0    276
            D1    277
        C3  D0    278
            D1    279
Length: 280, dtype: int64`, type: `Series`

self, value: `<pandas.core.indexing._LocIndexer object at 0x115520b80>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `1`, type: `int`

### Expected variable value and type before function return
labels, expected value: `array of shape (280,)`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_ ... D1')],
           length=280)>`, type: `method`

locs, expected value: `array([ 58,  59,  62,  63,  66,  67,  70,  71,  74,  75,  78,  79,  82,
        83,  86,  87,  90,  91,  94,  95,  98,  99, 102, 103, 106, 107,
       110, 111, 114, 115, 118, 119, 122, 123, 126, 127, 130, 131, 134,
       135, 138, 139, 142, 143, 146, 147, 150, 151, 154, 155, 158, 159,
       162, 163, 166, 167, 170, 171, 174, 175, 178, 179, 182, 183, 186,
       187, 190, 191, 194, 195, 198, 199, 202, 203, 206, 207, 210, 211,
       214, 215, 218, 219, 222, 223])`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_l ... D1')],
           length=280)>`, type: `method`

indexer, expected value: `[array([ 58,  59,  62,  63,  66,  67,  70,  71,  74,  75,  78,  79,  82,
        83,  86,  87,  90,  91,  94,  95,  98,  99, 102, 103, 106, 107,
       110, 111, 114, 115, 118, 119, 122, 123, 126, 127, 130, 131, 134,
       135, 138, 139, 142, 143, 146, 147, 150, 151, 154, 155, 158, 159,
       162, 163, 166, 167, 170, 171, 174, 175, 178, 179, 182, 183, 186,
       187, 190, 191, 194, 195, 198, 199, 202, 203, 206, 207, 210, 211,
       214, 215, 218, 219, 222, 223])]`, type: `list`

## Expected case 21
### Input parameter value and type
key, value: `array of shape 84`, type: `list`

self.obj, value: `A0  B0  C0  D0      0
            D1      1
        C1  D0      2
            D1      3
        C2  D0      4
                 ... 
A4  B6  C1  D1    275
        C2  D0    276
            D1    277
        C3  D0    278
            D1    279
Length: 280, dtype: int64`, type: `Series`

self, value: `<pandas.core.indexing._LocIndexer object at 0x115513680>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `1`, type: `int`

### Expected variable value and type before function return
labels, expected value: `array of shape (280,)`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_ ... D1')],
           length=280)>`, type: `method`

labels.get_locs, expected value: `<bound method MultiIndex.get_l ... D1')],
           length=280)>`, type: `method`

## Expected case 22
### Input parameter value and type
key, value: `('a', 'bar')`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x11550d7c0>`, type: `_LocIndexer`

axis, value: `1`, type: `int`

self.ndim, value: `2`, type: `int`

### Expected variable value and type before function return
labels, expected value: `MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

## Expected case 23
### Input parameter value and type
key, value: `(slice(None, None, None), one  two
A    1      False
     2      False
     3       True
B    1       True
Name: (a, bar), dtype: bool)`, type: `tuple`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1155133b0>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `2`, type: `int`

### Expected variable value and type before function return
labels, expected value: `MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

locs, expected value: `array([2, 3])`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([('A', 1),
            ('A', 2),
            ('A', 3),
            ('B', 1)],
           names=['one', 'two'])>`, type: `method`

indexer, expected value: `[array([2, 3]), slice(None, None, None)]`, type: `list`

## Expected case 24
### Input parameter value and type
key, value: `[1]`, type: `list`

self.obj, value: `lvl0      a       b    
lvl1    bar foo bah foo
one two                
A   1     1   0   3   2
    2     5   4   7   6
    3     9   8  11  10
B   1    13  12  15  14`, type: `DataFrame`

self, value: `<pandas.core.indexing._LocIndexer object at 0x11550e4a0>`, type: `_LocIndexer`

axis, value: `1`, type: `int`

self.ndim, value: `2`, type: `int`

### Expected variable value and type before function return
key, expected value: `([1],)`, type: `tuple`

labels, expected value: `MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

locs, expected value: `array([], dtype=int64)`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([('a', 'bar'),
            ('a', 'foo'),
            ('b', 'bah'),
            ('b', 'foo')],
           names=['lvl0', 'lvl1'])>`, type: `method`

indexer, expected value: `[slice(None, None, None), array([], dtype=int64)]`, type: `list`

## Expected case 25
### Input parameter value and type
key, value: `[5]`, type: `list`

self.obj, value: `0  2000-01-03    11
   2000-01-04    10
   2000-01-05     9
1  2000-01-03     8
   2000-01-04     7
   2000-01-05     6
2  2000-01-03     5
   2000-01-04     4
   2000-01-05     3
3  2000-01-03     2
   2000-01-04     1
   2000-01-05     0
dtype: int64`, type: `Series`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1153b0040>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `1`, type: `int`

### Expected variable value and type before function return
key, expected value: `([5],)`, type: `tuple`

labels, expected value: `MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`

locs, expected value: `array([], dtype=int64)`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`

indexer, expected value: `[array([], dtype=int64)]`, type: `list`

## Expected case 26
### Input parameter value and type
key, value: `array([5])`, type: `ndarray`

self.obj, value: `0  2000-01-03    11
   2000-01-04    10
   2000-01-05     9
1  2000-01-03     8
   2000-01-04     7
   2000-01-05     6
2  2000-01-03     5
   2000-01-04     4
   2000-01-05     3
3  2000-01-03     2
   2000-01-04     1
   2000-01-05     0
dtype: int64`, type: `Series`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1153a9e50>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

key.ndim, value: `1`, type: `int`

self.ndim, value: `1`, type: `int`

### Expected variable value and type before function return
key, expected value: `([5],)`, type: `tuple`

labels, expected value: `MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`

locs, expected value: `array([], dtype=int64)`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`

indexer, expected value: `[array([], dtype=int64)]`, type: `list`

## Expected case 27
### Input parameter value and type
key, value: `Int64Index([5], dtype='int64')`, type: `Int64Index`

self.obj, value: `0  2000-01-03    11
   2000-01-04    10
   2000-01-05     9
1  2000-01-03     8
   2000-01-04     7
   2000-01-05     6
2  2000-01-03     5
   2000-01-04     4
   2000-01-05     3
3  2000-01-03     2
   2000-01-04     1
   2000-01-05     0
dtype: int64`, type: `Series`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1153a94a0>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

key.ndim, value: `1`, type: `int`

self.ndim, value: `1`, type: `int`

### Expected variable value and type before function return
key, expected value: `(Int64Index([5], dtype='int64'),)`, type: `tuple`

labels, expected value: `MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`

locs, expected value: `array([], dtype=int64)`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`

indexer, expected value: `[array([], dtype=int64)]`, type: `list`

## Expected case 28
### Input parameter value and type
key, value: `[5]`, type: `list`

self.obj, value: `0.0  2000-01-03    11
     2000-01-04    10
     2000-01-05     9
1.0  2000-01-03     8
     2000-01-04     7
     2000-01-05     6
2.0  2000-01-03     5
     2000-01-04     4
     2000-01-05     3
3.0  2000-01-03     2
     2000-01-04     1
     2000-01-05     0
dtype: int64`, type: `Series`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1153a8630>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `1`, type: `int`

### Expected variable value and type before function return
key, expected value: `([5],)`, type: `tuple`

labels, expected value: `MultiIndex([(0.0, '2000-01-03'),
            (0.0, '2000-01-04'),
            (0.0, '2000-01-05'),
            (1.0, '2000-01-03'),
            (1.0, '2000-01-04'),
            (1.0, '2000-01-05'),
            (2.0, '2000-01-03'),
            (2.0, '2000-01-04'),
            (2.0, '2000-01-05'),
            (3.0, '2000-01-03'),
            (3.0, '2000-01-04'),
            (3.0, '2000-01-05')],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(0.0, '2000-01-03'),
            (0.0, '2000-01-04'),
            (0.0, '2000-01-05'),
            (1.0, '2000-01-03'),
            (1.0, '2000-01-04'),
            (1.0, '2000-01-05'),
            (2.0, '2000-01-03'),
            (2.0, '2000-01-04'),
            (2.0, '2000-01-05'),
            (3.0, '2000-01-03'),
            (3.0, '2000-01-04'),
            (3.0, '2000-01-05')],
           )>`, type: `method`

locs, expected value: `array([], dtype=int64)`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([(0.0, '2000-01-03'),
            (0.0, '2000-01-04'),
            (0.0, '2000-01-05'),
            (1.0, '2000-01-03'),
            (1.0, '2000-01-04'),
            (1.0, '2000-01-05'),
            (2.0, '2000-01-03'),
            (2.0, '2000-01-04'),
            (2.0, '2000-01-05'),
            (3.0, '2000-01-03'),
            (3.0, '2000-01-04'),
            (3.0, '2000-01-05')],
           )>`, type: `method`

indexer, expected value: `[array([], dtype=int64)]`, type: `list`

## Expected case 29
### Input parameter value and type
key, value: `array([5])`, type: `ndarray`

self.obj, value: `0.0  2000-01-03    11
     2000-01-04    10
     2000-01-05     9
1.0  2000-01-03     8
     2000-01-04     7
     2000-01-05     6
2.0  2000-01-03     5
     2000-01-04     4
     2000-01-05     3
3.0  2000-01-03     2
     2000-01-04     1
     2000-01-05     0
dtype: int64`, type: `Series`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1153b82c0>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

key.ndim, value: `1`, type: `int`

self.ndim, value: `1`, type: `int`

### Expected variable value and type before function return
key, expected value: `([5],)`, type: `tuple`

labels, expected value: `MultiIndex([(0.0, '2000-01-03'),
            (0.0, '2000-01-04'),
            (0.0, '2000-01-05'),
            (1.0, '2000-01-03'),
            (1.0, '2000-01-04'),
            (1.0, '2000-01-05'),
            (2.0, '2000-01-03'),
            (2.0, '2000-01-04'),
            (2.0, '2000-01-05'),
            (3.0, '2000-01-03'),
            (3.0, '2000-01-04'),
            (3.0, '2000-01-05')],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(0.0, '2000-01-03'),
            (0.0, '2000-01-04'),
            (0.0, '2000-01-05'),
            (1.0, '2000-01-03'),
            (1.0, '2000-01-04'),
            (1.0, '2000-01-05'),
            (2.0, '2000-01-03'),
            (2.0, '2000-01-04'),
            (2.0, '2000-01-05'),
            (3.0, '2000-01-03'),
            (3.0, '2000-01-04'),
            (3.0, '2000-01-05')],
           )>`, type: `method`

locs, expected value: `array([], dtype=int64)`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([(0.0, '2000-01-03'),
            (0.0, '2000-01-04'),
            (0.0, '2000-01-05'),
            (1.0, '2000-01-03'),
            (1.0, '2000-01-04'),
            (1.0, '2000-01-05'),
            (2.0, '2000-01-03'),
            (2.0, '2000-01-04'),
            (2.0, '2000-01-05'),
            (3.0, '2000-01-03'),
            (3.0, '2000-01-04'),
            (3.0, '2000-01-05')],
           )>`, type: `method`

indexer, expected value: `[array([], dtype=int64)]`, type: `list`

## Expected case 30
### Input parameter value and type
key, value: `Int64Index([5], dtype='int64')`, type: `Int64Index`

self.obj, value: `0.0  2000-01-03    11
     2000-01-04    10
     2000-01-05     9
1.0  2000-01-03     8
     2000-01-04     7
     2000-01-05     6
2.0  2000-01-03     5
     2000-01-04     4
     2000-01-05     3
3.0  2000-01-03     2
     2000-01-04     1
     2000-01-05     0
dtype: int64`, type: `Series`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1153b8f40>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

key.ndim, value: `1`, type: `int`

self.ndim, value: `1`, type: `int`

### Expected variable value and type before function return
key, expected value: `(Int64Index([5], dtype='int64'),)`, type: `tuple`

labels, expected value: `MultiIndex([(0.0, '2000-01-03'),
            (0.0, '2000-01-04'),
            (0.0, '2000-01-05'),
            (1.0, '2000-01-03'),
            (1.0, '2000-01-04'),
            (1.0, '2000-01-05'),
            (2.0, '2000-01-03'),
            (2.0, '2000-01-04'),
            (2.0, '2000-01-05'),
            (3.0, '2000-01-03'),
            (3.0, '2000-01-04'),
            (3.0, '2000-01-05')],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(0.0, '2000-01-03'),
            (0.0, '2000-01-04'),
            (0.0, '2000-01-05'),
            (1.0, '2000-01-03'),
            (1.0, '2000-01-04'),
            (1.0, '2000-01-05'),
            (2.0, '2000-01-03'),
            (2.0, '2000-01-04'),
            (2.0, '2000-01-05'),
            (3.0, '2000-01-03'),
            (3.0, '2000-01-04'),
            (3.0, '2000-01-05')],
           )>`, type: `method`

locs, expected value: `array([], dtype=int64)`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([(0.0, '2000-01-03'),
            (0.0, '2000-01-04'),
            (0.0, '2000-01-05'),
            (1.0, '2000-01-03'),
            (1.0, '2000-01-04'),
            (1.0, '2000-01-05'),
            (2.0, '2000-01-03'),
            (2.0, '2000-01-04'),
            (2.0, '2000-01-05'),
            (3.0, '2000-01-03'),
            (3.0, '2000-01-04'),
            (3.0, '2000-01-05')],
           )>`, type: `method`

indexer, expected value: `[array([], dtype=int64)]`, type: `list`

## Expected case 31
### Input parameter value and type
key, value: `[5]`, type: `list`

self.obj, value: `0  2000-01-03    11
   2000-01-04    10
   2000-01-05     9
1  2000-01-03     8
   2000-01-04     7
   2000-01-05     6
2  2000-01-03     5
   2000-01-04     4
   2000-01-05     3
3  2000-01-03     2
   2000-01-04     1
   2000-01-05     0
dtype: int64`, type: `Series`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1154b2400>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

self.ndim, value: `1`, type: `int`

### Expected variable value and type before function return
key, expected value: `([5],)`, type: `tuple`

labels, expected value: `MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`

locs, expected value: `array([], dtype=int64)`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`

indexer, expected value: `[array([], dtype=int64)]`, type: `list`

## Expected case 32
### Input parameter value and type
key, value: `array([5])`, type: `ndarray`

self.obj, value: `0  2000-01-03    11
   2000-01-04    10
   2000-01-05     9
1  2000-01-03     8
   2000-01-04     7
   2000-01-05     6
2  2000-01-03     5
   2000-01-04     4
   2000-01-05     3
3  2000-01-03     2
   2000-01-04     1
   2000-01-05     0
dtype: int64`, type: `Series`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1154c9e00>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

key.ndim, value: `1`, type: `int`

self.ndim, value: `1`, type: `int`

### Expected variable value and type before function return
key, expected value: `([5],)`, type: `tuple`

labels, expected value: `MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`

locs, expected value: `array([], dtype=int64)`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`

indexer, expected value: `[array([], dtype=int64)]`, type: `list`

## Expected case 33
### Input parameter value and type
key, value: `Int64Index([5], dtype='int64')`, type: `Int64Index`

self.obj, value: `0  2000-01-03    11
   2000-01-04    10
   2000-01-05     9
1  2000-01-03     8
   2000-01-04     7
   2000-01-05     6
2  2000-01-03     5
   2000-01-04     4
   2000-01-05     3
3  2000-01-03     2
   2000-01-04     1
   2000-01-05     0
dtype: int64`, type: `Series`

self, value: `<pandas.core.indexing._LocIndexer object at 0x1153b88b0>`, type: `_LocIndexer`

axis, value: `0`, type: `int`

key.ndim, value: `1`, type: `int`

self.ndim, value: `1`, type: `int`

### Expected variable value and type before function return
key, expected value: `(Int64Index([5], dtype='int64'),)`, type: `tuple`

labels, expected value: `MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )`, type: `MultiIndex`

labels._get_partial_string_timestamp_match_key, expected value: `<bound method MultiIndex._get_partial_string_timestamp_match_key of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`

locs, expected value: `array([], dtype=int64)`, type: `ndarray`

labels.get_locs, expected value: `<bound method MultiIndex.get_locs of MultiIndex([(0, '2000-01-03'),
            (0, '2000-01-04'),
            (0, '2000-01-05'),
            (1, '2000-01-03'),
            (1, '2000-01-04'),
            (1, '2000-01-05'),
            (2, '2000-01-03'),
            (2, '2000-01-04'),
            (2, '2000-01-05'),
            (3, '2000-01-03'),
            (3, '2000-01-04'),
            (3, '2000-01-05')],
           )>`, type: `method`

indexer, expected value: `[array([], dtype=int64)]`, type: `list`



# A test function for the buggy function
```python
# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_19/pandas/tests/indexing/multiindex/test_loc.py

    @pytest.mark.parametrize("key, pos", [([2, 4], [0, 1]), ([2], []), ([2, 3], [])])
    def test_loc_multiindex_list_missing_label(self, key, pos):
        # GH 27148 - lists with missing labels _do_ raise
        df = DataFrame(
            np.random.randn(3, 3),
            columns=[[2, 2, 4], [6, 8, 10]],
            index=[[4, 4, 8], [8, 10, 12]],
        )

        with pytest.raises(KeyError, match="not in index"):
            df.loc[key]
```

## Error message from test function
```text
self = <pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc object at 0x114beb4c0>
key = [2, 4], pos = [0, 1]

    @pytest.mark.parametrize("key, pos", [([2, 4], [0, 1]), ([2], []), ([2, 3], [])])
    def test_loc_multiindex_list_missing_label(self, key, pos):
        # GH 27148 - lists with missing labels _do_ raise
        df = DataFrame(
            np.random.randn(3, 3),
            columns=[[2, 2, 4], [6, 8, 10]],
            index=[[4, 4, 8], [8, 10, 12]],
        )
    
        with pytest.raises(KeyError, match="not in index"):
>           df.loc[key]
E           Failed: DID NOT RAISE <class 'KeyError'>

pandas/tests/indexing/multiindex/test_loc.py:145: Failed

```
# A test function for the buggy function
```python
# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_19/pandas/tests/indexing/multiindex/test_loc.py

    @pytest.mark.parametrize("key, pos", [([2, 4], [0, 1]), ([2], []), ([2, 3], [])])
    def test_loc_multiindex_list_missing_label(self, key, pos):
        # GH 27148 - lists with missing labels _do_ raise
        df = DataFrame(
            np.random.randn(3, 3),
            columns=[[2, 2, 4], [6, 8, 10]],
            index=[[4, 4, 8], [8, 10, 12]],
        )

        with pytest.raises(KeyError, match="not in index"):
            df.loc[key]
```

## Error message from test function
```text
self = <pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc object at 0x114c2d0a0>
key = [2], pos = []

    @pytest.mark.parametrize("key, pos", [([2, 4], [0, 1]), ([2], []), ([2, 3], [])])
    def test_loc_multiindex_list_missing_label(self, key, pos):
        # GH 27148 - lists with missing labels _do_ raise
        df = DataFrame(
            np.random.randn(3, 3),
            columns=[[2, 2, 4], [6, 8, 10]],
            index=[[4, 4, 8], [8, 10, 12]],
        )
    
        with pytest.raises(KeyError, match="not in index"):
>           df.loc[key]
E           Failed: DID NOT RAISE <class 'KeyError'>

pandas/tests/indexing/multiindex/test_loc.py:145: Failed

```
# A test function for the buggy function
```python
# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_19/pandas/tests/indexing/multiindex/test_loc.py

    @pytest.mark.parametrize("key, pos", [([2, 4], [0, 1]), ([2], []), ([2, 3], [])])
    def test_loc_multiindex_list_missing_label(self, key, pos):
        # GH 27148 - lists with missing labels _do_ raise
        df = DataFrame(
            np.random.randn(3, 3),
            columns=[[2, 2, 4], [6, 8, 10]],
            index=[[4, 4, 8], [8, 10, 12]],
        )

        with pytest.raises(KeyError, match="not in index"):
            df.loc[key]
```

## Error message from test function
```text
self = <pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc object at 0x114d52f40>
key = [2, 3], pos = []

    @pytest.mark.parametrize("key, pos", [([2, 4], [0, 1]), ([2], []), ([2, 3], [])])
    def test_loc_multiindex_list_missing_label(self, key, pos):
        # GH 27148 - lists with missing labels _do_ raise
        df = DataFrame(
            np.random.randn(3, 3),
            columns=[[2, 2, 4], [6, 8, 10]],
            index=[[4, 4, 8], [8, 10, 12]],
        )
    
        with pytest.raises(KeyError, match="not in index"):
>           df.loc[key]
E           Failed: DID NOT RAISE <class 'KeyError'>

pandas/tests/indexing/multiindex/test_loc.py:145: Failed

```
# A test function for the buggy function
```python
# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_19/pandas/tests/indexing/multiindex/test_slice.py

    def test_per_axis_per_level_getitem(self):

        # GH6134
        # example test case
        ix = MultiIndex.from_product(
            [_mklbl("A", 5), _mklbl("B", 7), _mklbl("C", 4), _mklbl("D", 2)]
        )
        df = DataFrame(np.arange(len(ix.to_numpy())), index=ix)

        result = df.loc[(slice("A1", "A3"), slice(None), ["C1", "C3"]), :]
        expected = df.loc[
            [
                tuple([a, b, c, d])
                for a, b, c, d in df.index.values
                if (a == "A1" or a == "A2" or a == "A3") and (c == "C1" or c == "C3")
            ]
        ]
        tm.assert_frame_equal(result, expected)

        expected = df.loc[
            [
                tuple([a, b, c, d])
                for a, b, c, d in df.index.values
                if (a == "A1" or a == "A2" or a == "A3")
                and (c == "C1" or c == "C2" or c == "C3")
            ]
        ]
        result = df.loc[(slice("A1", "A3"), slice(None), slice("C1", "C3")), :]
        tm.assert_frame_equal(result, expected)

        # test multi-index slicing with per axis and per index controls
        index = MultiIndex.from_tuples(
            [("A", 1), ("A", 2), ("A", 3), ("B", 1)], names=["one", "two"]
        )
        columns = MultiIndex.from_tuples(
            [("a", "foo"), ("a", "bar"), ("b", "foo"), ("b", "bah")],
            names=["lvl0", "lvl1"],
        )

        df = DataFrame(
            np.arange(16, dtype="int64").reshape(4, 4), index=index, columns=columns
        )
        df = df.sort_index(axis=0).sort_index(axis=1)

        # identity
        result = df.loc[(slice(None), slice(None)), :]
        tm.assert_frame_equal(result, df)
        result = df.loc[(slice(None), slice(None)), (slice(None), slice(None))]
        tm.assert_frame_equal(result, df)
        result = df.loc[:, (slice(None), slice(None))]
        tm.assert_frame_equal(result, df)

        # index
        result = df.loc[(slice(None), [1]), :]
        expected = df.iloc[[0, 3]]
        tm.assert_frame_equal(result, expected)

        result = df.loc[(slice(None), 1), :]
        expected = df.iloc[[0, 3]]
        tm.assert_frame_equal(result, expected)

        # columns
        result = df.loc[:, (slice(None), ["foo"])]
        expected = df.iloc[:, [1, 3]]
        tm.assert_frame_equal(result, expected)

        # both
        result = df.loc[(slice(None), 1), (slice(None), ["foo"])]
        expected = df.iloc[[0, 3], [1, 3]]
        tm.assert_frame_equal(result, expected)

        result = df.loc["A", "a"]
        expected = DataFrame(
            dict(bar=[1, 5, 9], foo=[0, 4, 8]),
            index=Index([1, 2, 3], name="two"),
            columns=Index(["bar", "foo"], name="lvl1"),
        )
        tm.assert_frame_equal(result, expected)

        result = df.loc[(slice(None), [1, 2]), :]
        expected = df.iloc[[0, 1, 3]]
        tm.assert_frame_equal(result, expected)

        # multi-level series
        s = Series(np.arange(len(ix.to_numpy())), index=ix)
        result = s.loc["A1":"A3", :, ["C1", "C3"]]
        expected = s.loc[
            [
                tuple([a, b, c, d])
                for a, b, c, d in s.index.values
                if (a == "A1" or a == "A2" or a == "A3") and (c == "C1" or c == "C3")
            ]
        ]
        tm.assert_series_equal(result, expected)

        # boolean indexers
        result = df.loc[(slice(None), df.loc[:, ("a", "bar")] > 5), :]
        expected = df.iloc[[2, 3]]
        tm.assert_frame_equal(result, expected)

        msg = (
            "cannot index with a boolean indexer "
            "that is not the same length as the index"
        )
        with pytest.raises(ValueError, match=msg):
            df.loc[(slice(None), np.array([True, False])), :]

        with pytest.raises(KeyError, match=r"\[1\] not in index"):
            # slice(None) is on the index, [1] is on the columns, but 1 is
            #  not in the columns, so we raise
            #  This used to treat [1] as positional GH#16396
            df.loc[slice(None), [1]]

        result = df.loc[(slice(None), [1]), :]
        expected = df.iloc[[0, 3]]
        tm.assert_frame_equal(result, expected)

        # not lexsorted
        assert df.index.lexsort_depth == 2
        df = df.sort_index(level=1, axis=0)
        assert df.index.lexsort_depth == 0

        msg = (
            "MultiIndex slicing requires the index to be "
            r"lexsorted: slicing on levels \[1\], lexsort depth 0"
        )
        with pytest.raises(UnsortedIndexError, match=msg):
            df.loc[(slice(None), slice("bar")), :]

        # GH 16734: not sorted, but no real slicing
        result = df.loc[(slice(None), df.loc[:, ("a", "bar")] > 5), :]
        tm.assert_frame_equal(result, df.iloc[[1, 3], :])
```

## Error message from test function
```text
self = <pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers object at 0x114d65610>

    def test_per_axis_per_level_getitem(self):
    
        # GH6134
        # example test case
        ix = MultiIndex.from_product(
            [_mklbl("A", 5), _mklbl("B", 7), _mklbl("C", 4), _mklbl("D", 2)]
        )
        df = DataFrame(np.arange(len(ix.to_numpy())), index=ix)
    
        result = df.loc[(slice("A1", "A3"), slice(None), ["C1", "C3"]), :]
        expected = df.loc[
            [
                tuple([a, b, c, d])
                for a, b, c, d in df.index.values
                if (a == "A1" or a == "A2" or a == "A3") and (c == "C1" or c == "C3")
            ]
        ]
        tm.assert_frame_equal(result, expected)
    
        expected = df.loc[
            [
                tuple([a, b, c, d])
                for a, b, c, d in df.index.values
                if (a == "A1" or a == "A2" or a == "A3")
                and (c == "C1" or c == "C2" or c == "C3")
            ]
        ]
        result = df.loc[(slice("A1", "A3"), slice(None), slice("C1", "C3")), :]
        tm.assert_frame_equal(result, expected)
    
        # test multi-index slicing with per axis and per index controls
        index = MultiIndex.from_tuples(
            [("A", 1), ("A", 2), ("A", 3), ("B", 1)], names=["one", "two"]
        )
        columns = MultiIndex.from_tuples(
            [("a", "foo"), ("a", "bar"), ("b", "foo"), ("b", "bah")],
            names=["lvl0", "lvl1"],
        )
    
        df = DataFrame(
            np.arange(16, dtype="int64").reshape(4, 4), index=index, columns=columns
        )
        df = df.sort_index(axis=0).sort_index(axis=1)
    
        # identity
        result = df.loc[(slice(None), slice(None)), :]
        tm.assert_frame_equal(result, df)
        result = df.loc[(slice(None), slice(None)), (slice(None), slice(None))]
        tm.assert_frame_equal(result, df)
        result = df.loc[:, (slice(None), slice(None))]
        tm.assert_frame_equal(result, df)
    
        # index
        result = df.loc[(slice(None), [1]), :]
        expected = df.iloc[[0, 3]]
        tm.assert_frame_equal(result, expected)
    
        result = df.loc[(slice(None), 1), :]
        expected = df.iloc[[0, 3]]
        tm.assert_frame_equal(result, expected)
    
        # columns
        result = df.loc[:, (slice(None), ["foo"])]
        expected = df.iloc[:, [1, 3]]
        tm.assert_frame_equal(result, expected)
    
        # both
        result = df.loc[(slice(None), 1), (slice(None), ["foo"])]
        expected = df.iloc[[0, 3], [1, 3]]
        tm.assert_frame_equal(result, expected)
    
        result = df.loc["A", "a"]
        expected = DataFrame(
            dict(bar=[1, 5, 9], foo=[0, 4, 8]),
            index=Index([1, 2, 3], name="two"),
            columns=Index(["bar", "foo"], name="lvl1"),
        )
        tm.assert_frame_equal(result, expected)
    
        result = df.loc[(slice(None), [1, 2]), :]
        expected = df.iloc[[0, 1, 3]]
        tm.assert_frame_equal(result, expected)
    
        # multi-level series
        s = Series(np.arange(len(ix.to_numpy())), index=ix)
        result = s.loc["A1":"A3", :, ["C1", "C3"]]
        expected = s.loc[
            [
                tuple([a, b, c, d])
                for a, b, c, d in s.index.values
                if (a == "A1" or a == "A2" or a == "A3") and (c == "C1" or c == "C3")
            ]
        ]
        tm.assert_series_equal(result, expected)
    
        # boolean indexers
        result = df.loc[(slice(None), df.loc[:, ("a", "bar")] > 5), :]
        expected = df.iloc[[2, 3]]
        tm.assert_frame_equal(result, expected)
    
        msg = (
            "cannot index with a boolean indexer "
            "that is not the same length as the index"
        )
        with pytest.raises(ValueError, match=msg):
            df.loc[(slice(None), np.array([True, False])), :]
    
        with pytest.raises(KeyError, match=r"\[1\] not in index"):
            # slice(None) is on the index, [1] is on the columns, but 1 is
            #  not in the columns, so we raise
            #  This used to treat [1] as positional GH#16396
>           df.loc[slice(None), [1]]
E           Failed: DID NOT RAISE <class 'KeyError'>

pandas/tests/indexing/multiindex/test_slice.py:125: Failed

```
# A test function for the buggy function
```python
# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_19/pandas/tests/series/indexing/test_getitem.py

    @pytest.mark.parametrize("box", [list, np.array, pd.Index])
    @pytest.mark.parametrize("dtype", [np.int64, np.float64, np.uint64])
    def test_getitem_intlist_multiindex_numeric_level(self, dtype, box):
        # GH#33404 do _not_ fall back to positional since ints are ambiguous
        idx = pd.Index(range(4)).astype(dtype)
        dti = date_range("2000-01-03", periods=3)
        mi = pd.MultiIndex.from_product([idx, dti])
        ser = Series(range(len(mi))[::-1], index=mi)

        key = box([5])
        with pytest.raises(KeyError, match="5"):
            ser[key]
```

## Error message from test function
```text
self = <pandas.tests.series.indexing.test_getitem.TestSeriesGetitemListLike object at 0x114d52370>
dtype = <class 'numpy.int64'>, box = <class 'list'>

    @pytest.mark.parametrize("box", [list, np.array, pd.Index])
    @pytest.mark.parametrize("dtype", [np.int64, np.float64, np.uint64])
    def test_getitem_intlist_multiindex_numeric_level(self, dtype, box):
        # GH#33404 do _not_ fall back to positional since ints are ambiguous
        idx = pd.Index(range(4)).astype(dtype)
        dti = date_range("2000-01-03", periods=3)
        mi = pd.MultiIndex.from_product([idx, dti])
        ser = Series(range(len(mi))[::-1], index=mi)
    
        key = box([5])
        with pytest.raises(KeyError, match="5"):
>           ser[key]
E           Failed: DID NOT RAISE <class 'KeyError'>

pandas/tests/series/indexing/test_getitem.py:128: Failed

```
# A test function for the buggy function
```python
# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_19/pandas/tests/series/indexing/test_getitem.py

    @pytest.mark.parametrize("box", [list, np.array, pd.Index])
    @pytest.mark.parametrize("dtype", [np.int64, np.float64, np.uint64])
    def test_getitem_intlist_multiindex_numeric_level(self, dtype, box):
        # GH#33404 do _not_ fall back to positional since ints are ambiguous
        idx = pd.Index(range(4)).astype(dtype)
        dti = date_range("2000-01-03", periods=3)
        mi = pd.MultiIndex.from_product([idx, dti])
        ser = Series(range(len(mi))[::-1], index=mi)

        key = box([5])
        with pytest.raises(KeyError, match="5"):
            ser[key]
```

## Error message from test function
```text
self = <pandas.tests.series.indexing.test_getitem.TestSeriesGetitemListLike object at 0x114d08160>
dtype = <class 'numpy.int64'>, box = <built-in function array>

    @pytest.mark.parametrize("box", [list, np.array, pd.Index])
    @pytest.mark.parametrize("dtype", [np.int64, np.float64, np.uint64])
    def test_getitem_intlist_multiindex_numeric_level(self, dtype, box):
        # GH#33404 do _not_ fall back to positional since ints are ambiguous
        idx = pd.Index(range(4)).astype(dtype)
        dti = date_range("2000-01-03", periods=3)
        mi = pd.MultiIndex.from_product([idx, dti])
        ser = Series(range(len(mi))[::-1], index=mi)
    
        key = box([5])
        with pytest.raises(KeyError, match="5"):
>           ser[key]
E           Failed: DID NOT RAISE <class 'KeyError'>

pandas/tests/series/indexing/test_getitem.py:128: Failed

```
# A test function for the buggy function
```python
# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_19/pandas/tests/series/indexing/test_getitem.py

    @pytest.mark.parametrize("box", [list, np.array, pd.Index])
    @pytest.mark.parametrize("dtype", [np.int64, np.float64, np.uint64])
    def test_getitem_intlist_multiindex_numeric_level(self, dtype, box):
        # GH#33404 do _not_ fall back to positional since ints are ambiguous
        idx = pd.Index(range(4)).astype(dtype)
        dti = date_range("2000-01-03", periods=3)
        mi = pd.MultiIndex.from_product([idx, dti])
        ser = Series(range(len(mi))[::-1], index=mi)

        key = box([5])
        with pytest.raises(KeyError, match="5"):
            ser[key]
```

## Error message from test function
```text
self = <pandas.tests.series.indexing.test_getitem.TestSeriesGetitemListLike object at 0x114d5bd00>
dtype = <class 'numpy.int64'>, box = <class 'pandas.core.indexes.base.Index'>

    @pytest.mark.parametrize("box", [list, np.array, pd.Index])
    @pytest.mark.parametrize("dtype", [np.int64, np.float64, np.uint64])
    def test_getitem_intlist_multiindex_numeric_level(self, dtype, box):
        # GH#33404 do _not_ fall back to positional since ints are ambiguous
        idx = pd.Index(range(4)).astype(dtype)
        dti = date_range("2000-01-03", periods=3)
        mi = pd.MultiIndex.from_product([idx, dti])
        ser = Series(range(len(mi))[::-1], index=mi)
    
        key = box([5])
        with pytest.raises(KeyError, match="5"):
>           ser[key]
E           Failed: DID NOT RAISE <class 'KeyError'>

pandas/tests/series/indexing/test_getitem.py:128: Failed

```
# A test function for the buggy function
```python
# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_19/pandas/tests/series/indexing/test_getitem.py

    @pytest.mark.parametrize("box", [list, np.array, pd.Index])
    @pytest.mark.parametrize("dtype", [np.int64, np.float64, np.uint64])
    def test_getitem_intlist_multiindex_numeric_level(self, dtype, box):
        # GH#33404 do _not_ fall back to positional since ints are ambiguous
        idx = pd.Index(range(4)).astype(dtype)
        dti = date_range("2000-01-03", periods=3)
        mi = pd.MultiIndex.from_product([idx, dti])
        ser = Series(range(len(mi))[::-1], index=mi)

        key = box([5])
        with pytest.raises(KeyError, match="5"):
            ser[key]
```

## Error message from test function
```text
self = <pandas.tests.series.indexing.test_getitem.TestSeriesGetitemListLike object at 0x114e6c250>
dtype = <class 'numpy.float64'>, box = <class 'list'>

    @pytest.mark.parametrize("box", [list, np.array, pd.Index])
    @pytest.mark.parametrize("dtype", [np.int64, np.float64, np.uint64])
    def test_getitem_intlist_multiindex_numeric_level(self, dtype, box):
        # GH#33404 do _not_ fall back to positional since ints are ambiguous
        idx = pd.Index(range(4)).astype(dtype)
        dti = date_range("2000-01-03", periods=3)
        mi = pd.MultiIndex.from_product([idx, dti])
        ser = Series(range(len(mi))[::-1], index=mi)
    
        key = box([5])
        with pytest.raises(KeyError, match="5"):
>           ser[key]
E           Failed: DID NOT RAISE <class 'KeyError'>

pandas/tests/series/indexing/test_getitem.py:128: Failed

```
# A test function for the buggy function
```python
# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_19/pandas/tests/series/indexing/test_getitem.py

    @pytest.mark.parametrize("box", [list, np.array, pd.Index])
    @pytest.mark.parametrize("dtype", [np.int64, np.float64, np.uint64])
    def test_getitem_intlist_multiindex_numeric_level(self, dtype, box):
        # GH#33404 do _not_ fall back to positional since ints are ambiguous
        idx = pd.Index(range(4)).astype(dtype)
        dti = date_range("2000-01-03", periods=3)
        mi = pd.MultiIndex.from_product([idx, dti])
        ser = Series(range(len(mi))[::-1], index=mi)

        key = box([5])
        with pytest.raises(KeyError, match="5"):
            ser[key]
```

## Error message from test function
```text
self = <pandas.tests.series.indexing.test_getitem.TestSeriesGetitemListLike object at 0x114dd1400>
dtype = <class 'numpy.float64'>, box = <built-in function array>

    @pytest.mark.parametrize("box", [list, np.array, pd.Index])
    @pytest.mark.parametrize("dtype", [np.int64, np.float64, np.uint64])
    def test_getitem_intlist_multiindex_numeric_level(self, dtype, box):
        # GH#33404 do _not_ fall back to positional since ints are ambiguous
        idx = pd.Index(range(4)).astype(dtype)
        dti = date_range("2000-01-03", periods=3)
        mi = pd.MultiIndex.from_product([idx, dti])
        ser = Series(range(len(mi))[::-1], index=mi)
    
        key = box([5])
        with pytest.raises(KeyError, match="5"):
>           ser[key]
E           Failed: DID NOT RAISE <class 'KeyError'>

pandas/tests/series/indexing/test_getitem.py:128: Failed

```
# A test function for the buggy function
```python
# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_19/pandas/tests/series/indexing/test_getitem.py

    @pytest.mark.parametrize("box", [list, np.array, pd.Index])
    @pytest.mark.parametrize("dtype", [np.int64, np.float64, np.uint64])
    def test_getitem_intlist_multiindex_numeric_level(self, dtype, box):
        # GH#33404 do _not_ fall back to positional since ints are ambiguous
        idx = pd.Index(range(4)).astype(dtype)
        dti = date_range("2000-01-03", periods=3)
        mi = pd.MultiIndex.from_product([idx, dti])
        ser = Series(range(len(mi))[::-1], index=mi)

        key = box([5])
        with pytest.raises(KeyError, match="5"):
            ser[key]
```

## Error message from test function
```text
self = <pandas.tests.series.indexing.test_getitem.TestSeriesGetitemListLike object at 0x114d5b0d0>
dtype = <class 'numpy.float64'>, box = <class 'pandas.core.indexes.base.Index'>

    @pytest.mark.parametrize("box", [list, np.array, pd.Index])
    @pytest.mark.parametrize("dtype", [np.int64, np.float64, np.uint64])
    def test_getitem_intlist_multiindex_numeric_level(self, dtype, box):
        # GH#33404 do _not_ fall back to positional since ints are ambiguous
        idx = pd.Index(range(4)).astype(dtype)
        dti = date_range("2000-01-03", periods=3)
        mi = pd.MultiIndex.from_product([idx, dti])
        ser = Series(range(len(mi))[::-1], index=mi)
    
        key = box([5])
        with pytest.raises(KeyError, match="5"):
>           ser[key]
E           Failed: DID NOT RAISE <class 'KeyError'>

pandas/tests/series/indexing/test_getitem.py:128: Failed

```
# A test function for the buggy function
```python
# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_19/pandas/tests/series/indexing/test_getitem.py

    @pytest.mark.parametrize("box", [list, np.array, pd.Index])
    @pytest.mark.parametrize("dtype", [np.int64, np.float64, np.uint64])
    def test_getitem_intlist_multiindex_numeric_level(self, dtype, box):
        # GH#33404 do _not_ fall back to positional since ints are ambiguous
        idx = pd.Index(range(4)).astype(dtype)
        dti = date_range("2000-01-03", periods=3)
        mi = pd.MultiIndex.from_product([idx, dti])
        ser = Series(range(len(mi))[::-1], index=mi)

        key = box([5])
        with pytest.raises(KeyError, match="5"):
            ser[key]
```

## Error message from test function
```text
self = <pandas.tests.series.indexing.test_getitem.TestSeriesGetitemListLike object at 0x114dd1970>
dtype = <class 'numpy.uint64'>, box = <class 'list'>

    @pytest.mark.parametrize("box", [list, np.array, pd.Index])
    @pytest.mark.parametrize("dtype", [np.int64, np.float64, np.uint64])
    def test_getitem_intlist_multiindex_numeric_level(self, dtype, box):
        # GH#33404 do _not_ fall back to positional since ints are ambiguous
        idx = pd.Index(range(4)).astype(dtype)
        dti = date_range("2000-01-03", periods=3)
        mi = pd.MultiIndex.from_product([idx, dti])
        ser = Series(range(len(mi))[::-1], index=mi)
    
        key = box([5])
        with pytest.raises(KeyError, match="5"):
>           ser[key]
E           Failed: DID NOT RAISE <class 'KeyError'>

pandas/tests/series/indexing/test_getitem.py:128: Failed

```
# A test function for the buggy function
```python
# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_19/pandas/tests/series/indexing/test_getitem.py

    @pytest.mark.parametrize("box", [list, np.array, pd.Index])
    @pytest.mark.parametrize("dtype", [np.int64, np.float64, np.uint64])
    def test_getitem_intlist_multiindex_numeric_level(self, dtype, box):
        # GH#33404 do _not_ fall back to positional since ints are ambiguous
        idx = pd.Index(range(4)).astype(dtype)
        dti = date_range("2000-01-03", periods=3)
        mi = pd.MultiIndex.from_product([idx, dti])
        ser = Series(range(len(mi))[::-1], index=mi)

        key = box([5])
        with pytest.raises(KeyError, match="5"):
            ser[key]
```

## Error message from test function
```text
self = <pandas.tests.series.indexing.test_getitem.TestSeriesGetitemListLike object at 0x114d48700>
dtype = <class 'numpy.uint64'>, box = <built-in function array>

    @pytest.mark.parametrize("box", [list, np.array, pd.Index])
    @pytest.mark.parametrize("dtype", [np.int64, np.float64, np.uint64])
    def test_getitem_intlist_multiindex_numeric_level(self, dtype, box):
        # GH#33404 do _not_ fall back to positional since ints are ambiguous
        idx = pd.Index(range(4)).astype(dtype)
        dti = date_range("2000-01-03", periods=3)
        mi = pd.MultiIndex.from_product([idx, dti])
        ser = Series(range(len(mi))[::-1], index=mi)
    
        key = box([5])
        with pytest.raises(KeyError, match="5"):
>           ser[key]
E           Failed: DID NOT RAISE <class 'KeyError'>

pandas/tests/series/indexing/test_getitem.py:128: Failed

```
# A test function for the buggy function
```python
# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_19/pandas/tests/series/indexing/test_getitem.py

    @pytest.mark.parametrize("box", [list, np.array, pd.Index])
    @pytest.mark.parametrize("dtype", [np.int64, np.float64, np.uint64])
    def test_getitem_intlist_multiindex_numeric_level(self, dtype, box):
        # GH#33404 do _not_ fall back to positional since ints are ambiguous
        idx = pd.Index(range(4)).astype(dtype)
        dti = date_range("2000-01-03", periods=3)
        mi = pd.MultiIndex.from_product([idx, dti])
        ser = Series(range(len(mi))[::-1], index=mi)

        key = box([5])
        with pytest.raises(KeyError, match="5"):
            ser[key]
```

## Error message from test function
```text
self = <pandas.tests.series.indexing.test_getitem.TestSeriesGetitemListLike object at 0x114d52eb0>
dtype = <class 'numpy.uint64'>, box = <class 'pandas.core.indexes.base.Index'>

    @pytest.mark.parametrize("box", [list, np.array, pd.Index])
    @pytest.mark.parametrize("dtype", [np.int64, np.float64, np.uint64])
    def test_getitem_intlist_multiindex_numeric_level(self, dtype, box):
        # GH#33404 do _not_ fall back to positional since ints are ambiguous
        idx = pd.Index(range(4)).astype(dtype)
        dti = date_range("2000-01-03", periods=3)
        mi = pd.MultiIndex.from_product([idx, dti])
        ser = Series(range(len(mi))[::-1], index=mi)
    
        key = box([5])
        with pytest.raises(KeyError, match="5"):
>           ser[key]
E           Failed: DID NOT RAISE <class 'KeyError'>

pandas/tests/series/indexing/test_getitem.py:128: Failed

```


# Instructions

1. Analyze the test case and its relationship with the error message, if applicable.
2. Identify the potential error location within the problematic function.
3. Explain the reasons behind the occurrence of the bug.
4. Suggest possible approaches for fixing the bug.
5. Present the corrected code for the problematic function.