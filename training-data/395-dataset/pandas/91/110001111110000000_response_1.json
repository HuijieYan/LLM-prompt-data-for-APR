{
    "pandas": [
        {
            "bugID": 91,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 1,
                "5": 0,
                "6": 0,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 0,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 1,
                "5": 0,
                "6": 0,
                "7": 0
            },
            "start_line": 356,
            "file_name": "pandas/core/indexes/timedeltas.py",
            "replace_code": "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    searchsorted(self, value, side='left', sorter=None)\n\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted TimedeltaIndex that would allow the insertion\n    of the given datetime data while maintaining order.\n\n    .. versionadded:: 1.2.0  # pragma: no cover\n\n    Parameters\n    ----------\n    value : object\n        The value or values to insert.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given. If\n        'right', return the last such index. If there is no suitable index,\n        return either 0 or N (where N is the length of data).\n    sorter : array-like of int or None, optional\n        The array of indices that define the sorted ordering. If None, then the\n        indices are inferred from the data.\n\n    Returns\n    -------\n    ndarray of int\n        An array of insertion points.\n\n    See Also\n    --------\n    Series.searchsorted : Similar method for Series or Index.\n    DataFrame.searchsorted : Equivalent method for DataFrame.\n    numpy.searchsorted : Equivalent function for NumPy arrays.\n    \"\"\"\n    if isinstance(value, (np.ndarray, Index)):\n        value = np.array(value, dtype=\"timedelta64[ns]\")  # Force to timedelta64 for consistency\n    else:\n        value = pd.Timedelta(value).to_timedelta64()  # Convert other types to timedelta64 for consistency\n\n    return self.values.searchsorted(value, side=side, sorter=sorter)",
            "imports": []
        }
    ]
}