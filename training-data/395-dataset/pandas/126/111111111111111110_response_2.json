{
    "pandas": [
        {
            "bugID": 126,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 1,
                "2.1.4": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 1,
                "3": 1,
                "4": 1,
                "5": 1,
                "6": 1,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 1,
                "3": 1,
                "4": 1,
                "5": 1,
                "6": 1,
                "7": 0
            },
            "start_line": 6822,
            "file_name": "pandas/core/frame.py",
            "replace_code": "def append(self, other, ignore_index=False, verify_integrity=False, sort=None):\n        \"\"\"\n        Append rows of `other` to the end of caller, returning a new object.\n\n        Columns in `other` that are not in the caller are added as new columns.\n\n        Parameters\n        ----------\n        other : DataFrame or Series/dict-like object, or list of these\n            The data to append.\n        ignore_index : bool, default False\n            If True, do not use the index labels.\n        verify_integrity : bool, default False\n            If True, raise ValueError on creating index with duplicates.\n        sort : bool, default None\n            Sort columns if the columns of `self` and `other` are not aligned.\n            The default sorting is deprecated and will change to not-sorting\n            in a future version of pandas. Explicitly pass ``sort=True`` to\n            silence the warning and sort. Explicitly pass ``sort=False`` to\n            silence the warning and not sort.\n\n            .. versionadded:: 0.23.0\n\n        Returns\n        -------\n        DataFrame\n\n        See Also\n        --------\n        concat : General function to concatenate DataFrame or Series objects.\n\n        Notes\n        -----\n        If a list of dict/series is passed and the keys are all contained in\n        the DataFrame's index, the order of the columns in the resulting\n        DataFrame will be unchanged.\n\n        Iteratively appending rows to a DataFrame can be more computationally\n        intensive than a single concatenate. A better solution is to append\n        those rows to a list and then concatenate the list with the original\n        DataFrame all at once.\n\n        Examples\n        --------\n\n        >>> df = pd.DataFrame([[1, 2], [3, 4]], columns=list('AB'))\n        >>> df\n           A  B\n        0  1  2\n        1  3  4\n        >>> df2 = pd.DataFrame([[5, 6], [7, 8]], columns=list('AB'))\n        >>> df.append(df2)\n           A  B\n        0  1  2\n        1  3  4\n        0  5  6\n        1  7  8\n\n        With `ignore_index` set to True:\n\n        >>> df.append(df2, ignore_index=True)\n           A  B\n        0  1  2\n        1  3  4\n        2  5  6\n        3  7  8\n\n        The following, while not recommended methods for generating DataFrames,\n        show two ways to generate a DataFrame from multiple data sources.\n\n        Less efficient:\n\n        >>> df = pd.DataFrame(columns=['A'])\n        >>> for i in range(5):\n        ...     df = df.append({'A': i}, ignore_index=True)\n        >>> df\n           A\n        0  0\n        1  1\n        2  2\n        3  3\n        4  4\n\n        More efficient:\n\n        >>> pd.concat([pd.DataFrame([i], columns=['A']) for i in range(5)],\n        ...           ignore_index=True)\n           A\n        0  0\n        1  1\n        2  2\n        3  3\n        4  4\n        \"\"\"\n        if isinstance(other, (Series, dict)):\n            if isinstance(other, dict):\n                other = Series(other)\n            if other.name is None and not ignore_index:\n                raise TypeError(\n                    \"Can only append a Series if ignore_index=True\"\n                    \" or if the Series has a name\"\n                )\n\n            if other.name is None:\n                index = None\n            else:\n                # other must have the same index name as self, otherwise\n                # index name will be reset\n                index = Index([other.name], name=self.index.name)\n\n            if isinstance(other, Series):\n                other = DataFrame(other).T\n            elif np.isscalar(other):\n                other = DataFrame([other], index=index, columns=self.columns)\n            else:\n                if isinstance(other, DataFrame):\n                    # other must have at least one column. If other has more than one\n                    # column, validate the column names\n\n                    scols = other.columns\n                    if len(scols) == 0:  # pragma: no cover\n                        raise ValueError(\"No valid DataFrame. Either it is empty or contains only Axis/Index objects\")\n\n                    common_idx = self._get_common_index(other)\n                    # ensure the dtype for the other is matched\n                    # or it is a datelike so that we don't downcast the dtypes in\n                    # the resulting DataFrame object\n                    if len(common_idx) < len(scols) or self.columns.equals(other.columns):\n                        other = other._convert(datetime=True, timedelta=True, copy=True)\n                        # first align using .reindex\n                        other = other.reindex(\n                            self.columns if isinstance(other, DataFrame) else self.columns.union(other.columns),\n                            copy=False,\n                        )\n            if self.columns.eye(0, 1).empty and not self.columns.is_numeric():\n                self = self.convert_dtypes(infer_objects=False)\n\n            # it's possible that the other has different columns and that the columns\n            # should be set to different types\n            combined_columns = self.columns.join(other.columns, how=\"outer\")\n            column_dtypes = self.dtypes.combine_first(other.dtypes)\n            if not other.columns.equals(combined_columns):\n                other = other.reindex(columns=combined_columns)\n                # in case columns se is a dict\n                other.columns = combined_columns\n\n            # which is a major content error.let's raise an error early.\n            self._consolidate_inplace()\n\n            self = self._combine_frame(other, value)  # For data, etc.\n            self.unify_dtype = unify_dtype\n\n            # indexers are copied from the newly combined DataFrame\n\n            if index:\n                index = index.get_level_values(0)\n            else:\n                index = self.index\n            # New columns may be in place\n            nd = self.values.copy()\n            self = DataFrame(nd, index=self.index)\n            other = other._convert(datetime=True, timedelta=True)\n\n            if not callable(self):\n                self = getattr(self, \"convert_to_type\")(dtype)\n                other = getattr(other, \"convert_to_type\")(dtype)\n\n            if not other.columns.equals(self.columns):\n                other = other.reindex(columns=self.columns)\n\n        if isinstance(other, (list, tuple)):\n            to_concat = [self] + other\n        else:\n            to_concat = [self, other]\n        return concat(\n            to_concat,\n            ignore_index=ignore_index,\n            verify_integrity=verify_integrity,\n            sort=sort,\n        )",
            "imports": []
        }
    ]
}