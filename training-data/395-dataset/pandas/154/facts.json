{
    "1.1.1": "def _get_cythonized_result(\n    self,\n    how,\n    grouper,\n    aggregate=False,\n    cython_dtype=None,\n    needs_values=False,\n    needs_mask=False,\n    needs_ngroups=False,\n    result_is_index=False,\n    pre_processing=None,\n    post_processing=None,\n    **kwargs\n):\n    \n    if result_is_index and aggregate:\n        raise ValueError(\"'result_is_index' and 'aggregate' cannot both be True!\")\n    if post_processing:\n        if not callable(pre_processing):\n            raise ValueError(\"'post_processing' must be a callable!\")\n    if pre_processing:\n        if not callable(pre_processing):\n            raise ValueError(\"'pre_processing' must be a callable!\")\n        if not needs_values:\n            raise ValueError(\n                \"Cannot use 'pre_processing' without specifying 'needs_values'!\"\n            )\n\n    labels, _, ngroups = grouper.group_info\n    output = collections.OrderedDict()\n    base_func = getattr(libgroupby, how)\n\n    for name, obj in self._iterate_slices():\n        if aggregate:\n            result_sz = ngroups\n        else:\n            result_sz = len(obj.values)\n\n        if not cython_dtype:\n            cython_dtype = obj.values.dtype\n\n        result = np.zeros(result_sz, dtype=cython_dtype)\n        func = partial(base_func, result, labels)\n        inferences = None\n\n        if needs_values:\n            vals = obj.values\n            if pre_processing:\n                vals, inferences = pre_processing(vals)\n            func = partial(func, vals)\n\n        if needs_mask:\n            mask = isna(obj.values).view(np.uint8)\n            func = partial(func, mask)\n\n        if needs_ngroups:\n            func = partial(func, ngroups)\n\n        func(**kwargs)  # Call func to modify indexer values in place\n\n        if result_is_index:\n            result = algorithms.take_nd(obj.values, result)\n\n        if post_processing:\n            result = post_processing(result, inferences)\n\n        output[name] = result\n\n    if aggregate:\n        return self._wrap_aggregated_output(output)\n    else:\n        return self._wrap_transformed_output(output)\n",
    "1.1.2": "Get result for Cythonized functions.\n\nParameters\n----------\nhow : str, Cythonized function name to be called\ngrouper : Grouper object containing pertinent group info\naggregate : bool, default False\n    Whether the result should be aggregated to match the number of\n    groups\ncython_dtype : default None\n    Type of the array that will be modified by the Cython call. If\n    `None`, the type will be inferred from the values of each slice\nneeds_values : bool, default False\n    Whether the values should be a part of the Cython call\n    signature\nneeds_mask : bool, default False\n    Whether boolean mask needs to be part of the Cython call\n    signature\nneeds_ngroups : bool, default False\n    Whether number of groups is part of the Cython call signature\nresult_is_index : bool, default False\n    Whether the result of the Cython operation is an index of\n    values to be retrieved, instead of the actual values themselves\npre_processing : function, default None\n    Function to be applied to `values` prior to passing to Cython.\n    Function should return a tuple where the first element is the\n    values to be passed to Cython and the second element is an optional\n    type which the values should be converted to after being returned\n    by the Cython operation. Raises if `needs_values` is False.\npost_processing : function, default None\n    Function to be applied to result of Cython function. Should accept\n    an array of values as the first argument and type inferences as its\n    second argument, i.e. the signature should be\n    (ndarray, Type).\n**kwargs : dict\n    Extra arguments to be passed back to Cython funcs\n\nReturns\n-------\n`Series` or `DataFrame`  with filled values",
    "1.2.1": "class GroupBy(_GroupBy)",
    "1.2.2": "Class for grouping and aggregating relational data.\n\nSee aggregate, transform, and apply functions on this object.\n\nIt's easiest to use obj.groupby(...) to use GroupBy, but you can also do:\n\n::\n\n    grouped = groupby(obj, ...)\n\nParameters\n----------\nobj : pandas object\naxis : int, default 0\nlevel : int, default None\n    Level of MultiIndex\ngroupings : list of Grouping objects\n    Most users should ignore this\nexclusions : array-like, optional\n    List of columns to exclude\nname : string\n    Most users should ignore this\n\nReturns\n-------\n**Attributes**\ngroups : dict\n    {group name -> group labels}\nlen(grouped) : int\n    Number of groups\n\nNotes\n-----\nAfter grouping, see aggregate, apply, and transform functions. Here are\nsome other brief notes about usage. When grouping by multiple groups, the\nresult index will be a MultiIndex (hierarchical) by default.\n\nIteration produces (key, group) tuples, i.e. chunking the data by group. So\nyou can write code like:\n\n::\n\n    grouped = obj.groupby(keys, axis=axis)\n    for key, group in grouped:\n        # do something with the data\n\nFunction calls on GroupBy, if not specially implemented, \"dispatch\" to the\ngrouped data. So if you group a DataFrame and wish to invoke the std()\nmethod on each group, you can simply do:\n\n::\n\n    df.groupby(mapper).std()\n\nrather than\n\n::\n\n    df.groupby(mapper).aggregate(np.std)\n\nYou can pass arguments to these \"wrapped\" functions, too.\n\nSee the online documentation for full exposition on these topics and much\nmore",
    "1.2.3": null,
    "1.3.1": "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/core/groupby/groupby.py",
    "1.3.2": [
        "ngroups(self)",
        "_iterate_slices(self)"
    ],
    "1.4.1": [
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"op, expected\",\n    [\n        (\n            \"shift\",\n            {\n                \"time\": [\n                    None,\n                    None,\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    None,\n                    None,\n                ]\n            },\n        ),\n        (\n            \"bfill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n        (\n            \"ffill\",\n            {\n                \"time\": [\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 12:00:00\"),\n                    Timestamp(\"2019-01-01 12:30:00\"),\n                    Timestamp(\"2019-01-01 14:00:00\"),\n                    Timestamp(\"2019-01-01 14:30:00\"),\n                ]\n            },\n        ),\n    ],\n)\ndef test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n    # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n    tz = tz_naive_fixture\n    data = {\n        \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n        \"time\": [\n            Timestamp(\"2019-01-01 12:00:00\"),\n            Timestamp(\"2019-01-01 12:30:00\"),\n            None,\n            None,\n            Timestamp(\"2019-01-01 14:00:00\"),\n            Timestamp(\"2019-01-01 14:30:00\"),\n        ],\n    }\n    df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n\n    grouped = df.groupby(\"id\")\n    result = getattr(grouped, op)()\n    expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    assert_frame_equal(result, expected)"
    ],
    "1.4.2": [
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_154/pandas/tests/groupby/test_groupby.py"
    ],
    "2.1.1": [
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, UTC]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, UTC]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, UTC]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, US/Eastern]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, US/Eastern]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, US/Eastern]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, Asia/Tokyo]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, Asia/Tokyo]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, Asia/Tokyo]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, tzutc()]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, tzutc()]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, tzutc()]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, tzlocal()]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, tzlocal()]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, tzlocal()]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, pytz.FixedOffset(300)]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, pytz.FixedOffset(300)]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, pytz.FixedOffset(300)]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, UTC]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, UTC]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, UTC]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, pytz.FixedOffset(-300)]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, pytz.FixedOffset(-300)]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, pytz.FixedOffset(-300)]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, UTC]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, UTC]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, UTC]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, UTC+01:00]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, UTC+01:00]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, UTC+01:00]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, foo]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, foo]"
        ],
        [
            "E       AssertionError: Attributes are different\nE       \nE       Attribute \"dtype\" are different\nE       [left]:  datetime64[ns]\nE       [right]: datetime64[ns, foo]"
        ]
    ],
    "2.1.2": [
        [
            "tz_naive_fixture = 'UTC', op = 'shift'\nexpected =                        time\n0                       NaT\n1                       NaT\n2 2019-01-01 12:00:00+00:00\n3 2019-01-01 12:30:00+00:00\n4                       NaT\n5                       NaT\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = 'UTC', op = 'bfill'\nexpected =                        time\n0 2019-01-01 12:00:00+00:00\n1 2019-01-01 12:30:00+00:00\n2 2019-01-01 14:00:00+00:00\n3 2019-01-01 14:30:00+00:00\n4 2019-01-01 14:00:00+00:00\n5 2019-01-01 14:30:00+00:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = 'UTC', op = 'ffill'\nexpected =                        time\n0 2019-01-01 12:00:00+00:00\n1 2019-01-01 12:30:00+00:00\n2 2019-01-01 12:00:00+00:00\n3 2019-01-01 12:30:00+00:00\n4 2019-01-01 14:00:00+00:00\n5 2019-01-01 14:30:00+00:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = 'US/Eastern', op = 'shift'\nexpected =                        time\n0                       NaT\n1                       NaT\n2 2019-01-01 12:00:00-05:00\n3 2019-01-01 12:30:00-05:00\n4                       NaT\n5                       NaT\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = 'US/Eastern', op = 'bfill'\nexpected =                        time\n0 2019-01-01 12:00:00-05:00\n1 2019-01-01 12:30:00-05:00\n2 2019-01-01 14:00:00-05:00\n3 2019-01-01 14:30:00-05:00\n4 2019-01-01 14:00:00-05:00\n5 2019-01-01 14:30:00-05:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = 'US/Eastern', op = 'ffill'\nexpected =                        time\n0 2019-01-01 12:00:00-05:00\n1 2019-01-01 12:30:00-05:00\n2 2019-01-01 12:00:00-05:00\n3 2019-01-01 12:30:00-05:00\n4 2019-01-01 14:00:00-05:00\n5 2019-01-01 14:30:00-05:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = 'Asia/Tokyo', op = 'shift'\nexpected =                        time\n0                       NaT\n1                       NaT\n2 2019-01-01 12:00:00+09:00\n3 2019-01-01 12:30:00+09:00\n4                       NaT\n5                       NaT\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = 'Asia/Tokyo', op = 'bfill'\nexpected =                        time\n0 2019-01-01 12:00:00+09:00\n1 2019-01-01 12:30:00+09:00\n2 2019-01-01 14:00:00+09:00\n3 2019-01-01 14:30:00+09:00\n4 2019-01-01 14:00:00+09:00\n5 2019-01-01 14:30:00+09:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = 'Asia/Tokyo', op = 'ffill'\nexpected =                        time\n0 2019-01-01 12:00:00+09:00\n1 2019-01-01 12:30:00+09:00\n2 2019-01-01 12:00:00+09:00\n3 2019-01-01 12:30:00+09:00\n4 2019-01-01 14:00:00+09:00\n5 2019-01-01 14:30:00+09:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = 'dateutil/US/Pacific', op = 'shift'\nexpected =                        time\n0                       NaT\n1                       NaT\n2 2019-01-01 12:00:00-08:00\n3 2019-01-01 12:30:00-08:00\n4                       NaT\n5                       NaT\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = 'dateutil/US/Pacific', op = 'bfill'\nexpected =                        time\n0 2019-01-01 12:00:00-08:00\n1 2019-01-01 12:30:00-08:00\n2 2019-01-01 14:00:00-08:00\n3 2019-01-01 14:30:00-08:00\n4 2019-01-01 14:00:00-08:00\n5 2019-01-01 14:30:00-08:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = 'dateutil/US/Pacific', op = 'ffill'\nexpected =                        time\n0 2019-01-01 12:00:00-08:00\n1 2019-01-01 12:30:00-08:00\n2 2019-01-01 12:00:00-08:00\n3 2019-01-01 12:30:00-08:00\n4 2019-01-01 14:00:00-08:00\n5 2019-01-01 14:30:00-08:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = 'dateutil/Asia/Singapore', op = 'shift'\nexpected =                        time\n0                       NaT\n1                       NaT\n2 2019-01-01 12:00:00+08:00\n3 2019-01-01 12:30:00+08:00\n4                       NaT\n5                       NaT\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = 'dateutil/Asia/Singapore', op = 'bfill'\nexpected =                        time\n0 2019-01-01 12:00:00+08:00\n1 2019-01-01 12:30:00+08:00\n2 2019-01-01 14:00:00+08:00\n3 2019-01-01 14:30:00+08:00\n4 2019-01-01 14:00:00+08:00\n5 2019-01-01 14:30:00+08:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = 'dateutil/Asia/Singapore', op = 'ffill'\nexpected =                        time\n0 2019-01-01 12:00:00+08:00\n1 2019-01-01 12:30:00+08:00\n2 2019-01-01 12:00:00+08:00\n3 2019-01-01 12:30:00+08:00\n4 2019-01-01 14:00:00+08:00\n5 2019-01-01 14:30:00+08:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = tzutc(), op = 'shift'\nexpected =                        time\n0                       NaT\n1                       NaT\n2 2019-01-01 12:00:00+00:00\n3 2019-01-01 12:30:00+00:00\n4                       NaT\n5                       NaT\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = tzutc(), op = 'bfill'\nexpected =                        time\n0 2019-01-01 12:00:00+00:00\n1 2019-01-01 12:30:00+00:00\n2 2019-01-01 14:00:00+00:00\n3 2019-01-01 14:30:00+00:00\n4 2019-01-01 14:00:00+00:00\n5 2019-01-01 14:30:00+00:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = tzutc(), op = 'ffill'\nexpected =                        time\n0 2019-01-01 12:00:00+00:00\n1 2019-01-01 12:30:00+00:00\n2 2019-01-01 12:00:00+00:00\n3 2019-01-01 12:30:00+00:00\n4 2019-01-01 14:00:00+00:00\n5 2019-01-01 14:30:00+00:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = tzlocal(), op = 'shift'\nexpected =                        time\n0                       NaT\n1                       NaT\n2 2019-01-01 12:00:00+00:00\n3 2019-01-01 12:30:00+00:00\n4                       NaT\n5                       NaT\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = tzlocal(), op = 'bfill'\nexpected =                        time\n0 2019-01-01 12:00:00+00:00\n1 2019-01-01 12:30:00+00:00\n2 2019-01-01 14:00:00+00:00\n3 2019-01-01 14:30:00+00:00\n4 2019-01-01 14:00:00+00:00\n5 2019-01-01 14:30:00+00:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = tzlocal(), op = 'ffill'\nexpected =                        time\n0 2019-01-01 12:00:00+00:00\n1 2019-01-01 12:30:00+00:00\n2 2019-01-01 12:00:00+00:00\n3 2019-01-01 12:30:00+00:00\n4 2019-01-01 14:00:00+00:00\n5 2019-01-01 14:30:00+00:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = pytz.FixedOffset(300), op = 'shift'\nexpected =                        time\n0                       NaT\n1                       NaT\n2 2019-01-01 12:00:00+05:00\n3 2019-01-01 12:30:00+05:00\n4                       NaT\n5                       NaT\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = pytz.FixedOffset(300), op = 'bfill'\nexpected =                        time\n0 2019-01-01 12:00:00+05:00\n1 2019-01-01 12:30:00+05:00\n2 2019-01-01 14:00:00+05:00\n3 2019-01-01 14:30:00+05:00\n4 2019-01-01 14:00:00+05:00\n5 2019-01-01 14:30:00+05:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = pytz.FixedOffset(300), op = 'ffill'\nexpected =                        time\n0 2019-01-01 12:00:00+05:00\n1 2019-01-01 12:30:00+05:00\n2 2019-01-01 12:00:00+05:00\n3 2019-01-01 12:30:00+05:00\n4 2019-01-01 14:00:00+05:00\n5 2019-01-01 14:30:00+05:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = <UTC>, op = 'shift'\nexpected =                        time\n0                       NaT\n1                       NaT\n2 2019-01-01 12:00:00+00:00\n3 2019-01-01 12:30:00+00:00\n4                       NaT\n5                       NaT\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = <UTC>, op = 'bfill'\nexpected =                        time\n0 2019-01-01 12:00:00+00:00\n1 2019-01-01 12:30:00+00:00\n2 2019-01-01 14:00:00+00:00\n3 2019-01-01 14:30:00+00:00\n4 2019-01-01 14:00:00+00:00\n5 2019-01-01 14:30:00+00:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = <UTC>, op = 'ffill'\nexpected =                        time\n0 2019-01-01 12:00:00+00:00\n1 2019-01-01 12:30:00+00:00\n2 2019-01-01 12:00:00+00:00\n3 2019-01-01 12:30:00+00:00\n4 2019-01-01 14:00:00+00:00\n5 2019-01-01 14:30:00+00:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = pytz.FixedOffset(-300), op = 'shift'\nexpected =                        time\n0                       NaT\n1                       NaT\n2 2019-01-01 12:00:00-05:00\n3 2019-01-01 12:30:00-05:00\n4                       NaT\n5                       NaT\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = pytz.FixedOffset(-300), op = 'bfill'\nexpected =                        time\n0 2019-01-01 12:00:00-05:00\n1 2019-01-01 12:30:00-05:00\n2 2019-01-01 14:00:00-05:00\n3 2019-01-01 14:30:00-05:00\n4 2019-01-01 14:00:00-05:00\n5 2019-01-01 14:30:00-05:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = pytz.FixedOffset(-300), op = 'ffill'\nexpected =                        time\n0 2019-01-01 12:00:00-05:00\n1 2019-01-01 12:30:00-05:00\n2 2019-01-01 12:00:00-05:00\n3 2019-01-01 12:30:00-05:00\n4 2019-01-01 14:00:00-05:00\n5 2019-01-01 14:30:00-05:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = datetime.timezone.utc, op = 'shift'\nexpected =                        time\n0                       NaT\n1                       NaT\n2 2019-01-01 12:00:00+00:00\n3 2019-01-01 12:30:00+00:00\n4                       NaT\n5                       NaT\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = datetime.timezone.utc, op = 'bfill'\nexpected =                        time\n0 2019-01-01 12:00:00+00:00\n1 2019-01-01 12:30:00+00:00\n2 2019-01-01 14:00:00+00:00\n3 2019-01-01 14:30:00+00:00\n4 2019-01-01 14:00:00+00:00\n5 2019-01-01 14:30:00+00:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = datetime.timezone.utc, op = 'ffill'\nexpected =                        time\n0 2019-01-01 12:00:00+00:00\n1 2019-01-01 12:30:00+00:00\n2 2019-01-01 12:00:00+00:00\n3 2019-01-01 12:30:00+00:00\n4 2019-01-01 14:00:00+00:00\n5 2019-01-01 14:30:00+00:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = datetime.timezone(datetime.timedelta(seconds=3600))\nop = 'shift'\nexpected =                        time\n0                       NaT\n1                       NaT\n2 2019-01-01 12:00:00+01:00\n3 2019-01-01 12:30:00+01:00\n4                       NaT\n5                       NaT\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = datetime.timezone(datetime.timedelta(seconds=3600))\nop = 'bfill'\nexpected =                        time\n0 2019-01-01 12:00:00+01:00\n1 2019-01-01 12:30:00+01:00\n2 2019-01-01 14:00:00+01:00\n3 2019-01-01 14:30:00+01:00\n4 2019-01-01 14:00:00+01:00\n5 2019-01-01 14:30:00+01:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = datetime.timezone(datetime.timedelta(seconds=3600))\nop = 'ffill'\nexpected =                        time\n0 2019-01-01 12:00:00+01:00\n1 2019-01-01 12:30:00+01:00\n2 2019-01-01 12:00:00+01:00\n3 2019-01-01 12:30:00+01:00\n4 2019-01-01 14:00:00+01:00\n5 2019-01-01 14:30:00+01:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = datetime.timezone(datetime.timedelta(days=-1, seconds=82800), 'foo')\nop = 'shift'\nexpected =                        time\n0                       NaT\n1                       NaT\n2 2019-01-01 12:00:00-01:00\n3 2019-01-01 12:30:00-01:00\n4                       NaT\n5                       NaT\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = datetime.timezone(datetime.timedelta(days=-1, seconds=82800), 'foo')\nop = 'bfill'\nexpected =                        time\n0 2019-01-01 12:00:00-01:00\n1 2019-01-01 12:30:00-01:00\n2 2019-01-01 14:00:00-01:00\n3 2019-01-01 14:30:00-01:00\n4 2019-01-01 14:00:00-01:00\n5 2019-01-01 14:30:00-01:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ],
        [
            "tz_naive_fixture = datetime.timezone(datetime.timedelta(days=-1, seconds=82800), 'foo')\nop = 'ffill'\nexpected =                        time\n0 2019-01-01 12:00:00-01:00\n1 2019-01-01 12:30:00-01:00\n2 2019-01-01 12:00:00-01:00\n3 2019-01-01 12:30:00-01:00\n4 2019-01-01 14:00:00-01:00\n5 2019-01-01 14:30:00-01:00\n\n    @pytest.mark.parametrize(\n        \"op, expected\",\n        [\n            (\n                \"shift\",\n                {\n                    \"time\": [\n                        None,\n                        None,\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        None,\n                        None,\n                    ]\n                },\n            ),\n            (\n                \"bfill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n            (\n                \"ffill\",\n                {\n                    \"time\": [\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 12:00:00\"),\n                        Timestamp(\"2019-01-01 12:30:00\"),\n                        Timestamp(\"2019-01-01 14:00:00\"),\n                        Timestamp(\"2019-01-01 14:30:00\"),\n                    ]\n                },\n            ),\n        ],\n    )\n    def test_shift_bfill_ffill_tz(tz_naive_fixture, op, expected):\n        # GH19995, GH27992: Check that timezone does not drop in shift, bfill, and ffill\n        tz = tz_naive_fixture\n        data = {\n            \"id\": [\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"],\n            \"time\": [\n                Timestamp(\"2019-01-01 12:00:00\"),\n                Timestamp(\"2019-01-01 12:30:00\"),\n                None,\n                None,\n                Timestamp(\"2019-01-01 14:00:00\"),\n                Timestamp(\"2019-01-01 14:30:00\"),\n            ],\n        }\n        df = DataFrame(data).assign(time=lambda x: x.time.dt.tz_localize(tz))\n    \n        grouped = df.groupby(\"id\")\n        result = getattr(grouped, op)()\n        expected = DataFrame(expected).assign(time=lambda x: x.time.dt.tz_localize(tz))\n>       assert_frame_equal(result, expected)",
            "\npandas/tests/groupby/test_groupby.py:1950: AssertionError"
        ]
    ],
    "2.1.3": [
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x120f900a0>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x120e45970>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array([                          'NaT',                           'NaT',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00\n1   2019-01-01 12:30:00\n2                   NaT\n3                   NaT\n4   2019-01-01 14:00:00\n5   2019-01-01 14:30:00\nName: time, dtype: datetime64[ns]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array([                          'NaT',                           'NaT',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x120f90160>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x120f90280>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00\n1   2019-01-01 12:30:00\n2                   NaT\n3                   NaT\n4   2019-01-01 14:00:00\n5   2019-01-01 14:30:00\nName: time, dtype: datetime64[ns]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x120f907c0>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x120f904c0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00\n1   2019-01-01 12:30:00\n2                   NaT\n3                   NaT\n4   2019-01-01 14:00:00\n5   2019-01-01 14:30:00\nName: time, dtype: datetime64[ns]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x120fd7af0>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x120fd7400>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array([                          'NaT',                           'NaT',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, UTC]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array([                          'NaT',                           'NaT',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x120fe3190>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x120fe3250>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, UTC]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x120e95f40>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x120dc9790>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, UTC]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x120f44220>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x120f44f40>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array([                          'NaT',                           'NaT',\n       '2019-01-01T17:00:00.000000000', '2019-01-01T17:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-05:00\n1   2019-01-01 12:30:00-05:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-05:00\n5   2019-01-01 14:30:00-05:00\nName: time, dtype: datetime64[ns, US/Eastern]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T17:00:00.000000000', '2019-01-01T17:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T19:00:00.000000000', '2019-01-01T19:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array([                          'NaT',                           'NaT',\n       '2019-01-01T17:00:00.000000000', '2019-01-01T17:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x120f51310>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x120f51970>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T17:00:00.000000000', '2019-01-01T17:30:00.000000000',\n       '2019-01-01T19:00:00.000000000', '2019-01-01T19:30:00.000000000',\n       '2019-01-01T19:00:00.000000000', '2019-01-01T19:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-05:00\n1   2019-01-01 12:30:00-05:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-05:00\n5   2019-01-01 14:30:00-05:00\nName: time, dtype: datetime64[ns, US/Eastern]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T17:00:00.000000000', '2019-01-01T17:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T19:00:00.000000000', '2019-01-01T19:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T17:00:00.000000000', '2019-01-01T17:30:00.000000000',\n       '2019-01-01T19:00:00.000000000', '2019-01-01T19:30:00.000000000',\n       '2019-01-01T19:00:00.000000000', '2019-01-01T19:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x120f90850>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x120f90430>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T17:00:00.000000000', '2019-01-01T17:30:00.000000000',\n       '2019-01-01T17:00:00.000000000', '2019-01-01T17:30:00.000000000',\n       '2019-01-01T19:00:00.000000000', '2019-01-01T19:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-05:00\n1   2019-01-01 12:30:00-05:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-05:00\n5   2019-01-01 14:30:00-05:00\nName: time, dtype: datetime64[ns, US/Eastern]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T17:00:00.000000000', '2019-01-01T17:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T19:00:00.000000000', '2019-01-01T19:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T17:00:00.000000000', '2019-01-01T17:30:00.000000000',\n       '2019-01-01T17:00:00.000000000', '2019-01-01T17:30:00.000000000',\n       '2019-01-01T19:00:00.000000000', '2019-01-01T19:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x121150cd0>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x1211504c0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array([                          'NaT',                           'NaT',\n       '2019-01-01T03:00:00.000000000', '2019-01-01T03:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+09:00\n1   2019-01-01 12:30:00+09:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+09:00\n5   2019-01-01 14:30:00+09:00\nName: time, dtype: datetime64[ns, Asia/Tokyo]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T03:00:00.000000000', '2019-01-01T03:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T05:00:00.000000000', '2019-01-01T05:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array([                          'NaT',                           'NaT',\n       '2019-01-01T03:00:00.000000000', '2019-01-01T03:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x120f902b0>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x120f905e0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T03:00:00.000000000', '2019-01-01T03:30:00.000000000',\n       '2019-01-01T05:00:00.000000000', '2019-01-01T05:30:00.000000000',\n       '2019-01-01T05:00:00.000000000', '2019-01-01T05:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+09:00\n1   2019-01-01 12:30:00+09:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+09:00\n5   2019-01-01 14:30:00+09:00\nName: time, dtype: datetime64[ns, Asia/Tokyo]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T03:00:00.000000000', '2019-01-01T03:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T05:00:00.000000000', '2019-01-01T05:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T03:00:00.000000000', '2019-01-01T03:30:00.000000000',\n       '2019-01-01T05:00:00.000000000', '2019-01-01T05:30:00.000000000',\n       '2019-01-01T05:00:00.000000000', '2019-01-01T05:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x120fe3520>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x120fe3640>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T03:00:00.000000000', '2019-01-01T03:30:00.000000000',\n       '2019-01-01T03:00:00.000000000', '2019-01-01T03:30:00.000000000',\n       '2019-01-01T05:00:00.000000000', '2019-01-01T05:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+09:00\n1   2019-01-01 12:30:00+09:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+09:00\n5   2019-01-01 14:30:00+09:00\nName: time, dtype: datetime64[ns, Asia/Tokyo]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T03:00:00.000000000', '2019-01-01T03:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T05:00:00.000000000', '2019-01-01T05:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T03:00:00.000000000', '2019-01-01T03:30:00.000000000',\n       '2019-01-01T03:00:00.000000000', '2019-01-01T03:30:00.000000000',\n       '2019-01-01T05:00:00.000000000', '2019-01-01T05:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x121097eb0>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x121097880>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array([                          'NaT',                           'NaT',\n       '2019-01-01T20:00:00.000000000', '2019-01-01T20:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-08:00\n1   2019-01-01 12:30:00-08:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-08:00\n5   2019-01-01 14:30:00-08:00\nName: time, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T20:00:00.000000000', '2019-01-01T20:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T22:00:00.000000000', '2019-01-01T22:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array([                          'NaT',                           'NaT',\n       '2019-01-01T20:00:00.000000000', '2019-01-01T20:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x121350310>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x121350be0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T20:00:00.000000000', '2019-01-01T20:30:00.000000000',\n       '2019-01-01T22:00:00.000000000', '2019-01-01T22:30:00.000000000',\n       '2019-01-01T22:00:00.000000000', '2019-01-01T22:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-08:00\n1   2019-01-01 12:30:00-08:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-08:00\n5   2019-01-01 14:30:00-08:00\nName: time, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T20:00:00.000000000', '2019-01-01T20:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T22:00:00.000000000', '2019-01-01T22:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T20:00:00.000000000', '2019-01-01T20:30:00.000000000',\n       '2019-01-01T22:00:00.000000000', '2019-01-01T22:30:00.000000000',\n       '2019-01-01T22:00:00.000000000', '2019-01-01T22:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x1292d4850>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x1292d4eb0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T20:00:00.000000000', '2019-01-01T20:30:00.000000000',\n       '2019-01-01T20:00:00.000000000', '2019-01-01T20:30:00.000000000',\n       '2019-01-01T22:00:00.000000000', '2019-01-01T22:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-08:00\n1   2019-01-01 12:30:00-08:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-08:00\n5   2019-01-01 14:30:00-08:00\nName: time, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T20:00:00.000000000', '2019-01-01T20:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T22:00:00.000000000', '2019-01-01T22:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T20:00:00.000000000', '2019-01-01T20:30:00.000000000',\n       '2019-01-01T20:00:00.000000000', '2019-01-01T20:30:00.000000000',\n       '2019-01-01T22:00:00.000000000', '2019-01-01T22:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x121350250>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x120e1afa0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array([                          'NaT',                           'NaT',\n       '2019-01-01T04:00:00.000000000', '2019-01-01T04:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+08:00\n1   2019-01-01 12:30:00+08:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+08:00\n5   2019-01-01 14:30:00+08:00\nName: time, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T04:00:00.000000000', '2019-01-01T04:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T06:00:00.000000000', '2019-01-01T06:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array([                          'NaT',                           'NaT',\n       '2019-01-01T04:00:00.000000000', '2019-01-01T04:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x120fe3c70>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x120fe3ee0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T04:00:00.000000000', '2019-01-01T04:30:00.000000000',\n       '2019-01-01T06:00:00.000000000', '2019-01-01T06:30:00.000000000',\n       '2019-01-01T06:00:00.000000000', '2019-01-01T06:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+08:00\n1   2019-01-01 12:30:00+08:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+08:00\n5   2019-01-01 14:30:00+08:00\nName: time, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T04:00:00.000000000', '2019-01-01T04:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T06:00:00.000000000', '2019-01-01T06:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T04:00:00.000000000', '2019-01-01T04:30:00.000000000',\n       '2019-01-01T06:00:00.000000000', '2019-01-01T06:30:00.000000000',\n       '2019-01-01T06:00:00.000000000', '2019-01-01T06:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x1211a8fa0>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x1211a8e80>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T04:00:00.000000000', '2019-01-01T04:30:00.000000000',\n       '2019-01-01T04:00:00.000000000', '2019-01-01T04:30:00.000000000',\n       '2019-01-01T06:00:00.000000000', '2019-01-01T06:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+08:00\n1   2019-01-01 12:30:00+08:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+08:00\n5   2019-01-01 14:30:00+08:00\nName: time, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T04:00:00.000000000', '2019-01-01T04:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T06:00:00.000000000', '2019-01-01T06:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T04:00:00.000000000', '2019-01-01T04:30:00.000000000',\n       '2019-01-01T04:00:00.000000000', '2019-01-01T04:30:00.000000000',\n       '2019-01-01T06:00:00.000000000', '2019-01-01T06:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x121289490>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x121289d00>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array([                          'NaT',                           'NaT',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, tzutc()]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array([                          'NaT',                           'NaT',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x1210d1520>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x1210d1d30>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, tzutc()]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x12121b9a0>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x12121b130>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, tzutc()]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x1211c5040>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x1211c5070>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array([                          'NaT',                           'NaT',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, tzlocal()]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array([                          'NaT',                           'NaT',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x120dd27f0>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x120f4b4c0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, tzlocal()]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x1211558b0>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x121155910>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, tzlocal()]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x1210594c0>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x121059400>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array([                          'NaT',                           'NaT',\n       '2019-01-01T07:00:00.000000000', '2019-01-01T07:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+05:00\n1   2019-01-01 12:30:00+05:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+05:00\n5   2019-01-01 14:30:00+05:00\nName: time, dtype: datetime64[ns, pytz.FixedOffset(300)]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T07:00:00.000000000', '2019-01-01T07:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T09:00:00.000000000', '2019-01-01T09:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array([                          'NaT',                           'NaT',\n       '2019-01-01T07:00:00.000000000', '2019-01-01T07:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x120eafc10>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x121350370>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T07:00:00.000000000', '2019-01-01T07:30:00.000000000',\n       '2019-01-01T09:00:00.000000000', '2019-01-01T09:30:00.000000000',\n       '2019-01-01T09:00:00.000000000', '2019-01-01T09:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+05:00\n1   2019-01-01 12:30:00+05:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+05:00\n5   2019-01-01 14:30:00+05:00\nName: time, dtype: datetime64[ns, pytz.FixedOffset(300)]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T07:00:00.000000000', '2019-01-01T07:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T09:00:00.000000000', '2019-01-01T09:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T07:00:00.000000000', '2019-01-01T07:30:00.000000000',\n       '2019-01-01T09:00:00.000000000', '2019-01-01T09:30:00.000000000',\n       '2019-01-01T09:00:00.000000000', '2019-01-01T09:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x121097430>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x121097940>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T07:00:00.000000000', '2019-01-01T07:30:00.000000000',\n       '2019-01-01T07:00:00.000000000', '2019-01-01T07:30:00.000000000',\n       '2019-01-01T09:00:00.000000000', '2019-01-01T09:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+05:00\n1   2019-01-01 12:30:00+05:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+05:00\n5   2019-01-01 14:30:00+05:00\nName: time, dtype: datetime64[ns, pytz.FixedOffset(300)]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T07:00:00.000000000', '2019-01-01T07:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T09:00:00.000000000', '2019-01-01T09:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T07:00:00.000000000', '2019-01-01T07:30:00.000000000',\n       '2019-01-01T07:00:00.000000000', '2019-01-01T07:30:00.000000000',\n       '2019-01-01T09:00:00.000000000', '2019-01-01T09:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x1292c6d00>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x1292c6d30>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array([                          'NaT',                           'NaT',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, UTC]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array([                          'NaT',                           'NaT',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x12929be50>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x12929b850>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, UTC]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x121333310>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x1213336d0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, UTC]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x121063700>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x121063130>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array([                          'NaT',                           'NaT',\n       '2019-01-01T17:00:00.000000000', '2019-01-01T17:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-05:00\n1   2019-01-01 12:30:00-05:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-05:00\n5   2019-01-01 14:30:00-05:00\nName: time, dtype: datetime64[ns, pytz.FixedOffset(-300)]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T17:00:00.000000000', '2019-01-01T17:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T19:00:00.000000000', '2019-01-01T19:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array([                          'NaT',                           'NaT',\n       '2019-01-01T17:00:00.000000000', '2019-01-01T17:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x1213330d0>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x120f44af0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T17:00:00.000000000', '2019-01-01T17:30:00.000000000',\n       '2019-01-01T19:00:00.000000000', '2019-01-01T19:30:00.000000000',\n       '2019-01-01T19:00:00.000000000', '2019-01-01T19:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-05:00\n1   2019-01-01 12:30:00-05:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-05:00\n5   2019-01-01 14:30:00-05:00\nName: time, dtype: datetime64[ns, pytz.FixedOffset(-300)]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T17:00:00.000000000', '2019-01-01T17:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T19:00:00.000000000', '2019-01-01T19:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T17:00:00.000000000', '2019-01-01T17:30:00.000000000',\n       '2019-01-01T19:00:00.000000000', '2019-01-01T19:30:00.000000000',\n       '2019-01-01T19:00:00.000000000', '2019-01-01T19:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x121063940>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x121063be0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T17:00:00.000000000', '2019-01-01T17:30:00.000000000',\n       '2019-01-01T17:00:00.000000000', '2019-01-01T17:30:00.000000000',\n       '2019-01-01T19:00:00.000000000', '2019-01-01T19:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-05:00\n1   2019-01-01 12:30:00-05:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-05:00\n5   2019-01-01 14:30:00-05:00\nName: time, dtype: datetime64[ns, pytz.FixedOffset(-300)]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T17:00:00.000000000', '2019-01-01T17:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T19:00:00.000000000', '2019-01-01T19:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T17:00:00.000000000', '2019-01-01T17:30:00.000000000',\n       '2019-01-01T17:00:00.000000000', '2019-01-01T17:30:00.000000000',\n       '2019-01-01T19:00:00.000000000', '2019-01-01T19:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x1210e98b0>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x1210e9eb0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array([                          'NaT',                           'NaT',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, UTC]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array([                          'NaT',                           'NaT',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x121185b80>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x121185ca0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, UTC]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x1292c65e0>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x1292c6eb0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, UTC]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x121185280>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x120f51430>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array([                          'NaT',                           'NaT',\n       '2019-01-01T11:00:00.000000000', '2019-01-01T11:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+01:00\n1   2019-01-01 12:30:00+01:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+01:00\n5   2019-01-01 14:30:00+01:00\nName: time, dtype: datetime64[ns, UTC+01:00]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T11:00:00.000000000', '2019-01-01T11:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T13:00:00.000000000', '2019-01-01T13:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array([                          'NaT',                           'NaT',\n       '2019-01-01T11:00:00.000000000', '2019-01-01T11:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x129230f40>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x129230640>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T11:00:00.000000000', '2019-01-01T11:30:00.000000000',\n       '2019-01-01T13:00:00.000000000', '2019-01-01T13:30:00.000000000',\n       '2019-01-01T13:00:00.000000000', '2019-01-01T13:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+01:00\n1   2019-01-01 12:30:00+01:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+01:00\n5   2019-01-01 14:30:00+01:00\nName: time, dtype: datetime64[ns, UTC+01:00]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T11:00:00.000000000', '2019-01-01T11:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T13:00:00.000000000', '2019-01-01T13:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T11:00:00.000000000', '2019-01-01T11:30:00.000000000',\n       '2019-01-01T13:00:00.000000000', '2019-01-01T13:30:00.000000000',\n       '2019-01-01T13:00:00.000000000', '2019-01-01T13:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x129230790>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x1292301c0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T11:00:00.000000000', '2019-01-01T11:30:00.000000000',\n       '2019-01-01T11:00:00.000000000', '2019-01-01T11:30:00.000000000',\n       '2019-01-01T13:00:00.000000000', '2019-01-01T13:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+01:00\n1   2019-01-01 12:30:00+01:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+01:00\n5   2019-01-01 14:30:00+01:00\nName: time, dtype: datetime64[ns, UTC+01:00]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T11:00:00.000000000', '2019-01-01T11:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T13:00:00.000000000', '2019-01-01T13:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T11:00:00.000000000', '2019-01-01T11:30:00.000000000',\n       '2019-01-01T11:00:00.000000000', '2019-01-01T11:30:00.000000000',\n       '2019-01-01T13:00:00.000000000', '2019-01-01T13:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x129322e20>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x129322af0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array([                          'NaT',                           'NaT',\n       '2019-01-01T13:00:00.000000000', '2019-01-01T13:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-01:00\n1   2019-01-01 12:30:00-01:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-01:00\n5   2019-01-01 14:30:00-01:00\nName: time, dtype: datetime64[ns, foo]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T13:00:00.000000000', '2019-01-01T13:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T15:00:00.000000000', '2019-01-01T15:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array([                          'NaT',                           'NaT',\n       '2019-01-01T13:00:00.000000000', '2019-01-01T13:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x1211c8a00>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x1211c8400>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T13:00:00.000000000', '2019-01-01T13:30:00.000000000',\n       '2019-01-01T15:00:00.000000000', '2019-01-01T15:30:00.000000000',\n       '2019-01-01T15:00:00.000000000', '2019-01-01T15:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-01:00\n1   2019-01-01 12:30:00-01:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-01:00\n5   2019-01-01 14:30:00-01:00\nName: time, dtype: datetime64[ns, foo]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T13:00:00.000000000', '2019-01-01T13:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T15:00:00.000000000', '2019-01-01T15:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T13:00:00.000000000', '2019-01-01T13:30:00.000000000',\n       '2019-01-01T15:00:00.000000000', '2019-01-01T15:30:00.000000000',\n       '2019-01-01T15:00:00.000000000', '2019-01-01T15:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x12929b5b0>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x12929b8b0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T13:00:00.000000000', '2019-01-01T13:30:00.000000000',\n       '2019-01-01T13:00:00.000000000', '2019-01-01T13:30:00.000000000',\n       '2019-01-01T15:00:00.000000000', '2019-01-01T15:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-01:00\n1   2019-01-01 12:30:00-01:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-01:00\n5   2019-01-01 14:30:00-01:00\nName: time, dtype: datetime64[ns, foo]",
                "result_sz": "6",
                "obj.values": "array(['2019-01-01T13:00:00.000000000', '2019-01-01T13:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T15:00:00.000000000', '2019-01-01T15:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "result": "array(['2019-01-01T13:00:00.000000000', '2019-01-01T13:30:00.000000000',\n       '2019-01-01T13:00:00.000000000', '2019-01-01T13:30:00.000000000',\n       '2019-01-01T15:00:00.000000000', '2019-01-01T15:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ]
    ],
    "2.1.4": [
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "result_sz": "int",
                "obj.values": "ndarray",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ]
    ],
    "2.1.5": [
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117bbc460>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x117b1c790>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array([                          'NaT',                           'NaT',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00\n1   2019-01-01 12:30:00\n2                   NaT\n3                   NaT\n4   2019-01-01 14:00:00\n5   2019-01-01 14:30:00\nName: time, dtype: datetime64[ns]",
                "values": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeBlock: 6 dtype: datetime64[ns]",
                "result_sz": "6",
                "values.dtype": "dtype('<M8[ns]')",
                "result": "array([                          'NaT',                           'NaT',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117bbce50>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x117bbc220>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00\n1   2019-01-01 12:30:00\n2                   NaT\n3                   NaT\n4   2019-01-01 14:00:00\n5   2019-01-01 14:30:00\nName: time, dtype: datetime64[ns]",
                "values": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeBlock: 6 dtype: datetime64[ns]",
                "result_sz": "6",
                "values.dtype": "dtype('<M8[ns]')",
                "result": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x11fd98610>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x117bbc370>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]'))])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00\n1   2019-01-01 12:30:00\n2                   NaT\n3                   NaT\n4   2019-01-01 14:00:00\n5   2019-01-01 14:30:00\nName: time, dtype: datetime64[ns]",
                "values": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n                                 'NaT',                           'NaT',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeBlock: 6 dtype: datetime64[ns]",
                "result_sz": "6",
                "values.dtype": "dtype('<M8[ns]')",
                "result": "array(['2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T12:00:00.000000000', '2019-01-01T12:30:00.000000000',\n       '2019-01-01T14:00:00.000000000', '2019-01-01T14:30:00.000000000'],\n      dtype='datetime64[ns]')",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x11fd98e20>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x11fd98700>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, UTC])])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, UTC]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, UTC]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, UTC]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, UTC]",
                "result": "<DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, UTC]",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x11fd982e0>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x11fd98460>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, UTC])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, UTC]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, UTC]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, UTC]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, UTC]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, UTC]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117bbc8b0>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x117bbcd00>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, UTC])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, UTC]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, UTC]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, UTC]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, UTC]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, UTC]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x11fdac370>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x11fdac910>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00-05:00', '2019-01-01 12:30:00-05:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, US/Eastern])])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-05:00\n1   2019-01-01 12:30:00-05:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-05:00\n5   2019-01-01 14:30:00-05:00\nName: time, dtype: datetime64[ns, US/Eastern]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00-05:00', '2019-01-01 12:30:00-05:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00-05:00', '2019-01-01 14:30:00-05:00']\nLength: 6, dtype: datetime64[ns, US/Eastern]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, US/Eastern]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, US/Eastern]",
                "result": "<DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00-05:00', '2019-01-01 12:30:00-05:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, US/Eastern]",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x108e69910>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x11fdaf4f0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00-05:00', '2019-01-01 12:30:00-05:00',\n '2019-01-01 14:00:00-05:00', '2019-01-01 14:30:00-05:00',\n '2019-01-01 14:00:00-05:00', '2019-01-01 14:30:00-05:00']\nLength: 6, dtype: datetime64[ns, US/Eastern])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-05:00\n1   2019-01-01 12:30:00-05:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-05:00\n5   2019-01-01 14:30:00-05:00\nName: time, dtype: datetime64[ns, US/Eastern]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00-05:00', '2019-01-01 12:30:00-05:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00-05:00', '2019-01-01 14:30:00-05:00']\nLength: 6, dtype: datetime64[ns, US/Eastern]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, US/Eastern]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, US/Eastern]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00-05:00', '2019-01-01 12:30:00-05:00',\n '2019-01-01 14:00:00-05:00', '2019-01-01 14:30:00-05:00',\n '2019-01-01 14:00:00-05:00', '2019-01-01 14:30:00-05:00']\nLength: 6, dtype: datetime64[ns, US/Eastern]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117f9c730>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x117f9c6a0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00-05:00', '2019-01-01 12:30:00-05:00',\n '2019-01-01 12:00:00-05:00', '2019-01-01 12:30:00-05:00',\n '2019-01-01 14:00:00-05:00', '2019-01-01 14:30:00-05:00']\nLength: 6, dtype: datetime64[ns, US/Eastern])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-05:00\n1   2019-01-01 12:30:00-05:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-05:00\n5   2019-01-01 14:30:00-05:00\nName: time, dtype: datetime64[ns, US/Eastern]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00-05:00', '2019-01-01 12:30:00-05:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00-05:00', '2019-01-01 14:30:00-05:00']\nLength: 6, dtype: datetime64[ns, US/Eastern]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, US/Eastern]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, US/Eastern]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00-05:00', '2019-01-01 12:30:00-05:00',\n '2019-01-01 12:00:00-05:00', '2019-01-01 12:30:00-05:00',\n '2019-01-01 14:00:00-05:00', '2019-01-01 14:30:00-05:00']\nLength: 6, dtype: datetime64[ns, US/Eastern]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x108e69cd0>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x117f9c790>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00+09:00', '2019-01-01 12:30:00+09:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, Asia/Tokyo])])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+09:00\n1   2019-01-01 12:30:00+09:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+09:00\n5   2019-01-01 14:30:00+09:00\nName: time, dtype: datetime64[ns, Asia/Tokyo]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+09:00', '2019-01-01 12:30:00+09:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+09:00', '2019-01-01 14:30:00+09:00']\nLength: 6, dtype: datetime64[ns, Asia/Tokyo]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, Asia/Tokyo]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, Asia/Tokyo]",
                "result": "<DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00+09:00', '2019-01-01 12:30:00+09:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, Asia/Tokyo]",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x11fdac040>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x11fdaf2b0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00+09:00', '2019-01-01 12:30:00+09:00',\n '2019-01-01 14:00:00+09:00', '2019-01-01 14:30:00+09:00',\n '2019-01-01 14:00:00+09:00', '2019-01-01 14:30:00+09:00']\nLength: 6, dtype: datetime64[ns, Asia/Tokyo])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+09:00\n1   2019-01-01 12:30:00+09:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+09:00\n5   2019-01-01 14:30:00+09:00\nName: time, dtype: datetime64[ns, Asia/Tokyo]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+09:00', '2019-01-01 12:30:00+09:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+09:00', '2019-01-01 14:30:00+09:00']\nLength: 6, dtype: datetime64[ns, Asia/Tokyo]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, Asia/Tokyo]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, Asia/Tokyo]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00+09:00', '2019-01-01 12:30:00+09:00',\n '2019-01-01 14:00:00+09:00', '2019-01-01 14:30:00+09:00',\n '2019-01-01 14:00:00+09:00', '2019-01-01 14:30:00+09:00']\nLength: 6, dtype: datetime64[ns, Asia/Tokyo]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x11fd98c70>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x11fdaf220>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00+09:00', '2019-01-01 12:30:00+09:00',\n '2019-01-01 12:00:00+09:00', '2019-01-01 12:30:00+09:00',\n '2019-01-01 14:00:00+09:00', '2019-01-01 14:30:00+09:00']\nLength: 6, dtype: datetime64[ns, Asia/Tokyo])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+09:00\n1   2019-01-01 12:30:00+09:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+09:00\n5   2019-01-01 14:30:00+09:00\nName: time, dtype: datetime64[ns, Asia/Tokyo]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+09:00', '2019-01-01 12:30:00+09:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+09:00', '2019-01-01 14:30:00+09:00']\nLength: 6, dtype: datetime64[ns, Asia/Tokyo]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, Asia/Tokyo]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, Asia/Tokyo]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00+09:00', '2019-01-01 12:30:00+09:00',\n '2019-01-01 12:00:00+09:00', '2019-01-01 12:30:00+09:00',\n '2019-01-01 14:00:00+09:00', '2019-01-01 14:30:00+09:00']\nLength: 6, dtype: datetime64[ns, Asia/Tokyo]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117bbc820>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x117bbca00>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00-08:00', '2019-01-01 12:30:00-08:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')])])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-08:00\n1   2019-01-01 12:30:00-08:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-08:00\n5   2019-01-01 14:30:00-08:00\nName: time, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00-08:00', '2019-01-01 12:30:00-08:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00-08:00', '2019-01-01 14:30:00-08:00']\nLength: 6, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]",
                "result": "<DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00-08:00', '2019-01-01 12:30:00-08:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x11fdacca0>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x11fdac790>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00-08:00', '2019-01-01 12:30:00-08:00',\n '2019-01-01 14:00:00-08:00', '2019-01-01 14:30:00-08:00',\n '2019-01-01 14:00:00-08:00', '2019-01-01 14:30:00-08:00']\nLength: 6, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-08:00\n1   2019-01-01 12:30:00-08:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-08:00\n5   2019-01-01 14:30:00-08:00\nName: time, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00-08:00', '2019-01-01 12:30:00-08:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00-08:00', '2019-01-01 14:30:00-08:00']\nLength: 6, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00-08:00', '2019-01-01 12:30:00-08:00',\n '2019-01-01 14:00:00-08:00', '2019-01-01 14:30:00-08:00',\n '2019-01-01 14:00:00-08:00', '2019-01-01 14:30:00-08:00']\nLength: 6, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x11fdb4670>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x11fdaf400>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00-08:00', '2019-01-01 12:30:00-08:00',\n '2019-01-01 12:00:00-08:00', '2019-01-01 12:30:00-08:00',\n '2019-01-01 14:00:00-08:00', '2019-01-01 14:30:00-08:00']\nLength: 6, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-08:00\n1   2019-01-01 12:30:00-08:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-08:00\n5   2019-01-01 14:30:00-08:00\nName: time, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00-08:00', '2019-01-01 12:30:00-08:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00-08:00', '2019-01-01 14:30:00-08:00']\nLength: 6, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00-08:00', '2019-01-01 12:30:00-08:00',\n '2019-01-01 12:00:00-08:00', '2019-01-01 12:30:00-08:00',\n '2019-01-01 14:00:00-08:00', '2019-01-01 14:30:00-08:00']\nLength: 6, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x11fdb45b0>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x11fdb4880>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00+08:00', '2019-01-01 12:30:00+08:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')])])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+08:00\n1   2019-01-01 12:30:00+08:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+08:00\n5   2019-01-01 14:30:00+08:00\nName: time, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+08:00', '2019-01-01 12:30:00+08:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+08:00', '2019-01-01 14:30:00+08:00']\nLength: 6, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]",
                "result": "<DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00+08:00', '2019-01-01 12:30:00+08:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x11fdb4040>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x11fdb45b0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00+08:00', '2019-01-01 12:30:00+08:00',\n '2019-01-01 14:00:00+08:00', '2019-01-01 14:30:00+08:00',\n '2019-01-01 14:00:00+08:00', '2019-01-01 14:30:00+08:00']\nLength: 6, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+08:00\n1   2019-01-01 12:30:00+08:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+08:00\n5   2019-01-01 14:30:00+08:00\nName: time, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+08:00', '2019-01-01 12:30:00+08:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+08:00', '2019-01-01 14:30:00+08:00']\nLength: 6, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00+08:00', '2019-01-01 12:30:00+08:00',\n '2019-01-01 14:00:00+08:00', '2019-01-01 14:30:00+08:00',\n '2019-01-01 14:00:00+08:00', '2019-01-01 14:30:00+08:00']\nLength: 6, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x11fd984c0>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x11fdb44c0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00+08:00', '2019-01-01 12:30:00+08:00',\n '2019-01-01 12:00:00+08:00', '2019-01-01 12:30:00+08:00',\n '2019-01-01 14:00:00+08:00', '2019-01-01 14:30:00+08:00']\nLength: 6, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+08:00\n1   2019-01-01 12:30:00+08:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+08:00\n5   2019-01-01 14:30:00+08:00\nName: time, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+08:00', '2019-01-01 12:30:00+08:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+08:00', '2019-01-01 14:30:00+08:00']\nLength: 6, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00+08:00', '2019-01-01 12:30:00+08:00',\n '2019-01-01 12:00:00+08:00', '2019-01-01 12:30:00+08:00',\n '2019-01-01 14:00:00+08:00', '2019-01-01 14:30:00+08:00']\nLength: 6, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117eaae50>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x117eaa7c0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, tzutc()])])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, tzutc()]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, tzutc()]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, tzutc()]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, tzutc()]",
                "result": "<DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, tzutc()]",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117eaa340>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x117eaa940>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, tzutc()])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, tzutc()]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, tzutc()]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, tzutc()]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, tzutc()]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, tzutc()]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x11fdb4220>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x117eaa4c0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, tzutc()])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, tzutc()]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, tzutc()]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, tzutc()]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, tzutc()]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, tzutc()]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117e93d30>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x117e93070>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, tzlocal()])])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, tzlocal()]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, tzlocal()]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, tzlocal()]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, tzlocal()]",
                "result": "<DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, tzlocal()]",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x11fdb4ee0>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x11fdb42e0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, tzlocal()])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, tzlocal()]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, tzlocal()]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, tzlocal()]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, tzlocal()]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, tzlocal()]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117bbcaf0>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x11fdb4b50>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, tzlocal()])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, tzlocal()]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, tzlocal()]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, tzlocal()]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, tzlocal()]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, tzlocal()]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117eaabe0>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x11fdb4850>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00+05:00', '2019-01-01 12:30:00+05:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, pytz.FixedOffset(300)])])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+05:00\n1   2019-01-01 12:30:00+05:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+05:00\n5   2019-01-01 14:30:00+05:00\nName: time, dtype: datetime64[ns, pytz.FixedOffset(300)]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+05:00', '2019-01-01 12:30:00+05:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+05:00', '2019-01-01 14:30:00+05:00']\nLength: 6, dtype: datetime64[ns, pytz.FixedOffset(300)]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, pytz.FixedOffset(300)]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, pytz.FixedOffset(300)]",
                "result": "<DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00+05:00', '2019-01-01 12:30:00+05:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, pytz.FixedOffset(300)]",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117e9e880>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x117e87040>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00+05:00', '2019-01-01 12:30:00+05:00',\n '2019-01-01 14:00:00+05:00', '2019-01-01 14:30:00+05:00',\n '2019-01-01 14:00:00+05:00', '2019-01-01 14:30:00+05:00']\nLength: 6, dtype: datetime64[ns, pytz.FixedOffset(300)])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+05:00\n1   2019-01-01 12:30:00+05:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+05:00\n5   2019-01-01 14:30:00+05:00\nName: time, dtype: datetime64[ns, pytz.FixedOffset(300)]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+05:00', '2019-01-01 12:30:00+05:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+05:00', '2019-01-01 14:30:00+05:00']\nLength: 6, dtype: datetime64[ns, pytz.FixedOffset(300)]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, pytz.FixedOffset(300)]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, pytz.FixedOffset(300)]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00+05:00', '2019-01-01 12:30:00+05:00',\n '2019-01-01 14:00:00+05:00', '2019-01-01 14:30:00+05:00',\n '2019-01-01 14:00:00+05:00', '2019-01-01 14:30:00+05:00']\nLength: 6, dtype: datetime64[ns, pytz.FixedOffset(300)]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117eaa490>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x117eaa940>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00+05:00', '2019-01-01 12:30:00+05:00',\n '2019-01-01 12:00:00+05:00', '2019-01-01 12:30:00+05:00',\n '2019-01-01 14:00:00+05:00', '2019-01-01 14:30:00+05:00']\nLength: 6, dtype: datetime64[ns, pytz.FixedOffset(300)])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+05:00\n1   2019-01-01 12:30:00+05:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+05:00\n5   2019-01-01 14:30:00+05:00\nName: time, dtype: datetime64[ns, pytz.FixedOffset(300)]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+05:00', '2019-01-01 12:30:00+05:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+05:00', '2019-01-01 14:30:00+05:00']\nLength: 6, dtype: datetime64[ns, pytz.FixedOffset(300)]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, pytz.FixedOffset(300)]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, pytz.FixedOffset(300)]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00+05:00', '2019-01-01 12:30:00+05:00',\n '2019-01-01 12:00:00+05:00', '2019-01-01 12:30:00+05:00',\n '2019-01-01 14:00:00+05:00', '2019-01-01 14:30:00+05:00']\nLength: 6, dtype: datetime64[ns, pytz.FixedOffset(300)]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x11fdaf250>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x117eaaeb0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, UTC])])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, UTC]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, UTC]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, UTC]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, UTC]",
                "result": "<DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, UTC]",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117e935b0>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x11fdb4880>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, UTC])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, UTC]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, UTC]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, UTC]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, UTC]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, UTC]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117e3f130>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x11fdb4700>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, UTC])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, UTC]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, UTC]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, UTC]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, UTC]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, UTC]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x108e69c10>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x108e69940>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00-05:00', '2019-01-01 12:30:00-05:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, pytz.FixedOffset(-300)])])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-05:00\n1   2019-01-01 12:30:00-05:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-05:00\n5   2019-01-01 14:30:00-05:00\nName: time, dtype: datetime64[ns, pytz.FixedOffset(-300)]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00-05:00', '2019-01-01 12:30:00-05:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00-05:00', '2019-01-01 14:30:00-05:00']\nLength: 6, dtype: datetime64[ns, pytz.FixedOffset(-300)]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, pytz.FixedOffset(-300)]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, pytz.FixedOffset(-300)]",
                "result": "<DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00-05:00', '2019-01-01 12:30:00-05:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, pytz.FixedOffset(-300)]",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117eaa340>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x11fdaf580>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00-05:00', '2019-01-01 12:30:00-05:00',\n '2019-01-01 14:00:00-05:00', '2019-01-01 14:30:00-05:00',\n '2019-01-01 14:00:00-05:00', '2019-01-01 14:30:00-05:00']\nLength: 6, dtype: datetime64[ns, pytz.FixedOffset(-300)])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-05:00\n1   2019-01-01 12:30:00-05:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-05:00\n5   2019-01-01 14:30:00-05:00\nName: time, dtype: datetime64[ns, pytz.FixedOffset(-300)]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00-05:00', '2019-01-01 12:30:00-05:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00-05:00', '2019-01-01 14:30:00-05:00']\nLength: 6, dtype: datetime64[ns, pytz.FixedOffset(-300)]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, pytz.FixedOffset(-300)]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, pytz.FixedOffset(-300)]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00-05:00', '2019-01-01 12:30:00-05:00',\n '2019-01-01 14:00:00-05:00', '2019-01-01 14:30:00-05:00',\n '2019-01-01 14:00:00-05:00', '2019-01-01 14:30:00-05:00']\nLength: 6, dtype: datetime64[ns, pytz.FixedOffset(-300)]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117e9e640>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x108e69be0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00-05:00', '2019-01-01 12:30:00-05:00',\n '2019-01-01 12:00:00-05:00', '2019-01-01 12:30:00-05:00',\n '2019-01-01 14:00:00-05:00', '2019-01-01 14:30:00-05:00']\nLength: 6, dtype: datetime64[ns, pytz.FixedOffset(-300)])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-05:00\n1   2019-01-01 12:30:00-05:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-05:00\n5   2019-01-01 14:30:00-05:00\nName: time, dtype: datetime64[ns, pytz.FixedOffset(-300)]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00-05:00', '2019-01-01 12:30:00-05:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00-05:00', '2019-01-01 14:30:00-05:00']\nLength: 6, dtype: datetime64[ns, pytz.FixedOffset(-300)]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, pytz.FixedOffset(-300)]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, pytz.FixedOffset(-300)]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00-05:00', '2019-01-01 12:30:00-05:00',\n '2019-01-01 12:00:00-05:00', '2019-01-01 12:30:00-05:00',\n '2019-01-01 14:00:00-05:00', '2019-01-01 14:30:00-05:00']\nLength: 6, dtype: datetime64[ns, pytz.FixedOffset(-300)]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117e365b0>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x117e3f130>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, UTC])])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, UTC]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, UTC]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, UTC]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, UTC]",
                "result": "<DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, UTC]",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x11fd98bb0>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x11fd98c70>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, UTC])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, UTC]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, UTC]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, UTC]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, UTC]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, UTC]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117e93520>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x11fdb4b80>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, UTC])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+00:00\n1   2019-01-01 12:30:00+00:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+00:00\n5   2019-01-01 14:30:00+00:00\nName: time, dtype: datetime64[ns, UTC]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, UTC]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, UTC]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, UTC]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 12:00:00+00:00', '2019-01-01 12:30:00+00:00',\n '2019-01-01 14:00:00+00:00', '2019-01-01 14:30:00+00:00']\nLength: 6, dtype: datetime64[ns, UTC]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117e3f7f0>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x117e3f6a0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00+01:00', '2019-01-01 12:30:00+01:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, UTC+01:00])])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+01:00\n1   2019-01-01 12:30:00+01:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+01:00\n5   2019-01-01 14:30:00+01:00\nName: time, dtype: datetime64[ns, UTC+01:00]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+01:00', '2019-01-01 12:30:00+01:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+01:00', '2019-01-01 14:30:00+01:00']\nLength: 6, dtype: datetime64[ns, UTC+01:00]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, UTC+01:00]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, UTC+01:00]",
                "result": "<DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00+01:00', '2019-01-01 12:30:00+01:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, UTC+01:00]",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117e368e0>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x117e36040>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00+01:00', '2019-01-01 12:30:00+01:00',\n '2019-01-01 14:00:00+01:00', '2019-01-01 14:30:00+01:00',\n '2019-01-01 14:00:00+01:00', '2019-01-01 14:30:00+01:00']\nLength: 6, dtype: datetime64[ns, UTC+01:00])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+01:00\n1   2019-01-01 12:30:00+01:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+01:00\n5   2019-01-01 14:30:00+01:00\nName: time, dtype: datetime64[ns, UTC+01:00]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+01:00', '2019-01-01 12:30:00+01:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+01:00', '2019-01-01 14:30:00+01:00']\nLength: 6, dtype: datetime64[ns, UTC+01:00]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, UTC+01:00]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, UTC+01:00]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00+01:00', '2019-01-01 12:30:00+01:00',\n '2019-01-01 14:00:00+01:00', '2019-01-01 14:30:00+01:00',\n '2019-01-01 14:00:00+01:00', '2019-01-01 14:30:00+01:00']\nLength: 6, dtype: datetime64[ns, UTC+01:00]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117e3f9a0>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x117e36100>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00+01:00', '2019-01-01 12:30:00+01:00',\n '2019-01-01 12:00:00+01:00', '2019-01-01 12:30:00+01:00',\n '2019-01-01 14:00:00+01:00', '2019-01-01 14:30:00+01:00']\nLength: 6, dtype: datetime64[ns, UTC+01:00])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00+01:00\n1   2019-01-01 12:30:00+01:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00+01:00\n5   2019-01-01 14:30:00+01:00\nName: time, dtype: datetime64[ns, UTC+01:00]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00+01:00', '2019-01-01 12:30:00+01:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00+01:00', '2019-01-01 14:30:00+01:00']\nLength: 6, dtype: datetime64[ns, UTC+01:00]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, UTC+01:00]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, UTC+01:00]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00+01:00', '2019-01-01 12:30:00+01:00',\n '2019-01-01 12:00:00+01:00', '2019-01-01 12:30:00+01:00',\n '2019-01-01 14:00:00+01:00', '2019-01-01 14:30:00+01:00']\nLength: 6, dtype: datetime64[ns, UTC+01:00]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117e9ef40>",
                "how": "'group_shift_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x117e9ecd0>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "False",
                "needs_ngroups": "True",
                "kwargs": "{'periods': 1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00-01:00', '2019-01-01 12:30:00-01:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, foo])])",
                "base_func": "<built-in function group_shift_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-01:00\n1   2019-01-01 12:30:00-01:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-01:00\n5   2019-01-01 14:30:00-01:00\nName: time, dtype: datetime64[ns, foo]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00-01:00', '2019-01-01 12:30:00-01:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00-01:00', '2019-01-01 14:30:00-01:00']\nLength: 6, dtype: datetime64[ns, foo]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, foo]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, foo]",
                "result": "<DatetimeArray>\n[                      'NaT',                       'NaT',\n '2019-01-01 12:00:00-01:00', '2019-01-01 12:30:00-01:00',\n                       'NaT',                       'NaT']\nLength: 6, dtype: datetime64[ns, foo]",
                "func": "functools.partial(<built-in function group_shift_indexer>, array([-1, -1,  0,  1,  2,  3]), array([0, 1, 0, 1, 0, 1]), 2)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117e87640>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x117e87760>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'bfill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00-01:00', '2019-01-01 12:30:00-01:00',\n '2019-01-01 14:00:00-01:00', '2019-01-01 14:30:00-01:00',\n '2019-01-01 14:00:00-01:00', '2019-01-01 14:30:00-01:00']\nLength: 6, dtype: datetime64[ns, foo])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-01:00\n1   2019-01-01 12:30:00-01:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-01:00\n5   2019-01-01 14:30:00-01:00\nName: time, dtype: datetime64[ns, foo]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00-01:00', '2019-01-01 12:30:00-01:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00-01:00', '2019-01-01 14:30:00-01:00']\nLength: 6, dtype: datetime64[ns, foo]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, foo]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, foo]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00-01:00', '2019-01-01 12:30:00-01:00',\n '2019-01-01 14:00:00-01:00', '2019-01-01 14:30:00-01:00',\n '2019-01-01 14:00:00-01:00', '2019-01-01 14:30:00-01:00']\nLength: 6, dtype: datetime64[ns, foo]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 4, 5, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ],
        [
            {
                "result_is_index": "True",
                "aggregate": "False",
                "needs_values": "False",
                "grouper.group_info": "(array([0, 1, 0, 1, 0, 1]), array([0, 1]), 2)",
                "grouper": "<pandas.core.groupby.ops.BaseGrouper object at 0x117e9e400>",
                "how": "'group_fillna_indexer'",
                "self": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x117e9e190>",
                "cython_dtype": "<class 'numpy.int64'>",
                "needs_mask": "True",
                "needs_ngroups": "False",
                "kwargs": "{'direction': 'ffill', 'limit': -1}"
            },
            {
                "labels": "array([0, 1, 0, 1, 0, 1])",
                "_": "array([0, 1])",
                "ngroups": "2",
                "output": "OrderedDict([('time', <DatetimeArray>\n['2019-01-01 12:00:00-01:00', '2019-01-01 12:30:00-01:00',\n '2019-01-01 12:00:00-01:00', '2019-01-01 12:30:00-01:00',\n '2019-01-01 14:00:00-01:00', '2019-01-01 14:30:00-01:00']\nLength: 6, dtype: datetime64[ns, foo])])",
                "base_func": "<built-in function group_fillna_indexer>",
                "name": "'time'",
                "obj": "0   2019-01-01 12:00:00-01:00\n1   2019-01-01 12:30:00-01:00\n2                         NaT\n3                         NaT\n4   2019-01-01 14:00:00-01:00\n5   2019-01-01 14:30:00-01:00\nName: time, dtype: datetime64[ns, foo]",
                "values": "<DatetimeArray>\n['2019-01-01 12:00:00-01:00', '2019-01-01 12:30:00-01:00',\n                       'NaT',                       'NaT',\n '2019-01-01 14:00:00-01:00', '2019-01-01 14:30:00-01:00']\nLength: 6, dtype: datetime64[ns, foo]",
                "obj._data": "SingleBlockManager\nItems: RangeIndex(start=0, stop=6, step=1)\nDatetimeTZBlock: 6 dtype: datetime64[ns, foo]",
                "result_sz": "6",
                "values.dtype": "datetime64[ns, foo]",
                "result": "<DatetimeArray>\n['2019-01-01 12:00:00-01:00', '2019-01-01 12:30:00-01:00',\n '2019-01-01 12:00:00-01:00', '2019-01-01 12:30:00-01:00',\n '2019-01-01 14:00:00-01:00', '2019-01-01 14:30:00-01:00']\nLength: 6, dtype: datetime64[ns, foo]",
                "func": "functools.partial(<built-in function group_fillna_indexer>, array([0, 1, 0, 1, 4, 5]), array([0, 1, 0, 1, 0, 1]), array([0, 0, 1, 1, 0, 0], dtype=uint8))",
                "mask": "array([0, 0, 1, 1, 0, 0], dtype=uint8)"
            }
        ]
    ],
    "2.1.6": [
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "ndarray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "dtype",
                "result": "ndarray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "ndarray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "dtype",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "ndarray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "dtype",
                "result": "ndarray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ],
        [
            {
                "result_is_index": "bool",
                "aggregate": "bool",
                "needs_values": "bool",
                "grouper.group_info": "tuple",
                "grouper": "BaseGrouper",
                "how": "str",
                "self": "DataFrameGroupBy",
                "cython_dtype": "type",
                "needs_mask": "bool",
                "needs_ngroups": "bool",
                "kwargs": "dict"
            },
            {
                "labels": "ndarray",
                "_": "ndarray",
                "ngroups": "int",
                "output": "OrderedDict",
                "base_func": "builtin_function_or_method",
                "name": "str",
                "obj": "Series",
                "values": "DatetimeArray",
                "obj._data": "SingleBlockManager",
                "result_sz": "int",
                "values.dtype": "DatetimeTZDtype",
                "result": "DatetimeArray",
                "func": "partial",
                "mask": "ndarray"
            }
        ]
    ],
    "3.1.1": [
        "Shifting a datetime column with timezone after groupby loses the timezone.\n"
    ],
    "3.1.2": [
        "Code Sample, a copy-pastable example if possible\nweeks = pd.Series(pd.date_range('2018-01', '2018-02', freq='7D', tz='America/New_York'))\nweek_ago = weeks.groupby([1, 1, 1, 1, 1]).shift()\nprint(week_ago)\nOutputs:\n\n0                   NaT\n1   2018-01-01 05:00:00\n2   2018-01-08 05:00:00\n3   2018-01-15 05:00:00\n4   2018-01-22 05:00:00\ndtype: datetime64[ns]\nProblem description\nShifting a groupby'd datetime column removes the timezone. It's not mentioned in the documentation so either the timezone should be preserved or the documentation should mention that timezone is removed (by converting to UTC it seems).\n\nI had a quick look and couldn't find another issue for this. I glanced at the GroupBy shift implementation and my guess is that it's due to cython/numpy not supporting timezones.\n\nI'm happy to work on a fix if someone says what the preferred solution is.\n\nExpected Output\n0                         NaT\n1   2018-01-01 00:00:00-05:00\n2   2018-01-08 00:00:00-05:00\n3   2018-01-15 00:00:00-05:00\n4   2018-01-22 00:00:00-05:00\ndtype: datetime64[ns, America/New_York]\n"
    ]
}