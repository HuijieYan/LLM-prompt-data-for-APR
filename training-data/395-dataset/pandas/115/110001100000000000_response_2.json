{
    "pandas": [
        {
            "bugID": 115,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 0,
                "6": 0,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 0,
                "6": 0,
                "7": 0
            },
            "start_line": 167,
            "file_name": "pandas/core/missing.py",
            "replace_code": "def interpolate_1d(\n        xvalues,\n        yvalues,\n        method=\"linear\",\n        limit=None,\n        limit_direction=\"forward\",\n        limit_area=None,\n        fill_value=None,\n        bounds_error=False,\n        order=None,\n        **kwargs\n    ):\n        \"\"\"\n        Logic for the 1-d interpolation.  The result should be 1-d, inputs\n        xvalues and yvalues will each be 1-d arrays of the same length.\n    \n        Bounds_error is currently hardcoded to False since non-scipy ones don't\n        take it as an argument.\n        \"\"\"\n        # Treat the original, non-scipy methods first.\n    \n        invalid = isna_array(yvalues)\n        valid = ~invalid\n    \n        if not valid.any():\n            # have to call np.asarray(xvalues) since xvalues could be an Index\n            # which can't be mutated\n            result = np.empty_like(np.asarray(xvalues), dtype=np.float64)\n            result.fill(np.nan)\n            return result\n    \n        if valid.all():\n            return yvalues\n\n        valid_limit_directions = [\"forward\", \"backward\", \"both\"]\n        lower_case_limit_directions = [direction.lower() for direction in valid_limit_directions]\n\n        if isinstance(method, str) and method.lower() == \"time\" and not getattr(xvalues, \"is_all_dates\", None):\n            raise ValueError(\"time-weighted interpolation only works on Series or DataFrames with a DatetimeIndex\")\n        method = method.lower()\n\n        if limit_direction not in lower_case_limit_directions:\n            raise ValueError(f\"Invalid limit_direction: expecting one of {valid_limit_directions!r}, got {limit_direction!r}.\")\n\n        if limit_area is not None:\n            valid_limit_areas = [\"inside\", \"outside\"]\n            lower_case_limit_areas = [area.lower() for area in valid_limit_areas]\n            if limit_area.lower() not in lower_case_limit_areas:\n                raise ValueError(\"Invalid limit_area: expecting one of {}, got {}.\".format(valid_limit_areas, limit_area))\n\n        # default limit is unlimited GH #16282\n        limit = _validate_limit(nobs=None, limit=limit)\n\n        all_nans = set(np.flatnonzero(invalid))\n        start_nans = set(range(_find_valid_index(yvalues, \"first\")))\n        end_nans = set(range(1 + _find_valid_index(yvalues, \"last\"), len(valid)))\n        mid_nans = all_nans - start_nans - end_nans\n\n        if limit_direction.lower() == \"forward\":\n            preserve_nans = start_nans | set(_interp_limit(invalid, limit, 0)) if limit is not None else start_nans\n        elif limit_direction.lower() == \"backward\":\n            preserve_nans = end_nans | set(_interp_limit(invalid, 0, limit)) if limit is not None else end_nans\n        else:\n            preserve_nans = set(_interp_limit(invalid, limit if limit is not None else 0, limit if limit is not None else 0))\n        \n        if limit_area is not None:\n            if limit_area.lower() == \"inside\":\n                preserve_nans |= start_nans | end_nans\n            elif limit_area.lower() == \"outside\":\n                preserve_nans |= mid_nans\n        \n        preserve_nans = sorted(preserve_nans)\n        x = np.array(xvalues)\n        y = np.array(yvalues)\n    \n        if method in [\"linear\", \"time\", \"index\", \"values\"]:\n            if method in (\"values\", \"index\"):\n                inds = np.asarray(xvalues)\n                # hack for DatetimeIndex, #1646\n                if needs_i8_conversion(inds.dtype.type):\n                    inds = inds.view(np.int64)\n                if inds.dtype == np.object_:\n                    inds = lib.maybe_convert_objects(inds)\n            else:\n                inds = xvalues\n            result = y.copy()\n            result[invalid] = np.interp(inds[invalid], inds[valid], y[valid])\n            result[preserve_nans] = np.nan\n            return result\n    \n        sp_methods = [\n            \"nearest\",\n            \"zero\",\n            \"slinear\",\n            \"quadratic\",\n            \"cubic\",\n            \"barycentric\",\n            \"krogh\",\n            \"spline\",\n            \"polynomial\",\n            \"from_derivatives\",\n            \"piecewise_polynomial\",\n            \"pchip\",\n            \"akima\",\n        ]\n    \n        if method in sp_methods:\n            if issubclass(x.dtype.type, np.datetime64):\n                x = x.view(np.int64)\n            result = y.copy()\n            result[invalid] = _interpolate_scipy_wrapper(\n                x[valid],\n                y[valid],\n                x[invalid],\n                method=method,\n                fill_value=fill_value,\n                bounds_error=bounds_error,\n                order=order,\n                **kwargs\n            )\n            result[preserve_nans] = np.nan\n            return result",
            "import_list": []
        }
    ]
}