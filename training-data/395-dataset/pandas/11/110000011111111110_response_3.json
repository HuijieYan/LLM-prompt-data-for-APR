{
    "pandas": [
        {
            "bugID": 11,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 1,
                "2.1.4": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 0,
                "4": 1,
                "5": 1,
                "6": 1,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 0,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 1,
                "2.1.4": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 0,
                "4": 1,
                "5": 1,
                "6": 1,
                "7": 0
            },
            "start_line": 590,
            "file_name": "pandas/core/reshape/concat.py",
            "replace_code": "def _make_concat_multiindex(indexes, keys, levels=None, names=None) -> MultiIndex:\n    from pandas.core.arrays.categorical import factorize_from_iterables\n    from pandas.core.indexes.multi import MultiIndex\n    import numpy as np\n\n    def ensure_index(x):\n        from pandas import Index\n        if not isinstance(x, Index):\n            return Index(x)\n        return x\n\n    def all_indexes_same(indexes):\n        from pandas import Index\n        for ix in indexes[1:]:\n            if not isinstance(ix, Index) or not ix.equals(indexes[0]):\n                return False\n        return True\n\n    def _concat_indexes(indexes):\n        from pandas import MultiIndex, concat\n        from pandas.core.series import Series\n        from pandas.core.groupby.groupby import GroupBy\n        from pandas.core.frame import DataFrame\n\n        zipped = list(zip(*indexes))\n        index = concat(\n            [Series(zipped[i], name=i) for i in range(len(zipped))], axis=1\n        )\n        if isinstance(index, DataFrame):\n            index = index.groupby(list(range(index.shape[1]))).grouper.group_info[0]\n        elif isinstance(index, GroupBy):\n            index = index.group_info[0]\n        return MultiIndex.from_tuples(index)\n\n    if levels is None:\n        levels, _ = factorize_from_iterables(keys)\n    else:\n        levels = [ensure_index(x) for x in levels]\n\n    if not all_indexes_same(indexes):\n        codes_list = []\n\n        for hlevel, level in zip(zip(*keys), levels):\n            to_concat = []\n            for key, index in zip(hlevel, indexes):\n                try:\n                    i = level.get_loc(key)\n                except KeyError as err:\n                    raise ValueError(f\"Key {key} not in level {level}\") from err\n\n                to_concat.append(np.repeat(i, len(index)))\n            codes_list.append(np.concatenate(to_concat))\n\n        concat_index = _concat_indexes(indexes)\n\n        if isinstance(concat_index, MultiIndex):\n            levels.extend(concat_index.levels)\n            codes_list.extend(concat_index.codes)\n        else:\n            codes, categories = factorize_from_iterables(concat_index)\n            levels.append(categories)\n            codes_list.append(codes)\n\n        if len(names) != len(levels):\n            if len({idx.nlevels for idx in indexes}) != 1:\n                raise AssertionError(\n                    \"Cannot concat indices that do not have the same number of levels\"\n                )\n            names = names + get_consensus_names(indexes)\n\n        return MultiIndex(\n            levels=levels, codes=codes_list, names=names, verify_integrity=False\n        )\n\n    new_index = indexes[0]\n    n = len(new_index)\n    kpieces = len(indexes)\n    new_names = list(names)\n    new_levels = list(levels)\n\n    new_codes = []\n\n    for hlevel, level in zip(zip(*keys), levels):\n        hlevel = ensure_index(hlevel)\n        mapped = level.get_indexer(hlevel)\n\n        mask = mapped == -1\n        if mask.any():\n            raise ValueError(f\"Values not found in passed level: {hlevel[mask]!s}\")\n\n        new_codes.append(np.repeat(mapped, n))\n\n    if isinstance(new_index, MultiIndex):\n        new_levels.extend(new_index.levels)\n        new_codes.extend([np.tile(lab, kpieces) for lab in new_index.codes])\n    else:\n        new_levels.append(new_index)\n        new_codes.append(np.tile(np.arange(n), kpieces))\n\n    if len(new_names) < len(new_levels):\n        new_names.extend(new_index.names)\n\n    return MultiIndex(\n        levels=new_levels, codes=new_codes, names=new_names, verify_integrity=False\n    )",
            "imports": [
                "from pandas.core.arrays.categorical import factorize_from_iterables",
                "from pandas.core.indexes.multi import MultiIndex",
                "import numpy as np",
                "from pandas import Index",
                "from pandas import Index",
                "from pandas import MultiIndex, concat",
                "from pandas.core.series import Series",
                "from pandas.core.groupby.groupby import GroupBy",
                "from pandas.core.frame import DataFrame"
            ]
        }
    ]
}