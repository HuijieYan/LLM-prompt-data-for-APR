{
    "1.1.1": "@Appender(_shared_docs[\"interpolate\"] % _shared_doc_kwargs)\ndef interpolate(\n    self,\n    method=\"linear\",\n    axis=0,\n    limit=None,\n    inplace=False,\n    limit_direction=\"forward\",\n    limit_area=None,\n    downcast=None,\n    **kwargs\n):\n    \n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n\n    if axis == 0:\n        ax = self._info_axis_name\n        _maybe_transposed_self = self\n    elif axis == 1:\n        _maybe_transposed_self = self.T\n        ax = 1\n    else:\n        _maybe_transposed_self = self\n    ax = _maybe_transposed_self._get_axis_number(ax)\n\n    if _maybe_transposed_self.ndim == 2:\n        alt_ax = 1 - ax\n    else:\n        alt_ax = ax\n\n    if isinstance(_maybe_transposed_self.index, MultiIndex) and method != \"linear\":\n        raise ValueError(\n            \"Only `method=linear` interpolation is supported on MultiIndexes.\"\n        )\n\n    if _maybe_transposed_self._data.get_dtype_counts().get(\"object\") == len(\n        _maybe_transposed_self.T\n    ):\n        raise TypeError(\n            \"Cannot interpolate with all object-dtype columns \"\n            \"in the DataFrame. Try setting at least one \"\n            \"column to a numeric dtype.\"\n        )\n\n    # create/use the index\n    if method == \"linear\":\n        # prior default\n        index = np.arange(len(_maybe_transposed_self._get_axis(alt_ax)))\n    else:\n        index = _maybe_transposed_self._get_axis(alt_ax)\n        methods = {\"index\", \"values\", \"nearest\", \"time\"}\n        is_numeric_or_datetime = (\n            is_numeric_dtype(index)\n            or is_datetime64_any_dtype(index)\n            or is_timedelta64_dtype(index)\n        )\n        if method not in methods and not is_numeric_or_datetime:\n            raise ValueError(\n                \"Index column must be numeric or datetime type when \"\n                \"using {method} method other than linear. \"\n                \"Try setting a numeric or datetime index column before \"\n                \"interpolating.\".format(method=method)\n            )\n\n    if isna(index).any():\n        raise NotImplementedError(\n            \"Interpolation with NaNs in the index \"\n            \"has not been implemented. Try filling \"\n            \"those NaNs before interpolating.\"\n        )\n    data = _maybe_transposed_self._data\n    new_data = data.interpolate(\n        method=method,\n        axis=ax,\n        index=index,\n        values=_maybe_transposed_self,\n        limit=limit,\n        limit_direction=limit_direction,\n        limit_area=limit_area,\n        inplace=inplace,\n        downcast=downcast,\n        **kwargs\n    )\n\n    if inplace:\n        if axis == 1:\n            new_data = self._constructor(new_data).T._data\n        self._update_inplace(new_data)\n    else:\n        res = self._constructor(new_data).__finalize__(self)\n        if axis == 1:\n            res = res.T\n        return res\n",
    "1.1.2": "Interpolate values according to different methods.",
    "1.2.1": "class NDFrame(PandasObject, SelectionMixin)",
    "1.2.2": "N-dimensional analogue of DataFrame. Store multi-dimensional in a\nsize-mutable, labeled data structure\n\nParameters\n----------\ndata : BlockManager\naxes : list\ncopy : bool, default False",
    "1.2.3": [
        "_constructor(self)",
        "_get_axis_number(cls, axis)",
        "_get_axis(self, axis)",
        "ndim(self)",
        "get(self, key, default=None)",
        "_update_inplace(self, result, verify_is_copy=True)",
        "__finalize__(self, other, method=None, **kwargs)",
        "get_dtype_counts(self)",
        "interpolate(self, method='linear', axis=0, limit=None, inplace=False, limit_direction='forward', limit_area=None, downcast=None, **kwargs)",
        "isna(self)"
    ],
    "1.2.4": null,
    "1.2.5": null,
    "1.3.1": "pandas/core/generic.py",
    "1.3.2": [
        "_constructor(self)",
        "_get_axis_number(cls, axis)",
        "_get_axis(self, axis)",
        "ndim(self)",
        "get(self, key, default=None)",
        "_update_inplace(self, result, verify_is_copy=True)",
        "__finalize__(self, other, method=None, **kwargs)",
        "get_dtype_counts(self)",
        "interpolate(self, method='linear', axis=0, limit=None, inplace=False, limit_direction='forward', limit_area=None, downcast=None, **kwargs)",
        "isna(self)"
    ],
    "1.4.1": [
        "    @pytest.mark.parametrize(\n        \"axis_name, axis_number\",\n        [\n            pytest.param(\"rows\", 0, id=\"rows_0\"),\n            pytest.param(\"index\", 0, id=\"index_0\"),\n            pytest.param(\"columns\", 1, id=\"columns_1\"),\n        ],\n    )\n    def test_interp_axis_names(self, axis_name, axis_number):\n        # GH 29132: test axis names\n        data = {0: [0, np.nan, 6], 1: [1, np.nan, 7], 2: [2, 5, 8]}\n\n        df = DataFrame(data, dtype=np.float64)\n        result = df.interpolate(axis=axis_name, method=\"linear\")\n        expected = df.interpolate(axis=axis_number, method=\"linear\")\n        assert_frame_equal(result, expected)",
        "    @pytest.mark.parametrize(\n        \"axis_name, axis_number\",\n        [\n            pytest.param(\"rows\", 0, id=\"rows_0\"),\n            pytest.param(\"index\", 0, id=\"index_0\"),\n            pytest.param(\"columns\", 1, id=\"columns_1\"),\n        ],\n    )\n    def test_interp_axis_names(self, axis_name, axis_number):\n        # GH 29132: test axis names\n        data = {0: [0, np.nan, 6], 1: [1, np.nan, 7], 2: [2, 5, 8]}\n\n        df = DataFrame(data, dtype=np.float64)\n        result = df.interpolate(axis=axis_name, method=\"linear\")\n        expected = df.interpolate(axis=axis_number, method=\"linear\")\n        assert_frame_equal(result, expected)",
        "    @pytest.mark.parametrize(\n        \"axis_name, axis_number\",\n        [\n            pytest.param(\"rows\", 0, id=\"rows_0\"),\n            pytest.param(\"index\", 0, id=\"index_0\"),\n            pytest.param(\"columns\", 1, id=\"columns_1\"),\n        ],\n    )\n    def test_interp_axis_names(self, axis_name, axis_number):\n        # GH 29132: test axis names\n        data = {0: [0, np.nan, 6], 1: [1, np.nan, 7], 2: [2, 5, 8]}\n\n        df = DataFrame(data, dtype=np.float64)\n        result = df.interpolate(axis=axis_name, method=\"linear\")\n        expected = df.interpolate(axis=axis_number, method=\"linear\")\n        assert_frame_equal(result, expected)"
    ],
    "1.4.2": [
        "pandas/tests/frame/test_missing.py",
        "pandas/tests/frame/test_missing.py",
        "pandas/tests/frame/test_missing.py"
    ],
    "2.1.1": [
        [
            "E       UnboundLocalError: local variable 'ax' referenced before assignment"
        ],
        [
            "E       UnboundLocalError: local variable 'ax' referenced before assignment"
        ],
        [
            "E       UnboundLocalError: local variable 'ax' referenced before assignment"
        ]
    ],
    "2.1.2": [
        [
            "self = <pandas.tests.frame.test_missing.TestDataFrameInterpolate object at 0x11d7db850>\naxis_name = 'rows', axis_number = 0\n\n    @pytest.mark.parametrize(\n        \"axis_name, axis_number\",\n        [\n            pytest.param(\"rows\", 0, id=\"rows_0\"),\n            pytest.param(\"index\", 0, id=\"index_0\"),\n            pytest.param(\"columns\", 1, id=\"columns_1\"),\n        ],\n    )\n    def test_interp_axis_names(self, axis_name, axis_number):\n        # GH 29132: test axis names\n        data = {0: [0, np.nan, 6], 1: [1, np.nan, 7], 2: [2, 5, 8]}\n    \n        df = DataFrame(data, dtype=np.float64)\n>       result = df.interpolate(axis=axis_name, method=\"linear\")\n\npandas/tests/frame/test_missing.py:894: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself =      0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0\nmethod = 'linear', axis = 'rows', limit = None, inplace = False\nlimit_direction = 'forward', limit_area = None, downcast = None, kwargs = {}\n_maybe_transposed_self =      0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0\n\n    @Appender(_shared_docs[\"interpolate\"] % _shared_doc_kwargs)\n    def interpolate(\n        self,\n        method=\"linear\",\n        axis=0,\n        limit=None,\n        inplace=False,\n        limit_direction=\"forward\",\n        limit_area=None,\n        downcast=None,\n        **kwargs\n    ):\n        \"\"\"\n        Interpolate values according to different methods.\n        \"\"\"\n        inplace = validate_bool_kwarg(inplace, \"inplace\")\n    \n        if axis == 0:\n            ax = self._info_axis_name\n            _maybe_transposed_self = self\n        elif axis == 1:\n            _maybe_transposed_self = self.T\n            ax = 1\n        else:\n            _maybe_transposed_self = self\n>       ax = _maybe_transposed_self._get_axis_number(ax)",
            "\npandas/core/generic.py:7059: UnboundLocalError"
        ],
        [
            "self = <pandas.tests.frame.test_missing.TestDataFrameInterpolate object at 0x11d90ce20>\naxis_name = 'index', axis_number = 0\n\n    @pytest.mark.parametrize(\n        \"axis_name, axis_number\",\n        [\n            pytest.param(\"rows\", 0, id=\"rows_0\"),\n            pytest.param(\"index\", 0, id=\"index_0\"),\n            pytest.param(\"columns\", 1, id=\"columns_1\"),\n        ],\n    )\n    def test_interp_axis_names(self, axis_name, axis_number):\n        # GH 29132: test axis names\n        data = {0: [0, np.nan, 6], 1: [1, np.nan, 7], 2: [2, 5, 8]}\n    \n        df = DataFrame(data, dtype=np.float64)\n>       result = df.interpolate(axis=axis_name, method=\"linear\")\n\npandas/tests/frame/test_missing.py:894: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself =      0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0\nmethod = 'linear', axis = 'index', limit = None, inplace = False\nlimit_direction = 'forward', limit_area = None, downcast = None, kwargs = {}\n_maybe_transposed_self =      0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0\n\n    @Appender(_shared_docs[\"interpolate\"] % _shared_doc_kwargs)\n    def interpolate(\n        self,\n        method=\"linear\",\n        axis=0,\n        limit=None,\n        inplace=False,\n        limit_direction=\"forward\",\n        limit_area=None,\n        downcast=None,\n        **kwargs\n    ):\n        \"\"\"\n        Interpolate values according to different methods.\n        \"\"\"\n        inplace = validate_bool_kwarg(inplace, \"inplace\")\n    \n        if axis == 0:\n            ax = self._info_axis_name\n            _maybe_transposed_self = self\n        elif axis == 1:\n            _maybe_transposed_self = self.T\n            ax = 1\n        else:\n            _maybe_transposed_self = self\n>       ax = _maybe_transposed_self._get_axis_number(ax)",
            "\npandas/core/generic.py:7059: UnboundLocalError"
        ],
        [
            "self = <pandas.tests.frame.test_missing.TestDataFrameInterpolate object at 0x11db1ffa0>\naxis_name = 'columns', axis_number = 1\n\n    @pytest.mark.parametrize(\n        \"axis_name, axis_number\",\n        [\n            pytest.param(\"rows\", 0, id=\"rows_0\"),\n            pytest.param(\"index\", 0, id=\"index_0\"),\n            pytest.param(\"columns\", 1, id=\"columns_1\"),\n        ],\n    )\n    def test_interp_axis_names(self, axis_name, axis_number):\n        # GH 29132: test axis names\n        data = {0: [0, np.nan, 6], 1: [1, np.nan, 7], 2: [2, 5, 8]}\n    \n        df = DataFrame(data, dtype=np.float64)\n>       result = df.interpolate(axis=axis_name, method=\"linear\")\n\npandas/tests/frame/test_missing.py:894: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself =      0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0\nmethod = 'linear', axis = 'columns', limit = None, inplace = False\nlimit_direction = 'forward', limit_area = None, downcast = None, kwargs = {}\n_maybe_transposed_self =      0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0\n\n    @Appender(_shared_docs[\"interpolate\"] % _shared_doc_kwargs)\n    def interpolate(\n        self,\n        method=\"linear\",\n        axis=0,\n        limit=None,\n        inplace=False,\n        limit_direction=\"forward\",\n        limit_area=None,\n        downcast=None,\n        **kwargs\n    ):\n        \"\"\"\n        Interpolate values according to different methods.\n        \"\"\"\n        inplace = validate_bool_kwarg(inplace, \"inplace\")\n    \n        if axis == 0:\n            ax = self._info_axis_name\n            _maybe_transposed_self = self\n        elif axis == 1:\n            _maybe_transposed_self = self.T\n            ax = 1\n        else:\n            _maybe_transposed_self = self\n>       ax = _maybe_transposed_self._get_axis_number(ax)",
            "\npandas/core/generic.py:7059: UnboundLocalError"
        ]
    ],
    "2.1.3": null,
    "2.1.4": null,
    "2.1.5": [
        [
            {
                "inplace": {
                    "value": "False",
                    "shape": null
                },
                "axis": {
                    "value": "'rows'",
                    "shape": "4"
                },
                "self": {
                    "value": "     0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0",
                    "shape": "(3, 3)"
                },
                "self._info_axis_name": {
                    "value": "'columns'",
                    "shape": "7"
                },
                "self.T": {
                    "value": "     0    1    2\n0  0.0  NaN  6.0\n1  1.0  NaN  7.0\n2  2.0  5.0  8.0",
                    "shape": "(3, 3)"
                },
                "method": {
                    "value": "'linear'",
                    "shape": "6"
                },
                "limit_direction": {
                    "value": "'forward'",
                    "shape": "7"
                },
                "kwargs": {
                    "value": "{}",
                    "shape": "0"
                }
            },
            {
                "axis": {
                    "value": "0",
                    "shape": null
                },
                "ax": {
                    "value": "1",
                    "shape": null
                },
                "_maybe_transposed_self": {
                    "value": "     0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0",
                    "shape": "(3, 3)"
                },
                "_maybe_transposed_self.ndim": {
                    "value": "2",
                    "shape": null
                },
                "alt_ax": {
                    "value": "0",
                    "shape": null
                },
                "_maybe_transposed_self.index": {
                    "value": "RangeIndex(start=0, stop=3, step=1)",
                    "shape": "(3,)"
                },
                "_maybe_transposed_self._data": {
                    "value": "BlockManager\nItems: Int64Index([0, 1, 2], dtype='int64')\nAxis 1: RangeIndex(start=0, stop=3, step=1)\nFloatBlock: slice(0, 3, 1), 3 x 3, dtype: float64",
                    "shape": "(3, 3)"
                },
                "_maybe_transposed_self.T": {
                    "value": "     0    1    2\n0  0.0  NaN  6.0\n1  1.0  NaN  7.0\n2  2.0  5.0  8.0",
                    "shape": "(3, 3)"
                },
                "index": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)"
                },
                "data": {
                    "value": "BlockManager\nItems: Int64Index([0, 1, 2], dtype='int64')\nAxis 1: RangeIndex(start=0, stop=3, step=1)\nFloatBlock: slice(0, 3, 1), 3 x 3, dtype: float64",
                    "shape": "(3, 3)"
                },
                "new_data": {
                    "value": "BlockManager\nItems: Int64Index([0, 1, 2], dtype='int64')\nAxis 1: RangeIndex(start=0, stop=3, step=1)\nFloatBlock: slice(0, 3, 1), 3 x 3, dtype: float64",
                    "shape": "(3, 3)"
                },
                "res": {
                    "value": "     0    1    2\n0  0.0  1.0  2.0\n1  3.0  4.0  5.0\n2  6.0  7.0  8.0",
                    "shape": "(3, 3)"
                },
                "res.T": {
                    "value": "     0    1    2\n0  0.0  3.0  6.0\n1  1.0  4.0  7.0\n2  2.0  5.0  8.0",
                    "shape": "(3, 3)"
                }
            }
        ],
        [
            {
                "inplace": {
                    "value": "False",
                    "shape": null
                },
                "axis": {
                    "value": "0",
                    "shape": null
                },
                "self": {
                    "value": "     0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0",
                    "shape": "(3, 3)"
                },
                "self._info_axis_name": {
                    "value": "'columns'",
                    "shape": "7"
                },
                "self.T": {
                    "value": "     0    1    2\n0  0.0  NaN  6.0\n1  1.0  NaN  7.0\n2  2.0  5.0  8.0",
                    "shape": "(3, 3)"
                },
                "method": {
                    "value": "'linear'",
                    "shape": "6"
                },
                "limit_direction": {
                    "value": "'forward'",
                    "shape": "7"
                },
                "kwargs": {
                    "value": "{}",
                    "shape": "0"
                }
            },
            {
                "ax": {
                    "value": "1",
                    "shape": null
                },
                "_maybe_transposed_self": {
                    "value": "     0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0",
                    "shape": "(3, 3)"
                },
                "_maybe_transposed_self.ndim": {
                    "value": "2",
                    "shape": null
                },
                "alt_ax": {
                    "value": "0",
                    "shape": null
                },
                "_maybe_transposed_self.index": {
                    "value": "RangeIndex(start=0, stop=3, step=1)",
                    "shape": "(3,)"
                },
                "_maybe_transposed_self._data": {
                    "value": "BlockManager\nItems: Int64Index([0, 1, 2], dtype='int64')\nAxis 1: RangeIndex(start=0, stop=3, step=1)\nFloatBlock: slice(0, 3, 1), 3 x 3, dtype: float64",
                    "shape": "(3, 3)"
                },
                "_maybe_transposed_self.T": {
                    "value": "     0    1    2\n0  0.0  NaN  6.0\n1  1.0  NaN  7.0\n2  2.0  5.0  8.0",
                    "shape": "(3, 3)"
                },
                "index": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)"
                },
                "data": {
                    "value": "BlockManager\nItems: Int64Index([0, 1, 2], dtype='int64')\nAxis 1: RangeIndex(start=0, stop=3, step=1)\nFloatBlock: slice(0, 3, 1), 3 x 3, dtype: float64",
                    "shape": "(3, 3)"
                },
                "new_data": {
                    "value": "BlockManager\nItems: Int64Index([0, 1, 2], dtype='int64')\nAxis 1: RangeIndex(start=0, stop=3, step=1)\nFloatBlock: slice(0, 3, 1), 3 x 3, dtype: float64",
                    "shape": "(3, 3)"
                },
                "res": {
                    "value": "     0    1    2\n0  0.0  1.0  2.0\n1  3.0  4.0  5.0\n2  6.0  7.0  8.0",
                    "shape": "(3, 3)"
                },
                "res.T": {
                    "value": "     0    1    2\n0  0.0  3.0  6.0\n1  1.0  4.0  7.0\n2  2.0  5.0  8.0",
                    "shape": "(3, 3)"
                }
            }
        ],
        [
            {
                "inplace": {
                    "value": "False",
                    "shape": null
                },
                "axis": {
                    "value": "'index'",
                    "shape": "5"
                },
                "self": {
                    "value": "     0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0",
                    "shape": "(3, 3)"
                },
                "self._info_axis_name": {
                    "value": "'columns'",
                    "shape": "7"
                },
                "self.T": {
                    "value": "     0    1    2\n0  0.0  NaN  6.0\n1  1.0  NaN  7.0\n2  2.0  5.0  8.0",
                    "shape": "(3, 3)"
                },
                "method": {
                    "value": "'linear'",
                    "shape": "6"
                },
                "limit_direction": {
                    "value": "'forward'",
                    "shape": "7"
                },
                "kwargs": {
                    "value": "{}",
                    "shape": "0"
                }
            },
            {
                "axis": {
                    "value": "0",
                    "shape": null
                },
                "ax": {
                    "value": "1",
                    "shape": null
                },
                "_maybe_transposed_self": {
                    "value": "     0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0",
                    "shape": "(3, 3)"
                },
                "_maybe_transposed_self.ndim": {
                    "value": "2",
                    "shape": null
                },
                "alt_ax": {
                    "value": "0",
                    "shape": null
                },
                "_maybe_transposed_self.index": {
                    "value": "RangeIndex(start=0, stop=3, step=1)",
                    "shape": "(3,)"
                },
                "_maybe_transposed_self._data": {
                    "value": "BlockManager\nItems: Int64Index([0, 1, 2], dtype='int64')\nAxis 1: RangeIndex(start=0, stop=3, step=1)\nFloatBlock: slice(0, 3, 1), 3 x 3, dtype: float64",
                    "shape": "(3, 3)"
                },
                "_maybe_transposed_self.T": {
                    "value": "     0    1    2\n0  0.0  NaN  6.0\n1  1.0  NaN  7.0\n2  2.0  5.0  8.0",
                    "shape": "(3, 3)"
                },
                "index": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)"
                },
                "data": {
                    "value": "BlockManager\nItems: Int64Index([0, 1, 2], dtype='int64')\nAxis 1: RangeIndex(start=0, stop=3, step=1)\nFloatBlock: slice(0, 3, 1), 3 x 3, dtype: float64",
                    "shape": "(3, 3)"
                },
                "new_data": {
                    "value": "BlockManager\nItems: Int64Index([0, 1, 2], dtype='int64')\nAxis 1: RangeIndex(start=0, stop=3, step=1)\nFloatBlock: slice(0, 3, 1), 3 x 3, dtype: float64",
                    "shape": "(3, 3)"
                },
                "res": {
                    "value": "     0    1    2\n0  0.0  1.0  2.0\n1  3.0  4.0  5.0\n2  6.0  7.0  8.0",
                    "shape": "(3, 3)"
                },
                "res.T": {
                    "value": "     0    1    2\n0  0.0  3.0  6.0\n1  1.0  4.0  7.0\n2  2.0  5.0  8.0",
                    "shape": "(3, 3)"
                }
            }
        ],
        [
            {
                "inplace": {
                    "value": "False",
                    "shape": null
                },
                "axis": {
                    "value": "'columns'",
                    "shape": "7"
                },
                "self": {
                    "value": "     0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0",
                    "shape": "(3, 3)"
                },
                "self._info_axis_name": {
                    "value": "'columns'",
                    "shape": "7"
                },
                "self.T": {
                    "value": "     0    1    2\n0  0.0  NaN  6.0\n1  1.0  NaN  7.0\n2  2.0  5.0  8.0",
                    "shape": "(3, 3)"
                },
                "method": {
                    "value": "'linear'",
                    "shape": "6"
                },
                "limit_direction": {
                    "value": "'forward'",
                    "shape": "7"
                },
                "kwargs": {
                    "value": "{}",
                    "shape": "0"
                }
            },
            {
                "axis": {
                    "value": "1",
                    "shape": null
                },
                "ax": {
                    "value": "1",
                    "shape": null
                },
                "_maybe_transposed_self": {
                    "value": "     0    1    2\n0  0.0  NaN  6.0\n1  1.0  NaN  7.0\n2  2.0  5.0  8.0",
                    "shape": "(3, 3)"
                },
                "_maybe_transposed_self.ndim": {
                    "value": "2",
                    "shape": null
                },
                "alt_ax": {
                    "value": "0",
                    "shape": null
                },
                "_maybe_transposed_self.index": {
                    "value": "Int64Index([0, 1, 2], dtype='int64')",
                    "shape": "(3,)"
                },
                "_maybe_transposed_self._data": {
                    "value": "BlockManager\nItems: RangeIndex(start=0, stop=3, step=1)\nAxis 1: Int64Index([0, 1, 2], dtype='int64')\nFloatBlock: slice(0, 3, 1), 3 x 3, dtype: float64",
                    "shape": "(3, 3)"
                },
                "_maybe_transposed_self.T": {
                    "value": "     0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0",
                    "shape": "(3, 3)"
                },
                "index": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)"
                },
                "data": {
                    "value": "BlockManager\nItems: RangeIndex(start=0, stop=3, step=1)\nAxis 1: Int64Index([0, 1, 2], dtype='int64')\nFloatBlock: slice(0, 3, 1), 3 x 3, dtype: float64",
                    "shape": "(3, 3)"
                },
                "new_data": {
                    "value": "BlockManager\nItems: RangeIndex(start=0, stop=3, step=1)\nAxis 1: Int64Index([0, 1, 2], dtype='int64')\nFloatBlock: slice(0, 3, 1), 3 x 3, dtype: float64",
                    "shape": "(3, 3)"
                },
                "res": {
                    "value": "     0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0",
                    "shape": "(3, 3)"
                },
                "res.T": {
                    "value": "     0    1    2\n0  0.0  NaN  6.0\n1  1.0  NaN  7.0\n2  2.0  5.0  8.0",
                    "shape": "(3, 3)"
                }
            }
        ],
        [
            {
                "inplace": {
                    "value": "False",
                    "shape": null
                },
                "axis": {
                    "value": "1",
                    "shape": null
                },
                "self": {
                    "value": "     0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0",
                    "shape": "(3, 3)"
                },
                "self._info_axis_name": {
                    "value": "'columns'",
                    "shape": "7"
                },
                "self.T": {
                    "value": "     0    1    2\n0  0.0  NaN  6.0\n1  1.0  NaN  7.0\n2  2.0  5.0  8.0",
                    "shape": "(3, 3)"
                },
                "method": {
                    "value": "'linear'",
                    "shape": "6"
                },
                "limit_direction": {
                    "value": "'forward'",
                    "shape": "7"
                },
                "kwargs": {
                    "value": "{}",
                    "shape": "0"
                }
            },
            {
                "ax": {
                    "value": "1",
                    "shape": null
                },
                "_maybe_transposed_self": {
                    "value": "     0    1    2\n0  0.0  NaN  6.0\n1  1.0  NaN  7.0\n2  2.0  5.0  8.0",
                    "shape": "(3, 3)"
                },
                "_maybe_transposed_self.ndim": {
                    "value": "2",
                    "shape": null
                },
                "alt_ax": {
                    "value": "0",
                    "shape": null
                },
                "_maybe_transposed_self.index": {
                    "value": "Int64Index([0, 1, 2], dtype='int64')",
                    "shape": "(3,)"
                },
                "_maybe_transposed_self._data": {
                    "value": "BlockManager\nItems: RangeIndex(start=0, stop=3, step=1)\nAxis 1: Int64Index([0, 1, 2], dtype='int64')\nFloatBlock: slice(0, 3, 1), 3 x 3, dtype: float64",
                    "shape": "(3, 3)"
                },
                "_maybe_transposed_self.T": {
                    "value": "     0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0",
                    "shape": "(3, 3)"
                },
                "index": {
                    "value": "array([0, 1, 2])",
                    "shape": "(3,)"
                },
                "data": {
                    "value": "BlockManager\nItems: RangeIndex(start=0, stop=3, step=1)\nAxis 1: Int64Index([0, 1, 2], dtype='int64')\nFloatBlock: slice(0, 3, 1), 3 x 3, dtype: float64",
                    "shape": "(3, 3)"
                },
                "new_data": {
                    "value": "BlockManager\nItems: RangeIndex(start=0, stop=3, step=1)\nAxis 1: Int64Index([0, 1, 2], dtype='int64')\nFloatBlock: slice(0, 3, 1), 3 x 3, dtype: float64",
                    "shape": "(3, 3)"
                },
                "res": {
                    "value": "     0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0",
                    "shape": "(3, 3)"
                },
                "res.T": {
                    "value": "     0    1    2\n0  0.0  NaN  6.0\n1  1.0  NaN  7.0\n2  2.0  5.0  8.0",
                    "shape": "(3, 3)"
                }
            }
        ]
    ],
    "2.1.6": [
        [
            {
                "inplace": "bool",
                "axis": "str",
                "self": "DataFrame",
                "self._info_axis_name": "str",
                "self.T": "DataFrame",
                "method": "str",
                "limit_direction": "str",
                "kwargs": "dict"
            },
            {
                "axis": "int",
                "ax": "int",
                "_maybe_transposed_self": "DataFrame",
                "_maybe_transposed_self.ndim": "int",
                "alt_ax": "int",
                "_maybe_transposed_self.index": "RangeIndex",
                "_maybe_transposed_self._data": "BlockManager",
                "_maybe_transposed_self.T": "DataFrame",
                "index": "ndarray",
                "data": "BlockManager",
                "new_data": "BlockManager",
                "res": "DataFrame",
                "res.T": "DataFrame"
            }
        ],
        [
            {
                "inplace": "bool",
                "axis": "int",
                "self": "DataFrame",
                "self._info_axis_name": "str",
                "self.T": "DataFrame",
                "method": "str",
                "limit_direction": "str",
                "kwargs": "dict"
            },
            {
                "ax": "int",
                "_maybe_transposed_self": "DataFrame",
                "_maybe_transposed_self.ndim": "int",
                "alt_ax": "int",
                "_maybe_transposed_self.index": "RangeIndex",
                "_maybe_transposed_self._data": "BlockManager",
                "_maybe_transposed_self.T": "DataFrame",
                "index": "ndarray",
                "data": "BlockManager",
                "new_data": "BlockManager",
                "res": "DataFrame",
                "res.T": "DataFrame"
            }
        ],
        [
            {
                "inplace": "bool",
                "axis": "str",
                "self": "DataFrame",
                "self._info_axis_name": "str",
                "self.T": "DataFrame",
                "method": "str",
                "limit_direction": "str",
                "kwargs": "dict"
            },
            {
                "axis": "int",
                "ax": "int",
                "_maybe_transposed_self": "DataFrame",
                "_maybe_transposed_self.ndim": "int",
                "alt_ax": "int",
                "_maybe_transposed_self.index": "RangeIndex",
                "_maybe_transposed_self._data": "BlockManager",
                "_maybe_transposed_self.T": "DataFrame",
                "index": "ndarray",
                "data": "BlockManager",
                "new_data": "BlockManager",
                "res": "DataFrame",
                "res.T": "DataFrame"
            }
        ],
        [
            {
                "inplace": "bool",
                "axis": "str",
                "self": "DataFrame",
                "self._info_axis_name": "str",
                "self.T": "DataFrame",
                "method": "str",
                "limit_direction": "str",
                "kwargs": "dict"
            },
            {
                "axis": "int",
                "ax": "int",
                "_maybe_transposed_self": "DataFrame",
                "_maybe_transposed_self.ndim": "int",
                "alt_ax": "int",
                "_maybe_transposed_self.index": "Int64Index",
                "_maybe_transposed_self._data": "BlockManager",
                "_maybe_transposed_self.T": "DataFrame",
                "index": "ndarray",
                "data": "BlockManager",
                "new_data": "BlockManager",
                "res": "DataFrame",
                "res.T": "DataFrame"
            }
        ],
        [
            {
                "inplace": "bool",
                "axis": "int",
                "self": "DataFrame",
                "self._info_axis_name": "str",
                "self.T": "DataFrame",
                "method": "str",
                "limit_direction": "str",
                "kwargs": "dict"
            },
            {
                "ax": "int",
                "_maybe_transposed_self": "DataFrame",
                "_maybe_transposed_self.ndim": "int",
                "alt_ax": "int",
                "_maybe_transposed_self.index": "Int64Index",
                "_maybe_transposed_self._data": "BlockManager",
                "_maybe_transposed_self.T": "DataFrame",
                "index": "ndarray",
                "data": "BlockManager",
                "new_data": "BlockManager",
                "res": "DataFrame",
                "res.T": "DataFrame"
            }
        ]
    ],
    "3.1.1": [
        "NDFrame.interpolate(): variable 'ax' not assigned when axis='index'\n"
    ],
    "3.1.2": [
        "The NDFrame.interpolate function fails when passing a string as axis. Example:\n\n>>> import numpy as np\n>>> import pandas as pd\n>>> df = pd.DataFrame(np.zeros((3,2)), columns=['a','b'])\n>>> df.iloc[1] = np.nan\n>>> df\n     a    b\n0  0.0  0.0\n1  NaN  NaN\n2  0.0  0.0\n>>> df.interpolate(axis=0)\n     a    b\n0  0.0  0.0\n1  0.0  0.0\n2  0.0  0.0\n>>> df.interpolate(axis='index')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/Users/lehanson/anaconda3/envs/plots/lib/python3.7/site-packages/pandas/core/generic.py\", line 7006, in interpolate\n    ax = _maybe_transposed_self._get_axis_number(ax)\nUnboundLocalError: local variable 'ax' referenced before assignment\nFrom the documentation and from the function itself, it looks like df.interpolate(axis='index') was intended to work, but that maybe someone accidentally deleted a line in generic.py? The function seems to work properly if I add ax = axis in the else block here:\npandas/pandas/core/generic.py\n\nLines 6998 to 7006 in 171c716\n\n if axis == 0: \n     ax = self._info_axis_name \n     _maybe_transposed_self = self \n elif axis == 1: \n     _maybe_transposed_self = self.T \n     ax = 1 \n else: \n     _maybe_transposed_self = self \n ax = _maybe_transposed_self._get_axis_number(ax) \nI am using pandas version 0.25.1\n"
    ]
}