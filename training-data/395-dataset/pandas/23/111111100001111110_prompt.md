Please fix the function/method provided below and provide the corrected function/method as the output.


# Buggy function source code
```python
# file name: /Volumes/JerrySSD/bgp_envs/repos/pandas_23/pandas/core/indexes/datetimelike.py

# relative function's signature in this file
def values(self):
    # ... omitted code ...
    pass

# relative function's signature in this file
def equals(self, other) -> bool:
    # ... omitted code ...
    pass

# relative function's signature in this file
def _set_freq(self, freq):
    # ... omitted code ...
    pass

# relative function's signature in this file
def _shallow_copy(self, values=None, name: Label=lib.no_default):
    # ... omitted code ...
    pass

# relative function's signature in this file
def intersection(self, other, sort=False):
    # ... omitted code ...
    pass

# class declaration containing the buggy function
class DatetimeTimedeltaMixin(DatetimeIndexOpsMixin, Int64Index):
    """
    Mixin class for methods shared by DatetimeIndex and TimedeltaIndex,
    but not PeriodIndex
    """

    # ... omitted code ...


    # signature of a relative function in this class
    def _set_freq(self, freq):
        # ... omitted code ...
        pass

    # signature of a relative function in this class
    def _shallow_copy(self, values=None, name: Label=lib.no_default):
        # ... omitted code ...
        pass

    # signature of a relative function in this class
    def intersection(self, other, sort=False):
        # ... omitted code ...
        pass



    # this is the buggy function you need to fix
    def intersection(self, other, sort=False):
        """
        Specialized intersection for DatetimeIndex/TimedeltaIndex.
    
        May be much faster than Index.intersection
    
        Parameters
        ----------
        other : Same type as self or array-like
        sort : False or None, default False
            Sort the resulting index if possible.
    
            .. versionadded:: 0.24.0
    
            .. versionchanged:: 0.24.1
    
               Changed the default to ``False`` to match the behaviour
               from before 0.24.0.
    
            .. versionchanged:: 0.25.0
    
               The `sort` keyword is added
    
        Returns
        -------
        y : Index or same type as self
        """
        self._validate_sort_keyword(sort)
        self._assert_can_do_setop(other)
    
        if self.equals(other):
            return self._get_reconciled_name_object(other)
    
        if len(self) == 0:
            return self.copy()
        if len(other) == 0:
            return other.copy()
    
        if not isinstance(other, type(self)):
            result = Index.intersection(self, other, sort=sort)
            if isinstance(result, type(self)):
                if result.freq is None:
                    result._set_freq("infer")
            return result
    
        elif (
            other.freq is None
            or self.freq is None
            or other.freq != self.freq
            or not other.freq.is_anchored()
            or (not self.is_monotonic or not other.is_monotonic)
        ):
            result = Index.intersection(self, other, sort=sort)
    
            # Invalidate the freq of `result`, which may not be correct at
            # this point, depending on the values.
    
            result._set_freq(None)
            result = self._shallow_copy(result._data, name=result.name)
            if result.freq is None:
                result._set_freq("infer")
            return result
    
        # to make our life easier, "sort" the two ranges
        if self[0] <= other[0]:
            left, right = self, other
        else:
            left, right = other, self
    
        # after sorting, the intersection always starts with the right index
        # and ends with the index of which the last elements is smallest
        end = min(left[-1], right[-1])
        start = right[0]
    
        if end < start:
            return type(self)(data=[])
        else:
            lslice = slice(*left.slice_locs(start, end))
            left_chunk = left.values[lslice]
            return self._shallow_copy(left_chunk)
    
```

# Variable runtime value and type inside buggy function
## Buggy case 1
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

other, value: `array of shape (20161,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... TC]', length=20161, freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, UTC]`, type: `DatetimeTZDtype`

## Buggy case 2
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... TC]', length=20161, freq='T')>`, type: `method`

self, value: `array of shape (20161,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... TC]', length=20161, freq='T')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... TC]', length=20161, freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... TC]', length=20161, freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... TC]', length=20161, freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... TC]', length=20161, freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, UTC]`, type: `DatetimeTZDtype`

## Buggy case 3
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, UTC]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
result, value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)`, type: `DatetimeIndex`

result._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)>`, type: `method`

result._data, value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, UTC]`, type: `DatetimeArray`

## Buggy case 4
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, UTC]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
result, value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)`, type: `DatetimeIndex`

result._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)>`, type: `method`

result._data, value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, UTC]`, type: `DatetimeArray`

## Buggy case 5
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',
               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',
               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',
               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',
               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',
               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',
               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, UTC]`, type: `DatetimeTZDtype`

## Buggy case 6
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... tetime64[ns, UTC]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',
               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',
               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',
               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... tetime64[ns, UTC]', freq='B')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... tetime64[ns, UTC]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... tetime64[ns, UTC]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',
               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',
               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',
               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... tetime64[ns, UTC]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, UTC]`, type: `DatetimeTZDtype`

## Buggy case 7
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, UTC]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`

end, value: `Timestamp('2000-06-05 00:00:00+0000', tz='UTC', freq='B')`, type: `Timestamp`

start, value: `Timestamp('2000-06-13 00:00:00+0000', tz='UTC', freq='B')`, type: `Timestamp`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

left._values, value: `<DatetimeArray>
['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
 '2000-06-05 00:00:00+00:00']
Length: 3, dtype: datetime64[ns, UTC]`, type: `DatetimeArray`

## Buggy case 8
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, UTC]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`

end, value: `Timestamp('2000-06-05 00:00:00+0000', tz='UTC', freq='B')`, type: `Timestamp`

start, value: `Timestamp('2000-06-13 00:00:00+0000', tz='UTC', freq='B')`, type: `Timestamp`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

left._values, value: `<DatetimeArray>
['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
 '2000-06-05 00:00:00+00:00']
Length: 3, dtype: datetime64[ns, UTC]`, type: `DatetimeArray`

## Buggy case 9
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

other, value: `array of shape (20161,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... rn]', length=20161, freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, US/Eastern]`, type: `DatetimeTZDtype`

## Buggy case 10
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... rn]', length=20161, freq='T')>`, type: `method`

self, value: `array of shape (20161,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... rn]', length=20161, freq='T')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... rn]', length=20161, freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... rn]', length=20161, freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... rn]', length=20161, freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... rn]', length=20161, freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, US/Eastern]`, type: `DatetimeTZDtype`

## Buggy case 11
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',
               '2000-06-01 00:02:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',
               '2000-06-01 00:02:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',
               '2000-06-01 00:02:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',
               '2000-06-01 00:02:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',
               '2000-06-01 00:02:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',
               '2000-06-01 00:02:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',
               '2000-06-01 00:02:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, US/Eastern]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
result, value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)`, type: `DatetimeIndex`

result._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)>`, type: `method`

result._data, value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, US/Eastern]`, type: `DatetimeArray`

## Buggy case 12
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',
               '2000-06-01 00:02:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',
               '2000-06-01 00:02:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, US/Eastern]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
result, value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)`, type: `DatetimeIndex`

result._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)>`, type: `method`

result._data, value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, US/Eastern]`, type: `DatetimeArray`

## Buggy case 13
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',
               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',
               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',
               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',
               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',
               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',
               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, US/Eastern]`, type: `DatetimeTZDtype`

## Buggy case 14
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... 4[ns, US/Eastern]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',
               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',
               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',
               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... 4[ns, US/Eastern]', freq='B')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... 4[ns, US/Eastern]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... 4[ns, US/Eastern]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',
               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',
               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',
               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... 4[ns, US/Eastern]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, US/Eastern]`, type: `DatetimeTZDtype`

## Buggy case 15
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, US/Eastern]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`

end, value: `Timestamp('2000-06-05 00:00:00-0400', tz='US/Eastern', freq='B')`, type: `Timestamp`

start, value: `Timestamp('2000-06-13 00:00:00-0400', tz='US/Eastern', freq='B')`, type: `Timestamp`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

left._values, value: `<DatetimeArray>
['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
 '2000-06-05 00:00:00-04:00']
Length: 3, dtype: datetime64[ns, US/Eastern]`, type: `DatetimeArray`

## Buggy case 16
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, US/Eastern]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`

end, value: `Timestamp('2000-06-05 00:00:00-0400', tz='US/Eastern', freq='B')`, type: `Timestamp`

start, value: `Timestamp('2000-06-13 00:00:00-0400', tz='US/Eastern', freq='B')`, type: `Timestamp`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

left._values, value: `<DatetimeArray>
['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
 '2000-06-05 00:00:00-04:00']
Length: 3, dtype: datetime64[ns, US/Eastern]`, type: `DatetimeArray`

## Buggy case 17
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

other, value: `array of shape (20161,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... yo]', length=20161, freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, Asia/Tokyo]`, type: `DatetimeTZDtype`

## Buggy case 18
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... yo]', length=20161, freq='T')>`, type: `method`

self, value: `array of shape (20161,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... yo]', length=20161, freq='T')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... yo]', length=20161, freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... yo]', length=20161, freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... yo]', length=20161, freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... yo]', length=20161, freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, Asia/Tokyo]`, type: `DatetimeTZDtype`

## Buggy case 19
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',
               '2000-06-01 00:02:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',
               '2000-06-01 00:02:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',
               '2000-06-01 00:02:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',
               '2000-06-01 00:02:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',
               '2000-06-01 00:02:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',
               '2000-06-01 00:02:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',
               '2000-06-01 00:02:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, Asia/Tokyo]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
result, value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)`, type: `DatetimeIndex`

result._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)>`, type: `method`

result._data, value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, Asia/Tokyo]`, type: `DatetimeArray`

## Buggy case 20
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',
               '2000-06-01 00:02:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',
               '2000-06-01 00:02:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, Asia/Tokyo]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
result, value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)`, type: `DatetimeIndex`

result._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)>`, type: `method`

result._data, value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, Asia/Tokyo]`, type: `DatetimeArray`

## Buggy case 21
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',
               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',
               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',
               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',
               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',
               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',
               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, Asia/Tokyo]`, type: `DatetimeTZDtype`

## Buggy case 22
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... 4[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',
               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',
               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',
               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... 4[ns, Asia/Tokyo]', freq='B')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... 4[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... 4[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',
               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',
               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',
               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... 4[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, Asia/Tokyo]`, type: `DatetimeTZDtype`

## Buggy case 23
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, Asia/Tokyo]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`

end, value: `Timestamp('2000-06-05 00:00:00+0900', tz='Asia/Tokyo', freq='B')`, type: `Timestamp`

start, value: `Timestamp('2000-06-13 00:00:00+0900', tz='Asia/Tokyo', freq='B')`, type: `Timestamp`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

left._values, value: `<DatetimeArray>
['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
 '2000-06-05 00:00:00+09:00']
Length: 3, dtype: datetime64[ns, Asia/Tokyo]`, type: `DatetimeArray`

## Buggy case 24
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, Asia/Tokyo]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`

end, value: `Timestamp('2000-06-05 00:00:00+0900', tz='Asia/Tokyo', freq='B')`, type: `Timestamp`

start, value: `Timestamp('2000-06-13 00:00:00+0900', tz='Asia/Tokyo', freq='B')`, type: `Timestamp`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

left._values, value: `<DatetimeArray>
['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
 '2000-06-05 00:00:00+09:00']
Length: 3, dtype: datetime64[ns, Asia/Tokyo]`, type: `DatetimeArray`

## Buggy case 25
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

other, value: `array of shape (20161,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... ')]', length=20161, freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeTZDtype`

## Buggy case 26
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... ')]', length=20161, freq='T')>`, type: `method`

self, value: `array of shape (20161,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... ')]', length=20161, freq='T')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... ')]', length=20161, freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... ')]', length=20161, freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... ')]', length=20161, freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... ')]', length=20161, freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeTZDtype`

## Buggy case 27
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',
               '2000-06-01 00:02:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',
               '2000-06-01 00:02:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',
               '2000-06-01 00:02:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',
               '2000-06-01 00:02:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',
               '2000-06-01 00:02:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',
               '2000-06-01 00:02:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',
               '2000-06-01 00:02:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
result, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)`, type: `DatetimeIndex`

result._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)>`, type: `method`

result._data, value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeArray`

## Buggy case 28
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',
               '2000-06-01 00:02:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',
               '2000-06-01 00:02:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
result, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)`, type: `DatetimeIndex`

result._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)>`, type: `method`

result._data, value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeArray`

## Buggy case 29
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00', '2000-06-06 00:00:00-07:00',
               '2000-06-07 00:00:00-07:00', '2000-06-08 00:00:00-07:00',
               '2000-06-09 00:00:00-07:00', '2000-06-12 00:00:00-07:00',
               '2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... nfo/US/Pacific')]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeTZDtype`

## Buggy case 30
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... nfo/US/Pacific')]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00', '2000-06-06 00:00:00-07:00',
               '2000-06-07 00:00:00-07:00', '2000-06-08 00:00:00-07:00',
               '2000-06-09 00:00:00-07:00', '2000-06-12 00:00:00-07:00',
               '2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... nfo/US/Pacific')]', freq='B')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... nfo/US/Pacific')]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... nfo/US/Pacific')]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... nfo/US/Pacific')]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... nfo/US/Pacific')]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeTZDtype`

## Buggy case 31
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`

end, value: `Timestamp('2000-06-05 00:00:00-0700', tz='dateutil//usr/share/zoneinfo/US/Pacific', freq='B')`, type: `Timestamp`

start, value: `Timestamp('2000-06-13 00:00:00-0700', tz='dateutil//usr/share/zoneinfo/US/Pacific', freq='B')`, type: `Timestamp`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

left._values, value: `<DatetimeArray>
['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
 '2000-06-05 00:00:00-07:00']
Length: 3, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeArray`

## Buggy case 32
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`

end, value: `Timestamp('2000-06-05 00:00:00-0700', tz='dateutil//usr/share/zoneinfo/US/Pacific', freq='B')`, type: `Timestamp`

start, value: `Timestamp('2000-06-13 00:00:00-0700', tz='dateutil//usr/share/zoneinfo/US/Pacific', freq='B')`, type: `Timestamp`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

left._values, value: `<DatetimeArray>
['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
 '2000-06-05 00:00:00-07:00']
Length: 3, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeArray`

## Buggy case 33
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

other, value: `array of shape (20161,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... ')]', length=20161, freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeTZDtype`

## Buggy case 34
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... ')]', length=20161, freq='T')>`, type: `method`

self, value: `array of shape (20161,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... ')]', length=20161, freq='T')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... ')]', length=20161, freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... ')]', length=20161, freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... ')]', length=20161, freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... ')]', length=20161, freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeTZDtype`

## Buggy case 35
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',
               '2000-06-01 00:02:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',
               '2000-06-01 00:02:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',
               '2000-06-01 00:02:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',
               '2000-06-01 00:02:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',
               '2000-06-01 00:02:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',
               '2000-06-01 00:02:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',
               '2000-06-01 00:02:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
result, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)`, type: `DatetimeIndex`

result._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)>`, type: `method`

result._data, value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeArray`

## Buggy case 36
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',
               '2000-06-01 00:02:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',
               '2000-06-01 00:02:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
result, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)`, type: `DatetimeIndex`

result._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)>`, type: `method`

result._data, value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeArray`

## Buggy case 37
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

other, value: `array of shape (11,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... Asia/Singapore')]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeTZDtype`

## Buggy case 38
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... Asia/Singapore')]', freq='B')>`, type: `method`

self, value: `array of shape (11,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... Asia/Singapore')]', freq='B')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... Asia/Singapore')]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... Asia/Singapore')]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... Asia/Singapore')]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... Asia/Singapore')]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeTZDtype`

## Buggy case 39
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
               '2000-06-05 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
               '2000-06-05 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
               '2000-06-05 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
               '2000-06-05 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
               '2000-06-05 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
               '2000-06-05 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
               '2000-06-05 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
               '2000-06-05 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`

end, value: `Timestamp('2000-06-05 00:00:00+0800', tz='dateutil//usr/share/zoneinfo/Asia/Singapore', freq='B')`, type: `Timestamp`

start, value: `Timestamp('2000-06-13 00:00:00+0800', tz='dateutil//usr/share/zoneinfo/Asia/Singapore', freq='B')`, type: `Timestamp`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
               '2000-06-05 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

left._values, value: `<DatetimeArray>
['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
 '2000-06-05 00:00:00+08:00']
Length: 3, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeArray`

## Buggy case 40
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
               '2000-06-05 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
               '2000-06-05 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
               '2000-06-05 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`

end, value: `Timestamp('2000-06-05 00:00:00+0800', tz='dateutil//usr/share/zoneinfo/Asia/Singapore', freq='B')`, type: `Timestamp`

start, value: `Timestamp('2000-06-13 00:00:00+0800', tz='dateutil//usr/share/zoneinfo/Asia/Singapore', freq='B')`, type: `Timestamp`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
               '2000-06-05 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

left._values, value: `<DatetimeArray>
['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
 '2000-06-05 00:00:00+08:00']
Length: 3, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeArray`

## Buggy case 41
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

other, value: `array of shape (20161,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... ()]', length=20161, freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, tzutc()]`, type: `DatetimeTZDtype`

## Buggy case 42
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... ()]', length=20161, freq='T')>`, type: `method`

self, value: `array of shape (20161,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... ()]', length=20161, freq='T')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... ()]', length=20161, freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... ()]', length=20161, freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... ()]', length=20161, freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... ()]', length=20161, freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, tzutc()]`, type: `DatetimeTZDtype`

## Buggy case 43
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, tzutc()]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
result, value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)`, type: `DatetimeIndex`

result._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)>`, type: `method`

result._data, value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, tzutc()]`, type: `DatetimeArray`

## Buggy case 44
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, tzutc()]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
result, value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)`, type: `DatetimeIndex`

result._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)>`, type: `method`

result._data, value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, tzutc()]`, type: `DatetimeArray`

## Buggy case 45
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',
               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',
               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',
               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',
               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',
               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',
               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, tzutc()]`, type: `DatetimeTZDtype`

## Buggy case 46
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... me64[ns, tzutc()]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',
               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',
               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',
               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... me64[ns, tzutc()]', freq='B')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... me64[ns, tzutc()]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... me64[ns, tzutc()]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',
               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',
               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',
               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... me64[ns, tzutc()]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, tzutc()]`, type: `DatetimeTZDtype`

## Buggy case 47
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, tzutc()]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`

end, value: `Timestamp('2000-06-05 00:00:00+0000', tz='tzutc()', freq='B')`, type: `Timestamp`

start, value: `Timestamp('2000-06-13 00:00:00+0000', tz='tzutc()', freq='B')`, type: `Timestamp`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

left._values, value: `<DatetimeArray>
['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
 '2000-06-05 00:00:00+00:00']
Length: 3, dtype: datetime64[ns, tzutc()]`, type: `DatetimeArray`

## Buggy case 48
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, tzutc()]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`

end, value: `Timestamp('2000-06-05 00:00:00+0000', tz='tzutc()', freq='B')`, type: `Timestamp`

start, value: `Timestamp('2000-06-13 00:00:00+0000', tz='tzutc()', freq='B')`, type: `Timestamp`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

left._values, value: `<DatetimeArray>
['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
 '2000-06-05 00:00:00+00:00']
Length: 3, dtype: datetime64[ns, tzutc()]`, type: `DatetimeArray`

## Buggy case 49
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

other, value: `array of shape (20161,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... ()]', length=20161, freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, tzlocal()]`, type: `DatetimeTZDtype`

## Buggy case 50
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... ()]', length=20161, freq='T')>`, type: `method`

self, value: `array of shape (20161,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... ()]', length=20161, freq='T')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... ()]', length=20161, freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... ()]', length=20161, freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... ()]', length=20161, freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... ()]', length=20161, freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, tzlocal()]`, type: `DatetimeTZDtype`

## Buggy case 51
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, tzlocal()]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
result, value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)`, type: `DatetimeIndex`

result._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)>`, type: `method`

result._data, value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, tzlocal()]`, type: `DatetimeArray`

## Buggy case 52
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, tzlocal()]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
result, value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)`, type: `DatetimeIndex`

result._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)>`, type: `method`

result._data, value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, tzlocal()]`, type: `DatetimeArray`

## Buggy case 53
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',
               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',
               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',
               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',
               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',
               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',
               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, tzlocal()]`, type: `DatetimeTZDtype`

## Buggy case 54
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... 64[ns, tzlocal()]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',
               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',
               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',
               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... 64[ns, tzlocal()]', freq='B')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... 64[ns, tzlocal()]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... 64[ns, tzlocal()]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',
               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',
               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',
               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... 64[ns, tzlocal()]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, tzlocal()]`, type: `DatetimeTZDtype`

## Buggy case 55
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, tzlocal()]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`

end, value: `Timestamp('2000-06-05 00:00:00+0100', tz='tzlocal()', freq='B')`, type: `Timestamp`

start, value: `Timestamp('2000-06-13 00:00:00+0100', tz='tzlocal()', freq='B')`, type: `Timestamp`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

left._values, value: `<DatetimeArray>
['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
 '2000-06-05 00:00:00+01:00']
Length: 3, dtype: datetime64[ns, tzlocal()]`, type: `DatetimeArray`

## Buggy case 56
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, tzlocal()]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`

end, value: `Timestamp('2000-06-05 00:00:00+0100', tz='tzlocal()', freq='B')`, type: `Timestamp`

start, value: `Timestamp('2000-06-13 00:00:00+0100', tz='tzlocal()', freq='B')`, type: `Timestamp`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

left._values, value: `<DatetimeArray>
['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
 '2000-06-05 00:00:00+01:00']
Length: 3, dtype: datetime64[ns, tzlocal()]`, type: `DatetimeArray`

## Buggy case 57
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

other, value: `array of shape (20161,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeTZDtype`

## Buggy case 58
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... 0)]', length=20161, freq='T')>`, type: `method`

self, value: `array of shape (20161,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... 0)]', length=20161, freq='T')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... 0)]', length=20161, freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... 0)]', length=20161, freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... 0)]', length=20161, freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeTZDtype`

## Buggy case 59
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',
               '2000-06-01 00:02:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',
               '2000-06-01 00:02:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',
               '2000-06-01 00:02:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',
               '2000-06-01 00:02:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',
               '2000-06-01 00:02:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',
               '2000-06-01 00:02:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',
               '2000-06-01 00:02:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
result, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)`, type: `DatetimeIndex`

result._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)>`, type: `method`

result._data, value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeArray`

## Buggy case 60
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',
               '2000-06-01 00:02:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',
               '2000-06-01 00:02:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
result, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)`, type: `DatetimeIndex`

result._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)>`, type: `method`

result._data, value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeArray`

## Buggy case 61
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00', '2000-06-06 00:00:00+05:00',
               '2000-06-07 00:00:00+05:00', '2000-06-08 00:00:00+05:00',
               '2000-06-09 00:00:00+05:00', '2000-06-12 00:00:00+05:00',
               '2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... FixedOffset(300)]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeTZDtype`

## Buggy case 62
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... FixedOffset(300)]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00', '2000-06-06 00:00:00+05:00',
               '2000-06-07 00:00:00+05:00', '2000-06-08 00:00:00+05:00',
               '2000-06-09 00:00:00+05:00', '2000-06-12 00:00:00+05:00',
               '2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... FixedOffset(300)]', freq='B')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... FixedOffset(300)]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... FixedOffset(300)]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... FixedOffset(300)]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... FixedOffset(300)]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeTZDtype`

## Buggy case 63
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`

end, value: `Timestamp('2000-06-05 00:00:00+0500', tz='pytz.FixedOffset(300)', freq='B')`, type: `Timestamp`

start, value: `Timestamp('2000-06-13 00:00:00+0500', tz='pytz.FixedOffset(300)', freq='B')`, type: `Timestamp`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

left._values, value: `<DatetimeArray>
['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
 '2000-06-05 00:00:00+05:00']
Length: 3, dtype: datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeArray`

## Buggy case 64
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`

end, value: `Timestamp('2000-06-05 00:00:00+0500', tz='pytz.FixedOffset(300)', freq='B')`, type: `Timestamp`

start, value: `Timestamp('2000-06-13 00:00:00+0500', tz='pytz.FixedOffset(300)', freq='B')`, type: `Timestamp`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

left._values, value: `<DatetimeArray>
['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
 '2000-06-05 00:00:00+05:00']
Length: 3, dtype: datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeArray`

## Buggy case 65
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

other, value: `array of shape (20161,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeTZDtype`

## Buggy case 66
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... 0)]', length=20161, freq='T')>`, type: `method`

self, value: `array of shape (20161,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... 0)]', length=20161, freq='T')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... 0)]', length=20161, freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... 0)]', length=20161, freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... 0)]', length=20161, freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeTZDtype`

## Buggy case 67
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',
               '2000-06-01 00:02:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',
               '2000-06-01 00:02:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',
               '2000-06-01 00:02:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',
               '2000-06-01 00:02:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',
               '2000-06-01 00:02:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',
               '2000-06-01 00:02:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',
               '2000-06-01 00:02:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
result, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)`, type: `DatetimeIndex`

result._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)>`, type: `method`

result._data, value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeArray`

## Buggy case 68
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',
               '2000-06-01 00:02:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',
               '2000-06-01 00:02:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
result, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)`, type: `DatetimeIndex`

result._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)>`, type: `method`

result._data, value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeArray`

## Buggy case 69
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00', '2000-06-06 00:00:00-05:00',
               '2000-06-07 00:00:00-05:00', '2000-06-08 00:00:00-05:00',
               '2000-06-09 00:00:00-05:00', '2000-06-12 00:00:00-05:00',
               '2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... ixedOffset(-300)]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeTZDtype`

## Buggy case 70
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... ixedOffset(-300)]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00', '2000-06-06 00:00:00-05:00',
               '2000-06-07 00:00:00-05:00', '2000-06-08 00:00:00-05:00',
               '2000-06-09 00:00:00-05:00', '2000-06-12 00:00:00-05:00',
               '2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... ixedOffset(-300)]', freq='B')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... ixedOffset(-300)]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... ixedOffset(-300)]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... ixedOffset(-300)]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... ixedOffset(-300)]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeTZDtype`

## Buggy case 71
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`

end, value: `Timestamp('2000-06-05 00:00:00-0500', tz='pytz.FixedOffset(-300)', freq='B')`, type: `Timestamp`

start, value: `Timestamp('2000-06-13 00:00:00-0500', tz='pytz.FixedOffset(-300)', freq='B')`, type: `Timestamp`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

left._values, value: `<DatetimeArray>
['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
 '2000-06-05 00:00:00-05:00']
Length: 3, dtype: datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeArray`

## Buggy case 72
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`

end, value: `Timestamp('2000-06-05 00:00:00-0500', tz='pytz.FixedOffset(-300)', freq='B')`, type: `Timestamp`

start, value: `Timestamp('2000-06-13 00:00:00-0500', tz='pytz.FixedOffset(-300)', freq='B')`, type: `Timestamp`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

left._values, value: `<DatetimeArray>
['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
 '2000-06-05 00:00:00-05:00']
Length: 3, dtype: datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeArray`

## Buggy case 73
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

other, value: `array of shape (20161,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... 00]', length=20161, freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, UTC+01:00]`, type: `DatetimeTZDtype`

## Buggy case 74
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... 00]', length=20161, freq='T')>`, type: `method`

self, value: `array of shape (20161,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... 00]', length=20161, freq='T')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... 00]', length=20161, freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... 00]', length=20161, freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... 00]', length=20161, freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... 00]', length=20161, freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, UTC+01:00]`, type: `DatetimeTZDtype`

## Buggy case 75
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, UTC+01:00]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
result, value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)`, type: `DatetimeIndex`

result._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)>`, type: `method`

result._data, value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, UTC+01:00]`, type: `DatetimeArray`

## Buggy case 76
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, UTC+01:00]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
result, value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)`, type: `DatetimeIndex`

result._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)>`, type: `method`

result._data, value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, UTC+01:00]`, type: `DatetimeArray`

## Buggy case 77
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',
               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',
               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',
               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',
               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',
               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',
               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, UTC+01:00]`, type: `DatetimeTZDtype`

## Buggy case 78
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... 64[ns, UTC+01:00]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',
               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',
               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',
               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... 64[ns, UTC+01:00]', freq='B')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... 64[ns, UTC+01:00]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... 64[ns, UTC+01:00]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',
               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',
               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',
               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... 64[ns, UTC+01:00]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, UTC+01:00]`, type: `DatetimeTZDtype`

## Buggy case 79
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, UTC+01:00]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`

end, value: `Timestamp('2000-06-05 00:00:00+0100', tz='UTC+01:00', freq='B')`, type: `Timestamp`

start, value: `Timestamp('2000-06-13 00:00:00+0100', tz='UTC+01:00', freq='B')`, type: `Timestamp`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

left._values, value: `<DatetimeArray>
['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
 '2000-06-05 00:00:00+01:00']
Length: 3, dtype: datetime64[ns, UTC+01:00]`, type: `DatetimeArray`

## Buggy case 80
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, UTC+01:00]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`

end, value: `Timestamp('2000-06-05 00:00:00+0100', tz='UTC+01:00', freq='B')`, type: `Timestamp`

start, value: `Timestamp('2000-06-13 00:00:00+0100', tz='UTC+01:00', freq='B')`, type: `Timestamp`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

left._values, value: `<DatetimeArray>
['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
 '2000-06-05 00:00:00+01:00']
Length: 3, dtype: datetime64[ns, UTC+01:00]`, type: `DatetimeArray`

## Buggy case 81
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

other, value: `array of shape (20161,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... oo]', length=20161, freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, foo]`, type: `DatetimeTZDtype`

## Buggy case 82
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... oo]', length=20161, freq='T')>`, type: `method`

self, value: `array of shape (20161,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... oo]', length=20161, freq='T')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... oo]', length=20161, freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... oo]', length=20161, freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... oo]', length=20161, freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... oo]', length=20161, freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, foo]`, type: `DatetimeTZDtype`

## Buggy case 83
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',
               '2000-06-01 00:02:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',
               '2000-06-01 00:02:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',
               '2000-06-01 00:02:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',
               '2000-06-01 00:02:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',
               '2000-06-01 00:02:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',
               '2000-06-01 00:02:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',
               '2000-06-01 00:02:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, foo]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
result, value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)`, type: `DatetimeIndex`

result._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)>`, type: `method`

result._data, value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, foo]`, type: `DatetimeArray`

## Buggy case 84
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',
               '2000-06-01 00:02:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',
               '2000-06-01 00:02:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

self.dtype, value: `datetime64[ns, foo]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
result, value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)`, type: `DatetimeIndex`

result._set_freq, value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)>`, type: `method`

result._data, value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, foo]`, type: `DatetimeArray`

## Buggy case 85
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',
               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',
               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',
               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',
               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',
               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',
               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, foo]`, type: `DatetimeTZDtype`

## Buggy case 86
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... tetime64[ns, foo]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',
               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',
               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',
               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... tetime64[ns, foo]', freq='B')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... tetime64[ns, foo]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... tetime64[ns, foo]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',
               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',
               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',
               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... tetime64[ns, foo]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, foo]`, type: `DatetimeTZDtype`

## Buggy case 87
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, foo]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`

end, value: `Timestamp('2000-06-05 00:00:00-0100', tz='foo', freq='B')`, type: `Timestamp`

start, value: `Timestamp('2000-06-13 00:00:00-0100', tz='foo', freq='B')`, type: `Timestamp`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

left._values, value: `<DatetimeArray>
['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
 '2000-06-05 00:00:00-01:00']
Length: 3, dtype: datetime64[ns, foo]`, type: `DatetimeArray`

## Buggy case 88
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

self.dtype, value: `datetime64[ns, foo]`, type: `DatetimeTZDtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`

end, value: `Timestamp('2000-06-05 00:00:00-0100', tz='foo', freq='B')`, type: `Timestamp`

start, value: `Timestamp('2000-06-13 00:00:00-0100', tz='foo', freq='B')`, type: `Timestamp`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

left._values, value: `<DatetimeArray>
['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
 '2000-06-05 00:00:00-01:00']
Length: 3, dtype: datetime64[ns, foo]`, type: `DatetimeArray`

## Buggy case 89
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... e='datetime64[ns]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',
               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',
               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',
               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',
               '2011-12-28', '2011-12-29', '2011-12-30'],
              dtype='datetime64[ns]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... e='datetime64[ns]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20'],
              dtype='datetime64[ns]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... e='datetime64[ns]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... e='datetime64[ns]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',
               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',
               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',
               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',
               '2011-12-28', '2011-12-29', '2011-12-30'],
              dtype='datetime64[ns]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20'],
              dtype='datetime64[ns]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... e='datetime64[ns]', freq='B')>`, type: `method`

self.dtype, value: `dtype('<M8[ns]')`, type: `dtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',
               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',
               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',
               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',
               '2011-12-28', '2011-12-29', '2011-12-30'],
              dtype='datetime64[ns]', freq='B')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20'],
              dtype='datetime64[ns]', freq='B')`, type: `DatetimeIndex`

end, value: `Timestamp('2011-12-20 00:00:00', freq='B')`, type: `Timestamp`

start, value: `Timestamp('2011-12-12 00:00:00', freq='B')`, type: `Timestamp`

lslice, value: `slice(8, 15, None)`, type: `slice`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',
               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',
               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',
               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',
               '2011-12-28', '2011-12-29', '2011-12-30'],
              dtype='datetime64[ns]', freq='B')>`, type: `method`

left_chunk, value: `<DatetimeArray>
['2011-12-12 00:00:00', '2011-12-13 00:00:00', '2011-12-14 00:00:00',
 '2011-12-15 00:00:00', '2011-12-16 00:00:00', '2011-12-19 00:00:00',
 '2011-12-20 00:00:00']
Length: 7, dtype: datetime64[ns]`, type: `DatetimeArray`

left._values, value: `array of shape (23,)`, type: `DatetimeArray`

## Buggy case 90
### input parameter runtime value and type for buggy function
self._validate_sort_keyword, value: `<bound method Index._validate_ ... e='datetime64[ns]', freq='C')>`, type: `method`

self, value: `DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',
               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',
               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',
               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',
               '2011-12-28', '2011-12-29', '2011-12-30'],
              dtype='datetime64[ns]', freq='C')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... e='datetime64[ns]', freq='C')>`, type: `method`

other, value: `DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20'],
              dtype='datetime64[ns]', freq='C')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... e='datetime64[ns]', freq='C')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... e='datetime64[ns]', freq='C')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',
               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',
               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',
               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',
               '2011-12-28', '2011-12-29', '2011-12-30'],
              dtype='datetime64[ns]', freq='C')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20'],
              dtype='datetime64[ns]', freq='C')>`, type: `method`

other.freq, value: `<CustomBusinessDay>`, type: `CustomBusinessDay`

self.freq, value: `<CustomBusinessDay>`, type: `CustomBusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... e='datetime64[ns]', freq='C')>`, type: `method`

self.dtype, value: `dtype('<M8[ns]')`, type: `dtype`

### variable runtime value and type before buggy function return
left, value: `DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',
               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',
               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',
               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',
               '2011-12-28', '2011-12-29', '2011-12-30'],
              dtype='datetime64[ns]', freq='C')`, type: `DatetimeIndex`

right, value: `DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20'],
              dtype='datetime64[ns]', freq='C')`, type: `DatetimeIndex`

end, value: `Timestamp('2011-12-20 00:00:00', freq='C')`, type: `Timestamp`

start, value: `Timestamp('2011-12-12 00:00:00', freq='C')`, type: `Timestamp`

lslice, value: `slice(8, 15, None)`, type: `slice`

left.slice_locs, value: `<bound method Index.slice_locs of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',
               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',
               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',
               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',
               '2011-12-28', '2011-12-29', '2011-12-30'],
              dtype='datetime64[ns]', freq='C')>`, type: `method`

left_chunk, value: `<DatetimeArray>
['2011-12-12 00:00:00', '2011-12-13 00:00:00', '2011-12-14 00:00:00',
 '2011-12-15 00:00:00', '2011-12-16 00:00:00', '2011-12-19 00:00:00',
 '2011-12-20 00:00:00']
Length: 7, dtype: datetime64[ns]`, type: `DatetimeArray`

left._values, value: `array of shape (23,)`, type: `DatetimeArray`



# Expected variable value and type in tests
## Expected case 1
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

other, value: `array of shape (20161,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... TC]', length=20161, freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

## Expected case 2
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... TC]', length=20161, freq='T')>`, type: `method`

self, value: `array of shape (20161,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... TC]', length=20161, freq='T')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... TC]', length=20161, freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... TC]', length=20161, freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... TC]', length=20161, freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... TC]', length=20161, freq='T')>`, type: `method`

## Expected case 3
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

### Expected variable value and type before function return
result, expected value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)`, type: `DatetimeIndex`

result._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)>`, type: `method`

result._data, expected value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, UTC]`, type: `DatetimeArray`

## Expected case 4
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='T')>`, type: `method`

### Expected variable value and type before function return
result, expected value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)`, type: `DatetimeIndex`

result._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)>`, type: `method`

result._data, expected value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, UTC]`, type: `DatetimeArray`

## Expected case 5
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',
               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',
               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',
               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',
               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',
               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',
               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

## Expected case 6
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... tetime64[ns, UTC]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',
               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',
               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',
               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... tetime64[ns, UTC]', freq='B')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... tetime64[ns, UTC]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... tetime64[ns, UTC]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',
               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',
               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',
               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... tetime64[ns, UTC]', freq='B')>`, type: `method`

## Expected case 7
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

### Expected variable value and type before function return
left, expected value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`

right, expected value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')`, type: `DatetimeIndex`

end, expected value: `Timestamp('2000-06-05 00:00:00+0000', tz='UTC', freq='B')`, type: `Timestamp`

start, expected value: `Timestamp('2000-06-13 00:00:00+0000', tz='UTC', freq='B')`, type: `Timestamp`

left.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='B')>`, type: `method`

left.values, expected value: `array(['2000-06-01T00:00:00.000000000', '2000-06-02T00:00:00.000000000',
       '2000-06-05T00:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`

## Expected case 8
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

other, value: `array of shape (20161,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... rn]', length=20161, freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

## Expected case 9
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... rn]', length=20161, freq='T')>`, type: `method`

self, value: `array of shape (20161,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... rn]', length=20161, freq='T')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... rn]', length=20161, freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... rn]', length=20161, freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... rn]', length=20161, freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... rn]', length=20161, freq='T')>`, type: `method`

## Expected case 10
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',
               '2000-06-01 00:02:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',
               '2000-06-01 00:02:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',
               '2000-06-01 00:02:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',
               '2000-06-01 00:02:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',
               '2000-06-01 00:02:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',
               '2000-06-01 00:02:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',
               '2000-06-01 00:02:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

### Expected variable value and type before function return
result, expected value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)`, type: `DatetimeIndex`

result._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)>`, type: `method`

result._data, expected value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, US/Eastern]`, type: `DatetimeArray`

## Expected case 11
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',
               '2000-06-01 00:02:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',
               '2000-06-01 00:02:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='T')>`, type: `method`

### Expected variable value and type before function return
result, expected value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)`, type: `DatetimeIndex`

result._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)>`, type: `method`

result._data, expected value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, US/Eastern]`, type: `DatetimeArray`

## Expected case 12
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',
               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',
               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',
               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',
               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',
               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',
               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

## Expected case 13
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... 4[ns, US/Eastern]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',
               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',
               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',
               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... 4[ns, US/Eastern]', freq='B')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... 4[ns, US/Eastern]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... 4[ns, US/Eastern]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',
               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',
               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',
               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... 4[ns, US/Eastern]', freq='B')>`, type: `method`

## Expected case 14
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

### Expected variable value and type before function return
left, expected value: `DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`

right, expected value: `DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',
               '2000-06-15 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')`, type: `DatetimeIndex`

end, expected value: `Timestamp('2000-06-05 00:00:00-0400', tz='US/Eastern', freq='B')`, type: `Timestamp`

start, expected value: `Timestamp('2000-06-13 00:00:00-0400', tz='US/Eastern', freq='B')`, type: `Timestamp`

left.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',
               '2000-06-05 00:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='B')>`, type: `method`

left.values, expected value: `array(['2000-06-01T04:00:00.000000000', '2000-06-02T04:00:00.000000000',
       '2000-06-05T04:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`

## Expected case 15
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

other, value: `array of shape (20161,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... yo]', length=20161, freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

## Expected case 16
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... yo]', length=20161, freq='T')>`, type: `method`

self, value: `array of shape (20161,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... yo]', length=20161, freq='T')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... yo]', length=20161, freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... yo]', length=20161, freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... yo]', length=20161, freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... yo]', length=20161, freq='T')>`, type: `method`

## Expected case 17
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',
               '2000-06-01 00:02:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',
               '2000-06-01 00:02:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',
               '2000-06-01 00:02:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',
               '2000-06-01 00:02:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',
               '2000-06-01 00:02:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',
               '2000-06-01 00:02:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',
               '2000-06-01 00:02:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

### Expected variable value and type before function return
result, expected value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)`, type: `DatetimeIndex`

result._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)>`, type: `method`

result._data, expected value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, Asia/Tokyo]`, type: `DatetimeArray`

## Expected case 18
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',
               '2000-06-01 00:02:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',
               '2000-06-01 00:02:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>`, type: `method`

### Expected variable value and type before function return
result, expected value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)`, type: `DatetimeIndex`

result._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)>`, type: `method`

result._data, expected value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, Asia/Tokyo]`, type: `DatetimeArray`

## Expected case 19
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',
               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',
               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',
               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',
               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',
               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',
               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

## Expected case 20
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... 4[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',
               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',
               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',
               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... 4[ns, Asia/Tokyo]', freq='B')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... 4[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... 4[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',
               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',
               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',
               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... 4[ns, Asia/Tokyo]', freq='B')>`, type: `method`

## Expected case 21
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

### Expected variable value and type before function return
left, expected value: `DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`

right, expected value: `DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',
               '2000-06-15 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')`, type: `DatetimeIndex`

end, expected value: `Timestamp('2000-06-05 00:00:00+0900', tz='Asia/Tokyo', freq='B')`, type: `Timestamp`

start, expected value: `Timestamp('2000-06-13 00:00:00+0900', tz='Asia/Tokyo', freq='B')`, type: `Timestamp`

left.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',
               '2000-06-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>`, type: `method`

left.values, expected value: `array(['2000-05-31T15:00:00.000000000', '2000-06-01T15:00:00.000000000',
       '2000-06-04T15:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`

## Expected case 22
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

other, value: `array of shape (20161,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... ')]', length=20161, freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

## Expected case 23
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... ')]', length=20161, freq='T')>`, type: `method`

self, value: `array of shape (20161,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... ')]', length=20161, freq='T')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... ')]', length=20161, freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... ')]', length=20161, freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... ')]', length=20161, freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... ')]', length=20161, freq='T')>`, type: `method`

## Expected case 24
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',
               '2000-06-01 00:02:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',
               '2000-06-01 00:02:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',
               '2000-06-01 00:02:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',
               '2000-06-01 00:02:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',
               '2000-06-01 00:02:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',
               '2000-06-01 00:02:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',
               '2000-06-01 00:02:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

### Expected variable value and type before function return
result, expected value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)`, type: `DatetimeIndex`

result._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)>`, type: `method`

result._data, expected value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeArray`

## Expected case 25
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',
               '2000-06-01 00:02:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',
               '2000-06-01 00:02:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>`, type: `method`

### Expected variable value and type before function return
result, expected value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)`, type: `DatetimeIndex`

result._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)>`, type: `method`

result._data, expected value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]`, type: `DatetimeArray`

## Expected case 26
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00', '2000-06-06 00:00:00-07:00',
               '2000-06-07 00:00:00-07:00', '2000-06-08 00:00:00-07:00',
               '2000-06-09 00:00:00-07:00', '2000-06-12 00:00:00-07:00',
               '2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... nfo/US/Pacific')]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

## Expected case 27
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... nfo/US/Pacific')]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00', '2000-06-06 00:00:00-07:00',
               '2000-06-07 00:00:00-07:00', '2000-06-08 00:00:00-07:00',
               '2000-06-09 00:00:00-07:00', '2000-06-12 00:00:00-07:00',
               '2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... nfo/US/Pacific')]', freq='B')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... nfo/US/Pacific')]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... nfo/US/Pacific')]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... nfo/US/Pacific')]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... nfo/US/Pacific')]', freq='B')>`, type: `method`

## Expected case 28
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

### Expected variable value and type before function return
left, expected value: `DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`

right, expected value: `DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',
               '2000-06-15 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')`, type: `DatetimeIndex`

end, expected value: `Timestamp('2000-06-05 00:00:00-0700', tz='dateutil//usr/share/zoneinfo/US/Pacific', freq='B')`, type: `Timestamp`

start, expected value: `Timestamp('2000-06-13 00:00:00-0700', tz='dateutil//usr/share/zoneinfo/US/Pacific', freq='B')`, type: `Timestamp`

left.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',
               '2000-06-05 00:00:00-07:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>`, type: `method`

left.values, expected value: `array(['2000-06-01T07:00:00.000000000', '2000-06-02T07:00:00.000000000',
       '2000-06-05T07:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`

## Expected case 29
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

other, value: `array of shape (20161,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... ')]', length=20161, freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

## Expected case 30
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... ')]', length=20161, freq='T')>`, type: `method`

self, value: `array of shape (20161,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... ')]', length=20161, freq='T')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... ')]', length=20161, freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... ')]', length=20161, freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... ')]', length=20161, freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... ')]', length=20161, freq='T')>`, type: `method`

## Expected case 31
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',
               '2000-06-01 00:02:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',
               '2000-06-01 00:02:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',
               '2000-06-01 00:02:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',
               '2000-06-01 00:02:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',
               '2000-06-01 00:02:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',
               '2000-06-01 00:02:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',
               '2000-06-01 00:02:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

### Expected variable value and type before function return
result, expected value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)`, type: `DatetimeIndex`

result._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)>`, type: `method`

result._data, expected value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeArray`

## Expected case 32
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',
               '2000-06-01 00:02:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',
               '2000-06-01 00:02:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>`, type: `method`

### Expected variable value and type before function return
result, expected value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)`, type: `DatetimeIndex`

result._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)>`, type: `method`

result._data, expected value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]`, type: `DatetimeArray`

## Expected case 33
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

other, value: `array of shape (11,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... Asia/Singapore')]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

## Expected case 34
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... Asia/Singapore')]', freq='B')>`, type: `method`

self, value: `array of shape (11,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... Asia/Singapore')]', freq='B')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... Asia/Singapore')]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... Asia/Singapore')]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... Asia/Singapore')]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... Asia/Singapore')]', freq='B')>`, type: `method`

## Expected case 35
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
               '2000-06-05 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
               '2000-06-05 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
               '2000-06-05 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
               '2000-06-05 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
               '2000-06-05 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
               '2000-06-05 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
               '2000-06-05 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

### Expected variable value and type before function return
left, expected value: `DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
               '2000-06-05 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`

right, expected value: `DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',
               '2000-06-15 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')`, type: `DatetimeIndex`

end, expected value: `Timestamp('2000-06-05 00:00:00+0800', tz='dateutil//usr/share/zoneinfo/Asia/Singapore', freq='B')`, type: `Timestamp`

start, expected value: `Timestamp('2000-06-13 00:00:00+0800', tz='dateutil//usr/share/zoneinfo/Asia/Singapore', freq='B')`, type: `Timestamp`

left.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',
               '2000-06-05 00:00:00+08:00'],
              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>`, type: `method`

left.values, expected value: `array(['2000-05-31T16:00:00.000000000', '2000-06-01T16:00:00.000000000',
       '2000-06-04T16:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`

## Expected case 36
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

other, value: `array of shape (20161,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... ()]', length=20161, freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

## Expected case 37
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... ()]', length=20161, freq='T')>`, type: `method`

self, value: `array of shape (20161,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... ()]', length=20161, freq='T')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... ()]', length=20161, freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... ()]', length=20161, freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... ()]', length=20161, freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... ()]', length=20161, freq='T')>`, type: `method`

## Expected case 38
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

### Expected variable value and type before function return
result, expected value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)`, type: `DatetimeIndex`

result._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)>`, type: `method`

result._data, expected value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, tzutc()]`, type: `DatetimeArray`

## Expected case 39
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',
               '2000-06-01 00:02:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='T')>`, type: `method`

### Expected variable value and type before function return
result, expected value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)`, type: `DatetimeIndex`

result._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)>`, type: `method`

result._data, expected value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, tzutc()]`, type: `DatetimeArray`

## Expected case 40
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',
               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',
               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',
               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',
               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',
               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',
               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

## Expected case 41
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... me64[ns, tzutc()]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',
               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',
               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',
               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... me64[ns, tzutc()]', freq='B')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... me64[ns, tzutc()]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... me64[ns, tzutc()]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',
               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',
               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',
               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... me64[ns, tzutc()]', freq='B')>`, type: `method`

## Expected case 42
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

### Expected variable value and type before function return
left, expected value: `DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`

right, expected value: `DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',
               '2000-06-15 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')`, type: `DatetimeIndex`

end, expected value: `Timestamp('2000-06-05 00:00:00+0000', tz='tzutc()', freq='B')`, type: `Timestamp`

start, expected value: `Timestamp('2000-06-13 00:00:00+0000', tz='tzutc()', freq='B')`, type: `Timestamp`

left.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',
               '2000-06-05 00:00:00+00:00'],
              dtype='datetime64[ns, tzutc()]', freq='B')>`, type: `method`

left.values, expected value: `array(['2000-06-01T00:00:00.000000000', '2000-06-02T00:00:00.000000000',
       '2000-06-05T00:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`

## Expected case 43
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

other, value: `array of shape (20161,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... ()]', length=20161, freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

## Expected case 44
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... ()]', length=20161, freq='T')>`, type: `method`

self, value: `array of shape (20161,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... ()]', length=20161, freq='T')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... ()]', length=20161, freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... ()]', length=20161, freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... ()]', length=20161, freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... ()]', length=20161, freq='T')>`, type: `method`

## Expected case 45
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

### Expected variable value and type before function return
result, expected value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)`, type: `DatetimeIndex`

result._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)>`, type: `method`

result._data, expected value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, tzlocal()]`, type: `DatetimeArray`

## Expected case 46
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='T')>`, type: `method`

### Expected variable value and type before function return
result, expected value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)`, type: `DatetimeIndex`

result._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)>`, type: `method`

result._data, expected value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, tzlocal()]`, type: `DatetimeArray`

## Expected case 47
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',
               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',
               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',
               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',
               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',
               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',
               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

## Expected case 48
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... 64[ns, tzlocal()]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',
               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',
               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',
               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... 64[ns, tzlocal()]', freq='B')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... 64[ns, tzlocal()]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... 64[ns, tzlocal()]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',
               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',
               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',
               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... 64[ns, tzlocal()]', freq='B')>`, type: `method`

## Expected case 49
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

### Expected variable value and type before function return
left, expected value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`

right, expected value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')`, type: `DatetimeIndex`

end, expected value: `Timestamp('2000-06-05 00:00:00+0100', tz='tzlocal()', freq='B')`, type: `Timestamp`

start, expected value: `Timestamp('2000-06-13 00:00:00+0100', tz='tzlocal()', freq='B')`, type: `Timestamp`

left.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, tzlocal()]', freq='B')>`, type: `method`

left.values, expected value: `array(['2000-05-31T23:00:00.000000000', '2000-06-01T23:00:00.000000000',
       '2000-06-04T23:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`

## Expected case 50
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

other, value: `array of shape (20161,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

## Expected case 51
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... 0)]', length=20161, freq='T')>`, type: `method`

self, value: `array of shape (20161,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... 0)]', length=20161, freq='T')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... 0)]', length=20161, freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... 0)]', length=20161, freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... 0)]', length=20161, freq='T')>`, type: `method`

## Expected case 52
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',
               '2000-06-01 00:02:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',
               '2000-06-01 00:02:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',
               '2000-06-01 00:02:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',
               '2000-06-01 00:02:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',
               '2000-06-01 00:02:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',
               '2000-06-01 00:02:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',
               '2000-06-01 00:02:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

### Expected variable value and type before function return
result, expected value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)`, type: `DatetimeIndex`

result._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)>`, type: `method`

result._data, expected value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeArray`

## Expected case 53
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',
               '2000-06-01 00:02:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',
               '2000-06-01 00:02:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>`, type: `method`

### Expected variable value and type before function return
result, expected value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)`, type: `DatetimeIndex`

result._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)>`, type: `method`

result._data, expected value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, pytz.FixedOffset(300)]`, type: `DatetimeArray`

## Expected case 54
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00', '2000-06-06 00:00:00+05:00',
               '2000-06-07 00:00:00+05:00', '2000-06-08 00:00:00+05:00',
               '2000-06-09 00:00:00+05:00', '2000-06-12 00:00:00+05:00',
               '2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... FixedOffset(300)]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

## Expected case 55
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... FixedOffset(300)]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00', '2000-06-06 00:00:00+05:00',
               '2000-06-07 00:00:00+05:00', '2000-06-08 00:00:00+05:00',
               '2000-06-09 00:00:00+05:00', '2000-06-12 00:00:00+05:00',
               '2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... FixedOffset(300)]', freq='B')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... FixedOffset(300)]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... FixedOffset(300)]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... FixedOffset(300)]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... FixedOffset(300)]', freq='B')>`, type: `method`

## Expected case 56
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

### Expected variable value and type before function return
left, expected value: `DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`

right, expected value: `DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',
               '2000-06-15 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')`, type: `DatetimeIndex`

end, expected value: `Timestamp('2000-06-05 00:00:00+0500', tz='pytz.FixedOffset(300)', freq='B')`, type: `Timestamp`

start, expected value: `Timestamp('2000-06-13 00:00:00+0500', tz='pytz.FixedOffset(300)', freq='B')`, type: `Timestamp`

left.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',
               '2000-06-05 00:00:00+05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>`, type: `method`

left.values, expected value: `array(['2000-05-31T19:00:00.000000000', '2000-06-01T19:00:00.000000000',
       '2000-06-04T19:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`

## Expected case 57
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

other, value: `array of shape (20161,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

## Expected case 58
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... 0)]', length=20161, freq='T')>`, type: `method`

self, value: `array of shape (20161,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... 0)]', length=20161, freq='T')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... 0)]', length=20161, freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... 0)]', length=20161, freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... 0)]', length=20161, freq='T')>`, type: `method`

## Expected case 59
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',
               '2000-06-01 00:02:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',
               '2000-06-01 00:02:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',
               '2000-06-01 00:02:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',
               '2000-06-01 00:02:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',
               '2000-06-01 00:02:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',
               '2000-06-01 00:02:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',
               '2000-06-01 00:02:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

### Expected variable value and type before function return
result, expected value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)`, type: `DatetimeIndex`

result._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)>`, type: `method`

result._data, expected value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeArray`

## Expected case 60
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',
               '2000-06-01 00:02:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',
               '2000-06-01 00:02:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>`, type: `method`

### Expected variable value and type before function return
result, expected value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)`, type: `DatetimeIndex`

result._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)>`, type: `method`

result._data, expected value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, pytz.FixedOffset(-300)]`, type: `DatetimeArray`

## Expected case 61
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00', '2000-06-06 00:00:00-05:00',
               '2000-06-07 00:00:00-05:00', '2000-06-08 00:00:00-05:00',
               '2000-06-09 00:00:00-05:00', '2000-06-12 00:00:00-05:00',
               '2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... ixedOffset(-300)]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

## Expected case 62
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... ixedOffset(-300)]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00', '2000-06-06 00:00:00-05:00',
               '2000-06-07 00:00:00-05:00', '2000-06-08 00:00:00-05:00',
               '2000-06-09 00:00:00-05:00', '2000-06-12 00:00:00-05:00',
               '2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... ixedOffset(-300)]', freq='B')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... ixedOffset(-300)]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... ixedOffset(-300)]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... ixedOffset(-300)]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... ixedOffset(-300)]', freq='B')>`, type: `method`

## Expected case 63
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

### Expected variable value and type before function return
left, expected value: `DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`

right, expected value: `DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',
               '2000-06-15 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')`, type: `DatetimeIndex`

end, expected value: `Timestamp('2000-06-05 00:00:00-0500', tz='pytz.FixedOffset(-300)', freq='B')`, type: `Timestamp`

start, expected value: `Timestamp('2000-06-13 00:00:00-0500', tz='pytz.FixedOffset(-300)', freq='B')`, type: `Timestamp`

left.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',
               '2000-06-05 00:00:00-05:00'],
              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>`, type: `method`

left.values, expected value: `array(['2000-06-01T05:00:00.000000000', '2000-06-02T05:00:00.000000000',
       '2000-06-05T05:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`

## Expected case 64
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

other, value: `array of shape (20161,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... 00]', length=20161, freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

## Expected case 65
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... 00]', length=20161, freq='T')>`, type: `method`

self, value: `array of shape (20161,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... 00]', length=20161, freq='T')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... 00]', length=20161, freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... 00]', length=20161, freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... 00]', length=20161, freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... 00]', length=20161, freq='T')>`, type: `method`

## Expected case 66
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

### Expected variable value and type before function return
result, expected value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)`, type: `DatetimeIndex`

result._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)>`, type: `method`

result._data, expected value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, UTC+01:00]`, type: `DatetimeArray`

## Expected case 67
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',
               '2000-06-01 00:02:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='T')>`, type: `method`

### Expected variable value and type before function return
result, expected value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)`, type: `DatetimeIndex`

result._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)>`, type: `method`

result._data, expected value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, UTC+01:00]`, type: `DatetimeArray`

## Expected case 68
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',
               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',
               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',
               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',
               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',
               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',
               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

## Expected case 69
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... 64[ns, UTC+01:00]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',
               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',
               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',
               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... 64[ns, UTC+01:00]', freq='B')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... 64[ns, UTC+01:00]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... 64[ns, UTC+01:00]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',
               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',
               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',
               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... 64[ns, UTC+01:00]', freq='B')>`, type: `method`

## Expected case 70
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

### Expected variable value and type before function return
left, expected value: `DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`

right, expected value: `DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',
               '2000-06-15 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')`, type: `DatetimeIndex`

end, expected value: `Timestamp('2000-06-05 00:00:00+0100', tz='UTC+01:00', freq='B')`, type: `Timestamp`

start, expected value: `Timestamp('2000-06-13 00:00:00+0100', tz='UTC+01:00', freq='B')`, type: `Timestamp`

left.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',
               '2000-06-05 00:00:00+01:00'],
              dtype='datetime64[ns, UTC+01:00]', freq='B')>`, type: `method`

left.values, expected value: `array(['2000-05-31T23:00:00.000000000', '2000-06-01T23:00:00.000000000',
       '2000-06-04T23:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`

## Expected case 71
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

other, value: `array of shape (20161,)`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of Da ... oo]', length=20161, freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

## Expected case 72
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... oo]', length=20161, freq='T')>`, type: `method`

self, value: `array of shape (20161,)`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... oo]', length=20161, freq='T')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... oo]', length=20161, freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... oo]', length=20161, freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of Da ... oo]', length=20161, freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... oo]', length=20161, freq='T')>`, type: `method`

## Expected case 73
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',
               '2000-06-01 00:02:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',
               '2000-06-01 00:02:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',
               '2000-06-01 00:02:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',
               '2000-06-01 00:02:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',
               '2000-06-01 00:02:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',
               '2000-06-01 00:02:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',
               '2000-06-01 00:02:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

### Expected variable value and type before function return
result, expected value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)`, type: `DatetimeIndex`

result._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)>`, type: `method`

result._data, expected value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, foo]`, type: `DatetimeArray`

## Expected case 74
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',
               '2000-06-01 00:02:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',
               '2000-06-01 00:02:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

other.freq, value: `<Minute>`, type: `Minute`

self.freq, value: `<Minute>`, type: `Minute`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='T')>`, type: `method`

### Expected variable value and type before function return
result, expected value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)`, type: `DatetimeIndex`

result._set_freq, expected value: `<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)>`, type: `method`

result._data, expected value: `<DatetimeArray>
[]
Length: 0, dtype: datetime64[ns, foo]`, type: `DatetimeArray`

## Expected case 75
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

self, value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',
               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',
               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',
               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',
               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',
               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',
               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

## Expected case 76
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... tetime64[ns, foo]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',
               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',
               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',
               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... tetime64[ns, foo]', freq='B')>`, type: `method`

other, value: `DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... tetime64[ns, foo]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... tetime64[ns, foo]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',
               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',
               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',
               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... tetime64[ns, foo]', freq='B')>`, type: `method`

## Expected case 77
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

### Expected variable value and type before function return
left, expected value: `DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`

right, expected value: `DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',
               '2000-06-15 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')`, type: `DatetimeIndex`

end, expected value: `Timestamp('2000-06-05 00:00:00-0100', tz='foo', freq='B')`, type: `Timestamp`

start, expected value: `Timestamp('2000-06-13 00:00:00-0100', tz='foo', freq='B')`, type: `Timestamp`

left.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',
               '2000-06-05 00:00:00-01:00'],
              dtype='datetime64[ns, foo]', freq='B')>`, type: `method`

left.values, expected value: `array(['2000-06-01T01:00:00.000000000', '2000-06-02T01:00:00.000000000',
       '2000-06-05T01:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`

## Expected case 78
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... e='datetime64[ns]', freq='B')>`, type: `method`

self, value: `DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',
               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',
               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',
               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',
               '2011-12-28', '2011-12-29', '2011-12-30'],
              dtype='datetime64[ns]', freq='B')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... e='datetime64[ns]', freq='B')>`, type: `method`

other, value: `DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20'],
              dtype='datetime64[ns]', freq='B')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... e='datetime64[ns]', freq='B')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... e='datetime64[ns]', freq='B')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',
               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',
               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',
               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',
               '2011-12-28', '2011-12-29', '2011-12-30'],
              dtype='datetime64[ns]', freq='B')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20'],
              dtype='datetime64[ns]', freq='B')>`, type: `method`

other.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.freq, value: `<BusinessDay>`, type: `BusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... e='datetime64[ns]', freq='B')>`, type: `method`

### Expected variable value and type before function return
left, expected value: `DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',
               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',
               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',
               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',
               '2011-12-28', '2011-12-29', '2011-12-30'],
              dtype='datetime64[ns]', freq='B')`, type: `DatetimeIndex`

right, expected value: `DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20'],
              dtype='datetime64[ns]', freq='B')`, type: `DatetimeIndex`

end, expected value: `Timestamp('2011-12-20 00:00:00', freq='B')`, type: `Timestamp`

start, expected value: `Timestamp('2011-12-12 00:00:00', freq='B')`, type: `Timestamp`

lslice, expected value: `slice(8, 15, None)`, type: `slice`

left.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',
               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',
               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',
               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',
               '2011-12-28', '2011-12-29', '2011-12-30'],
              dtype='datetime64[ns]', freq='B')>`, type: `method`

left_chunk, expected value: `array(['2011-12-12T00:00:00.000000000', '2011-12-13T00:00:00.000000000',
       '2011-12-14T00:00:00.000000000', '2011-12-15T00:00:00.000000000',
       '2011-12-16T00:00:00.000000000', '2011-12-19T00:00:00.000000000',
       '2011-12-20T00:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`

left.values, expected value: `array of shape (23,)`, type: `ndarray`

## Expected case 79
### Input parameter value and type
self._validate_sort_keyword, value: `<bound method Index._validate_ ... e='datetime64[ns]', freq='C')>`, type: `method`

self, value: `DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',
               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',
               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',
               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',
               '2011-12-28', '2011-12-29', '2011-12-30'],
              dtype='datetime64[ns]', freq='C')`, type: `DatetimeIndex`

sort, value: `False`, type: `bool`

self._assert_can_do_setop, value: `<bound method Index._assert_ca ... e='datetime64[ns]', freq='C')>`, type: `method`

other, value: `DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20'],
              dtype='datetime64[ns]', freq='C')`, type: `DatetimeIndex`

self.equals, value: `<bound method DatetimeIndexOps ... e='datetime64[ns]', freq='C')>`, type: `method`

self._get_reconciled_name_object, value: `<bound method Index._get_recon ... e='datetime64[ns]', freq='C')>`, type: `method`

self.copy, value: `<bound method Index.copy of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',
               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',
               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',
               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',
               '2011-12-28', '2011-12-29', '2011-12-30'],
              dtype='datetime64[ns]', freq='C')>`, type: `method`

other.copy, value: `<bound method Index.copy of DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20'],
              dtype='datetime64[ns]', freq='C')>`, type: `method`

other.freq, value: `<CustomBusinessDay>`, type: `CustomBusinessDay`

self.freq, value: `<CustomBusinessDay>`, type: `CustomBusinessDay`

self.is_monotonic, value: `True`, type: `bool`

other.is_monotonic, value: `True`, type: `bool`

self._shallow_copy, value: `<bound method DatetimeTimedelt ... e='datetime64[ns]', freq='C')>`, type: `method`

### Expected variable value and type before function return
left, expected value: `DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',
               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',
               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',
               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',
               '2011-12-28', '2011-12-29', '2011-12-30'],
              dtype='datetime64[ns]', freq='C')`, type: `DatetimeIndex`

right, expected value: `DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20'],
              dtype='datetime64[ns]', freq='C')`, type: `DatetimeIndex`

end, expected value: `Timestamp('2011-12-20 00:00:00', freq='C')`, type: `Timestamp`

start, expected value: `Timestamp('2011-12-12 00:00:00', freq='C')`, type: `Timestamp`

lslice, expected value: `slice(8, 15, None)`, type: `slice`

left.slice_locs, expected value: `<bound method Index.slice_locs of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',
               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',
               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',
               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',
               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',
               '2011-12-28', '2011-12-29', '2011-12-30'],
              dtype='datetime64[ns]', freq='C')>`, type: `method`

left_chunk, expected value: `array(['2011-12-12T00:00:00.000000000', '2011-12-13T00:00:00.000000000',
       '2011-12-14T00:00:00.000000000', '2011-12-15T00:00:00.000000000',
       '2011-12-16T00:00:00.000000000', '2011-12-19T00:00:00.000000000',
       '2011-12-20T00:00:00.000000000'], dtype='datetime64[ns]')`, type: `ndarray`

left.values, expected value: `array of shape (23,)`, type: `ndarray`




















