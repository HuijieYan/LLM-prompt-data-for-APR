{
    "1.1.1": "def intersection(self, other, sort=False):\n    \n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n\n    if self.equals(other):\n        return self._get_reconciled_name_object(other)\n\n    if len(self) == 0:\n        return self.copy()\n    if len(other) == 0:\n        return other.copy()\n\n    if not isinstance(other, type(self)):\n        result = Index.intersection(self, other, sort=sort)\n        if isinstance(result, type(self)):\n            if result.freq is None:\n                result._set_freq(\"infer\")\n        return result\n\n    elif (\n        other.freq is None\n        or self.freq is None\n        or other.freq != self.freq\n        or not other.freq.is_anchored()\n        or (not self.is_monotonic or not other.is_monotonic)\n    ):\n        result = Index.intersection(self, other, sort=sort)\n\n        # Invalidate the freq of `result`, which may not be correct at\n        # this point, depending on the values.\n\n        result._set_freq(None)\n        result = self._shallow_copy(result._data, name=result.name)\n        if result.freq is None:\n            result._set_freq(\"infer\")\n        return result\n\n    # to make our life easier, \"sort\" the two ranges\n    if self[0] <= other[0]:\n        left, right = self, other\n    else:\n        left, right = other, self\n\n    # after sorting, the intersection always starts with the right index\n    # and ends with the index of which the last elements is smallest\n    end = min(left[-1], right[-1])\n    start = right[0]\n\n    if end < start:\n        return type(self)(data=[])\n    else:\n        lslice = slice(*left.slice_locs(start, end))\n        left_chunk = left.values[lslice]\n        return self._shallow_copy(left_chunk)\n",
    "1.1.2": "Specialized intersection for DatetimeIndex/TimedeltaIndex.\n\nMay be much faster than Index.intersection\n\nParameters\n----------\nother : Same type as self or array-like\nsort : False or None, default False\n    Sort the resulting index if possible.\n\n    .. versionadded:: 0.24.0\n\n    .. versionchanged:: 0.24.1\n\n       Changed the default to ``False`` to match the behaviour\n       from before 0.24.0.\n\n    .. versionchanged:: 0.25.0\n\n       The `sort` keyword is added\n\nReturns\n-------\ny : Index or same type as self",
    "1.2.1": "class DatetimeTimedeltaMixin(DatetimeIndexOpsMixin, Int64Index)",
    "1.2.2": "Mixin class for methods shared by DatetimeIndex and TimedeltaIndex,\nbut not PeriodIndex",
    "1.2.3": [
        "_set_freq(self, freq)",
        "_shallow_copy(self, values=None, name: Label=lib.no_default)",
        "intersection(self, other, sort=False)"
    ],
    "1.2.4": null,
    "1.2.5": null,
    "1.3.1": "pandas/core/indexes/datetimelike.py",
    "1.3.2": [
        "values(self)",
        "equals(self, other) -> bool",
        "_set_freq(self, freq)",
        "_shallow_copy(self, values=None, name: Label=lib.no_default)",
        "intersection(self, other, sort=False)"
    ],
    "1.4.1": [
        "    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq",
        "    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq",
        "    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq",
        "    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq",
        "    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq",
        "    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq",
        "    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq",
        "    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq",
        "    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq",
        "    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq",
        "    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq",
        "    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq",
        "    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n\n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq\n\n        # swapped left and right\n        result = rng[-3:].intersection(rng[:3])\n        tm.assert_index_equal(result, rng[:0])\n        if freq != \"T\":\n            # We don't preserve freq on non-anchored offsets\n            assert result.freq == rng.freq",
        "    def test_intersection_bug(self):\n        # GH #771\n        a = bdate_range(\"11/30/2011\", \"12/31/2011\")\n        b = bdate_range(\"12/10/2011\", \"12/20/2011\")\n        result = a.intersection(b)\n        tm.assert_index_equal(result, b)\n        assert result.freq == b.freq",
        "    def test_intersection_bug(self):\n        # GH #771\n        a = bdate_range(\"11/30/2011\", \"12/31/2011\")\n        b = bdate_range(\"12/10/2011\", \"12/20/2011\")\n        result = a.intersection(b)\n        tm.assert_index_equal(result, b)\n        assert result.freq == b.freq"
    ],
    "1.4.2": [
        "pandas/tests/indexes/datetimes/test_setops.py",
        "pandas/tests/indexes/datetimes/test_setops.py",
        "pandas/tests/indexes/datetimes/test_setops.py",
        "pandas/tests/indexes/datetimes/test_setops.py",
        "pandas/tests/indexes/datetimes/test_setops.py",
        "pandas/tests/indexes/datetimes/test_setops.py",
        "pandas/tests/indexes/datetimes/test_setops.py",
        "pandas/tests/indexes/datetimes/test_setops.py",
        "pandas/tests/indexes/datetimes/test_setops.py",
        "pandas/tests/indexes/datetimes/test_setops.py",
        "pandas/tests/indexes/datetimes/test_setops.py",
        "pandas/tests/indexes/datetimes/test_setops.py",
        "pandas/tests/indexes/datetimes/test_setops.py",
        "pandas/tests/indexes/datetimes/test_setops.py",
        "pandas/tests/indexes/datetimes/test_setops.py"
    ],
    "2.1.1": [
        [
            "E               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, UTC]"
        ],
        [
            "E               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, US/Eastern]"
        ],
        [
            "E               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, Asia/Tokyo]"
        ],
        [
            "E               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]"
        ],
        [
            "E               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]"
        ],
        [
            "E               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, tzutc()]"
        ],
        [
            "E               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, tzlocal()]"
        ],
        [
            "E               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, pytz.FixedOffset(300)]"
        ],
        [
            "E               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, UTC]"
        ],
        [
            "E               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, pytz.FixedOffset(-300)]"
        ],
        [
            "E               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, UTC]"
        ],
        [
            "E               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, UTC+01:00]"
        ],
        [
            "E               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, foo]"
        ],
        [
            "E       assert None == <BusinessDay>\nE         +None\nE         -<BusinessDay>"
        ],
        [
            "E       assert None == <CustomBusinessDay>\nE         +None\nE         -<CustomBusinessDay>"
        ]
    ],
    "2.1.2": [
        [
            "self = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110a7d400>\ntz_aware_fixture = 'UTC', freq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B'), obj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)",
            "\npandas/_testing.py:611: AssertionError"
        ],
        [
            "self = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110a64760>\ntz_aware_fixture = 'US/Eastern', freq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')\nobj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)",
            "\npandas/_testing.py:611: AssertionError"
        ],
        [
            "self = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110b159d0>\ntz_aware_fixture = 'Asia/Tokyo', freq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')\nobj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)",
            "\npandas/_testing.py:611: AssertionError"
        ],
        [
            "self = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110a7d0d0>\ntz_aware_fixture = 'dateutil/US/Pacific', freq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')\nobj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)",
            "\npandas/_testing.py:611: AssertionError"
        ],
        [
            "self = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110a754c0>\ntz_aware_fixture = 'dateutil/Asia/Singapore', freq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')\nobj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)",
            "\npandas/_testing.py:611: AssertionError"
        ],
        [
            "self = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110a4b190>\ntz_aware_fixture = tzutc(), freq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B'), obj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)",
            "\npandas/_testing.py:611: AssertionError"
        ],
        [
            "self = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110a970a0>\ntz_aware_fixture = tzlocal(), freq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')\nobj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)",
            "\npandas/_testing.py:611: AssertionError"
        ],
        [
            "self = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110bcbe80>\ntz_aware_fixture = pytz.FixedOffset(300), freq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')\nobj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)",
            "\npandas/_testing.py:611: AssertionError"
        ],
        [
            "self = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110c8ba30>\ntz_aware_fixture = <UTC>, freq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B'), obj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)",
            "\npandas/_testing.py:611: AssertionError"
        ],
        [
            "self = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110a64fa0>\ntz_aware_fixture = pytz.FixedOffset(-300), freq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')\nobj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)",
            "\npandas/_testing.py:611: AssertionError"
        ],
        [
            "self = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110b589a0>\ntz_aware_fixture = datetime.timezone.utc, freq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B'), obj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)",
            "\npandas/_testing.py:611: AssertionError"
        ],
        [
            "self = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110c7aa00>\ntz_aware_fixture = datetime.timezone(datetime.timedelta(seconds=3600))\nfreq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')\nobj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)",
            "\npandas/_testing.py:611: AssertionError"
        ],
        [
            "self = <pandas.tests.indexes.datetimes.test_setops.TestDatetimeIndexSetOps object at 0x110c7e9d0>\ntz_aware_fixture = datetime.timezone(datetime.timedelta(days=-1, seconds=82800), 'foo')\nfreq = 'B'\n\n    @pytest.mark.parametrize(\"freq\", [\"T\", \"B\"])\n    def test_intersection_empty(self, tz_aware_fixture, freq):\n        # empty same freq GH2129\n        tz = tz_aware_fixture\n        rng = date_range(\"6/1/2000\", \"6/15/2000\", freq=freq, tz=tz)\n        result = rng[0:0].intersection(rng)\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        result = rng.intersection(rng[0:0])\n        assert len(result) == 0\n        assert result.freq == rng.freq\n    \n        # no overlap GH#33604\n        result = rng[:3].intersection(rng[-3:])\n>       tm.assert_index_equal(result, rng[:0])\n\npandas/tests/indexes/datetimes/test_setops.py:289: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex([], dtype='datetime64[ns]', freq=None)\nr = DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B'), obj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)",
            "\npandas/_testing.py:611: AssertionError"
        ],
        [
            "self = <pandas.tests.indexes.datetimes.test_setops.TestBusinessDatetimeIndex object at 0x110c75970>\n\n    def test_intersection_bug(self):\n        # GH #771\n        a = bdate_range(\"11/30/2011\", \"12/31/2011\")\n        b = bdate_range(\"12/10/2011\", \"12/20/2011\")\n        result = a.intersection(b)\n        tm.assert_index_equal(result, b)\n>       assert result.freq == b.freq",
            "\npandas/tests/indexes/datetimes/test_setops.py:473: AssertionError"
        ],
        [
            "self = <pandas.tests.indexes.datetimes.test_setops.TestCustomDatetimeIndex object at 0x110b58070>\n\n    def test_intersection_bug(self):\n        # GH #771\n        a = bdate_range(\"11/30/2011\", \"12/31/2011\", freq=\"C\")\n        b = bdate_range(\"12/10/2011\", \"12/20/2011\", freq=\"C\")\n        result = a.intersection(b)\n        tm.assert_index_equal(result, b)\n>       assert result.freq == b.freq",
            "\npandas/tests/indexes/datetimes/test_setops.py:551: AssertionError"
        ]
    ],
    "2.1.3": [
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>",
                "other": "array of shape (20161,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>",
                "other.copy": "<bound method Index.copy of Da ... TC]', length=20161, freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... TC]', length=20161, freq='T')>",
                "self": "array of shape (20161,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... TC]', length=20161, freq='T')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOps ... TC]', length=20161, freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... TC]', length=20161, freq='T')>",
                "self.copy": "<bound method Index.copy of Da ... TC]', length=20161, freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... TC]', length=20161, freq='T')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, UTC]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, UTC]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... tetime64[ns, UTC]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... tetime64[ns, UTC]', freq='B')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... tetime64[ns, UTC]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... tetime64[ns, UTC]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... tetime64[ns, UTC]', freq='B')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00+0000', tz='UTC', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00+0000', tz='UTC', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "left.values": "array(['2000-06-01T00:00:00.000000000', '2000-06-02T00:00:00.000000000',\n       '2000-06-05T00:00:00.000000000'], dtype='datetime64[ns]')"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "other": "array of shape (20161,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "other.copy": "<bound method Index.copy of Da ... rn]', length=20161, freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... rn]', length=20161, freq='T')>",
                "self": "array of shape (20161,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... rn]', length=20161, freq='T')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOps ... rn]', length=20161, freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... rn]', length=20161, freq='T')>",
                "self.copy": "<bound method Index.copy of Da ... rn]', length=20161, freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... rn]', length=20161, freq='T')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, US/Eastern]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, US/Eastern]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',\n               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',\n               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',\n               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',\n               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',\n               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',\n               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... 4[ns, US/Eastern]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',\n               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',\n               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',\n               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... 4[ns, US/Eastern]', freq='B')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... 4[ns, US/Eastern]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... 4[ns, US/Eastern]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',\n               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',\n               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',\n               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... 4[ns, US/Eastern]', freq='B')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00-0400', tz='US/Eastern', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00-0400', tz='US/Eastern', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "left.values": "array(['2000-06-01T04:00:00.000000000', '2000-06-02T04:00:00.000000000',\n       '2000-06-05T04:00:00.000000000'], dtype='datetime64[ns]')"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "other": "array of shape (20161,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "other.copy": "<bound method Index.copy of Da ... yo]', length=20161, freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... yo]', length=20161, freq='T')>",
                "self": "array of shape (20161,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... yo]', length=20161, freq='T')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOps ... yo]', length=20161, freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... yo]', length=20161, freq='T')>",
                "self.copy": "<bound method Index.copy of Da ... yo]', length=20161, freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... yo]', length=20161, freq='T')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, Asia/Tokyo]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, Asia/Tokyo]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',\n               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',\n               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',\n               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',\n               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',\n               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',\n               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... 4[ns, Asia/Tokyo]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',\n               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',\n               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',\n               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... 4[ns, Asia/Tokyo]', freq='B')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... 4[ns, Asia/Tokyo]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... 4[ns, Asia/Tokyo]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',\n               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',\n               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',\n               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... 4[ns, Asia/Tokyo]', freq='B')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00+0900', tz='Asia/Tokyo', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00+0900', tz='Asia/Tokyo', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "left.values": "array(['2000-05-31T15:00:00.000000000', '2000-06-01T15:00:00.000000000',\n       '2000-06-04T15:00:00.000000000'], dtype='datetime64[ns]')"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "other": "array of shape (20161,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "other.copy": "<bound method Index.copy of Da ... ')]', length=20161, freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... ')]', length=20161, freq='T')>",
                "self": "array of shape (20161,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... ')]', length=20161, freq='T')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOps ... ')]', length=20161, freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... ')]', length=20161, freq='T')>",
                "self.copy": "<bound method Index.copy of Da ... ')]', length=20161, freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... ')]', length=20161, freq='T')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00', '2000-06-06 00:00:00-07:00',\n               '2000-06-07 00:00:00-07:00', '2000-06-08 00:00:00-07:00',\n               '2000-06-09 00:00:00-07:00', '2000-06-12 00:00:00-07:00',\n               '2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "other.copy": "<bound method Index.copy of Da ... nfo/US/Pacific')]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... nfo/US/Pacific')]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00', '2000-06-06 00:00:00-07:00',\n               '2000-06-07 00:00:00-07:00', '2000-06-08 00:00:00-07:00',\n               '2000-06-09 00:00:00-07:00', '2000-06-12 00:00:00-07:00',\n               '2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... nfo/US/Pacific')]', freq='B')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... nfo/US/Pacific')]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... nfo/US/Pacific')]', freq='B')>",
                "self.copy": "<bound method Index.copy of Da ... nfo/US/Pacific')]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... nfo/US/Pacific')]', freq='B')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00-0700', tz='dateutil//usr/share/zoneinfo/US/Pacific', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00-0700', tz='dateutil//usr/share/zoneinfo/US/Pacific', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "left.values": "array(['2000-06-01T07:00:00.000000000', '2000-06-02T07:00:00.000000000',\n       '2000-06-05T07:00:00.000000000'], dtype='datetime64[ns]')"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "other": "array of shape (20161,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "other.copy": "<bound method Index.copy of Da ... ')]', length=20161, freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... ')]', length=20161, freq='T')>",
                "self": "array of shape (20161,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... ')]', length=20161, freq='T')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOps ... ')]', length=20161, freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... ')]', length=20161, freq='T')>",
                "self.copy": "<bound method Index.copy of Da ... ')]', length=20161, freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... ')]', length=20161, freq='T')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "other": "array of shape (11,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "other.copy": "<bound method Index.copy of Da ... Asia/Singapore')]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... Asia/Singapore')]', freq='B')>",
                "self": "array of shape (11,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... Asia/Singapore')]', freq='B')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... Asia/Singapore')]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... Asia/Singapore')]', freq='B')>",
                "self.copy": "<bound method Index.copy of Da ... Asia/Singapore')]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... Asia/Singapore')]', freq='B')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00+0800', tz='dateutil//usr/share/zoneinfo/Asia/Singapore', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00+0800', tz='dateutil//usr/share/zoneinfo/Asia/Singapore', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "left.values": "array(['2000-05-31T16:00:00.000000000', '2000-06-01T16:00:00.000000000',\n       '2000-06-04T16:00:00.000000000'], dtype='datetime64[ns]')"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>",
                "other": "array of shape (20161,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>",
                "other.copy": "<bound method Index.copy of Da ... ()]', length=20161, freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... ()]', length=20161, freq='T')>",
                "self": "array of shape (20161,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... ()]', length=20161, freq='T')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOps ... ()]', length=20161, freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... ()]', length=20161, freq='T')>",
                "self.copy": "<bound method Index.copy of Da ... ()]', length=20161, freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... ()]', length=20161, freq='T')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzutc()]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzutc()]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... me64[ns, tzutc()]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... me64[ns, tzutc()]', freq='B')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... me64[ns, tzutc()]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... me64[ns, tzutc()]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... me64[ns, tzutc()]', freq='B')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00+0000', tz='tzutc()', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00+0000', tz='tzutc()', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "left.values": "array(['2000-06-01T00:00:00.000000000', '2000-06-02T00:00:00.000000000',\n       '2000-06-05T00:00:00.000000000'], dtype='datetime64[ns]')"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "other": "array of shape (20161,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "other.copy": "<bound method Index.copy of Da ... ()]', length=20161, freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... ()]', length=20161, freq='T')>",
                "self": "array of shape (20161,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... ()]', length=20161, freq='T')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOps ... ()]', length=20161, freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... ()]', length=20161, freq='T')>",
                "self.copy": "<bound method Index.copy of Da ... ()]', length=20161, freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... ()]', length=20161, freq='T')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzlocal()]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzlocal()]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... 64[ns, tzlocal()]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... 64[ns, tzlocal()]', freq='B')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... 64[ns, tzlocal()]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... 64[ns, tzlocal()]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... 64[ns, tzlocal()]', freq='B')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00+0100', tz='tzlocal()', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00+0100', tz='tzlocal()', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "left.values": "array(['2000-05-31T23:00:00.000000000', '2000-06-01T23:00:00.000000000',\n       '2000-06-04T23:00:00.000000000'], dtype='datetime64[ns]')"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "other": "array of shape (20161,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "other.copy": "<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... 0)]', length=20161, freq='T')>",
                "self": "array of shape (20161,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... 0)]', length=20161, freq='T')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOps ... 0)]', length=20161, freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... 0)]', length=20161, freq='T')>",
                "self.copy": "<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... 0)]', length=20161, freq='T')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, pytz.FixedOffset(300)]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, pytz.FixedOffset(300)]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00', '2000-06-06 00:00:00+05:00',\n               '2000-06-07 00:00:00+05:00', '2000-06-08 00:00:00+05:00',\n               '2000-06-09 00:00:00+05:00', '2000-06-12 00:00:00+05:00',\n               '2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "other.copy": "<bound method Index.copy of Da ... FixedOffset(300)]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... FixedOffset(300)]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00', '2000-06-06 00:00:00+05:00',\n               '2000-06-07 00:00:00+05:00', '2000-06-08 00:00:00+05:00',\n               '2000-06-09 00:00:00+05:00', '2000-06-12 00:00:00+05:00',\n               '2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... FixedOffset(300)]', freq='B')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... FixedOffset(300)]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... FixedOffset(300)]', freq='B')>",
                "self.copy": "<bound method Index.copy of Da ... FixedOffset(300)]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... FixedOffset(300)]', freq='B')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00+0500', tz='pytz.FixedOffset(300)', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00+0500', tz='pytz.FixedOffset(300)', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "left.values": "array(['2000-05-31T19:00:00.000000000', '2000-06-01T19:00:00.000000000',\n       '2000-06-04T19:00:00.000000000'], dtype='datetime64[ns]')"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "other": "array of shape (20161,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "other.copy": "<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... 0)]', length=20161, freq='T')>",
                "self": "array of shape (20161,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... 0)]', length=20161, freq='T')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOps ... 0)]', length=20161, freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... 0)]', length=20161, freq='T')>",
                "self.copy": "<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... 0)]', length=20161, freq='T')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, pytz.FixedOffset(-300)]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, pytz.FixedOffset(-300)]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00', '2000-06-06 00:00:00-05:00',\n               '2000-06-07 00:00:00-05:00', '2000-06-08 00:00:00-05:00',\n               '2000-06-09 00:00:00-05:00', '2000-06-12 00:00:00-05:00',\n               '2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "other.copy": "<bound method Index.copy of Da ... ixedOffset(-300)]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... ixedOffset(-300)]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00', '2000-06-06 00:00:00-05:00',\n               '2000-06-07 00:00:00-05:00', '2000-06-08 00:00:00-05:00',\n               '2000-06-09 00:00:00-05:00', '2000-06-12 00:00:00-05:00',\n               '2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... ixedOffset(-300)]', freq='B')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... ixedOffset(-300)]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... ixedOffset(-300)]', freq='B')>",
                "self.copy": "<bound method Index.copy of Da ... ixedOffset(-300)]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... ixedOffset(-300)]', freq='B')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00-0500', tz='pytz.FixedOffset(-300)', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00-0500', tz='pytz.FixedOffset(-300)', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "left.values": "array(['2000-06-01T05:00:00.000000000', '2000-06-02T05:00:00.000000000',\n       '2000-06-05T05:00:00.000000000'], dtype='datetime64[ns]')"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "other": "array of shape (20161,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "other.copy": "<bound method Index.copy of Da ... 00]', length=20161, freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... 00]', length=20161, freq='T')>",
                "self": "array of shape (20161,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... 00]', length=20161, freq='T')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOps ... 00]', length=20161, freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... 00]', length=20161, freq='T')>",
                "self.copy": "<bound method Index.copy of Da ... 00]', length=20161, freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... 00]', length=20161, freq='T')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, UTC+01:00]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, UTC+01:00]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... 64[ns, UTC+01:00]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... 64[ns, UTC+01:00]', freq='B')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... 64[ns, UTC+01:00]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... 64[ns, UTC+01:00]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... 64[ns, UTC+01:00]', freq='B')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00+0100', tz='UTC+01:00', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00+0100', tz='UTC+01:00', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "left.values": "array(['2000-05-31T23:00:00.000000000', '2000-06-01T23:00:00.000000000',\n       '2000-06-04T23:00:00.000000000'], dtype='datetime64[ns]')"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>",
                "other": "array of shape (20161,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>",
                "other.copy": "<bound method Index.copy of Da ... oo]', length=20161, freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... oo]', length=20161, freq='T')>",
                "self": "array of shape (20161,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... oo]', length=20161, freq='T')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOps ... oo]', length=20161, freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... oo]', length=20161, freq='T')>",
                "self.copy": "<bound method Index.copy of Da ... oo]', length=20161, freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... oo]', length=20161, freq='T')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, foo]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, foo]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',\n               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',\n               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',\n               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',\n               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',\n               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',\n               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... tetime64[ns, foo]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',\n               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',\n               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',\n               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... tetime64[ns, foo]', freq='B')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... tetime64[ns, foo]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... tetime64[ns, foo]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',\n               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',\n               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',\n               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... tetime64[ns, foo]', freq='B')>"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00-0100', tz='foo', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00-0100', tz='foo', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "left.values": "array(['2000-06-01T01:00:00.000000000', '2000-06-02T01:00:00.000000000',\n       '2000-06-05T01:00:00.000000000'], dtype='datetime64[ns]')"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... e='datetime64[ns]', freq='B')>",
                "self": "DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... e='datetime64[ns]', freq='B')>",
                "other": "DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... e='datetime64[ns]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... e='datetime64[ns]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... e='datetime64[ns]', freq='B')>"
            },
            {
                "left": "DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='B')",
                "right": "DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='B')",
                "end": "Timestamp('2011-12-20 00:00:00', freq='B')",
                "start": "Timestamp('2011-12-12 00:00:00', freq='B')",
                "lslice": "slice(8, 15, None)",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='B')>",
                "left_chunk": "array(['2011-12-12T00:00:00.000000000', '2011-12-13T00:00:00.000000000',\n       '2011-12-14T00:00:00.000000000', '2011-12-15T00:00:00.000000000',\n       '2011-12-16T00:00:00.000000000', '2011-12-19T00:00:00.000000000',\n       '2011-12-20T00:00:00.000000000'], dtype='datetime64[ns]')",
                "left.values": "array of shape (23,)"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... e='datetime64[ns]', freq='C')>",
                "self": "DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='C')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... e='datetime64[ns]', freq='C')>",
                "other": "DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='C')",
                "self.equals": "<bound method DatetimeIndexOps ... e='datetime64[ns]', freq='C')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... e='datetime64[ns]', freq='C')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='C')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='C')>",
                "other.freq": "<CustomBusinessDay>",
                "self.freq": "<CustomBusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... e='datetime64[ns]', freq='C')>"
            },
            {
                "left": "DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='C')",
                "right": "DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='C')",
                "end": "Timestamp('2011-12-20 00:00:00', freq='C')",
                "start": "Timestamp('2011-12-12 00:00:00', freq='C')",
                "lslice": "slice(8, 15, None)",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='C')>",
                "left_chunk": "array(['2011-12-12T00:00:00.000000000', '2011-12-13T00:00:00.000000000',\n       '2011-12-14T00:00:00.000000000', '2011-12-15T00:00:00.000000000',\n       '2011-12-16T00:00:00.000000000', '2011-12-19T00:00:00.000000000',\n       '2011-12-20T00:00:00.000000000'], dtype='datetime64[ns]')",
                "left.values": "array of shape (23,)"
            }
        ]
    ],
    "2.1.4": [
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left.values": "ndarray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left.values": "ndarray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left.values": "ndarray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left.values": "ndarray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left.values": "ndarray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left.values": "ndarray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left.values": "ndarray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left.values": "ndarray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left.values": "ndarray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left.values": "ndarray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left.values": "ndarray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "lslice": "slice",
                "left.slice_locs": "method",
                "left_chunk": "ndarray",
                "left.values": "ndarray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "CustomBusinessDay",
                "self.freq": "CustomBusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "lslice": "slice",
                "left.slice_locs": "method",
                "left_chunk": "ndarray",
                "left.values": "ndarray"
            }
        ]
    ],
    "2.1.5": [
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>",
                "other": "array of shape (20161,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>",
                "other.copy": "<bound method Index.copy of Da ... TC]', length=20161, freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>",
                "self.dtype": "datetime64[ns, UTC]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... TC]', length=20161, freq='T')>",
                "self": "array of shape (20161,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... TC]', length=20161, freq='T')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOps ... TC]', length=20161, freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... TC]', length=20161, freq='T')>",
                "self.copy": "<bound method Index.copy of Da ... TC]', length=20161, freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... TC]', length=20161, freq='T')>",
                "self.dtype": "datetime64[ns, UTC]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "self.dtype": "datetime64[ns, UTC]"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, UTC]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='T')>",
                "self.dtype": "datetime64[ns, UTC]"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, UTC]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>",
                "self.dtype": "datetime64[ns, UTC]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... tetime64[ns, UTC]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... tetime64[ns, UTC]', freq='B')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... tetime64[ns, UTC]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... tetime64[ns, UTC]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... tetime64[ns, UTC]', freq='B')>",
                "self.dtype": "datetime64[ns, UTC]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "self.dtype": "datetime64[ns, UTC]"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00+0000', tz='UTC', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00+0000', tz='UTC', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "left._values": "<DatetimeArray>\n['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n '2000-06-05 00:00:00+00:00']\nLength: 3, dtype: datetime64[ns, UTC]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "self.dtype": "datetime64[ns, UTC]"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00+0000', tz='UTC', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00+0000', tz='UTC', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='B')>",
                "left._values": "<DatetimeArray>\n['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n '2000-06-05 00:00:00+00:00']\nLength: 3, dtype: datetime64[ns, UTC]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "other": "array of shape (20161,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "other.copy": "<bound method Index.copy of Da ... rn]', length=20161, freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "self.dtype": "datetime64[ns, US/Eastern]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... rn]', length=20161, freq='T')>",
                "self": "array of shape (20161,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... rn]', length=20161, freq='T')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOps ... rn]', length=20161, freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... rn]', length=20161, freq='T')>",
                "self.copy": "<bound method Index.copy of Da ... rn]', length=20161, freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... rn]', length=20161, freq='T')>",
                "self.dtype": "datetime64[ns, US/Eastern]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "self.dtype": "datetime64[ns, US/Eastern]"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, US/Eastern]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-01 00:01:00-04:00',\n               '2000-06-01 00:02:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-04:00', '2000-06-14 23:59:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='T')>",
                "self.dtype": "datetime64[ns, US/Eastern]"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, US/Eastern]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',\n               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',\n               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',\n               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',\n               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',\n               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',\n               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "self.dtype": "datetime64[ns, US/Eastern]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... 4[ns, US/Eastern]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',\n               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',\n               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',\n               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... 4[ns, US/Eastern]', freq='B')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... 4[ns, US/Eastern]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... 4[ns, US/Eastern]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00', '2000-06-06 00:00:00-04:00',\n               '2000-06-07 00:00:00-04:00', '2000-06-08 00:00:00-04:00',\n               '2000-06-09 00:00:00-04:00', '2000-06-12 00:00:00-04:00',\n               '2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... 4[ns, US/Eastern]', freq='B')>",
                "self.dtype": "datetime64[ns, US/Eastern]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "self.dtype": "datetime64[ns, US/Eastern]"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00-0400', tz='US/Eastern', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00-0400', tz='US/Eastern', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "left._values": "<DatetimeArray>\n['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n '2000-06-05 00:00:00-04:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "self.dtype": "datetime64[ns, US/Eastern]"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00-04:00', '2000-06-14 00:00:00-04:00',\n               '2000-06-15 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00-0400', tz='US/Eastern', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00-0400', tz='US/Eastern', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n               '2000-06-05 00:00:00-04:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='B')>",
                "left._values": "<DatetimeArray>\n['2000-06-01 00:00:00-04:00', '2000-06-02 00:00:00-04:00',\n '2000-06-05 00:00:00-04:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "other": "array of shape (20161,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "other.copy": "<bound method Index.copy of Da ... yo]', length=20161, freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "self.dtype": "datetime64[ns, Asia/Tokyo]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... yo]', length=20161, freq='T')>",
                "self": "array of shape (20161,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... yo]', length=20161, freq='T')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOps ... yo]', length=20161, freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... yo]', length=20161, freq='T')>",
                "self.copy": "<bound method Index.copy of Da ... yo]', length=20161, freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... yo]', length=20161, freq='T')>",
                "self.dtype": "datetime64[ns, Asia/Tokyo]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "self.dtype": "datetime64[ns, Asia/Tokyo]"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, Asia/Tokyo]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-01 00:01:00+09:00',\n               '2000-06-01 00:02:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+09:00', '2000-06-14 23:59:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='T')>",
                "self.dtype": "datetime64[ns, Asia/Tokyo]"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, Asia/Tokyo]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',\n               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',\n               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',\n               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',\n               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',\n               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',\n               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "self.dtype": "datetime64[ns, Asia/Tokyo]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... 4[ns, Asia/Tokyo]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',\n               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',\n               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',\n               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... 4[ns, Asia/Tokyo]', freq='B')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... 4[ns, Asia/Tokyo]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... 4[ns, Asia/Tokyo]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00', '2000-06-06 00:00:00+09:00',\n               '2000-06-07 00:00:00+09:00', '2000-06-08 00:00:00+09:00',\n               '2000-06-09 00:00:00+09:00', '2000-06-12 00:00:00+09:00',\n               '2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... 4[ns, Asia/Tokyo]', freq='B')>",
                "self.dtype": "datetime64[ns, Asia/Tokyo]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "self.dtype": "datetime64[ns, Asia/Tokyo]"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00+0900', tz='Asia/Tokyo', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00+0900', tz='Asia/Tokyo', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "left._values": "<DatetimeArray>\n['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n '2000-06-05 00:00:00+09:00']\nLength: 3, dtype: datetime64[ns, Asia/Tokyo]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "self.dtype": "datetime64[ns, Asia/Tokyo]"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00+09:00', '2000-06-14 00:00:00+09:00',\n               '2000-06-15 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00+0900', tz='Asia/Tokyo', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00+0900', tz='Asia/Tokyo', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n               '2000-06-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='B')>",
                "left._values": "<DatetimeArray>\n['2000-06-01 00:00:00+09:00', '2000-06-02 00:00:00+09:00',\n '2000-06-05 00:00:00+09:00']\nLength: 3, dtype: datetime64[ns, Asia/Tokyo]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "other": "array of shape (20161,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "other.copy": "<bound method Index.copy of Da ... ')]', length=20161, freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "self.dtype": "datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... ')]', length=20161, freq='T')>",
                "self": "array of shape (20161,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... ')]', length=20161, freq='T')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOps ... ')]', length=20161, freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... ')]', length=20161, freq='T')>",
                "self.copy": "<bound method Index.copy of Da ... ')]', length=20161, freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... ')]', length=20161, freq='T')>",
                "self.dtype": "datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "self.dtype": "datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-01 00:01:00-07:00',\n               '2000-06-01 00:02:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-07:00', '2000-06-14 23:59:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='T')>",
                "self.dtype": "datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00', '2000-06-06 00:00:00-07:00',\n               '2000-06-07 00:00:00-07:00', '2000-06-08 00:00:00-07:00',\n               '2000-06-09 00:00:00-07:00', '2000-06-12 00:00:00-07:00',\n               '2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "other.copy": "<bound method Index.copy of Da ... nfo/US/Pacific')]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "self.dtype": "datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... nfo/US/Pacific')]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00', '2000-06-06 00:00:00-07:00',\n               '2000-06-07 00:00:00-07:00', '2000-06-08 00:00:00-07:00',\n               '2000-06-09 00:00:00-07:00', '2000-06-12 00:00:00-07:00',\n               '2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... nfo/US/Pacific')]', freq='B')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... nfo/US/Pacific')]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... nfo/US/Pacific')]', freq='B')>",
                "self.copy": "<bound method Index.copy of Da ... nfo/US/Pacific')]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... nfo/US/Pacific')]', freq='B')>",
                "self.dtype": "datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "self.dtype": "datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00-0700', tz='dateutil//usr/share/zoneinfo/US/Pacific', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00-0700', tz='dateutil//usr/share/zoneinfo/US/Pacific', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "left._values": "<DatetimeArray>\n['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n '2000-06-05 00:00:00-07:00']\nLength: 3, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "self.dtype": "datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00-07:00', '2000-06-14 00:00:00-07:00',\n               '2000-06-15 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00-0700', tz='dateutil//usr/share/zoneinfo/US/Pacific', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00-0700', tz='dateutil//usr/share/zoneinfo/US/Pacific', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n               '2000-06-05 00:00:00-07:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='B')>",
                "left._values": "<DatetimeArray>\n['2000-06-01 00:00:00-07:00', '2000-06-02 00:00:00-07:00',\n '2000-06-05 00:00:00-07:00']\nLength: 3, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "other": "array of shape (20161,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "other.copy": "<bound method Index.copy of Da ... ')]', length=20161, freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "self.dtype": "datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... ')]', length=20161, freq='T')>",
                "self": "array of shape (20161,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... ')]', length=20161, freq='T')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOps ... ')]', length=20161, freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... ')]', length=20161, freq='T')>",
                "self.copy": "<bound method Index.copy of Da ... ')]', length=20161, freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... ')]', length=20161, freq='T')>",
                "self.dtype": "datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "self.dtype": "datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-01 00:01:00+08:00',\n               '2000-06-01 00:02:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+08:00', '2000-06-14 23:59:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='T')>",
                "self.dtype": "datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "other": "array of shape (11,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "other.copy": "<bound method Index.copy of Da ... Asia/Singapore')]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "self.dtype": "datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... Asia/Singapore')]', freq='B')>",
                "self": "array of shape (11,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... Asia/Singapore')]', freq='B')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... Asia/Singapore')]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... Asia/Singapore')]', freq='B')>",
                "self.copy": "<bound method Index.copy of Da ... Asia/Singapore')]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... Asia/Singapore')]', freq='B')>",
                "self.dtype": "datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "self.dtype": "datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00+0800', tz='dateutil//usr/share/zoneinfo/Asia/Singapore', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00+0800', tz='dateutil//usr/share/zoneinfo/Asia/Singapore', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "left._values": "<DatetimeArray>\n['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n '2000-06-05 00:00:00+08:00']\nLength: 3, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "self.dtype": "datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00+08:00', '2000-06-14 00:00:00+08:00',\n               '2000-06-15 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00+0800', tz='dateutil//usr/share/zoneinfo/Asia/Singapore', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00+0800', tz='dateutil//usr/share/zoneinfo/Asia/Singapore', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n               '2000-06-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='B')>",
                "left._values": "<DatetimeArray>\n['2000-06-01 00:00:00+08:00', '2000-06-02 00:00:00+08:00',\n '2000-06-05 00:00:00+08:00']\nLength: 3, dtype: datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>",
                "other": "array of shape (20161,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>",
                "other.copy": "<bound method Index.copy of Da ... ()]', length=20161, freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>",
                "self.dtype": "datetime64[ns, tzutc()]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... ()]', length=20161, freq='T')>",
                "self": "array of shape (20161,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... ()]', length=20161, freq='T')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOps ... ()]', length=20161, freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... ()]', length=20161, freq='T')>",
                "self.copy": "<bound method Index.copy of Da ... ()]', length=20161, freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... ()]', length=20161, freq='T')>",
                "self.dtype": "datetime64[ns, tzutc()]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "self.dtype": "datetime64[ns, tzutc()]"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzutc()]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-01 00:01:00+00:00',\n               '2000-06-01 00:02:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+00:00', '2000-06-14 23:59:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='T')>",
                "self.dtype": "datetime64[ns, tzutc()]"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzutc()]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>",
                "self.dtype": "datetime64[ns, tzutc()]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... me64[ns, tzutc()]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... me64[ns, tzutc()]', freq='B')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... me64[ns, tzutc()]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... me64[ns, tzutc()]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00', '2000-06-06 00:00:00+00:00',\n               '2000-06-07 00:00:00+00:00', '2000-06-08 00:00:00+00:00',\n               '2000-06-09 00:00:00+00:00', '2000-06-12 00:00:00+00:00',\n               '2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzutc()]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... me64[ns, tzutc()]', freq='B')>",
                "self.dtype": "datetime64[ns, tzutc()]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "self.dtype": "datetime64[ns, tzutc()]"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00+0000', tz='tzutc()', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00+0000', tz='tzutc()', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "left._values": "<DatetimeArray>\n['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n '2000-06-05 00:00:00+00:00']\nLength: 3, dtype: datetime64[ns, tzutc()]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "self.dtype": "datetime64[ns, tzutc()]"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00+00:00', '2000-06-14 00:00:00+00:00',\n               '2000-06-15 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00+0000', tz='tzutc()', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00+0000', tz='tzutc()', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n               '2000-06-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='B')>",
                "left._values": "<DatetimeArray>\n['2000-06-01 00:00:00+00:00', '2000-06-02 00:00:00+00:00',\n '2000-06-05 00:00:00+00:00']\nLength: 3, dtype: datetime64[ns, tzutc()]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "other": "array of shape (20161,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "other.copy": "<bound method Index.copy of Da ... ()]', length=20161, freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "self.dtype": "datetime64[ns, tzlocal()]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... ()]', length=20161, freq='T')>",
                "self": "array of shape (20161,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... ()]', length=20161, freq='T')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOps ... ()]', length=20161, freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... ()]', length=20161, freq='T')>",
                "self.copy": "<bound method Index.copy of Da ... ()]', length=20161, freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... ()]', length=20161, freq='T')>",
                "self.dtype": "datetime64[ns, tzlocal()]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "self.dtype": "datetime64[ns, tzlocal()]"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzlocal()]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='T')>",
                "self.dtype": "datetime64[ns, tzlocal()]"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, tzlocal()]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "self.dtype": "datetime64[ns, tzlocal()]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... 64[ns, tzlocal()]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... 64[ns, tzlocal()]', freq='B')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... 64[ns, tzlocal()]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... 64[ns, tzlocal()]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... 64[ns, tzlocal()]', freq='B')>",
                "self.dtype": "datetime64[ns, tzlocal()]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "self.dtype": "datetime64[ns, tzlocal()]"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00+0100', tz='tzlocal()', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00+0100', tz='tzlocal()', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "left._values": "<DatetimeArray>\n['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n '2000-06-05 00:00:00+01:00']\nLength: 3, dtype: datetime64[ns, tzlocal()]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "self.dtype": "datetime64[ns, tzlocal()]"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00+0100', tz='tzlocal()', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00+0100', tz='tzlocal()', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='B')>",
                "left._values": "<DatetimeArray>\n['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n '2000-06-05 00:00:00+01:00']\nLength: 3, dtype: datetime64[ns, tzlocal()]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "other": "array of shape (20161,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "other.copy": "<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "self.dtype": "datetime64[ns, pytz.FixedOffset(300)]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... 0)]', length=20161, freq='T')>",
                "self": "array of shape (20161,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... 0)]', length=20161, freq='T')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOps ... 0)]', length=20161, freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... 0)]', length=20161, freq='T')>",
                "self.copy": "<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... 0)]', length=20161, freq='T')>",
                "self.dtype": "datetime64[ns, pytz.FixedOffset(300)]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "self.dtype": "datetime64[ns, pytz.FixedOffset(300)]"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, pytz.FixedOffset(300)]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-01 00:01:00+05:00',\n               '2000-06-01 00:02:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+05:00', '2000-06-14 23:59:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='T')>",
                "self.dtype": "datetime64[ns, pytz.FixedOffset(300)]"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, pytz.FixedOffset(300)]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00', '2000-06-06 00:00:00+05:00',\n               '2000-06-07 00:00:00+05:00', '2000-06-08 00:00:00+05:00',\n               '2000-06-09 00:00:00+05:00', '2000-06-12 00:00:00+05:00',\n               '2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "other.copy": "<bound method Index.copy of Da ... FixedOffset(300)]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "self.dtype": "datetime64[ns, pytz.FixedOffset(300)]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... FixedOffset(300)]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00', '2000-06-06 00:00:00+05:00',\n               '2000-06-07 00:00:00+05:00', '2000-06-08 00:00:00+05:00',\n               '2000-06-09 00:00:00+05:00', '2000-06-12 00:00:00+05:00',\n               '2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... FixedOffset(300)]', freq='B')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... FixedOffset(300)]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... FixedOffset(300)]', freq='B')>",
                "self.copy": "<bound method Index.copy of Da ... FixedOffset(300)]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... FixedOffset(300)]', freq='B')>",
                "self.dtype": "datetime64[ns, pytz.FixedOffset(300)]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "self.dtype": "datetime64[ns, pytz.FixedOffset(300)]"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00+0500', tz='pytz.FixedOffset(300)', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00+0500', tz='pytz.FixedOffset(300)', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "left._values": "<DatetimeArray>\n['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n '2000-06-05 00:00:00+05:00']\nLength: 3, dtype: datetime64[ns, pytz.FixedOffset(300)]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "self.dtype": "datetime64[ns, pytz.FixedOffset(300)]"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00+05:00', '2000-06-14 00:00:00+05:00',\n               '2000-06-15 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00+0500', tz='pytz.FixedOffset(300)', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00+0500', tz='pytz.FixedOffset(300)', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n               '2000-06-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='B')>",
                "left._values": "<DatetimeArray>\n['2000-06-01 00:00:00+05:00', '2000-06-02 00:00:00+05:00',\n '2000-06-05 00:00:00+05:00']\nLength: 3, dtype: datetime64[ns, pytz.FixedOffset(300)]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "other": "array of shape (20161,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "other.copy": "<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "self.dtype": "datetime64[ns, pytz.FixedOffset(-300)]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... 0)]', length=20161, freq='T')>",
                "self": "array of shape (20161,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... 0)]', length=20161, freq='T')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOps ... 0)]', length=20161, freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... 0)]', length=20161, freq='T')>",
                "self.copy": "<bound method Index.copy of Da ... 0)]', length=20161, freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... 0)]', length=20161, freq='T')>",
                "self.dtype": "datetime64[ns, pytz.FixedOffset(-300)]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "self.dtype": "datetime64[ns, pytz.FixedOffset(-300)]"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, pytz.FixedOffset(-300)]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-01 00:01:00-05:00',\n               '2000-06-01 00:02:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-05:00', '2000-06-14 23:59:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='T')>",
                "self.dtype": "datetime64[ns, pytz.FixedOffset(-300)]"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, pytz.FixedOffset(-300)]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00', '2000-06-06 00:00:00-05:00',\n               '2000-06-07 00:00:00-05:00', '2000-06-08 00:00:00-05:00',\n               '2000-06-09 00:00:00-05:00', '2000-06-12 00:00:00-05:00',\n               '2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "other.copy": "<bound method Index.copy of Da ... ixedOffset(-300)]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "self.dtype": "datetime64[ns, pytz.FixedOffset(-300)]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... ixedOffset(-300)]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00', '2000-06-06 00:00:00-05:00',\n               '2000-06-07 00:00:00-05:00', '2000-06-08 00:00:00-05:00',\n               '2000-06-09 00:00:00-05:00', '2000-06-12 00:00:00-05:00',\n               '2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... ixedOffset(-300)]', freq='B')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... ixedOffset(-300)]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... ixedOffset(-300)]', freq='B')>",
                "self.copy": "<bound method Index.copy of Da ... ixedOffset(-300)]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... ixedOffset(-300)]', freq='B')>",
                "self.dtype": "datetime64[ns, pytz.FixedOffset(-300)]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "self.dtype": "datetime64[ns, pytz.FixedOffset(-300)]"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00-0500', tz='pytz.FixedOffset(-300)', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00-0500', tz='pytz.FixedOffset(-300)', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "left._values": "<DatetimeArray>\n['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n '2000-06-05 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, pytz.FixedOffset(-300)]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "self.dtype": "datetime64[ns, pytz.FixedOffset(-300)]"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00-05:00', '2000-06-14 00:00:00-05:00',\n               '2000-06-15 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00-0500', tz='pytz.FixedOffset(-300)', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00-0500', tz='pytz.FixedOffset(-300)', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n               '2000-06-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='B')>",
                "left._values": "<DatetimeArray>\n['2000-06-01 00:00:00-05:00', '2000-06-02 00:00:00-05:00',\n '2000-06-05 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, pytz.FixedOffset(-300)]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "other": "array of shape (20161,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "other.copy": "<bound method Index.copy of Da ... 00]', length=20161, freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "self.dtype": "datetime64[ns, UTC+01:00]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... 00]', length=20161, freq='T')>",
                "self": "array of shape (20161,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... 00]', length=20161, freq='T')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOps ... 00]', length=20161, freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... 00]', length=20161, freq='T')>",
                "self.copy": "<bound method Index.copy of Da ... 00]', length=20161, freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... 00]', length=20161, freq='T')>",
                "self.dtype": "datetime64[ns, UTC+01:00]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "self.dtype": "datetime64[ns, UTC+01:00]"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, UTC+01:00]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-01 00:01:00+01:00',\n               '2000-06-01 00:02:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00+01:00', '2000-06-14 23:59:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='T')>",
                "self.dtype": "datetime64[ns, UTC+01:00]"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, UTC+01:00]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "self.dtype": "datetime64[ns, UTC+01:00]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... 64[ns, UTC+01:00]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... 64[ns, UTC+01:00]', freq='B')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... 64[ns, UTC+01:00]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... 64[ns, UTC+01:00]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00', '2000-06-06 00:00:00+01:00',\n               '2000-06-07 00:00:00+01:00', '2000-06-08 00:00:00+01:00',\n               '2000-06-09 00:00:00+01:00', '2000-06-12 00:00:00+01:00',\n               '2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... 64[ns, UTC+01:00]', freq='B')>",
                "self.dtype": "datetime64[ns, UTC+01:00]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "self.dtype": "datetime64[ns, UTC+01:00]"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00+0100', tz='UTC+01:00', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00+0100', tz='UTC+01:00', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "left._values": "<DatetimeArray>\n['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n '2000-06-05 00:00:00+01:00']\nLength: 3, dtype: datetime64[ns, UTC+01:00]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "self.dtype": "datetime64[ns, UTC+01:00]"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00+01:00', '2000-06-14 00:00:00+01:00',\n               '2000-06-15 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00+0100', tz='UTC+01:00', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00+0100', tz='UTC+01:00', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n               '2000-06-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='B')>",
                "left._values": "<DatetimeArray>\n['2000-06-01 00:00:00+01:00', '2000-06-02 00:00:00+01:00',\n '2000-06-05 00:00:00+01:00']\nLength: 3, dtype: datetime64[ns, UTC+01:00]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>",
                "other": "array of shape (20161,)",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>",
                "other.copy": "<bound method Index.copy of Da ... oo]', length=20161, freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>",
                "self.dtype": "datetime64[ns, foo]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... oo]', length=20161, freq='T')>",
                "self": "array of shape (20161,)",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... oo]', length=20161, freq='T')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOps ... oo]', length=20161, freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... oo]', length=20161, freq='T')>",
                "self.copy": "<bound method Index.copy of Da ... oo]', length=20161, freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... oo]', length=20161, freq='T')>",
                "self.dtype": "datetime64[ns, foo]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "self.dtype": "datetime64[ns, foo]"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, foo]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "self": "DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-01 00:01:00-01:00',\n               '2000-06-01 00:02:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "other.freq": "<Minute>",
                "self.freq": "<Minute>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-14 23:58:00-01:00', '2000-06-14 23:59:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='T')>",
                "self.dtype": "datetime64[ns, foo]"
            },
            {
                "result": "DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)",
                "result._set_freq": "<bound method DatetimeTimedeltaMixin._set_freq of DatetimeIndex([], dtype='datetime64[ns, foo]', freq=None)>",
                "result._data": "<DatetimeArray>\n[]\nLength: 0, dtype: datetime64[ns, foo]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>",
                "self": "DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',\n               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',\n               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',\n               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',\n               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',\n               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',\n               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>",
                "self.dtype": "datetime64[ns, foo]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... tetime64[ns, foo]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',\n               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',\n               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',\n               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... tetime64[ns, foo]', freq='B')>",
                "other": "DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... tetime64[ns, foo]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... tetime64[ns, foo]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00', '2000-06-06 00:00:00-01:00',\n               '2000-06-07 00:00:00-01:00', '2000-06-08 00:00:00-01:00',\n               '2000-06-09 00:00:00-01:00', '2000-06-12 00:00:00-01:00',\n               '2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex([], dtype='datetime64[ns, foo]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... tetime64[ns, foo]', freq='B')>",
                "self.dtype": "datetime64[ns, foo]"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "self.dtype": "datetime64[ns, foo]"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00-0100', tz='foo', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00-0100', tz='foo', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "left._values": "<DatetimeArray>\n['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n '2000-06-05 00:00:00-01:00']\nLength: 3, dtype: datetime64[ns, foo]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_sort_keyword of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "self": "DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_can_do_setop of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "other": "DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_reconciled_name_object of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedeltaMixin._shallow_copy of DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "self.dtype": "datetime64[ns, foo]"
            },
            {
                "left": "DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')",
                "right": "DatetimeIndex(['2000-06-13 00:00:00-01:00', '2000-06-14 00:00:00-01:00',\n               '2000-06-15 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')",
                "end": "Timestamp('2000-06-05 00:00:00-0100', tz='foo', freq='B')",
                "start": "Timestamp('2000-06-13 00:00:00-0100', tz='foo', freq='B')",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n               '2000-06-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='B')>",
                "left._values": "<DatetimeArray>\n['2000-06-01 00:00:00-01:00', '2000-06-02 00:00:00-01:00',\n '2000-06-05 00:00:00-01:00']\nLength: 3, dtype: datetime64[ns, foo]"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... e='datetime64[ns]', freq='B')>",
                "self": "DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='B')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... e='datetime64[ns]', freq='B')>",
                "other": "DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='B')",
                "self.equals": "<bound method DatetimeIndexOps ... e='datetime64[ns]', freq='B')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... e='datetime64[ns]', freq='B')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='B')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='B')>",
                "other.freq": "<BusinessDay>",
                "self.freq": "<BusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... e='datetime64[ns]', freq='B')>",
                "self.dtype": "dtype('<M8[ns]')"
            },
            {
                "left": "DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='B')",
                "right": "DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='B')",
                "end": "Timestamp('2011-12-20 00:00:00', freq='B')",
                "start": "Timestamp('2011-12-12 00:00:00', freq='B')",
                "lslice": "slice(8, 15, None)",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='B')>",
                "left_chunk": "<DatetimeArray>\n['2011-12-12 00:00:00', '2011-12-13 00:00:00', '2011-12-14 00:00:00',\n '2011-12-15 00:00:00', '2011-12-16 00:00:00', '2011-12-19 00:00:00',\n '2011-12-20 00:00:00']\nLength: 7, dtype: datetime64[ns]",
                "left._values": "array of shape (23,)"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "<bound method Index._validate_ ... e='datetime64[ns]', freq='C')>",
                "self": "DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='C')",
                "sort": "False",
                "self._assert_can_do_setop": "<bound method Index._assert_ca ... e='datetime64[ns]', freq='C')>",
                "other": "DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='C')",
                "self.equals": "<bound method DatetimeIndexOps ... e='datetime64[ns]', freq='C')>",
                "self._get_reconciled_name_object": "<bound method Index._get_recon ... e='datetime64[ns]', freq='C')>",
                "self.copy": "<bound method Index.copy of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='C')>",
                "other.copy": "<bound method Index.copy of DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='C')>",
                "other.freq": "<CustomBusinessDay>",
                "self.freq": "<CustomBusinessDay>",
                "self.is_monotonic": "True",
                "other.is_monotonic": "True",
                "self._shallow_copy": "<bound method DatetimeTimedelt ... e='datetime64[ns]', freq='C')>",
                "self.dtype": "dtype('<M8[ns]')"
            },
            {
                "left": "DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='C')",
                "right": "DatetimeIndex(['2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20'],\n              dtype='datetime64[ns]', freq='C')",
                "end": "Timestamp('2011-12-20 00:00:00', freq='C')",
                "start": "Timestamp('2011-12-12 00:00:00', freq='C')",
                "lslice": "slice(8, 15, None)",
                "left.slice_locs": "<bound method Index.slice_locs of DatetimeIndex(['2011-11-30', '2011-12-01', '2011-12-02', '2011-12-05',\n               '2011-12-06', '2011-12-07', '2011-12-08', '2011-12-09',\n               '2011-12-12', '2011-12-13', '2011-12-14', '2011-12-15',\n               '2011-12-16', '2011-12-19', '2011-12-20', '2011-12-21',\n               '2011-12-22', '2011-12-23', '2011-12-26', '2011-12-27',\n               '2011-12-28', '2011-12-29', '2011-12-30'],\n              dtype='datetime64[ns]', freq='C')>",
                "left_chunk": "<DatetimeArray>\n['2011-12-12 00:00:00', '2011-12-13 00:00:00', '2011-12-14 00:00:00',\n '2011-12-15 00:00:00', '2011-12-16 00:00:00', '2011-12-19 00:00:00',\n '2011-12-20 00:00:00']\nLength: 7, dtype: datetime64[ns]",
                "left._values": "array of shape (23,)"
            }
        ]
    ],
    "2.1.6": [
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left._values": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left._values": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left._values": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left._values": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left._values": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left._values": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left._values": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left._values": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left._values": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left._values": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left._values": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left._values": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left._values": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left._values": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left._values": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left._values": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left._values": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left._values": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left._values": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left._values": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "Minute",
                "self.freq": "Minute",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "result": "DatetimeIndex",
                "result._set_freq": "method",
                "result._data": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {}
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left._values": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "DatetimeTZDtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "left.slice_locs": "method",
                "left._values": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "BusinessDay",
                "self.freq": "BusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "dtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "lslice": "slice",
                "left.slice_locs": "method",
                "left_chunk": "DatetimeArray",
                "left._values": "DatetimeArray"
            }
        ],
        [
            {
                "self._validate_sort_keyword": "method",
                "self": "DatetimeIndex",
                "sort": "bool",
                "self._assert_can_do_setop": "method",
                "other": "DatetimeIndex",
                "self.equals": "method",
                "self._get_reconciled_name_object": "method",
                "self.copy": "method",
                "other.copy": "method",
                "other.freq": "CustomBusinessDay",
                "self.freq": "CustomBusinessDay",
                "self.is_monotonic": "bool",
                "other.is_monotonic": "bool",
                "self._shallow_copy": "method",
                "self.dtype": "dtype"
            },
            {
                "left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "end": "Timestamp",
                "start": "Timestamp",
                "lslice": "slice",
                "left.slice_locs": "method",
                "left_chunk": "DatetimeArray",
                "left._values": "DatetimeArray"
            }
        ]
    ],
    "3.1.1": null,
    "3.1.2": null
}