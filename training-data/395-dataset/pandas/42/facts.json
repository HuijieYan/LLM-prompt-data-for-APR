{
    "1.1.1": "def assert_series_equal(\n    left,\n    right,\n    check_dtype=True,\n    check_index_type=\"equiv\",\n    check_series_type=True,\n    check_less_precise=False,\n    check_names=True,\n    check_exact=False,\n    check_datetimelike_compat=False,\n    check_categorical=True,\n    check_category_order=True,\n    obj=\"Series\",\n):\n    \n    __tracebackhide__ = True\n\n    # instance validation\n    _check_isinstance(left, right, Series)\n\n    if check_series_type:\n        assert_class_equal(left, right, obj=obj)\n\n    # length comparison\n    if len(left) != len(right):\n        msg1 = f\"{len(left)}, {left.index}\"\n        msg2 = f\"{len(right)}, {right.index}\"\n        raise_assert_detail(obj, \"Series length are different\", msg1, msg2)\n\n    # index comparison\n    assert_index_equal(\n        left.index,\n        right.index,\n        exact=check_index_type,\n        check_names=check_names,\n        check_less_precise=check_less_precise,\n        check_exact=check_exact,\n        check_categorical=check_categorical,\n        obj=f\"{obj}.index\",\n    )\n\n    if check_dtype:\n        # We want to skip exact dtype checking when `check_categorical`\n        # is False. We'll still raise if only one is a `Categorical`,\n        # regardless of `check_categorical`\n        if (\n            is_categorical_dtype(left.dtype)\n            and is_categorical_dtype(right.dtype)\n            and not check_categorical\n        ):\n            pass\n        else:\n            assert_attr_equal(\"dtype\", left, right, obj=f\"Attributes of {obj}\")\n\n    if check_exact:\n        if not is_numeric_dtype(left.dtype):\n            raise AssertionError(\"check_exact may only be used with numeric Series\")\n\n        assert_numpy_array_equal(\n            left._values, right._values, check_dtype=check_dtype, obj=str(obj)\n        )\n    elif check_datetimelike_compat and (\n        needs_i8_conversion(left.dtype) or needs_i8_conversion(right.dtype)\n    ):\n        # we want to check only if we have compat dtypes\n        # e.g. integer and M|m are NOT compat, but we can simply check\n        # the values in that case\n\n        # datetimelike may have different objects (e.g. datetime.datetime\n        # vs Timestamp) but will compare equal\n        if not Index(left._values).equals(Index(right._values)):\n            msg = (\n                f\"[datetimelike_compat=True] {left._values} \"\n                f\"is not equal to {right._values}.\"\n            )\n            raise AssertionError(msg)\n    elif is_interval_dtype(left.dtype) or is_interval_dtype(right.dtype):\n        assert_interval_array_equal(left.array, right.array)\n    elif is_categorical_dtype(left.dtype) or is_categorical_dtype(right.dtype):\n        _testing.assert_almost_equal(\n            left._values,\n            right._values,\n            check_less_precise=check_less_precise,\n            check_dtype=check_dtype,\n            obj=str(obj),\n        )\n    elif is_extension_array_dtype(left.dtype) or is_extension_array_dtype(right.dtype):\n        assert_extension_array_equal(left._values, right._values)\n    elif needs_i8_conversion(left.dtype) or needs_i8_conversion(right.dtype):\n        # DatetimeArray or TimedeltaArray\n        assert_extension_array_equal(left._values, right._values)\n    else:\n        _testing.assert_almost_equal(\n            left._values,\n            right._values,\n            check_less_precise=check_less_precise,\n            check_dtype=check_dtype,\n            obj=str(obj),\n        )\n\n    # metadata comparison\n    if check_names:\n        assert_attr_equal(\"name\", left, right, obj=obj)\n\n    if check_categorical:\n        if is_categorical_dtype(left) or is_categorical_dtype(right):\n            assert_categorical_equal(\n                left._values,\n                right._values,\n                obj=f\"{obj} category\",\n                check_category_order=check_category_order,\n            )\n",
    "1.1.2": "Check that left and right Series are equal.\n\nParameters\n----------\nleft : Series\nright : Series\ncheck_dtype : bool, default True\n    Whether to check the Series dtype is identical.\ncheck_index_type : bool or {'equiv'}, default 'equiv'\n    Whether to check the Index class, dtype and inferred_type\n    are identical.\ncheck_series_type : bool, default True\n     Whether to check the Series class is identical.\ncheck_less_precise : bool or int, default False\n    Specify comparison precision. Only used when check_exact is False.\n    5 digits (False) or 3 digits (True) after decimal points are compared.\n    If int, then specify the digits to compare.\n\n    When comparing two numbers, if the first number has magnitude less\n    than 1e-5, we compare the two numbers directly and check whether\n    they are equivalent within the specified precision. Otherwise, we\n    compare the **ratio** of the second number to the first number and\n    check whether it is equivalent to 1 within the specified precision.\ncheck_names : bool, default True\n    Whether to check the Series and Index names attribute.\ncheck_exact : bool, default False\n    Whether to compare number exactly.\ncheck_datetimelike_compat : bool, default False\n    Compare datetime-like which is comparable ignoring dtype.\ncheck_categorical : bool, default True\n    Whether to compare internal Categorical exactly.\ncheck_category_order : bool, default True\n    Whether to compare category order of internal Categoricals.\n\n    .. versionadded:: 1.0.2\nobj : str, default 'Series'\n    Specify object name being compared, internally used to show appropriate\n    assertion message.",
    "1.2.1": null,
    "1.2.2": null,
    "1.2.3": null,
    "1.2.4": null,
    "1.2.5": null,
    "1.3.1": "pandas/_testing.py",
    "1.3.2": [
        "assert_almost_equal(left, right, check_dtype: Union[bool, str]='equiv', check_less_precise: Union[bool, int]=False, **kwargs)",
        "_check_isinstance(left, right, cls)",
        "assert_index_equal(left: Index, right: Index, exact: Union[bool, str]='equiv', check_names: bool=True, check_less_precise: Union[bool, int]=False, check_exact: bool=True, check_categorical: bool=True, obj: str='Index') -> None",
        "assert_class_equal(left, right, exact: Union[bool, str]=True, obj='Input')",
        "assert_attr_equal(attr: str, left, right, obj: str='Attributes')",
        "assert_categorical_equal(left, right, check_dtype=True, check_category_order=True, obj='Categorical')",
        "assert_interval_array_equal(left, right, exact='equiv', obj='IntervalArray')",
        "raise_assert_detail(obj, message, left, right, diff=None)",
        "assert_numpy_array_equal(left, right, strict_nan=False, check_dtype=True, err_msg=None, check_same=None, obj='numpy array')",
        "assert_extension_array_equal(left, right, check_dtype=True, check_less_precise=False, check_exact=False)"
    ],
    "1.4.1": [
        "def test_assert_frame_equal_extension_dtype_mismatch():\n    # https://github.com/pandas-dev/pandas/issues/32747\n    left = DataFrame({\"a\": [1, 2, 3]}, dtype=\"Int64\")\n    right = left.astype(int)\n\n    msg = (\n        \"Attributes of DataFrame\\\\.iloc\\\\[:, 0\\\\] \"\n        '\\\\(column name=\"a\"\\\\) are different\\n\\n'\n        'Attribute \"dtype\" are different\\n'\n        \"\\\\[left\\\\]:  Int64\\n\"\n        \"\\\\[right\\\\]: int[32|64]\"\n    )\n\n    tm.assert_frame_equal(left, right, check_dtype=False)\n\n    with pytest.raises(AssertionError, match=msg):\n        tm.assert_frame_equal(left, right, check_dtype=True)",
        "def test_assert_frame_equal_interval_dtype_mismatch():\n    # https://github.com/pandas-dev/pandas/issues/32747\n    left = DataFrame({\"a\": [pd.Interval(0, 1)]}, dtype=\"interval\")\n    right = left.astype(object)\n\n    msg = (\n        \"Attributes of DataFrame\\\\.iloc\\\\[:, 0\\\\] \"\n        '\\\\(column name=\"a\"\\\\) are different\\n\\n'\n        'Attribute \"dtype\" are different\\n'\n        \"\\\\[left\\\\]:  interval\\\\[int64\\\\]\\n\"\n        \"\\\\[right\\\\]: object\"\n    )\n\n    tm.assert_frame_equal(left, right, check_dtype=False)\n\n    with pytest.raises(AssertionError, match=msg):\n        tm.assert_frame_equal(left, right, check_dtype=True)",
        "def test_assert_series_equal_extension_dtype_mismatch():\n    # https://github.com/pandas-dev/pandas/issues/32747\n    left = Series(pd.array([1, 2, 3], dtype=\"Int64\"))\n    right = left.astype(int)\n\n    msg = \"\"\"Attributes of Series are different\n\nAttribute \"dtype\" are different\n\\\\[left\\\\]:  Int64\n\\\\[right\\\\]: int[32|64]\"\"\"\n\n    tm.assert_series_equal(left, right, check_dtype=False)\n\n    with pytest.raises(AssertionError, match=msg):\n        tm.assert_series_equal(left, right, check_dtype=True)",
        "def test_assert_series_equal_interval_dtype_mismatch():\n    # https://github.com/pandas-dev/pandas/issues/32747\n    left = Series([pd.Interval(0, 1)], dtype=\"interval\")\n    right = left.astype(object)\n\n    msg = \"\"\"Attributes of Series are different\n\nAttribute \"dtype\" are different\n\\\\[left\\\\]:  interval\\\\[int64\\\\]\n\\\\[right\\\\]: object\"\"\"\n\n    tm.assert_series_equal(left, right, check_dtype=False)\n\n    with pytest.raises(AssertionError, match=msg):\n        tm.assert_series_equal(left, right, check_dtype=True)"
    ],
    "1.4.2": [
        "pandas/tests/util/test_assert_frame_equal.py",
        "pandas/tests/util/test_assert_frame_equal.py",
        "pandas/tests/util/test_assert_series_equal.py",
        "pandas/tests/util/test_assert_series_equal.py"
    ],
    "2.1.1": [
        [
            "E       AssertionError: right is not an ExtensionArray"
        ],
        [
            "E           AssertionError: IntervalArray Expected type <class 'pandas.core.arrays.interval.IntervalArray'>, found <class 'pandas.core.arrays.numpy_.PandasArray'> instead"
        ],
        [
            "E       AssertionError: right is not an ExtensionArray"
        ],
        [
            "E           AssertionError: IntervalArray Expected type <class 'pandas.core.arrays.interval.IntervalArray'>, found <class 'pandas.core.arrays.numpy_.PandasArray'> instead"
        ]
    ],
    "2.1.2": [
        [
            "def test_assert_frame_equal_extension_dtype_mismatch():\n        # https://github.com/pandas-dev/pandas/issues/32747\n        left = DataFrame({\"a\": [1, 2, 3]}, dtype=\"Int64\")\n        right = left.astype(int)\n    \n        msg = (\n            \"Attributes of DataFrame\\\\.iloc\\\\[:, 0\\\\] \"\n            '\\\\(column name=\"a\"\\\\) are different\\n\\n'\n            'Attribute \"dtype\" are different\\n'\n            \"\\\\[left\\\\]:  Int64\\n\"\n            \"\\\\[right\\\\]: int[32|64]\"\n        )\n    \n>       tm.assert_frame_equal(left, right, check_dtype=False)\n\npandas/tests/util/test_assert_frame_equal.py:237: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = <IntegerArray>\n[1, 2, 3]\nLength: 3, dtype: Int64\nright = array([1, 2, 3]), check_dtype = True, check_less_precise = False\ncheck_exact = False\n\n    def assert_extension_array_equal(\n        left, right, check_dtype=True, check_less_precise=False, check_exact=False\n    ):\n        \"\"\"\n        Check that left and right ExtensionArrays are equal.\n    \n        Parameters\n        ----------\n        left, right : ExtensionArray\n            The two arrays to compare.\n        check_dtype : bool, default True\n            Whether to check if the ExtensionArray dtypes are identical.\n        check_less_precise : bool or int, default False\n            Specify comparison precision. Only used when check_exact is False.\n            5 digits (False) or 3 digits (True) after decimal points are compared.\n            If int, then specify the digits to compare.\n        check_exact : bool, default False\n            Whether to compare number exactly.\n    \n        Notes\n        -----\n        Missing values are checked separately from valid values.\n        A mask of missing values is computed for each and checked to match.\n        The remaining all-valid values are cast to object dtype and checked.\n        \"\"\"\n        assert isinstance(left, ExtensionArray), \"left is not an ExtensionArray\"\n>       assert isinstance(right, ExtensionArray), \"right is not an ExtensionArray\"",
            "\npandas/_testing.py:1019: AssertionError"
        ],
        [
            "def test_assert_frame_equal_interval_dtype_mismatch():\n        # https://github.com/pandas-dev/pandas/issues/32747\n        left = DataFrame({\"a\": [pd.Interval(0, 1)]}, dtype=\"interval\")\n        right = left.astype(object)\n    \n        msg = (\n            \"Attributes of DataFrame\\\\.iloc\\\\[:, 0\\\\] \"\n            '\\\\(column name=\"a\"\\\\) are different\\n\\n'\n            'Attribute \"dtype\" are different\\n'\n            \"\\\\[left\\\\]:  interval\\\\[int64\\\\]\\n\"\n            \"\\\\[right\\\\]: object\"\n        )\n    \n>       tm.assert_frame_equal(left, right, check_dtype=False)\n\npandas/tests/util/test_assert_frame_equal.py:256: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/_testing.py:861: in assert_interval_array_equal\n    _check_isinstance(left, right, IntervalArray)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = <IntervalArray>\n[(0, 1]]\nLength: 1, closed: right, dtype: interval[int64]\nright = <PandasArray>\n[Interval(0, 1, closed='right')]\nLength: 1, dtype: object\ncls = <class 'pandas.core.arrays.interval.IntervalArray'>\n\n    def _check_isinstance(left, right, cls):\n        \"\"\"\n        Helper method for our assert_* methods that ensures that\n        the two objects being compared have the right type before\n        proceeding with the comparison.\n    \n        Parameters\n        ----------\n        left : The first object being compared.\n        right : The second object being compared.\n        cls : The class type to check against.\n    \n        Raises\n        ------\n        AssertionError : Either `left` or `right` is not an instance of `cls`.\n        \"\"\"\n        cls_name = cls.__name__\n    \n        if not isinstance(left, cls):\n            raise AssertionError(\n                f\"{cls_name} Expected type {cls}, found {type(left)} instead\"\n            )\n        if not isinstance(right, cls):\n>           raise AssertionError(\n                f\"{cls_name} Expected type {cls}, found {type(right)} instead\"\n            )",
            "\npandas/_testing.py:389: AssertionError"
        ],
        [
            "def test_assert_series_equal_extension_dtype_mismatch():\n        # https://github.com/pandas-dev/pandas/issues/32747\n        left = Series(pd.array([1, 2, 3], dtype=\"Int64\"))\n        right = left.astype(int)\n    \n        msg = \"\"\"Attributes of Series are different\n    \n    Attribute \"dtype\" are different\n    \\\\[left\\\\]:  Int64\n    \\\\[right\\\\]: int[32|64]\"\"\"\n    \n>       tm.assert_series_equal(left, right, check_dtype=False)\n\npandas/tests/util/test_assert_series_equal.py:211: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = <IntegerArray>\n[1, 2, 3]\nLength: 3, dtype: Int64\nright = array([1, 2, 3]), check_dtype = True, check_less_precise = False\ncheck_exact = False\n\n    def assert_extension_array_equal(\n        left, right, check_dtype=True, check_less_precise=False, check_exact=False\n    ):\n        \"\"\"\n        Check that left and right ExtensionArrays are equal.\n    \n        Parameters\n        ----------\n        left, right : ExtensionArray\n            The two arrays to compare.\n        check_dtype : bool, default True\n            Whether to check if the ExtensionArray dtypes are identical.\n        check_less_precise : bool or int, default False\n            Specify comparison precision. Only used when check_exact is False.\n            5 digits (False) or 3 digits (True) after decimal points are compared.\n            If int, then specify the digits to compare.\n        check_exact : bool, default False\n            Whether to compare number exactly.\n    \n        Notes\n        -----\n        Missing values are checked separately from valid values.\n        A mask of missing values is computed for each and checked to match.\n        The remaining all-valid values are cast to object dtype and checked.\n        \"\"\"\n        assert isinstance(left, ExtensionArray), \"left is not an ExtensionArray\"\n>       assert isinstance(right, ExtensionArray), \"right is not an ExtensionArray\"",
            "\npandas/_testing.py:1019: AssertionError"
        ],
        [
            "def test_assert_series_equal_interval_dtype_mismatch():\n        # https://github.com/pandas-dev/pandas/issues/32747\n        left = Series([pd.Interval(0, 1)], dtype=\"interval\")\n        right = left.astype(object)\n    \n        msg = \"\"\"Attributes of Series are different\n    \n    Attribute \"dtype\" are different\n    \\\\[left\\\\]:  interval\\\\[int64\\\\]\n    \\\\[right\\\\]: object\"\"\"\n    \n>       tm.assert_series_equal(left, right, check_dtype=False)\n\npandas/tests/util/test_assert_series_equal.py:228: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/_testing.py:861: in assert_interval_array_equal\n    _check_isinstance(left, right, IntervalArray)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = <IntervalArray>\n[(0, 1]]\nLength: 1, closed: right, dtype: interval[int64]\nright = <PandasArray>\n[Interval(0, 1, closed='right')]\nLength: 1, dtype: object\ncls = <class 'pandas.core.arrays.interval.IntervalArray'>\n\n    def _check_isinstance(left, right, cls):\n        \"\"\"\n        Helper method for our assert_* methods that ensures that\n        the two objects being compared have the right type before\n        proceeding with the comparison.\n    \n        Parameters\n        ----------\n        left : The first object being compared.\n        right : The second object being compared.\n        cls : The class type to check against.\n    \n        Raises\n        ------\n        AssertionError : Either `left` or `right` is not an instance of `cls`.\n        \"\"\"\n        cls_name = cls.__name__\n    \n        if not isinstance(left, cls):\n            raise AssertionError(\n                f\"{cls_name} Expected type {cls}, found {type(left)} instead\"\n            )\n        if not isinstance(right, cls):\n>           raise AssertionError(\n                f\"{cls_name} Expected type {cls}, found {type(right)} instead\"\n            )",
            "\npandas/_testing.py:389: AssertionError"
        ]
    ],
    "2.1.3": null,
    "2.1.4": null,
    "2.1.5": [
        [
            {
                "left": "0    1\n1    2\n2    3\nName: a, dtype: Int64",
                "right": "0    1\n1    2\n2    3\nName: a, dtype: int64",
                "check_series_type": "True",
                "obj": "'DataFrame.iloc[:, 0] (column name=\"a\")'",
                "left.index": "RangeIndex(start=0, stop=3, step=1)",
                "right.index": "RangeIndex(start=0, stop=3, step=1)",
                "check_index_type": "'equiv'",
                "check_names": "True",
                "check_less_precise": "False",
                "check_exact": "False",
                "check_categorical": "True",
                "check_dtype": "False",
                "left.dtype": "Int64Dtype()",
                "right.dtype": "dtype('int64')",
                "left._values": "<IntegerArray>\n[1, 2, 3]\nLength: 3, dtype: Int64",
                "right._values": "array([1, 2, 3])",
                "check_datetimelike_compat": "False",
                "left.array": "<IntegerArray>\n[1, 2, 3]\nLength: 3, dtype: Int64",
                "right.array": "<PandasArray>\n[1, 2, 3]\nLength: 3, dtype: int64",
                "check_category_order": "True"
            },
            {
                "__tracebackhide__": "True"
            }
        ],
        [
            {
                "left": "0    (0, 1]\nName: a, dtype: interval",
                "right": "0    (0, 1]\nName: a, dtype: object",
                "check_series_type": "True",
                "obj": "'DataFrame.iloc[:, 0] (column name=\"a\")'",
                "left.index": "RangeIndex(start=0, stop=1, step=1)",
                "right.index": "RangeIndex(start=0, stop=1, step=1)",
                "check_index_type": "'equiv'",
                "check_names": "True",
                "check_less_precise": "False",
                "check_exact": "False",
                "check_categorical": "True",
                "check_dtype": "False",
                "left.dtype": "interval[int64]",
                "right.dtype": "dtype('O')",
                "left._values": "<IntervalArray>\n[(0, 1]]\nLength: 1, closed: right, dtype: interval[int64]",
                "right._values": "array([Interval(0, 1, closed='right')], dtype=object)",
                "check_datetimelike_compat": "False",
                "left.array": "<IntervalArray>\n[(0, 1]]\nLength: 1, closed: right, dtype: interval[int64]",
                "right.array": "<PandasArray>\n[Interval(0, 1, closed='right')]\nLength: 1, dtype: object",
                "check_category_order": "True"
            },
            {
                "__tracebackhide__": "True"
            }
        ],
        [
            {
                "left": "0    1\n1    2\n2    3\ndtype: Int64",
                "right": "0    1\n1    2\n2    3\ndtype: int64",
                "check_series_type": "True",
                "obj": "'Series'",
                "left.index": "RangeIndex(start=0, stop=3, step=1)",
                "right.index": "RangeIndex(start=0, stop=3, step=1)",
                "check_index_type": "'equiv'",
                "check_names": "True",
                "check_less_precise": "False",
                "check_exact": "False",
                "check_categorical": "True",
                "check_dtype": "False",
                "left.dtype": "Int64Dtype()",
                "right.dtype": "dtype('int64')",
                "left._values": "<IntegerArray>\n[1, 2, 3]\nLength: 3, dtype: Int64",
                "right._values": "array([1, 2, 3])",
                "check_datetimelike_compat": "False",
                "left.array": "<IntegerArray>\n[1, 2, 3]\nLength: 3, dtype: Int64",
                "right.array": "<PandasArray>\n[1, 2, 3]\nLength: 3, dtype: int64",
                "check_category_order": "True"
            },
            {
                "__tracebackhide__": "True"
            }
        ],
        [
            {
                "left": "0    (0, 1]\ndtype: interval",
                "right": "0    (0, 1]\ndtype: object",
                "check_series_type": "True",
                "obj": "'Series'",
                "left.index": "RangeIndex(start=0, stop=1, step=1)",
                "right.index": "RangeIndex(start=0, stop=1, step=1)",
                "check_index_type": "'equiv'",
                "check_names": "True",
                "check_less_precise": "False",
                "check_exact": "False",
                "check_categorical": "True",
                "check_dtype": "False",
                "left.dtype": "interval[int64]",
                "right.dtype": "dtype('O')",
                "left._values": "<IntervalArray>\n[(0, 1]]\nLength: 1, closed: right, dtype: interval[int64]",
                "right._values": "array([Interval(0, 1, closed='right')], dtype=object)",
                "check_datetimelike_compat": "False",
                "left.array": "<IntervalArray>\n[(0, 1]]\nLength: 1, closed: right, dtype: interval[int64]",
                "right.array": "<PandasArray>\n[Interval(0, 1, closed='right')]\nLength: 1, dtype: object",
                "check_category_order": "True"
            },
            {
                "__tracebackhide__": "True"
            }
        ]
    ],
    "2.1.6": [
        [
            {
                "left": "Series",
                "right": "Series",
                "check_series_type": "bool",
                "obj": "str",
                "left.index": "RangeIndex",
                "right.index": "RangeIndex",
                "check_index_type": "str",
                "check_names": "bool",
                "check_less_precise": "bool",
                "check_exact": "bool",
                "check_categorical": "bool",
                "check_dtype": "bool",
                "left.dtype": "Int64Dtype",
                "right.dtype": "dtype",
                "left._values": "IntegerArray",
                "right._values": "ndarray",
                "check_datetimelike_compat": "bool",
                "left.array": "IntegerArray",
                "right.array": "PandasArray",
                "check_category_order": "bool"
            },
            {
                "__tracebackhide__": "bool"
            }
        ],
        [
            {
                "left": "Series",
                "right": "Series",
                "check_series_type": "bool",
                "obj": "str",
                "left.index": "RangeIndex",
                "right.index": "RangeIndex",
                "check_index_type": "str",
                "check_names": "bool",
                "check_less_precise": "bool",
                "check_exact": "bool",
                "check_categorical": "bool",
                "check_dtype": "bool",
                "left.dtype": "IntervalDtype",
                "right.dtype": "dtype",
                "left._values": "IntervalArray",
                "right._values": "ndarray",
                "check_datetimelike_compat": "bool",
                "left.array": "IntervalArray",
                "right.array": "PandasArray",
                "check_category_order": "bool"
            },
            {
                "__tracebackhide__": "bool"
            }
        ],
        [
            {
                "left": "Series",
                "right": "Series",
                "check_series_type": "bool",
                "obj": "str",
                "left.index": "RangeIndex",
                "right.index": "RangeIndex",
                "check_index_type": "str",
                "check_names": "bool",
                "check_less_precise": "bool",
                "check_exact": "bool",
                "check_categorical": "bool",
                "check_dtype": "bool",
                "left.dtype": "Int64Dtype",
                "right.dtype": "dtype",
                "left._values": "IntegerArray",
                "right._values": "ndarray",
                "check_datetimelike_compat": "bool",
                "left.array": "IntegerArray",
                "right.array": "PandasArray",
                "check_category_order": "bool"
            },
            {
                "__tracebackhide__": "bool"
            }
        ],
        [
            {
                "left": "Series",
                "right": "Series",
                "check_series_type": "bool",
                "obj": "str",
                "left.index": "RangeIndex",
                "right.index": "RangeIndex",
                "check_index_type": "str",
                "check_names": "bool",
                "check_less_precise": "bool",
                "check_exact": "bool",
                "check_categorical": "bool",
                "check_dtype": "bool",
                "left.dtype": "IntervalDtype",
                "right.dtype": "dtype",
                "left._values": "IntervalArray",
                "right._values": "ndarray",
                "check_datetimelike_compat": "bool",
                "left.array": "IntervalArray",
                "right.array": "PandasArray",
                "check_category_order": "bool"
            },
            {
                "__tracebackhide__": "bool"
            }
        ]
    ],
    "3.1.1": [
        "BUG: Regression in assert_frame_equal check_dtype for extension dtypes\n"
    ],
    "3.1.2": [
        "Consider this small example of two DataFrames, one with an Int64 extension dtype, the other with the same values but object dtype:\n\ndf1 = pd.DataFrame({'a': pd.array([1, 2, 3], dtype=\"Int64\")}) \ndf2 = df1.astype(object)   \nWith pandas 1.0.1, this passes assert_frame_equal with the check_dtype=False:\n\nIn [5]: pd.testing.assert_frame_equal(df1, df2)  \n...\nAttribute \"dtype\" are different\n[left]:  Int64\n[right]: object\n\nIn [6]: pd.testing.assert_frame_equal(df1, df2, check_dtype=False)  \nbut with master (since #32570, see my comment there, cc @jbrockmendel), this fails:\n\nIn [2]: pd.testing.assert_frame_equal(df1, df2, check_dtype=False)   \n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\n<ipython-input-2-d2d792202db1> in <module>\n----> 1 pd.testing.assert_frame_equal(df1, df2, check_dtype=False)\n\n~/scipy/pandas/pandas/_testing.py in assert_frame_equal(left, right, check_dtype, check_index_type, check_column_type, check_frame_type, check_less_precise, check_names, by_blocks, check_exact, check_datetimelike_compat, check_categorical, check_like, obj)\n   1378                 check_datetimelike_compat=check_datetimelike_compat,\n   1379                 check_categorical=check_categorical,\n-> 1380                 obj=f'{obj}.iloc[:, {i}] (column name=\"{col}\")',\n   1381             )\n   1382 \n\n~/scipy/pandas/pandas/_testing.py in assert_series_equal(left, right, check_dtype, check_index_type, check_series_type, check_less_precise, check_names, check_exact, check_datetimelike_compat, check_categorical, check_category_order, obj)\n   1177         )\n   1178     elif is_extension_array_dtype(left.dtype) or is_extension_array_dtype(right.dtype):\n-> 1179         assert_extension_array_equal(left._values, right._values)\n   1180     elif needs_i8_conversion(left.dtype) or needs_i8_conversion(right.dtype):\n   1181         # DatetimeArray or TimedeltaArray\n\n~/scipy/pandas/pandas/_testing.py in assert_extension_array_equal(left, right, check_dtype, check_less_precise, check_exact)\n   1017     \"\"\"\n   1018     assert isinstance(left, ExtensionArray), \"left is not an ExtensionArray\"\n-> 1019     assert isinstance(right, ExtensionArray), \"right is not an ExtensionArray\"\n   1020     if check_dtype:\n   1021         assert_attr_equal(\"dtype\", left, right, obj=\"ExtensionArray\")\n\nAssertionError: right is not an ExtensionArray\n"
    ]
}