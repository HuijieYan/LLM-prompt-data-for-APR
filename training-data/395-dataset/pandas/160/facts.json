{
    "1.1.1": "def _can_use_numexpr(op, op_str, a, b, dtype_check):\n    \n    if op_str is not None:\n\n        # required min elements (otherwise we are adding overhead)\n        if np.prod(a.shape) > _MIN_ELEMENTS:\n\n            # check for dtype compatibility\n            dtypes = set()\n            for o in [a, b]:\n                if hasattr(o, \"dtypes\"):\n                    s = o.dtypes.value_counts()\n                    if len(s) > 1:\n                        return False\n                    dtypes |= set(s.index.astype(str))\n                elif isinstance(o, np.ndarray):\n                    dtypes |= {o.dtype.name}\n\n            # allowed are a superset\n            if not len(dtypes) or _ALLOWED_DTYPES[dtype_check] >= dtypes:\n                return True\n\n    return False\n",
    "1.1.2": "return a boolean if we WILL be using numexpr ",
    "1.2.1": null,
    "1.2.2": null,
    "1.2.3": null,
    "1.2.4": null,
    "1.2.5": null,
    "1.3.1": "pandas/core/computation/expressions.py",
    "1.3.2": null,
    "1.4.1": [
        "    @pytest.mark.parametrize(\n        \"arith\", (\"add\", \"sub\", \"mul\", \"mod\", \"truediv\", \"floordiv\")\n    )\n    @pytest.mark.parametrize(\"axis\", (0, 1))\n    def test_frame_series_axis(self, axis, arith):\n        # GH#26736 Dataframe.floordiv(Series, axis=1) fails\n        if axis == 1 and arith == \"floordiv\":\n            pytest.xfail(\"'floordiv' does not succeed with axis=1 #27636\")\n\n        df = self.frame\n        if axis == 1:\n            other = self.frame.iloc[0, :]\n        else:\n            other = self.frame.iloc[:, 0]\n\n        expr._MIN_ELEMENTS = 0\n\n        op_func = getattr(df, arith)\n\n        expr.set_use_numexpr(False)\n        expected = op_func(other, axis=axis)\n        expr.set_use_numexpr(True)\n\n        result = op_func(other, axis=axis)\n        assert_frame_equal(expected, result)",
        "    @pytest.mark.parametrize(\n        \"arith\", (\"add\", \"sub\", \"mul\", \"mod\", \"truediv\", \"floordiv\")\n    )\n    @pytest.mark.parametrize(\"axis\", (0, 1))\n    def test_frame_series_axis(self, axis, arith):\n        # GH#26736 Dataframe.floordiv(Series, axis=1) fails\n        if axis == 1 and arith == \"floordiv\":\n            pytest.xfail(\"'floordiv' does not succeed with axis=1 #27636\")\n\n        df = self.frame\n        if axis == 1:\n            other = self.frame.iloc[0, :]\n        else:\n            other = self.frame.iloc[:, 0]\n\n        expr._MIN_ELEMENTS = 0\n\n        op_func = getattr(df, arith)\n\n        expr.set_use_numexpr(False)\n        expected = op_func(other, axis=axis)\n        expr.set_use_numexpr(True)\n\n        result = op_func(other, axis=axis)\n        assert_frame_equal(expected, result)",
        "    @pytest.mark.parametrize(\n        \"arith\", (\"add\", \"sub\", \"mul\", \"mod\", \"truediv\", \"floordiv\")\n    )\n    @pytest.mark.parametrize(\"axis\", (0, 1))\n    def test_frame_series_axis(self, axis, arith):\n        # GH#26736 Dataframe.floordiv(Series, axis=1) fails\n        if axis == 1 and arith == \"floordiv\":\n            pytest.xfail(\"'floordiv' does not succeed with axis=1 #27636\")\n\n        df = self.frame\n        if axis == 1:\n            other = self.frame.iloc[0, :]\n        else:\n            other = self.frame.iloc[:, 0]\n\n        expr._MIN_ELEMENTS = 0\n\n        op_func = getattr(df, arith)\n\n        expr.set_use_numexpr(False)\n        expected = op_func(other, axis=axis)\n        expr.set_use_numexpr(True)\n\n        result = op_func(other, axis=axis)\n        assert_frame_equal(expected, result)",
        "    @pytest.mark.parametrize(\n        \"arith\", (\"add\", \"sub\", \"mul\", \"mod\", \"truediv\", \"floordiv\")\n    )\n    @pytest.mark.parametrize(\"axis\", (0, 1))\n    def test_frame_series_axis(self, axis, arith):\n        # GH#26736 Dataframe.floordiv(Series, axis=1) fails\n        if axis == 1 and arith == \"floordiv\":\n            pytest.xfail(\"'floordiv' does not succeed with axis=1 #27636\")\n\n        df = self.frame\n        if axis == 1:\n            other = self.frame.iloc[0, :]\n        else:\n            other = self.frame.iloc[:, 0]\n\n        expr._MIN_ELEMENTS = 0\n\n        op_func = getattr(df, arith)\n\n        expr.set_use_numexpr(False)\n        expected = op_func(other, axis=axis)\n        expr.set_use_numexpr(True)\n\n        result = op_func(other, axis=axis)\n        assert_frame_equal(expected, result)"
    ],
    "1.4.2": [
        "pandas/tests/test_expressions.py",
        "pandas/tests/test_expressions.py",
        "pandas/tests/test_expressions.py",
        "pandas/tests/test_expressions.py"
    ],
    "2.1.1": [
        [
            "E                       AttributeError: 'numpy.dtype' object has no attribute 'value_counts'"
        ],
        [
            "E                       AttributeError: 'numpy.dtype' object has no attribute 'value_counts'"
        ],
        [
            "E                       AttributeError: 'numpy.dtype' object has no attribute 'value_counts'"
        ],
        [
            "E                       AttributeError: 'numpy.dtype' object has no attribute 'value_counts'"
        ]
    ],
    "2.1.2": [
        [
            "self = <pandas.tests.test_expressions.TestExpressions object at 0x11c224100>\naxis = 1, arith = 'add'\n\n    @pytest.mark.parametrize(\n        \"arith\", (\"add\", \"sub\", \"mul\", \"mod\", \"truediv\", \"floordiv\")\n    )\n    @pytest.mark.parametrize(\"axis\", (0, 1))\n    def test_frame_series_axis(self, axis, arith):\n        # GH#26736 Dataframe.floordiv(Series, axis=1) fails\n        if axis == 1 and arith == \"floordiv\":\n            pytest.xfail(\"'floordiv' does not succeed with axis=1 #27636\")\n    \n        df = self.frame\n        if axis == 1:\n            other = self.frame.iloc[0, :]\n        else:\n            other = self.frame.iloc[:, 0]\n    \n        expr._MIN_ELEMENTS = 0\n    \n        op_func = getattr(df, arith)\n    \n        expr.set_use_numexpr(False)\n        expected = op_func(other, axis=axis)\n        expr.set_use_numexpr(True)\n    \n>       result = op_func(other, axis=axis)\n\npandas/tests/test_expressions.py:457: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/ops/__init__.py:1010: in f\n    return _combine_series_frame(\npandas/core/ops/__init__.py:910: in _combine_series_frame\n    return self._combine_match_columns(other, func, level=level)\npandas/core/frame.py:5332: in _combine_match_columns\n    return ops.dispatch_to_series(left, right, func, axis=\"columns\")\npandas/core/ops/__init__.py:515: in dispatch_to_series\n    new_data = expressions.evaluate(column_op, str_rep, left, right)\npandas/core/computation/expressions.py:220: in evaluate\n    return _evaluate(op, op_str, a, b, **eval_kwargs)\npandas/core/computation/expressions.py:124: in _evaluate_numexpr\n    result = _evaluate_standard(op, op_str, a, b)\npandas/core/computation/expressions.py:70: in _evaluate_standard\n    return op(a, b)\npandas/core/ops/__init__.py:503: in column_op\n    return {i: func(a.iloc[:, i], b.iloc[i]) for i in range(len(a.columns))}\npandas/core/ops/__init__.py:503: in <dictcomp>\n    return {i: func(a.iloc[:, i], b.iloc[i]) for i in range(len(a.columns))}\npandas/core/ops/array_ops.py:121: in na_op\n    result = expressions.evaluate(op, str_rep, x, y, **eval_kwargs)\npandas/core/computation/expressions.py:220: in evaluate\n    return _evaluate(op, op_str, a, b, **eval_kwargs)\npandas/core/computation/expressions.py:101: in _evaluate_numexpr\n    if _can_use_numexpr(op, op_str, a, b, \"evaluate\"):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nop = <built-in function add>, op_str = '+'\na = 0       0.264538\n1       0.133694\n2       0.522648\n3      -1.945674\n4       0.287703\n          ...   \n9995    1.385442\n9996   -0.849164\n9997   -0.059349\n9998    0.630657\n9999   -0.437685\nName: A, Length: 10000, dtype: float64\nb = 0.26453828781627187, dtype_check = 'evaluate'\n\n    def _can_use_numexpr(op, op_str, a, b, dtype_check):\n        \"\"\" return a boolean if we WILL be using numexpr \"\"\"\n        if op_str is not None:\n    \n            # required min elements (otherwise we are adding overhead)\n            if np.prod(a.shape) > _MIN_ELEMENTS:\n    \n                # check for dtype compatibility\n                dtypes = set()\n                for o in [a, b]:\n                    if hasattr(o, \"dtypes\"):\n>                       s = o.dtypes.value_counts()",
            "\npandas/core/computation/expressions.py:84: AttributeError"
        ],
        [
            "self = <pandas.tests.test_expressions.TestExpressions object at 0x11c4fe640>\naxis = 1, arith = 'sub'\n\n    @pytest.mark.parametrize(\n        \"arith\", (\"add\", \"sub\", \"mul\", \"mod\", \"truediv\", \"floordiv\")\n    )\n    @pytest.mark.parametrize(\"axis\", (0, 1))\n    def test_frame_series_axis(self, axis, arith):\n        # GH#26736 Dataframe.floordiv(Series, axis=1) fails\n        if axis == 1 and arith == \"floordiv\":\n            pytest.xfail(\"'floordiv' does not succeed with axis=1 #27636\")\n    \n        df = self.frame\n        if axis == 1:\n            other = self.frame.iloc[0, :]\n        else:\n            other = self.frame.iloc[:, 0]\n    \n        expr._MIN_ELEMENTS = 0\n    \n        op_func = getattr(df, arith)\n    \n        expr.set_use_numexpr(False)\n        expected = op_func(other, axis=axis)\n        expr.set_use_numexpr(True)\n    \n>       result = op_func(other, axis=axis)\n\npandas/tests/test_expressions.py:457: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/ops/__init__.py:1010: in f\n    return _combine_series_frame(\npandas/core/ops/__init__.py:910: in _combine_series_frame\n    return self._combine_match_columns(other, func, level=level)\npandas/core/frame.py:5332: in _combine_match_columns\n    return ops.dispatch_to_series(left, right, func, axis=\"columns\")\npandas/core/ops/__init__.py:515: in dispatch_to_series\n    new_data = expressions.evaluate(column_op, str_rep, left, right)\npandas/core/computation/expressions.py:220: in evaluate\n    return _evaluate(op, op_str, a, b, **eval_kwargs)\npandas/core/computation/expressions.py:124: in _evaluate_numexpr\n    result = _evaluate_standard(op, op_str, a, b)\npandas/core/computation/expressions.py:70: in _evaluate_standard\n    return op(a, b)\npandas/core/ops/__init__.py:503: in column_op\n    return {i: func(a.iloc[:, i], b.iloc[i]) for i in range(len(a.columns))}\npandas/core/ops/__init__.py:503: in <dictcomp>\n    return {i: func(a.iloc[:, i], b.iloc[i]) for i in range(len(a.columns))}\npandas/core/ops/array_ops.py:121: in na_op\n    result = expressions.evaluate(op, str_rep, x, y, **eval_kwargs)\npandas/core/computation/expressions.py:220: in evaluate\n    return _evaluate(op, op_str, a, b, **eval_kwargs)\npandas/core/computation/expressions.py:101: in _evaluate_numexpr\n    if _can_use_numexpr(op, op_str, a, b, \"evaluate\"):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nop = <built-in function sub>, op_str = '-'\na = 0       0.264538\n1       0.133694\n2       0.522648\n3      -1.945674\n4       0.287703\n          ...   \n9995    1.385442\n9996   -0.849164\n9997   -0.059349\n9998    0.630657\n9999   -0.437685\nName: A, Length: 10000, dtype: float64\nb = 0.26453828781627187, dtype_check = 'evaluate'\n\n    def _can_use_numexpr(op, op_str, a, b, dtype_check):\n        \"\"\" return a boolean if we WILL be using numexpr \"\"\"\n        if op_str is not None:\n    \n            # required min elements (otherwise we are adding overhead)\n            if np.prod(a.shape) > _MIN_ELEMENTS:\n    \n                # check for dtype compatibility\n                dtypes = set()\n                for o in [a, b]:\n                    if hasattr(o, \"dtypes\"):\n>                       s = o.dtypes.value_counts()",
            "\npandas/core/computation/expressions.py:84: AttributeError"
        ],
        [
            "self = <pandas.tests.test_expressions.TestExpressions object at 0x124572bb0>\naxis = 1, arith = 'mul'\n\n    @pytest.mark.parametrize(\n        \"arith\", (\"add\", \"sub\", \"mul\", \"mod\", \"truediv\", \"floordiv\")\n    )\n    @pytest.mark.parametrize(\"axis\", (0, 1))\n    def test_frame_series_axis(self, axis, arith):\n        # GH#26736 Dataframe.floordiv(Series, axis=1) fails\n        if axis == 1 and arith == \"floordiv\":\n            pytest.xfail(\"'floordiv' does not succeed with axis=1 #27636\")\n    \n        df = self.frame\n        if axis == 1:\n            other = self.frame.iloc[0, :]\n        else:\n            other = self.frame.iloc[:, 0]\n    \n        expr._MIN_ELEMENTS = 0\n    \n        op_func = getattr(df, arith)\n    \n        expr.set_use_numexpr(False)\n        expected = op_func(other, axis=axis)\n        expr.set_use_numexpr(True)\n    \n>       result = op_func(other, axis=axis)\n\npandas/tests/test_expressions.py:457: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/ops/__init__.py:1010: in f\n    return _combine_series_frame(\npandas/core/ops/__init__.py:910: in _combine_series_frame\n    return self._combine_match_columns(other, func, level=level)\npandas/core/frame.py:5332: in _combine_match_columns\n    return ops.dispatch_to_series(left, right, func, axis=\"columns\")\npandas/core/ops/__init__.py:515: in dispatch_to_series\n    new_data = expressions.evaluate(column_op, str_rep, left, right)\npandas/core/computation/expressions.py:220: in evaluate\n    return _evaluate(op, op_str, a, b, **eval_kwargs)\npandas/core/computation/expressions.py:124: in _evaluate_numexpr\n    result = _evaluate_standard(op, op_str, a, b)\npandas/core/computation/expressions.py:70: in _evaluate_standard\n    return op(a, b)\npandas/core/ops/__init__.py:503: in column_op\n    return {i: func(a.iloc[:, i], b.iloc[i]) for i in range(len(a.columns))}\npandas/core/ops/__init__.py:503: in <dictcomp>\n    return {i: func(a.iloc[:, i], b.iloc[i]) for i in range(len(a.columns))}\npandas/core/ops/array_ops.py:121: in na_op\n    result = expressions.evaluate(op, str_rep, x, y, **eval_kwargs)\npandas/core/computation/expressions.py:220: in evaluate\n    return _evaluate(op, op_str, a, b, **eval_kwargs)\npandas/core/computation/expressions.py:101: in _evaluate_numexpr\n    if _can_use_numexpr(op, op_str, a, b, \"evaluate\"):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nop = <built-in function mul>, op_str = '*'\na = 0       0.264538\n1       0.133694\n2       0.522648\n3      -1.945674\n4       0.287703\n          ...   \n9995    1.385442\n9996   -0.849164\n9997   -0.059349\n9998    0.630657\n9999   -0.437685\nName: A, Length: 10000, dtype: float64\nb = 0.26453828781627187, dtype_check = 'evaluate'\n\n    def _can_use_numexpr(op, op_str, a, b, dtype_check):\n        \"\"\" return a boolean if we WILL be using numexpr \"\"\"\n        if op_str is not None:\n    \n            # required min elements (otherwise we are adding overhead)\n            if np.prod(a.shape) > _MIN_ELEMENTS:\n    \n                # check for dtype compatibility\n                dtypes = set()\n                for o in [a, b]:\n                    if hasattr(o, \"dtypes\"):\n>                       s = o.dtypes.value_counts()",
            "\npandas/core/computation/expressions.py:84: AttributeError"
        ],
        [
            "self = <pandas.tests.test_expressions.TestExpressions object at 0x11c285250>\naxis = 1, arith = 'truediv'\n\n    @pytest.mark.parametrize(\n        \"arith\", (\"add\", \"sub\", \"mul\", \"mod\", \"truediv\", \"floordiv\")\n    )\n    @pytest.mark.parametrize(\"axis\", (0, 1))\n    def test_frame_series_axis(self, axis, arith):\n        # GH#26736 Dataframe.floordiv(Series, axis=1) fails\n        if axis == 1 and arith == \"floordiv\":\n            pytest.xfail(\"'floordiv' does not succeed with axis=1 #27636\")\n    \n        df = self.frame\n        if axis == 1:\n            other = self.frame.iloc[0, :]\n        else:\n            other = self.frame.iloc[:, 0]\n    \n        expr._MIN_ELEMENTS = 0\n    \n        op_func = getattr(df, arith)\n    \n        expr.set_use_numexpr(False)\n        expected = op_func(other, axis=axis)\n        expr.set_use_numexpr(True)\n    \n>       result = op_func(other, axis=axis)\n\npandas/tests/test_expressions.py:457: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/ops/__init__.py:1010: in f\n    return _combine_series_frame(\npandas/core/ops/__init__.py:910: in _combine_series_frame\n    return self._combine_match_columns(other, func, level=level)\npandas/core/frame.py:5332: in _combine_match_columns\n    return ops.dispatch_to_series(left, right, func, axis=\"columns\")\npandas/core/ops/__init__.py:515: in dispatch_to_series\n    new_data = expressions.evaluate(column_op, str_rep, left, right)\npandas/core/computation/expressions.py:220: in evaluate\n    return _evaluate(op, op_str, a, b, **eval_kwargs)\npandas/core/computation/expressions.py:124: in _evaluate_numexpr\n    result = _evaluate_standard(op, op_str, a, b)\npandas/core/computation/expressions.py:70: in _evaluate_standard\n    return op(a, b)\npandas/core/ops/__init__.py:503: in column_op\n    return {i: func(a.iloc[:, i], b.iloc[i]) for i in range(len(a.columns))}\npandas/core/ops/__init__.py:503: in <dictcomp>\n    return {i: func(a.iloc[:, i], b.iloc[i]) for i in range(len(a.columns))}\npandas/core/ops/array_ops.py:121: in na_op\n    result = expressions.evaluate(op, str_rep, x, y, **eval_kwargs)\npandas/core/computation/expressions.py:220: in evaluate\n    return _evaluate(op, op_str, a, b, **eval_kwargs)\npandas/core/computation/expressions.py:101: in _evaluate_numexpr\n    if _can_use_numexpr(op, op_str, a, b, \"evaluate\"):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nop = <built-in function truediv>, op_str = '/'\na = 0       0.264538\n1       0.133694\n2       0.522648\n3      -1.945674\n4       0.287703\n          ...   \n9995    1.385442\n9996   -0.849164\n9997   -0.059349\n9998    0.630657\n9999   -0.437685\nName: A, Length: 10000, dtype: float64\nb = 0.26453828781627187, dtype_check = 'evaluate'\n\n    def _can_use_numexpr(op, op_str, a, b, dtype_check):\n        \"\"\" return a boolean if we WILL be using numexpr \"\"\"\n        if op_str is not None:\n    \n            # required min elements (otherwise we are adding overhead)\n            if np.prod(a.shape) > _MIN_ELEMENTS:\n    \n                # check for dtype compatibility\n                dtypes = set()\n                for o in [a, b]:\n                    if hasattr(o, \"dtypes\"):\n>                       s = o.dtypes.value_counts()",
            "\npandas/core/computation/expressions.py:84: AttributeError"
        ]
    ],
    "2.1.3": [
        [
            {
                "a.shape": "(10000, 4)",
                "a": "array of shape (10000, 4)",
                "b": "A    0.761335\nB    0.001048\nC    0.999442\nD   -0.014994\nName: 0, dtype: float64",
                "dtype_check": "'evaluate'"
            },
            {}
        ],
        [
            {
                "a.shape": "(10000,)",
                "a": "0       0.761335\n1      -0.129271\n2       0.550976\n3      -0.605095\n4      -0.688107\n          ...   \n9995   -1.022974\n9996    1.129512\n9997   -0.952096\n9998    0.104927\n9999   -0.801916\nName: A, Length: 10000, dtype: float64",
                "b": "0.76133517641967",
                "dtype_check": "'evaluate'"
            },
            {}
        ],
        [
            {
                "a.shape": "(10000,)",
                "a": "array([ 0.76133518, -0.12927122,  0.55097583, ..., -0.95209608,\n        0.10492666, -0.80191577])",
                "b": "0.76133517641967",
                "dtype_check": "'evaluate'"
            },
            {}
        ],
        [
            {
                "a.shape": "(10000,)",
                "a": "0       0.001048\n1       0.701252\n2       1.154293\n3      -0.168118\n4      -0.889402\n          ...   \n9995    0.115447\n9996    1.680831\n9997    0.258222\n9998    0.003217\n9999    0.519302\nName: B, Length: 10000, dtype: float64",
                "b": "0.0010480426450795522",
                "dtype_check": "'evaluate'"
            },
            {}
        ],
        [
            {
                "a.shape": "(10000,)",
                "a": "array([1.04804265e-03, 7.01251705e-01, 1.15429326e+00, ...,\n       2.58221838e-01, 3.21724595e-03, 5.19302226e-01])",
                "b": "0.0010480426450795522",
                "dtype_check": "'evaluate'"
            },
            {}
        ],
        [
            {
                "a.shape": "(10000,)",
                "a": "0       0.999442\n1      -1.061233\n2      -0.924933\n3      -0.065656\n4      -0.478970\n          ...   \n9995    0.558776\n9996   -0.395178\n9997    0.605079\n9998   -0.882434\n9999   -0.116271\nName: C, Length: 10000, dtype: float64",
                "b": "0.9994419621805138",
                "dtype_check": "'evaluate'"
            },
            {}
        ],
        [
            {
                "a.shape": "(10000,)",
                "a": "array([ 0.99944196, -1.0612329 , -0.92493347, ...,  0.60507909,\n       -0.88243439, -0.11627075])",
                "b": "0.9994419621805138",
                "dtype_check": "'evaluate'"
            },
            {}
        ],
        [
            {
                "a.shape": "(10000,)",
                "a": "0      -0.014994\n1      -1.272181\n2      -0.867558\n3      -0.817851\n4      -1.215057\n          ...   \n9995   -0.545269\n9996   -2.272315\n9997   -0.604773\n9998   -0.661102\n9999    0.814927\nName: D, Length: 10000, dtype: float64",
                "b": "-0.014994137947596319",
                "dtype_check": "'evaluate'"
            },
            {}
        ],
        [
            {
                "a.shape": "(10000,)",
                "a": "array([-0.01499414, -1.27218052, -0.86755811, ..., -0.60477275,\n       -0.66110248,  0.81492743])",
                "b": "-0.014994137947596319",
                "dtype_check": "'evaluate'"
            },
            {}
        ]
    ],
    "2.1.4": [
        [
            {
                "a.shape": "tuple",
                "a": "DataFrame",
                "b": "Series",
                "dtype_check": "str"
            },
            {}
        ],
        [
            {
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {}
        ],
        [
            {
                "a.shape": "tuple",
                "a": "ndarray",
                "b": "float64",
                "dtype_check": "str"
            },
            {}
        ],
        [
            {
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {}
        ],
        [
            {
                "a.shape": "tuple",
                "a": "ndarray",
                "b": "float64",
                "dtype_check": "str"
            },
            {}
        ],
        [
            {
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {}
        ],
        [
            {
                "a.shape": "tuple",
                "a": "ndarray",
                "b": "float64",
                "dtype_check": "str"
            },
            {}
        ],
        [
            {
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {}
        ],
        [
            {
                "a.shape": "tuple",
                "a": "ndarray",
                "b": "float64",
                "dtype_check": "str"
            },
            {}
        ]
    ],
    "2.1.5": [
        [
            {
                "a.shape": "(10000, 4)",
                "a": "array of shape (10000, 4)",
                "b": "A    0.161187\nB   -0.832019\nC    1.447289\nD   -0.310850\nName: 0, dtype: float64",
                "dtype_check": "'evaluate'"
            },
            {}
        ],
        [
            {
                "op_str": "'+'",
                "a.shape": "(10000,)",
                "a": "0       0.161187\n1      -0.325447\n2       1.476291\n3      -0.630954\n4      -0.198291\n          ...   \n9995   -0.447562\n9996   -1.776905\n9997    0.133223\n9998   -0.047923\n9999   -0.299336\nName: A, Length: 10000, dtype: float64",
                "b": "0.1611869796344804",
                "dtype_check": "'evaluate'"
            },
            {
                "dtypes": "{'float64'}",
                "o": "0.1611869796344804",
                "o.ndim": "0",
                "o.dtype": "dtype('float64')"
            }
        ],
        [
            {
                "op_str": "'+'",
                "a.shape": "(10000,)",
                "a": "0      -0.832019\n1      -0.704368\n2      -0.935820\n3       1.426034\n4       1.049603\n          ...   \n9995   -0.607258\n9996   -0.345834\n9997    1.260477\n9998    1.072023\n9999    0.068797\nName: B, Length: 10000, dtype: float64",
                "b": "-0.8320192736143672",
                "dtype_check": "'evaluate'"
            },
            {
                "dtypes": "{'float64'}",
                "o": "-0.8320192736143672",
                "o.ndim": "0",
                "o.dtype": "dtype('float64')"
            }
        ],
        [
            {
                "op_str": "'+'",
                "a.shape": "(10000,)",
                "a": "0       1.447289\n1      -1.197218\n2      -2.207724\n3      -0.799321\n4      -0.731616\n          ...   \n9995   -0.050972\n9996   -0.788028\n9997   -0.383056\n9998    1.153808\n9999    0.463986\nName: C, Length: 10000, dtype: float64",
                "b": "1.4472887729167054",
                "dtype_check": "'evaluate'"
            },
            {
                "dtypes": "{'float64'}",
                "o": "1.4472887729167054",
                "o.ndim": "0",
                "o.dtype": "dtype('float64')"
            }
        ],
        [
            {
                "op_str": "'+'",
                "a.shape": "(10000,)",
                "a": "0      -0.310850\n1      -1.186644\n2       2.013714\n3      -0.945381\n4       1.258360\n          ...   \n9995    0.777873\n9996   -0.359008\n9997   -0.055831\n9998   -1.816998\n9999    0.110455\nName: D, Length: 10000, dtype: float64",
                "b": "-0.3108500651961882",
                "dtype_check": "'evaluate'"
            },
            {
                "dtypes": "{'float64'}",
                "o": "-0.3108500651961882",
                "o.ndim": "0",
                "o.dtype": "dtype('float64')"
            }
        ],
        [
            {
                "op_str": "'-'",
                "a.shape": "(10000,)",
                "a": "0       0.161187\n1      -0.325447\n2       1.476291\n3      -0.630954\n4      -0.198291\n          ...   \n9995   -0.447562\n9996   -1.776905\n9997    0.133223\n9998   -0.047923\n9999   -0.299336\nName: A, Length: 10000, dtype: float64",
                "b": "0.1611869796344804",
                "dtype_check": "'evaluate'"
            },
            {
                "dtypes": "{'float64'}",
                "o": "0.1611869796344804",
                "o.ndim": "0",
                "o.dtype": "dtype('float64')"
            }
        ],
        [
            {
                "op_str": "'-'",
                "a.shape": "(10000,)",
                "a": "0      -0.832019\n1      -0.704368\n2      -0.935820\n3       1.426034\n4       1.049603\n          ...   \n9995   -0.607258\n9996   -0.345834\n9997    1.260477\n9998    1.072023\n9999    0.068797\nName: B, Length: 10000, dtype: float64",
                "b": "-0.8320192736143672",
                "dtype_check": "'evaluate'"
            },
            {
                "dtypes": "{'float64'}",
                "o": "-0.8320192736143672",
                "o.ndim": "0",
                "o.dtype": "dtype('float64')"
            }
        ],
        [
            {
                "op_str": "'-'",
                "a.shape": "(10000,)",
                "a": "0       1.447289\n1      -1.197218\n2      -2.207724\n3      -0.799321\n4      -0.731616\n          ...   \n9995   -0.050972\n9996   -0.788028\n9997   -0.383056\n9998    1.153808\n9999    0.463986\nName: C, Length: 10000, dtype: float64",
                "b": "1.4472887729167054",
                "dtype_check": "'evaluate'"
            },
            {
                "dtypes": "{'float64'}",
                "o": "1.4472887729167054",
                "o.ndim": "0",
                "o.dtype": "dtype('float64')"
            }
        ],
        [
            {
                "op_str": "'-'",
                "a.shape": "(10000,)",
                "a": "0      -0.310850\n1      -1.186644\n2       2.013714\n3      -0.945381\n4       1.258360\n          ...   \n9995    0.777873\n9996   -0.359008\n9997   -0.055831\n9998   -1.816998\n9999    0.110455\nName: D, Length: 10000, dtype: float64",
                "b": "-0.3108500651961882",
                "dtype_check": "'evaluate'"
            },
            {
                "dtypes": "{'float64'}",
                "o": "-0.3108500651961882",
                "o.ndim": "0",
                "o.dtype": "dtype('float64')"
            }
        ],
        [
            {
                "op_str": "'*'",
                "a.shape": "(10000,)",
                "a": "0       0.161187\n1      -0.325447\n2       1.476291\n3      -0.630954\n4      -0.198291\n          ...   \n9995   -0.447562\n9996   -1.776905\n9997    0.133223\n9998   -0.047923\n9999   -0.299336\nName: A, Length: 10000, dtype: float64",
                "b": "0.1611869796344804",
                "dtype_check": "'evaluate'"
            },
            {
                "dtypes": "{'float64'}",
                "o": "0.1611869796344804",
                "o.ndim": "0",
                "o.dtype": "dtype('float64')"
            }
        ],
        [
            {
                "op_str": "'*'",
                "a.shape": "(10000,)",
                "a": "0      -0.832019\n1      -0.704368\n2      -0.935820\n3       1.426034\n4       1.049603\n          ...   \n9995   -0.607258\n9996   -0.345834\n9997    1.260477\n9998    1.072023\n9999    0.068797\nName: B, Length: 10000, dtype: float64",
                "b": "-0.8320192736143672",
                "dtype_check": "'evaluate'"
            },
            {
                "dtypes": "{'float64'}",
                "o": "-0.8320192736143672",
                "o.ndim": "0",
                "o.dtype": "dtype('float64')"
            }
        ],
        [
            {
                "op_str": "'*'",
                "a.shape": "(10000,)",
                "a": "0       1.447289\n1      -1.197218\n2      -2.207724\n3      -0.799321\n4      -0.731616\n          ...   \n9995   -0.050972\n9996   -0.788028\n9997   -0.383056\n9998    1.153808\n9999    0.463986\nName: C, Length: 10000, dtype: float64",
                "b": "1.4472887729167054",
                "dtype_check": "'evaluate'"
            },
            {
                "dtypes": "{'float64'}",
                "o": "1.4472887729167054",
                "o.ndim": "0",
                "o.dtype": "dtype('float64')"
            }
        ],
        [
            {
                "op_str": "'*'",
                "a.shape": "(10000,)",
                "a": "0      -0.310850\n1      -1.186644\n2       2.013714\n3      -0.945381\n4       1.258360\n          ...   \n9995    0.777873\n9996   -0.359008\n9997   -0.055831\n9998   -1.816998\n9999    0.110455\nName: D, Length: 10000, dtype: float64",
                "b": "-0.3108500651961882",
                "dtype_check": "'evaluate'"
            },
            {
                "dtypes": "{'float64'}",
                "o": "-0.3108500651961882",
                "o.ndim": "0",
                "o.dtype": "dtype('float64')"
            }
        ],
        [
            {
                "a.shape": "(10000,)",
                "a": "0       0.161187\n1      -0.325447\n2       1.476291\n3      -0.630954\n4      -0.198291\n          ...   \n9995   -0.447562\n9996   -1.776905\n9997    0.133223\n9998   -0.047923\n9999   -0.299336\nName: A, Length: 10000, dtype: float64",
                "b": "0.1611869796344804",
                "dtype_check": "'evaluate'"
            },
            {}
        ],
        [
            {
                "a.shape": "(10000,)",
                "a": "array([ 0.16118698, -0.32544675,  1.47629101, ...,  0.13322311,\n       -0.04792277, -0.29933601])",
                "b": "0.1611869796344804",
                "dtype_check": "'evaluate'"
            },
            {}
        ],
        [
            {
                "a.shape": "(10000,)",
                "a": "0      -0.832019\n1      -0.704368\n2      -0.935820\n3       1.426034\n4       1.049603\n          ...   \n9995   -0.607258\n9996   -0.345834\n9997    1.260477\n9998    1.072023\n9999    0.068797\nName: B, Length: 10000, dtype: float64",
                "b": "-0.8320192736143672",
                "dtype_check": "'evaluate'"
            },
            {}
        ],
        [
            {
                "a.shape": "(10000,)",
                "a": "array([-0.83201927, -0.70436767, -0.93581971, ...,  1.26047732,\n        1.07202265,  0.06879694])",
                "b": "-0.8320192736143672",
                "dtype_check": "'evaluate'"
            },
            {}
        ],
        [
            {
                "a.shape": "(10000,)",
                "a": "0       1.447289\n1      -1.197218\n2      -2.207724\n3      -0.799321\n4      -0.731616\n          ...   \n9995   -0.050972\n9996   -0.788028\n9997   -0.383056\n9998    1.153808\n9999    0.463986\nName: C, Length: 10000, dtype: float64",
                "b": "1.4472887729167054",
                "dtype_check": "'evaluate'"
            },
            {}
        ],
        [
            {
                "a.shape": "(10000,)",
                "a": "array([ 1.44728877, -1.19721819, -2.2077241 , ..., -0.38305644,\n        1.15380818,  0.46398585])",
                "b": "1.4472887729167054",
                "dtype_check": "'evaluate'"
            },
            {}
        ],
        [
            {
                "a.shape": "(10000,)",
                "a": "0      -0.310850\n1      -1.186644\n2       2.013714\n3      -0.945381\n4       1.258360\n          ...   \n9995    0.777873\n9996   -0.359008\n9997   -0.055831\n9998   -1.816998\n9999    0.110455\nName: D, Length: 10000, dtype: float64",
                "b": "-0.3108500651961882",
                "dtype_check": "'evaluate'"
            },
            {}
        ],
        [
            {
                "a.shape": "(10000,)",
                "a": "array([-0.31085007, -1.18664387,  2.01371391, ..., -0.05583147,\n       -1.81699752,  0.11045459])",
                "b": "-0.3108500651961882",
                "dtype_check": "'evaluate'"
            },
            {}
        ],
        [
            {
                "op_str": "'/'",
                "a.shape": "(10000,)",
                "a": "0       0.161187\n1      -0.325447\n2       1.476291\n3      -0.630954\n4      -0.198291\n          ...   \n9995   -0.447562\n9996   -1.776905\n9997    0.133223\n9998   -0.047923\n9999   -0.299336\nName: A, Length: 10000, dtype: float64",
                "b": "0.1611869796344804",
                "dtype_check": "'evaluate'"
            },
            {
                "dtypes": "{'float64'}",
                "o": "0.1611869796344804",
                "o.ndim": "0",
                "o.dtype": "dtype('float64')"
            }
        ],
        [
            {
                "op_str": "'/'",
                "a.shape": "(10000,)",
                "a": "0      -0.832019\n1      -0.704368\n2      -0.935820\n3       1.426034\n4       1.049603\n          ...   \n9995   -0.607258\n9996   -0.345834\n9997    1.260477\n9998    1.072023\n9999    0.068797\nName: B, Length: 10000, dtype: float64",
                "b": "-0.8320192736143672",
                "dtype_check": "'evaluate'"
            },
            {
                "dtypes": "{'float64'}",
                "o": "-0.8320192736143672",
                "o.ndim": "0",
                "o.dtype": "dtype('float64')"
            }
        ],
        [
            {
                "op_str": "'/'",
                "a.shape": "(10000,)",
                "a": "0       1.447289\n1      -1.197218\n2      -2.207724\n3      -0.799321\n4      -0.731616\n          ...   \n9995   -0.050972\n9996   -0.788028\n9997   -0.383056\n9998    1.153808\n9999    0.463986\nName: C, Length: 10000, dtype: float64",
                "b": "1.4472887729167054",
                "dtype_check": "'evaluate'"
            },
            {
                "dtypes": "{'float64'}",
                "o": "1.4472887729167054",
                "o.ndim": "0",
                "o.dtype": "dtype('float64')"
            }
        ],
        [
            {
                "op_str": "'/'",
                "a.shape": "(10000,)",
                "a": "0      -0.310850\n1      -1.186644\n2       2.013714\n3      -0.945381\n4       1.258360\n          ...   \n9995    0.777873\n9996   -0.359008\n9997   -0.055831\n9998   -1.816998\n9999    0.110455\nName: D, Length: 10000, dtype: float64",
                "b": "-0.3108500651961882",
                "dtype_check": "'evaluate'"
            },
            {
                "dtypes": "{'float64'}",
                "o": "-0.3108500651961882",
                "o.ndim": "0",
                "o.dtype": "dtype('float64')"
            }
        ]
    ],
    "2.1.6": [
        [
            {
                "a.shape": "tuple",
                "a": "DataFrame",
                "b": "Series",
                "dtype_check": "str"
            },
            {}
        ],
        [
            {
                "op_str": "str",
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {
                "dtypes": "set",
                "o": "float64",
                "o.ndim": "int",
                "o.dtype": "dtype"
            }
        ],
        [
            {
                "op_str": "str",
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {
                "dtypes": "set",
                "o": "float64",
                "o.ndim": "int",
                "o.dtype": "dtype"
            }
        ],
        [
            {
                "op_str": "str",
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {
                "dtypes": "set",
                "o": "float64",
                "o.ndim": "int",
                "o.dtype": "dtype"
            }
        ],
        [
            {
                "op_str": "str",
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {
                "dtypes": "set",
                "o": "float64",
                "o.ndim": "int",
                "o.dtype": "dtype"
            }
        ],
        [
            {
                "op_str": "str",
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {
                "dtypes": "set",
                "o": "float64",
                "o.ndim": "int",
                "o.dtype": "dtype"
            }
        ],
        [
            {
                "op_str": "str",
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {
                "dtypes": "set",
                "o": "float64",
                "o.ndim": "int",
                "o.dtype": "dtype"
            }
        ],
        [
            {
                "op_str": "str",
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {
                "dtypes": "set",
                "o": "float64",
                "o.ndim": "int",
                "o.dtype": "dtype"
            }
        ],
        [
            {
                "op_str": "str",
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {
                "dtypes": "set",
                "o": "float64",
                "o.ndim": "int",
                "o.dtype": "dtype"
            }
        ],
        [
            {
                "op_str": "str",
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {
                "dtypes": "set",
                "o": "float64",
                "o.ndim": "int",
                "o.dtype": "dtype"
            }
        ],
        [
            {
                "op_str": "str",
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {
                "dtypes": "set",
                "o": "float64",
                "o.ndim": "int",
                "o.dtype": "dtype"
            }
        ],
        [
            {
                "op_str": "str",
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {
                "dtypes": "set",
                "o": "float64",
                "o.ndim": "int",
                "o.dtype": "dtype"
            }
        ],
        [
            {
                "op_str": "str",
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {
                "dtypes": "set",
                "o": "float64",
                "o.ndim": "int",
                "o.dtype": "dtype"
            }
        ],
        [
            {
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {}
        ],
        [
            {
                "a.shape": "tuple",
                "a": "ndarray",
                "b": "float64",
                "dtype_check": "str"
            },
            {}
        ],
        [
            {
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {}
        ],
        [
            {
                "a.shape": "tuple",
                "a": "ndarray",
                "b": "float64",
                "dtype_check": "str"
            },
            {}
        ],
        [
            {
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {}
        ],
        [
            {
                "a.shape": "tuple",
                "a": "ndarray",
                "b": "float64",
                "dtype_check": "str"
            },
            {}
        ],
        [
            {
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {}
        ],
        [
            {
                "a.shape": "tuple",
                "a": "ndarray",
                "b": "float64",
                "dtype_check": "str"
            },
            {}
        ],
        [
            {
                "op_str": "str",
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {
                "dtypes": "set",
                "o": "float64",
                "o.ndim": "int",
                "o.dtype": "dtype"
            }
        ],
        [
            {
                "op_str": "str",
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {
                "dtypes": "set",
                "o": "float64",
                "o.ndim": "int",
                "o.dtype": "dtype"
            }
        ],
        [
            {
                "op_str": "str",
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {
                "dtypes": "set",
                "o": "float64",
                "o.ndim": "int",
                "o.dtype": "dtype"
            }
        ],
        [
            {
                "op_str": "str",
                "a.shape": "tuple",
                "a": "Series",
                "b": "float64",
                "dtype_check": "str"
            },
            {
                "dtypes": "set",
                "o": "float64",
                "o.ndim": "int",
                "o.dtype": "dtype"
            }
        ]
    ],
    "3.1.1": [
        "Operators between DataFrame and Series fail on large dataframes\n"
    ],
    "3.1.2": [
        "Code Sample\nimport pandas as pd\n\nind = list(range(0, 100))\ncols = list(range(0, 300))\ndf = pd.DataFrame(index=ind, columns=cols, data=1.0)\nseries = pd.Series(index=cols, data=cols)\nprint(df.multiply(series, axis=1).head())  # Works fine\nind = list(range(0, 100000))\ncols = list(range(0, 300))\ndf = pd.DataFrame(index=ind, columns=cols, data=1.0)\nseries = pd.Series(index=cols, data=cols)\nprint(df.add(series,axis=1).head()) \nCode Output:\n   0    1    2    3    4    5    ...    294    295    296    297    298    299\n0  0.0  1.0  2.0  3.0  4.0  5.0  ...  294.0  295.0  296.0  297.0  298.0  299.0\n1  0.0  1.0  2.0  3.0  4.0  5.0  ...  294.0  295.0  296.0  297.0  298.0  299.0\n2  0.0  1.0  2.0  3.0  4.0  5.0  ...  294.0  295.0  296.0  297.0  298.0  299.0\n3  0.0  1.0  2.0  3.0  4.0  5.0  ...  294.0  295.0  296.0  297.0  298.0  299.0\n4  0.0  1.0  2.0  3.0  4.0  5.0  ...  294.0  295.0  296.0  297.0  298.0  299.0\n[5 rows x 300 columns]\nTraceback (most recent call last):\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\IPython\\core\\interactiveshell.py\", line 2963, in run_code\n    exec(code_obj, self.user_global_ns, self.user_ns)\n  File \"<ipython-input-25-4d9165e5df4a>\", line 15, in <module>\n    print(df.add(series,axis=1).head())\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\ops\\__init__.py\", line 1499, in f\n    self, other, pass_op, fill_value=fill_value, axis=axis, level=level\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\ops\\__init__.py\", line 1388, in _combine_series_frame\n    return self._combine_match_columns(other, func, level=level)\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\frame.py\", line 5392, in _combine_match_columns\n    return ops.dispatch_to_series(left, right, func, axis=\"columns\")\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\ops\\__init__.py\", line 596, in dispatch_to_series\n    new_data = expressions.evaluate(column_op, str_rep, left, right)\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\computation\\expressions.py\", line 220, in evaluate\n    return _evaluate(op, op_str, a, b, **eval_kwargs)\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\computation\\expressions.py\", line 126, in _evaluate_numexpr\n    result = _evaluate_standard(op, op_str, a, b)\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\computation\\expressions.py\", line 70, in _evaluate_standard\n    return op(a, b)\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\ops\\__init__.py\", line 584, in column_op\n    return {i: func(a.iloc[:, i], b.iloc[i]) for i in range(len(a.columns))}\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\ops\\__init__.py\", line 584, in <dictcomp>\n    return {i: func(a.iloc[:, i], b.iloc[i]) for i in range(len(a.columns))}\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\ops\\__init__.py\", line 1473, in na_op\n    result = expressions.evaluate(op, str_rep, x, y, **eval_kwargs)\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\computation\\expressions.py\", line 220, in evaluate\n    return _evaluate(op, op_str, a, b, **eval_kwargs)\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\computation\\expressions.py\", line 101, in _evaluate_numexpr\n    if _can_use_numexpr(op, op_str, a, b, \"evaluate\"):\n  File \"C:\\dev\\bin\\anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\computation\\expressions.py\", line 84, in _can_use_numexpr\n    s = o.dtypes.value_counts()\nAttributeError: 'numpy.dtype' object has no attribute 'value_counts'\nProblem description\nI think this is a regression somewhere between pandas 0.19.2 and 0.25. If you multiply or use any other operator function such as add/divide on a DataFrame by a Series where axis=1 pandas will crash in the _can_use_numexpr functon when the DataFrame/Series becomes very large. This is presumably down to check of the size of the objects being operated on not passing for small datasets but for larger ones it gets to the failing line.\n\n#pandas/core/computation/expressions.py : 73\ndef _can_use_numexpr(op, op_str, a, b, dtype_check):\n    \"\"\" return a boolean if we WILL be using numexpr \"\"\"\n    if op_str is not None:\n\n        # required min elements (otherwise we are adding overhead)\n        if np.prod(a.shape) > _MIN_ELEMENTS:\n\n            # check for dtype compatibility\n            dtypes = set()\n            for o in [a, b]:\n                if hasattr(o, \"dtypes\"):\n                    s = o.dtypes.value_counts()  # Fails here\nIn pandas 0.19.2 the function uses the get_dtype_counts() method instead to inspect if the dtype is uniform in the object:\n\ndef _can_use_numexpr(op, op_str, a, b, dtype_check):\n    \"\"\" return a boolean if we WILL be using numexpr \"\"\"\n    if op_str is not None:\n\n        # required min elements (otherwise we are adding overhead)\n        if np.prod(a.shape) > _MIN_ELEMENTS:\n\n            # check for dtype compatiblity\n            dtypes = set()\n            for o in [a, b]:\n                if hasattr(o, 'get_dtype_counts'):\n                    s = o.get_dtype_counts()\nI have a workaround which is to transpose the dataframe and use axis=0:\n\ndf.T.add(series,axis=0).T.head()\nI noticed get_dtype_counts() is deprecated ( #27145 ) which appears to be the PR that has caused this regression as a Series only returns a single numpy dtype which does not have a value_counts() method.\n"
    ]
}