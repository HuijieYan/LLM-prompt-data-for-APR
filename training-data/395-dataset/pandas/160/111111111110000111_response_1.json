{
    "pandas": [
        {
            "bugID": 160,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 1
            },
            "strata": {
                "1": 1,
                "2": 1,
                "3": 1,
                "4": 1,
                "5": 0,
                "6": 1,
                "7": 1
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 0,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 1
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 1,
                "5": 0,
                "6": 1,
                "7": 1
            },
            "start_line": 73,
            "file_name": "pandas/core/computation/expressions.py",
            "replace_code": "def _can_use_numexpr(op, op_str, a, b, dtype_check):\n    \"\"\" return a boolean if we WILL be using numexpr \"\"\"\n    if op_str is not None:\n        # required min elements (otherwise we are adding overhead)\n        if np.prod(a.shape) > _MIN_ELEMENTS:\n            # check for dtype compatibility\n            dtypes = set()\n            if hasattr(a, \"dtypes\"):\n                if hasattr(a.dtypes, 'value_counts'):\n                    s = a.dtypes.value_counts()\n                    if len(s) > 1:\n                        return False\n                    dtypes |= set(s.index.astype(str))\n                    if dtypes:\n                        dtype_counts = {dtype: 1 for dtype in dtypes}\n                    else:\n                        dtype_counts = {}\n                    if hasattr(b, \"dtypes\"):\n                        s = b.dtypes.value_counts()\n                        if len(s) > 1:\n                            return False\n                        dtypes |= set(s.index.astype(str))\n                        for dtype in dtypes:\n                            dtype_counts[dtype] = dtype_counts.get(dtype, 0) + 1\n                    elif isinstance(b, np.ndarray):\n                        dtypes |= {b.dtype.name}\n                    for dtype in dtype_counts:\n                        if dtype_counts[dtype] > 1 or dtype_counts[dtype] > _ALLOWED_DTYPES[dtype_check]:\n                            return False\n            elif isinstance(a, np.ndarray):\n                if isinstance(b, np.ndarray):\n                    dtypes |= {a.dtype.name, b.dtype.name}\n                else:\n                    dtypes |= {a.dtype.name}\n                    if hasattr(b, \"dtypes\"):\n                        s = b.dtypes.value_counts()\n                        if len(s) > 1:\n                            return False\n                        dtypes |= set(s.index.astype(str))\n                    elif isinstance(b, np.ndarray):\n                        dtypes |= {b.dtype.name}\n                    if len(dtypes) > 1:\n                        return False\n            if len(dtypes) > 1 or _ALLOWED_DTYPES[dtype_check] >= dtypes:\n                return True\n    return False",
            "imports": []
        }
    ]
}