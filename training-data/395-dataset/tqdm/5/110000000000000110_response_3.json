{
    "tqdm": [
        {
            "bugID": 5,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 0,
                "4": 0,
                "5": 0,
                "6": 1,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 0,
                "4": 0,
                "5": 0,
                "6": 1,
                "7": 0
            },
            "start_line": 641,
            "file_name": "tqdm/_tqdm.py",
            "replace_code": "def __init__(self, iterable=None, desc=None, total=None, leave=True, file=None, ncols=None, \n             dynamic_ncols=False, smoothing=0.3, bar_format=None, initial=0, position=None, \n             postfix=None, **kwargs):\n    \"\"\"\n    Parameters\n    ----------\n    iterable  : iterable, optional\n        Iterable to decorate with a progressbar.\n        Leave blank to manually manage the updates.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If unspecified,\n        len(iterable) is used if possible. As a last resort, only basic\n        progress statistics are displayed (no ETA, no progressbar).\n        If `gui` is True and this parameter needs subsequent updating,\n        specify an initial arbitrary large positive integer,\n        e.g. int(9e9).\n    leave  : bool, optional\n        If [default: True], keeps all traces of the progressbar\n        upon termination of iteration.\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages\n        (default: sys.stderr). Uses `file.write(str)` and `file.flush()`\n        methods.\n    ncols  : int, optional\n        The width of the entire output message. If specified,\n        dynamically resizes the progressbar to stay within this bound.\n        If unspecified, attempts to use environment width. The\n        fallback is a meter width of 10 and no limit for the counter and\n        statistics. If 0, will not print any meter (only stats).\n    dynamic_ncols  : bool, optional\n        If set, constantly alters `ncols` to the environment (allowing\n        for window resizes) [default: False].\n    smoothing  : float, optional\n        Exponential moving average smoothing factor for speed estimates\n        (ignored in GUI mode). Ranges from 0 (average speed) to 1\n        (current/instantaneous speed) [default: 0.3].\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where\n        l_bar='{desc}: {percentage:3.0f}%|' and\n        r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n          '{rate_fmt}{postfix}]'\n        Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n          percentage, rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n          rate_inv, rate_inv_fmt, elapsed, remaining, desc, postfix.\n        Note that a trailing \": \" is automatically removed after {desc}\n        if the latter is empty.\n    initial  : int, optional\n        The initial counter value. Useful when restarting a progress\n        bar [default: 0].\n    position  : int, optional\n        Specify the line offset to print this bar (starting from 0)\n        Automatic if unspecified.\n        Useful to manage multiple bars at once (eg, from threads).\n    postfix  : dict or *, optional\n        Specify additional stats to display at the end of the bar.\n        Calls `set_postfix(**postfix)` if possible (dict).\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n\n    if file is None:\n        file = sys.stderr\n\n    if disable is None and hasattr(file, \"isatty\") and not file.isatty():\n        disable = True\n\n    if disable:\n        self.iterable = iterable\n        self.disable = disable\n        self.pos = self._get_free_pos(self)\n        self._instances.remove(self)\n        self.n = initial\n        return\n\n    if kwargs:\n        self.disable = True\n        self.pos = self._get_free_pos(self)\n        self._instances.remove(self)\n        raise (TqdmDeprecationWarning(\"\"\"\\\n`nested` is deprecated and automated. Use position instead for manual control.\n\"\"\", fp_write=getattr(file, 'write', sys.stderr.write)) if \"nested\" in kwargs\n            else TqdmKeyError(\"Unknown argument(s): \" + str(kwargs)))\n\n    # Preprocess the arguments\n    if total is None and iterable is not None:\n        try:\n            total = len(iterable)\n        except (TypeError, AttributeError):\n            total = None\n\n    if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n            dynamic_ncols:  # pragma: no cover\n        if dynamic_ncols:\n            dynamic_ncols = _environ_cols_wrapper()\n            if dynamic_ncols:\n                ncols = dynamic_ncols(file)\n\n    if miniters is None:\n        miniters = 0\n        dynamic_miniters = True\n    else:\n        dynamic_miniters = False\n\n    if mininterval is None:\n        mininterval = 0\n\n    if maxinterval is None:\n        maxinterval = 0\n\n    if ascii is None:\n        ascii = not _supports_unicode(file)\n\n    if bar_format and not ascii:\n        # Convert bar format into unicode since terminal uses unicode\n        bar_format = _unicode(bar_format)\n\n    if smoothing is None:\n        smoothing = 0\n\n    # Store the arguments\n    self.iterable = iterable\n    self.desc = desc or ''\n    self.total = total\n    self.leave = leave\n    self.fp = file\n    self.ncols = ncols\n    self.mininterval = mininterval\n    self.maxinterval = maxinterval\n    self.miniters = miniters\n    self.dynamic_miniters = dynamic_miniters\n    self.ascii = ascii\n    self.disable = disable\n    self.unit = unit\n    self.unit_scale = unit_scale\n    self.unit_divisor = unit_divisor\n    self.gui = gui\n    self.dynamic_ncols = dynamic_ncols\n    self.smoothing = smoothing\n    self.avg_time = None\n    self._time = time\n    self.bar_format = bar_format\n    self.postfix = None\n    if postfix:\n        try:\n            self.set_postfix(refresh=False, **postfix)\n        except TypeError:\n            self.postfix = postfix\n\n    # Init the iterations counters\n    self.last_print_n = initial\n    self.n = initial\n\n    # if nested, at initial sp() call we replace '\\r' by '\\n' to\n    # not overwrite the outer progress bar\n    with self._lock:\n        if position is None:\n            self.pos = self._get_free_pos(self)\n        else:  # mark fixed positions as negative\n            self.pos = -position\n\n    if not gui:\n        # Initialize the screen printer\n        self.sp = self.status_printer(self.fp)\n        with self._lock:\n            if self.pos:\n                self.moveto(abs(self.pos))\n            self.sp(self.__repr__(elapsed=0))\n            if self.pos:\n                self.moveto(-abs(self.pos))\n\n    # Init the time counter\n    self.last_print_t = self._time()\n    # NB: Avoid race conditions by setting start_t at the very end of init\n    self.start_t = self.last_print_t",
            "imports": []
        }
    ]
}