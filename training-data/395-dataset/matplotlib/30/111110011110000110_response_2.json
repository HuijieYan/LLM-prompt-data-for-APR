{
    "matplotlib": [
        {
            "bugID": 30,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 1,
                "3": 0,
                "4": 1,
                "5": 0,
                "6": 1,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 0,
                "4": 1,
                "5": 0,
                "6": 1,
                "7": 0
            },
            "start_line": 336,
            "file_name": "lib/matplotlib/colors.py",
            "replace_code": "def makeMappingArray(N, data, gamma=1.0):\n    import numpy as np\n    import numpy.testing as npt\n    \"\"\"Create an *N* -element 1-d lookup table\n    \n    *data* represented by a list of x,y0,y1 mapping correspondences.\n    Each element in this list represents how a value between 0 and 1\n    (inclusive) represented by x is mapped to a corresponding value\n    between 0 and 1 (inclusive). The two values of y are to allow\n    for discontinuous mapping functions (say as might be found in a\n    sawtooth) where y0 represents the value of y for values of x\n    <= to that given, and y1 is the value to be used for x > than\n    that given). The list must start with x=0, end with x=1, and\n    all values of x must be in increasing order. Values between\n    the given mapping points are determined by simple linear interpolation.\n    \n    Alternatively, data can be a function mapping values between 0 - 1\n    to 0 - 1.\n    \n    The function returns an array \"result\" where ``result[x*(N-1)]``\n    gives the closest value for values of x between 0 and 1.\n    \"\"\"\n    result = np.empty(N)\n    if callable(data):\n        xind = np.linspace(0, 1, N) ** gamma\n        lut = np.clip(np.array(data(xind), dtype=float), 0, 1)\n        return lut\n    try:\n        adata = np.array(data)\n    except Exception:\n        raise TypeError(\"data must be convertible to an array\")\n    shape = adata.shape\n    if len(shape) != 2 or shape[1] != 3:\n        raise ValueError(\"data must be nx3 format\")\n    x = adata[:, 0]\n    y0 = adata[:, 1]\n    y1 = adata[:, 2]\n    if x[0] != 0. or x[-1] != 1.0:\n        raise ValueError(\"data mapping points must start with x=0 and end with x=1\")\n    if (np.diff(x) < 0).any():\n        raise ValueError(\"data mapping points must have x in increasing order\")\n    x = x * (N - 1)\n    xind = (N - 1) * np.linspace(0, 1, N) ** gamma\n    ind = np.searchsorted(x, xind)[1:-1]\n    distance = (xind[1:-1] - x[ind - 1]) / (x[ind] - x[ind - 1])\n    lut = np.concatenate([\n        [y1[0]],\n        distance * (y0[ind] - y1[ind - 1]) + y1[ind - 1],\n        [y0[-1]],\n    ])\n    result = np.clip(lut, 0.0, 1.0)\n    return result"
        }
    ]
}