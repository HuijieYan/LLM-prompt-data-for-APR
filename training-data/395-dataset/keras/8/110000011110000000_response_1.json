{
    "keras": [
        {
            "bugID": 8,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 0,
                "4": 1,
                "5": 0,
                "6": 0,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 0,
                "4": 1,
                "5": 0,
                "6": 0,
                "7": 0
            },
            "start_line": 933,
            "file_name": "keras/engine/network.py",
            "replace_code": "def from_config(cls, config, custom_objects=None):\n    \"\"\"Instantiates a Model from its config (output of `get_config()`).\n\n    # Arguments\n        config: Model config dictionary.\n        custom_objects: Optional dictionary mapping names\n            (strings) to custom classes or functions to be\n            considered during deserialization.\n\n    # Returns\n        A model instance.\n\n    # Raises\n        ValueError: In case of improperly formatted config dict.\n    \"\"\"\n    # Layer instances created during\n    # the graph reconstruction process\n    created_layers = {}\n\n    def build(layer, node_data):\n        input_tensors = []\n        if node_data:\n            for input_data in node_data:\n                inbound_layer_name = input_data[0]\n                inbound_node_index = input_data[1]\n                inbound_tensor_index = input_data[2]\n                if len(input_data) == 3:\n                    kwargs = {}\n                elif len(input_data) == 4:\n                    kwargs = input_data[3]\n                else:\n                    raise ValueError('Improperly formatted model config.')\n                inbound_layer = created_layers[inbound_layer_name]\n                if len(inbound_layer._inbound_nodes) <= inbound_node_index:\n                    return None\n                inbound_node = inbound_layer._inbound_nodes[inbound_node_index]\n                input_tensors.append(inbound_node.output_tensors[inbound_tensor_index])\n            return layer(unpack_singleton(input_tensors), **kwargs)\n        else:\n            return None\n\n    def process_layer(layer_data):\n        \"\"\"Deserializes a layer, then call it on appropriate inputs.\n\n        # Arguments\n            layer_data: layer config dict.\n\n        # Raises\n            ValueError: In case of improperly formatted `layer_data` dict.\n        \"\"\"\n        layer_name = layer_data['name']\n\n        layer_class_name = layer_data['class_name']\n        layer = deserialize(config=layer_data,\n                            custom_objects=custom_objects)\n        created_layers[layer_name] = layer\n\n    # First, we create all layers and enqueue nodes to be processed\n    for layer_data in config['layers']:\n        if layer_data['class_name'] == 'InputLayer':\n            continue\n        process_layer(layer_data)\n\n    # Build the model\n    for layer_data in config['layers']:\n        if layer_data['class_name'] == 'InputLayer':\n            continue\n        layer_name = layer_data['name']\n        layer = created_layers[layer_name]\n        inbound_nodes_data = layer_data['inbound_nodes']\n        for node_data in inbound_nodes_data:\n            build(layer, node_data)\n\n    name = config.get('name')\n    input_layers = []\n    output_layers = []\n    for layer_data in config['input_layers']:\n        layer_name = layer_data[0]\n        input_layers.append(created_layers[layer_name])\n    for layer_data in config['output_layers']:\n        layer_name = layer_data[0]\n        output_layers.append(created_layers[layer_name])\n\n    return cls(inputs=input_layers, outputs=output_layers, name=name)",
            "imports": []
        }
    ]
}