# Error stack trace

```json
[
    [
        "layer_class = <class 'keras.layers.recurrent.LSTM'>\n\n    @rnn_test\n    def test_implementation_mode(layer_class):\n        for mode in [1, 2]:\n            # Without dropout\n            layer_test(layer_class,\n                       kwargs={'units': units,\n                               'implementation': mode},\n                       input_shape=(num_samples, timesteps, embedding_dim))\n            # With dropout\n            layer_test(layer_class,\n                       kwargs={'units': units,\n                               'implementation': mode,\n                               'dropout': 0.1,\n                               'recurrent_dropout': 0.1},\n                       input_shape=(num_samples, timesteps, embedding_dim))\n            # Without bias\n            layer_test(layer_class,\n                       kwargs={'units': units,\n                               'implementation': mode,\n                               'use_bias': False},\n>                      input_shape=(num_samples, timesteps, embedding_dim))\n\ntests/keras/layers/recurrent_test.py:191: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nkeras/utils/test_utils.py:85: in layer_test\n    y = layer(x)\nkeras/layers/recurrent.py:483: in __call__\n    return super(RNN, self).__call__(inputs, **kwargs)\nkeras/engine/topology.py:603: in __call__\n    output = self.call(inputs, **kwargs)\nkeras/layers/recurrent.py:2004: in call\n    initial_state=initial_state)\nkeras/layers/recurrent.py:590: in call\n    input_length=timesteps)\nkeras/backend/tensorflow_backend.py:2533: in rnn\n    outputs, _ = step_function(inputs[0], initial_states + constants)\nkeras/layers/recurrent.py:581: in step\n    return self.cell.call(inputs, states, **kwargs)\nkeras/layers/recurrent.py:1806: in call\n    x_i = K.dot(inputs_i, self.kernel_i) + self.bias_i\n../../envs/keras_45/lib/python3.7/site-packages/tensorflow_core/python/ops/math_ops.py:903: in binary_op_wrapper\n    y, dtype_hint=x.dtype.base_dtype, name=\"y\")\n../../envs/keras_45/lib/python3.7/site-packages/tensorflow_core/python/framework/ops.py:1242: in convert_to_tensor_v2\n    as_ref=False)\n../../envs/keras_45/lib/python3.7/site-packages/tensorflow_core/python/framework/ops.py:1297: in internal_convert_to_tensor\n    ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)\n../../envs/keras_45/lib/python3.7/site-packages/tensorflow_core/python/framework/constant_op.py:286: in _constant_tensor_conversion_function\n    return constant(v, dtype=dtype, name=name)\n../../envs/keras_45/lib/python3.7/site-packages/tensorflow_core/python/framework/constant_op.py:227: in constant\n    allow_broadcast=True)\n../../envs/keras_45/lib/python3.7/site-packages/tensorflow_core/python/framework/constant_op.py:265: in _constant_impl\n    allow_broadcast=allow_broadcast))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nvalues = None, dtype = None, shape = None, verify_shape = False\nallow_broadcast = True\n\n    @tf_export(\"make_tensor_proto\")\n    def make_tensor_proto(values, dtype=None, shape=None, verify_shape=False,\n                          allow_broadcast=False):\n      \"\"\"Create a TensorProto.\n    \n      In TensorFlow 2.0, representing tensors as protos should no longer be a\n      common workflow. That said, this utility function is still useful for\n      generating TF Serving request protos:\n    \n        request = tensorflow_serving.apis.predict_pb2.PredictRequest()\n        request.model_spec.name = \"my_model\"\n        request.model_spec.signature_name = \"serving_default\"\n        request.inputs[\"images\"].CopyFrom(tf.make_tensor_proto(X_new))\n    \n      make_tensor_proto accepts \"values\" of a python scalar, a python list, a\n      numpy ndarray, or a numpy scalar.\n    \n      If \"values\" is a python scalar or a python list, make_tensor_proto\n      first convert it to numpy ndarray. If dtype is None, the\n      conversion tries its best to infer the right numpy data\n      type. Otherwise, the resulting numpy array has a compatible data\n      type with the given dtype.\n    \n      In either case above, the numpy ndarray (either the caller provided\n      or the auto converted) must have the compatible type with dtype.\n    \n      make_tensor_proto then converts the numpy array to a tensor proto.\n    \n      If \"shape\" is None, the resulting tensor proto represents the numpy\n      array precisely.\n    \n      Otherwise, \"shape\" specifies the tensor's shape and the numpy array\n      can not have more elements than what \"shape\" specifies.\n    \n      Args:\n        values:         Values to put in the TensorProto.\n        dtype:          Optional tensor_pb2 DataType value.\n        shape:          List of integers representing the dimensions of tensor.\n        verify_shape:   Boolean that enables verification of a shape of values.\n        allow_broadcast:  Boolean that enables allowing scalars and 1 length vector\n            broadcasting. Cannot be true when verify_shape is true.\n    \n      Returns:\n        A `TensorProto`. Depending on the type, it may contain data in the\n        \"tensor_content\" attribute, which is not directly useful to Python programs.\n        To access the values you should convert the proto back to a numpy ndarray\n        with `tf.make_ndarray(proto)`.\n    \n        If `values` is a `TensorProto`, it is immediately returned; `dtype` and\n        `shape` are ignored.\n    \n      Raises:\n        TypeError:  if unsupported types are provided.\n        ValueError: if arguments have inappropriate values or if verify_shape is\n         True and shape of values is not equals to a shape from the argument.\n    \n      \"\"\"\n      if allow_broadcast and verify_shape:\n        raise ValueError(\"allow_broadcast and verify_shape are not both allowed.\")\n      if isinstance(values, tensor_pb2.TensorProto):\n        return values\n    \n      if dtype:\n        dtype = dtypes.as_dtype(dtype)\n    \n      is_quantized = (\n          dtype in [\n              dtypes.qint8, dtypes.quint8, dtypes.qint16, dtypes.quint16,\n              dtypes.qint32\n          ])\n    \n      if _is_array_like(values):\n        values = np.asarray(values)\n    \n      # We first convert value to a numpy array or scalar.\n      if isinstance(values, (np.ndarray, np.generic)):\n        if dtype and dtype.is_numpy_compatible:\n          nparray = values.astype(dtype.as_numpy_dtype)\n        else:\n          nparray = values\n      else:\n        if values is None:\n>         raise ValueError(\"None values not supported.\")",
        "\n../../envs/keras_45/lib/python3.7/site-packages/tensorflow_core/python/framework/tensor_util.py:437: ValueError"
    ]
]
```
