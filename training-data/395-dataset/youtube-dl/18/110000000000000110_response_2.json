{
    "youtube-dl": [
        {
            "bugID": 18,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 0,
                "4": 0,
                "5": 0,
                "6": 1,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 0,
                "4": 0,
                "5": 0,
                "6": 0,
                "7": 0
            },
            "start_line": 820,
            "file_name": "youtube_dl/YoutubeDL.py",
            "replace_code": "def process_ie_result(self, ie_result, download=True, extra_info={}):\n    \"\"\"\n    Take the result of the ie (may be modified) and resolve all unresolved\n    references (URLs, playlist items).\n\n    It will also download the videos if 'download'.\n    Returns the resolved ie_result.\n    \"\"\"\n    result_type = ie_result.get('_type', 'video')\n\n    if result_type in ('url', 'url_transparent'):\n        if extra_info.get('playlist') or self.params.get('extract_flat', False):\n            if self.params.get('forcejson', False):\n                self.to_stdout(json.dumps(ie_result))\n            return ie_result\n\n    if result_type == 'video':\n        self.add_extra_info(ie_result, extra_info)\n        return self.process_video_result(ie_result, download=download)\n    elif result_type == 'url':\n        return self.extract_info(ie_result['url'], download, ie_key=ie_result.get('ie_key'), extra_info=extra_info)\n    elif result_type == 'url_transparent':\n        info = self.extract_info(ie_result['url'], ie_key=ie_result.get('ie_key'), extra_info=extra_info, download=False, process=False)\n        if not info:\n            return info\n        force_properties = {k: v for k, v in ie_result.items() if v is not None}\n        for f in ('_type', 'url', 'ie_key'):\n            if f in force_properties:\n                del force_properties[f]\n        new_result = info.copy()\n        new_result.update(force_properties)\n        if new_result.get('_type') == 'url':\n            new_result['_type'] = 'url_transparent'\n        return self.process_ie_result(new_result, download=download, extra_info=extra_info)\n    elif result_type in ('playlist', 'multi_video'):\n        playlist = ie_result.get('title') or ie_result.get('id')\n        self.to_screen(f'[download] Downloading playlist: {playlist}')\n        playlist_results = []\n        playliststart = int(self.params.get('playliststart', 1)) - 1\n        playlistend = self.params.get('playlistend')\n        if playlistend == -1:\n            playlistend = None\n        playlistitems_str = self.params.get('playlist_items')\n        playlistitems = None\n        if playlistitems_str is not None:\n            def iter_playlistitems(format):\n                for string_segment in format.split(','):\n                    if '-' in string_segment:\n                        start, end = map(int, string_segment.split('-'))\n                        for item in range(start, end + 1):\n                            yield item\n                    else:\n                        yield int(string_segment)\n            playlistitems = iter_playlistitems(playlistitems_str)\n        ie_entries = ie_result['entries']\n        if isinstance(ie_entries, list):\n            n_all_entries = len(ie_entries)\n            if playlistitems:\n                entries = [ie_entries[i - 1] for i in playlistitems if -n_all_entries <= i - 1 < n_all_entries]\n            else:\n                entries = ie_entries[playliststart:playlistend]\n            n_entries = len(entries)\n            self.to_screen(f'[{ie_result[\"extractor\"]}] playlist {playlist}: Collected {n_all_entries} video ids (downloading {n_entries} of them)')\n        elif isinstance(ie_entries, PagedList):\n            # Implementation for PagedList\n            pass\n        else:\n            entries = []  # refereces missing type\n        # more intervals\n\n    # rest of the implementation goes here for the remaining conditions\n\n    else:\n        raise Exception(f'Invalid result type: {result_type}')",
            "import_list": [
                "import json",
                "import itertools",
                "import random",
                "from paged_list import PagedList"
            ]
        }
    ]
}