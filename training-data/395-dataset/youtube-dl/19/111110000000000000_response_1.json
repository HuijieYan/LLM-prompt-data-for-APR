{
    "youtube-dl": [
        {
            "bugID": 19,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 1,
                "3": 0,
                "4": 0,
                "5": 0,
                "6": 0,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 1,
                "3": 0,
                "4": 0,
                "5": 0,
                "6": 0,
                "7": 0
            },
            "start_line": 611,
            "file_name": "youtube_dl/YoutubeDL.py",
            "replace_code": "def prepare_filename(self, info_dict):\n        \"\"\"Generate the output filename.\"\"\"\n        try:\n            import time  # added this import\n\n            template_dict = dict(info_dict)\n    \n            if 'epoch' not in template_dict:\n                template_dict['epoch'] = int(time.time())\n\n            # updated the way of retrieving autonumber_size\n            autonumber_size = self.params.get('autonumber_size', 5)\n\n            # updated the way of retrieving autonumber_start\n            autonumber_start = self.params.get('autonumber_start', 1) - 1 + self._num_downloads\n            template_dict['autonumber'] = autonumber_start\n\n            if 'resolution' not in template_dict:\n                if 'width' in template_dict and 'height' in template_dict:\n                    template_dict['resolution'] = '%dx%d' % (template_dict['width'], template_dict['height'])\n                elif 'height' in template_dict:\n                    template_dict['resolution'] = '%sp' % template_dict['height']\n                elif 'width' in template_dict:\n                    template_dict['resolution'] = '%dx?' % template_dict['width']\n    \n            # use sanitize_filename in the dictionary comprehension\n            template_dict = {k: sanitize_filename(compat_str(v), restricted=self.params.get('restrictfilenames'), is_id=(k == 'id' or k.endswith('_id'))) for k, v in template_dict.items() if v is not None and not isinstance(v, (list, tuple, dict))}\n\n            # updated the way of setting default value for template_dict\n            template_dict = collections.defaultdict(lambda: 'NA', template_dict)\n\n            outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)\n\n            # For fields playlist_index and autonumber convert all occurrences\n            # of %(field)s to %(field)0Nd for backward compatibility\n            field_size_compat_map = {\n                'playlist_index': len(str(template_dict['n_entries'])),\n                'autonumber': autonumber_size,\n            }\n            FIELD_SIZE_COMPAT_RE = r'(?<!%)%\\((?P<field>autonumber|playlist_index)\\)s'\n            mobj = re.search(FIELD_SIZE_COMPAT_RE, outtmpl)\n            if mobj:\n                outtmpl = re.sub(\n                    FIELD_SIZE_COMPAT_RE,\n                    r'%%(\\1)0%dd' % field_size_compat_map[mobj.group('field')],\n                    outtmpl)\n\n            # Missing numeric fields used together with integer presentation types\n            # in format specification will break the argument substitution since\n            # string 'NA' is returned for missing fields. We will patch output\n            # template for missing fields to meet string presentation type.\n            for numeric_field in self._NUMERIC_FIELDS:\n                if numeric_field not in template_dict:\n                    FORMAT_RE = r'''(?x)\n                        (?<!%)\n                        %\n                        \\({0}\\)  # mapping key\n                        (?:[#0\\-+ ]+)?  # conversion flags (optional)\n                        (?:\\d+)?  # minimum field width (optional)\n                        (?:\\.\\d+)?  # precision (optional)\n                        [hlL]?  # length modifier (optional)\n                        [diouxXeEfFgGcrs%]  # conversion type\n                    '''\n                    outtmpl = re.sub(\n                        FORMAT_RE.format(numeric_field),\n                        r'%({0})s'.format(numeric_field), outtmpl)\n    \n            filename = expand_path(outtmpl % template_dict)\n            if sys.version_info < (3, 0) and sys.platform == 'win32':\n                filename = encodeFilename(filename, True).decode(preferredencoding())\n            return sanitize_path(filename)\n        except ValueError as err:\n            self.report_error('Error in output template: ' + str(err) + ' (encoding: ' + repr(preferredencoding()) + ')')\n            return None",
            "import_list": [
                "import collections",
                "import re",
                "import sys",
                "import time",
                "from .utils import (\n    DEFAULT_OUTTMPL,\n    compat_numeric_types,\n    compat_str,\n    encodeFilename,\n    expand_path,\n    preferredencoding,\n    sanitize_filename,\n    sanitize_path,\n)",
                "import time"
            ]
        }
    ]
}