{
    "1.1.1": "def bracket_split_build_line(\n    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False\n) -> Line:\n    \n    result = Line(depth=original.depth)\n    if is_body:\n        result.inside_brackets = True\n        result.depth += 1\n        if leaves:\n            # Since body is a new indent level, remove spurious leading whitespace.\n            normalize_prefix(leaves[0], inside_brackets=True)\n            # Ensure a trailing comma when expected.\n            if original.is_import:\n                if leaves[-1].type != token.COMMA:\n                    leaves.append(Leaf(token.COMMA, \",\"))\n    # Populate the line\n    for leaf in leaves:\n        result.append(leaf, preformatted=True)\n        for comment_after in original.comments_after(leaf):\n            result.append(comment_after, preformatted=True)\n    if is_body:\n        result.should_explode = should_explode(result, opening_bracket)\n    return result\n",
    "1.1.2": "Return a new line with given `leaves` and respective comments from `original`.\n\nIf `is_body` is True, the result line is one-indented inside brackets and as such\nhas its first leaf's prefix normalized and a trailing comma added when expected.",
    "1.2.1": null,
    "1.2.2": null,
    "1.2.3": null,
    "1.2.4": null,
    "1.2.5": null,
    "1.3.1": "black.py",
    "1.3.2": [
        "is_import(leaf: Leaf) -> bool",
        "normalize_prefix(leaf: Leaf) -> None",
        "should_explode(line: Line, opening_bracket: Leaf) -> bool",
        "append(self, leaf: Leaf, preformatted: bool=False) -> None",
        "is_import(self) -> bool",
        "comments_after(self, leaf: Leaf) -> List[Leaf]"
    ],
    "1.4.1": [
        "    @patch(\"black.dump_to_file\", dump_to_stderr)\n    def test_comments7(self) -> None:\n        source, expected = read_data(\"comments7\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())"
    ],
    "1.4.2": [
        "tests/test_black.py"
    ],
    "2.1.1": [
        [
            "E   AssertionError: 'from[181 chars]ES,\\n)\\n\\n\\nfrom .config import (\\n    Any,\\n [179 chars]n)\\n' != 'from[181 chars]ES,\\n    ,\\n)\\n\\n\\nfrom .config import (\\n    [192 chars]n)\\n'\nE     from .config import (\nE         Any,\nE         Bool,\nE         ConfigType,\nE         ConfigTypeAttributes,\nE         Int,\nE         Path,\nE         #  String,\nE         #  resolve_to_config_type,\nE         #  DEFAULT_TYPE_ATTRIBUTES,\nE   +     ,\nE     )\nE     \nE     \nE     from .config import (\nE         Any,\nE         Bool,\nE         ConfigType,\nE         ConfigTypeAttributes,\nE         Int,\nE   -     no_comma_here_yet,\nE   ?                      -\nE   +     no_comma_here_yet\nE         #  and some comments,\nE         #  resolve_to_config_type,\nE         #  DEFAULT_TYPE_ATTRIBUTES,\nE   +     ,\nE     )"
        ]
    ],
    "2.1.2": [
        [
            "self = <test_black.BlackTestCase testMethod=test_comments7>\n\n    @patch(\"black.dump_to_file\", dump_to_stderr)\n    def test_comments7(self) -> None:\n        source, expected = read_data(\"comments7\")\n        actual = fs(source)\n>       self.assertFormatEqual(expected, actual)\n\ntests/test_black.py:395: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/test_black.py:159: in assertFormatEqual\n    self.assertEqual(expected, actual)"
        ]
    ],
    "2.1.3": [
        [
            {
                "original.depth": "0",
                "original": "Line(depth=0, leaves=[Leaf(NAM ... s=False, should_explode=False)",
                "is_body": "False",
                "leaves": "[Leaf(NAME, 'from'), Leaf(DOT, '.'), Leaf(NAME, 'config'), Leaf(NAME, 'import'), Leaf(LPAR, '')]",
                "original.is_import": "True",
                "original.comments_after": "<bound method Line.comments_af ... =False, should_explode=False)>",
                "opening_bracket": "Leaf(LPAR, '')"
            },
            {
                "result": "Line(depth=0, leaves=[Leaf(NAME, 'from'), Leaf(DOT, '.'), Leaf(NAME, 'config'), Leaf(NAME, 'import'), Leaf(LPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)",
                "result.inside_brackets": "False",
                "result.depth": "0",
                "leaf": "Leaf(LPAR, '')",
                "result.append": "<bound method Line.append of Line(depth=0, leaves=[Leaf(NAME, 'from'), Leaf(DOT, '.'), Leaf(NAME, 'config'), Leaf(NAME, 'import'), Leaf(LPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)>",
                "result.should_explode": "False"
            }
        ],
        [
            {
                "original.depth": "0",
                "original": "Line(depth=0, leaves=[Leaf(NAM ... s=False, should_explode=False)",
                "is_body": "True",
                "leaves": "[Leaf(NAME, 'Any'), Leaf(COMMA, ','), Leaf(NAME, 'Bool'), Leaf(COMMA, ','), Leaf(NAME, 'ConfigType'), Leaf(COMMA, ','), Leaf(NAME, 'ConfigTypeAttributes'), Leaf(COMMA, ','), Leaf(NAME, 'Int'), Leaf(COMMA, ','), Leaf(NAME, 'Path'), Leaf(COMMA, ','), Leaf(STANDALONE_COMMENT, '#  String,'), Leaf(STANDALONE_COMMENT, '#  resolve_to_config_type,'), Leaf(STANDALONE_COMMENT, '#  DEFAULT_TYPE_ATTRIBUTES,')]",
                "original.is_import": "True",
                "original.comments_after": "<bound method Line.comments_af ... =False, should_explode=False)>",
                "opening_bracket": "Leaf(LPAR, '')"
            },
            {
                "result": "Line(depth=1, leaves=[Leaf(NAM ... ets=True, should_explode=True)",
                "result.inside_brackets": "True",
                "result.depth": "1",
                "leaves": "[Leaf(NAME, 'Any'), Leaf(COMMA, ','), Leaf(NAME, 'Bool'), Leaf(COMMA, ','), Leaf(NAME, 'ConfigType'), Leaf(COMMA, ','), Leaf(NAME, 'ConfigTypeAttributes'), Leaf(COMMA, ','), Leaf(NAME, 'Int'), Leaf(COMMA, ','), Leaf(NAME, 'Path'), Leaf(COMMA, ','), Leaf(STANDALONE_COMMENT, '#  String,'), Leaf(STANDALONE_COMMENT, '#  resolve_to_config_type,'), Leaf(STANDALONE_COMMENT, '#  DEFAULT_TYPE_ATTRIBUTES,'), Leaf(COMMA, ',')]",
                "leaf": "Leaf(COMMA, ',')",
                "result.append": "<bound method Line.append of L ... ts=True, should_explode=True)>",
                "result.should_explode": "True"
            }
        ],
        [
            {
                "original.depth": "0",
                "original": "Line(depth=0, leaves=[Leaf(NAM ... s=False, should_explode=False)",
                "is_body": "False",
                "leaves": "[Leaf(RPAR, '')]",
                "original.is_import": "True",
                "original.comments_after": "<bound method Line.comments_af ... =False, should_explode=False)>",
                "opening_bracket": "Leaf(LPAR, '')"
            },
            {
                "result": "Line(depth=0, leaves=[Leaf(RPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)",
                "result.inside_brackets": "False",
                "result.depth": "0",
                "leaf": "Leaf(RPAR, '')",
                "result.append": "<bound method Line.append of Line(depth=0, leaves=[Leaf(RPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)>",
                "result.should_explode": "False"
            }
        ],
        [
            {
                "original.depth": "0",
                "original": "Line(depth=0, leaves=[Leaf(NAM ... s=False, should_explode=False)",
                "is_body": "False",
                "leaves": "[Leaf(NAME, 'from'), Leaf(DOT, '.'), Leaf(NAME, 'config'), Leaf(NAME, 'import'), Leaf(LPAR, '')]",
                "original.is_import": "True",
                "original.comments_after": "<bound method Line.comments_af ... =False, should_explode=False)>",
                "opening_bracket": "Leaf(LPAR, '')"
            },
            {
                "result": "Line(depth=0, leaves=[Leaf(NAME, 'from'), Leaf(DOT, '.'), Leaf(NAME, 'config'), Leaf(NAME, 'import'), Leaf(LPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)",
                "result.inside_brackets": "False",
                "result.depth": "0",
                "leaf": "Leaf(LPAR, '')",
                "result.append": "<bound method Line.append of Line(depth=0, leaves=[Leaf(NAME, 'from'), Leaf(DOT, '.'), Leaf(NAME, 'config'), Leaf(NAME, 'import'), Leaf(LPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)>",
                "result.should_explode": "False"
            }
        ],
        [
            {
                "original.depth": "0",
                "original": "Line(depth=0, leaves=[Leaf(NAM ... s=False, should_explode=False)",
                "is_body": "True",
                "leaves": "[Leaf(NAME, 'Any'), Leaf(COMMA, ','), Leaf(NAME, 'Bool'), Leaf(COMMA, ','), Leaf(NAME, 'ConfigType'), Leaf(COMMA, ','), Leaf(NAME, 'ConfigTypeAttributes'), Leaf(COMMA, ','), Leaf(NAME, 'Int'), Leaf(COMMA, ','), Leaf(NAME, 'no_comma_here_yet'), Leaf(STANDALONE_COMMENT, '#  and some comments,'), Leaf(STANDALONE_COMMENT, '#  resolve_to_config_type,'), Leaf(STANDALONE_COMMENT, '#  DEFAULT_TYPE_ATTRIBUTES,')]",
                "original.is_import": "True",
                "original.comments_after": "<bound method Line.comments_af ... =False, should_explode=False)>",
                "opening_bracket": "Leaf(LPAR, '')"
            },
            {
                "result": "Line(depth=1, leaves=[Leaf(NAM ... ets=True, should_explode=True)",
                "result.inside_brackets": "True",
                "result.depth": "1",
                "leaves": "[Leaf(NAME, 'Any'), Leaf(COMMA, ','), Leaf(NAME, 'Bool'), Leaf(COMMA, ','), Leaf(NAME, 'ConfigType'), Leaf(COMMA, ','), Leaf(NAME, 'ConfigTypeAttributes'), Leaf(COMMA, ','), Leaf(NAME, 'Int'), Leaf(COMMA, ','), Leaf(NAME, 'no_comma_here_yet'), Leaf(STANDALONE_COMMENT, '#  and some comments,'), Leaf(STANDALONE_COMMENT, '#  resolve_to_config_type,'), Leaf(STANDALONE_COMMENT, '#  DEFAULT_TYPE_ATTRIBUTES,'), Leaf(COMMA, ',')]",
                "leaf": "Leaf(COMMA, ',')",
                "result.append": "<bound method Line.append of L ... ts=True, should_explode=True)>",
                "result.should_explode": "True"
            }
        ],
        [
            {
                "original.depth": "0",
                "original": "Line(depth=0, leaves=[Leaf(NAM ... s=False, should_explode=False)",
                "is_body": "False",
                "leaves": "[Leaf(RPAR, '')]",
                "original.is_import": "True",
                "original.comments_after": "<bound method Line.comments_af ... =False, should_explode=False)>",
                "opening_bracket": "Leaf(LPAR, '')"
            },
            {
                "result": "Line(depth=0, leaves=[Leaf(RPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)",
                "result.inside_brackets": "False",
                "result.depth": "0",
                "leaf": "Leaf(RPAR, '')",
                "result.append": "<bound method Line.append of Line(depth=0, leaves=[Leaf(RPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)>",
                "result.should_explode": "False"
            }
        ]
    ],
    "2.1.4": [
        [
            {
                "original.depth": "int",
                "original": "Line",
                "is_body": "bool",
                "leaves": "list",
                "original.is_import": "bool",
                "original.comments_after": "method",
                "opening_bracket": "Leaf"
            },
            {
                "result": "Line",
                "result.inside_brackets": "bool",
                "result.depth": "int",
                "leaf": "Leaf",
                "result.append": "method",
                "result.should_explode": "bool"
            }
        ],
        [
            {
                "original.depth": "int",
                "original": "Line",
                "is_body": "bool",
                "leaves": "list",
                "original.is_import": "bool",
                "original.comments_after": "method",
                "opening_bracket": "Leaf"
            },
            {
                "result": "Line",
                "result.inside_brackets": "bool",
                "result.depth": "int",
                "leaves": "list",
                "leaf": "Leaf",
                "result.append": "method",
                "result.should_explode": "bool"
            }
        ],
        [
            {
                "original.depth": "int",
                "original": "Line",
                "is_body": "bool",
                "leaves": "list",
                "original.is_import": "bool",
                "original.comments_after": "method",
                "opening_bracket": "Leaf"
            },
            {
                "result": "Line",
                "result.inside_brackets": "bool",
                "result.depth": "int",
                "leaf": "Leaf",
                "result.append": "method",
                "result.should_explode": "bool"
            }
        ],
        [
            {
                "original.depth": "int",
                "original": "Line",
                "is_body": "bool",
                "leaves": "list",
                "original.is_import": "bool",
                "original.comments_after": "method",
                "opening_bracket": "Leaf"
            },
            {
                "result": "Line",
                "result.inside_brackets": "bool",
                "result.depth": "int",
                "leaf": "Leaf",
                "result.append": "method",
                "result.should_explode": "bool"
            }
        ],
        [
            {
                "original.depth": "int",
                "original": "Line",
                "is_body": "bool",
                "leaves": "list",
                "original.is_import": "bool",
                "original.comments_after": "method",
                "opening_bracket": "Leaf"
            },
            {
                "result": "Line",
                "result.inside_brackets": "bool",
                "result.depth": "int",
                "leaves": "list",
                "leaf": "Leaf",
                "result.append": "method",
                "result.should_explode": "bool"
            }
        ],
        [
            {
                "original.depth": "int",
                "original": "Line",
                "is_body": "bool",
                "leaves": "list",
                "original.is_import": "bool",
                "original.comments_after": "method",
                "opening_bracket": "Leaf"
            },
            {
                "result": "Line",
                "result.inside_brackets": "bool",
                "result.depth": "int",
                "leaf": "Leaf",
                "result.append": "method",
                "result.should_explode": "bool"
            }
        ]
    ],
    "2.1.5": [
        [
            {
                "original.depth": "0",
                "original": "Line(depth=0, leaves=[Leaf(NAM ... s=False, should_explode=False)",
                "is_body": "False",
                "leaves": "[Leaf(NAME, 'from'), Leaf(DOT, '.'), Leaf(NAME, 'config'), Leaf(NAME, 'import'), Leaf(LPAR, '')]",
                "original.is_import": "True",
                "original.comments_after": "<bound method Line.comments_af ... =False, should_explode=False)>",
                "opening_bracket": "Leaf(LPAR, '')"
            },
            {
                "result": "Line(depth=0, leaves=[Leaf(NAME, 'from'), Leaf(DOT, '.'), Leaf(NAME, 'config'), Leaf(NAME, 'import'), Leaf(LPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)",
                "result.inside_brackets": "False",
                "result.depth": "0",
                "leaf": "Leaf(LPAR, '')",
                "result.append": "<bound method Line.append of Line(depth=0, leaves=[Leaf(NAME, 'from'), Leaf(DOT, '.'), Leaf(NAME, 'config'), Leaf(NAME, 'import'), Leaf(LPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)>",
                "result.should_explode": "False"
            }
        ],
        [
            {
                "original.depth": "0",
                "original": "Line(depth=0, leaves=[Leaf(NAM ... s=False, should_explode=False)",
                "is_body": "True",
                "leaves": "[Leaf(NAME, 'Any'), Leaf(COMMA, ','), Leaf(NAME, 'Bool'), Leaf(COMMA, ','), Leaf(NAME, 'ConfigType'), Leaf(COMMA, ','), Leaf(NAME, 'ConfigTypeAttributes'), Leaf(COMMA, ','), Leaf(NAME, 'Int'), Leaf(COMMA, ','), Leaf(NAME, 'Path'), Leaf(COMMA, ','), Leaf(STANDALONE_COMMENT, '#  String,'), Leaf(STANDALONE_COMMENT, '#  resolve_to_config_type,'), Leaf(STANDALONE_COMMENT, '#  DEFAULT_TYPE_ATTRIBUTES,')]",
                "original.is_import": "True",
                "original.comments_after": "<bound method Line.comments_af ... =False, should_explode=False)>",
                "opening_bracket": "Leaf(LPAR, '')"
            },
            {
                "result": "Line(depth=1, leaves=[Leaf(NAM ... ets=True, should_explode=True)",
                "result.inside_brackets": "True",
                "result.depth": "1",
                "i": "11",
                "leaf": "Leaf(STANDALONE_COMMENT, '#  DEFAULT_TYPE_ATTRIBUTES,')",
                "result.append": "<bound method Line.append of L ... ts=True, should_explode=True)>",
                "result.should_explode": "True"
            }
        ],
        [
            {
                "original.depth": "0",
                "original": "Line(depth=0, leaves=[Leaf(NAM ... s=False, should_explode=False)",
                "is_body": "False",
                "leaves": "[Leaf(RPAR, '')]",
                "original.is_import": "True",
                "original.comments_after": "<bound method Line.comments_af ... =False, should_explode=False)>",
                "opening_bracket": "Leaf(LPAR, '')"
            },
            {
                "result": "Line(depth=0, leaves=[Leaf(RPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)",
                "result.inside_brackets": "False",
                "result.depth": "0",
                "leaf": "Leaf(RPAR, '')",
                "result.append": "<bound method Line.append of Line(depth=0, leaves=[Leaf(RPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)>",
                "result.should_explode": "False"
            }
        ],
        [
            {
                "original.depth": "0",
                "original": "Line(depth=0, leaves=[Leaf(NAM ... s=False, should_explode=False)",
                "is_body": "False",
                "leaves": "[Leaf(NAME, 'from'), Leaf(DOT, '.'), Leaf(NAME, 'config'), Leaf(NAME, 'import'), Leaf(LPAR, '')]",
                "original.is_import": "True",
                "original.comments_after": "<bound method Line.comments_af ... =False, should_explode=False)>",
                "opening_bracket": "Leaf(LPAR, '')"
            },
            {
                "result": "Line(depth=0, leaves=[Leaf(NAME, 'from'), Leaf(DOT, '.'), Leaf(NAME, 'config'), Leaf(NAME, 'import'), Leaf(LPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)",
                "result.inside_brackets": "False",
                "result.depth": "0",
                "leaf": "Leaf(LPAR, '')",
                "result.append": "<bound method Line.append of Line(depth=0, leaves=[Leaf(NAME, 'from'), Leaf(DOT, '.'), Leaf(NAME, 'config'), Leaf(NAME, 'import'), Leaf(LPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)>",
                "result.should_explode": "False"
            }
        ],
        [
            {
                "original.depth": "0",
                "original": "Line(depth=0, leaves=[Leaf(NAM ... s=False, should_explode=False)",
                "is_body": "True",
                "leaves": "[Leaf(NAME, 'Any'), Leaf(COMMA, ','), Leaf(NAME, 'Bool'), Leaf(COMMA, ','), Leaf(NAME, 'ConfigType'), Leaf(COMMA, ','), Leaf(NAME, 'ConfigTypeAttributes'), Leaf(COMMA, ','), Leaf(NAME, 'Int'), Leaf(COMMA, ','), Leaf(NAME, 'no_comma_here_yet'), Leaf(STANDALONE_COMMENT, '#  and some comments,'), Leaf(STANDALONE_COMMENT, '#  resolve_to_config_type,'), Leaf(STANDALONE_COMMENT, '#  DEFAULT_TYPE_ATTRIBUTES,')]",
                "original.is_import": "True",
                "original.comments_after": "<bound method Line.comments_af ... =False, should_explode=False)>",
                "opening_bracket": "Leaf(LPAR, '')"
            },
            {
                "result": "Line(depth=1, leaves=[Leaf(NAM ... ets=True, should_explode=True)",
                "result.inside_brackets": "True",
                "result.depth": "1",
                "leaves": "[Leaf(NAME, 'Any'), Leaf(COMMA, ','), Leaf(NAME, 'Bool'), Leaf(COMMA, ','), Leaf(NAME, 'ConfigType'), Leaf(COMMA, ','), Leaf(NAME, 'ConfigTypeAttributes'), Leaf(COMMA, ','), Leaf(NAME, 'Int'), Leaf(COMMA, ','), Leaf(NAME, 'no_comma_here_yet'), Leaf(COMMA, ','), Leaf(STANDALONE_COMMENT, '#  and some comments,'), Leaf(STANDALONE_COMMENT, '#  resolve_to_config_type,'), Leaf(STANDALONE_COMMENT, '#  DEFAULT_TYPE_ATTRIBUTES,')]",
                "i": "10",
                "leaf": "Leaf(STANDALONE_COMMENT, '#  DEFAULT_TYPE_ATTRIBUTES,')",
                "result.append": "<bound method Line.append of L ... ts=True, should_explode=True)>",
                "result.should_explode": "True"
            }
        ],
        [
            {
                "original.depth": "0",
                "original": "Line(depth=0, leaves=[Leaf(NAM ... s=False, should_explode=False)",
                "is_body": "False",
                "leaves": "[Leaf(RPAR, '')]",
                "original.is_import": "True",
                "original.comments_after": "<bound method Line.comments_af ... =False, should_explode=False)>",
                "opening_bracket": "Leaf(LPAR, '')"
            },
            {
                "result": "Line(depth=0, leaves=[Leaf(RPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)",
                "result.inside_brackets": "False",
                "result.depth": "0",
                "leaf": "Leaf(RPAR, '')",
                "result.append": "<bound method Line.append of Line(depth=0, leaves=[Leaf(RPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)>",
                "result.should_explode": "False"
            }
        ],
        [
            {
                "original.depth": "0",
                "original": "Line(depth=0, leaves=[Leaf(NAM ... s=False, should_explode=False)",
                "is_body": "False",
                "leaves": "[Leaf(NAME, 'from'), Leaf(DOT, '.'), Leaf(NAME, 'config'), Leaf(NAME, 'import'), Leaf(LPAR, '')]",
                "original.is_import": "True",
                "original.comments_after": "<bound method Line.comments_af ... =False, should_explode=False)>",
                "opening_bracket": "Leaf(LPAR, '')"
            },
            {
                "result": "Line(depth=0, leaves=[Leaf(NAME, 'from'), Leaf(DOT, '.'), Leaf(NAME, 'config'), Leaf(NAME, 'import'), Leaf(LPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)",
                "result.inside_brackets": "False",
                "result.depth": "0",
                "leaf": "Leaf(LPAR, '')",
                "result.append": "<bound method Line.append of Line(depth=0, leaves=[Leaf(NAME, 'from'), Leaf(DOT, '.'), Leaf(NAME, 'config'), Leaf(NAME, 'import'), Leaf(LPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)>",
                "result.should_explode": "False"
            }
        ],
        [
            {
                "original.depth": "0",
                "original": "Line(depth=0, leaves=[Leaf(NAM ... s=False, should_explode=False)",
                "is_body": "True",
                "leaves": "[Leaf(NAME, 'Any'), Leaf(COMMA, ','), Leaf(NAME, 'Bool'), Leaf(COMMA, ','), Leaf(NAME, 'ConfigType'), Leaf(COMMA, ','), Leaf(NAME, 'ConfigTypeAttributes'), Leaf(COMMA, ','), Leaf(NAME, 'Int'), Leaf(COMMA, ','), Leaf(NAME, 'Path'), Leaf(COMMA, ','), Leaf(STANDALONE_COMMENT, '#  String,'), Leaf(STANDALONE_COMMENT, '#  resolve_to_config_type,'), Leaf(STANDALONE_COMMENT, '#  DEFAULT_TYPE_ATTRIBUTES,')]",
                "original.is_import": "True",
                "original.comments_after": "<bound method Line.comments_af ... =False, should_explode=False)>",
                "opening_bracket": "Leaf(LPAR, '')"
            },
            {
                "result": "Line(depth=1, leaves=[Leaf(NAM ... ets=True, should_explode=True)",
                "result.inside_brackets": "True",
                "result.depth": "1",
                "i": "11",
                "leaf": "Leaf(STANDALONE_COMMENT, '#  DEFAULT_TYPE_ATTRIBUTES,')",
                "result.append": "<bound method Line.append of L ... ts=True, should_explode=True)>",
                "result.should_explode": "True"
            }
        ],
        [
            {
                "original.depth": "0",
                "original": "Line(depth=0, leaves=[Leaf(NAM ... s=False, should_explode=False)",
                "is_body": "False",
                "leaves": "[Leaf(RPAR, '')]",
                "original.is_import": "True",
                "original.comments_after": "<bound method Line.comments_af ... =False, should_explode=False)>",
                "opening_bracket": "Leaf(LPAR, '')"
            },
            {
                "result": "Line(depth=0, leaves=[Leaf(RPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)",
                "result.inside_brackets": "False",
                "result.depth": "0",
                "leaf": "Leaf(RPAR, '')",
                "result.append": "<bound method Line.append of Line(depth=0, leaves=[Leaf(RPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)>",
                "result.should_explode": "False"
            }
        ],
        [
            {
                "original.depth": "0",
                "original": "Line(depth=0, leaves=[Leaf(NAM ... s=False, should_explode=False)",
                "is_body": "False",
                "leaves": "[Leaf(NAME, 'from'), Leaf(DOT, '.'), Leaf(NAME, 'config'), Leaf(NAME, 'import'), Leaf(LPAR, '')]",
                "original.is_import": "True",
                "original.comments_after": "<bound method Line.comments_af ... =False, should_explode=False)>",
                "opening_bracket": "Leaf(LPAR, '')"
            },
            {
                "result": "Line(depth=0, leaves=[Leaf(NAME, 'from'), Leaf(DOT, '.'), Leaf(NAME, 'config'), Leaf(NAME, 'import'), Leaf(LPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)",
                "result.inside_brackets": "False",
                "result.depth": "0",
                "leaf": "Leaf(LPAR, '')",
                "result.append": "<bound method Line.append of Line(depth=0, leaves=[Leaf(NAME, 'from'), Leaf(DOT, '.'), Leaf(NAME, 'config'), Leaf(NAME, 'import'), Leaf(LPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)>",
                "result.should_explode": "False"
            }
        ],
        [
            {
                "original.depth": "0",
                "original": "Line(depth=0, leaves=[Leaf(NAM ... s=False, should_explode=False)",
                "is_body": "True",
                "leaves": "[Leaf(NAME, 'Any'), Leaf(COMMA, ','), Leaf(NAME, 'Bool'), Leaf(COMMA, ','), Leaf(NAME, 'ConfigType'), Leaf(COMMA, ','), Leaf(NAME, 'ConfigTypeAttributes'), Leaf(COMMA, ','), Leaf(NAME, 'Int'), Leaf(COMMA, ','), Leaf(NAME, 'no_comma_here_yet'), Leaf(COMMA, ','), Leaf(STANDALONE_COMMENT, '#  and some comments,'), Leaf(STANDALONE_COMMENT, '#  resolve_to_config_type,'), Leaf(STANDALONE_COMMENT, '#  DEFAULT_TYPE_ATTRIBUTES,')]",
                "original.is_import": "True",
                "original.comments_after": "<bound method Line.comments_af ... =False, should_explode=False)>",
                "opening_bracket": "Leaf(LPAR, '')"
            },
            {
                "result": "Line(depth=1, leaves=[Leaf(NAM ... ets=True, should_explode=True)",
                "result.inside_brackets": "True",
                "result.depth": "1",
                "i": "11",
                "leaf": "Leaf(STANDALONE_COMMENT, '#  DEFAULT_TYPE_ATTRIBUTES,')",
                "result.append": "<bound method Line.append of L ... ts=True, should_explode=True)>",
                "result.should_explode": "True"
            }
        ],
        [
            {
                "original.depth": "0",
                "original": "Line(depth=0, leaves=[Leaf(NAM ... s=False, should_explode=False)",
                "is_body": "False",
                "leaves": "[Leaf(RPAR, '')]",
                "original.is_import": "True",
                "original.comments_after": "<bound method Line.comments_af ... =False, should_explode=False)>",
                "opening_bracket": "Leaf(LPAR, '')"
            },
            {
                "result": "Line(depth=0, leaves=[Leaf(RPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)",
                "result.inside_brackets": "False",
                "result.depth": "0",
                "leaf": "Leaf(RPAR, '')",
                "result.append": "<bound method Line.append of Line(depth=0, leaves=[Leaf(RPAR, '')], comments={}, bracket_tracker=BracketTracker(depth=0, bracket_match={}, delimiters={}, previous=None, _for_loop_depths=[], _lambda_argument_depths=[]), inside_brackets=False, should_explode=False)>",
                "result.should_explode": "False"
            }
        ]
    ],
    "2.1.6": [
        [
            {
                "original.depth": "int",
                "original": "Line",
                "is_body": "bool",
                "leaves": "list",
                "original.is_import": "bool",
                "original.comments_after": "method",
                "opening_bracket": "Leaf"
            },
            {
                "result": "Line",
                "result.inside_brackets": "bool",
                "result.depth": "int",
                "leaf": "Leaf",
                "result.append": "method",
                "result.should_explode": "bool"
            }
        ],
        [
            {
                "original.depth": "int",
                "original": "Line",
                "is_body": "bool",
                "leaves": "list",
                "original.is_import": "bool",
                "original.comments_after": "method",
                "opening_bracket": "Leaf"
            },
            {
                "result": "Line",
                "result.inside_brackets": "bool",
                "result.depth": "int",
                "i": "int",
                "leaf": "Leaf",
                "result.append": "method",
                "result.should_explode": "bool"
            }
        ],
        [
            {
                "original.depth": "int",
                "original": "Line",
                "is_body": "bool",
                "leaves": "list",
                "original.is_import": "bool",
                "original.comments_after": "method",
                "opening_bracket": "Leaf"
            },
            {
                "result": "Line",
                "result.inside_brackets": "bool",
                "result.depth": "int",
                "leaf": "Leaf",
                "result.append": "method",
                "result.should_explode": "bool"
            }
        ],
        [
            {
                "original.depth": "int",
                "original": "Line",
                "is_body": "bool",
                "leaves": "list",
                "original.is_import": "bool",
                "original.comments_after": "method",
                "opening_bracket": "Leaf"
            },
            {
                "result": "Line",
                "result.inside_brackets": "bool",
                "result.depth": "int",
                "leaf": "Leaf",
                "result.append": "method",
                "result.should_explode": "bool"
            }
        ],
        [
            {
                "original.depth": "int",
                "original": "Line",
                "is_body": "bool",
                "leaves": "list",
                "original.is_import": "bool",
                "original.comments_after": "method",
                "opening_bracket": "Leaf"
            },
            {
                "result": "Line",
                "result.inside_brackets": "bool",
                "result.depth": "int",
                "leaves": "list",
                "i": "int",
                "leaf": "Leaf",
                "result.append": "method",
                "result.should_explode": "bool"
            }
        ],
        [
            {
                "original.depth": "int",
                "original": "Line",
                "is_body": "bool",
                "leaves": "list",
                "original.is_import": "bool",
                "original.comments_after": "method",
                "opening_bracket": "Leaf"
            },
            {
                "result": "Line",
                "result.inside_brackets": "bool",
                "result.depth": "int",
                "leaf": "Leaf",
                "result.append": "method",
                "result.should_explode": "bool"
            }
        ],
        [
            {
                "original.depth": "int",
                "original": "Line",
                "is_body": "bool",
                "leaves": "list",
                "original.is_import": "bool",
                "original.comments_after": "method",
                "opening_bracket": "Leaf"
            },
            {
                "result": "Line",
                "result.inside_brackets": "bool",
                "result.depth": "int",
                "leaf": "Leaf",
                "result.append": "method",
                "result.should_explode": "bool"
            }
        ],
        [
            {
                "original.depth": "int",
                "original": "Line",
                "is_body": "bool",
                "leaves": "list",
                "original.is_import": "bool",
                "original.comments_after": "method",
                "opening_bracket": "Leaf"
            },
            {
                "result": "Line",
                "result.inside_brackets": "bool",
                "result.depth": "int",
                "i": "int",
                "leaf": "Leaf",
                "result.append": "method",
                "result.should_explode": "bool"
            }
        ],
        [
            {
                "original.depth": "int",
                "original": "Line",
                "is_body": "bool",
                "leaves": "list",
                "original.is_import": "bool",
                "original.comments_after": "method",
                "opening_bracket": "Leaf"
            },
            {
                "result": "Line",
                "result.inside_brackets": "bool",
                "result.depth": "int",
                "leaf": "Leaf",
                "result.append": "method",
                "result.should_explode": "bool"
            }
        ],
        [
            {
                "original.depth": "int",
                "original": "Line",
                "is_body": "bool",
                "leaves": "list",
                "original.is_import": "bool",
                "original.comments_after": "method",
                "opening_bracket": "Leaf"
            },
            {
                "result": "Line",
                "result.inside_brackets": "bool",
                "result.depth": "int",
                "leaf": "Leaf",
                "result.append": "method",
                "result.should_explode": "bool"
            }
        ],
        [
            {
                "original.depth": "int",
                "original": "Line",
                "is_body": "bool",
                "leaves": "list",
                "original.is_import": "bool",
                "original.comments_after": "method",
                "opening_bracket": "Leaf"
            },
            {
                "result": "Line",
                "result.inside_brackets": "bool",
                "result.depth": "int",
                "i": "int",
                "leaf": "Leaf",
                "result.append": "method",
                "result.should_explode": "bool"
            }
        ],
        [
            {
                "original.depth": "int",
                "original": "Line",
                "is_body": "bool",
                "leaves": "list",
                "original.is_import": "bool",
                "original.comments_after": "method",
                "opening_bracket": "Leaf"
            },
            {
                "result": "Line",
                "result.inside_brackets": "bool",
                "result.depth": "int",
                "leaf": "Leaf",
                "result.append": "method",
                "result.should_explode": "bool"
            }
        ]
    ],
    "3.1.1": [
        "Black produces invalid code with commented out multi-line includes\n"
    ],
    "3.1.2": [
        "Howdy! Sorry you're having trouble. To expedite your experience,\nprovide some basics for me:\n\nOperating system: MacOS\nPython version: Python 3.7.1\nBlack version: 18.9b0\nDoes also happen on master: Yes\n\nrepro:\n\n(black-repro) [schrockn@mbp ~/code/playground/black_bug_repro]$ black test.py\nerror: cannot format test.py: INTERNAL ERROR: Black produced invalid code: invalid syntax (<unknown>, line 11). Please report a bug on https://github.com/ambv/black/issues.  This invalid output might be helpful: /var/folders/nb/18_t4vkx595_cnpf8nz5gt_80000gn/T/blk_di3puv3v.log\nAll done! \ud83d\udca5 \ud83d\udc94 \ud83d\udca5\n1 file failed to reformat.\ntest file:\n\nfrom .config import (\n    Any,\n    Bool,\n    ConfigType,\n    ConfigTypeAttributes,\n    Int,\n    Path,\n    #  String,\n    #  resolve_to_config_type,\n    #  DEFAULT_TYPE_ATTRIBUTES,\n)\nThe invalid output:\n\n(black-repro) [schrockn@mbp ~/code/playground/black_bug_repro]$ more /var/folders/nb/18_t4vkx595_cnpf8nz5gt_80000gn/T/blk_di3puv3v.log\n  File \"/Users/schrockn/code/githubs/black/black.py\", line 3318, in assert_equivalent\n    dst_ast = ast.parse(dst)\n  File \"/Users/schrockn/.pyenv/versions/3.7.1/lib/python3.7/ast.py\", line 35, in parse\n    return compile(source, filename, mode, PyCF_ONLY_AST)\nfrom .config import (\n    Any,\n    Bool,\n    ConfigType,\n    ConfigTypeAttributes,\n    Int,\n    Path,\n    #  String,\n    #  resolve_to_config_type,\n    #  DEFAULT_TYPE_ATTRIBUTES,\n    ,\n)\nThanks!\n"
    ]
}