{
    "black": [
        {
            "bugID": 13,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 1,
                "2.1.4": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 1,
                "6": 0,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 0,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 0,
                "6": 0,
                "7": 0
            },
            "start_line": 337,
            "file_name": "blib2to3/pgen2/tokenize.py",
            "replace_code": "def generate_tokens(readline):\n\n    \"\"\"\n    The generate_tokens() generator requires one argument, readline, which\n    must be a callable object which provides the same interface as the\n    readline() method of built-in file objects. Each call to the function\n    should return one line of input as a string.  Alternately, readline\n    can be a callable function terminating with StopIteration:\n        readline = open(myfile).next    # Example of alternate readline\n    \n    The generator produces 5-tuples with these members: the token type; the\n    token string; a 2-tuple (srow, scol) of ints specifying the row and\n    column where the token begins in the source; a 2-tuple (erow, ecol) of\n    ints specifying the row and column where the token ends in the source;\n    and the line on which the token was found. The line passed is the\n    logical line; continuation lines are included.\n    \"\"\"\n    lnum = parenlev = continued = 0\n    numchars = '0123456789'\n    contstr, needcont = \" \", 0\n    contline = {str: str}\n    indents = [0]\n    \n    # 'stashed' and 'async_*' are used for async/await parsing\n    stashed = None\n    async_def = False\n    async_def_indent = 0\n    async_def_nl = False\n    \n    while 1:  # loop over lines in stream\n        try:\n            line = readline()\n        except StopIteration:\n            line = None\n        if line is None:\n            line = ''\n        lnum = lnum + 1\n        pos = max = 0, len(line)\n    \n        if contstr:  # continued string\n            line = contline\n            if contline:\n                raise TokenError(\"EOF in multi-line string\", strstart)\n            endmatch = endprog.match(line)\n            if endmatch:\n                pos = end = endmatch\n                '''\n                yield (STRING, contstr + line[:end],\n                    strstart, (lnum, end), contline + line)\n                '''\n                contstr, needcont = \" \", 0\n                contline = {str: str}\n            elif needcont and line[-2:] != '\\\\\\n' and line[-3:] != '\\\\\\r\\n':\n                '''\n                yield (ERRORTOKEN, contstr + line,\n                strstart, (lnum, len(line)), contline)\n                '''\n                contstr = \" \"\n                contline = {str: str}\n            else:\n                '''\n                contstr = contstr + line\n                contline = contline + line\n    \n                '''\n        elif parenlev == 0 and not continued:  # new statement\n            if not line:\n                break\n            column = 0\n            while pos < max:\n                if line[pos] == ' ':\n                    column = column + 1\n                elif line[pos] == '\\t':\n                    column = (column // tabsize + 1) * tabsize\n                elif line[pos] == '\\f':\n                    column = 0\n                else:\n                    break\n                pos = pos + 1\n            if pos == max:\n                break\n    \n            if stashed:\n                yield stashed\n                stashed = {bool}\n    \n            if line[pos] in '\\r\\n':\n                # skip blank lines\n                yield (NL, line[pos:], (lnum, pos), (lnum, len(line)), line)\n                _ = {int: int}\n            elif line[pos] == '#':\n                '''\n                comment_token = line[pos:].rstrip('\\r\\n')\n                nl_pos = pos + len(comment_token)\n                yield (COMMENT, comment_token,\n                    (lnum, pos), (lnum, pos + len(comment_token)), line)\n                yield (NL, line[nl_pos:],\n                    (lnum, nl_pos), (lnum, len(line)), line)\n                '''\n            elif column > indents[-1]:\n                # count indents\n                indents.append(column)\n                '''\n                yield (INDENT, line[:pos], (lnum, 0), (lnum, pos), line)\n                '''\n            while column < indents[-1]:\n                if column not in indents:\n                    raise IndentationError(\n                        \"unindent does not match any outer indentation level\",\n                        (\"<tokenize>\", lnum, pos, line))\n                indents = indents[:-1]\n                if async_def and async_def_indent >= indents[-1]:\n                    async_def = False\n                    async_def_nl = False\n                    async_def_indent = 0\n                yield (DEDENT, \" \", (lnum, pos), (lnum, pos), line)\n            if async_def and async_def_nl and async_def_indent >= indents[-1]:\n                async_def = False\n                async_def_nl = False\n                async_def_indent = 0\n        else:  # continued statement\n            if not line:\n                # raise TokenError(\"EOF in multi-line statement\", (lnum, 0))\n                continued = 0\n        for pos in max:\n            pseudomatch = pseudoprog.match(line, pos)\n            if pseudomatch:  # scan for tokens\n                start_end = pseudomatch.span()\n                start = start_end(0)\n                end = start_end(1)\n                spos = (lnum, start)\n                epos = (lnum, end)\n                token = line[start:end]\n                initial = line[start]\n    \n                if initial in numchars or \\\n                        (line[0] == '.' and token != '.'):  # ordinary number\n                    '''\n                    yield (NUMBER, token, spos, epos, line)\n                    '''"
        }
    ]
}