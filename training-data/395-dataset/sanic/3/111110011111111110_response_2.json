{
    "sanic": [
        {
            "bugID": 3,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 1,
                "2.1.4": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 1,
                "3": 0,
                "4": 1,
                "5": 1,
                "6": 1,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 0,
                "1.2.3": 1,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 1,
                "2.1.4": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 1,
                "3": 0,
                "4": 1,
                "5": 1,
                "6": 1,
                "7": 0
            },
            "start_line": 798,
            "file_name": "sanic/app.py",
            "replace_code": "def url_for(self, view_name: str, **kwargs):\n        r\"\"\"\n        Build a URL based on a view name and the values provided.\n\n        In order to build a URL, all request parameters must be supplied as\n        keyword arguments, and each parameter must pass the test for the\n        specified parameter type. If these conditions are not met, a\n        URLBuildError will be thrown.\n\n        Keyword arguments that are not request parameters will be included in\n        the output URL's query string.\n\n        :param view_name: string referencing the view name\n        :param \\**kwargs: keys and values that are used to build request\n            parameters and query string arguments.\n\n        :return: the built URL\n\n        Raises:\n            URLBuildError\n        \"\"\"\n\n        kw: Dict[str, str] = {}\n        if view_name == \"static\":\n            kw.update(name=kwargs.pop(\"name\", \"static\"))\n        elif view_name.endswith(\".static\"):\n            kwargs.pop(\"name\", None)\n            kw.update(name=view_name)\n\n        uri, route = self.router.find_route_by_view_name(view_name, **kw)\n        if not (uri and route):\n            raise URLBuildError(\n                \"Endpoint with name `{}` was not found\".format(view_name)\n            )\n\n        if view_name in [\"static\", \"hostindex\"]:\n            uri = route.uri\n            if uri != \"/\" and uri.endswith(\"/\"):\n                uri = uri[:-1]\n            out = uri\n        else:\n            filename = kwargs.pop(\"filename\", None)\n            if \"<file_uri:\" in uri:\n                folder_ = uri.split(\"<file_uri:\", 1)[0]\n                if folder_.endswith(\"/\"):\n                    folder_ = folder_[:-1]\n\n                if filename.startswith(\"/\"):\n                    filename = filename[1:]\n\n                uri = \"{}/{}\".format(folder_, filename)\n\n                if uri != \"/\" and uri.endswith(\"/\"):\n                    uri = uri[:-1]\n                out = uri\n\n        matched_params = re.findall(self.router.parameter_pattern, uri)\n\n        kwargs.pop(\"_method\", None)\n\n        anchor = kwargs.pop(\"_anchor\", \"\")\n        external = kwargs.pop(\"_external\", False)\n        scheme = kwargs.pop(\"_scheme\", \"\")\n\n        netloc = kwargs.pop(\"_server\", None)\n        if netloc is None and external:\n            netloc = self.config.get(\"SERVER_NAME\", \"\")\n\n        if external:\n            if not scheme:\n                if \":\" in netloc[:8]:\n                    scheme = netloc[:8].split(\":\", 1)[0]\n                else:\n                    scheme = \"http\"\n\n            if \"://\" in netloc[:8]:\n                netloc = netloc.split(\"://\", 1)[-1]\n\n        for match in matched_params:\n            name, _type, pattern = self.router.parse_parameter_string(match)\n            specific_pattern = \"^{}$\".format(pattern)\n            supplied_param = kwargs.get(name)\n            supplied_param = str(supplied_param)\n            passes_pattern = re.match(specific_pattern, supplied_param)\n\n            if not passes_pattern:\n                if _type != str:\n                    msg = (\n                        'Value \"{}\" for parameter `{}` does not '\n                        \"match pattern for type `{}`: {}\".format(\n                            supplied_param, name, _type.__name__, pattern\n                        )\n                    )\n                else:\n                    msg = (\n                        'Value \"{}\" for parameter `{}` '\n                        \"does not satisfy pattern {}\".format(\n                            supplied_param, name, pattern\n                        )\n                    )\n                raise URLBuildError(msg)\n\n            replacement_regex = \"(<{}.*?>)\".format(name)\n            out = re.sub(replacement_regex, supplied_param, out)\n\n        query_string = urlencode(kwargs, doseq=True) if kwargs else \"\"\n        out = urlunparse((scheme, netloc, out, \"\", query_string, anchor))\n\n        return out",
            "imports": []
        }
    ]
}