# Error stack trace

```json
[
    [
        "self = <parameter_test.ParameterTest testMethod=test_local_insignificant_param>\n\n    def test_local_insignificant_param(self):\n        \"\"\" Ensure we have the same behavior as in before a78338c  \"\"\"\n        class MyTask(luigi.Task):\n            # This could typically be \"--num-threads=True\"\n            x = luigi.Parameter(significant=False)\n    \n>       MyTask('arg')\n\ntest/parameter_test.py:304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nluigi/task.py:103: in __call__\n    param_values = cls.get_param_values(params, args, kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncls = <class 'parameter_test.ParameterTest.test_local_insignificant_param.<locals>.MyTask'>\nparams = [('x', <luigi.parameter.Parameter object at 0x10400efa0>)]\nargs = ('arg',), kwargs = {}\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        \"\"\"\n        Get the values of the parameters from the args and kwargs.\n    \n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n        result = {}\n    \n        params_dict = dict(params)\n    \n        task_name = cls.task_family\n    \n        # In case any exceptions are thrown, create a helpful description of how the Task was invoked\n        # TODO: should we detect non-reprable arguments? These will lead to mysterious errors\n        exc_desc = '%s[args=%s, kwargs=%s]' % (task_name, args, kwargs)\n    \n        # Fill in the positional arguments\n        positional_params = [(n, p) for n, p in params if p.significant]\n        for i, arg in enumerate(args):\n            if i >= len(positional_params):\n>               raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))",
        "\nluigi/task.py:337: UnknownParameterException"
    ],
    [
        "self = <parameter_test.TestRemoveGlobalParameters testMethod=test_global_significant_param>\n\n    def test_global_significant_param(self):\n        \"\"\" We don't want any kind of global param to be positional \"\"\"\n        class MyTask(luigi.Task):\n            # This could typically be called \"--test-dry-run\"\n            x_g1 = luigi.Parameter(default='y', is_global=True, significant=True)\n    \n>       self.assertRaises(luigi.parameter.UnknownParameterException,\n                          lambda: MyTask('arg'))",
        "\ntest/parameter_test.py:428: AssertionError"
    ],
    [
        "self = <parameter_test.TestRemoveGlobalParameters testMethod=test_mixed_params>\n\n    def test_mixed_params(self):\n        \"\"\" Essentially for what broke in a78338c and was reported in #738 \"\"\"\n        class MyTask(luigi.Task):\n            # This could typically be \"--num-threads=True\"\n            x_g3 = luigi.Parameter(default='y', is_global=True)\n            local_param = luigi.Parameter()\n    \n>       MyTask('setting_local_param')\n\ntest/parameter_test.py:447: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nluigi/task.py:103: in __call__\n    param_values = cls.get_param_values(params, args, kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncls = <class 'parameter_test.TestRemoveGlobalParameters.test_mixed_params.<locals>.MyTask'>\nparams = [('x_g3', <luigi.parameter.Parameter object at 0x103ff6eb0>), ('local_param', <luigi.parameter.Parameter object at 0x103ff6f40>)]\nargs = ('setting_local_param',), kwargs = {}\n\n    @classmethod\n    def get_param_values(cls, params, args, kwargs):\n        \"\"\"\n        Get the values of the parameters from the args and kwargs.\n    \n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n        result = {}\n    \n        params_dict = dict(params)\n    \n        task_name = cls.task_family\n    \n        # In case any exceptions are thrown, create a helpful description of how the Task was invoked\n        # TODO: should we detect non-reprable arguments? These will lead to mysterious errors\n        exc_desc = '%s[args=%s, kwargs=%s]' % (task_name, args, kwargs)\n    \n        # Fill in the positional arguments\n        positional_params = [(n, p) for n, p in params if p.significant]\n        for i, arg in enumerate(args):\n            if i >= len(positional_params):\n                raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n            param_name, param_obj = positional_params[i]\n            result[param_name] = arg\n    \n        # Then the optional arguments\n        for param_name, arg in six.iteritems(kwargs):\n            if param_name in result:\n                raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n            if param_name not in params_dict:\n                raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n            result[param_name] = arg\n    \n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_task_value(task_name, param_name):\n>                   raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))",
        "\nluigi/task.py:353: MissingParameterException"
    ],
    [
        "self = <parameter_test.TestRemoveGlobalParameters testMethod=test_mixed_params_inheritence>\n\n    def test_mixed_params_inheritence(self):\n        \"\"\" A slightly more real-world like test case \"\"\"\n        class TaskWithOneGlobalParam(luigi.Task):\n            non_positional_param = luigi.Parameter(default='y', is_global=True)\n    \n        class TaskWithOnePositionalParam(TaskWithOneGlobalParam):\n            \"\"\" Try to mess with positional parameters by subclassing \"\"\"\n            only_positional_param = luigi.Parameter()\n    \n            def complete(self):\n                return True\n    \n        class PositionalParamsRequirer(luigi.Task):\n    \n            def requires(self):\n                return TaskWithOnePositionalParam('only_positional_value')\n    \n            def run(self):\n                pass\n    \n>       self.run_and_check(['PositionalParamsRequirer'])\n\ntest/parameter_test.py:469: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntest/parameter_test.py:367: in run_and_check\n    self.assertTrue(run_exit_status)"
    ]
]
```
