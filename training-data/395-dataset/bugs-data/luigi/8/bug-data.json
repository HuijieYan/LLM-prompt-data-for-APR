{
    "luigi:8": {
        "/Volumes/SSD2T/bgp_envs/repos/luigi_8/luigi/contrib/redshift.py": {
            "buggy_functions": [
                {
                    "function_name": "does_table_exist",
                    "function_code": "def does_table_exist(self, connection):\n    \"\"\"\n    Determine whether the table already exists.\n    \"\"\"\n\n    if '.' in self.table:\n        query = (\"select 1 as table_exists \"\n                 \"from information_schema.tables \"\n                 \"where table_schema = %s and table_name = %s limit 1\")\n    else:\n        query = (\"select 1 as table_exists \"\n                 \"from pg_table_def \"\n                 \"where tablename = %s limit 1\")\n    cursor = connection.cursor()\n    try:\n        cursor.execute(query, tuple(self.table.split('.')))\n        result = cursor.fetchone()\n        return bool(result)\n    finally:\n        cursor.close()\n",
                    "decorators": [],
                    "docstring": "Determine whether the table already exists.",
                    "start_line": 327,
                    "end_line": 346,
                    "variables": {
                        "self.table": [
                            332,
                            342
                        ],
                        "self": [
                            332,
                            342
                        ],
                        "query": [
                            337,
                            333,
                            342
                        ],
                        "cursor": [
                            346,
                            340,
                            342,
                            343
                        ],
                        "connection.cursor": [
                            340
                        ],
                        "connection": [
                            340
                        ],
                        "cursor.execute": [
                            342
                        ],
                        "tuple": [
                            342
                        ],
                        "self.table.split": [
                            342
                        ],
                        "result": [
                            344,
                            343
                        ],
                        "cursor.fetchone": [
                            343
                        ],
                        "bool": [
                            344
                        ],
                        "cursor.close": [
                            346
                        ]
                    },
                    "filtered_variables": {
                        "self.table": [
                            332,
                            342
                        ],
                        "self": [
                            332,
                            342
                        ],
                        "query": [
                            337,
                            333,
                            342
                        ],
                        "cursor": [
                            346,
                            340,
                            342,
                            343
                        ],
                        "connection.cursor": [
                            340
                        ],
                        "connection": [
                            340
                        ],
                        "cursor.execute": [
                            342
                        ],
                        "self.table.split": [
                            342
                        ],
                        "result": [
                            344,
                            343
                        ],
                        "cursor.fetchone": [
                            343
                        ],
                        "cursor.close": [
                            346
                        ]
                    },
                    "diff_line_number": 335,
                    "class_data": {
                        "signature": "class S3CopyToTable(rdbms.CopyToTable)",
                        "docstring": "Template task for inserting a data set into Redshift from s3.\n\nUsage:\n\n* Subclass and override the required attributes:\n\n  * `host`,\n  * `database`,\n  * `user`,\n  * `password`,\n  * `table`,\n  * `columns`,\n  * `aws_access_key_id`,\n  * `aws_secret_access_key`,\n  * `s3_load_path`.",
                        "constructor_docstring": null,
                        "functions": [
                            "@abc.abstractmethod\ndef s3_load_path(self):\n    \"\"\"\n    Override to return the load path.\n    \"\"\"\n    return None",
                            "@property\ndef aws_access_key_id(self):\n    \"\"\"\n    Override to return the key id.\n    \"\"\"\n    return None",
                            "@property\ndef aws_secret_access_key(self):\n    \"\"\"\n    Override to return the secret access key.\n    \"\"\"\n    return None",
                            "@property\ndef aws_account_id(self):\n    \"\"\"\n    Override to return the account id.\n    \"\"\"\n    return None",
                            "@property\ndef aws_arn_role_name(self):\n    \"\"\"\n    Override to return the arn role name.\n    \"\"\"\n    return None",
                            "@property\ndef aws_session_token(self):\n    \"\"\"\n    Override to return the session token.\n    \"\"\"\n    return None",
                            "@abc.abstractproperty\ndef copy_options(self):\n    \"\"\"\n    Add extra copy options, for example:\n\n    * TIMEFORMAT 'auto'\n    * IGNOREHEADER 1\n    * TRUNCATECOLUMNS\n    * IGNOREBLANKLINES\n    * DELIMITER '\t'\n    \"\"\"\n    return ''",
                            "@property\ndef prune_table(self):\n    \"\"\"\n    Override to set equal to the name of the table which is to be pruned.\n    Intended to be used in conjunction with prune_column and prune_date\n    i.e. copy to temp table, prune production table to prune_column with a date greater than prune_date, then insert into production table from temp table\n    \"\"\"\n    return None",
                            "@property\ndef prune_column(self):\n    \"\"\"\n    Override to set equal to the column of the prune_table which is to be compared\n    Intended to be used in conjunction with prune_table and prune_date\n    i.e. copy to temp table, prune production table to prune_column with a date greater than prune_date, then insert into production table from temp table\n    \"\"\"\n    return None",
                            "@property\ndef prune_date(self):\n    \"\"\"\n    Override to set equal to the date by which prune_column is to be compared\n    Intended to be used in conjunction with prune_table and prune_column\n    i.e. copy to temp table, prune production table to prune_column with a date greater than prune_date, then insert into production table from temp table\n    \"\"\"\n    return None",
                            "@property\ndef table_attributes(self):\n    \"\"\"\n    Add extra table attributes, for example:\n\n    DISTSTYLE KEY\n    DISTKEY (MY_FIELD)\n    SORTKEY (MY_FIELD_2, MY_FIELD_3)\n    \"\"\"\n    return ''",
                            "@property\ndef do_truncate_table(self):\n    \"\"\"\n    Return True if table should be truncated before copying new data in.\n    \"\"\"\n    return False",
                            "def do_prune(self):\n    \"\"\"\n    Return True if prune_table, prune_column, and prune_date are implemented.\n    If only a subset of prune variables are override, an exception is raised to remind the user to implement all or none.\n    Prune (data newer than prune_date deleted) before copying new data in.\n    \"\"\"\n    if self.prune_table and self.prune_column and self.prune_date:\n        return True\n    elif self.prune_table or self.prune_column or self.prune_date:\n        raise Exception('override zero or all prune variables')\n    else:\n        return False",
                            "@property\ndef table_type(self):\n    \"\"\"\n    Return table type (i.e. 'temp').\n    \"\"\"\n    return ''",
                            "@property\ndef queries(self):\n    \"\"\"\n    Override to return a list of queries to be executed in order.\n    \"\"\"\n    return []",
                            "def truncate_table(self, connection):\n    query = 'truncate %s' % self.table\n    cursor = connection.cursor()\n    try:\n        cursor.execute(query)\n    finally:\n        cursor.close()",
                            "def prune(self, connection):\n    query = 'delete from %s where %s >= %s' % (self.prune_table, self.prune_column, self.prune_date)\n    cursor = connection.cursor()\n    try:\n        cursor.execute(query)\n    finally:\n        cursor.close()",
                            "def create_table(self, connection):\n    \"\"\"\n    Override to provide code for creating the target table.\n\n    By default it will be created using types (optionally)\n    specified in columns.\n\n    If overridden, use the provided connection object for\n    setting up the table in order to create the table and\n    insert data using the same transaction.\n    \"\"\"\n    if len(self.columns[0]) == 1:\n        raise NotImplementedError('create_table() not implemented for %r and columns types not specified' % self.table)\n    elif len(self.columns[0]) == 2:\n        coldefs = ','.join(('{name} {type}'.format(name=name, type=type) for name, type in self.columns))\n        query = 'CREATE {type} TABLE {table} ({coldefs}) {table_attributes}'.format(type=self.table_type, table=self.table, coldefs=coldefs, table_attributes=self.table_attributes)\n        connection.cursor().execute(query)\n    else:\n        raise ValueError('create_table() found no columns for %r' % self.table)",
                            "def run(self):\n    \"\"\"\n    If the target table doesn't exist, self.create_table\n    will be called to attempt to create the table.\n    \"\"\"\n    if not self.table:\n        raise Exception('table need to be specified')\n    path = self.s3_load_path()\n    output = self.output()\n    connection = output.connect()\n    cursor = connection.cursor()\n    self.init_copy(connection)\n    self.copy(cursor, path)\n    self.post_copy(cursor)\n    output.touch(connection)\n    connection.commit()\n    connection.close()",
                            "def copy(self, cursor, f):\n    \"\"\"\n    Defines copying from s3 into redshift.\n\n    If both key-based and role-based credentials are provided, role-based will be used.\n    \"\"\"\n    if self.aws_account_id and self.aws_arn_role_name:\n        cred_str = 'aws_iam_role=arn:aws:iam::{id}:role/{role}'.format(id=self.aws_account_id, role=self.aws_arn_role_name)\n    elif self.aws_access_key_id and self.aws_secret_access_key:\n        cred_str = 'aws_access_key_id={key};aws_secret_access_key={secret}{opt}'.format(key=self.aws_access_key_id, secret=self.aws_secret_access_key, opt=';token={}'.format(self.aws_session_token) if self.aws_session_token else '')\n    else:\n        raise NotImplementedError(\"Missing Credentials. Override one of the following pairs of auth-args: 'aws_access_key_id' AND 'aws_secret_access_key' OR 'aws_account_id' AND 'aws_arn_role_name'\")\n    logger.info('Inserting file: %s', f)\n    cursor.execute(\"\\n         COPY {table} from '{source}'\\n         CREDENTIALS '{creds}'\\n         {options}\\n         ;\".format(table=self.table, source=f, creds=cred_str, options=self.copy_options))",
                            "def output(self):\n    \"\"\"\n    Returns a RedshiftTarget representing the inserted dataset.\n\n    Normally you don't override this.\n    \"\"\"\n    return RedshiftTarget(host=self.host, database=self.database, user=self.user, password=self.password, table=self.table, update_id=self.update_id)",
                            "def does_table_exist(self, connection):\n    \"\"\"\n    Determine whether the table already exists.\n    \"\"\"\n    if '.' in self.table:\n        query = 'select 1 as table_exists from information_schema.tables where table_schema = %s and table_name = %s limit 1'\n    else:\n        query = 'select 1 as table_exists from pg_table_def where tablename = %s limit 1'\n    cursor = connection.cursor()\n    try:\n        cursor.execute(query, tuple(self.table.split('.')))\n        result = cursor.fetchone()\n        return bool(result)\n    finally:\n        cursor.close()",
                            "def init_copy(self, connection):\n    \"\"\"\n    Perform pre-copy sql - such as creating table, truncating, or removing data older than x.\n    \"\"\"\n    if not self.does_table_exist(connection):\n        logger.info('Creating table %s', self.table)\n        connection.reset()\n        self.create_table(connection)\n    if self.do_truncate_table:\n        logger.info('Truncating table %s', self.table)\n        self.truncate_table(connection)\n    if self.do_prune():\n        logger.info('Removing %s older than %s from %s', self.prune_column, self.prune_date, self.prune_table)\n        self.prune(connection)",
                            "def post_copy(self, cursor):\n    \"\"\"\n    Performs post-copy sql - such as cleansing data, inserting into production table (if copied to temp table), etc.\n    \"\"\"\n    logger.info('Executing post copy queries')\n    for query in self.queries:\n        cursor.execute(query)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [],
                        "class_decorators": [],
                        "function_signatures": [
                            "s3_load_path(self)",
                            "aws_access_key_id(self)",
                            "aws_secret_access_key(self)",
                            "aws_account_id(self)",
                            "aws_arn_role_name(self)",
                            "aws_session_token(self)",
                            "copy_options(self)",
                            "prune_table(self)",
                            "prune_column(self)",
                            "prune_date(self)",
                            "table_attributes(self)",
                            "do_truncate_table(self)",
                            "do_prune(self)",
                            "table_type(self)",
                            "queries(self)",
                            "truncate_table(self, connection)",
                            "prune(self, connection)",
                            "create_table(self, connection)",
                            "run(self)",
                            "copy(self, cursor, f)",
                            "output(self)",
                            "does_table_exist(self, connection)",
                            "init_copy(self, connection)",
                            "post_copy(self, cursor)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "self.table": {
                                    "variable_value": "'dummy_schema.dummy_table'",
                                    "variable_type": "str",
                                    "variable_shape": "24"
                                },
                                "self": {
                                    "variable_value": "DummyS3CopyToTableKey(table=dummy_schema.dummy_table)",
                                    "variable_type": "DummyS3CopyToTableKey",
                                    "variable_shape": null
                                },
                                "query": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cursor": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "connection.cursor": {
                                    "variable_value": "<MagicMock name='RedshiftTarget().connect().cursor' id='4559550160'>",
                                    "variable_type": "MagicMock",
                                    "variable_shape": "<MagicMock name='RedshiftTarget().connect().cursor.shape' id='4559558112'>"
                                },
                                "connection": {
                                    "variable_value": "<MagicMock name='RedshiftTarget().connect()' id='4559538160'>",
                                    "variable_type": "MagicMock",
                                    "variable_shape": null
                                },
                                "cursor.execute": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.table.split": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cursor.fetchone": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cursor.close": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.table": {
                                    "variable_value": "'dummy_schema.dummy_table'",
                                    "variable_type": "str",
                                    "variable_shape": "24"
                                },
                                "self": {
                                    "variable_value": "DummyS3CopyToTableKey(table=dummy_schema.dummy_table)",
                                    "variable_type": "DummyS3CopyToTableKey",
                                    "variable_shape": null
                                },
                                "query": {
                                    "variable_value": "'select 1 as table_exists from information_schema.tables where table_schema = %s and table_name = %s limit 1'",
                                    "variable_type": "str",
                                    "variable_shape": "107"
                                },
                                "cursor": {
                                    "variable_value": "<MagicMock name='RedshiftTarget().connect().cursor()' id='4559566544'>",
                                    "variable_type": "MagicMock",
                                    "variable_shape": null
                                },
                                "connection.cursor": {
                                    "variable_value": "<MagicMock name='RedshiftTarget().connect().cursor' id='4559550160'>",
                                    "variable_type": "MagicMock",
                                    "variable_shape": "<MagicMock name='RedshiftTarget().connect().cursor.shape' id='4559558112'>"
                                },
                                "connection": {
                                    "variable_value": "<MagicMock name='RedshiftTarget().connect()' id='4559538160'>",
                                    "variable_type": "MagicMock",
                                    "variable_shape": null
                                },
                                "cursor.execute": {
                                    "variable_value": "<MagicMock name='RedshiftTarget().connect().cursor().execute' id='4559628320'>",
                                    "variable_type": "MagicMock",
                                    "variable_shape": "<MagicMock name='RedshiftTarget().connect().cursor().execute.shape' id='4559636272'>"
                                },
                                "self.table.split": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": "<MagicMock name='RedshiftTarget().connect().cursor().fetchone()' id='4559672272'>",
                                    "variable_type": "MagicMock",
                                    "variable_shape": null
                                },
                                "cursor.fetchone": {
                                    "variable_value": "<MagicMock name='RedshiftTarget().connect().cursor().fetchone' id='4559659888'>",
                                    "variable_type": "MagicMock",
                                    "variable_shape": "<MagicMock name='RedshiftTarget().connect().cursor().fetchone.shape' id='4559663744'>"
                                },
                                "cursor.close": {
                                    "variable_value": "<MagicMock name='RedshiftTarget().connect().cursor().close' id='4559776256'>",
                                    "variable_type": "MagicMock",
                                    "variable_shape": "<MagicMock name='RedshiftTarget().connect().cursor().close.shape' id='4559784208'>"
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "self.table": {
                                    "variable_value": "'dummy_schema.dummy_table'",
                                    "variable_type": "str",
                                    "variable_shape": "24"
                                },
                                "self": {
                                    "variable_value": "DummyS3CopyToTableKey(table=dummy_schema.dummy_table)",
                                    "variable_type": "DummyS3CopyToTableKey",
                                    "variable_shape": null
                                },
                                "query": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cursor": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "connection.cursor": {
                                    "variable_value": "<MagicMock name='RedshiftTarget().connect().cursor' id='4467431120'>",
                                    "variable_type": "MagicMock",
                                    "variable_shape": "<MagicMock name='RedshiftTarget().connect().cursor.shape' id='4467433920'>"
                                },
                                "connection": {
                                    "variable_value": "<MagicMock name='RedshiftTarget().connect()' id='4467415408'>",
                                    "variable_type": "MagicMock",
                                    "variable_shape": null
                                },
                                "cursor.execute": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.table.split": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cursor.fetchone": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cursor.close": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.table": {
                                    "variable_value": "'dummy_schema.dummy_table'",
                                    "variable_type": "str",
                                    "variable_shape": "24"
                                },
                                "self": {
                                    "variable_value": "DummyS3CopyToTableKey(table=dummy_schema.dummy_table)",
                                    "variable_type": "DummyS3CopyToTableKey",
                                    "variable_shape": null
                                },
                                "query": {
                                    "variable_value": "'select 1 as table_exists from information_schema.tables where table_schema = lower(%s) and table_name = lower(%s) limit 1'",
                                    "variable_type": "str",
                                    "variable_shape": "121"
                                },
                                "cursor": {
                                    "variable_value": "<MagicMock name='RedshiftTarget().connect().cursor()' id='4467443408'>",
                                    "variable_type": "MagicMock",
                                    "variable_shape": null
                                },
                                "connection.cursor": {
                                    "variable_value": "<MagicMock name='RedshiftTarget().connect().cursor' id='4467431120'>",
                                    "variable_type": "MagicMock",
                                    "variable_shape": "<MagicMock name='RedshiftTarget().connect().cursor.shape' id='4467433920'>"
                                },
                                "connection": {
                                    "variable_value": "<MagicMock name='RedshiftTarget().connect()' id='4467415408'>",
                                    "variable_type": "MagicMock",
                                    "variable_shape": null
                                },
                                "cursor.execute": {
                                    "variable_value": "<MagicMock name='RedshiftTarget().connect().cursor().execute' id='4467513376'>",
                                    "variable_type": "MagicMock",
                                    "variable_shape": "<MagicMock name='RedshiftTarget().connect().cursor().execute.shape' id='4467520272'>"
                                },
                                "self.table.split": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": "<MagicMock name='RedshiftTarget().connect().cursor().fetchone()' id='4467561424'>",
                                    "variable_type": "MagicMock",
                                    "variable_shape": null
                                },
                                "cursor.fetchone": {
                                    "variable_value": "<MagicMock name='RedshiftTarget().connect().cursor().fetchone' id='4467550096'>",
                                    "variable_type": "MagicMock",
                                    "variable_shape": "<MagicMock name='RedshiftTarget().connect().cursor().fetchone.shape' id='4467556992'>"
                                },
                                "cursor.close": {
                                    "variable_value": "<MagicMock name='RedshiftTarget().connect().cursor().close' id='4467665408'>",
                                    "variable_type": "MagicMock",
                                    "variable_shape": "<MagicMock name='RedshiftTarget().connect().cursor().close.shape' id='4467668208'>"
                                }
                            }
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "@abc.abstractmethod\ndef s3_load_path(self):\n    \"\"\"\n    Override to return the load path.\n    \"\"\"\n    return None",
                "@property\ndef aws_access_key_id(self):\n    \"\"\"\n    Override to return the key id.\n    \"\"\"\n    return None",
                "@property\ndef aws_secret_access_key(self):\n    \"\"\"\n    Override to return the secret access key.\n    \"\"\"\n    return None",
                "@property\ndef aws_account_id(self):\n    \"\"\"\n    Override to return the account id.\n    \"\"\"\n    return None",
                "@property\ndef aws_arn_role_name(self):\n    \"\"\"\n    Override to return the arn role name.\n    \"\"\"\n    return None",
                "@property\ndef aws_session_token(self):\n    \"\"\"\n    Override to return the session token.\n    \"\"\"\n    return None",
                "@abc.abstractproperty\ndef copy_options(self):\n    \"\"\"\n    Add extra copy options, for example:\n\n    * TIMEFORMAT 'auto'\n    * IGNOREHEADER 1\n    * TRUNCATECOLUMNS\n    * IGNOREBLANKLINES\n    * DELIMITER '\\t'\n    \"\"\"\n    return ''",
                "@property\ndef prune_table(self):\n    \"\"\"\n    Override to set equal to the name of the table which is to be pruned.\n    Intended to be used in conjunction with prune_column and prune_date\n    i.e. copy to temp table, prune production table to prune_column with a date greater than prune_date, then insert into production table from temp table\n    \"\"\"\n    return None",
                "@property\ndef prune_column(self):\n    \"\"\"\n    Override to set equal to the column of the prune_table which is to be compared\n    Intended to be used in conjunction with prune_table and prune_date\n    i.e. copy to temp table, prune production table to prune_column with a date greater than prune_date, then insert into production table from temp table\n    \"\"\"\n    return None",
                "@property\ndef prune_date(self):\n    \"\"\"\n    Override to set equal to the date by which prune_column is to be compared\n    Intended to be used in conjunction with prune_table and prune_column\n    i.e. copy to temp table, prune production table to prune_column with a date greater than prune_date, then insert into production table from temp table\n    \"\"\"\n    return None",
                "@property\ndef table_attributes(self):\n    \"\"\"\n    Add extra table attributes, for example:\n\n    DISTSTYLE KEY\n    DISTKEY (MY_FIELD)\n    SORTKEY (MY_FIELD_2, MY_FIELD_3)\n    \"\"\"\n    return ''",
                "@property\ndef do_truncate_table(self):\n    \"\"\"\n    Return True if table should be truncated before copying new data in.\n    \"\"\"\n    return False",
                "def do_prune(self):\n    \"\"\"\n    Return True if prune_table, prune_column, and prune_date are implemented.\n    If only a subset of prune variables are override, an exception is raised to remind the user to implement all or none.\n    Prune (data newer than prune_date deleted) before copying new data in.\n    \"\"\"\n    if self.prune_table and self.prune_column and self.prune_date:\n        return True\n    elif self.prune_table or self.prune_column or self.prune_date:\n        raise Exception('override zero or all prune variables')\n    else:\n        return False",
                "@property\ndef table_type(self):\n    \"\"\"\n    Return table type (i.e. 'temp').\n    \"\"\"\n    return ''",
                "@property\ndef queries(self):\n    \"\"\"\n    Override to return a list of queries to be executed in order.\n    \"\"\"\n    return []",
                "def truncate_table(self, connection):\n    query = \"truncate %s\" % self.table\n    cursor = connection.cursor()\n    try:\n        cursor.execute(query)\n    finally:\n        cursor.close()",
                "def prune(self, connection):\n    query = \"delete from %s where %s >= %s\" % (self.prune_table, self.prune_column, self.prune_date)\n    cursor = connection.cursor()\n    try:\n        cursor.execute(query)\n    finally:\n        cursor.close()",
                "def create_table(self, connection):\n    \"\"\"\n    Override to provide code for creating the target table.\n\n    By default it will be created using types (optionally)\n    specified in columns.\n\n    If overridden, use the provided connection object for\n    setting up the table in order to create the table and\n    insert data using the same transaction.\n    \"\"\"\n    if len(self.columns[0]) == 1:\n        # only names of columns specified, no types\n        raise NotImplementedError(\"create_table() not implemented \"\n                                  \"for %r and columns types not \"\n                                  \"specified\" % self.table)\n    elif len(self.columns[0]) == 2:\n        # if columns is specified as (name, type) tuples\n        coldefs = ','.join(\n            '{name} {type}'.format(\n                name=name,\n                type=type) for name, type in self.columns\n        )\n        query = (\"CREATE {type} TABLE \"\n                 \"{table} ({coldefs}) \"\n                 \"{table_attributes}\").format(\n            type=self.table_type,\n            table=self.table,\n            coldefs=coldefs,\n            table_attributes=self.table_attributes)\n\n        connection.cursor().execute(query)\n    else:\n        raise ValueError(\"create_table() found no columns for %r\"\n                         % self.table)",
                "def run(self):\n    \"\"\"\n    If the target table doesn't exist, self.create_table\n    will be called to attempt to create the table.\n    \"\"\"\n    if not (self.table):\n        raise Exception(\"table need to be specified\")\n\n    path = self.s3_load_path()\n    output = self.output()\n    connection = output.connect()\n    cursor = connection.cursor()\n\n    self.init_copy(connection)\n    self.copy(cursor, path)\n    self.post_copy(cursor)\n\n    # update marker table\n    output.touch(connection)\n    connection.commit()\n\n    # commit and clean up\n    connection.close()",
                "def copy(self, cursor, f):\n    \"\"\"\n    Defines copying from s3 into redshift.\n\n    If both key-based and role-based credentials are provided, role-based will be used.\n    \"\"\"\n    # format the credentials string dependent upon which type of credentials were provided\n    if self.aws_account_id and self.aws_arn_role_name:\n        cred_str = 'aws_iam_role=arn:aws:iam::{id}:role/{role}'.format(\n            id=self.aws_account_id,\n            role=self.aws_arn_role_name\n        )\n    elif self.aws_access_key_id and self.aws_secret_access_key:\n        cred_str = 'aws_access_key_id={key};aws_secret_access_key={secret}{opt}'.format(\n            key=self.aws_access_key_id,\n            secret=self.aws_secret_access_key,\n            opt=';token={}'.format(self.aws_session_token) if self.aws_session_token else ''\n        )\n    else:\n        raise NotImplementedError(\"Missing Credentials. \"\n                                  \"Override one of the following pairs of auth-args: \"\n                                  \"'aws_access_key_id' AND 'aws_secret_access_key' OR \"\n                                  \"'aws_account_id' AND 'aws_arn_role_name'\")\n\n    logger.info(\"Inserting file: %s\", f)\n    cursor.execute(\"\"\"\n     COPY {table} from '{source}'\n     CREDENTIALS '{creds}'\n     {options}\n     ;\"\"\".format(\n        table=self.table,\n        source=f,\n        creds=cred_str,\n        options=self.copy_options)\n    )",
                "def output(self):\n    \"\"\"\n    Returns a RedshiftTarget representing the inserted dataset.\n\n    Normally you don't override this.\n    \"\"\"\n    return RedshiftTarget(\n        host=self.host,\n        database=self.database,\n        user=self.user,\n        password=self.password,\n        table=self.table,\n        update_id=self.update_id)",
                "def does_table_exist(self, connection):\n    \"\"\"\n    Determine whether the table already exists.\n    \"\"\"\n\n    if '.' in self.table:\n        query = (\"select 1 as table_exists \"\n                 \"from information_schema.tables \"\n                 \"where table_schema = %s and table_name = %s limit 1\")\n    else:\n        query = (\"select 1 as table_exists \"\n                 \"from pg_table_def \"\n                 \"where tablename = %s limit 1\")\n    cursor = connection.cursor()\n    try:\n        cursor.execute(query, tuple(self.table.split('.')))\n        result = cursor.fetchone()\n        return bool(result)\n    finally:\n        cursor.close()",
                "def init_copy(self, connection):\n    \"\"\"\n    Perform pre-copy sql - such as creating table, truncating, or removing data older than x.\n    \"\"\"\n    if not self.does_table_exist(connection):\n        logger.info(\"Creating table %s\", self.table)\n        connection.reset()\n        self.create_table(connection)\n\n    if self.do_truncate_table:\n        logger.info(\"Truncating table %s\", self.table)\n        self.truncate_table(connection)\n\n    if self.do_prune():\n        logger.info(\"Removing %s older than %s from %s\", self.prune_column, self.prune_date, self.prune_table)\n        self.prune(connection)",
                "def post_copy(self, cursor):\n    \"\"\"\n    Performs post-copy sql - such as cleansing data, inserting into production table (if copied to temp table), etc.\n    \"\"\"\n    logger.info('Executing post copy queries')\n    for query in self.queries:\n        cursor.execute(query)",
                "@abc.abstractproperty\ndef jsonpath(self):\n    \"\"\"\n    Override the jsonpath schema location for the table.\n    \"\"\"\n    return ''",
                "@abc.abstractproperty\ndef copy_json_options(self):\n    \"\"\"\n    Add extra copy options, for example:\n\n    * GZIP\n    * LZOP\n    \"\"\"\n    return ''",
                "def copy(self, cursor, f):\n    \"\"\"\n    Defines copying JSON from s3 into redshift.\n    \"\"\"\n    # if session token is set, create token string\n    if self.aws_session_token:\n        token = ';token=%s' % self.aws_session_token\n    # otherwise, leave token string empty\n    else:\n        token = ''\n\n    logger.info(\"Inserting file: %s\", f)\n    cursor.execute(\"\"\"\n     COPY %s from '%s'\n     CREDENTIALS 'aws_access_key_id=%s;aws_secret_access_key=%s%s'\n     JSON AS '%s' %s\n     %s\n     ;\"\"\" % (self.table, f, self.aws_access_key_id,\n             self.aws_secret_access_key, token,\n             self.jsonpath, self.copy_json_options, self.copy_options))",
                "def run(self):\n    entries = []\n    for folder_path in self.folder_paths:\n        s3 = S3Target(folder_path)\n        client = s3.fs\n        for file_name in client.list(s3.path):\n            entries.append({\n                'url': '%s/%s' % (folder_path, file_name),\n                'mandatory': True\n            })\n    manifest = {'entries': entries}\n    target = self.output().open('w')\n    dump = json.dumps(manifest)\n    if not self.text_target:\n        dump = dump.encode('utf8')\n    target.write(dump)\n    target.close()",
                "@abc.abstractproperty\ndef host(self):\n    return None",
                "@abc.abstractproperty\ndef database(self):\n    return None",
                "@abc.abstractproperty\ndef user(self):\n    return None",
                "@abc.abstractproperty\ndef password(self):\n    return None",
                "@property\ndef update_id(self):\n    \"\"\"\n    This update id will be a unique identifier\n    for this insert on this table.\n    \"\"\"\n    return self.task_id",
                "def output(self):\n    \"\"\"\n    Returns a RedshiftTarget representing the inserted dataset.\n\n    Normally you don't override this.\n    \"\"\"\n    # uses class name as a meta-table\n    return RedshiftTarget(\n        host=self.host,\n        database=self.database,\n        user=self.user,\n        password=self.password,\n        table=self.__class__.__name__,\n        update_id=self.update_id)",
                "def run(self):\n    \"\"\"\n    Kill any open Redshift sessions for the given database.\n    \"\"\"\n    connection = self.output().connect()\n    # kill any sessions other than ours and\n    # internal Redshift sessions (rdsdb)\n    query = (\"select pg_terminate_backend(process) \"\n             \"from STV_SESSIONS \"\n             \"where db_name=%s \"\n             \"and user_name != 'rdsdb' \"\n             \"and process != pg_backend_pid()\")\n    cursor = connection.cursor()\n    logger.info('Killing all open Redshift sessions for database: %s', self.database)\n    try:\n        cursor.execute(query, (self.database,))\n        cursor.close()\n        connection.commit()\n    except psycopg2.DatabaseError as e:\n        if e.message and 'EOF' in e.message:\n            # sometimes this operation kills the current session.\n            # rebuild the connection. Need to pause for 30-60 seconds\n            # before Redshift will allow us back in.\n            connection.close()\n            logger.info('Pausing %s seconds for Redshift to reset connection', self.connection_reset_wait_seconds)\n            time.sleep(self.connection_reset_wait_seconds)\n            logger.info('Reconnecting to Redshift')\n            connection = self.output().connect()\n        else:\n            raise\n\n    try:\n        self.output().touch(connection)\n        connection.commit()\n    finally:\n        connection.close()\n\n    logger.info('Done killing all open Redshift sessions for database: %s', self.database)",
                "def output(self):\n    \"\"\"\n    Returns a RedshiftTarget representing the executed query.\n\n    Normally you don't override this.\n    \"\"\"\n    return RedshiftTarget(\n        host=self.host,\n        database=self.database,\n        user=self.user,\n        password=self.password,\n        table=self.table,\n        update_id=self.update_id\n    )",
                "@abc.abstractproperty\ndef aws_access_key_id(self):\n    \"\"\"\n    Override to return the key id.\n    \"\"\"\n    return None",
                "@abc.abstractproperty\ndef aws_secret_access_key(self):\n    \"\"\"\n    Override to return the secret access key.\n    \"\"\"\n    return None",
                "@property\ndef s3_unload_path(self):\n    \"\"\"\n    Override to return the load path.\n    \"\"\"\n    return ''",
                "@property\ndef unload_options(self):\n    \"\"\"\n    Add extra or override default unload options:\n    \"\"\"\n    return \"DELIMITER '|' ADDQUOTES GZIP ALLOWOVERWRITE PARALLEL ON\"",
                "@property\ndef unload_query(self):\n    \"\"\"\n    Default UNLOAD command\n    \"\"\"\n    return (\"UNLOAD ( '{query}' ) TO '{s3_unload_path}' \"\n            \"credentials 'aws_access_key_id={s3_access_key};aws_secret_access_key={s3_security_key}' \"\n            \"{unload_options};\")",
                "def run(self):\n    connection = self.output().connect()\n    cursor = connection.cursor()\n\n    # Retrieve AWS s3 credentials\n    config = luigi.configuration.get_config()\n    if self.aws_access_key_id is None or self.aws_secret_access_key is None:\n        self.aws_access_key_id = config.get('s3', 'aws_access_key_id')\n        self.aws_secret_access_key = config.get('s3', 'aws_secret_access_key')\n    # Optionally we can access env variables to get the keys\n    if self.aws_access_key_id is None or self.aws_access_key_id.strip() == '' \\\n            or self.aws_secret_access_key is None or self.aws_secret_access_key.strip() == '':\n        self.aws_access_key_id = os.environ['AWS_ACCESS_KEY_ID']\n        self.aws_secret_access_key = os.environ['AWS_SECRET_ACCESS_KEY']\n\n    unload_query = self.unload_query.format(\n        query=self.query().replace(\"'\", r\"\\'\"),\n        s3_unload_path=self.s3_unload_path,\n        unload_options=self.unload_options,\n        s3_access_key=self.aws_access_key_id,\n        s3_security_key=self.aws_secret_access_key)\n\n    logger.info('Executing unload query from task: {name}'.format(name=self.__class__))\n    try:\n        cursor = connection.cursor()\n        cursor.execute(unload_query)\n        logger.info(cursor.statusmessage)\n    except:\n        raise\n\n    # Update marker table\n    self.output().touch(connection)\n    # commit and close connection\n    connection.commit()\n    connection.close()",
                "def output(self):\n    \"\"\"\n    Returns a RedshiftTarget representing the executed query.\n\n    Normally you don't override this.\n    \"\"\"\n    return RedshiftTarget(\n        host=self.host,\n        database=self.database,\n        user=self.user,\n        password=self.password,\n        table=self.table,\n        update_id=self.update_id\n    )"
            ],
            "inscope_function_signatures": [
                "s3_load_path(self)",
                "aws_access_key_id(self)",
                "aws_secret_access_key(self)",
                "aws_account_id(self)",
                "aws_arn_role_name(self)",
                "aws_session_token(self)",
                "copy_options(self)",
                "prune_table(self)",
                "prune_column(self)",
                "prune_date(self)",
                "table_attributes(self)",
                "do_truncate_table(self)",
                "do_prune(self)",
                "table_type(self)",
                "queries(self)",
                "truncate_table(self, connection)",
                "prune(self, connection)",
                "create_table(self, connection)",
                "run(self)",
                "copy(self, cursor, f)",
                "output(self)",
                "does_table_exist(self, connection)",
                "init_copy(self, connection)",
                "post_copy(self, cursor)",
                "jsonpath(self)",
                "copy_json_options(self)",
                "copy(self, cursor, f)",
                "run(self)",
                "host(self)",
                "database(self)",
                "user(self)",
                "password(self)",
                "update_id(self)",
                "output(self)",
                "run(self)",
                "output(self)",
                "aws_access_key_id(self)",
                "aws_secret_access_key(self)",
                "s3_unload_path(self)",
                "unload_options(self)",
                "unload_query(self)",
                "run(self)",
                "output(self)"
            ],
            "variables_in_file": {
                "logger": [
                    353,
                    36,
                    677,
                    358,
                    423,
                    550,
                    681,
                    362,
                    301,
                    369,
                    561,
                    563,
                    29,
                    574
                ],
                "logging.getLogger": [
                    29
                ],
                "logging": [
                    29
                ],
                "ImportError": [
                    35
                ],
                "logger.warning": [
                    36
                ],
                "postgres.PostgresTarget": [
                    40
                ],
                "postgres": [
                    40,
                    577,
                    607
                ],
                "marker_table": [
                    47
                ],
                "get": [
                    47
                ],
                "luigi.configuration.get_config": [
                    660,
                    47
                ],
                "luigi.configuration": [
                    660,
                    47
                ],
                "luigi": [
                    480,
                    458,
                    47,
                    496,
                    660
                ],
                "use_db_timestamps": [
                    52
                ],
                "rdbms.CopyToTable": [
                    55
                ],
                "rdbms": [
                    55
                ],
                "abc.abstractmethod": [
                    74
                ],
                "abc": [
                    74,
                    395,
                    618,
                    625,
                    498,
                    402,
                    116,
                    502,
                    506,
                    510
                ],
                "property": [
                    129,
                    194,
                    514,
                    102,
                    167,
                    646,
                    138,
                    632,
                    109,
                    639,
                    81,
                    147,
                    88,
                    187,
                    156,
                    95
                ],
                "abc.abstractproperty": [
                    618,
                    395,
                    625,
                    498,
                    402,
                    116,
                    502,
                    506,
                    510
                ],
                "self.prune_table": [
                    210,
                    180,
                    182,
                    362
                ],
                "self": [
                    520,
                    530,
                    531,
                    532,
                    533,
                    534,
                    535,
                    541,
                    550,
                    552,
                    561,
                    562,
                    564,
                    569,
                    574,
                    598,
                    599,
                    600,
                    601,
                    602,
                    603,
                    656,
                    661,
                    662,
                    663,
                    665,
                    666,
                    667,
                    668,
                    670,
                    671,
                    672,
                    673,
                    674,
                    675,
                    677,
                    686,
                    180,
                    182,
                    698,
                    699,
                    700,
                    701,
                    702,
                    703,
                    202,
                    210,
                    228,
                    232,
                    233,
                    238,
                    243,
                    244,
                    246,
                    251,
                    258,
                    261,
                    262,
                    266,
                    267,
                    268,
                    284,
                    286,
                    287,
                    289,
                    291,
                    292,
                    293,
                    307,
                    310,
                    320,
                    321,
                    322,
                    323,
                    324,
                    325,
                    332,
                    342,
                    352,
                    353,
                    355,
                    357,
                    358,
                    359,
                    361,
                    362,
                    363,
                    370,
                    417,
                    418,
                    429,
                    430,
                    431,
                    463,
                    472,
                    474
                ],
                "self.prune_column": [
                    210,
                    180,
                    182,
                    362
                ],
                "self.prune_date": [
                    210,
                    180,
                    182,
                    362
                ],
                "Exception": [
                    259,
                    183
                ],
                "query": [
                    544,
                    552,
                    202,
                    205,
                    333,
                    240,
                    337,
                    210,
                    370,
                    371,
                    213,
                    342,
                    248
                ],
                "self.table": [
                    353,
                    258,
                    324,
                    358,
                    232,
                    202,
                    332,
                    429,
                    307,
                    244,
                    342,
                    602,
                    251,
                    702
                ],
                "cursor": [
                    264,
                    267,
                    268,
                    657,
                    549,
                    679,
                    424,
                    552,
                    553,
                    680,
                    681,
                    302,
                    203,
                    205,
                    207,
                    211,
                    340,
                    213,
                    342,
                    215,
                    343,
                    346,
                    371
                ],
                "connection.cursor": [
                    549,
                    679,
                    264,
                    203,
                    657,
                    211,
                    340,
                    248
                ],
                "connection": [
                    263,
                    264,
                    266,
                    271,
                    272,
                    656,
                    657,
                    275,
                    541,
                    549,
                    679,
                    554,
                    686,
                    560,
                    688,
                    689,
                    564,
                    569,
                    570,
                    572,
                    203,
                    211,
                    340,
                    352,
                    354,
                    355,
                    359,
                    363,
                    248
                ],
                "cursor.execute": [
                    424,
                    552,
                    680,
                    205,
                    302,
                    371,
                    213,
                    342
                ],
                "cursor.close": [
                    553,
                    215,
                    346,
                    207
                ],
                "len": [
                    233,
                    228
                ],
                "self.columns": [
                    233,
                    228,
                    238
                ],
                "NotImplementedError": [
                    296,
                    230
                ],
                "coldefs": [
                    235,
                    245
                ],
                "join": [
                    235
                ],
                "format": [
                    290,
                    293,
                    677,
                    236,
                    302,
                    240,
                    285
                ],
                "name": [
                    237,
                    238
                ],
                "type": [
                    238
                ],
                "self.table_type": [
                    243
                ],
                "self.table_attributes": [
                    246
                ],
                "execute": [
                    248
                ],
                "ValueError": [
                    250
                ],
                "path": [
                    267,
                    261
                ],
                "self.s3_load_path": [
                    261
                ],
                "output": [
                    271,
                    262,
                    263
                ],
                "self.output": [
                    262,
                    686,
                    656,
                    564,
                    472,
                    569,
                    541
                ],
                "output.connect": [
                    263
                ],
                "self.init_copy": [
                    266
                ],
                "self.copy": [
                    267
                ],
                "self.post_copy": [
                    268
                ],
                "output.touch": [
                    271
                ],
                "connection.commit": [
                    272,
                    554,
                    570,
                    688
                ],
                "connection.close": [
                    560,
                    689,
                    275,
                    572
                ],
                "self.aws_account_id": [
                    284,
                    286
                ],
                "self.aws_arn_role_name": [
                    284,
                    287
                ],
                "cred_str": [
                    290,
                    309,
                    285
                ],
                "self.aws_access_key_id": [
                    289,
                    674,
                    291,
                    429,
                    661,
                    662,
                    665,
                    667
                ],
                "self.aws_secret_access_key": [
                    289,
                    675,
                    292,
                    430,
                    661,
                    663,
                    666,
                    668
                ],
                "self.aws_session_token": [
                    417,
                    418,
                    293
                ],
                "logger.info": [
                    353,
                    677,
                    358,
                    423,
                    550,
                    681,
                    362,
                    301,
                    369,
                    561,
                    563,
                    574
                ],
                "f": [
                    429,
                    308,
                    301,
                    423
                ],
                "self.copy_options": [
                    310,
                    431
                ],
                "RedshiftTarget": [
                    529,
                    697,
                    597,
                    319
                ],
                "self.host": [
                    320,
                    698,
                    530,
                    598
                ],
                "self.database": [
                    321,
                    550,
                    552,
                    531,
                    599,
                    699,
                    574
                ],
                "self.user": [
                    600,
                    322,
                    700,
                    532
                ],
                "self.password": [
                    601,
                    323,
                    533,
                    701
                ],
                "self.update_id": [
                    703,
                    603,
                    325,
                    535
                ],
                "tuple": [
                    342
                ],
                "self.table.split": [
                    342
                ],
                "result": [
                    344,
                    343
                ],
                "cursor.fetchone": [
                    343
                ],
                "bool": [
                    344
                ],
                "self.does_table_exist": [
                    352
                ],
                "connection.reset": [
                    354
                ],
                "self.create_table": [
                    355
                ],
                "self.do_truncate_table": [
                    357
                ],
                "self.truncate_table": [
                    359
                ],
                "self.do_prune": [
                    361
                ],
                "self.prune": [
                    363
                ],
                "self.queries": [
                    370
                ],
                "S3CopyToTable": [
                    374
                ],
                "token": [
                    418,
                    421,
                    430
                ],
                "self.jsonpath": [
                    431
                ],
                "self.copy_json_options": [
                    431
                ],
                "S3PathTask": [
                    434
                ],
                "folder_paths": [
                    458
                ],
                "luigi.Parameter": [
                    458
                ],
                "text_target": [
                    459
                ],
                "entries": [
                    467,
                    462,
                    471
                ],
                "folder_path": [
                    464,
                    468,
                    463
                ],
                "self.folder_paths": [
                    463
                ],
                "s3": [
                    464,
                    465,
                    466
                ],
                "S3Target": [
                    464
                ],
                "client": [
                    465,
                    466
                ],
                "s3.fs": [
                    465
                ],
                "file_name": [
                    466,
                    468
                ],
                "client.list": [
                    466
                ],
                "s3.path": [
                    466
                ],
                "entries.append": [
                    467
                ],
                "manifest": [
                    473,
                    471
                ],
                "target": [
                    472,
                    476,
                    477
                ],
                "open": [
                    472
                ],
                "dump": [
                    473,
                    475,
                    476
                ],
                "json.dumps": [
                    473
                ],
                "json": [
                    473
                ],
                "self.text_target": [
                    474
                ],
                "dump.encode": [
                    475
                ],
                "target.write": [
                    476
                ],
                "target.close": [
                    477
                ],
                "luigi.Task": [
                    480
                ],
                "connection_reset_wait_seconds": [
                    496
                ],
                "luigi.IntParameter": [
                    496
                ],
                "self.task_id": [
                    520
                ],
                "self.__class__.__name__": [
                    534
                ],
                "self.__class__": [
                    677,
                    534
                ],
                "connect": [
                    656,
                    564,
                    541
                ],
                "psycopg2.DatabaseError": [
                    555
                ],
                "psycopg2": [
                    555
                ],
                "e.message": [
                    556
                ],
                "e": [
                    556
                ],
                "self.connection_reset_wait_seconds": [
                    561,
                    562
                ],
                "time.sleep": [
                    562
                ],
                "time": [
                    562
                ],
                "touch": [
                    569,
                    686
                ],
                "postgres.PostgresQuery": [
                    577,
                    607
                ],
                "config": [
                    660,
                    662,
                    663
                ],
                "config.get": [
                    662,
                    663
                ],
                "self.aws_access_key_id.strip": [
                    665
                ],
                "self.aws_secret_access_key.strip": [
                    666
                ],
                "os.environ": [
                    667,
                    668
                ],
                "os": [
                    667,
                    668
                ],
                "unload_query": [
                    680,
                    670
                ],
                "self.unload_query.format": [
                    670
                ],
                "self.unload_query": [
                    670
                ],
                "replace": [
                    671
                ],
                "self.query": [
                    671
                ],
                "self.s3_unload_path": [
                    672
                ],
                "self.unload_options": [
                    673
                ],
                "cursor.statusmessage": [
                    681
                ]
            },
            "filtered_variables_in_file": {
                "logger": [
                    353,
                    36,
                    677,
                    358,
                    423,
                    550,
                    681,
                    362,
                    301,
                    369,
                    561,
                    563,
                    29,
                    574
                ],
                "logging.getLogger": [
                    29
                ],
                "logging": [
                    29
                ],
                "logger.warning": [
                    36
                ],
                "postgres.PostgresTarget": [
                    40
                ],
                "postgres": [
                    40,
                    577,
                    607
                ],
                "marker_table": [
                    47
                ],
                "get": [
                    47
                ],
                "luigi.configuration.get_config": [
                    660,
                    47
                ],
                "luigi.configuration": [
                    660,
                    47
                ],
                "luigi": [
                    480,
                    458,
                    47,
                    496,
                    660
                ],
                "use_db_timestamps": [
                    52
                ],
                "rdbms.CopyToTable": [
                    55
                ],
                "rdbms": [
                    55
                ],
                "abc.abstractmethod": [
                    74
                ],
                "abc": [
                    74,
                    395,
                    618,
                    625,
                    498,
                    402,
                    116,
                    502,
                    506,
                    510
                ],
                "abc.abstractproperty": [
                    618,
                    395,
                    625,
                    498,
                    402,
                    116,
                    502,
                    506,
                    510
                ],
                "self.prune_table": [
                    210,
                    180,
                    182,
                    362
                ],
                "self": [
                    520,
                    530,
                    531,
                    532,
                    533,
                    534,
                    535,
                    541,
                    550,
                    552,
                    561,
                    562,
                    564,
                    569,
                    574,
                    598,
                    599,
                    600,
                    601,
                    602,
                    603,
                    656,
                    661,
                    662,
                    663,
                    665,
                    666,
                    667,
                    668,
                    670,
                    671,
                    672,
                    673,
                    674,
                    675,
                    677,
                    686,
                    180,
                    182,
                    698,
                    699,
                    700,
                    701,
                    702,
                    703,
                    202,
                    210,
                    228,
                    232,
                    233,
                    238,
                    243,
                    244,
                    246,
                    251,
                    258,
                    261,
                    262,
                    266,
                    267,
                    268,
                    284,
                    286,
                    287,
                    289,
                    291,
                    292,
                    293,
                    307,
                    310,
                    320,
                    321,
                    322,
                    323,
                    324,
                    325,
                    332,
                    342,
                    352,
                    353,
                    355,
                    357,
                    358,
                    359,
                    361,
                    362,
                    363,
                    370,
                    417,
                    418,
                    429,
                    430,
                    431,
                    463,
                    472,
                    474
                ],
                "self.prune_column": [
                    210,
                    180,
                    182,
                    362
                ],
                "self.prune_date": [
                    210,
                    180,
                    182,
                    362
                ],
                "query": [
                    544,
                    552,
                    202,
                    205,
                    333,
                    240,
                    337,
                    210,
                    370,
                    371,
                    213,
                    342,
                    248
                ],
                "self.table": [
                    353,
                    258,
                    324,
                    358,
                    232,
                    202,
                    332,
                    429,
                    307,
                    244,
                    342,
                    602,
                    251,
                    702
                ],
                "cursor": [
                    264,
                    267,
                    268,
                    657,
                    549,
                    679,
                    424,
                    552,
                    553,
                    680,
                    681,
                    302,
                    203,
                    205,
                    207,
                    211,
                    340,
                    213,
                    342,
                    215,
                    343,
                    346,
                    371
                ],
                "connection.cursor": [
                    549,
                    679,
                    264,
                    203,
                    657,
                    211,
                    340,
                    248
                ],
                "connection": [
                    263,
                    264,
                    266,
                    271,
                    272,
                    656,
                    657,
                    275,
                    541,
                    549,
                    679,
                    554,
                    686,
                    560,
                    688,
                    689,
                    564,
                    569,
                    570,
                    572,
                    203,
                    211,
                    340,
                    352,
                    354,
                    355,
                    359,
                    363,
                    248
                ],
                "cursor.execute": [
                    424,
                    552,
                    680,
                    205,
                    302,
                    371,
                    213,
                    342
                ],
                "cursor.close": [
                    553,
                    215,
                    346,
                    207
                ],
                "self.columns": [
                    233,
                    228,
                    238
                ],
                "coldefs": [
                    235,
                    245
                ],
                "join": [
                    235
                ],
                "name": [
                    237,
                    238
                ],
                "self.table_type": [
                    243
                ],
                "self.table_attributes": [
                    246
                ],
                "execute": [
                    248
                ],
                "path": [
                    267,
                    261
                ],
                "self.s3_load_path": [
                    261
                ],
                "output": [
                    271,
                    262,
                    263
                ],
                "self.output": [
                    262,
                    686,
                    656,
                    564,
                    472,
                    569,
                    541
                ],
                "output.connect": [
                    263
                ],
                "self.init_copy": [
                    266
                ],
                "self.copy": [
                    267
                ],
                "self.post_copy": [
                    268
                ],
                "output.touch": [
                    271
                ],
                "connection.commit": [
                    272,
                    554,
                    570,
                    688
                ],
                "connection.close": [
                    560,
                    689,
                    275,
                    572
                ],
                "self.aws_account_id": [
                    284,
                    286
                ],
                "self.aws_arn_role_name": [
                    284,
                    287
                ],
                "cred_str": [
                    290,
                    309,
                    285
                ],
                "self.aws_access_key_id": [
                    289,
                    674,
                    291,
                    429,
                    661,
                    662,
                    665,
                    667
                ],
                "self.aws_secret_access_key": [
                    289,
                    675,
                    292,
                    430,
                    661,
                    663,
                    666,
                    668
                ],
                "self.aws_session_token": [
                    417,
                    418,
                    293
                ],
                "logger.info": [
                    353,
                    677,
                    358,
                    423,
                    550,
                    681,
                    362,
                    301,
                    369,
                    561,
                    563,
                    574
                ],
                "f": [
                    429,
                    308,
                    301,
                    423
                ],
                "self.copy_options": [
                    310,
                    431
                ],
                "RedshiftTarget": [
                    529,
                    697,
                    597,
                    319
                ],
                "self.host": [
                    320,
                    698,
                    530,
                    598
                ],
                "self.database": [
                    321,
                    550,
                    552,
                    531,
                    599,
                    699,
                    574
                ],
                "self.user": [
                    600,
                    322,
                    700,
                    532
                ],
                "self.password": [
                    601,
                    323,
                    533,
                    701
                ],
                "self.update_id": [
                    703,
                    603,
                    325,
                    535
                ],
                "self.table.split": [
                    342
                ],
                "result": [
                    344,
                    343
                ],
                "cursor.fetchone": [
                    343
                ],
                "self.does_table_exist": [
                    352
                ],
                "connection.reset": [
                    354
                ],
                "self.create_table": [
                    355
                ],
                "self.do_truncate_table": [
                    357
                ],
                "self.truncate_table": [
                    359
                ],
                "self.do_prune": [
                    361
                ],
                "self.prune": [
                    363
                ],
                "self.queries": [
                    370
                ],
                "S3CopyToTable": [
                    374
                ],
                "token": [
                    418,
                    421,
                    430
                ],
                "self.jsonpath": [
                    431
                ],
                "self.copy_json_options": [
                    431
                ],
                "S3PathTask": [
                    434
                ],
                "folder_paths": [
                    458
                ],
                "luigi.Parameter": [
                    458
                ],
                "text_target": [
                    459
                ],
                "entries": [
                    467,
                    462,
                    471
                ],
                "folder_path": [
                    464,
                    468,
                    463
                ],
                "self.folder_paths": [
                    463
                ],
                "s3": [
                    464,
                    465,
                    466
                ],
                "S3Target": [
                    464
                ],
                "client": [
                    465,
                    466
                ],
                "s3.fs": [
                    465
                ],
                "file_name": [
                    466,
                    468
                ],
                "client.list": [
                    466
                ],
                "s3.path": [
                    466
                ],
                "entries.append": [
                    467
                ],
                "manifest": [
                    473,
                    471
                ],
                "target": [
                    472,
                    476,
                    477
                ],
                "dump": [
                    473,
                    475,
                    476
                ],
                "json.dumps": [
                    473
                ],
                "json": [
                    473
                ],
                "self.text_target": [
                    474
                ],
                "dump.encode": [
                    475
                ],
                "target.write": [
                    476
                ],
                "target.close": [
                    477
                ],
                "luigi.Task": [
                    480
                ],
                "connection_reset_wait_seconds": [
                    496
                ],
                "luigi.IntParameter": [
                    496
                ],
                "self.task_id": [
                    520
                ],
                "self.__class__.__name__": [
                    534
                ],
                "self.__class__": [
                    677,
                    534
                ],
                "connect": [
                    656,
                    564,
                    541
                ],
                "psycopg2.DatabaseError": [
                    555
                ],
                "psycopg2": [
                    555
                ],
                "e.message": [
                    556
                ],
                "e": [
                    556
                ],
                "self.connection_reset_wait_seconds": [
                    561,
                    562
                ],
                "time.sleep": [
                    562
                ],
                "time": [
                    562
                ],
                "touch": [
                    569,
                    686
                ],
                "postgres.PostgresQuery": [
                    577,
                    607
                ],
                "config": [
                    660,
                    662,
                    663
                ],
                "config.get": [
                    662,
                    663
                ],
                "self.aws_access_key_id.strip": [
                    665
                ],
                "self.aws_secret_access_key.strip": [
                    666
                ],
                "os.environ": [
                    667,
                    668
                ],
                "os": [
                    667,
                    668
                ],
                "unload_query": [
                    680,
                    670
                ],
                "self.unload_query.format": [
                    670
                ],
                "self.unload_query": [
                    670
                ],
                "replace": [
                    671
                ],
                "self.query": [
                    671
                ],
                "self.s3_unload_path": [
                    672
                ],
                "self.unload_options": [
                    673
                ],
                "cursor.statusmessage": [
                    681
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/SSD2T/bgp_envs/repos/luigi_8/test/contrib/redshift_test.py",
                "test_function": "test_s3_copy_to_table",
                "test_function_code": "    @mock.patch(\"luigi.contrib.redshift.S3CopyToTable.copy\")\n    @mock.patch(\"luigi.contrib.redshift.RedshiftTarget\")\n    def test_s3_copy_to_table(self, mock_redshift_target, mock_copy):\n        task = DummyS3CopyToTableKey()\n        task.run()\n\n        # The mocked connection cursor passed to\n        # S3CopyToTable.copy(self, cursor, f).\n        mock_cursor = (mock_redshift_target.return_value\n                                           .connect\n                                           .return_value\n                                           .cursor\n                                           .return_value)\n\n        # `mock_redshift_target` is the mocked `RedshiftTarget` object\n        # returned by S3CopyToTable.output(self).\n        mock_redshift_target.assert_called_with(database=task.database,\n                                                host=task.host,\n                                                update_id=task.task_id,\n                                                user=task.user,\n                                                table=task.table,\n                                                password=task.password)\n\n        # Check if the `S3CopyToTable.s3_load_path` class attribute was\n        # successfully referenced in the `S3CopyToTable.run` method, which is\n        # in-turn passed to `S3CopyToTable.copy` and other functions in `run`\n        # (see issue #995).\n        mock_copy.assert_called_with(mock_cursor, task.s3_load_path())\n\n        # Check the SQL query in `S3CopyToTable.does_table_exist`.\n        mock_cursor.execute.assert_called_with(\"select 1 as table_exists \"\n                                               \"from pg_table_def \"\n                                               \"where tablename = lower(%s) limit 1\",\n                                               (task.table,))\n\n        return",
                "test_error": "AssertionError: expected call not found. Expected: execute('select 1 as table_exists from information_schema.tables where table_schema = lower(%s) and table_name = lower(%s) limit 1', ('dummy_schema', 'dummy_table')) Actual: execute('select 1 as table_exists from information_schema.tables where table_schema = %s and table_name = %s limit 1', ('dummy_schema', 'dummy_table'))",
                "full_test_error": "self = <contrib.redshift_test.TestS3CopyToSchemaTable testMethod=test_s3_copy_to_table>\nmock_redshift_target = <MagicMock name='RedshiftTarget' id='4411784016'>\nmock_copy = <MagicMock name='copy' id='4411898560'>\n\n    @mock.patch(\"luigi.contrib.redshift.S3CopyToTable.copy\")\n    @mock.patch(\"luigi.contrib.redshift.RedshiftTarget\")\n    def test_s3_copy_to_table(self, mock_redshift_target, mock_copy):\n        task = DummyS3CopyToTableKey(table='dummy_schema.dummy_table')\n        task.run()\n    \n        # The mocked connection cursor passed to\n        # S3CopyToTable.copy(self, cursor, f).\n        mock_cursor = (mock_redshift_target.return_value\n                                           .connect\n                                           .return_value\n                                           .cursor\n                                           .return_value)\n    \n        # Check the SQL query in `S3CopyToTable.does_table_exist`.\n>       mock_cursor.execute.assert_called_with(\n            \"select 1 as table_exists \"\n            \"from information_schema.tables \"\n            \"where table_schema = lower(%s) and \"\n            \"table_name = lower(%s) limit 1\",\n            tuple(task.table.split('.')),\n        )\n\ntest/contrib/redshift_test.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n_mock_self = <MagicMock name='RedshiftTarget().connect().cursor().execute' id='4412007952'>\nargs = ('select 1 as table_exists from information_schema.tables where table_schema = lower(%s) and table_name = lower(%s) limit 1', ('dummy_schema', 'dummy_table'))\nkwargs = {}\nexpected = call('select 1 as table_exists from information_schema.tables where table_schema = lower(%s) and table_name = lower(%s) limit 1', ('dummy_schema', 'dummy_table'))\nactual = call('select 1 as table_exists from information_schema.tables where table_schema = %s and table_name = %s limit 1', ('dummy_schema', 'dummy_table'))\n_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x106a274c0>\ncause = None\n\n    def assert_called_with(_mock_self, *args, **kwargs):\n        \"\"\"assert that the last call was made with the specified arguments.\n    \n        Raises an AssertionError if the args and keyword args passed in are\n        different to the last call to the mock.\"\"\"\n        self = _mock_self\n        if self.call_args is None:\n            expected = self._format_mock_call_signature(args, kwargs)\n            actual = 'not called.'\n            error_message = ('expected call not found.\\nExpected: %s\\nActual: %s'\n                    % (expected, actual))\n            raise AssertionError(error_message)\n    \n        def _error_message():\n            msg = self._format_mock_failure_message(args, kwargs)\n            return msg\n        expected = self._call_matcher(_Call((args, kwargs), two=True))\n        actual = self._call_matcher(self.call_args)\n        if actual != expected:\n            cause = expected if isinstance(expected, Exception) else None\n>           raise AssertionError(_error_message()) from cause\nE           AssertionError: expected call not found.\nE           Expected: execute('select 1 as table_exists from information_schema.tables where table_schema = lower(%s) and table_name = lower(%s) limit 1', ('dummy_schema', 'dummy_table'))\nE           Actual: execute('select 1 as table_exists from information_schema.tables where table_schema = %s and table_name = %s limit 1', ('dummy_schema', 'dummy_table'))\n\n../../envs/luigi_8/lib/python3.8/site-packages/mock/mock.py:913: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "mock.patch('luigi.contrib.redshift.S3CopyToTable.copy')",
                    "mock.patch('luigi.contrib.redshift.RedshiftTarget')"
                ]
            }
        ]
    }
}