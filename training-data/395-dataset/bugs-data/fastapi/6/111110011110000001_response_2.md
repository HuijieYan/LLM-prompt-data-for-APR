The error message in the test cases indicates that the response status code is 422 instead of the expected 200. This indicates that there is an issue with the body to args conversion in the `request_body_to_args` function.

The bug occurs due to the incorrect handling of sequence shapes in the `request_body_to_args` function. The function is not properly handling the case where the required parameter is a list, set, or tuple. As a result, it fails to extract the values from the received body correctly, causing the response status code to be 422 instead of 200.

To fix the bug, the function needs to correctly handle the extraction of values for list, set, and tuple parameters from the received body. This means iterating over each item in the sequence type and extracting its value from the received body.

Here's the corrected code for the `request_body_to_args` function:

```python
async def request_body_to_args(
    required_params: List[ModelField],
    received_body: Optional[Union[Dict[str, Any], FormData]],
) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:
    values = {}
    errors = []
    if required_params:
        for field in required_params:
            value: Any = None
            if received_body is not None:
                if field.shape in sequence_shapes and isinstance(
                    received_body, FormData
                ):
                    value = received_body.getlist(field.alias)
                else:
                    value = received_body.get(field.alias)
                if field.shape == "list":
                    value = list(value)  # Convert to list
                elif field.shape == "set":
                    value = set(value)  # Convert to set
                elif field.shape == "tuple":
                    value = tuple(value)  # Convert to tuple

            if (
                value is None
                or (isinstance(field_info, params.Form) and value == "")
                or (
                    isinstance(field_info, params.Form)
                    and field.shape in sequence_shapes
                    and len(value) == 0
                )
            ):
                if field.required:
                    if PYDANTIC_1:
                        errors.append(
                            ErrorWrapper(MissingError(), loc=("body", field.alias))
                        )
                    else:  # pragma: nocover
                        errors.append(
                            ErrorWrapper(  # type: ignore
                                MissingError(),
                                loc=("body", field.alias),
                                config=BaseConfig,
                            )
                        )
                else:
                    values[field.name] = deepcopy(field.default)
                continue
            if (
                isinstance(field_info, params.File)
                and lenient_issubclass(field.type_, bytes)
                and isinstance(value, UploadFile)
            ):
                value = await value.read()
            elif (
                field.shape in sequence_shapes
                and isinstance(field_info, params.File)
                and lenient_issubclass(field.type_, bytes)
                and isinstance(value, sequence_types)
            ):
                awaitables = [sub_value.read() for sub_value in value]
                contents = await asyncio.gather(*awaitables)
                value = sequence_shape_to_type[field.shape](contents)
            v_, errors_ = field.validate(value, values, loc=("body", field.alias))
            if isinstance(errors_, ErrorWrapper):
                errors.append(errors_)
            elif isinstance(errors_, list):
                errors.extend(errors_)
            else:
                values[field.name] = v_
    return values, errors
```

In the corrected code, after extracting the value from the received body, we check the shape of the field and convert the value to the respective sequence type (list, set, or tuple) if necessary. This ensures that the extracted values are correctly handled based on the required parameter's shape.