{
    "pandas:167": {
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_167/pandas/core/indexes/base.py": {
            "buggy_functions": [],
            "snippets": [
                {
                    "snippet_code": "_engine_type = libindex.ObjectEngine",
                    "start_line": 245,
                    "end_line": 246
                }
            ],
            "inscope_functions": [
                "def _make_comparison_op(op, cls):\n    def cmp_method(self, other):\n        if isinstance(other, (np.ndarray, Index, ABCSeries)):\n            if other.ndim > 0 and len(self) != len(other):\n                raise ValueError(\"Lengths must match to compare\")\n\n        if is_object_dtype(self) and not isinstance(self, ABCMultiIndex):\n            # don't pass MultiIndex\n            with np.errstate(all=\"ignore\"):\n                result = ops._comp_method_OBJECT_ARRAY(op, self.values, other)\n\n        else:\n            with np.errstate(all=\"ignore\"):\n                result = op(self.values, np.asarray(other))\n\n        # technically we could support bool dtyped Index\n        # for now just return the indexing array directly\n        if is_bool_dtype(result):\n            return result\n        try:\n            return Index(result)\n        except TypeError:\n            return result\n\n    name = \"__{name}__\".format(name=op.__name__)\n    # TODO: docstring?\n    return set_function_name(cmp_method, name, cls)",
                "def _make_arithmetic_op(op, cls):\n    def index_arithmetic_method(self, other):\n        if isinstance(other, (ABCSeries, ABCDataFrame, ABCTimedeltaIndex)):\n            return NotImplemented\n\n        from pandas import Series\n\n        result = op(Series(self), other)\n        if isinstance(result, tuple):\n            return (Index(result[0]), Index(result[1]))\n        return Index(result)\n\n    name = \"__{name}__\".format(name=op.__name__)\n    # TODO: docstring?\n    return set_function_name(index_arithmetic_method, name, cls)",
                "def _new_Index(cls, d):\n    \"\"\"\n    This is called upon unpickling, rather than the default which doesn't\n    have arguments and breaks __new__.\n    \"\"\"\n    # required for backward compat, because PI can't be instantiated with\n    # ordinals through __new__ GH #13277\n    if issubclass(cls, ABCPeriodIndex):\n        from pandas.core.indexes.period import _new_PeriodIndex\n\n        return _new_PeriodIndex(cls, **d)\n    return cls.__new__(cls, **d)",
                "def ensure_index_from_sequences(sequences, names=None):\n    \"\"\"\n    Construct an index from sequences of data.\n\n    A single sequence returns an Index. Many sequences returns a\n    MultiIndex.\n\n    Parameters\n    ----------\n    sequences : sequence of sequences\n    names : sequence of str\n\n    Returns\n    -------\n    index : Index or MultiIndex\n\n    Examples\n    --------\n    >>> ensure_index_from_sequences([[1, 2, 3]], names=['name'])\n    Int64Index([1, 2, 3], dtype='int64', name='name')\n\n    >>> ensure_index_from_sequences([['a', 'a'], ['a', 'b']],\n                                    names=['L1', 'L2'])\n    MultiIndex([('a', 'a'),\n                ('a', 'b')],\n               names=['L1', 'L2'])\n\n    See Also\n    --------\n    ensure_index\n    \"\"\"\n    from .multi import MultiIndex\n\n    if len(sequences) == 1:\n        if names is not None:\n            names = names[0]\n        return Index(sequences[0], name=names)\n    else:\n        return MultiIndex.from_arrays(sequences, names=names)",
                "def ensure_index(index_like, copy=False):\n    \"\"\"\n    Ensure that we have an index from some index-like object.\n\n    Parameters\n    ----------\n    index : sequence\n        An Index or other sequence\n    copy : bool\n\n    Returns\n    -------\n    index : Index or MultiIndex\n\n    Examples\n    --------\n    >>> ensure_index(['a', 'b'])\n    Index(['a', 'b'], dtype='object')\n\n    >>> ensure_index([('a', 'a'),  ('b', 'c')])\n    Index([('a', 'a'), ('b', 'c')], dtype='object')\n\n    >>> ensure_index([['a', 'a'], ['b', 'c']])\n    MultiIndex([('a', 'b'),\n                ('a', 'c')],\n               dtype='object')\n               )\n\n    See Also\n    --------\n    ensure_index_from_sequences\n    \"\"\"\n    if isinstance(index_like, Index):\n        if copy:\n            index_like = index_like.copy()\n        return index_like\n    if hasattr(index_like, \"name\"):\n        return Index(index_like, name=index_like.name, copy=copy)\n\n    if is_iterator(index_like):\n        index_like = list(index_like)\n\n    # must check for exactly list here because of strict type\n    # check in clean_index_list\n    if isinstance(index_like, list):\n        if type(index_like) != list:\n            index_like = list(index_like)\n\n        converted, all_arrays = lib.clean_index_list(index_like)\n\n        if len(converted) > 0 and all_arrays:\n            from .multi import MultiIndex\n\n            return MultiIndex.from_arrays(converted)\n        else:\n            index_like = converted\n    else:\n        # clean_index_list does the equivalent of copying\n        # so only need to do this if not list instance\n        if copy:\n            from copy import copy\n\n            index_like = copy(index_like)\n\n    return Index(index_like)",
                "def _ensure_has_len(seq):\n    \"\"\"\n    If seq is an iterator, put its values into a list.\n    \"\"\"\n    try:\n        len(seq)\n    except TypeError:\n        return list(seq)\n    else:\n        return seq",
                "def _trim_front(strings):\n    \"\"\"\n    Trims zeros and decimal points.\n    \"\"\"\n    trimmed = strings\n    while len(strings) > 0 and all(x[0] == \" \" for x in trimmed):\n        trimmed = [x[1:] for x in trimmed]\n    return trimmed",
                "def _validate_join_method(method):\n    if method not in [\"left\", \"right\", \"inner\", \"outer\"]:\n        raise ValueError(\"do not recognize join method %s\" % method)",
                "def default_index(n):\n    from pandas.core.index import RangeIndex\n\n    return RangeIndex(0, n, name=None)",
                "def cmp_method(self, other):\n    if isinstance(other, (np.ndarray, Index, ABCSeries)):\n        if other.ndim > 0 and len(self) != len(other):\n            raise ValueError(\"Lengths must match to compare\")\n\n    if is_object_dtype(self) and not isinstance(self, ABCMultiIndex):\n        # don't pass MultiIndex\n        with np.errstate(all=\"ignore\"):\n            result = ops._comp_method_OBJECT_ARRAY(op, self.values, other)\n\n    else:\n        with np.errstate(all=\"ignore\"):\n            result = op(self.values, np.asarray(other))\n\n    # technically we could support bool dtyped Index\n    # for now just return the indexing array directly\n    if is_bool_dtype(result):\n        return result\n    try:\n        return Index(result)\n    except TypeError:\n        return result",
                "def index_arithmetic_method(self, other):\n    if isinstance(other, (ABCSeries, ABCDataFrame, ABCTimedeltaIndex)):\n        return NotImplemented\n\n    from pandas import Series\n\n    result = op(Series(self), other)\n    if isinstance(result, tuple):\n        return (Index(result[0]), Index(result[1]))\n    return Index(result)",
                "def _left_indexer_unique(self, left, right):\n    return libjoin.left_join_indexer_unique(left, right)",
                "def _left_indexer(self, left, right):\n    return libjoin.left_join_indexer(left, right)",
                "def _inner_indexer(self, left, right):\n    return libjoin.inner_join_indexer(left, right)",
                "def _outer_indexer(self, left, right):\n    return libjoin.outer_join_indexer(left, right)",
                "def __new__(\n    cls,\n    data=None,\n    dtype=None,\n    copy=False,\n    name=None,\n    fastpath=None,\n    tupleize_cols=True,\n    **kwargs\n):\n\n    if name is None and hasattr(data, \"name\"):\n        name = data.name\n\n    if fastpath is not None:\n        warnings.warn(\n            \"The 'fastpath' keyword is deprecated, and will be \"\n            \"removed in a future version.\",\n            FutureWarning,\n            stacklevel=2,\n        )\n        if fastpath:\n            return cls._simple_new(data, name)\n\n    from .range import RangeIndex\n\n    if isinstance(data, ABCPandasArray):\n        # ensure users don't accidentally put a PandasArray in an index.\n        data = data.to_numpy()\n\n    # range\n    if isinstance(data, RangeIndex):\n        return RangeIndex(start=data, copy=copy, dtype=dtype, name=name)\n    elif isinstance(data, range):\n        return RangeIndex.from_range(data, dtype=dtype, name=name)\n\n    # categorical\n    elif is_categorical_dtype(data) or is_categorical_dtype(dtype):\n        from .category import CategoricalIndex\n\n        return CategoricalIndex(data, dtype=dtype, copy=copy, name=name, **kwargs)\n\n    # interval\n    elif (\n        is_interval_dtype(data) or is_interval_dtype(dtype)\n    ) and not is_object_dtype(dtype):\n        from .interval import IntervalIndex\n\n        closed = kwargs.get(\"closed\", None)\n        return IntervalIndex(data, dtype=dtype, name=name, copy=copy, closed=closed)\n\n    elif (\n        is_datetime64_any_dtype(data)\n        or (dtype is not None and is_datetime64_any_dtype(dtype))\n        or \"tz\" in kwargs\n    ):\n        from pandas import DatetimeIndex\n\n        if dtype is not None and is_dtype_equal(_o_dtype, dtype):\n            # GH#23524 passing `dtype=object` to DatetimeIndex is invalid,\n            #  will raise in the where `data` is already tz-aware.  So\n            #  we leave it out of this step and cast to object-dtype after\n            #  the DatetimeIndex construction.\n            # Note we can pass copy=False because the .astype below\n            #  will always make a copy\n            result = DatetimeIndex(data, copy=False, name=name, **kwargs)\n            return result.astype(object)\n        else:\n            result = DatetimeIndex(\n                data, copy=copy, name=name, dtype=dtype, **kwargs\n            )\n            return result\n\n    elif is_timedelta64_dtype(data) or (\n        dtype is not None and is_timedelta64_dtype(dtype)\n    ):\n        from pandas import TimedeltaIndex\n\n        if dtype is not None and is_dtype_equal(_o_dtype, dtype):\n            # Note we can pass copy=False because the .astype below\n            #  will always make a copy\n            result = TimedeltaIndex(data, copy=False, name=name, **kwargs)\n            return result.astype(object)\n        else:\n            result = TimedeltaIndex(\n                data, copy=copy, name=name, dtype=dtype, **kwargs\n            )\n            return result\n\n    elif is_period_dtype(data) and not is_object_dtype(dtype):\n        from pandas import PeriodIndex\n\n        result = PeriodIndex(data, copy=copy, name=name, **kwargs)\n        return result\n\n    # extension dtype\n    elif is_extension_array_dtype(data) or is_extension_array_dtype(dtype):\n        data = np.asarray(data)\n        if not (dtype is None or is_object_dtype(dtype)):\n\n            # coerce to the provided dtype\n            data = dtype.construct_array_type()._from_sequence(\n                data, dtype=dtype, copy=False\n            )\n\n        # coerce to the object dtype\n        data = data.astype(object)\n        return Index(data, dtype=object, copy=copy, name=name, **kwargs)\n\n    # index-like\n    elif isinstance(data, (np.ndarray, Index, ABCSeries)):\n        if dtype is not None:\n            try:\n\n                # we need to avoid having numpy coerce\n                # things that look like ints/floats to ints unless\n                # they are actually ints, e.g. '0' and 0.0\n                # should not be coerced\n                # GH 11836\n                if is_integer_dtype(dtype):\n                    inferred = lib.infer_dtype(data, skipna=False)\n                    if inferred == \"integer\":\n                        data = maybe_cast_to_integer_array(data, dtype, copy=copy)\n                    elif inferred in [\"floating\", \"mixed-integer-float\"]:\n                        if isna(data).any():\n                            raise ValueError(\"cannot convert float NaN to integer\")\n\n                        if inferred == \"mixed-integer-float\":\n                            data = maybe_cast_to_integer_array(data, dtype)\n\n                        # If we are actually all equal to integers,\n                        # then coerce to integer.\n                        try:\n                            return cls._try_convert_to_int_index(\n                                data, copy, name, dtype\n                            )\n                        except ValueError:\n                            pass\n\n                        # Return an actual float index.\n                        from .numeric import Float64Index\n\n                        return Float64Index(data, copy=copy, dtype=dtype, name=name)\n\n                    elif inferred == \"string\":\n                        pass\n                    else:\n                        data = data.astype(dtype)\n                elif is_float_dtype(dtype):\n                    inferred = lib.infer_dtype(data, skipna=False)\n                    if inferred == \"string\":\n                        pass\n                    else:\n                        data = data.astype(dtype)\n                else:\n                    data = np.array(data, dtype=dtype, copy=copy)\n\n            except (TypeError, ValueError) as e:\n                msg = str(e)\n                if (\n                    \"cannot convert float\" in msg\n                    or \"Trying to coerce float values to integer\" in msg\n                ):\n                    raise\n\n        # maybe coerce to a sub-class\n        from pandas.core.indexes.period import PeriodIndex, IncompatibleFrequency\n\n        if is_signed_integer_dtype(data.dtype):\n            from .numeric import Int64Index\n\n            return Int64Index(data, copy=copy, dtype=dtype, name=name)\n        elif is_unsigned_integer_dtype(data.dtype):\n            from .numeric import UInt64Index\n\n            return UInt64Index(data, copy=copy, dtype=dtype, name=name)\n        elif is_float_dtype(data.dtype):\n            from .numeric import Float64Index\n\n            return Float64Index(data, copy=copy, dtype=dtype, name=name)\n        elif issubclass(data.dtype.type, np.bool) or is_bool_dtype(data):\n            subarr = data.astype(\"object\")\n        else:\n            subarr = com.asarray_tuplesafe(data, dtype=object)\n\n        # asarray_tuplesafe does not always copy underlying data,\n        # so need to make sure that this happens\n        if copy:\n            subarr = subarr.copy()\n\n        if dtype is None:\n            inferred = lib.infer_dtype(subarr, skipna=False)\n            if inferred == \"integer\":\n                try:\n                    return cls._try_convert_to_int_index(subarr, copy, name, dtype)\n                except ValueError:\n                    pass\n\n                return Index(subarr, copy=copy, dtype=object, name=name)\n            elif inferred in [\"floating\", \"mixed-integer-float\", \"integer-na\"]:\n                # TODO: Returns IntegerArray for integer-na case in the future\n                from .numeric import Float64Index\n\n                return Float64Index(subarr, copy=copy, name=name)\n            elif inferred == \"interval\":\n                from .interval import IntervalIndex\n\n                try:\n                    return IntervalIndex(subarr, name=name, copy=copy)\n                except ValueError:\n                    # GH27172: mixed closed Intervals --> object dtype\n                    pass\n            elif inferred == \"boolean\":\n                # don't support boolean explicitly ATM\n                pass\n            elif inferred != \"string\":\n                if inferred.startswith(\"datetime\"):\n                    from pandas import DatetimeIndex\n\n                    try:\n                        return DatetimeIndex(subarr, copy=copy, name=name, **kwargs)\n                    except (ValueError, OutOfBoundsDatetime):\n                        # GH 27011\n                        # If we have mixed timezones, just send it\n                        # down the base constructor\n                        pass\n\n                elif inferred.startswith(\"timedelta\"):\n                    from pandas import TimedeltaIndex\n\n                    return TimedeltaIndex(subarr, copy=copy, name=name, **kwargs)\n                elif inferred == \"period\":\n                    try:\n                        return PeriodIndex(subarr, name=name, **kwargs)\n                    except IncompatibleFrequency:\n                        pass\n        return cls._simple_new(subarr, name)\n\n    elif hasattr(data, \"__array__\"):\n        return Index(np.asarray(data), dtype=dtype, copy=copy, name=name, **kwargs)\n    elif data is None or is_scalar(data):\n        cls._scalar_data_error(data)\n    else:\n        if tupleize_cols and is_list_like(data):\n            # GH21470: convert iterable to list before determining if empty\n            if is_iterator(data):\n                data = list(data)\n\n            if data and all(isinstance(e, tuple) for e in data):\n                # we must be all tuples, otherwise don't construct\n                # 10697\n                from .multi import MultiIndex\n\n                return MultiIndex.from_tuples(\n                    data, names=name or kwargs.get(\"names\")\n                )\n        # other iterable of some kind\n        subarr = com.asarray_tuplesafe(data, dtype=object)\n        return Index(subarr, dtype=dtype, copy=copy, name=name, **kwargs)",
                "@property\ndef asi8(self):\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return None",
                "@classmethod\ndef _simple_new(cls, values, name=None, dtype=None, **kwargs):\n    \"\"\"\n    We require that we have a dtype compat for the values. If we are passed\n    a non-dtype compat, then coerce using the constructor.\n\n    Must be careful not to recurse.\n    \"\"\"\n    if not hasattr(values, \"dtype\"):\n        if (values is None or not len(values)) and dtype is not None:\n            values = np.empty(0, dtype=dtype)\n        else:\n            values = np.array(values, copy=False)\n            if is_object_dtype(values):\n                values = cls(\n                    values, name=name, dtype=dtype, **kwargs\n                )._ndarray_values\n\n    if isinstance(values, (ABCSeries, ABCIndexClass)):\n        # Index._data must always be an ndarray.\n        # This is no-copy for when _values is an ndarray,\n        # which should be always at this point.\n        values = np.asarray(values._values)\n\n    result = object.__new__(cls)\n    result._data = values\n    # _index_data is a (temporary?) fix to ensure that the direct data\n    # manipulation we do in `_libs/reduction.pyx` continues to work.\n    # We need access to the actual ndarray, since we're messing with\n    # data buffers and strides. We don't re-use `_ndarray_values`, since\n    # we actually set this value too.\n    result._index_data = values\n    result.name = name\n    for k, v in kwargs.items():\n        setattr(result, k, v)\n    return result._reset_identity()",
                "@cache_readonly\ndef _constructor(self):\n    return type(self)",
                "def _get_attributes_dict(self):\n    \"\"\"\n    Return an attributes dict for my class.\n    \"\"\"\n    return {k: getattr(self, k, None) for k in self._attributes}",
                "@Appender(_index_shared_docs[\"_shallow_copy\"])\ndef _shallow_copy(self, values=None, **kwargs):\n    if values is None:\n        values = self.values\n    attributes = self._get_attributes_dict()\n    attributes.update(kwargs)\n    if not len(values) and \"dtype\" not in kwargs:\n        attributes[\"dtype\"] = self.dtype\n\n    # _simple_new expects an the type of self._data\n    values = getattr(values, \"_values\", values)\n    if isinstance(values, ABCDatetimeArray):\n        # `self.values` returns `self` for tz-aware, so we need to unwrap\n        #  more specifically\n        values = values.asi8\n\n    return self._simple_new(values, **attributes)",
                "def _shallow_copy_with_infer(self, values, **kwargs):\n    \"\"\"\n    Create a new Index inferring the class with passed value, don't copy\n    the data, use the same object attributes with passed in attributes\n    taking precedence.\n\n    *this is an internal non-public method*\n\n    Parameters\n    ----------\n    values : the values to create the new Index, optional\n    kwargs : updates the default attributes for this Index\n    \"\"\"\n    attributes = self._get_attributes_dict()\n    attributes.update(kwargs)\n    attributes[\"copy\"] = False\n    if not len(values) and \"dtype\" not in kwargs:\n        attributes[\"dtype\"] = self.dtype\n    if self._infer_as_myclass:\n        try:\n            return self._constructor(values, **attributes)\n        except (TypeError, ValueError):\n            pass\n    return Index(values, **attributes)",
                "def _update_inplace(self, result, **kwargs):\n    # guard when called from IndexOpsMixin\n    raise TypeError(\"Index can't be updated inplace\")",
                "def is_(self, other):\n    \"\"\"\n    More flexible, faster check like ``is`` but that works through views.\n\n    Note: this is *not* the same as ``Index.identical()``, which checks\n    that metadata is also the same.\n\n    Parameters\n    ----------\n    other : object\n        other object to compare against.\n\n    Returns\n    -------\n    True if both have same underlying data, False otherwise : bool\n    \"\"\"\n    # use something other than None to be clearer\n    return self._id is getattr(other, \"_id\", Ellipsis) and self._id is not None",
                "def _reset_identity(self):\n    \"\"\"\n    Initializes or resets ``_id`` attribute with new object.\n    \"\"\"\n    self._id = _Identity()\n    return self",
                "def _cleanup(self):\n    self._engine.clear_mapping()",
                "@cache_readonly\ndef _engine(self):\n    # property, for now, slow to look up\n    return self._engine_type(lambda: self._ndarray_values, len(self))",
                "def __len__(self):\n    \"\"\"\n    Return the length of the Index.\n    \"\"\"\n    return len(self._data)",
                "def __array__(self, dtype=None):\n    \"\"\"\n    The array interface, return my values.\n    \"\"\"\n    return np.asarray(self._data, dtype=dtype)",
                "def __array_wrap__(self, result, context=None):\n    \"\"\"\n    Gets called after a ufunc.\n    \"\"\"\n    result = lib.item_from_zerodim(result)\n    if is_bool_dtype(result) or lib.is_scalar(result):\n        return result\n\n    attrs = self._get_attributes_dict()\n    attrs = self._maybe_update_attributes(attrs)\n    return Index(result, **attrs)",
                "@cache_readonly\ndef dtype(self):\n    \"\"\"\n    Return the dtype object of the underlying data.\n    \"\"\"\n    return self._data.dtype",
                "@property\ndef dtype_str(self):\n    \"\"\"\n    Return the dtype str of the underlying data.\n\n    .. deprecated:: 0.25.0\n    \"\"\"\n    warnings.warn(\n        \"`dtype_str` has been deprecated. Call `str` on the \"\n        \"dtype attribute instead.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n    return str(self.dtype)",
                "def ravel(self, order=\"C\"):\n    \"\"\"\n    Return an ndarray of the flattened values of the underlying data.\n\n    Returns\n    -------\n    numpy.ndarray\n        Flattened array.\n\n    See Also\n    --------\n    numpy.ndarray.ravel\n    \"\"\"\n    return self._ndarray_values.ravel(order=order)",
                "def view(self, cls=None):\n\n    # we need to see if we are subclassing an\n    # index type here\n    if cls is not None and not hasattr(cls, \"_typ\"):\n        result = self._data.view(cls)\n    else:\n        result = self._shallow_copy()\n    if isinstance(result, Index):\n        result._id = self._id\n    return result",
                "@Appender(_index_shared_docs[\"astype\"])\ndef astype(self, dtype, copy=True):\n    if is_dtype_equal(self.dtype, dtype):\n        return self.copy() if copy else self\n\n    elif is_categorical_dtype(dtype):\n        from .category import CategoricalIndex\n\n        return CategoricalIndex(self.values, name=self.name, dtype=dtype, copy=copy)\n    elif is_datetime64tz_dtype(dtype):\n        # TODO(GH-24559): Remove this block, use the following elif.\n        # avoid FutureWarning from DatetimeIndex constructor.\n        from pandas import DatetimeIndex\n\n        tz = pandas_dtype(dtype).tz\n        return DatetimeIndex(np.asarray(self)).tz_localize(\"UTC\").tz_convert(tz)\n\n    elif is_extension_array_dtype(dtype):\n        return Index(np.asarray(self), dtype=dtype, copy=copy)\n\n    try:\n        if is_datetime64tz_dtype(dtype):\n            from pandas import DatetimeIndex\n\n            return DatetimeIndex(\n                self.values, name=self.name, dtype=dtype, copy=copy\n            )\n        return Index(\n            self.values.astype(dtype, copy=copy), name=self.name, dtype=dtype\n        )\n    except (TypeError, ValueError):\n        msg = \"Cannot cast {name} to dtype {dtype}\"\n        raise TypeError(msg.format(name=type(self).__name__, dtype=dtype))",
                "@Appender(_index_shared_docs[\"take\"] % _index_doc_kwargs)\ndef take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs):\n    if kwargs:\n        nv.validate_take(tuple(), kwargs)\n    indices = ensure_platform_int(indices)\n    if self._can_hold_na:\n        taken = self._assert_take_fillable(\n            self.values,\n            indices,\n            allow_fill=allow_fill,\n            fill_value=fill_value,\n            na_value=self._na_value,\n        )\n    else:\n        if allow_fill and fill_value is not None:\n            msg = \"Unable to fill values because {0} cannot contain NA\"\n            raise ValueError(msg.format(self.__class__.__name__))\n        taken = self.values.take(indices)\n    return self._shallow_copy(taken)",
                "def _assert_take_fillable(\n    self, values, indices, allow_fill=True, fill_value=None, na_value=np.nan\n):\n    \"\"\"\n    Internal method to handle NA filling of take.\n    \"\"\"\n    indices = ensure_platform_int(indices)\n\n    # only fill if we are passing a non-None fill_value\n    if allow_fill and fill_value is not None:\n        if (indices < -1).any():\n            msg = (\n                \"When allow_fill=True and fill_value is not None, \"\n                \"all indices must be >= -1\"\n            )\n            raise ValueError(msg)\n        taken = algos.take(\n            values, indices, allow_fill=allow_fill, fill_value=na_value\n        )\n    else:\n        taken = values.take(indices)\n    return taken",
                "@Appender(_index_shared_docs[\"repeat\"] % _index_doc_kwargs)\ndef repeat(self, repeats, axis=None):\n    repeats = ensure_platform_int(repeats)\n    nv.validate_repeat(tuple(), dict(axis=axis))\n    return self._shallow_copy(self._values.repeat(repeats))",
                "@Appender(_index_shared_docs[\"copy\"])\ndef copy(self, name=None, deep=False, dtype=None, **kwargs):\n    if deep:\n        new_index = self._shallow_copy(self._data.copy())\n    else:\n        new_index = self._shallow_copy()\n\n    names = kwargs.get(\"names\")\n    names = self._validate_names(name=name, names=names, deep=deep)\n    new_index = new_index.set_names(names)\n\n    if dtype:\n        new_index = new_index.astype(dtype)\n    return new_index",
                "def __copy__(self, **kwargs):\n    return self.copy(**kwargs)",
                "def __deepcopy__(self, memo=None):\n    \"\"\"\n    Parameters\n    ----------\n    memo, default None\n        Standard signature. Unused\n    \"\"\"\n    if memo is None:\n        memo = {}\n    return self.copy(deep=True)",
                "def __repr__(self):\n    \"\"\"\n    Return a string representation for this object.\n    \"\"\"\n    klass = self.__class__.__name__\n    data = self._format_data()\n    attrs = self._format_attrs()\n    space = self._format_space()\n\n    prepr = (\",%s\" % space).join(\"%s=%s\" % (k, v) for k, v in attrs)\n\n    # no data provided, just attributes\n    if data is None:\n        data = \"\"\n\n    res = \"%s(%s%s)\" % (klass, data, prepr)\n\n    return res",
                "def _format_space(self):\n\n    # using space here controls if the attributes\n    # are line separated or not (the default)\n\n    # max_seq_items = get_option('display.max_seq_items')\n    # if len(self) > max_seq_items:\n    #    space = \"\\n%s\" % (' ' * (len(klass) + 1))\n    return \" \"",
                "@property\ndef _formatter_func(self):\n    \"\"\"\n    Return the formatter function.\n    \"\"\"\n    return default_pprint",
                "def _format_data(self, name=None):\n    \"\"\"\n    Return the formatted data as a unicode string.\n    \"\"\"\n\n    # do we want to justify (only do so for non-objects)\n    is_justify = not (\n        self.inferred_type in (\"string\", \"unicode\")\n        or (\n            self.inferred_type == \"categorical\" and is_object_dtype(self.categories)\n        )\n    )\n\n    return format_object_summary(\n        self, self._formatter_func, is_justify=is_justify, name=name\n    )",
                "def _format_attrs(self):\n    \"\"\"\n    Return a list of tuples of the (attr,formatted_value).\n    \"\"\"\n    return format_object_attrs(self)",
                "def _mpl_repr(self):\n    # how to represent ourselves to matplotlib\n    return self.values",
                "def format(self, name=False, formatter=None, **kwargs):\n    \"\"\"\n    Render a string representation of the Index.\n    \"\"\"\n    header = []\n    if name:\n        header.append(\n            pprint_thing(self.name, escape_chars=(\"\\t\", \"\\r\", \"\\n\"))\n            if self.name is not None\n            else \"\"\n        )\n\n    if formatter is not None:\n        return header + list(self.map(formatter))\n\n    return self._format_with_header(header, **kwargs)",
                "def _format_with_header(self, header, na_rep=\"NaN\", **kwargs):\n    values = self.values\n\n    from pandas.io.formats.format import format_array\n\n    if is_categorical_dtype(values.dtype):\n        values = np.array(values)\n\n    elif is_object_dtype(values.dtype):\n        values = lib.maybe_convert_objects(values, safe=1)\n\n    if is_object_dtype(values.dtype):\n        result = [pprint_thing(x, escape_chars=(\"\\t\", \"\\r\", \"\\n\")) for x in values]\n\n        # could have nans\n        mask = isna(values)\n        if mask.any():\n            result = np.array(result)\n            result[mask] = na_rep\n            result = result.tolist()\n\n    else:\n        result = _trim_front(format_array(values, None, justify=\"left\"))\n    return header + result",
                "def to_native_types(self, slicer=None, **kwargs):\n    \"\"\"\n    Format specified values of `self` and return them.\n\n    Parameters\n    ----------\n    slicer : int, array-like\n        An indexer into `self` that specifies which values\n        are used in the formatting process.\n    kwargs : dict\n        Options for specifying how the values should be formatted.\n        These options include the following:\n\n        1) na_rep : str\n            The value that serves as a placeholder for NULL values\n        2) quoting : bool or None\n            Whether or not there are quoted values in `self`\n        3) date_format : str\n            The format used to represent date-like values\n\n    Returns\n    -------\n    numpy.ndarray\n        Formatted values.\n    \"\"\"\n\n    values = self\n    if slicer is not None:\n        values = values[slicer]\n    return values._format_native_types(**kwargs)",
                "def _format_native_types(self, na_rep=\"\", quoting=None, **kwargs):\n    \"\"\"\n    Actually format specific types of the index.\n    \"\"\"\n    mask = isna(self)\n    if not self.is_object() and not quoting:\n        values = np.asarray(self).astype(str)\n    else:\n        values = np.array(self, dtype=object, copy=True)\n\n    values[mask] = na_rep\n    return values",
                "def _summary(self, name=None):\n    \"\"\"\n    Return a summarized representation.\n\n    Parameters\n    ----------\n    name : str\n        name to use in the summary representation\n\n    Returns\n    -------\n    String with a summarized representation of the index\n    \"\"\"\n    if len(self) > 0:\n        head = self[0]\n        if hasattr(head, \"format\") and not isinstance(head, str):\n            head = head.format()\n        tail = self[-1]\n        if hasattr(tail, \"format\") and not isinstance(tail, str):\n            tail = tail.format()\n        index_summary = \", %s to %s\" % (pprint_thing(head), pprint_thing(tail))\n    else:\n        index_summary = \"\"\n\n    if name is None:\n        name = type(self).__name__\n    return \"%s: %s entries%s\" % (name, len(self), index_summary)",
                "def summary(self, name=None):\n    \"\"\"\n    Return a summarized representation.\n\n    .. deprecated:: 0.23.0\n    \"\"\"\n    warnings.warn(\n        \"'summary' is deprecated and will be removed in a future version.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n    return self._summary(name)",
                "def to_flat_index(self):\n    \"\"\"\n    Identity method.\n\n    .. versionadded:: 0.24.0\n\n    This is implemented for compatibility with subclass implementations\n    when chaining.\n\n    Returns\n    -------\n    pd.Index\n        Caller.\n\n    See Also\n    --------\n    MultiIndex.to_flat_index : Subclass implementation.\n    \"\"\"\n    return self",
                "def to_series(self, index=None, name=None):\n    \"\"\"\n    Create a Series with both index and values equal to the index keys\n    useful with map for returning an indexer based on an index.\n\n    Parameters\n    ----------\n    index : Index, optional\n        index of resulting Series. If None, defaults to original index\n    name : string, optional\n        name of resulting Series. If None, defaults to name of original\n        index\n\n    Returns\n    -------\n    Series : dtype will be based on the type of the Index values.\n    \"\"\"\n\n    from pandas import Series\n\n    if index is None:\n        index = self._shallow_copy()\n    if name is None:\n        name = self.name\n\n    return Series(self.values.copy(), index=index, name=name)",
                "def to_frame(self, index=True, name=None):\n    \"\"\"\n    Create a DataFrame with a column containing the Index.\n\n    .. versionadded:: 0.24.0\n\n    Parameters\n    ----------\n    index : boolean, default True\n        Set the index of the returned DataFrame as the original Index.\n\n    name : object, default None\n        The passed name should substitute for the index name (if it has\n        one).\n\n    Returns\n    -------\n    DataFrame\n        DataFrame containing the original Index data.\n\n    See Also\n    --------\n    Index.to_series : Convert an Index to a Series.\n    Series.to_frame : Convert Series to DataFrame.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['Ant', 'Bear', 'Cow'], name='animal')\n    >>> idx.to_frame()\n           animal\n    animal\n    Ant       Ant\n    Bear     Bear\n    Cow       Cow\n\n    By default, the original Index is reused. To enforce a new Index:\n\n    >>> idx.to_frame(index=False)\n        animal\n    0   Ant\n    1  Bear\n    2   Cow\n\n    To override the name of the resulting column, specify `name`:\n\n    >>> idx.to_frame(index=False, name='zoo')\n        zoo\n    0   Ant\n    1  Bear\n    2   Cow\n    \"\"\"\n\n    from pandas import DataFrame\n\n    if name is None:\n        name = self.name or 0\n    result = DataFrame({name: self._values.copy()})\n\n    if index:\n        result.index = self\n    return result",
                "def _validate_names(self, name=None, names=None, deep=False):\n    \"\"\"\n    Handles the quirks of having a singular 'name' parameter for general\n    Index and plural 'names' parameter for MultiIndex.\n    \"\"\"\n    from copy import deepcopy\n\n    if names is not None and name is not None:\n        raise TypeError(\"Can only provide one of `names` and `name`\")\n    elif names is None and name is None:\n        return deepcopy(self.names) if deep else self.names\n    elif names is not None:\n        if not is_list_like(names):\n            raise TypeError(\"Must pass list-like as `names`.\")\n        return names\n    else:\n        if not is_list_like(name):\n            return [name]\n        return name",
                "def _get_names(self):\n    return FrozenList((self.name,))",
                "def _set_names(self, values, level=None):\n    \"\"\"\n    Set new names on index. Each name has to be a hashable type.\n\n    Parameters\n    ----------\n    values : str or sequence\n        name(s) to set\n    level : int, level name, or sequence of int/level names (default None)\n        If the index is a MultiIndex (hierarchical), level(s) to set (None\n        for all levels).  Otherwise level must be None\n\n    Raises\n    ------\n    TypeError if each name is not hashable.\n    \"\"\"\n    if not is_list_like(values):\n        raise ValueError(\"Names must be a list-like\")\n    if len(values) != 1:\n        raise ValueError(\"Length of new names must be 1, got %d\" % len(values))\n\n    # GH 20527\n    # All items in 'name' need to be hashable:\n    for name in values:\n        if not is_hashable(name):\n            raise TypeError(\n                \"{}.name must be a hashable type\".format(self.__class__.__name__)\n            )\n    self.name = values[0]",
                "def set_names(self, names, level=None, inplace=False):\n    \"\"\"\n    Set Index or MultiIndex name.\n\n    Able to set new names partially and by level.\n\n    Parameters\n    ----------\n    names : label or list of label\n        Name(s) to set.\n    level : int, label or list of int or label, optional\n        If the index is a MultiIndex, level(s) to set (None for all\n        levels). Otherwise level must be None.\n    inplace : bool, default False\n        Modifies the object directly, instead of creating a new Index or\n        MultiIndex.\n\n    Returns\n    -------\n    Index\n        The same type as the caller or None if inplace is True.\n\n    See Also\n    --------\n    Index.rename : Able to set new names without level.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1, 2, 3, 4])\n    >>> idx\n    Int64Index([1, 2, 3, 4], dtype='int64')\n    >>> idx.set_names('quarter')\n    Int64Index([1, 2, 3, 4], dtype='int64', name='quarter')\n\n    >>> idx = pd.MultiIndex.from_product([['python', 'cobra'],\n    ...                                   [2018, 2019]])\n    >>> idx\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               )\n    >>> idx.set_names(['kind', 'year'], inplace=True)\n    >>> idx\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['kind', 'year'])\n    >>> idx.set_names('species', level=0)\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['species', 'year'])\n    \"\"\"\n\n    if level is not None and not isinstance(self, ABCMultiIndex):\n        raise ValueError(\"Level must be None for non-MultiIndex\")\n\n    if level is not None and not is_list_like(level) and is_list_like(names):\n        msg = \"Names must be a string when a single level is provided.\"\n        raise TypeError(msg)\n\n    if not is_list_like(names) and level is None and self.nlevels > 1:\n        raise TypeError(\"Must pass list-like as `names`.\")\n\n    if not is_list_like(names):\n        names = [names]\n    if level is not None and not is_list_like(level):\n        level = [level]\n\n    if inplace:\n        idx = self\n    else:\n        idx = self._shallow_copy()\n    idx._set_names(names, level=level)\n    if not inplace:\n        return idx",
                "def rename(self, name, inplace=False):\n    \"\"\"\n    Alter Index or MultiIndex name.\n\n    Able to set new names without level. Defaults to returning new index.\n    Length of names must match number of levels in MultiIndex.\n\n    Parameters\n    ----------\n    name : label or list of labels\n        Name(s) to set.\n    inplace : boolean, default False\n        Modifies the object directly, instead of creating a new Index or\n        MultiIndex.\n\n    Returns\n    -------\n    Index\n        The same type as the caller or None if inplace is True.\n\n    See Also\n    --------\n    Index.set_names : Able to set new names partially and by level.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['A', 'C', 'A', 'B'], name='score')\n    >>> idx.rename('grade')\n    Index(['A', 'C', 'A', 'B'], dtype='object', name='grade')\n\n    >>> idx = pd.MultiIndex.from_product([['python', 'cobra'],\n    ...                                   [2018, 2019]],\n    ...                                   names=['kind', 'year'])\n    >>> idx\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['kind', 'year'])\n    >>> idx.rename(['species', 'year'])\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['species', 'year'])\n    >>> idx.rename('species')\n    Traceback (most recent call last):\n    TypeError: Must pass list-like as `names`.\n    \"\"\"\n    return self.set_names([name], inplace=inplace)",
                "@property\ndef nlevels(self):\n    \"\"\"\n    Number of levels.\n    \"\"\"\n    return 1",
                "def _sort_levels_monotonic(self):\n    \"\"\"\n    Compat with MultiIndex.\n    \"\"\"\n    return self",
                "def _validate_index_level(self, level):\n    \"\"\"\n    Validate index level.\n\n    For single-level Index getting level number is a no-op, but some\n    verification must be done like in MultiIndex.\n\n    \"\"\"\n    if isinstance(level, int):\n        if level < 0 and level != -1:\n            raise IndexError(\n                \"Too many levels: Index has only 1 level,\"\n                \" %d is not a valid level number\" % (level,)\n            )\n        elif level > 0:\n            raise IndexError(\n                \"Too many levels: Index has only 1 level, not %d\" % (level + 1)\n            )\n    elif level != self.name:\n        raise KeyError(\n            \"Requested level ({}) does not match index name ({})\".format(\n                level, self.name\n            )\n        )",
                "def _get_level_number(self, level):\n    self._validate_index_level(level)\n    return 0",
                "def sortlevel(self, level=None, ascending=True, sort_remaining=None):\n    \"\"\"\n    For internal compatibility with with the Index API.\n\n    Sort the Index. This is for compat with MultiIndex\n\n    Parameters\n    ----------\n    ascending : boolean, default True\n        False to sort in descending order\n\n    level, sort_remaining are compat parameters\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    return self.sort_values(return_indexer=True, ascending=ascending)",
                "def _get_level_values(self, level):\n    \"\"\"\n    Return an Index of values for requested level.\n\n    This is primarily useful to get an individual level of values from a\n    MultiIndex, but is provided on Index as well for compatibility.\n\n    Parameters\n    ----------\n    level : int or str\n        It is either the integer position or the name of the level.\n\n    Returns\n    -------\n    Index\n        Calling object, as there is only one level in the Index.\n\n    See Also\n    --------\n    MultiIndex.get_level_values : Get values for a level of a MultiIndex.\n\n    Notes\n    -----\n    For Index, level should be 0, since there are no multiple levels.\n\n    Examples\n    --------\n\n    >>> idx = pd.Index(list('abc'))\n    >>> idx\n    Index(['a', 'b', 'c'], dtype='object')\n\n    Get level values by supplying `level` as integer:\n\n    >>> idx.get_level_values(0)\n    Index(['a', 'b', 'c'], dtype='object')\n    \"\"\"\n    self._validate_index_level(level)\n    return self",
                "def droplevel(self, level=0):\n    \"\"\"\n    Return index with requested level(s) removed.\n\n    If resulting index has only 1 level left, the result will be\n    of Index type, not MultiIndex.\n\n    .. versionadded:: 0.23.1 (support for non-MultiIndex)\n\n    Parameters\n    ----------\n    level : int, str, or list-like, default 0\n        If a string is given, must be the name of a level\n        If list-like, elements must be names or indexes of levels.\n\n    Returns\n    -------\n    Index or MultiIndex\n    \"\"\"\n    if not isinstance(level, (tuple, list)):\n        level = [level]\n\n    levnums = sorted(self._get_level_number(lev) for lev in level)[::-1]\n\n    if len(level) == 0:\n        return self\n    if len(level) >= self.nlevels:\n        raise ValueError(\n            \"Cannot remove {} levels from an index with {} \"\n            \"levels: at least one level must be \"\n            \"left.\".format(len(level), self.nlevels)\n        )\n    # The two checks above guarantee that here self is a MultiIndex\n\n    new_levels = list(self.levels)\n    new_codes = list(self.codes)\n    new_names = list(self.names)\n\n    for i in levnums:\n        new_levels.pop(i)\n        new_codes.pop(i)\n        new_names.pop(i)\n\n    if len(new_levels) == 1:\n\n        # set nan if needed\n        mask = new_codes[0] == -1\n        result = new_levels[0].take(new_codes[0])\n        if mask.any():\n            result = result.putmask(mask, np.nan)\n\n        result.name = new_names[0]\n        return result\n    else:\n        from .multi import MultiIndex\n\n        return MultiIndex(\n            levels=new_levels,\n            codes=new_codes,\n            names=new_names,\n            verify_integrity=False,\n        )",
                "@Appender(_index_shared_docs[\"_get_grouper_for_level\"])\ndef _get_grouper_for_level(self, mapper, level=None):\n    assert level is None or level == 0\n    if mapper is None:\n        grouper = self\n    else:\n        grouper = self.map(mapper)\n\n    return grouper, None, None",
                "@property\ndef is_monotonic(self):\n    \"\"\"\n    Alias for is_monotonic_increasing.\n    \"\"\"\n    return self.is_monotonic_increasing",
                "@property\ndef is_monotonic_increasing(self):\n    \"\"\"\n    Return if the index is monotonic increasing (only equal or\n    increasing) values.\n\n    Examples\n    --------\n    >>> Index([1, 2, 3]).is_monotonic_increasing\n    True\n    >>> Index([1, 2, 2]).is_monotonic_increasing\n    True\n    >>> Index([1, 3, 2]).is_monotonic_increasing\n    False\n    \"\"\"\n    return self._engine.is_monotonic_increasing",
                "@property\ndef is_monotonic_decreasing(self):\n    \"\"\"\n    Return if the index is monotonic decreasing (only equal or\n    decreasing) values.\n\n    Examples\n    --------\n    >>> Index([3, 2, 1]).is_monotonic_decreasing\n    True\n    >>> Index([3, 2, 2]).is_monotonic_decreasing\n    True\n    >>> Index([3, 1, 2]).is_monotonic_decreasing\n    False\n    \"\"\"\n    return self._engine.is_monotonic_decreasing",
                "@property\ndef _is_strictly_monotonic_increasing(self):\n    \"\"\"\n    Return if the index is strictly monotonic increasing\n    (only increasing) values.\n\n    Examples\n    --------\n    >>> Index([1, 2, 3])._is_strictly_monotonic_increasing\n    True\n    >>> Index([1, 2, 2])._is_strictly_monotonic_increasing\n    False\n    >>> Index([1, 3, 2])._is_strictly_monotonic_increasing\n    False\n    \"\"\"\n    return self.is_unique and self.is_monotonic_increasing",
                "@property\ndef _is_strictly_monotonic_decreasing(self):\n    \"\"\"\n    Return if the index is strictly monotonic decreasing\n    (only decreasing) values.\n\n    Examples\n    --------\n    >>> Index([3, 2, 1])._is_strictly_monotonic_decreasing\n    True\n    >>> Index([3, 2, 2])._is_strictly_monotonic_decreasing\n    False\n    >>> Index([3, 1, 2])._is_strictly_monotonic_decreasing\n    False\n    \"\"\"\n    return self.is_unique and self.is_monotonic_decreasing",
                "def is_lexsorted_for_tuple(self, tup):\n    return True",
                "@cache_readonly\ndef is_unique(self):\n    \"\"\"\n    Return if the index has unique values.\n    \"\"\"\n    return self._engine.is_unique",
                "@property\ndef has_duplicates(self):\n    return not self.is_unique",
                "def is_boolean(self):\n    return self.inferred_type in [\"boolean\"]",
                "def is_integer(self):\n    return self.inferred_type in [\"integer\"]",
                "def is_floating(self):\n    return self.inferred_type in [\"floating\", \"mixed-integer-float\", \"integer-na\"]",
                "def is_numeric(self):\n    return self.inferred_type in [\"integer\", \"floating\"]",
                "def is_object(self):\n    return is_object_dtype(self.dtype)",
                "def is_categorical(self):\n    \"\"\"\n    Check if the Index holds categorical data.\n\n    Returns\n    -------\n    boolean\n        True if the Index is categorical.\n\n    See Also\n    --------\n    CategoricalIndex : Index for categorical data.\n\n    Examples\n    --------\n    >>> idx = pd.Index([\"Watermelon\", \"Orange\", \"Apple\",\n    ...                 \"Watermelon\"]).astype(\"category\")\n    >>> idx.is_categorical()\n    True\n\n    >>> idx = pd.Index([1, 3, 5, 7])\n    >>> idx.is_categorical()\n    False\n\n    >>> s = pd.Series([\"Peter\", \"Victor\", \"Elisabeth\", \"Mar\"])\n    >>> s\n    0        Peter\n    1       Victor\n    2    Elisabeth\n    3          Mar\n    dtype: object\n    >>> s.index.is_categorical()\n    False\n    \"\"\"\n    return self.inferred_type in [\"categorical\"]",
                "def is_interval(self):\n    return self.inferred_type in [\"interval\"]",
                "def is_mixed(self):\n    return self.inferred_type in [\"mixed\"]",
                "def holds_integer(self):\n    \"\"\"\n    Whether the type is an integer type.\n    \"\"\"\n    return self.inferred_type in [\"integer\", \"mixed-integer\"]",
                "@cache_readonly\ndef inferred_type(self):\n    \"\"\"\n    Return a string of the type inferred from the values.\n    \"\"\"\n    return lib.infer_dtype(self, skipna=False)",
                "@cache_readonly\ndef is_all_dates(self):\n    if self._data is None:\n        return False\n    return is_datetime_array(ensure_object(self.values))",
                "def __reduce__(self):\n    d = dict(data=self._data)\n    d.update(self._get_attributes_dict())\n    return _new_Index, (self.__class__, d), None",
                "def __setstate__(self, state):\n    \"\"\"\n    Necessary for making this object picklable.\n    \"\"\"\n\n    if isinstance(state, dict):\n        self._data = state.pop(\"data\")\n        for k, v in state.items():\n            setattr(self, k, v)\n\n    elif isinstance(state, tuple):\n\n        if len(state) == 2:\n            nd_state, own_state = state\n            data = np.empty(nd_state[1], dtype=nd_state[2])\n            np.ndarray.__setstate__(data, nd_state)\n            self.name = own_state[0]\n\n        else:  # pragma: no cover\n            data = np.empty(state)\n            np.ndarray.__setstate__(data, state)\n\n        self._data = data\n        self._reset_identity()\n    else:\n        raise Exception(\"invalid pickle state\")",
                "@cache_readonly\ndef _isnan(self):\n    \"\"\"\n    Return if each value is NaN.\n    \"\"\"\n    if self._can_hold_na:\n        return isna(self)\n    else:\n        # shouldn't reach to this condition by checking hasnans beforehand\n        values = np.empty(len(self), dtype=np.bool_)\n        values.fill(False)\n        return values",
                "@cache_readonly\ndef _nan_idxs(self):\n    if self._can_hold_na:\n        w, = self._isnan.nonzero()\n        return w\n    else:\n        return np.array([], dtype=np.int64)",
                "@cache_readonly\ndef hasnans(self):\n    \"\"\"\n    Return if I have any nans; enables various perf speedups.\n    \"\"\"\n    if self._can_hold_na:\n        return bool(self._isnan.any())\n    else:\n        return False",
                "def isna(self):\n    \"\"\"\n    Detect missing values.\n\n    Return a boolean same-sized object indicating if the values are NA.\n    NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get\n    mapped to ``True`` values.\n    Everything else get mapped to ``False`` values. Characters such as\n    empty strings `''` or :attr:`numpy.inf` are not considered NA values\n    (unless you set ``pandas.options.mode.use_inf_as_na = True``).\n\n    .. versionadded:: 0.20.0\n\n    Returns\n    -------\n    numpy.ndarray\n        A boolean array of whether my values are NA.\n\n    See Also\n    --------\n    Index.notna : Boolean inverse of isna.\n    Index.dropna : Omit entries with missing values.\n    isna : Top-level isna.\n    Series.isna : Detect missing values in Series object.\n\n    Examples\n    --------\n    Show which entries in a pandas.Index are NA. The result is an\n    array.\n\n    >>> idx = pd.Index([5.2, 6.0, np.NaN])\n    >>> idx\n    Float64Index([5.2, 6.0, nan], dtype='float64')\n    >>> idx.isna()\n    array([False, False,  True], dtype=bool)\n\n    Empty strings are not considered NA values. None is considered an NA\n    value.\n\n    >>> idx = pd.Index(['black', '', 'red', None])\n    >>> idx\n    Index(['black', '', 'red', None], dtype='object')\n    >>> idx.isna()\n    array([False, False, False,  True], dtype=bool)\n\n    For datetimes, `NaT` (Not a Time) is considered as an NA value.\n\n    >>> idx = pd.DatetimeIndex([pd.Timestamp('1940-04-25'),\n    ...                         pd.Timestamp(''), None, pd.NaT])\n    >>> idx\n    DatetimeIndex(['1940-04-25', 'NaT', 'NaT', 'NaT'],\n                  dtype='datetime64[ns]', freq=None)\n    >>> idx.isna()\n    array([False,  True,  True,  True], dtype=bool)\n    \"\"\"\n    return self._isnan",
                "def notna(self):\n    \"\"\"\n    Detect existing (non-missing) values.\n\n    Return a boolean same-sized object indicating if the values are not NA.\n    Non-missing values get mapped to ``True``. Characters such as empty\n    strings ``''`` or :attr:`numpy.inf` are not considered NA values\n    (unless you set ``pandas.options.mode.use_inf_as_na = True``).\n    NA values, such as None or :attr:`numpy.NaN`, get mapped to ``False``\n    values.\n\n    .. versionadded:: 0.20.0\n\n    Returns\n    -------\n    numpy.ndarray\n        Boolean array to indicate which entries are not NA.\n\n    See Also\n    --------\n    Index.notnull : Alias of notna.\n    Index.isna: Inverse of notna.\n    notna : Top-level notna.\n\n    Examples\n    --------\n    Show which entries in an Index are not NA. The result is an\n    array.\n\n    >>> idx = pd.Index([5.2, 6.0, np.NaN])\n    >>> idx\n    Float64Index([5.2, 6.0, nan], dtype='float64')\n    >>> idx.notna()\n    array([ True,  True, False])\n\n    Empty strings are not considered NA values. None is considered a NA\n    value.\n\n    >>> idx = pd.Index(['black', '', 'red', None])\n    >>> idx\n    Index(['black', '', 'red', None], dtype='object')\n    >>> idx.notna()\n    array([ True,  True,  True, False])\n    \"\"\"\n    return ~self.isna()",
                "@Appender(_index_shared_docs[\"fillna\"])\ndef fillna(self, value=None, downcast=None):\n    self._assert_can_do_op(value)\n    if self.hasnans:\n        result = self.putmask(self._isnan, value)\n        if downcast is None:\n            # no need to care metadata other than name\n            # because it can't have freq if\n            return Index(result, name=self.name)\n    return self._shallow_copy()",
                "@Appender(_index_shared_docs[\"dropna\"])\ndef dropna(self, how=\"any\"):\n    if how not in (\"any\", \"all\"):\n        raise ValueError(\"invalid how option: {0}\".format(how))\n\n    if self.hasnans:\n        return self._shallow_copy(self.values[~self._isnan])\n    return self._shallow_copy()",
                "@Appender(_index_shared_docs[\"index_unique\"] % _index_doc_kwargs)\ndef unique(self, level=None):\n    if level is not None:\n        self._validate_index_level(level)\n    result = super().unique()\n    return self._shallow_copy(result)",
                "def drop_duplicates(self, keep=\"first\"):\n    \"\"\"\n    Return Index with duplicate values removed.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', ``False``}, default 'first'\n        - 'first' : Drop duplicates except for the first occurrence.\n        - 'last' : Drop duplicates except for the last occurrence.\n        - ``False`` : Drop all duplicates.\n\n    Returns\n    -------\n    deduplicated : Index\n\n    See Also\n    --------\n    Series.drop_duplicates : Equivalent method on Series.\n    DataFrame.drop_duplicates : Equivalent method on DataFrame.\n    Index.duplicated : Related method on Index, indicating duplicate\n        Index values.\n\n    Examples\n    --------\n    Generate an pandas.Index with duplicate values.\n\n    >>> idx = pd.Index(['lama', 'cow', 'lama', 'beetle', 'lama', 'hippo'])\n\n    The `keep` parameter controls  which duplicate values are removed.\n    The value 'first' keeps the first occurrence for each\n    set of duplicated entries. The default value of keep is 'first'.\n\n    >>> idx.drop_duplicates(keep='first')\n    Index(['lama', 'cow', 'beetle', 'hippo'], dtype='object')\n\n    The value 'last' keeps the last occurrence for each set of duplicated\n    entries.\n\n    >>> idx.drop_duplicates(keep='last')\n    Index(['cow', 'beetle', 'lama', 'hippo'], dtype='object')\n\n    The value ``False`` discards all sets of duplicated entries.\n\n    >>> idx.drop_duplicates(keep=False)\n    Index(['cow', 'beetle', 'hippo'], dtype='object')\n    \"\"\"\n    return super().drop_duplicates(keep=keep)",
                "def duplicated(self, keep=\"first\"):\n    \"\"\"\n    Indicate duplicate index values.\n\n    Duplicated values are indicated as ``True`` values in the resulting\n    array. Either all duplicates, all except the first, or all except the\n    last occurrence of duplicates can be indicated.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', False}, default 'first'\n        The value or values in a set of duplicates to mark as missing.\n\n        - 'first' : Mark duplicates as ``True`` except for the first\n          occurrence.\n        - 'last' : Mark duplicates as ``True`` except for the last\n          occurrence.\n        - ``False`` : Mark all duplicates as ``True``.\n\n    Returns\n    -------\n    numpy.ndarray\n\n    See Also\n    --------\n    Series.duplicated : Equivalent method on pandas.Series.\n    DataFrame.duplicated : Equivalent method on pandas.DataFrame.\n    Index.drop_duplicates : Remove duplicate values from Index.\n\n    Examples\n    --------\n    By default, for each set of duplicated values, the first occurrence is\n    set to False and all others to True:\n\n    >>> idx = pd.Index(['lama', 'cow', 'lama', 'beetle', 'lama'])\n    >>> idx.duplicated()\n    array([False, False,  True, False,  True])\n\n    which is equivalent to\n\n    >>> idx.duplicated(keep='first')\n    array([False, False,  True, False,  True])\n\n    By using 'last', the last occurrence of each set of duplicated values\n    is set on False and all others on True:\n\n    >>> idx.duplicated(keep='last')\n    array([ True, False,  True, False, False])\n\n    By setting keep on ``False``, all duplicates are True:\n\n    >>> idx.duplicated(keep=False)\n    array([ True, False,  True, False,  True])\n    \"\"\"\n    return super().duplicated(keep=keep)",
                "def get_duplicates(self):\n    \"\"\"\n    Extract duplicated index elements.\n\n    .. deprecated:: 0.23.0\n        Use idx[idx.duplicated()].unique() instead\n\n    Returns a sorted list of index elements which appear more than once in\n    the index.\n\n    Returns\n    -------\n    array-like\n        List of duplicated indexes.\n\n    See Also\n    --------\n    Index.duplicated : Return boolean array denoting duplicates.\n    Index.drop_duplicates : Return Index with duplicates removed.\n\n    Examples\n    --------\n\n    Works on different Index of types.\n\n    >>> pd.Index([1, 2, 2, 3, 3, 3, 4]).get_duplicates()  # doctest: +SKIP\n    [2, 3]\n\n    Note that for a DatetimeIndex, it does not return a list but a new\n    DatetimeIndex:\n\n    >>> dates = pd.to_datetime(['2018-01-01', '2018-01-02', '2018-01-03',\n    ...                         '2018-01-03', '2018-01-04', '2018-01-04'],\n    ...                        format='%Y-%m-%d')\n    >>> pd.Index(dates).get_duplicates()  # doctest: +SKIP\n    DatetimeIndex(['2018-01-03', '2018-01-04'],\n                  dtype='datetime64[ns]', freq=None)\n\n    Sorts duplicated elements even when indexes are unordered.\n\n    >>> pd.Index([1, 2, 3, 2, 3, 4, 3]).get_duplicates()  # doctest: +SKIP\n    [2, 3]\n\n    Return empty array-like structure when all elements are unique.\n\n    >>> pd.Index([1, 2, 3, 4]).get_duplicates()  # doctest: +SKIP\n    []\n    >>> dates = pd.to_datetime(['2018-01-01', '2018-01-02', '2018-01-03'],\n    ...                        format='%Y-%m-%d')\n    >>> pd.Index(dates).get_duplicates()  # doctest: +SKIP\n    DatetimeIndex([], dtype='datetime64[ns]', freq=None)\n    \"\"\"\n    warnings.warn(\n        \"'get_duplicates' is deprecated and will be removed in \"\n        \"a future release. You can use \"\n        \"idx[idx.duplicated()].unique() instead\",\n        FutureWarning,\n        stacklevel=2,\n    )\n\n    return self[self.duplicated()].unique()",
                "def _get_unique_index(self, dropna=False):\n    \"\"\"\n    Returns an index containing unique values.\n\n    Parameters\n    ----------\n    dropna : bool\n        If True, NaN values are dropped.\n\n    Returns\n    -------\n    uniques : index\n    \"\"\"\n    if self.is_unique and not dropna:\n        return self\n\n    values = self.values\n\n    if not self.is_unique:\n        values = self.unique()\n\n    if dropna:\n        try:\n            if self.hasnans:\n                values = values[~isna(values)]\n        except NotImplementedError:\n            pass\n\n    return self._shallow_copy(values)",
                "def __add__(self, other):\n    if isinstance(other, (ABCSeries, ABCDataFrame)):\n        return NotImplemented\n    from pandas import Series\n\n    return Index(Series(self) + other)",
                "def __radd__(self, other):\n    from pandas import Series\n\n    return Index(other + Series(self))",
                "def __iadd__(self, other):\n    # alias for __add__\n    return self + other",
                "def __sub__(self, other):\n    return Index(np.array(self) - other)",
                "def __rsub__(self, other):\n    return Index(other - np.array(self))",
                "def __and__(self, other):\n    return self.intersection(other)",
                "def __or__(self, other):\n    return self.union(other)",
                "def __xor__(self, other):\n    return self.symmetric_difference(other)",
                "def __nonzero__(self):\n    raise ValueError(\n        \"The truth value of a {0} is ambiguous. \"\n        \"Use a.empty, a.bool(), a.item(), a.any() or a.all().\".format(\n            self.__class__.__name__\n        )\n    )",
                "def _get_reconciled_name_object(self, other):\n    \"\"\"\n    If the result of a set operation will be self,\n    return self, unless the name changes, in which\n    case make a shallow copy of self.\n    \"\"\"\n    name = get_op_result_name(self, other)\n    if self.name != name:\n        return self._shallow_copy(name=name)\n    return self",
                "def _union_incompatible_dtypes(self, other, sort):\n    \"\"\"\n    Casts this and other index to object dtype to allow the formation\n    of a union between incompatible types.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : False or None, default False\n        Whether to sort the resulting index.\n\n        * False : do not sort the result.\n        * None : sort the result, except when `self` and `other` are equal\n          or when the values cannot be compared.\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    this = self.astype(object, copy=False)\n    # cast to Index for when `other` is list-like\n    other = Index(other).astype(object, copy=False)\n    return Index.union(this, other, sort=sort).astype(object, copy=False)",
                "def _is_compatible_with_other(self, other):\n    \"\"\"\n    Check whether this and the other dtype are compatible with each other.\n    Meaning a union can be formed between them without needing to be cast\n    to dtype object.\n\n    Parameters\n    ----------\n    other : Index or array-like\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    return type(self) is type(other) and is_dtype_equal(self.dtype, other.dtype)",
                "def _validate_sort_keyword(self, sort):\n    if sort not in [None, False]:\n        raise ValueError(\n            \"The 'sort' keyword only takes the values of \"\n            \"None or False; {0} was passed.\".format(sort)\n        )",
                "def union(self, other, sort=None):\n    \"\"\"\n    Form the union of two Index objects.\n\n    If the Index objects are incompatible, both Index objects will be\n    cast to dtype('object') first.\n\n        .. versionchanged:: 0.25.0\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : bool or None, default None\n        Whether to sort the resulting Index.\n\n        * None : Sort the result, except when\n\n          1. `self` and `other` are equal.\n          2. `self` or `other` has length 0.\n          3. Some values in `self` or `other` cannot be compared.\n             A RuntimeWarning is issued in this case.\n\n        * False : do not sort the result.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    union : Index\n\n    Examples\n    --------\n\n    Union matching dtypes\n\n    >>> idx1 = pd.Index([1, 2, 3, 4])\n    >>> idx2 = pd.Index([3, 4, 5, 6])\n    >>> idx1.union(idx2)\n    Int64Index([1, 2, 3, 4, 5, 6], dtype='int64')\n\n    Union mismatched dtypes\n\n    >>> idx1 = pd.Index(['a', 'b', 'c', 'd'])\n    >>> idx2 = pd.Index([1, 2, 3, 4])\n    >>> idx1.union(idx2)\n    Index(['a', 'b', 'c', 'd', 1, 2, 3, 4], dtype='object')\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n\n    if not self._is_compatible_with_other(other):\n        return self._union_incompatible_dtypes(other, sort=sort)\n\n    return self._union(other, sort=sort)",
                "def _union(self, other, sort):\n    \"\"\"\n    Specific union logic should go here. In subclasses, union behavior\n    should be overwritten here rather than in `self.union`.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : False or None, default False\n        Whether to sort the resulting index.\n\n        * False : do not sort the result.\n        * None : sort the result, except when `self` and `other` are equal\n          or when the values cannot be compared.\n\n    Returns\n    -------\n    Index\n    \"\"\"\n\n    if not len(other) or self.equals(other):\n        return self._get_reconciled_name_object(other)\n\n    if not len(self):\n        return other._get_reconciled_name_object(self)\n\n    # TODO(EA): setops-refactor, clean all this up\n    if is_period_dtype(self) or is_datetime64tz_dtype(self):\n        lvals = self._ndarray_values\n    else:\n        lvals = self._values\n    if is_period_dtype(other) or is_datetime64tz_dtype(other):\n        rvals = other._ndarray_values\n    else:\n        rvals = other._values\n\n    if sort is None and self.is_monotonic and other.is_monotonic:\n        try:\n            result = self._outer_indexer(lvals, rvals)[0]\n        except TypeError:\n            # incomparable objects\n            result = list(lvals)\n\n            # worth making this faster? a very unusual case\n            value_set = set(lvals)\n            result.extend([x for x in rvals if x not in value_set])\n    else:\n        indexer = self.get_indexer(other)\n        indexer, = (indexer == -1).nonzero()\n\n        if len(indexer) > 0:\n            other_diff = algos.take_nd(rvals, indexer, allow_fill=False)\n            result = concat_compat((lvals, other_diff))\n\n        else:\n            result = lvals\n\n        if sort is None:\n            try:\n                result = sorting.safe_sort(result)\n            except TypeError as e:\n                warnings.warn(\n                    \"{}, sort order is undefined for \"\n                    \"incomparable objects\".format(e),\n                    RuntimeWarning,\n                    stacklevel=3,\n                )\n\n    # for subclasses\n    return self._wrap_setop_result(other, result)",
                "def _wrap_setop_result(self, other, result):\n    return self._constructor(result, name=get_op_result_name(self, other))",
                "@Appender(_index_shared_docs[\"intersection\"])\ndef intersection(self, other, sort=False):\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other = ensure_index(other)\n\n    if self.equals(other):\n        return self._get_reconciled_name_object(other)\n\n    if not is_dtype_equal(self.dtype, other.dtype):\n        this = self.astype(\"O\")\n        other = other.astype(\"O\")\n        return this.intersection(other, sort=sort)\n\n    # TODO(EA): setops-refactor, clean all this up\n    if is_period_dtype(self):\n        lvals = self._ndarray_values\n    else:\n        lvals = self._values\n    if is_period_dtype(other):\n        rvals = other._ndarray_values\n    else:\n        rvals = other._values\n\n    if self.is_monotonic and other.is_monotonic:\n        try:\n            result = self._inner_indexer(lvals, rvals)[0]\n            return self._wrap_setop_result(other, result)\n        except TypeError:\n            pass\n\n    try:\n        indexer = Index(rvals).get_indexer(lvals)\n        indexer = indexer.take((indexer != -1).nonzero()[0])\n    except Exception:\n        # duplicates\n        indexer = algos.unique1d(Index(rvals).get_indexer_non_unique(lvals)[0])\n        indexer = indexer[indexer != -1]\n\n    taken = other.take(indexer)\n\n    if sort is None:\n        taken = sorting.safe_sort(taken.values)\n        if self.name != other.name:\n            name = None\n        else:\n            name = self.name\n        return self._shallow_copy(taken, name=name)\n\n    if self.name != other.name:\n        taken.name = None\n\n    return taken",
                "def difference(self, other, sort=None):\n    \"\"\"\n    Return a new Index with elements from the index that are not in\n    `other`.\n\n    This is the set difference of two Index objects.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : False or None, default None\n        Whether to sort the resulting index. By default, the\n        values are attempted to be sorted, but any TypeError from\n        incomparable elements is caught by pandas.\n\n        * None : Attempt to sort the result, but catch any TypeErrors\n          from comparing incomparable elements.\n        * False : Do not sort the result.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    difference : Index\n\n    Examples\n    --------\n\n    >>> idx1 = pd.Index([2, 1, 3, 4])\n    >>> idx2 = pd.Index([3, 4, 5, 6])\n    >>> idx1.difference(idx2)\n    Int64Index([1, 2], dtype='int64')\n    >>> idx1.difference(idx2, sort=False)\n    Int64Index([2, 1], dtype='int64')\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n\n    if self.equals(other):\n        # pass an empty np.ndarray with the appropriate dtype\n        return self._shallow_copy(self._data[:0])\n\n    other, result_name = self._convert_can_do_setop(other)\n\n    this = self._get_unique_index()\n\n    indexer = this.get_indexer(other)\n    indexer = indexer.take((indexer != -1).nonzero()[0])\n\n    label_diff = np.setdiff1d(np.arange(this.size), indexer, assume_unique=True)\n    the_diff = this.values.take(label_diff)\n    if sort is None:\n        try:\n            the_diff = sorting.safe_sort(the_diff)\n        except TypeError:\n            pass\n\n    return this._shallow_copy(the_diff, name=result_name, freq=None)",
                "def symmetric_difference(self, other, result_name=None, sort=None):\n    \"\"\"\n    Compute the symmetric difference of two Index objects.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    result_name : str\n    sort : False or None, default None\n        Whether to sort the resulting index. By default, the\n        values are attempted to be sorted, but any TypeError from\n        incomparable elements is caught by pandas.\n\n        * None : Attempt to sort the result, but catch any TypeErrors\n          from comparing incomparable elements.\n        * False : Do not sort the result.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    symmetric_difference : Index\n\n    Notes\n    -----\n    ``symmetric_difference`` contains elements that appear in either\n    ``idx1`` or ``idx2`` but not both. Equivalent to the Index created by\n    ``idx1.difference(idx2) | idx2.difference(idx1)`` with duplicates\n    dropped.\n\n    Examples\n    --------\n    >>> idx1 = pd.Index([1, 2, 3, 4])\n    >>> idx2 = pd.Index([2, 3, 4, 5])\n    >>> idx1.symmetric_difference(idx2)\n    Int64Index([1, 5], dtype='int64')\n\n    You can also use the ``^`` operator:\n\n    >>> idx1 ^ idx2\n    Int64Index([1, 5], dtype='int64')\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other, result_name_update = self._convert_can_do_setop(other)\n    if result_name is None:\n        result_name = result_name_update\n\n    this = self._get_unique_index()\n    other = other._get_unique_index()\n    indexer = this.get_indexer(other)\n\n    # {this} minus {other}\n    common_indexer = indexer.take((indexer != -1).nonzero()[0])\n    left_indexer = np.setdiff1d(\n        np.arange(this.size), common_indexer, assume_unique=True\n    )\n    left_diff = this.values.take(left_indexer)\n\n    # {other} minus {this}\n    right_indexer = (indexer == -1).nonzero()[0]\n    right_diff = other.values.take(right_indexer)\n\n    the_diff = concat_compat([left_diff, right_diff])\n    if sort is None:\n        try:\n            the_diff = sorting.safe_sort(the_diff)\n        except TypeError:\n            pass\n\n    attribs = self._get_attributes_dict()\n    attribs[\"name\"] = result_name\n    if \"freq\" in attribs:\n        attribs[\"freq\"] = None\n    return self._shallow_copy_with_infer(the_diff, **attribs)",
                "def _assert_can_do_setop(self, other):\n    if not is_list_like(other):\n        raise TypeError(\"Input must be Index or array-like\")\n    return True",
                "def _convert_can_do_setop(self, other):\n    if not isinstance(other, Index):\n        other = Index(other, name=self.name)\n        result_name = self.name\n    else:\n        result_name = get_op_result_name(self, other)\n    return other, result_name",
                "@Appender(_index_shared_docs[\"get_loc\"])\ndef get_loc(self, key, method=None, tolerance=None):\n    if method is None:\n        if tolerance is not None:\n            raise ValueError(\n                \"tolerance argument only valid if using pad, \"\n                \"backfill or nearest lookups\"\n            )\n        try:\n            return self._engine.get_loc(key)\n        except KeyError:\n            return self._engine.get_loc(self._maybe_cast_indexer(key))\n    indexer = self.get_indexer([key], method=method, tolerance=tolerance)\n    if indexer.ndim > 1 or indexer.size > 1:\n        raise TypeError(\"get_loc requires scalar valued input\")\n    loc = indexer.item()\n    if loc == -1:\n        raise KeyError(key)\n    return loc",
                "@Appender(_index_shared_docs[\"get_indexer\"] % _index_doc_kwargs)\ndef get_indexer(self, target, method=None, limit=None, tolerance=None):\n    method = missing.clean_reindex_fill_method(method)\n    target = ensure_index(target)\n    if tolerance is not None:\n        tolerance = self._convert_tolerance(tolerance, target)\n\n    # Treat boolean labels passed to a numeric index as not found. Without\n    # this fix False and True would be treated as 0 and 1 respectively.\n    # (GH #16877)\n    if target.is_boolean() and self.is_numeric():\n        return ensure_platform_int(np.repeat(-1, target.size))\n\n    pself, ptarget = self._maybe_promote(target)\n    if pself is not self or ptarget is not target:\n        return pself.get_indexer(\n            ptarget, method=method, limit=limit, tolerance=tolerance\n        )\n\n    if not is_dtype_equal(self.dtype, target.dtype):\n        this = self.astype(object)\n        target = target.astype(object)\n        return this.get_indexer(\n            target, method=method, limit=limit, tolerance=tolerance\n        )\n\n    if not self.is_unique:\n        raise InvalidIndexError(\n            \"Reindexing only valid with uniquely valued Index objects\"\n        )\n\n    if method == \"pad\" or method == \"backfill\":\n        indexer = self._get_fill_indexer(target, method, limit, tolerance)\n    elif method == \"nearest\":\n        indexer = self._get_nearest_indexer(target, limit, tolerance)\n    else:\n        if tolerance is not None:\n            raise ValueError(\n                \"tolerance argument only valid if doing pad, \"\n                \"backfill or nearest reindexing\"\n            )\n        if limit is not None:\n            raise ValueError(\n                \"limit argument only valid if doing pad, \"\n                \"backfill or nearest reindexing\"\n            )\n\n        indexer = self._engine.get_indexer(target._ndarray_values)\n\n    return ensure_platform_int(indexer)",
                "def _convert_tolerance(self, tolerance, target):\n    # override this method on subclasses\n    tolerance = np.asarray(tolerance)\n    if target.size != tolerance.size and tolerance.size > 1:\n        raise ValueError(\"list-like tolerance size must match target index size\")\n    return tolerance",
                "def _get_fill_indexer(self, target, method, limit=None, tolerance=None):\n    if self.is_monotonic_increasing and target.is_monotonic_increasing:\n        method = (\n            self._engine.get_pad_indexer\n            if method == \"pad\"\n            else self._engine.get_backfill_indexer\n        )\n        indexer = method(target._ndarray_values, limit)\n    else:\n        indexer = self._get_fill_indexer_searchsorted(target, method, limit)\n    if tolerance is not None:\n        indexer = self._filter_indexer_tolerance(\n            target._ndarray_values, indexer, tolerance\n        )\n    return indexer",
                "def _get_fill_indexer_searchsorted(self, target, method, limit=None):\n    \"\"\"\n    Fallback pad/backfill get_indexer that works for monotonic decreasing\n    indexes and non-monotonic targets.\n    \"\"\"\n    if limit is not None:\n        raise ValueError(\n            \"limit argument for %r method only well-defined \"\n            \"if index and target are monotonic\" % method\n        )\n\n    side = \"left\" if method == \"pad\" else \"right\"\n\n    # find exact matches first (this simplifies the algorithm)\n    indexer = self.get_indexer(target)\n    nonexact = indexer == -1\n    indexer[nonexact] = self._searchsorted_monotonic(target[nonexact], side)\n    if side == \"left\":\n        # searchsorted returns \"indices into a sorted array such that,\n        # if the corresponding elements in v were inserted before the\n        # indices, the order of a would be preserved\".\n        # Thus, we need to subtract 1 to find values to the left.\n        indexer[nonexact] -= 1\n        # This also mapped not found values (values of 0 from\n        # np.searchsorted) to -1, which conveniently is also our\n        # sentinel for missing values\n    else:\n        # Mark indices to the right of the largest value as not found\n        indexer[indexer == len(self)] = -1\n    return indexer",
                "def _get_nearest_indexer(self, target, limit, tolerance):\n    \"\"\"\n    Get the indexer for the nearest index labels; requires an index with\n    values that can be subtracted from each other (e.g., not strings or\n    tuples).\n    \"\"\"\n    left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n    right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n\n    target = np.asarray(target)\n    left_distances = abs(self.values[left_indexer] - target)\n    right_distances = abs(self.values[right_indexer] - target)\n\n    op = operator.lt if self.is_monotonic_increasing else operator.le\n    indexer = np.where(\n        op(left_distances, right_distances) | (right_indexer == -1),\n        left_indexer,\n        right_indexer,\n    )\n    if tolerance is not None:\n        indexer = self._filter_indexer_tolerance(target, indexer, tolerance)\n    return indexer",
                "def _filter_indexer_tolerance(self, target, indexer, tolerance):\n    distance = abs(self.values[indexer] - target)\n    indexer = np.where(distance <= tolerance, indexer, -1)\n    return indexer",
                "@Appender(_index_shared_docs[\"_convert_scalar_indexer\"])\ndef _convert_scalar_indexer(self, key, kind=None):\n    assert kind in [\"ix\", \"loc\", \"getitem\", \"iloc\", None]\n\n    if kind == \"iloc\":\n        return self._validate_indexer(\"positional\", key, kind)\n\n    if len(self) and not isinstance(self, ABCMultiIndex):\n\n        # we can raise here if we are definitive that this\n        # is positional indexing (eg. .ix on with a float)\n        # or label indexing if we are using a type able\n        # to be represented in the index\n\n        if kind in [\"getitem\", \"ix\"] and is_float(key):\n            if not self.is_floating():\n                return self._invalid_indexer(\"label\", key)\n\n        elif kind in [\"loc\"] and is_float(key):\n\n            # we want to raise KeyError on string/mixed here\n            # technically we *could* raise a TypeError\n            # on anything but mixed though\n            if self.inferred_type not in [\n                \"floating\",\n                \"mixed-integer-float\",\n                \"integer-na\",\n                \"string\",\n                \"unicode\",\n                \"mixed\",\n            ]:\n                return self._invalid_indexer(\"label\", key)\n\n        elif kind in [\"loc\"] and is_integer(key):\n            if not self.holds_integer():\n                return self._invalid_indexer(\"label\", key)\n\n    return key",
                "@Appender(_index_shared_docs[\"_convert_slice_indexer\"])\ndef _convert_slice_indexer(self, key, kind=None):\n    assert kind in [\"ix\", \"loc\", \"getitem\", \"iloc\", None]\n\n    # if we are not a slice, then we are done\n    if not isinstance(key, slice):\n        return key\n\n    # validate iloc\n    if kind == \"iloc\":\n        return slice(\n            self._validate_indexer(\"slice\", key.start, kind),\n            self._validate_indexer(\"slice\", key.stop, kind),\n            self._validate_indexer(\"slice\", key.step, kind),\n        )\n\n    # potentially cast the bounds to integers\n    start, stop, step = key.start, key.stop, key.step\n\n    # figure out if this is a positional indexer\n    def is_int(v):\n        return v is None or is_integer(v)\n\n    is_null_slicer = start is None and stop is None\n    is_index_slice = is_int(start) and is_int(stop)\n    is_positional = is_index_slice and not self.is_integer()\n\n    if kind == \"getitem\":\n        \"\"\"\n        called from the getitem slicers, validate that we are in fact\n        integers\n        \"\"\"\n        if self.is_integer() or is_index_slice:\n            return slice(\n                self._validate_indexer(\"slice\", key.start, kind),\n                self._validate_indexer(\"slice\", key.stop, kind),\n                self._validate_indexer(\"slice\", key.step, kind),\n            )\n\n    # convert the slice to an indexer here\n\n    # if we are mixed and have integers\n    try:\n        if is_positional and self.is_mixed():\n            # Validate start & stop\n            if start is not None:\n                self.get_loc(start)\n            if stop is not None:\n                self.get_loc(stop)\n            is_positional = False\n    except KeyError:\n        if self.inferred_type in [\"mixed-integer-float\", \"integer-na\"]:\n            raise\n\n    if is_null_slicer:\n        indexer = key\n    elif is_positional:\n        indexer = key\n    else:\n        try:\n            indexer = self.slice_indexer(start, stop, step, kind=kind)\n        except Exception:\n            if is_index_slice:\n                if self.is_integer():\n                    raise\n                else:\n                    indexer = key\n            else:\n                raise\n\n    return indexer",
                "def _convert_listlike_indexer(self, keyarr, kind=None):\n    \"\"\"\n    Parameters\n    ----------\n    keyarr : list-like\n        Indexer to convert.\n\n    Returns\n    -------\n    indexer : numpy.ndarray or None\n        Return an ndarray or None if cannot convert.\n    keyarr : numpy.ndarray\n        Return tuple-safe keys.\n    \"\"\"\n    if isinstance(keyarr, Index):\n        keyarr = self._convert_index_indexer(keyarr)\n    else:\n        keyarr = self._convert_arr_indexer(keyarr)\n\n    indexer = self._convert_list_indexer(keyarr, kind=kind)\n    return indexer, keyarr",
                "@Appender(_index_shared_docs[\"_convert_arr_indexer\"])\ndef _convert_arr_indexer(self, keyarr):\n    keyarr = com.asarray_tuplesafe(keyarr)\n    return keyarr",
                "@Appender(_index_shared_docs[\"_convert_index_indexer\"])\ndef _convert_index_indexer(self, keyarr):\n    return keyarr",
                "@Appender(_index_shared_docs[\"_convert_list_indexer\"])\ndef _convert_list_indexer(self, keyarr, kind=None):\n    if (\n        kind in [None, \"iloc\", \"ix\"]\n        and is_integer_dtype(keyarr)\n        and not self.is_floating()\n        and not isinstance(keyarr, ABCPeriodIndex)\n    ):\n\n        if self.inferred_type == \"mixed-integer\":\n            indexer = self.get_indexer(keyarr)\n            if (indexer >= 0).all():\n                return indexer\n            # missing values are flagged as -1 by get_indexer and negative\n            # indices are already converted to positive indices in the\n            # above if-statement, so the negative flags are changed to\n            # values outside the range of indices so as to trigger an\n            # IndexError in maybe_convert_indices\n            indexer[indexer < 0] = len(self)\n\n            return maybe_convert_indices(indexer, len(self))\n\n        elif not self.inferred_type == \"integer\":\n            keyarr = np.where(keyarr < 0, len(self) + keyarr, keyarr)\n            return keyarr\n\n    return None",
                "def _invalid_indexer(self, form, key):\n    \"\"\"\n    Consistent invalid indexer message.\n    \"\"\"\n    raise TypeError(\n        \"cannot do {form} indexing on {klass} with these \"\n        \"indexers [{key}] of {kind}\".format(\n            form=form, klass=type(self), key=key, kind=type(key)\n        )\n    )",
                "def _can_reindex(self, indexer):\n    \"\"\"\n    Check if we are allowing reindexing with this particular indexer.\n\n    Parameters\n    ----------\n    indexer : an integer indexer\n\n    Raises\n    ------\n    ValueError if its a duplicate axis\n    \"\"\"\n\n    # trying to reindex on an axis with duplicates\n    if not self.is_unique and len(indexer):\n        raise ValueError(\"cannot reindex from a duplicate axis\")",
                "def reindex(self, target, method=None, level=None, limit=None, tolerance=None):\n    \"\"\"\n    Create index with target's values (move/add/delete values\n    as necessary).\n\n    Parameters\n    ----------\n    target : an iterable\n\n    Returns\n    -------\n    new_index : pd.Index\n        Resulting index.\n    indexer : np.ndarray or None\n        Indices of output values in original index.\n    \"\"\"\n    # GH6552: preserve names when reindexing to non-named target\n    # (i.e. neither Index nor Series).\n    preserve_names = not hasattr(target, \"name\")\n\n    # GH7774: preserve dtype/tz if target is empty and not an Index.\n    target = _ensure_has_len(target)  # target may be an iterator\n\n    if not isinstance(target, Index) and len(target) == 0:\n        attrs = self._get_attributes_dict()\n        attrs.pop(\"freq\", None)  # don't preserve freq\n        values = self._data[:0]  # appropriately-dtyped empty array\n        target = self._simple_new(values, dtype=self.dtype, **attrs)\n    else:\n        target = ensure_index(target)\n\n    if level is not None:\n        if method is not None:\n            raise TypeError(\"Fill method not supported if level passed\")\n        _, indexer, _ = self._join_level(\n            target, level, how=\"right\", return_indexers=True\n        )\n    else:\n        if self.equals(target):\n            indexer = None\n        else:\n            # check is_overlapping for IntervalIndex compat\n            if self.is_unique and not getattr(self, \"is_overlapping\", False):\n                indexer = self.get_indexer(\n                    target, method=method, limit=limit, tolerance=tolerance\n                )\n            else:\n                if method is not None or limit is not None:\n                    raise ValueError(\n                        \"cannot reindex a non-unique index \"\n                        \"with a method or limit\"\n                    )\n                indexer, missing = self.get_indexer_non_unique(target)\n\n    if preserve_names and target.nlevels == 1 and target.name != self.name:\n        target = target.copy()\n        target.name = self.name\n\n    return target, indexer",
                "def _reindex_non_unique(self, target):\n    \"\"\"\n    Create a new index with target's values (move/add/delete values as\n    necessary) use with non-unique Index and a possibly non-unique target.\n\n    Parameters\n    ----------\n    target : an iterable\n\n    Returns\n    -------\n    new_index : pd.Index\n        Resulting index.\n    indexer : np.ndarray or None\n        Indices of output values in original index.\n\n    \"\"\"\n\n    target = ensure_index(target)\n    indexer, missing = self.get_indexer_non_unique(target)\n    check = indexer != -1\n    new_labels = self.take(indexer[check])\n    new_indexer = None\n\n    if len(missing):\n        length = np.arange(len(indexer))\n\n        missing = ensure_platform_int(missing)\n        missing_labels = target.take(missing)\n        missing_indexer = ensure_int64(length[~check])\n        cur_labels = self.take(indexer[check]).values\n        cur_indexer = ensure_int64(length[check])\n\n        new_labels = np.empty(tuple([len(indexer)]), dtype=object)\n        new_labels[cur_indexer] = cur_labels\n        new_labels[missing_indexer] = missing_labels\n\n        # a unique indexer\n        if target.is_unique:\n\n            # see GH5553, make sure we use the right indexer\n            new_indexer = np.arange(len(indexer))\n            new_indexer[cur_indexer] = np.arange(len(cur_labels))\n            new_indexer[missing_indexer] = -1\n\n        # we have a non_unique selector, need to use the original\n        # indexer here\n        else:\n\n            # need to retake to have the same size as the indexer\n            indexer[~check] = -1\n\n            # reset the new indexer to account for the new size\n            new_indexer = np.arange(len(self.take(indexer)))\n            new_indexer[~check] = -1\n\n    new_index = self._shallow_copy_with_infer(new_labels, freq=None)\n    return new_index, indexer, new_indexer",
                "@Appender(_index_shared_docs[\"join\"])\ndef join(self, other, how=\"left\", level=None, return_indexers=False, sort=False):\n    self_is_mi = isinstance(self, ABCMultiIndex)\n    other_is_mi = isinstance(other, ABCMultiIndex)\n\n    # try to figure out the join level\n    # GH3662\n    if level is None and (self_is_mi or other_is_mi):\n\n        # have the same levels/names so a simple join\n        if self.names == other.names:\n            pass\n        else:\n            return self._join_multi(other, how=how, return_indexers=return_indexers)\n\n    # join on the level\n    if level is not None and (self_is_mi or other_is_mi):\n        return self._join_level(\n            other, level, how=how, return_indexers=return_indexers\n        )\n\n    other = ensure_index(other)\n\n    if len(other) == 0 and how in (\"left\", \"outer\"):\n        join_index = self._shallow_copy()\n        if return_indexers:\n            rindexer = np.repeat(-1, len(join_index))\n            return join_index, None, rindexer\n        else:\n            return join_index\n\n    if len(self) == 0 and how in (\"right\", \"outer\"):\n        join_index = other._shallow_copy()\n        if return_indexers:\n            lindexer = np.repeat(-1, len(join_index))\n            return join_index, lindexer, None\n        else:\n            return join_index\n\n    if self._join_precedence < other._join_precedence:\n        how = {\"right\": \"left\", \"left\": \"right\"}.get(how, how)\n        result = other.join(\n            self, how=how, level=level, return_indexers=return_indexers\n        )\n        if return_indexers:\n            x, y, z = result\n            result = x, z, y\n        return result\n\n    if not is_dtype_equal(self.dtype, other.dtype):\n        this = self.astype(\"O\")\n        other = other.astype(\"O\")\n        return this.join(other, how=how, return_indexers=return_indexers)\n\n    _validate_join_method(how)\n\n    if not self.is_unique and not other.is_unique:\n        return self._join_non_unique(\n            other, how=how, return_indexers=return_indexers\n        )\n    elif not self.is_unique or not other.is_unique:\n        if self.is_monotonic and other.is_monotonic:\n            return self._join_monotonic(\n                other, how=how, return_indexers=return_indexers\n            )\n        else:\n            return self._join_non_unique(\n                other, how=how, return_indexers=return_indexers\n            )\n    elif self.is_monotonic and other.is_monotonic:\n        try:\n            return self._join_monotonic(\n                other, how=how, return_indexers=return_indexers\n            )\n        except TypeError:\n            pass\n\n    if how == \"left\":\n        join_index = self\n    elif how == \"right\":\n        join_index = other\n    elif how == \"inner\":\n        # TODO: sort=False here for backwards compat. It may\n        # be better to use the sort parameter passed into join\n        join_index = self.intersection(other, sort=False)\n    elif how == \"outer\":\n        # TODO: sort=True here for backwards compat. It may\n        # be better to use the sort parameter passed into join\n        join_index = self.union(other)\n\n    if sort:\n        join_index = join_index.sort_values()\n\n    if return_indexers:\n        if join_index is self:\n            lindexer = None\n        else:\n            lindexer = self.get_indexer(join_index)\n        if join_index is other:\n            rindexer = None\n        else:\n            rindexer = other.get_indexer(join_index)\n        return join_index, lindexer, rindexer\n    else:\n        return join_index",
                "def _join_multi(self, other, how, return_indexers=True):\n    from .multi import MultiIndex\n    from pandas.core.reshape.merge import _restore_dropped_levels_multijoin\n\n    # figure out join names\n    self_names = set(com.not_none(*self.names))\n    other_names = set(com.not_none(*other.names))\n    overlap = self_names & other_names\n\n    # need at least 1 in common\n    if not overlap:\n        raise ValueError(\"cannot join with no overlapping index names\")\n\n    self_is_mi = isinstance(self, MultiIndex)\n    other_is_mi = isinstance(other, MultiIndex)\n\n    if self_is_mi and other_is_mi:\n\n        # Drop the non-matching levels from left and right respectively\n        ldrop_names = list(self_names - overlap)\n        rdrop_names = list(other_names - overlap)\n\n        self_jnlevels = self.droplevel(ldrop_names)\n        other_jnlevels = other.droplevel(rdrop_names)\n\n        # Join left and right\n        # Join on same leveled multi-index frames is supported\n        join_idx, lidx, ridx = self_jnlevels.join(\n            other_jnlevels, how, return_indexers=True\n        )\n\n        # Restore the dropped levels\n        # Returned index level order is\n        # common levels, ldrop_names, rdrop_names\n        dropped_names = ldrop_names + rdrop_names\n\n        levels, codes, names = _restore_dropped_levels_multijoin(\n            self, other, dropped_names, join_idx, lidx, ridx\n        )\n\n        # Re-create the multi-index\n        multi_join_idx = MultiIndex(\n            levels=levels, codes=codes, names=names, verify_integrity=False\n        )\n\n        multi_join_idx = multi_join_idx.remove_unused_levels()\n\n        return multi_join_idx, lidx, ridx\n\n    jl = list(overlap)[0]\n\n    # Case where only one index is multi\n    # make the indices into mi's that match\n    flip_order = False\n    if self_is_mi:\n        self, other = other, self\n        flip_order = True\n        # flip if join method is right or left\n        how = {\"right\": \"left\", \"left\": \"right\"}.get(how, how)\n\n    level = other.names.index(jl)\n    result = self._join_level(\n        other, level, how=how, return_indexers=return_indexers\n    )\n\n    if flip_order:\n        if isinstance(result, tuple):\n            return result[0], result[2], result[1]\n    return result",
                "def _join_non_unique(self, other, how=\"left\", return_indexers=False):\n    from pandas.core.reshape.merge import _get_join_indexers\n\n    left_idx, right_idx = _get_join_indexers(\n        [self._ndarray_values], [other._ndarray_values], how=how, sort=True\n    )\n\n    left_idx = ensure_platform_int(left_idx)\n    right_idx = ensure_platform_int(right_idx)\n\n    join_index = np.asarray(self._ndarray_values.take(left_idx))\n    mask = left_idx == -1\n    np.putmask(join_index, mask, other._ndarray_values.take(right_idx))\n\n    join_index = self._wrap_joined_index(join_index, other)\n\n    if return_indexers:\n        return join_index, left_idx, right_idx\n    else:\n        return join_index",
                "def _join_level(\n    self, other, level, how=\"left\", return_indexers=False, keep_order=True\n):\n    \"\"\"\n    The join method *only* affects the level of the resulting\n    MultiIndex. Otherwise it just exactly aligns the Index data to the\n    labels of the level in the MultiIndex.\n\n    If ```keep_order == True```, the order of the data indexed by the\n    MultiIndex will not be changed; otherwise, it will tie out\n    with `other`.\n    \"\"\"\n    from .multi import MultiIndex\n\n    def _get_leaf_sorter(labels):\n        \"\"\"\n        Returns sorter for the inner most level while preserving the\n        order of higher levels.\n        \"\"\"\n        if labels[0].size == 0:\n            return np.empty(0, dtype=\"int64\")\n\n        if len(labels) == 1:\n            lab = ensure_int64(labels[0])\n            sorter, _ = libalgos.groupsort_indexer(lab, 1 + lab.max())\n            return sorter\n\n        # find indexers of beginning of each set of\n        # same-key labels w.r.t all but last level\n        tic = labels[0][:-1] != labels[0][1:]\n        for lab in labels[1:-1]:\n            tic |= lab[:-1] != lab[1:]\n\n        starts = np.hstack(([True], tic, [True])).nonzero()[0]\n        lab = ensure_int64(labels[-1])\n        return lib.get_level_sorter(lab, ensure_int64(starts))\n\n    if isinstance(self, MultiIndex) and isinstance(other, MultiIndex):\n        raise TypeError(\"Join on level between two MultiIndex objects is ambiguous\")\n\n    left, right = self, other\n\n    flip_order = not isinstance(self, MultiIndex)\n    if flip_order:\n        left, right = right, left\n        how = {\"right\": \"left\", \"left\": \"right\"}.get(how, how)\n\n    level = left._get_level_number(level)\n    old_level = left.levels[level]\n\n    if not right.is_unique:\n        raise NotImplementedError(\n            \"Index._join_level on non-unique index is not implemented\"\n        )\n\n    new_level, left_lev_indexer, right_lev_indexer = old_level.join(\n        right, how=how, return_indexers=True\n    )\n\n    if left_lev_indexer is None:\n        if keep_order or len(left) == 0:\n            left_indexer = None\n            join_index = left\n        else:  # sort the leaves\n            left_indexer = _get_leaf_sorter(left.codes[: level + 1])\n            join_index = left[left_indexer]\n\n    else:\n        left_lev_indexer = ensure_int64(left_lev_indexer)\n        rev_indexer = lib.get_reverse_indexer(left_lev_indexer, len(old_level))\n\n        new_lev_codes = algos.take_nd(\n            rev_indexer, left.codes[level], allow_fill=False\n        )\n\n        new_codes = list(left.codes)\n        new_codes[level] = new_lev_codes\n\n        new_levels = list(left.levels)\n        new_levels[level] = new_level\n\n        if keep_order:  # just drop missing values. o.w. keep order\n            left_indexer = np.arange(len(left), dtype=np.intp)\n            mask = new_lev_codes != -1\n            if not mask.all():\n                new_codes = [lab[mask] for lab in new_codes]\n                left_indexer = left_indexer[mask]\n\n        else:  # tie out the order with other\n            if level == 0:  # outer most level, take the fast route\n                ngroups = 1 + new_lev_codes.max()\n                left_indexer, counts = libalgos.groupsort_indexer(\n                    new_lev_codes, ngroups\n                )\n\n                # missing values are placed first; drop them!\n                left_indexer = left_indexer[counts[0] :]\n                new_codes = [lab[left_indexer] for lab in new_codes]\n\n            else:  # sort the leaves\n                mask = new_lev_codes != -1\n                mask_all = mask.all()\n                if not mask_all:\n                    new_codes = [lab[mask] for lab in new_codes]\n\n                left_indexer = _get_leaf_sorter(new_codes[: level + 1])\n                new_codes = [lab[left_indexer] for lab in new_codes]\n\n                # left_indexers are w.r.t masked frame.\n                # reverse to original frame!\n                if not mask_all:\n                    left_indexer = mask.nonzero()[0][left_indexer]\n\n        join_index = MultiIndex(\n            levels=new_levels,\n            codes=new_codes,\n            names=left.names,\n            verify_integrity=False,\n        )\n\n    if right_lev_indexer is not None:\n        right_indexer = algos.take_nd(\n            right_lev_indexer, join_index.codes[level], allow_fill=False\n        )\n    else:\n        right_indexer = join_index.codes[level]\n\n    if flip_order:\n        left_indexer, right_indexer = right_indexer, left_indexer\n\n    if return_indexers:\n        left_indexer = (\n            None if left_indexer is None else ensure_platform_int(left_indexer)\n        )\n        right_indexer = (\n            None if right_indexer is None else ensure_platform_int(right_indexer)\n        )\n        return join_index, left_indexer, right_indexer\n    else:\n        return join_index",
                "def _join_monotonic(self, other, how=\"left\", return_indexers=False):\n    if self.equals(other):\n        ret_index = other if how == \"right\" else self\n        if return_indexers:\n            return ret_index, None, None\n        else:\n            return ret_index\n\n    sv = self._ndarray_values\n    ov = other._ndarray_values\n\n    if self.is_unique and other.is_unique:\n        # We can perform much better than the general case\n        if how == \"left\":\n            join_index = self\n            lidx = None\n            ridx = self._left_indexer_unique(sv, ov)\n        elif how == \"right\":\n            join_index = other\n            lidx = self._left_indexer_unique(ov, sv)\n            ridx = None\n        elif how == \"inner\":\n            join_index, lidx, ridx = self._inner_indexer(sv, ov)\n            join_index = self._wrap_joined_index(join_index, other)\n        elif how == \"outer\":\n            join_index, lidx, ridx = self._outer_indexer(sv, ov)\n            join_index = self._wrap_joined_index(join_index, other)\n    else:\n        if how == \"left\":\n            join_index, lidx, ridx = self._left_indexer(sv, ov)\n        elif how == \"right\":\n            join_index, ridx, lidx = self._left_indexer(ov, sv)\n        elif how == \"inner\":\n            join_index, lidx, ridx = self._inner_indexer(sv, ov)\n        elif how == \"outer\":\n            join_index, lidx, ridx = self._outer_indexer(sv, ov)\n        join_index = self._wrap_joined_index(join_index, other)\n\n    if return_indexers:\n        lidx = None if lidx is None else ensure_platform_int(lidx)\n        ridx = None if ridx is None else ensure_platform_int(ridx)\n        return join_index, lidx, ridx\n    else:\n        return join_index",
                "def _wrap_joined_index(self, joined, other):\n    name = get_op_result_name(self, other)\n    return Index(joined, name=name)",
                "@property\ndef values(self):\n    \"\"\"\n    Return an array representing the data in the Index.\n\n    .. warning::\n\n       We recommend using :attr:`Index.array` or\n       :meth:`Index.to_numpy`, depending on whether you need\n       a reference to the underlying data or a NumPy array.\n\n    Returns\n    -------\n    array: numpy.ndarray or ExtensionArray\n\n    See Also\n    --------\n    Index.array : Reference to the underlying data.\n    Index.to_numpy : A NumPy array representing the underlying data.\n    \"\"\"\n    return self._data.view(np.ndarray)",
                "@property\ndef _values(self) -> Union[ExtensionArray, ABCIndexClass, np.ndarray]:\n    # TODO(EA): remove index types as they become extension arrays\n    \"\"\"\n    The best array representation.\n\n    This is an ndarray, ExtensionArray, or Index subclass. This differs\n    from ``_ndarray_values``, which always returns an ndarray.\n\n    Both ``_values`` and ``_ndarray_values`` are consistent between\n    ``Series`` and ``Index``.\n\n    It may differ from the public '.values' method.\n\n    index             | values          | _values       | _ndarray_values |\n    ----------------- | --------------- | ------------- | --------------- |\n    Index             | ndarray         | ndarray       | ndarray         |\n    CategoricalIndex  | Categorical     | Categorical   | ndarray[int]    |\n    DatetimeIndex     | ndarray[M8ns]   | ndarray[M8ns] | ndarray[M8ns]   |\n    DatetimeIndex[tz] | ndarray[M8ns]   | DTI[tz]       | ndarray[M8ns]   |\n    PeriodIndex       | ndarray[object] | PeriodArray   | ndarray[int]    |\n    IntervalIndex     | IntervalArray   | IntervalArray | ndarray[object] |\n\n    See Also\n    --------\n    values\n    _ndarray_values\n    \"\"\"\n    return self._data",
                "def get_values(self):\n    \"\"\"\n    Return `Index` data as an `numpy.ndarray`.\n\n    .. deprecated:: 0.25.0\n        Use :meth:`Index.to_numpy` or :attr:`Index.array` instead.\n\n    Returns\n    -------\n    numpy.ndarray\n        A one-dimensional numpy array of the `Index` values.\n\n    See Also\n    --------\n    Index.values : The attribute that get_values wraps.\n\n    Examples\n    --------\n    Getting the `Index` values of a `DataFrame`:\n\n    >>> df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n    ...                    index=['a', 'b', 'c'], columns=['A', 'B', 'C'])\n    >>> df\n       A  B  C\n    a  1  2  3\n    b  4  5  6\n    c  7  8  9\n    >>> df.index.get_values()\n    array(['a', 'b', 'c'], dtype=object)\n\n    Standalone `Index` values:\n\n    >>> idx = pd.Index(['1', '2', '3'])\n    >>> idx.get_values()\n    array(['1', '2', '3'], dtype=object)\n\n    `MultiIndex` arrays also have only one dimension:\n\n    >>> midx = pd.MultiIndex.from_arrays([[1, 2, 3], ['a', 'b', 'c']],\n    ...                                  names=('number', 'letter'))\n    >>> midx.get_values()\n    array([(1, 'a'), (2, 'b'), (3, 'c')], dtype=object)\n    >>> midx.get_values().ndim\n    1\n    \"\"\"\n    warnings.warn(\n        \"The 'get_values' method is deprecated and will be removed in a \"\n        \"future version. Use '.to_numpy()' or '.array' instead.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n    return self._internal_get_values()",
                "def _internal_get_values(self):\n    return self.values",
                "@Appender(IndexOpsMixin.memory_usage.__doc__)\ndef memory_usage(self, deep=False):\n    result = super().memory_usage(deep=deep)\n\n    # include our engine hashtable\n    result += self._engine.sizeof(deep=deep)\n    return result",
                "@Appender(_index_shared_docs[\"where\"])\ndef where(self, cond, other=None):\n    if other is None:\n        other = self._na_value\n\n    dtype = self.dtype\n    values = self.values\n\n    if is_bool(other) or is_bool_dtype(other):\n\n        # bools force casting\n        values = values.astype(object)\n        dtype = None\n\n    values = np.where(cond, values, other)\n\n    if self._is_numeric_dtype and np.any(isna(values)):\n        # We can't coerce to the numeric dtype of \"self\" (unless\n        # it's float) if there are NaN values in our output.\n        dtype = None\n\n    return self._shallow_copy_with_infer(values, dtype=dtype)",
                "@classmethod\ndef _try_convert_to_int_index(cls, data, copy, name, dtype):\n    \"\"\"\n    Attempt to convert an array of data into an integer index.\n\n    Parameters\n    ----------\n    data : The data to convert.\n    copy : Whether to copy the data or not.\n    name : The name of the index returned.\n\n    Returns\n    -------\n    int_index : data converted to either an Int64Index or a\n                UInt64Index\n\n    Raises\n    ------\n    ValueError if the conversion was not successful.\n    \"\"\"\n\n    from .numeric import Int64Index, UInt64Index\n\n    if not is_unsigned_integer_dtype(dtype):\n        # skip int64 conversion attempt if uint-like dtype is passed, as\n        # this could return Int64Index when UInt64Index is what's desired\n        try:\n            res = data.astype(\"i8\", copy=False)\n            if (res == data).all():\n                return Int64Index(res, copy=copy, name=name)\n        except (OverflowError, TypeError, ValueError):\n            pass\n\n    # Conversion to int64 failed (possibly due to overflow) or was skipped,\n    # so let's try now with uint64.\n    try:\n        res = data.astype(\"u8\", copy=False)\n        if (res == data).all():\n            return UInt64Index(res, copy=copy, name=name)\n    except (OverflowError, TypeError, ValueError):\n        pass\n\n    raise ValueError",
                "@classmethod\ndef _scalar_data_error(cls, data):\n    raise TypeError(\n        \"{0}(...) must be called with a collection of some \"\n        \"kind, {1} was passed\".format(cls.__name__, repr(data))\n    )",
                "@classmethod\ndef _string_data_error(cls, data):\n    raise TypeError(\n        \"String dtype not supported, you may need \"\n        \"to explicitly cast to a numeric type\"\n    )",
                "@classmethod\ndef _coerce_to_ndarray(cls, data):\n    \"\"\"\n    Coerces data to ndarray.\n\n    Converts other iterables to list first and then to array.\n    Does not touch ndarrays.\n\n    Raises\n    ------\n    TypeError\n        When the data passed in is a scalar.\n    \"\"\"\n\n    if not isinstance(data, (np.ndarray, Index)):\n        if data is None or is_scalar(data):\n            cls._scalar_data_error(data)\n\n        # other iterable of some kind\n        if not isinstance(data, (ABCSeries, list, tuple)):\n            data = list(data)\n        data = np.asarray(data)\n    return data",
                "def _coerce_scalar_to_index(self, item):\n    \"\"\"\n    We need to coerce a scalar to a compat for our index type.\n\n    Parameters\n    ----------\n    item : scalar item to coerce\n    \"\"\"\n    dtype = self.dtype\n\n    if self._is_numeric_dtype and isna(item):\n        # We can't coerce to the numeric dtype of \"self\" (unless\n        # it's float) if there are NaN values in our output.\n        dtype = None\n\n    return Index([item], dtype=dtype, **self._get_attributes_dict())",
                "def _to_safe_for_reshape(self):\n    \"\"\"\n    Convert to object if we are a categorical.\n    \"\"\"\n    return self",
                "def _convert_for_op(self, value):\n    \"\"\"\n    Convert value to be insertable to ndarray.\n    \"\"\"\n    return value",
                "def _assert_can_do_op(self, value):\n    \"\"\"\n    Check value is valid for scalar op.\n    \"\"\"\n    if not is_scalar(value):\n        msg = \"'value' must be a scalar, passed: {0}\"\n        raise TypeError(msg.format(type(value).__name__))",
                "@property\ndef _has_complex_internals(self):\n    # to disable groupby tricks in MultiIndex\n    return False",
                "def _is_memory_usage_qualified(self):\n    \"\"\"\n    Return a boolean if we need a qualified .info display.\n    \"\"\"\n    return self.is_object()",
                "def is_type_compatible(self, kind):\n    \"\"\"\n    Whether the index type is compatible with the provided type.\n    \"\"\"\n    return kind == self.inferred_type",
                "@Appender(_index_shared_docs[\"contains\"] % _index_doc_kwargs)\ndef __contains__(self, key):\n    hash(key)\n    try:\n        return key in self._engine\n    except (OverflowError, TypeError, ValueError):\n        return False",
                "def contains(self, key):\n    \"\"\"\n    Return a boolean indicating whether the provided key is in the index.\n\n    .. deprecated:: 0.25.0\n        Use ``key in index`` instead of ``index.contains(key)``.\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    warnings.warn(\n        \"The 'contains' method is deprecated and will be removed in a \"\n        \"future version. Use 'key in index' instead of \"\n        \"'index.contains(key)'\",\n        FutureWarning,\n        stacklevel=2,\n    )\n    return key in self",
                "def __hash__(self):\n    raise TypeError(\"unhashable type: %r\" % type(self).__name__)",
                "def __setitem__(self, key, value):\n    raise TypeError(\"Index does not support mutable operations\")",
                "def __getitem__(self, key):\n    \"\"\"\n    Override numpy.ndarray's __getitem__ method to work as desired.\n\n    This function adds lists and Series as valid boolean indexers\n    (ndarrays only supports ndarray with dtype=bool).\n\n    If resulting ndim != 1, plain ndarray is returned instead of\n    corresponding `Index` subclass.\n\n    \"\"\"\n    # There's no custom logic to be implemented in __getslice__, so it's\n    # not overloaded intentionally.\n    getitem = self._data.__getitem__\n    promote = self._shallow_copy\n\n    if is_scalar(key):\n        key = com.cast_scalar_indexer(key)\n        return getitem(key)\n\n    if isinstance(key, slice):\n        # This case is separated from the conditional above to avoid\n        # pessimization of basic indexing.\n        return promote(getitem(key))\n\n    if com.is_bool_indexer(key):\n        key = np.asarray(key, dtype=bool)\n\n    key = com.values_from_object(key)\n    result = getitem(key)\n    if not is_scalar(result):\n        return promote(result)\n    else:\n        return result",
                "def _can_hold_identifiers_and_holds_name(self, name):\n    \"\"\"\n    Faster check for ``name in self`` when we know `name` is a Python\n    identifier (e.g. in NDFrame.__getattr__, which hits this to support\n    . key lookup). For indexes that can't hold identifiers (everything\n    but object & categorical) we just return False.\n\n    https://github.com/pandas-dev/pandas/issues/19764\n    \"\"\"\n    if self.is_object() or self.is_categorical():\n        return name in self\n    return False",
                "def append(self, other):\n    \"\"\"\n    Append a collection of Index options together.\n\n    Parameters\n    ----------\n    other : Index or list/tuple of indices\n\n    Returns\n    -------\n    appended : Index\n    \"\"\"\n\n    to_concat = [self]\n\n    if isinstance(other, (list, tuple)):\n        to_concat = to_concat + list(other)\n    else:\n        to_concat.append(other)\n\n    for obj in to_concat:\n        if not isinstance(obj, Index):\n            raise TypeError(\"all inputs must be Index\")\n\n    names = {obj.name for obj in to_concat}\n    name = None if len(names) > 1 else self.name\n\n    return self._concat(to_concat, name)",
                "def _concat(self, to_concat, name):\n\n    typs = _concat.get_dtype_kinds(to_concat)\n\n    if len(typs) == 1:\n        return self._concat_same_dtype(to_concat, name=name)\n    return _concat._concat_index_asobject(to_concat, name=name)",
                "def _concat_same_dtype(self, to_concat, name):\n    \"\"\"\n    Concatenate to_concat which has the same class.\n    \"\"\"\n    # must be overridden in specific classes\n    return _concat._concat_index_asobject(to_concat, name)",
                "def putmask(self, mask, value):\n    \"\"\"\n    Return a new Index of the values set with the mask.\n\n    Returns\n    -------\n    Index\n\n    See Also\n    --------\n    numpy.ndarray.putmask\n    \"\"\"\n    values = self.values.copy()\n    try:\n        np.putmask(values, mask, self._convert_for_op(value))\n        return self._shallow_copy(values)\n    except (ValueError, TypeError) as err:\n        if is_object_dtype(self):\n            raise err\n\n        # coerces to object\n        return self.astype(object).putmask(mask, value)",
                "def equals(self, other):\n    \"\"\"\n    Determine if two Index objects contain the same elements.\n\n    Returns\n    -------\n    bool\n        True if \"other\" is an Index and it has the same elements as calling\n        index; False otherwise.\n    \"\"\"\n    if self.is_(other):\n        return True\n\n    if not isinstance(other, Index):\n        return False\n\n    if is_object_dtype(self) and not is_object_dtype(other):\n        # if other is not object, use other's logic for coercion\n        return other.equals(self)\n\n    try:\n        return array_equivalent(\n            com.values_from_object(self), com.values_from_object(other)\n        )\n    except Exception:\n        return False",
                "def identical(self, other):\n    \"\"\"\n    Similar to equals, but check that other comparable attributes are\n    also equal.\n\n    Returns\n    -------\n    bool\n        If two Index objects have equal elements and same type True,\n        otherwise False.\n    \"\"\"\n    return (\n        self.equals(other)\n        and all(\n            (\n                getattr(self, c, None) == getattr(other, c, None)\n                for c in self._comparables\n            )\n        )\n        and type(self) == type(other)\n    )",
                "def asof(self, label):\n    \"\"\"\n    Return the label from the index, or, if not present, the previous one.\n\n    Assuming that the index is sorted, return the passed index label if it\n    is in the index, or return the previous index label if the passed one\n    is not in the index.\n\n    Parameters\n    ----------\n    label : object\n        The label up to which the method returns the latest index label.\n\n    Returns\n    -------\n    object\n        The passed label if it is in the index. The previous label if the\n        passed label is not in the sorted index or `NaN` if there is no\n        such label.\n\n    See Also\n    --------\n    Series.asof : Return the latest value in a Series up to the\n        passed index.\n    merge_asof : Perform an asof merge (similar to left join but it\n        matches on nearest key rather than equal key).\n    Index.get_loc : An `asof` is a thin wrapper around `get_loc`\n        with method='pad'.\n\n    Examples\n    --------\n    `Index.asof` returns the latest index label up to the passed label.\n\n    >>> idx = pd.Index(['2013-12-31', '2014-01-02', '2014-01-03'])\n    >>> idx.asof('2014-01-01')\n    '2013-12-31'\n\n    If the label is in the index, the method returns the passed label.\n\n    >>> idx.asof('2014-01-02')\n    '2014-01-02'\n\n    If all of the labels in the index are later than the passed label,\n    NaN is returned.\n\n    >>> idx.asof('1999-01-02')\n    nan\n\n    If the index is not sorted, an error is raised.\n\n    >>> idx_not_sorted = pd.Index(['2013-12-31', '2015-01-02',\n    ...                            '2014-01-03'])\n    >>> idx_not_sorted.asof('2013-12-31')\n    Traceback (most recent call last):\n    ValueError: index must be monotonic increasing or decreasing\n    \"\"\"\n    try:\n        loc = self.get_loc(label, method=\"pad\")\n    except KeyError:\n        return self._na_value\n    else:\n        if isinstance(loc, slice):\n            loc = loc.indices(len(self))[-1]\n        return self[loc]",
                "def asof_locs(self, where, mask):\n    \"\"\"\n    Find the locations (indices) of the labels from the index for\n    every entry in the `where` argument.\n\n    As in the `asof` function, if the label (a particular entry in\n    `where`) is not in the index, the latest index label upto the\n    passed label is chosen and its index returned.\n\n    If all of the labels in the index are later than a label in `where`,\n    -1 is returned.\n\n    `mask` is used to ignore NA values in the index during calculation.\n\n    Parameters\n    ----------\n    where : Index\n        An Index consisting of an array of timestamps.\n    mask : array-like\n        Array of booleans denoting where values in the original\n        data are not NA.\n\n    Returns\n    -------\n    numpy.ndarray\n        An array of locations (indices) of the labels from the Index\n        which correspond to the return values of the `asof` function\n        for every element in `where`.\n    \"\"\"\n    locs = self.values[mask].searchsorted(where.values, side=\"right\")\n    locs = np.where(locs > 0, locs - 1, 0)\n\n    result = np.arange(len(self))[mask].take(locs)\n\n    first = mask.argmax()\n    result[(locs == 0) & (where.values < self.values[first])] = -1\n\n    return result",
                "def sort_values(self, return_indexer=False, ascending=True):\n    \"\"\"\n    Return a sorted copy of the index.\n\n    Return a sorted copy of the index, and optionally return the indices\n    that sorted the index itself.\n\n    Parameters\n    ----------\n    return_indexer : bool, default False\n        Should the indices that would sort the index be returned.\n    ascending : bool, default True\n        Should the index values be sorted in an ascending order.\n\n    Returns\n    -------\n    sorted_index : pandas.Index\n        Sorted copy of the index.\n    indexer : numpy.ndarray, optional\n        The indices that the index itself was sorted by.\n\n    See Also\n    --------\n    Series.sort_values : Sort values of a Series.\n    DataFrame.sort_values : Sort values in a DataFrame.\n\n    Examples\n    --------\n    >>> idx = pd.Index([10, 100, 1, 1000])\n    >>> idx\n    Int64Index([10, 100, 1, 1000], dtype='int64')\n\n    Sort values in ascending order (default behavior).\n\n    >>> idx.sort_values()\n    Int64Index([1, 10, 100, 1000], dtype='int64')\n\n    Sort values in descending order, and also get the indices `idx` was\n    sorted by.\n\n    >>> idx.sort_values(ascending=False, return_indexer=True)\n    (Int64Index([1000, 100, 10, 1], dtype='int64'), array([3, 1, 0, 2]))\n    \"\"\"\n    _as = self.argsort()\n    if not ascending:\n        _as = _as[::-1]\n\n    sorted_index = self.take(_as)\n\n    if return_indexer:\n        return sorted_index, _as\n    else:\n        return sorted_index",
                "def sort(self, *args, **kwargs):\n    \"\"\"\n    Use sort_values instead.\n    \"\"\"\n    raise TypeError(\"cannot sort an Index object in-place, use sort_values instead\")",
                "def shift(self, periods=1, freq=None):\n    \"\"\"\n    Shift index by desired number of time frequency increments.\n\n    This method is for shifting the values of datetime-like indexes\n    by a specified time increment a given number of times.\n\n    Parameters\n    ----------\n    periods : int, default 1\n        Number of periods (or increments) to shift by,\n        can be positive or negative.\n    freq : pandas.DateOffset, pandas.Timedelta or string, optional\n        Frequency increment to shift by.\n        If None, the index is shifted by its own `freq` attribute.\n        Offset aliases are valid strings, e.g., 'D', 'W', 'M' etc.\n\n    Returns\n    -------\n    pandas.Index\n        Shifted index.\n\n    See Also\n    --------\n    Series.shift : Shift values of Series.\n\n    Notes\n    -----\n    This method is only implemented for datetime-like index classes,\n    i.e., DatetimeIndex, PeriodIndex and TimedeltaIndex.\n\n    Examples\n    --------\n    Put the first 5 month starts of 2011 into an index.\n\n    >>> month_starts = pd.date_range('1/1/2011', periods=5, freq='MS')\n    >>> month_starts\n    DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01', '2011-04-01',\n                   '2011-05-01'],\n                  dtype='datetime64[ns]', freq='MS')\n\n    Shift the index by 10 days.\n\n    >>> month_starts.shift(10, freq='D')\n    DatetimeIndex(['2011-01-11', '2011-02-11', '2011-03-11', '2011-04-11',\n                   '2011-05-11'],\n                  dtype='datetime64[ns]', freq=None)\n\n    The default value of `freq` is the `freq` attribute of the index,\n    which is 'MS' (month start) in this example.\n\n    >>> month_starts.shift(10)\n    DatetimeIndex(['2011-11-01', '2011-12-01', '2012-01-01', '2012-02-01',\n                   '2012-03-01'],\n                  dtype='datetime64[ns]', freq='MS')\n    \"\"\"\n    raise NotImplementedError(\"Not supported for type %s\" % type(self).__name__)",
                "def argsort(self, *args, **kwargs):\n    \"\"\"\n    Return the integer indices that would sort the index.\n\n    Parameters\n    ----------\n    *args\n        Passed to `numpy.ndarray.argsort`.\n    **kwargs\n        Passed to `numpy.ndarray.argsort`.\n\n    Returns\n    -------\n    numpy.ndarray\n        Integer indices that would sort the index if used as\n        an indexer.\n\n    See Also\n    --------\n    numpy.argsort : Similar method for NumPy arrays.\n    Index.sort_values : Return sorted copy of Index.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['b', 'a', 'd', 'c'])\n    >>> idx\n    Index(['b', 'a', 'd', 'c'], dtype='object')\n\n    >>> order = idx.argsort()\n    >>> order\n    array([1, 0, 3, 2])\n\n    >>> idx[order]\n    Index(['a', 'b', 'c', 'd'], dtype='object')\n    \"\"\"\n    result = self.asi8\n    if result is None:\n        result = np.array(self)\n    return result.argsort(*args, **kwargs)",
                "@Appender(_index_shared_docs[\"get_value\"] % _index_doc_kwargs)\ndef get_value(self, series, key):\n\n    # if we have something that is Index-like, then\n    # use this, e.g. DatetimeIndex\n    # Things like `Series._get_value` (via .at) pass the EA directly here.\n    s = getattr(series, \"_values\", series)\n    if isinstance(s, (ExtensionArray, Index)) and is_scalar(key):\n        # GH 20882, 21257\n        # Unify Index and ExtensionArray treatment\n        # First try to convert the key to a location\n        # If that fails, raise a KeyError if an integer\n        # index, otherwise, see if key is an integer, and\n        # try that\n        try:\n            iloc = self.get_loc(key)\n            return s[iloc]\n        except KeyError:\n            if len(self) > 0 and (self.holds_integer() or self.is_boolean()):\n                raise\n            elif is_integer(key):\n                return s[key]\n\n    s = com.values_from_object(series)\n    k = com.values_from_object(key)\n\n    k = self._convert_scalar_indexer(k, kind=\"getitem\")\n    try:\n        return self._engine.get_value(s, k, tz=getattr(series.dtype, \"tz\", None))\n    except KeyError as e1:\n        if len(self) > 0 and (self.holds_integer() or self.is_boolean()):\n            raise\n\n        try:\n            return libindex.get_value_box(s, key)\n        except IndexError:\n            raise\n        except TypeError:\n            # generator/iterator-like\n            if is_iterator(key):\n                raise InvalidIndexError(key)\n            else:\n                raise e1\n        except Exception:  # pragma: no cover\n            raise e1\n    except TypeError:\n        # python 3\n        if is_scalar(key):  # pragma: no cover\n            raise IndexError(key)\n        raise InvalidIndexError(key)",
                "def set_value(self, arr, key, value):\n    \"\"\"\n    Fast lookup of value from 1-dimensional ndarray.\n\n    Notes\n    -----\n    Only use this if you know what you're doing.\n    \"\"\"\n    self._engine.set_value(\n        com.values_from_object(arr), com.values_from_object(key), value\n    )",
                "@Appender(_index_shared_docs[\"get_indexer_non_unique\"] % _index_doc_kwargs)\ndef get_indexer_non_unique(self, target):\n    target = ensure_index(target)\n    if is_categorical(target):\n        target = target.astype(target.dtype.categories.dtype)\n    pself, ptarget = self._maybe_promote(target)\n    if pself is not self or ptarget is not target:\n        return pself.get_indexer_non_unique(ptarget)\n\n    if self.is_all_dates:\n        tgt_values = target.asi8\n    else:\n        tgt_values = target._ndarray_values\n\n    indexer, missing = self._engine.get_indexer_non_unique(tgt_values)\n    return ensure_platform_int(indexer), missing",
                "def get_indexer_for(self, target, **kwargs):\n    \"\"\"\n    Guaranteed return of an indexer even when non-unique.\n\n    This dispatches to get_indexer or get_indexer_nonunique\n    as appropriate.\n\n    Returns\n    -------\n    numpy.ndarray\n        List of indices.\n    \"\"\"\n    if self.is_unique:\n        return self.get_indexer(target, **kwargs)\n    indexer, _ = self.get_indexer_non_unique(target, **kwargs)\n    return indexer",
                "def _maybe_promote(self, other):\n    # A hack, but it works\n    from pandas import DatetimeIndex\n\n    if self.inferred_type == \"date\" and isinstance(other, DatetimeIndex):\n        return DatetimeIndex(self), other\n    elif self.inferred_type == \"boolean\":\n        if not is_object_dtype(self.dtype):\n            return self.astype(\"object\"), other.astype(\"object\")\n    return self, other",
                "def groupby(self, values):\n    \"\"\"\n    Group the index labels by a given array of values.\n\n    Parameters\n    ----------\n    values : array\n        Values used to determine the groups.\n\n    Returns\n    -------\n    groups : dict\n        {group name -> group labels}\n    \"\"\"\n\n    # TODO: if we are a MultiIndex, we can do better\n    # that converting to tuples\n    if isinstance(values, ABCMultiIndex):\n        values = values.values\n    values = ensure_categorical(values)\n    result = values._reverse_indexer()\n\n    # map to the label\n    result = {k: self.take(v) for k, v in result.items()}\n\n    return result",
                "def map(self, mapper, na_action=None):\n    \"\"\"\n    Map values using input correspondence (a dict, Series, or function).\n\n    Parameters\n    ----------\n    mapper : function, dict, or Series\n        Mapping correspondence.\n    na_action : {None, 'ignore'}\n        If 'ignore', propagate NA values, without passing them to the\n        mapping correspondence.\n\n    Returns\n    -------\n    applied : Union[Index, MultiIndex], inferred\n        The output of the mapping function applied to the index.\n        If the function returns a tuple with more than one element\n        a MultiIndex will be returned.\n    \"\"\"\n\n    from .multi import MultiIndex\n\n    new_values = super()._map_values(mapper, na_action=na_action)\n\n    attributes = self._get_attributes_dict()\n\n    # we can return a MultiIndex\n    if new_values.size and isinstance(new_values[0], tuple):\n        if isinstance(self, MultiIndex):\n            names = self.names\n        elif attributes.get(\"name\"):\n            names = [attributes.get(\"name\")] * len(new_values[0])\n        else:\n            names = None\n        return MultiIndex.from_tuples(new_values, names=names)\n\n    attributes[\"copy\"] = False\n    if not new_values.size:\n        # empty\n        attributes[\"dtype\"] = self.dtype\n\n    return Index(new_values, **attributes)",
                "def isin(self, values, level=None):\n    \"\"\"\n    Return a boolean array where the index values are in `values`.\n\n    Compute boolean array of whether each index value is found in the\n    passed set of values. The length of the returned boolean array matches\n    the length of the index.\n\n    Parameters\n    ----------\n    values : set or list-like\n        Sought values.\n    level : str or int, optional\n        Name or position of the index level to use (if the index is a\n        `MultiIndex`).\n\n    Returns\n    -------\n    is_contained : ndarray\n        NumPy array of boolean values.\n\n    See Also\n    --------\n    Series.isin : Same for Series.\n    DataFrame.isin : Same method for DataFrames.\n\n    Notes\n    -----\n    In the case of `MultiIndex` you must either specify `values` as a\n    list-like object containing tuples that are the same length as the\n    number of levels, or specify `level`. Otherwise it will raise a\n    ``ValueError``.\n\n    If `level` is specified:\n\n    - if it is the name of one *and only one* index level, use that level;\n    - otherwise it should be a number indicating level position.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1,2,3])\n    >>> idx\n    Int64Index([1, 2, 3], dtype='int64')\n\n    Check whether each index value in a list of values.\n    >>> idx.isin([1, 4])\n    array([ True, False, False])\n\n    >>> midx = pd.MultiIndex.from_arrays([[1,2,3],\n    ...                                  ['red', 'blue', 'green']],\n    ...                                  names=('number', 'color'))\n    >>> midx\n    MultiIndex(levels=[[1, 2, 3], ['blue', 'green', 'red']],\n               codes=[[0, 1, 2], [2, 0, 1]],\n               names=['number', 'color'])\n\n    Check whether the strings in the 'color' level of the MultiIndex\n    are in a list of colors.\n\n    >>> midx.isin(['red', 'orange', 'yellow'], level='color')\n    array([ True, False, False])\n\n    To check across the levels of a MultiIndex, pass a list of tuples:\n\n    >>> midx.isin([(1, 'red'), (3, 'red')])\n    array([ True, False, False])\n\n    For a DatetimeIndex, string values in `values` are converted to\n    Timestamps.\n\n    >>> dates = ['2000-03-11', '2000-03-12', '2000-03-13']\n    >>> dti = pd.to_datetime(dates)\n    >>> dti\n    DatetimeIndex(['2000-03-11', '2000-03-12', '2000-03-13'],\n    dtype='datetime64[ns]', freq=None)\n\n    >>> dti.isin(['2000-03-11'])\n    array([ True, False, False])\n    \"\"\"\n    if level is not None:\n        self._validate_index_level(level)\n    return algos.isin(self, values)",
                "def _get_string_slice(self, key, use_lhs=True, use_rhs=True):\n    # this is for partial string indexing,\n    # overridden in DatetimeIndex, TimedeltaIndex and PeriodIndex\n    raise NotImplementedError",
                "def slice_indexer(self, start=None, end=None, step=None, kind=None):\n    \"\"\"\n    For an ordered or unique index, compute the slice indexer for input\n    labels and step.\n\n    Parameters\n    ----------\n    start : label, default None\n        If None, defaults to the beginning\n    end : label, default None\n        If None, defaults to the end\n    step : int, default None\n    kind : string, default None\n\n    Returns\n    -------\n    indexer : slice\n\n    Raises\n    ------\n    KeyError : If key does not exist, or key is not unique and index is\n        not ordered.\n\n    Notes\n    -----\n    This function assumes that the data is sorted, so use at your own peril\n\n    Examples\n    --------\n    This is a method on all index types. For example you can do:\n\n    >>> idx = pd.Index(list('abcd'))\n    >>> idx.slice_indexer(start='b', end='c')\n    slice(1, 3)\n\n    >>> idx = pd.MultiIndex.from_arrays([list('abcd'), list('efgh')])\n    >>> idx.slice_indexer(start='b', end=('c', 'g'))\n    slice(1, 3)\n    \"\"\"\n    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)\n\n    # return a slice\n    if not is_scalar(start_slice):\n        raise AssertionError(\"Start slice bound is non-scalar\")\n    if not is_scalar(end_slice):\n        raise AssertionError(\"End slice bound is non-scalar\")\n\n    return slice(start_slice, end_slice, step)",
                "def _maybe_cast_indexer(self, key):\n    \"\"\"\n    If we have a float key and are not a floating index, then try to cast\n    to an int if equivalent.\n    \"\"\"\n\n    if is_float(key) and not self.is_floating():\n        try:\n            ckey = int(key)\n            if ckey == key:\n                key = ckey\n        except (OverflowError, ValueError, TypeError):\n            pass\n    return key",
                "def _validate_indexer(self, form, key, kind):\n    \"\"\"\n    If we are positional indexer, validate that we have appropriate\n    typed bounds must be an integer.\n    \"\"\"\n    assert kind in [\"ix\", \"loc\", \"getitem\", \"iloc\"]\n\n    if key is None:\n        pass\n    elif is_integer(key):\n        pass\n    elif kind in [\"iloc\", \"getitem\"]:\n        self._invalid_indexer(form, key)\n    return key",
                "@Appender(_index_shared_docs[\"_maybe_cast_slice_bound\"])\ndef _maybe_cast_slice_bound(self, label, side, kind):\n    assert kind in [\"ix\", \"loc\", \"getitem\", None]\n\n    # We are a plain index here (sub-class override this method if they\n    # wish to have special treatment for floats/ints, e.g. Float64Index and\n    # datetimelike Indexes\n    # reject them\n    if is_float(label):\n        if not (kind in [\"ix\"] and (self.holds_integer() or self.is_floating())):\n            self._invalid_indexer(\"slice\", label)\n\n    # we are trying to find integer bounds on a non-integer based index\n    # this is rejected (generally .loc gets you here)\n    elif is_integer(label):\n        self._invalid_indexer(\"slice\", label)\n\n    return label",
                "def _searchsorted_monotonic(self, label, side=\"left\"):\n    if self.is_monotonic_increasing:\n        return self.searchsorted(label, side=side)\n    elif self.is_monotonic_decreasing:\n        # np.searchsorted expects ascending sort order, have to reverse\n        # everything for it to work (element ordering, search side and\n        # resulting value).\n        pos = self[::-1].searchsorted(\n            label, side=\"right\" if side == \"left\" else \"left\"\n        )\n        return len(self) - pos\n\n    raise ValueError(\"index must be monotonic increasing or decreasing\")",
                "def get_slice_bound(self, label, side, kind):\n    \"\"\"\n    Calculate slice bound that corresponds to given label.\n\n    Returns leftmost (one-past-the-rightmost if ``side=='right'``) position\n    of given label.\n\n    Parameters\n    ----------\n    label : object\n    side : {'left', 'right'}\n    kind : {'ix', 'loc', 'getitem'}\n\n    Returns\n    -------\n    int\n        Index of label.\n    \"\"\"\n    assert kind in [\"ix\", \"loc\", \"getitem\", None]\n\n    if side not in (\"left\", \"right\"):\n        raise ValueError(\n            \"Invalid value for side kwarg,\"\n            \" must be either 'left' or 'right': %s\" % (side,)\n        )\n\n    original_label = label\n\n    # For datetime indices label may be a string that has to be converted\n    # to datetime boundary according to its resolution.\n    label = self._maybe_cast_slice_bound(label, side, kind)\n\n    # we need to look up the label\n    try:\n        slc = self.get_loc(label)\n    except KeyError as err:\n        try:\n            return self._searchsorted_monotonic(label, side)\n        except ValueError:\n            # raise the original KeyError\n            raise err\n\n    if isinstance(slc, np.ndarray):\n        # get_loc may return a boolean array or an array of indices, which\n        # is OK as long as they are representable by a slice.\n        if is_bool_dtype(slc):\n            slc = lib.maybe_booleans_to_slice(slc.view(\"u1\"))\n        else:\n            slc = lib.maybe_indices_to_slice(slc.astype(\"i8\"), len(self))\n        if isinstance(slc, np.ndarray):\n            raise KeyError(\n                \"Cannot get %s slice bound for non-unique \"\n                \"label: %r\" % (side, original_label)\n            )\n\n    if isinstance(slc, slice):\n        if side == \"left\":\n            return slc.start\n        else:\n            return slc.stop\n    else:\n        if side == \"right\":\n            return slc + 1\n        else:\n            return slc",
                "def slice_locs(self, start=None, end=None, step=None, kind=None):\n    \"\"\"\n    Compute slice locations for input labels.\n\n    Parameters\n    ----------\n    start : label, default None\n        If None, defaults to the beginning\n    end : label, default None\n        If None, defaults to the end\n    step : int, defaults None\n        If None, defaults to 1\n    kind : {'ix', 'loc', 'getitem'} or None\n\n    Returns\n    -------\n    start, end : int\n\n    See Also\n    --------\n    Index.get_loc : Get location for a single label.\n\n    Notes\n    -----\n    This method only works if the index is monotonic or unique.\n\n    Examples\n    --------\n    >>> idx = pd.Index(list('abcd'))\n    >>> idx.slice_locs(start='b', end='c')\n    (1, 3)\n    \"\"\"\n    inc = step is None or step >= 0\n\n    if not inc:\n        # If it's a reverse slice, temporarily swap bounds.\n        start, end = end, start\n\n    # GH 16785: If start and end happen to be date strings with UTC offsets\n    # attempt to parse and check that the offsets are the same\n    if isinstance(start, (str, datetime)) and isinstance(end, (str, datetime)):\n        try:\n            ts_start = Timestamp(start)\n            ts_end = Timestamp(end)\n        except (ValueError, TypeError):\n            pass\n        else:\n            if not tz_compare(ts_start.tzinfo, ts_end.tzinfo):\n                raise ValueError(\"Both dates must have the same UTC offset\")\n\n    start_slice = None\n    if start is not None:\n        start_slice = self.get_slice_bound(start, \"left\", kind)\n    if start_slice is None:\n        start_slice = 0\n\n    end_slice = None\n    if end is not None:\n        end_slice = self.get_slice_bound(end, \"right\", kind)\n    if end_slice is None:\n        end_slice = len(self)\n\n    if not inc:\n        # Bounds at this moment are swapped, swap them back and shift by 1.\n        #\n        # slice_locs('B', 'A', step=-1): s='B', e='A'\n        #\n        #              s='A'                 e='B'\n        # AFTER SWAP:    |                     |\n        #                v ------------------> V\n        #           -----------------------------------\n        #           | | |A|A|A|A| | | | | |B|B| | | | |\n        #           -----------------------------------\n        #              ^ <------------------ ^\n        # SHOULD BE:   |                     |\n        #           end=s-1              start=e-1\n        #\n        end_slice, start_slice = start_slice - 1, end_slice - 1\n\n        # i == -1 triggers ``len(self) + i`` selection that points to the\n        # last element, not before-the-first one, subtracting len(self)\n        # compensates that.\n        if end_slice == -1:\n            end_slice -= len(self)\n        if start_slice == -1:\n            start_slice -= len(self)\n\n    return start_slice, end_slice",
                "def delete(self, loc):\n    \"\"\"\n    Make new Index with passed location(-s) deleted.\n\n    Returns\n    -------\n    new_index : Index\n    \"\"\"\n    return self._shallow_copy(np.delete(self._data, loc))",
                "def insert(self, loc, item):\n    \"\"\"\n    Make new Index inserting new item at location.\n\n    Follows Python list.append semantics for negative values.\n\n    Parameters\n    ----------\n    loc : int\n    item : object\n\n    Returns\n    -------\n    new_index : Index\n    \"\"\"\n    _self = np.asarray(self)\n    item = self._coerce_scalar_to_index(item)._ndarray_values\n    idx = np.concatenate((_self[:loc], item, _self[loc:]))\n    return self._shallow_copy_with_infer(idx)",
                "def drop(self, labels, errors=\"raise\"):\n    \"\"\"\n    Make new Index with passed list of labels deleted.\n\n    Parameters\n    ----------\n    labels : array-like\n    errors : {'ignore', 'raise'}, default 'raise'\n        If 'ignore', suppress error and existing labels are dropped.\n\n    Returns\n    -------\n    dropped : Index\n\n    Raises\n    ------\n    KeyError\n        If not all of the labels are found in the selected axis\n    \"\"\"\n    arr_dtype = \"object\" if self.dtype == \"object\" else None\n    labels = com.index_labels_to_array(labels, dtype=arr_dtype)\n    indexer = self.get_indexer(labels)\n    mask = indexer == -1\n    if mask.any():\n        if errors != \"ignore\":\n            raise KeyError(\"{} not found in axis\".format(labels[mask]))\n        indexer = indexer[~mask]\n    return self.delete(indexer)",
                "@classmethod\ndef _add_comparison_methods(cls):\n    \"\"\"\n    Add in comparison methods.\n    \"\"\"\n    cls.__eq__ = _make_comparison_op(operator.eq, cls)\n    cls.__ne__ = _make_comparison_op(operator.ne, cls)\n    cls.__lt__ = _make_comparison_op(operator.lt, cls)\n    cls.__gt__ = _make_comparison_op(operator.gt, cls)\n    cls.__le__ = _make_comparison_op(operator.le, cls)\n    cls.__ge__ = _make_comparison_op(operator.ge, cls)",
                "@classmethod\ndef _add_numeric_methods_add_sub_disabled(cls):\n    \"\"\"\n    Add in the numeric add/sub methods to disable.\n    \"\"\"\n    cls.__add__ = make_invalid_op(\"__add__\")\n    cls.__radd__ = make_invalid_op(\"__radd__\")\n    cls.__iadd__ = make_invalid_op(\"__iadd__\")\n    cls.__sub__ = make_invalid_op(\"__sub__\")\n    cls.__rsub__ = make_invalid_op(\"__rsub__\")\n    cls.__isub__ = make_invalid_op(\"__isub__\")",
                "@classmethod\ndef _add_numeric_methods_disabled(cls):\n    \"\"\"\n    Add in numeric methods to disable other than add/sub.\n    \"\"\"\n    cls.__pow__ = make_invalid_op(\"__pow__\")\n    cls.__rpow__ = make_invalid_op(\"__rpow__\")\n    cls.__mul__ = make_invalid_op(\"__mul__\")\n    cls.__rmul__ = make_invalid_op(\"__rmul__\")\n    cls.__floordiv__ = make_invalid_op(\"__floordiv__\")\n    cls.__rfloordiv__ = make_invalid_op(\"__rfloordiv__\")\n    cls.__truediv__ = make_invalid_op(\"__truediv__\")\n    cls.__rtruediv__ = make_invalid_op(\"__rtruediv__\")\n    cls.__mod__ = make_invalid_op(\"__mod__\")\n    cls.__divmod__ = make_invalid_op(\"__divmod__\")\n    cls.__neg__ = make_invalid_op(\"__neg__\")\n    cls.__pos__ = make_invalid_op(\"__pos__\")\n    cls.__abs__ = make_invalid_op(\"__abs__\")\n    cls.__inv__ = make_invalid_op(\"__inv__\")",
                "def _maybe_update_attributes(self, attrs):\n    \"\"\"\n    Update Index attributes (e.g. freq) depending on op.\n    \"\"\"\n    return attrs",
                "def _validate_for_numeric_unaryop(self, op, opstr):\n    \"\"\"\n    Validate if we can perform a numeric unary operation.\n    \"\"\"\n    if not self._is_numeric_dtype:\n        raise TypeError(\n            \"cannot evaluate a numeric op \"\n            \"{opstr} for type: {typ}\".format(opstr=opstr, typ=type(self).__name__)\n        )",
                "def _validate_for_numeric_binop(self, other, op):\n    \"\"\"\n    Return valid other; evaluate or raise TypeError if we are not of\n    the appropriate type.\n\n    Notes\n    -----\n    This is an internal method called by ops.\n    \"\"\"\n    opstr = \"__{opname}__\".format(opname=op.__name__)\n    # if we are an inheritor of numeric,\n    # but not actually numeric (e.g. DatetimeIndex/PeriodIndex)\n    if not self._is_numeric_dtype:\n        raise TypeError(\n            \"cannot evaluate a numeric op {opstr} \"\n            \"for type: {typ}\".format(opstr=opstr, typ=type(self).__name__)\n        )\n\n    if isinstance(other, Index):\n        if not other._is_numeric_dtype:\n            raise TypeError(\n                \"cannot evaluate a numeric op \"\n                \"{opstr} with type: {typ}\".format(opstr=opstr, typ=type(other))\n            )\n    elif isinstance(other, np.ndarray) and not other.ndim:\n        other = other.item()\n\n    if isinstance(other, (Index, ABCSeries, np.ndarray)):\n        if len(self) != len(other):\n            raise ValueError(\"cannot evaluate a numeric op with unequal lengths\")\n        other = com.values_from_object(other)\n        if other.dtype.kind not in [\"f\", \"i\", \"u\"]:\n            raise TypeError(\"cannot evaluate a numeric op with a non-numeric dtype\")\n    elif isinstance(other, (ABCDateOffset, np.timedelta64, timedelta)):\n        # higher up to handle\n        pass\n    elif isinstance(other, (datetime, np.datetime64)):\n        # higher up to handle\n        pass\n    else:\n        if not (is_float(other) or is_integer(other)):\n            raise TypeError(\"can only perform ops with scalar values\")\n\n    return other",
                "@classmethod\ndef _add_numeric_methods_binary(cls):\n    \"\"\"\n    Add in numeric methods.\n    \"\"\"\n    cls.__add__ = _make_arithmetic_op(operator.add, cls)\n    cls.__radd__ = _make_arithmetic_op(ops.radd, cls)\n    cls.__sub__ = _make_arithmetic_op(operator.sub, cls)\n    cls.__rsub__ = _make_arithmetic_op(ops.rsub, cls)\n    cls.__rpow__ = _make_arithmetic_op(ops.rpow, cls)\n    cls.__pow__ = _make_arithmetic_op(operator.pow, cls)\n\n    cls.__truediv__ = _make_arithmetic_op(operator.truediv, cls)\n    cls.__rtruediv__ = _make_arithmetic_op(ops.rtruediv, cls)\n\n    # TODO: rmod? rdivmod?\n    cls.__mod__ = _make_arithmetic_op(operator.mod, cls)\n    cls.__floordiv__ = _make_arithmetic_op(operator.floordiv, cls)\n    cls.__rfloordiv__ = _make_arithmetic_op(ops.rfloordiv, cls)\n    cls.__divmod__ = _make_arithmetic_op(divmod, cls)\n    cls.__mul__ = _make_arithmetic_op(operator.mul, cls)\n    cls.__rmul__ = _make_arithmetic_op(ops.rmul, cls)",
                "@classmethod\ndef _add_numeric_methods_unary(cls):\n    \"\"\"\n    Add in numeric unary methods.\n    \"\"\"\n\n    def _make_evaluate_unary(op, opstr):\n        def _evaluate_numeric_unary(self):\n\n            self._validate_for_numeric_unaryop(op, opstr)\n            attrs = self._get_attributes_dict()\n            attrs = self._maybe_update_attributes(attrs)\n            return Index(op(self.values), **attrs)\n\n        _evaluate_numeric_unary.__name__ = opstr\n        return _evaluate_numeric_unary\n\n    cls.__neg__ = _make_evaluate_unary(operator.neg, \"__neg__\")\n    cls.__pos__ = _make_evaluate_unary(operator.pos, \"__pos__\")\n    cls.__abs__ = _make_evaluate_unary(np.abs, \"__abs__\")\n    cls.__inv__ = _make_evaluate_unary(lambda x: -x, \"__inv__\")",
                "@classmethod\ndef _add_numeric_methods(cls):\n    cls._add_numeric_methods_unary()\n    cls._add_numeric_methods_binary()",
                "@classmethod\ndef _add_logical_methods(cls):\n    \"\"\"\n    Add in logical methods.\n    \"\"\"\n    _doc = \"\"\"\n    %(desc)s\n\n    Parameters\n    ----------\n    *args\n        These parameters will be passed to numpy.%(outname)s.\n    **kwargs\n        These parameters will be passed to numpy.%(outname)s.\n\n    Returns\n    -------\n    %(outname)s : bool or array_like (if axis is specified)\n        A single element array_like may be converted to bool.\"\"\"\n\n    _index_shared_docs[\"index_all\"] = dedent(\n        \"\"\"\n\n    See Also\n    --------\n    Index.any : Return whether any element in an Index is True.\n    Series.any : Return whether any element in a Series is True.\n    Series.all : Return whether all elements in a Series are True.\n\n    Notes\n    -----\n    Not a Number (NaN), positive infinity and negative infinity\n    evaluate to True because these are not equal to zero.\n\n    Examples\n    --------\n    **all**\n\n    True, because nonzero integers are considered True.\n\n    >>> pd.Index([1, 2, 3]).all()\n    True\n\n    False, because ``0`` is considered False.\n\n    >>> pd.Index([0, 1, 2]).all()\n    False\n\n    **any**\n\n    True, because ``1`` is considered True.\n\n    >>> pd.Index([0, 0, 1]).any()\n    True\n\n    False, because ``0`` is considered False.\n\n    >>> pd.Index([0, 0, 0]).any()\n    False\n    \"\"\"\n    )\n\n    _index_shared_docs[\"index_any\"] = dedent(\n        \"\"\"\n\n    See Also\n    --------\n    Index.all : Return whether all elements are True.\n    Series.all : Return whether all elements are True.\n\n    Notes\n    -----\n    Not a Number (NaN), positive infinity and negative infinity\n    evaluate to True because these are not equal to zero.\n\n    Examples\n    --------\n    >>> index = pd.Index([0, 1, 2])\n    >>> index.any()\n    True\n\n    >>> index = pd.Index([0, 0, 0])\n    >>> index.any()\n    False\n    \"\"\"\n    )\n\n    def _make_logical_function(name, desc, f):\n        @Substitution(outname=name, desc=desc)\n        @Appender(_index_shared_docs[\"index_\" + name])\n        @Appender(_doc)\n        def logical_func(self, *args, **kwargs):\n            result = f(self.values)\n            if (\n                isinstance(result, (np.ndarray, ABCSeries, Index))\n                and result.ndim == 0\n            ):\n                # return NumPy type\n                return result.dtype.type(result.item())\n            else:  # pragma: no cover\n                return result\n\n        logical_func.__name__ = name\n        return logical_func\n\n    cls.all = _make_logical_function(\n        \"all\", \"Return whether all elements are True.\", np.all\n    )\n    cls.any = _make_logical_function(\n        \"any\", \"Return whether any element is True.\", np.any\n    )",
                "@classmethod\ndef _add_logical_methods_disabled(cls):\n    \"\"\"\n    Add in logical methods to disable.\n    \"\"\"\n    cls.all = make_invalid_op(\"all\")\n    cls.any = make_invalid_op(\"any\")",
                "@property\ndef shape(self):\n    \"\"\"\n    Return a tuple of the shape of the underlying data.\n    \"\"\"\n    return (len(self),)",
                "def is_int(v):\n    return v is None or is_integer(v)",
                "def _get_leaf_sorter(labels):\n    \"\"\"\n    Returns sorter for the inner most level while preserving the\n    order of higher levels.\n    \"\"\"\n    if labels[0].size == 0:\n        return np.empty(0, dtype=\"int64\")\n\n    if len(labels) == 1:\n        lab = ensure_int64(labels[0])\n        sorter, _ = libalgos.groupsort_indexer(lab, 1 + lab.max())\n        return sorter\n\n    # find indexers of beginning of each set of\n    # same-key labels w.r.t all but last level\n    tic = labels[0][:-1] != labels[0][1:]\n    for lab in labels[1:-1]:\n        tic |= lab[:-1] != lab[1:]\n\n    starts = np.hstack(([True], tic, [True])).nonzero()[0]\n    lab = ensure_int64(labels[-1])\n    return lib.get_level_sorter(lab, ensure_int64(starts))",
                "def _make_evaluate_unary(op, opstr):\n    def _evaluate_numeric_unary(self):\n\n        self._validate_for_numeric_unaryop(op, opstr)\n        attrs = self._get_attributes_dict()\n        attrs = self._maybe_update_attributes(attrs)\n        return Index(op(self.values), **attrs)\n\n    _evaluate_numeric_unary.__name__ = opstr\n    return _evaluate_numeric_unary",
                "def _make_logical_function(name, desc, f):\n    @Substitution(outname=name, desc=desc)\n    @Appender(_index_shared_docs[\"index_\" + name])\n    @Appender(_doc)\n    def logical_func(self, *args, **kwargs):\n        result = f(self.values)\n        if (\n            isinstance(result, (np.ndarray, ABCSeries, Index))\n            and result.ndim == 0\n        ):\n            # return NumPy type\n            return result.dtype.type(result.item())\n        else:  # pragma: no cover\n            return result\n\n    logical_func.__name__ = name\n    return logical_func",
                "def _evaluate_numeric_unary(self):\n\n    self._validate_for_numeric_unaryop(op, opstr)\n    attrs = self._get_attributes_dict()\n    attrs = self._maybe_update_attributes(attrs)\n    return Index(op(self.values), **attrs)",
                "@Substitution(outname=name, desc=desc)\n@Appender(_index_shared_docs[\"index_\" + name])\n@Appender(_doc)\ndef logical_func(self, *args, **kwargs):\n    result = f(self.values)\n    if (\n        isinstance(result, (np.ndarray, ABCSeries, Index))\n        and result.ndim == 0\n    ):\n        # return NumPy type\n        return result.dtype.type(result.item())\n    else:  # pragma: no cover\n        return result"
            ],
            "inscope_function_signatures": [
                "_make_comparison_op(op, cls)",
                "_make_arithmetic_op(op, cls)",
                "_new_Index(cls, d)",
                "ensure_index_from_sequences(sequences, names=None)",
                "ensure_index(index_like, copy=False)",
                "_ensure_has_len(seq)",
                "_trim_front(strings)",
                "_validate_join_method(method)",
                "default_index(n)",
                "cmp_method(self, other)",
                "index_arithmetic_method(self, other)",
                "_left_indexer_unique(self, left, right)",
                "_left_indexer(self, left, right)",
                "_inner_indexer(self, left, right)",
                "_outer_indexer(self, left, right)",
                "__new__(cls, data=None, dtype=None, copy=False, name=None, fastpath=None, tupleize_cols=True, **kwargs)",
                "asi8(self)",
                "_simple_new(cls, values, name=None, dtype=None, **kwargs)",
                "_constructor(self)",
                "_get_attributes_dict(self)",
                "_shallow_copy(self, values=None, **kwargs)",
                "_shallow_copy_with_infer(self, values, **kwargs)",
                "_update_inplace(self, result, **kwargs)",
                "is_(self, other)",
                "_reset_identity(self)",
                "_cleanup(self)",
                "_engine(self)",
                "__len__(self)",
                "__array__(self, dtype=None)",
                "__array_wrap__(self, result, context=None)",
                "dtype(self)",
                "dtype_str(self)",
                "ravel(self, order='C')",
                "view(self, cls=None)",
                "astype(self, dtype, copy=True)",
                "take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs)",
                "_assert_take_fillable(self, values, indices, allow_fill=True, fill_value=None, na_value=np.nan)",
                "repeat(self, repeats, axis=None)",
                "copy(self, name=None, deep=False, dtype=None, **kwargs)",
                "__copy__(self, **kwargs)",
                "__deepcopy__(self, memo=None)",
                "__repr__(self)",
                "_format_space(self)",
                "_formatter_func(self)",
                "_format_data(self, name=None)",
                "_format_attrs(self)",
                "_mpl_repr(self)",
                "format(self, name=False, formatter=None, **kwargs)",
                "_format_with_header(self, header, na_rep='NaN', **kwargs)",
                "to_native_types(self, slicer=None, **kwargs)",
                "_format_native_types(self, na_rep='', quoting=None, **kwargs)",
                "_summary(self, name=None)",
                "summary(self, name=None)",
                "to_flat_index(self)",
                "to_series(self, index=None, name=None)",
                "to_frame(self, index=True, name=None)",
                "_validate_names(self, name=None, names=None, deep=False)",
                "_get_names(self)",
                "_set_names(self, values, level=None)",
                "set_names(self, names, level=None, inplace=False)",
                "rename(self, name, inplace=False)",
                "nlevels(self)",
                "_sort_levels_monotonic(self)",
                "_validate_index_level(self, level)",
                "_get_level_number(self, level)",
                "sortlevel(self, level=None, ascending=True, sort_remaining=None)",
                "_get_level_values(self, level)",
                "droplevel(self, level=0)",
                "_get_grouper_for_level(self, mapper, level=None)",
                "is_monotonic(self)",
                "is_monotonic_increasing(self)",
                "is_monotonic_decreasing(self)",
                "_is_strictly_monotonic_increasing(self)",
                "_is_strictly_monotonic_decreasing(self)",
                "is_lexsorted_for_tuple(self, tup)",
                "is_unique(self)",
                "has_duplicates(self)",
                "is_boolean(self)",
                "is_integer(self)",
                "is_floating(self)",
                "is_numeric(self)",
                "is_object(self)",
                "is_categorical(self)",
                "is_interval(self)",
                "is_mixed(self)",
                "holds_integer(self)",
                "inferred_type(self)",
                "is_all_dates(self)",
                "__reduce__(self)",
                "__setstate__(self, state)",
                "_isnan(self)",
                "_nan_idxs(self)",
                "hasnans(self)",
                "isna(self)",
                "notna(self)",
                "fillna(self, value=None, downcast=None)",
                "dropna(self, how='any')",
                "unique(self, level=None)",
                "drop_duplicates(self, keep='first')",
                "duplicated(self, keep='first')",
                "get_duplicates(self)",
                "_get_unique_index(self, dropna=False)",
                "__add__(self, other)",
                "__radd__(self, other)",
                "__iadd__(self, other)",
                "__sub__(self, other)",
                "__rsub__(self, other)",
                "__and__(self, other)",
                "__or__(self, other)",
                "__xor__(self, other)",
                "__nonzero__(self)",
                "_get_reconciled_name_object(self, other)",
                "_union_incompatible_dtypes(self, other, sort)",
                "_is_compatible_with_other(self, other)",
                "_validate_sort_keyword(self, sort)",
                "union(self, other, sort=None)",
                "_union(self, other, sort)",
                "_wrap_setop_result(self, other, result)",
                "intersection(self, other, sort=False)",
                "difference(self, other, sort=None)",
                "symmetric_difference(self, other, result_name=None, sort=None)",
                "_assert_can_do_setop(self, other)",
                "_convert_can_do_setop(self, other)",
                "get_loc(self, key, method=None, tolerance=None)",
                "get_indexer(self, target, method=None, limit=None, tolerance=None)",
                "_convert_tolerance(self, tolerance, target)",
                "_get_fill_indexer(self, target, method, limit=None, tolerance=None)",
                "_get_fill_indexer_searchsorted(self, target, method, limit=None)",
                "_get_nearest_indexer(self, target, limit, tolerance)",
                "_filter_indexer_tolerance(self, target, indexer, tolerance)",
                "_convert_scalar_indexer(self, key, kind=None)",
                "_convert_slice_indexer(self, key, kind=None)",
                "_convert_listlike_indexer(self, keyarr, kind=None)",
                "_convert_arr_indexer(self, keyarr)",
                "_convert_index_indexer(self, keyarr)",
                "_convert_list_indexer(self, keyarr, kind=None)",
                "_invalid_indexer(self, form, key)",
                "_can_reindex(self, indexer)",
                "reindex(self, target, method=None, level=None, limit=None, tolerance=None)",
                "_reindex_non_unique(self, target)",
                "join(self, other, how='left', level=None, return_indexers=False, sort=False)",
                "_join_multi(self, other, how, return_indexers=True)",
                "_join_non_unique(self, other, how='left', return_indexers=False)",
                "_join_level(self, other, level, how='left', return_indexers=False, keep_order=True)",
                "_join_monotonic(self, other, how='left', return_indexers=False)",
                "_wrap_joined_index(self, joined, other)",
                "values(self)",
                "_values(self) -> Union[ExtensionArray, ABCIndexClass, np.ndarray]",
                "get_values(self)",
                "_internal_get_values(self)",
                "memory_usage(self, deep=False)",
                "where(self, cond, other=None)",
                "_try_convert_to_int_index(cls, data, copy, name, dtype)",
                "_scalar_data_error(cls, data)",
                "_string_data_error(cls, data)",
                "_coerce_to_ndarray(cls, data)",
                "_coerce_scalar_to_index(self, item)",
                "_to_safe_for_reshape(self)",
                "_convert_for_op(self, value)",
                "_assert_can_do_op(self, value)",
                "_has_complex_internals(self)",
                "_is_memory_usage_qualified(self)",
                "is_type_compatible(self, kind)",
                "__contains__(self, key)",
                "contains(self, key)",
                "__hash__(self)",
                "__setitem__(self, key, value)",
                "__getitem__(self, key)",
                "_can_hold_identifiers_and_holds_name(self, name)",
                "append(self, other)",
                "_concat(self, to_concat, name)",
                "_concat_same_dtype(self, to_concat, name)",
                "putmask(self, mask, value)",
                "equals(self, other)",
                "identical(self, other)",
                "asof(self, label)",
                "asof_locs(self, where, mask)",
                "sort_values(self, return_indexer=False, ascending=True)",
                "sort(self, *args, **kwargs)",
                "shift(self, periods=1, freq=None)",
                "argsort(self, *args, **kwargs)",
                "get_value(self, series, key)",
                "set_value(self, arr, key, value)",
                "get_indexer_non_unique(self, target)",
                "get_indexer_for(self, target, **kwargs)",
                "_maybe_promote(self, other)",
                "groupby(self, values)",
                "map(self, mapper, na_action=None)",
                "isin(self, values, level=None)",
                "_get_string_slice(self, key, use_lhs=True, use_rhs=True)",
                "slice_indexer(self, start=None, end=None, step=None, kind=None)",
                "_maybe_cast_indexer(self, key)",
                "_validate_indexer(self, form, key, kind)",
                "_maybe_cast_slice_bound(self, label, side, kind)",
                "_searchsorted_monotonic(self, label, side='left')",
                "get_slice_bound(self, label, side, kind)",
                "slice_locs(self, start=None, end=None, step=None, kind=None)",
                "delete(self, loc)",
                "insert(self, loc, item)",
                "drop(self, labels, errors='raise')",
                "_add_comparison_methods(cls)",
                "_add_numeric_methods_add_sub_disabled(cls)",
                "_add_numeric_methods_disabled(cls)",
                "_maybe_update_attributes(self, attrs)",
                "_validate_for_numeric_unaryop(self, op, opstr)",
                "_validate_for_numeric_binop(self, other, op)",
                "_add_numeric_methods_binary(cls)",
                "_add_numeric_methods_unary(cls)",
                "_add_numeric_methods(cls)",
                "_add_logical_methods(cls)",
                "_add_logical_methods_disabled(cls)",
                "shape(self)",
                "is_int(v)",
                "_get_leaf_sorter(labels)",
                "_make_evaluate_unary(op, opstr)",
                "_make_logical_function(name, desc, f)",
                "_evaluate_numeric_unary(self)",
                "logical_func(self, *args, **kwargs)"
            ],
            "variables_in_file": {
                "__all__": [
                    83
                ],
                "_unsortable_types": [
                    85
                ],
                "frozenset": [
                    208,
                    85
                ],
                "_index_doc_kwargs": [
                    4195,
                    937,
                    2123,
                    2927,
                    4752,
                    87,
                    855,
                    4667
                ],
                "dict": [
                    1864,
                    940,
                    1873,
                    87,
                    95
                ],
                "_index_shared_docs": [
                    768,
                    3457,
                    898,
                    2818,
                    3074,
                    2565,
                    2061,
                    4752,
                    1682,
                    3986,
                    5524,
                    3221,
                    2072,
                    793,
                    3480,
                    4003,
                    3236,
                    2088,
                    937,
                    2858,
                    2603,
                    3113,
                    3241,
                    5034,
                    4655,
                    5551,
                    946,
                    2100,
                    3127,
                    3256,
                    827,
                    3260,
                    4667,
                    2878,
                    5057,
                    4163,
                    968,
                    2123,
                    3276,
                    595,
                    855,
                    95,
                    610,
                    4195,
                    5482,
                    2927,
                    3063,
                    2041,
                    4730,
                    1660
                ],
                "isinstance": [
                    129,
                    3714,
                    4099,
                    4357,
                    135,
                    3719,
                    1417,
                    3081,
                    4104,
                    1164,
                    3213,
                    5132,
                    1167,
                    3599,
                    3600,
                    5385,
                    5139,
                    5391,
                    5394,
                    280,
                    4249,
                    2330,
                    3482,
                    3483,
                    285,
                    3358,
                    287,
                    5145,
                    5400,
                    5403,
                    5668,
                    5680,
                    563,
                    5556,
                    4790,
                    3132,
                    4674,
                    3652,
                    4292,
                    4298,
                    5196,
                    4814,
                    1616,
                    1873,
                    3282,
                    1878,
                    100,
                    4454,
                    104,
                    1515,
                    364,
                    621,
                    4851,
                    4852,
                    502,
                    2808,
                    764
                ],
                "other": [
                    2560,
                    2563,
                    3592,
                    3600,
                    3609,
                    3623,
                    2606,
                    2607,
                    2609,
                    2610,
                    2612,
                    2614,
                    2615,
                    3641,
                    2622,
                    2623,
                    3646,
                    2625,
                    3648,
                    2627,
                    2630,
                    3660,
                    2642,
                    3668,
                    2646,
                    3670,
                    2652,
                    100,
                    101,
                    107,
                    111,
                    129,
                    3714,
                    3717,
                    134,
                    2698,
                    2700,
                    2704,
                    2708,
                    674,
                    4790,
                    4791,
                    4794,
                    4795,
                    4292,
                    4293,
                    4295,
                    2769,
                    2770,
                    2775,
                    2776,
                    2787,
                    3819,
                    3820,
                    2803,
                    3827,
                    3829,
                    2808,
                    2809,
                    2812,
                    2813,
                    3836,
                    3841,
                    4354,
                    3844,
                    4357,
                    4360,
                    5385,
                    4362,
                    5386,
                    5389,
                    3854,
                    4366,
                    5391,
                    5392,
                    5394,
                    5395,
                    5397,
                    5398,
                    3864,
                    5400,
                    2330,
                    5403,
                    2334,
                    4383,
                    5407,
                    4386,
                    2339,
                    5410,
                    4390,
                    2343,
                    2346,
                    2349,
                    2352,
                    2355,
                    2358,
                    2379,
                    2405,
                    2406,
                    2422,
                    3483,
                    3490,
                    3493,
                    4005,
                    4006,
                    3498,
                    4011,
                    3501,
                    3503,
                    4017,
                    2484,
                    2486,
                    2487,
                    3512,
                    2489,
                    3519,
                    3521,
                    3529,
                    3531,
                    3532,
                    2511,
                    2512,
                    3536,
                    3538,
                    2515,
                    3540,
                    3541,
                    3543,
                    2522,
                    2523,
                    3547,
                    2525,
                    3549,
                    2527,
                    3552,
                    3560,
                    2538,
                    3564,
                    3568,
                    3578,
                    3581
                ],
                "np.ndarray": [
                    1888,
                    4099,
                    100,
                    364,
                    5132,
                    5391,
                    3890,
                    5139,
                    5394,
                    3893,
                    5556,
                    1883
                ],
                "np": [
                    1922,
                    4099,
                    5253,
                    4488,
                    4106,
                    4490,
                    5132,
                    5391,
                    5394,
                    5139,
                    148,
                    1912,
                    5270,
                    2711,
                    5272,
                    409,
                    5400,
                    5403,
                    4255,
                    2980,
                    808,
                    2346,
                    555,
                    811,
                    557,
                    2349,
                    3759,
                    4652,
                    4017,
                    434,
                    3506,
                    3890,
                    3893,
                    4019,
                    567,
                    4335,
                    5556,
                    3514,
                    1086,
                    5568,
                    705,
                    5571,
                    3448,
                    1097,
                    5454,
                    3666,
                    3668,
                    1882,
                    1883,
                    2780,
                    2781,
                    3420,
                    351,
                    1887,
                    1888,
                    3041,
                    3299,
                    100,
                    3428,
                    3046,
                    106,
                    364,
                    493,
                    110,
                    111,
                    876,
                    1646,
                    1900,
                    3057,
                    3436,
                    3437,
                    1142,
                    3697,
                    1144,
                    2938,
                    3710
                ],
                "Index": [
                    512,
                    4865,
                    4099,
                    4357,
                    136,
                    137,
                    5385,
                    651,
                    3213,
                    5394,
                    2069,
                    3865,
                    4124,
                    2334,
                    3358,
                    2339,
                    5668,
                    5673,
                    2346,
                    811,
                    2349,
                    820,
                    5556,
                    4674,
                    452,
                    5700,
                    5447,
                    4298,
                    2635,
                    717,
                    2639,
                    5590,
                    5591,
                    5592,
                    100,
                    2405,
                    2406,
                    361,
                    364,
                    493,
                    118,
                    2808,
                    2809,
                    764,
                    5631
                ],
                "ABCSeries": [
                    129,
                    100,
                    4104,
                    364,
                    5394,
                    563,
                    5556,
                    2330
                ],
                "other.ndim": [
                    101,
                    5391
                ],
                "len": [
                    644,
                    3332,
                    3081,
                    1162,
                    4490,
                    5138,
                    5395,
                    1175,
                    3737,
                    3358,
                    3746,
                    554,
                    3503,
                    3759,
                    689,
                    3506,
                    5686,
                    3511,
                    3514,
                    699,
                    1346,
                    1347,
                    3448,
                    5708,
                    4685,
                    4302,
                    2511,
                    2514,
                    5587,
                    1621,
                    3029,
                    1623,
                    1880,
                    4310,
                    4697,
                    1627,
                    3419,
                    3420,
                    3294,
                    5086,
                    3296,
                    5216,
                    5239,
                    3299,
                    3428,
                    101,
                    4455,
                    616,
                    1640,
                    5720,
                    3436,
                    2541,
                    3437,
                    3699,
                    4855,
                    1912,
                    5241,
                    5628
                ],
                "self": [
                    2063,
                    2064,
                    2065,
                    2069,
                    2070,
                    4117,
                    4119,
                    4124,
                    4130,
                    2093,
                    2094,
                    2095,
                    4155,
                    4161,
                    2126,
                    2128,
                    101,
                    4199,
                    104,
                    107,
                    111,
                    4221,
                    4224,
                    134,
                    4242,
                    4243,
                    4273,
                    4274,
                    4290,
                    4302,
                    4304,
                    4311,
                    4333,
                    4335,
                    4336,
                    4338,
                    2294,
                    4342,
                    4354,
                    2309,
                    2310,
                    2312,
                    4360,
                    2314,
                    2315,
                    4362,
                    4366,
                    2319,
                    2324,
                    2334,
                    4383,
                    4386,
                    2339,
                    4387,
                    4390,
                    2343,
                    2346,
                    2349,
                    2352,
                    2355,
                    2358,
                    2364,
                    2379,
                    2380,
                    2381,
                    2382,
                    4450,
                    2403,
                    4452,
                    4455,
                    4456,
                    2422,
                    4487,
                    4490,
                    4493,
                    2483,
                    2484,
                    2486,
                    2487,
                    2489,
                    4540,
                    4544,
                    2511,
                    2512,
                    2514,
                    2515,
                    2518,
                    2519,
                    2521,
                    2527,
                    2529,
                    2538,
                    2560,
                    2563,
                    4613,
                    4650,
                    4652,
                    2605,
                    2606,
                    2609,
                    2610,
                    2612,
                    2613,
                    2618,
                    2619,
                    2621,
                    2627,
                    2629,
                    2630,
                    584,
                    4682,
                    4685,
                    593,
                    4693,
                    2646,
                    4695,
                    2649,
                    2650,
                    4697,
                    2652,
                    613,
                    614,
                    617,
                    626,
                    4726,
                    641,
                    645,
                    646,
                    648,
                    2697,
                    2698,
                    2700,
                    2702,
                    2704,
                    2706,
                    4757,
                    4758,
                    4761,
                    4766,
                    674,
                    680,
                    681,
                    684,
                    4781,
                    4782,
                    4783,
                    689,
                    4790,
                    4791,
                    4792,
                    4793,
                    4794,
                    699,
                    4795,
                    705,
                    715,
                    716,
                    2768,
                    2769,
                    2770,
                    724,
                    4820,
                    2774,
                    739,
                    2796,
                    2800,
                    4848,
                    754,
                    4852,
                    4853,
                    761,
                    2809,
                    763,
                    2810,
                    765,
                    2812,
                    4863,
                    795,
                    796,
                    801,
                    808,
                    811,
                    818,
                    2867,
                    821,
                    2869,
                    2870,
                    825,
                    4947,
                    4948,
                    860,
                    861,
                    862,
                    866,
                    871,
                    872,
                    873,
                    2932,
                    2937,
                    2940,
                    2941,
                    2946,
                    2947,
                    4994,
                    2953,
                    2959,
                    2961,
                    5010,
                    2974,
                    5031,
                    2986,
                    2988,
                    941,
                    2990,
                    2994,
                    2996,
                    3015,
                    3017,
                    5066,
                    971,
                    5067,
                    973,
                    976,
                    5072,
                    3029,
                    5077,
                    5078,
                    984,
                    5079,
                    5083,
                    3038,
                    3039,
                    5086,
                    3042,
                    995,
                    3043,
                    3045,
                    1004,
                    1005,
                    1006,
                    1007,
                    3052,
                    3056,
                    5120,
                    5124,
                    3079,
                    5127,
                    3081,
                    3089,
                    3090,
                    1043,
                    5138,
                    1045,
                    3097,
                    1050,
                    1057,
                    3105,
                    3108,
                    1061,
                    3109,
                    1070,
                    1071,
                    1076,
                    1078,
                    1081,
                    3138,
                    3139,
                    3140,
                    3152,
                    3159,
                    5208,
                    3161,
                    3162,
                    3163,
                    5214,
                    5216,
                    3170,
                    3173,
                    3175,
                    3178,
                    1131,
                    3187,
                    1140,
                    1141,
                    1142,
                    3190,
                    1144,
                    5239,
                    5241,
                    5253,
                    1162,
                    1163,
                    1166,
                    3214,
                    3216,
                    3218,
                    1174,
                    1175,
                    5270,
                    5271,
                    5273,
                    1188,
                    5294,
                    5296,
                    5302,
                    1211,
                    3281,
                    1234,
                    1236,
                    3285,
                    1238,
                    3286,
                    3294,
                    3296,
                    3298,
                    3299,
                    3311,
                    5361,
                    5364,
                    5379,
                    3332,
                    5382,
                    1295,
                    1296,
                    1299,
                    5395,
                    3359,
                    3361,
                    3362,
                    1315,
                    3369,
                    3373,
                    1326,
                    3377,
                    3378,
                    3387,
                    3389,
                    3391,
                    5444,
                    5445,
                    5446,
                    5447,
                    1354,
                    1356,
                    3414,
                    3416,
                    3425,
                    3448,
                    3451,
                    1417,
                    1424,
                    1433,
                    3482,
                    1435,
                    3490,
                    3493,
                    3497,
                    3504,
                    5554,
                    3511,
                    3519,
                    3522,
                    3529,
                    3530,
                    3536,
                    1489,
                    3537,
                    5587,
                    3540,
                    3541,
                    3542,
                    3546,
                    3549,
                    3551,
                    1505,
                    3558,
                    3564,
                    3568,
                    1525,
                    3574,
                    1528,
                    3577,
                    1533,
                    3591,
                    3599,
                    1553,
                    3608,
                    3623,
                    1592,
                    1593,
                    3641,
                    3647,
                    3660,
                    3666,
                    1619,
                    1622,
                    1623,
                    3670,
                    1627,
                    1631,
                    1632,
                    1633,
                    3714,
                    3717,
                    3719,
                    1686,
                    1688,
                    1700,
                    1717,
                    1734,
                    1751,
                    1768,
                    3819,
                    3820,
                    1778,
                    3826,
                    3829,
                    1782,
                    3832,
                    1785,
                    3834,
                    1788,
                    3837,
                    1791,
                    3840,
                    3841,
                    1794,
                    3843,
                    3844,
                    1797,
                    3847,
                    3849,
                    3851,
                    3853,
                    3854,
                    3864,
                    1833,
                    1836,
                    1839,
                    3890,
                    1845,
                    1852,
                    1856,
                    1858,
                    1864,
                    1865,
                    1866,
                    3920,
                    1874,
                    1876,
                    1884,
                    1890,
                    1891,
                    1908,
                    1909,
                    1912,
                    1918,
                    1919,
                    3973,
                    3976,
                    1929,
                    1930,
                    3983,
                    4006,
                    4008,
                    4009,
                    4019,
                    4024,
                    1989,
                    2037
                ],
                "ValueError": [
                    3333,
                    390,
                    5128,
                    649,
                    1418,
                    3597,
                    2964,
                    5396,
                    5015,
                    2969,
                    411,
                    2982,
                    2091,
                    2862,
                    823,
                    3383,
                    2361,
                    3007,
                    449,
                    1345,
                    1347,
                    463,
                    5200,
                    5204,
                    1624,
                    4057,
                    475,
                    5727,
                    5088,
                    4066,
                    4069,
                    102,
                    871,
                    4200,
                    4337,
                    5111,
                    2426,
                    379,
                    890
                ],
                "is_object_dtype": [
                    352,
                    1088,
                    1091,
                    1797,
                    104,
                    4360,
                    299,
                    558,
                    4338,
                    1045,
                    343,
                    4793
                ],
                "ABCMultiIndex": [
                    104,
                    1417,
                    3081,
                    4814,
                    3482,
                    3483
                ],
                "np.errstate": [
                    106,
                    110
                ],
                "result": [
                    2560,
                    2563,
                    2065,
                    2069,
                    4650,
                    4651,
                    4652,
                    4653,
                    569,
                    570,
                    3647,
                    576,
                    577,
                    579,
                    580,
                    3653,
                    2629,
                    2630,
                    1092,
                    1097,
                    1098,
                    1099,
                    3654,
                    3652,
                    1102,
                    1103,
                    2127,
                    2128,
                    107,
                    1644,
                    1646,
                    111,
                    1648,
                    1649,
                    115,
                    116,
                    118,
                    120,
                    134,
                    135,
                    136,
                    137,
                    4258,
                    4259,
                    4260,
                    4262,
                    711,
                    712,
                    713,
                    717,
                    4817,
                    4820,
                    4822,
                    761,
                    763,
                    764,
                    765,
                    766,
                    1296,
                    1299,
                    1300,
                    319,
                    320,
                    322,
                    325,
                    335,
                    336,
                    338,
                    341,
                    346,
                    347,
                    4490,
                    3980,
                    4493,
                    3983,
                    3984,
                    4495,
                    5554,
                    5556,
                    5557,
                    5560,
                    5562,
                    3521,
                    3525,
                    3526,
                    3527,
                    2529,
                    2532,
                    2536,
                    2543,
                    2546,
                    2550
                ],
                "ops._comp_method_OBJECT_ARRAY": [
                    107
                ],
                "ops": [
                    5418,
                    107,
                    5420,
                    5421,
                    5425,
                    5430,
                    5433
                ],
                "op": [
                    5376,
                    5444,
                    3045,
                    134,
                    3047,
                    5447,
                    107,
                    139,
                    111,
                    122
                ],
                "self.values": [
                    4487,
                    2312,
                    3976,
                    4493,
                    801,
                    1061,
                    4009,
                    2094,
                    818,
                    5554,
                    821,
                    1081,
                    1858,
                    5447,
                    1238,
                    862,
                    3042,
                    3043,
                    613,
                    872,
                    107,
                    4333,
                    111,
                    3056
                ],
                "np.asarray": [
                    4255,
                    705,
                    3041,
                    2980,
                    808,
                    4106,
                    811,
                    493,
                    111,
                    3666,
                    1142,
                    567,
                    5270,
                    351
                ],
                "is_bool_dtype": [
                    712,
                    4011,
                    5135,
                    434,
                    115
                ],
                "TypeError": [
                    4224,
                    3715,
                    4227,
                    5380,
                    649,
                    5387,
                    1422,
                    655,
                    1425,
                    5015,
                    5399,
                    411,
                    2716,
                    5408,
                    1313,
                    1318,
                    3368,
                    4144,
                    823,
                    2872,
                    825,
                    2631,
                    1353,
                    4299,
                    4555,
                    5709,
                    5200,
                    119,
                    4057,
                    4704,
                    2530,
                    3554,
                    4066,
                    4200,
                    2793,
                    4073,
                    4712,
                    3308,
                    4080,
                    4337,
                    5362,
                    2804,
                    2551
                ],
                "name": [
                    512,
                    388,
                    265,
                    266,
                    139,
                    396,
                    141,
                    1294,
                    1295,
                    1296,
                    276,
                    1173,
                    1174,
                    1175,
                    3864,
                    3865,
                    1050,
                    4304,
                    286,
                    288,
                    1312,
                    1314,
                    1188,
                    294,
                    425,
                    1321,
                    1322,
                    1068,
                    429,
                    1323,
                    303,
                    560,
                    433,
                    4274,
                    5550,
                    5551,
                    5564,
                    319,
                    448,
                    577,
                    323,
                    452,
                    1351,
                    1352,
                    457,
                    2379,
                    2380,
                    2381,
                    462,
                    335,
                    976,
                    1489,
                    4302,
                    339,
                    1235,
                    1236,
                    1238,
                    2647,
                    4056,
                    2649,
                    346,
                    474,
                    2650,
                    4311,
                    4312,
                    4319,
                    4065,
                    484,
                    487,
                    232,
                    361,
                    490,
                    493,
                    508,
                    122,
                    124
                ],
                "format": [
                    5376,
                    5381,
                    1354,
                    139,
                    2091,
                    2362,
                    2553,
                    3309,
                    4074,
                    5388,
                    5363,
                    5300,
                    1527,
                    1625,
                    122,
                    2427
                ],
                "op.__name__": [
                    5376,
                    122,
                    139
                ],
                "set_function_name": [
                    124,
                    141
                ],
                "cmp_method": [
                    124
                ],
                "cls": [
                    387,
                    4101,
                    141,
                    276,
                    159,
                    162,
                    163,
                    5417,
                    5418,
                    5419,
                    5420,
                    5421,
                    5422,
                    559,
                    5424,
                    5425,
                    5580,
                    5428,
                    5429,
                    5430,
                    5431,
                    5432,
                    569,
                    5433,
                    5567,
                    448,
                    5312,
                    5313,
                    5314,
                    5315,
                    5316,
                    5317,
                    5570,
                    5579,
                    5324,
                    5325,
                    5326,
                    5327,
                    5328,
                    5329,
                    5452,
                    5453,
                    5454,
                    5455,
                    5459,
                    5460,
                    5336,
                    5337,
                    5338,
                    5339,
                    5340,
                    5341,
                    5342,
                    5343,
                    5344,
                    5345,
                    5346,
                    5347,
                    5348,
                    5349,
                    490,
                    4075,
                    495,
                    760,
                    761,
                    124
                ],
                "ABCDataFrame": [
                    129,
                    2330
                ],
                "ABCTimedeltaIndex": [
                    129
                ],
                "NotImplemented": [
                    130,
                    2331
                ],
                "Series": [
                    2339,
                    1238,
                    134,
                    2334
                ],
                "tuple": [
                    3428,
                    3652,
                    4292,
                    135,
                    4104,
                    940,
                    1616,
                    4851,
                    502,
                    1878,
                    858
                ],
                "index_arithmetic_method": [
                    141
                ],
                "Exception": [
                    1893,
                    4710,
                    2637,
                    144,
                    4368,
                    3188
                ],
                "_o_dtype": [
                    312,
                    148,
                    332
                ],
                "np.dtype": [
                    148
                ],
                "object": [
                    2947,
                    2948,
                    148,
                    149,
                    4014,
                    437,
                    569,
                    320,
                    452,
                    336,
                    2403,
                    3428,
                    2405,
                    2406,
                    360,
                    361,
                    4342,
                    1144,
                    511
                ],
                "_Identity": [
                    680,
                    149
                ],
                "issubclass": [
                    434,
                    159
                ],
                "ABCPeriodIndex": [
                    3282,
                    159
                ],
                "_new_PeriodIndex": [
                    162
                ],
                "d": [
                    162,
                    163,
                    1864,
                    1865,
                    1866
                ],
                "cls.__new__": [
                    163
                ],
                "IndexOpsMixin": [
                    3978,
                    166
                ],
                "PandasObject": [
                    166
                ],
                "_deprecations": [
                    208
                ],
                "DirNamesMixin._deprecations": [
                    208
                ],
                "DirNamesMixin": [
                    208
                ],
                "_join_precedence": [
                    211
                ],
                "libjoin.left_join_indexer_unique": [
                    218
                ],
                "libjoin": [
                    224,
                    218,
                    227,
                    221
                ],
                "left": [
                    224,
                    227,
                    3717,
                    3741,
                    3749,
                    3752,
                    3721,
                    3755,
                    3724,
                    3725,
                    3759,
                    3793,
                    3737,
                    218,
                    3739,
                    221,
                    3742
                ],
                "right": [
                    224,
                    227,
                    3717,
                    3721,
                    3727,
                    3733,
                    218,
                    221
                ],
                "libjoin.left_join_indexer": [
                    221
                ],
                "libjoin.inner_join_indexer": [
                    224
                ],
                "libjoin.outer_join_indexer": [
                    227
                ],
                "_typ": [
                    229
                ],
                "_data": [
                    230
                ],
                "_id": [
                    231
                ],
                "_comparables": [
                    233
                ],
                "_attributes": [
                    234
                ],
                "_is_numeric_dtype": [
                    235
                ],
                "_can_hold_na": [
                    236
                ],
                "_defer_to_indexing": [
                    239
                ],
                "_infer_as_myclass": [
                    243
                ],
                "_engine_type": [
                    245
                ],
                "libindex.ObjectEngine": [
                    245
                ],
                "libindex": [
                    4701,
                    245
                ],
                "_accessors": [
                    247
                ],
                "str": [
                    739,
                    1164,
                    5196,
                    1167,
                    1142,
                    249,
                    412
                ],
                "CachedAccessor": [
                    249
                ],
                "StringMethods": [
                    249
                ],
                "hasattr": [
                    5672,
                    265,
                    553,
                    492,
                    1164,
                    1167,
                    760,
                    3353
                ],
                "data": [
                    4099,
                    4100,
                    4101,
                    4104,
                    4105,
                    4106,
                    4107,
                    265,
                    266,
                    276,
                    280,
                    282,
                    285,
                    286,
                    287,
                    288,
                    291,
                    294,
                    298,
                    303,
                    306,
                    319,
                    323,
                    327,
                    335,
                    339,
                    343,
                    346,
                    1882,
                    1883,
                    350,
                    351,
                    1887,
                    1888,
                    1890,
                    355,
                    356,
                    360,
                    361,
                    364,
                    374,
                    376,
                    378,
                    382,
                    388,
                    396,
                    401,
                    403,
                    407,
                    409,
                    422,
                    425,
                    426,
                    429,
                    430,
                    433,
                    434,
                    435,
                    437,
                    4054,
                    4055,
                    4063,
                    4064,
                    4075,
                    492,
                    493,
                    494,
                    495,
                    1005,
                    497,
                    499,
                    500,
                    1012,
                    502,
                    1013,
                    1015,
                    508,
                    511
                ],
                "data.name": [
                    266
                ],
                "fastpath": [
                    275,
                    268
                ],
                "warnings.warn": [
                    269,
                    2286,
                    4214,
                    3967,
                    2552,
                    733,
                    1183
                ],
                "warnings": [
                    269,
                    2286,
                    4214,
                    3967,
                    2552,
                    733,
                    1183
                ],
                "FutureWarning": [
                    736,
                    1185,
                    3970,
                    272,
                    2290,
                    4218
                ],
                "cls._simple_new": [
                    490,
                    276
                ],
                "ABCPandasArray": [
                    280
                ],
                "data.to_numpy": [
                    282
                ],
                "RangeIndex": [
                    288,
                    285,
                    286,
                    5733
                ],
                "copy": [
                    512,
                    388,
                    396,
                    409,
                    796,
                    286,
                    801,
                    5669,
                    294,
                    425,
                    5673,
                    811,
                    429,
                    303,
                    433,
                    818,
                    821,
                    441,
                    5695,
                    448,
                    5698,
                    323,
                    452,
                    457,
                    462,
                    339,
                    4056,
                    346,
                    474,
                    4065,
                    484,
                    361,
                    493,
                    376
                ],
                "dtype": [
                    512,
                    388,
                    396,
                    401,
                    402,
                    4117,
                    407,
                    409,
                    4122,
                    795,
                    4124,
                    286,
                    798,
                    288,
                    801,
                    802,
                    291,
                    294,
                    807,
                    4008,
                    425,
                    298,
                    299,
                    554,
                    429,
                    555,
                    303,
                    560,
                    433,
                    810,
                    307,
                    811,
                    814,
                    818,
                    821,
                    312,
                    825,
                    4022,
                    4024,
                    444,
                    448,
                    705,
                    323,
                    328,
                    332,
                    4050,
                    339,
                    979,
                    980,
                    343,
                    350,
                    352,
                    355,
                    356,
                    4015,
                    365,
                    493,
                    373,
                    376,
                    382
                ],
                "range": [
                    287
                ],
                "RangeIndex.from_range": [
                    288
                ],
                "is_categorical_dtype": [
                    291,
                    1085,
                    798
                ],
                "CategoricalIndex": [
                    801,
                    294
                ],
                "kwargs": [
                    512,
                    642,
                    644,
                    294,
                    4653,
                    302,
                    4782,
                    560,
                    4783,
                    308,
                    1078,
                    319,
                    578,
                    323,
                    335,
                    975,
                    339,
                    984,
                    857,
                    474,
                    346,
                    858,
                    484,
                    487,
                    615,
                    361,
                    616,
                    493,
                    1134,
                    508
                ],
                "is_interval_dtype": [
                    298
                ],
                "closed": [
                    302,
                    303
                ],
                "kwargs.get": [
                    508,
                    302,
                    975
                ],
                "IntervalIndex": [
                    462,
                    303
                ],
                "is_datetime64_any_dtype": [
                    306,
                    307
                ],
                "is_dtype_equal": [
                    2946,
                    3529,
                    332,
                    2612,
                    2422,
                    312,
                    795
                ],
                "DatetimeIndex": [
                    322,
                    808,
                    817,
                    4790,
                    4791,
                    474,
                    319
                ],
                "result.astype": [
                    320,
                    336
                ],
                "is_timedelta64_dtype": [
                    328,
                    327
                ],
                "TimedeltaIndex": [
                    338,
                    484,
                    335
                ],
                "is_period_dtype": [
                    2618,
                    2518,
                    343,
                    2522,
                    2622
                ],
                "PeriodIndex": [
                    346,
                    487
                ],
                "is_extension_array_dtype": [
                    810,
                    350
                ],
                "_from_sequence": [
                    355
                ],
                "dtype.construct_array_type": [
                    355
                ],
                "data.astype": [
                    360,
                    401,
                    435,
                    4054,
                    407,
                    4063
                ],
                "is_integer_dtype": [
                    3280,
                    373
                ],
                "inferred": [
                    481,
                    453,
                    485,
                    458,
                    398,
                    466,
                    403,
                    404,
                    469,
                    374,
                    375,
                    470,
                    377,
                    381,
                    446,
                    445
                ],
                "lib.infer_dtype": [
                    403,
                    1852,
                    445,
                    374
                ],
                "lib": [
                    3712,
                    1089,
                    3746,
                    711,
                    712,
                    5136,
                    5138,
                    403,
                    5684,
                    374,
                    1852,
                    445
                ],
                "maybe_cast_to_integer_array": [
                    376,
                    382
                ],
                "any": [
                    378,
                    885
                ],
                "isna": [
                    1991,
                    1095,
                    2320,
                    4019,
                    1140,
                    1909,
                    4119,
                    378
                ],
                "cls._try_convert_to_int_index": [
                    448,
                    387
                ],
                "Float64Index": [
                    433,
                    396,
                    457
                ],
                "is_float_dtype": [
                    402,
                    430
                ],
                "np.array": [
                    1922,
                    1097,
                    2346,
                    4652,
                    557,
                    2349,
                    1144,
                    409,
                    1086
                ],
                "msg": [
                    870,
                    871,
                    1421,
                    1422,
                    4143,
                    4144,
                    886,
                    824,
                    825,
                    890,
                    412,
                    414,
                    415
                ],
                "e": [
                    2554,
                    412,
                    502
                ],
                "is_signed_integer_dtype": [
                    422
                ],
                "data.dtype": [
                    434,
                    426,
                    430,
                    422
                ],
                "Int64Index": [
                    4056,
                    425
                ],
                "is_unsigned_integer_dtype": [
                    4050,
                    426
                ],
                "UInt64Index": [
                    4065,
                    429
                ],
                "data.dtype.type": [
                    434
                ],
                "np.bool": [
                    434
                ],
                "subarr": [
                    448,
                    512,
                    452,
                    484,
                    487,
                    457,
                    490,
                    462,
                    474,
                    435,
                    437,
                    442,
                    445,
                    511
                ],
                "com.asarray_tuplesafe": [
                    437,
                    3238,
                    511
                ],
                "com": [
                    4257,
                    3238,
                    3591,
                    3592,
                    4366,
                    5295,
                    4690,
                    4691,
                    437,
                    4246,
                    4727,
                    5397,
                    4254,
                    511
                ],
                "subarr.copy": [
                    442
                ],
                "inferred.startswith": [
                    481,
                    470
                ],
                "OutOfBoundsDatetime": [
                    475
                ],
                "IncompatibleFrequency": [
                    488
                ],
                "is_scalar": [
                    4674,
                    4259,
                    4100,
                    4997,
                    4999,
                    4714,
                    4142,
                    494,
                    4245
                ],
                "cls._scalar_data_error": [
                    4101,
                    495
                ],
                "tupleize_cols": [
                    497
                ],
                "is_list_like": [
                    1344,
                    1317,
                    1321,
                    1420,
                    1424,
                    497,
                    1427,
                    2803,
                    1429
                ],
                "is_iterator": [
                    5675,
                    4706,
                    499
                ],
                "list": [
                    4104,
                    4105,
                    3605,
                    3606,
                    3752,
                    3755,
                    5676,
                    5680,
                    5681,
                    5682,
                    3635,
                    1076,
                    4292,
                    4293,
                    5710,
                    1616,
                    1631,
                    1632,
                    1633,
                    2532,
                    500
                ],
                "all": [
                    4064,
                    4384,
                    502,
                    4055,
                    5720,
                    3287
                ],
                "MultiIndex.from_tuples": [
                    4858,
                    507
                ],
                "MultiIndex": [
                    5633,
                    3714,
                    3719,
                    3627,
                    3790,
                    3599,
                    3600,
                    4852,
                    1653,
                    5689,
                    4858,
                    507
                ],
                "property": [
                    1029,
                    1702,
                    1736,
                    1719,
                    1358,
                    5582,
                    4146,
                    1780,
                    533,
                    1494,
                    726,
                    3892,
                    1753,
                    3870,
                    1695
                ],
                "values": [
                    644,
                    648,
                    2312,
                    651,
                    2315,
                    2320,
                    1912,
                    2324,
                    1914,
                    3361,
                    3362,
                    553,
                    554,
                    555,
                    4009,
                    557,
                    558,
                    559,
                    560,
                    4014,
                    4017,
                    563,
                    4019,
                    567,
                    4024,
                    1081,
                    570,
                    1085,
                    1086,
                    576,
                    1088,
                    1089,
                    1091,
                    1092,
                    1344,
                    1346,
                    1095,
                    1347,
                    1351,
                    1356,
                    1102,
                    4814,
                    4815,
                    4816,
                    4817,
                    4948,
                    3425,
                    612,
                    613,
                    616,
                    1131,
                    620,
                    621,
                    1133,
                    1134,
                    624,
                    4333,
                    626,
                    4335,
                    4336,
                    1142,
                    1144,
                    1913,
                    1146,
                    1147,
                    892,
                    895
                ],
                "np.empty": [
                    3428,
                    555,
                    3697,
                    1912,
                    1882,
                    1887
                ],
                "_ndarray_values": [
                    5271,
                    559
                ],
                "ABCIndexClass": [
                    563,
                    3893
                ],
                "values._values": [
                    567
                ],
                "object.__new__": [
                    569
                ],
                "result._data": [
                    570
                ],
                "result._index_data": [
                    576
                ],
                "result.name": [
                    1648,
                    577
                ],
                "k": [
                    578,
                    579,
                    593,
                    1009,
                    1875,
                    1876,
                    4691,
                    4693,
                    4695,
                    4820
                ],
                "v": [
                    578,
                    579,
                    3148,
                    1009,
                    1875,
                    1876,
                    4820
                ],
                "kwargs.items": [
                    578
                ],
                "setattr": [
                    579,
                    1876
                ],
                "result._reset_identity": [
                    580
                ],
                "classmethod": [
                    545,
                    5412,
                    5574,
                    4071,
                    5319,
                    5307,
                    4078,
                    5435,
                    5457,
                    5331,
                    4085,
                    5462,
                    4027
                ],
                "type": [
                    4224,
                    4613,
                    4390,
                    5382,
                    584,
                    5389,
                    3311,
                    4144,
                    5681,
                    5364,
                    2422,
                    1174,
                    825
                ],
                "cache_readonly": [
                    1924,
                    582,
                    1773,
                    686,
                    719,
                    1903,
                    1847,
                    1916,
                    1854
                ],
                "getattr": [
                    4673,
                    674,
                    4386,
                    620,
                    593,
                    3377,
                    4695
                ],
                "self._attributes": [
                    593
                ],
                "attributes": [
                    641,
                    642,
                    643,
                    4865,
                    645,
                    614,
                    615,
                    648,
                    617,
                    651,
                    4848,
                    626,
                    4854,
                    4855,
                    4860,
                    4863
                ],
                "self._get_attributes_dict": [
                    641,
                    5445,
                    614,
                    1865,
                    715,
                    2796,
                    4848,
                    4124,
                    3359
                ],
                "attributes.update": [
                    642,
                    615
                ],
                "self.dtype": [
                    2946,
                    739,
                    3362,
                    1797,
                    645,
                    4008,
                    617,
                    3529,
                    5294,
                    2612,
                    4117,
                    2422,
                    4793,
                    795,
                    4863
                ],
                "ABCDatetimeArray": [
                    621
                ],
                "values.asi8": [
                    624
                ],
                "self._simple_new": [
                    626,
                    3362
                ],
                "Appender": [
                    3074,
                    3978,
                    2061,
                    4752,
                    1682,
                    3480,
                    793,
                    4003,
                    3236,
                    2088,
                    937,
                    2858,
                    2603,
                    5551,
                    5552,
                    3127,
                    3256,
                    4667,
                    5057,
                    968,
                    2123,
                    3276,
                    855,
                    610,
                    4195,
                    2927
                ],
                "self._infer_as_myclass": [
                    646
                ],
                "self._constructor": [
                    648,
                    2563
                ],
                "self._id": [
                    680,
                    674,
                    765
                ],
                "Ellipsis": [
                    674
                ],
                "self._engine.clear_mapping": [
                    684
                ],
                "self._engine": [
                    1734,
                    4199,
                    4766,
                    684,
                    2988,
                    2990,
                    3983,
                    1778,
                    2867,
                    1717,
                    2869,
                    4695,
                    4726,
                    2974
                ],
                "self._engine_type": [
                    689
                ],
                "self._ndarray_values": [
                    3660,
                    689,
                    754,
                    3666,
                    3826,
                    2519,
                    2619
                ],
                "self._data": [
                    1856,
                    705,
                    1890,
                    3361,
                    5253,
                    1864,
                    971,
                    2702,
                    3920,
                    1874,
                    3890,
                    724,
                    4242,
                    761,
                    699
                ],
                "lib.item_from_zerodim": [
                    711
                ],
                "lib.is_scalar": [
                    712
                ],
                "attrs": [
                    3360,
                    3362,
                    5445,
                    5446,
                    5447,
                    715,
                    716,
                    717,
                    1006,
                    5355,
                    1009,
                    3359
                ],
                "self._maybe_update_attributes": [
                    716,
                    5446
                ],
                "self._data.dtype": [
                    724
                ],
                "self._ndarray_values.ravel": [
                    754
                ],
                "order": [
                    754
                ],
                "self._data.view": [
                    761,
                    3890
                ],
                "self._shallow_copy": [
                    5253,
                    2702,
                    4243,
                    2324,
                    2070,
                    1435,
                    941,
                    2094,
                    2095,
                    3504,
                    971,
                    973,
                    2381,
                    2128,
                    1234,
                    2650,
                    873,
                    4336,
                    763
                ],
                "result._id": [
                    765
                ],
                "self.copy": [
                    984,
                    995,
                    796
                ],
                "self.name": [
                    1295,
                    2069,
                    801,
                    1070,
                    1071,
                    1326,
                    818,
                    821,
                    3389,
                    3391,
                    1356,
                    2380,
                    4302,
                    1236,
                    2646,
                    2649,
                    1884,
                    2652,
                    1525,
                    1528,
                    2809,
                    2810
                ],
                "is_datetime64tz_dtype": [
                    2522,
                    802,
                    2518,
                    814
                ],
                "tz": [
                    808,
                    807
                ],
                "pandas_dtype": [
                    807
                ],
                "tz_convert": [
                    808
                ],
                "tz_localize": [
                    808
                ],
                "self.values.astype": [
                    821
                ],
                "msg.format": [
                    4144,
                    825,
                    871
                ],
                "__name__": [
                    4224,
                    4613,
                    5382,
                    4144,
                    5364,
                    1174,
                    825
                ],
                "nv.validate_take": [
                    858
                ],
                "nv": [
                    858,
                    940
                ],
                "indices": [
                    872,
                    881,
                    885,
                    895,
                    859,
                    892,
                    863
                ],
                "ensure_platform_int": [
                    2976,
                    3809,
                    3812,
                    939,
                    3663,
                    3664,
                    881,
                    3857,
                    3858,
                    2938,
                    859,
                    3422,
                    4767
                ],
                "self._can_hold_na": [
                    1908,
                    1929,
                    860,
                    1918
                ],
                "taken": [
                    896,
                    2653,
                    872,
                    873,
                    2655,
                    2642,
                    2645,
                    2650,
                    891,
                    861,
                    895
                ],
                "self._assert_take_fillable": [
                    861
                ],
                "allow_fill": [
                    864,
                    892,
                    884,
                    869
                ],
                "fill_value": [
                    865,
                    884,
                    869
                ],
                "self._na_value": [
                    866,
                    4452,
                    4006
                ],
                "self.__class__.__name__": [
                    1354,
                    1004,
                    2364,
                    871
                ],
                "self.__class__": [
                    871,
                    1354,
                    1866,
                    1004,
                    2364
                ],
                "self.values.take": [
                    872
                ],
                "np.nan": [
                    1900,
                    876,
                    1646
                ],
                "algos.take": [
                    891
                ],
                "algos": [
                    3748,
                    2542,
                    2639,
                    4948,
                    3798,
                    891
                ],
                "na_value": [
                    892
                ],
                "values.take": [
                    895
                ],
                "repeats": [
                    939,
                    941
                ],
                "nv.validate_repeat": [
                    940
                ],
                "axis": [
                    940
                ],
                "self._values.repeat": [
                    941
                ],
                "self._values": [
                    1296,
                    2521,
                    2621,
                    941
                ],
                "deep": [
                    1315,
                    970,
                    3980,
                    3983,
                    976
                ],
                "new_index": [
                    971,
                    973,
                    977,
                    980,
                    981,
                    3451,
                    3452
                ],
                "self._data.copy": [
                    971
                ],
                "names": [
                    5633,
                    1420,
                    1424,
                    1427,
                    1428,
                    1436,
                    1312,
                    1314,
                    1316,
                    1317,
                    3622,
                    1319,
                    3628,
                    4301,
                    1358,
                    975,
                    976,
                    977,
                    4302,
                    4853,
                    4855,
                    4857,
                    4858,
                    5629,
                    5630,
                    5631
                ],
                "self._validate_names": [
                    976
                ],
                "new_index.set_names": [
                    977
                ],
                "new_index.astype": [
                    980
                ],
                "memo": [
                    993,
                    994
                ],
                "klass": [
                    1004,
                    1015
                ],
                "self._format_data": [
                    1005
                ],
                "self._format_attrs": [
                    1006
                ],
                "space": [
                    1009,
                    1007
                ],
                "self._format_space": [
                    1007
                ],
                "prepr": [
                    1009,
                    1015
                ],
                "join": [
                    1009
                ],
                "res": [
                    4064,
                    4065,
                    1015,
                    4054,
                    4055,
                    4056,
                    1017,
                    4063
                ],
                "default_pprint": [
                    1034
                ],
                "is_justify": [
                    1042,
                    1050
                ],
                "self.inferred_type": [
                    4161,
                    1794,
                    3298,
                    1833,
                    3178,
                    1836,
                    4792,
                    1839,
                    1043,
                    1045,
                    1845,
                    3285,
                    4790,
                    1785,
                    1788,
                    3097,
                    1791
                ],
                "self.categories": [
                    1045
                ],
                "format_object_summary": [
                    1049
                ],
                "self._formatter_func": [
                    1050
                ],
                "format_object_attrs": [
                    1057
                ],
                "header": [
                    1067,
                    1069,
                    1103,
                    1076,
                    1078
                ],
                "header.append": [
                    1069
                ],
                "pprint_thing": [
                    1169,
                    1092,
                    1070
                ],
                "formatter": [
                    1075,
                    1076
                ],
                "self.map": [
                    1688,
                    1076
                ],
                "self._format_with_header": [
                    1078
                ],
                "values.dtype": [
                    1088,
                    1091,
                    1085
                ],
                "lib.maybe_convert_objects": [
                    1089
                ],
                "x": [
                    1092,
                    3525,
                    3526,
                    2536,
                    5455,
                    5720,
                    5721
                ],
                "mask": [
                    4487,
                    4490,
                    4492,
                    3760,
                    3761,
                    3762,
                    3763,
                    5297,
                    5298,
                    5300,
                    5301,
                    3777,
                    3778,
                    3780,
                    1095,
                    1096,
                    1098,
                    3788,
                    3667,
                    3668,
                    1643,
                    1645,
                    1646,
                    4335,
                    1140,
                    4342,
                    1146
                ],
                "mask.any": [
                    1096,
                    5298,
                    1645
                ],
                "na_rep": [
                    1098,
                    1146
                ],
                "result.tolist": [
                    1099
                ],
                "_trim_front": [
                    1102
                ],
                "format_array": [
                    1102
                ],
                "slicer": [
                    1132,
                    1133
                ],
                "values._format_native_types": [
                    1134
                ],
                "self.is_object": [
                    4273,
                    4155,
                    1141
                ],
                "quoting": [
                    1141
                ],
                "astype": [
                    2406,
                    2405,
                    1142
                ],
                "head": [
                    1169,
                    1163,
                    1164,
                    1165
                ],
                "head.format": [
                    1165
                ],
                "tail": [
                    1168,
                    1169,
                    1166,
                    1167
                ],
                "tail.format": [
                    1168
                ],
                "index_summary": [
                    1169,
                    1171,
                    1175
                ],
                "self._summary": [
                    1188
                ],
                "index": [
                    1233,
                    1234,
                    1298,
                    1238
                ],
                "self.values.copy": [
                    4333,
                    1238
                ],
                "DataFrame": [
                    1296
                ],
                "self._values.copy": [
                    1296
                ],
                "result.index": [
                    1299
                ],
                "deepcopy": [
                    1315
                ],
                "self.names": [
                    1633,
                    3490,
                    1315,
                    3591,
                    4853
                ],
                "FrozenList": [
                    1326
                ],
                "is_hashable": [
                    1352
                ],
                "_set_names": [
                    1358
                ],
                "_get_names": [
                    1358
                ],
                "level": [
                    1417,
                    1420,
                    3724,
                    3725,
                    1424,
                    1684,
                    1429,
                    1430,
                    1436,
                    3741,
                    3487,
                    3749,
                    3366,
                    3496,
                    3753,
                    3370,
                    3498,
                    3756,
                    3766,
                    1592,
                    3646,
                    3648,
                    3522,
                    3782,
                    2125,
                    2126,
                    1616,
                    1617,
                    4946,
                    1619,
                    4947,
                    1621,
                    1623,
                    3799,
                    3802,
                    1627,
                    1515,
                    1516,
                    1519,
                    1521,
                    1523,
                    1525,
                    1528,
                    1533
                ],
                "self.nlevels": [
                    1424,
                    1627,
                    1623
                ],
                "inplace": [
                    1432,
                    1489,
                    1437
                ],
                "idx": [
                    5273,
                    5272,
                    1433,
                    1435,
                    1436,
                    1438
                ],
                "idx._set_names": [
                    1436
                ],
                "self.set_names": [
                    1489
                ],
                "int": [
                    1515,
                    5012
                ],
                "IndexError": [
                    1522,
                    4715,
                    1517,
                    4702
                ],
                "KeyError": [
                    4451,
                    5125,
                    3177,
                    4684,
                    2868,
                    5140,
                    1526,
                    5300,
                    4696,
                    2875
                ],
                "self._validate_index_level": [
                    1592,
                    4947,
                    1533,
                    2126
                ],
                "self.sort_values": [
                    1553
                ],
                "ascending": [
                    1553,
                    4541
                ],
                "get_level_values": [
                    1595
                ],
                "_get_level_values": [
                    1595
                ],
                "levnums": [
                    1635,
                    1619
                ],
                "sorted": [
                    1619
                ],
                "self._get_level_number": [
                    1619
                ],
                "lev": [
                    1619
                ],
                "new_levels": [
                    1636,
                    1640,
                    3755,
                    1644,
                    3756,
                    3791,
                    1654,
                    1631
                ],
                "self.levels": [
                    1631
                ],
                "new_codes": [
                    1632,
                    3780,
                    1637,
                    3782,
                    3783,
                    3752,
                    3753,
                    1643,
                    1644,
                    3792,
                    3762,
                    1655,
                    3774
                ],
                "self.codes": [
                    1632
                ],
                "new_names": [
                    1648,
                    1633,
                    1656,
                    1638
                ],
                "i": [
                    1635,
                    1636,
                    1637,
                    1638
                ],
                "new_levels.pop": [
                    1636
                ],
                "new_codes.pop": [
                    1637
                ],
                "new_names.pop": [
                    1638
                ],
                "take": [
                    4490,
                    1644
                ],
                "result.putmask": [
                    1646
                ],
                "mapper": [
                    1688,
                    1685,
                    4846
                ],
                "grouper": [
                    1688,
                    1690,
                    1686
                ],
                "self.is_monotonic_increasing": [
                    1700,
                    3045,
                    2986,
                    5077,
                    1751
                ],
                "self._engine.is_monotonic_increasing": [
                    1717
                ],
                "self._engine.is_monotonic_decreasing": [
                    1734
                ],
                "self.is_unique": [
                    3332,
                    2309,
                    1768,
                    2953,
                    2314,
                    4781,
                    3536,
                    3377,
                    3540,
                    3829,
                    1782,
                    1751
                ],
                "self.is_monotonic_decreasing": [
                    1768,
                    5079
                ],
                "self._engine.is_unique": [
                    1778
                ],
                "is_datetime_array": [
                    1858
                ],
                "ensure_object": [
                    1858
                ],
                "d.update": [
                    1865
                ],
                "_new_Index": [
                    1866
                ],
                "state": [
                    1888,
                    1873,
                    1874,
                    1875,
                    1878,
                    1880,
                    1881,
                    1887
                ],
                "state.pop": [
                    1874
                ],
                "state.items": [
                    1875
                ],
                "nd_state": [
                    1881,
                    1882,
                    1883
                ],
                "own_state": [
                    1881,
                    1884
                ],
                "np.ndarray.__setstate__": [
                    1888,
                    1883
                ],
                "self._reset_identity": [
                    1891
                ],
                "_unpickle_compat": [
                    1895
                ],
                "__setstate__": [
                    1895
                ],
                "_na_value": [
                    1900
                ],
                "np.bool_": [
                    1912
                ],
                "values.fill": [
                    1913
                ],
                "w": [
                    1920,
                    1919
                ],
                "self._isnan.nonzero": [
                    1919
                ],
                "self._isnan": [
                    1989,
                    1930,
                    2094,
                    2065,
                    1919
                ],
                "np.int64": [
                    1922
                ],
                "bool": [
                    1930,
                    4255
                ],
                "self._isnan.any": [
                    1930
                ],
                "isnull": [
                    1991
                ],
                "self.isna": [
                    2037
                ],
                "notnull": [
                    2039
                ],
                "notna": [
                    2039
                ],
                "self._assert_can_do_op": [
                    2063
                ],
                "value": [
                    4136,
                    4142,
                    2063,
                    4144,
                    2065,
                    4335,
                    4342,
                    4727
                ],
                "self.hasnans": [
                    2064,
                    2093,
                    2319
                ],
                "self.putmask": [
                    2065
                ],
                "downcast": [
                    2066
                ],
                "how": [
                    3842,
                    3846,
                    3848,
                    3722,
                    3850,
                    3852,
                    3733,
                    3614,
                    3493,
                    3498,
                    2090,
                    2091,
                    3503,
                    3511,
                    3644,
                    3520,
                    3648,
                    3522,
                    3532,
                    3660,
                    3534,
                    3538,
                    3543,
                    3547,
                    3552,
                    3557,
                    3559,
                    3561,
                    3820,
                    3565,
                    3831,
                    3835,
                    3839
                ],
                "unique": [
                    2294,
                    2127
                ],
                "super": [
                    2176,
                    3980,
                    4846,
                    2127,
                    2232
                ],
                "drop_duplicates": [
                    2176
                ],
                "keep": [
                    2176,
                    2232
                ],
                "duplicated": [
                    2232
                ],
                "self.duplicated": [
                    2294
                ],
                "dropna": [
                    2317,
                    2309
                ],
                "self.unique": [
                    2315
                ],
                "NotImplementedError": [
                    3728,
                    2321,
                    4953,
                    4613
                ],
                "self.intersection": [
                    2352,
                    3564
                ],
                "self.union": [
                    3568,
                    2355
                ],
                "self.symmetric_difference": [
                    2358
                ],
                "__bool__": [
                    2368
                ],
                "__nonzero__": [
                    2368
                ],
                "get_op_result_name": [
                    2563,
                    3864,
                    2379,
                    2812
                ],
                "this": [
                    2403,
                    2947,
                    2949,
                    2406,
                    2711,
                    3530,
                    3532,
                    2776,
                    2706,
                    2783,
                    2708,
                    2613,
                    2774,
                    2615,
                    2712,
                    2781,
                    2719
                ],
                "self.astype": [
                    2403,
                    2947,
                    3530,
                    2613,
                    4342,
                    4794
                ],
                "Index.union": [
                    2406
                ],
                "sort": [
                    2615,
                    2406,
                    2790,
                    2697,
                    2489,
                    2605,
                    2768,
                    2713,
                    2483,
                    2548,
                    2644,
                    3570,
                    2487,
                    2425,
                    2428,
                    2527
                ],
                "other.dtype": [
                    3529,
                    2612,
                    2422,
                    5398
                ],
                "self._validate_sort_keyword": [
                    2768,
                    2697,
                    2483,
                    2605
                ],
                "self._assert_can_do_setop": [
                    2769,
                    2698,
                    2484,
                    2606
                ],
                "self._is_compatible_with_other": [
                    2486
                ],
                "self._union_incompatible_dtypes": [
                    2487
                ],
                "self._union": [
                    2489
                ],
                "self.equals": [
                    3819,
                    2700,
                    3373,
                    2511,
                    2609,
                    4383
                ],
                "self._get_reconciled_name_object": [
                    2512,
                    2610
                ],
                "other._get_reconciled_name_object": [
                    2515
                ],
                "lvals": [
                    2529,
                    2532,
                    2629,
                    2535,
                    2635,
                    2543,
                    2639,
                    2546,
                    2519,
                    2521,
                    2619,
                    2621
                ],
                "rvals": [
                    2529,
                    2625,
                    2629,
                    2536,
                    2635,
                    2542,
                    2639,
                    2523,
                    2525,
                    2623
                ],
                "other._ndarray_values": [
                    3660,
                    3827,
                    3668,
                    2523,
                    2623
                ],
                "other._values": [
                    2625,
                    2525
                ],
                "self.is_monotonic": [
                    3549,
                    2627,
                    3541,
                    2527
                ],
                "other.is_monotonic": [
                    3549,
                    2627,
                    3541,
                    2527
                ],
                "self._outer_indexer": [
                    2529,
                    3843,
                    3853
                ],
                "value_set": [
                    2536,
                    2535
                ],
                "set": [
                    3592,
                    3591,
                    2535
                ],
                "result.extend": [
                    2536
                ],
                "indexer": [
                    3332,
                    3436,
                    2959,
                    2961,
                    3218,
                    3219,
                    2708,
                    2709,
                    5296,
                    2711,
                    2974,
                    4766,
                    2976,
                    4767,
                    3369,
                    3374,
                    4783,
                    2992,
                    4784,
                    2994,
                    3378,
                    2996,
                    2997,
                    2870,
                    2871,
                    2999,
                    2873,
                    5297,
                    3387,
                    5301,
                    5302,
                    3393,
                    3015,
                    3016,
                    3017,
                    2635,
                    2636,
                    2639,
                    2640,
                    3023,
                    2642,
                    3029,
                    3030,
                    3286,
                    2776,
                    3287,
                    3288,
                    2779,
                    3414,
                    3415,
                    3294,
                    3416,
                    3296,
                    3420,
                    2786,
                    3425,
                    3428,
                    3046,
                    2538,
                    2539,
                    3052,
                    2541,
                    2542,
                    3053,
                    3056,
                    3057,
                    3058,
                    3182,
                    3184,
                    3187,
                    3445,
                    3448,
                    3193,
                    3452,
                    3197
                ],
                "self.get_indexer": [
                    3015,
                    2538,
                    4782,
                    5296,
                    3378,
                    2870,
                    3286,
                    3577,
                    3038,
                    3039
                ],
                "nonzero": [
                    2786,
                    2539,
                    2636,
                    2709,
                    2779,
                    3710
                ],
                "other_diff": [
                    2542,
                    2543
                ],
                "algos.take_nd": [
                    3748,
                    3798,
                    2542
                ],
                "concat_compat": [
                    2789,
                    2543
                ],
                "sorting.safe_sort": [
                    2792,
                    2715,
                    2645,
                    2550
                ],
                "sorting": [
                    2792,
                    2715,
                    2645,
                    2550
                ],
                "RuntimeWarning": [
                    2555
                ],
                "self._wrap_setop_result": [
                    2560,
                    2630
                ],
                "ensure_index": [
                    3364,
                    3501,
                    2607,
                    2930,
                    4754,
                    3413
                ],
                "other.astype": [
                    4794,
                    3531,
                    2614
                ],
                "this.intersection": [
                    2615
                ],
                "self._inner_indexer": [
                    3840,
                    3851,
                    2629
                ],
                "get_indexer": [
                    2635
                ],
                "indexer.take": [
                    2779,
                    2636,
                    2709
                ],
                "algos.unique1d": [
                    2639
                ],
                "get_indexer_non_unique": [
                    2639
                ],
                "other.take": [
                    2642
                ],
                "taken.values": [
                    2645
                ],
                "other.name": [
                    2652,
                    2646
                ],
                "taken.name": [
                    2653
                ],
                "result_name": [
                    2797,
                    2704,
                    2771,
                    2772,
                    2810,
                    2812,
                    2813,
                    2719
                ],
                "self._convert_can_do_setop": [
                    2704,
                    2770
                ],
                "self._get_unique_index": [
                    2706,
                    2774
                ],
                "this.get_indexer": [
                    2776,
                    2708,
                    2949
                ],
                "label_diff": [
                    2712,
                    2711
                ],
                "np.setdiff1d": [
                    2780,
                    2711
                ],
                "np.arange": [
                    4490,
                    3436,
                    3437,
                    3759,
                    2711,
                    3448,
                    3420,
                    2781
                ],
                "this.size": [
                    2781,
                    2711
                ],
                "the_diff": [
                    2789,
                    2792,
                    2800,
                    2712,
                    2715,
                    2719
                ],
                "this.values.take": [
                    2712,
                    2783
                ],
                "this.values": [
                    2712,
                    2783
                ],
                "this._shallow_copy": [
                    2719
                ],
                "result_name_update": [
                    2770,
                    2772
                ],
                "other._get_unique_index": [
                    2775
                ],
                "common_indexer": [
                    2779,
                    2781
                ],
                "left_indexer": [
                    3738,
                    3741,
                    3742,
                    3759,
                    3763,
                    3768,
                    3773,
                    3774,
                    3782,
                    3783,
                    3788,
                    2780,
                    3805,
                    3038,
                    2783,
                    3808,
                    3809,
                    3042,
                    3814,
                    3048
                ],
                "left_diff": [
                    2789,
                    2783
                ],
                "right_indexer": [
                    2786,
                    2787,
                    3043,
                    3811,
                    3812,
                    3047,
                    3814,
                    3049,
                    3798,
                    3802,
                    3805,
                    3039
                ],
                "right_diff": [
                    2787,
                    2789
                ],
                "other.values.take": [
                    2787
                ],
                "other.values": [
                    2787
                ],
                "attribs": [
                    2796,
                    2797,
                    2798,
                    2799,
                    2800
                ],
                "self._shallow_copy_with_infer": [
                    2800,
                    5273,
                    3451,
                    4024
                ],
                "method": [
                    2950,
                    2958,
                    2959,
                    2960,
                    3367,
                    2987,
                    2860,
                    2989,
                    2992,
                    2994,
                    3379,
                    2870,
                    3382,
                    3009,
                    3012,
                    5726,
                    5727,
                    2929,
                    2943
                ],
                "tolerance": [
                    2980,
                    2981,
                    2950,
                    2983,
                    3051,
                    3052,
                    2861,
                    2959,
                    2961,
                    3057,
                    2931,
                    2932,
                    2963,
                    2870,
                    2995,
                    2997,
                    3379,
                    2943
                ],
                "self._engine.get_loc": [
                    2867,
                    2869
                ],
                "key": [
                    3079,
                    3088,
                    3090,
                    5010,
                    3092,
                    4245,
                    4246,
                    4247,
                    5012,
                    4249,
                    5013,
                    5014,
                    4252,
                    5017,
                    4254,
                    4255,
                    3105,
                    4257,
                    3107,
                    4258,
                    3109,
                    5026,
                    3111,
                    5028,
                    5031,
                    5032,
                    2867,
                    2869,
                    2870,
                    2875,
                    3132,
                    3133,
                    3138,
                    3139,
                    3140,
                    4674,
                    3144,
                    4682,
                    4687,
                    4688,
                    4691,
                    3161,
                    3162,
                    3163,
                    4701,
                    4706,
                    4707,
                    4197,
                    4199,
                    4714,
                    4715,
                    4716,
                    3182,
                    3311,
                    3184,
                    4727,
                    3193,
                    4221
                ],
                "self._maybe_cast_indexer": [
                    2869
                ],
                "indexer.ndim": [
                    2871
                ],
                "indexer.size": [
                    2871
                ],
                "loc": [
                    4450,
                    5253,
                    4454,
                    4455,
                    4456,
                    5272,
                    2873,
                    2874,
                    2876
                ],
                "indexer.item": [
                    2873
                ],
                "missing.clean_reindex_fill_method": [
                    2929
                ],
                "missing": [
                    4766,
                    4767,
                    2929,
                    3387,
                    3414,
                    3419,
                    3422,
                    3423
                ],
                "target": [
                    2946,
                    2948,
                    2950,
                    2959,
                    2961,
                    4754,
                    4755,
                    4756,
                    4757,
                    4758,
                    3353,
                    4762,
                    3356,
                    4764,
                    2974,
                    3358,
                    3362,
                    3364,
                    2981,
                    2986,
                    3370,
                    3373,
                    4782,
                    4783,
                    2992,
                    2994,
                    3379,
                    2997,
                    3387,
                    3389,
                    3390,
                    3391,
                    3393,
                    3015,
                    3017,
                    3413,
                    3414,
                    3038,
                    3039,
                    3423,
                    3041,
                    3042,
                    3043,
                    3433,
                    3052,
                    3056,
                    2930,
                    2932,
                    2937,
                    2938,
                    2940,
                    2941
                ],
                "self._convert_tolerance": [
                    2932
                ],
                "target.is_boolean": [
                    2937
                ],
                "self.is_numeric": [
                    2937
                ],
                "np.repeat": [
                    3506,
                    2938,
                    3514
                ],
                "target.size": [
                    2938,
                    2981
                ],
                "pself": [
                    4757,
                    4758,
                    4759,
                    2940,
                    2941,
                    2942
                ],
                "ptarget": [
                    4757,
                    4758,
                    4759,
                    2940,
                    2941,
                    2943
                ],
                "self._maybe_promote": [
                    2940,
                    4757
                ],
                "pself.get_indexer": [
                    2942
                ],
                "limit": [
                    2950,
                    2959,
                    2992,
                    2961,
                    2994,
                    3379,
                    3038,
                    3382,
                    2968,
                    3039,
                    3006,
                    2943
                ],
                "target.dtype": [
                    2946,
                    4756
                ],
                "target.astype": [
                    4756,
                    2948
                ],
                "InvalidIndexError": [
                    2954,
                    4707,
                    4716
                ],
                "self._get_fill_indexer": [
                    2959
                ],
                "self._get_nearest_indexer": [
                    2961
                ],
                "self._engine.get_indexer": [
                    2974
                ],
                "target._ndarray_values": [
                    2992,
                    4764,
                    2997,
                    2974
                ],
                "tolerance.size": [
                    2981
                ],
                "target.is_monotonic_increasing": [
                    2986
                ],
                "self._engine.get_pad_indexer": [
                    2988
                ],
                "self._engine.get_backfill_indexer": [
                    2990
                ],
                "self._get_fill_indexer_searchsorted": [
                    2994
                ],
                "self._filter_indexer_tolerance": [
                    2996,
                    3052
                ],
                "side": [
                    5120,
                    3012,
                    5127,
                    3017,
                    3018,
                    5078,
                    5110,
                    5142,
                    5113,
                    5146,
                    5084,
                    5151
                ],
                "nonexact": [
                    3016,
                    3017,
                    3023
                ],
                "self._searchsorted_monotonic": [
                    3017,
                    5127
                ],
                "left_distances": [
                    3042,
                    3047
                ],
                "abs": [
                    3056,
                    3042,
                    3043
                ],
                "right_distances": [
                    3043,
                    3047
                ],
                "operator.lt": [
                    5314,
                    3045
                ],
                "operator": [
                    5312,
                    5313,
                    5314,
                    5315,
                    5316,
                    3045,
                    5317,
                    5417,
                    5419,
                    5452,
                    5453,
                    5422,
                    5424,
                    5428,
                    5429,
                    5432
                ],
                "operator.le": [
                    5316,
                    3045
                ],
                "np.where": [
                    3299,
                    3046,
                    4488,
                    4017,
                    3057
                ],
                "distance": [
                    3056,
                    3057
                ],
                "kind": [
                    5120,
                    4994,
                    3076,
                    3078,
                    3079,
                    3088,
                    3218,
                    3092,
                    5024,
                    3107,
                    5030,
                    3129,
                    3136,
                    4161,
                    3138,
                    3139,
                    3140,
                    5059,
                    5066,
                    3279,
                    3154,
                    5208,
                    3161,
                    3162,
                    3163,
                    5214,
                    3187,
                    5108
                ],
                "self._validate_indexer": [
                    3138,
                    3139,
                    3140,
                    3079,
                    3161,
                    3162,
                    3163
                ],
                "is_float": [
                    5065,
                    3088,
                    5010,
                    3092,
                    5407
                ],
                "self.is_floating": [
                    3089,
                    5010,
                    5066,
                    3281
                ],
                "self._invalid_indexer": [
                    3105,
                    3109,
                    5031,
                    5067,
                    5072,
                    3090
                ],
                "is_integer": [
                    3107,
                    5028,
                    3148,
                    5071,
                    4687,
                    5407
                ],
                "self.holds_integer": [
                    4697,
                    5066,
                    3108,
                    4685
                ],
                "slice": [
                    3137,
                    4454,
                    5002,
                    3160,
                    4249,
                    3132,
                    5145
                ],
                "key.start": [
                    3144,
                    3161,
                    3138
                ],
                "key.stop": [
                    3144,
                    3162,
                    3139
                ],
                "key.step": [
                    3144,
                    3163,
                    3140
                ],
                "start": [
                    4994,
                    3172,
                    3173,
                    3144,
                    5192,
                    5196,
                    3150,
                    3151,
                    5198,
                    3187,
                    5207,
                    5208
                ],
                "stop": [
                    3174,
                    3175,
                    3144,
                    3150,
                    3151,
                    3187
                ],
                "step": [
                    4994,
                    5188,
                    3144,
                    5002,
                    3187
                ],
                "is_null_slicer": [
                    3181,
                    3150
                ],
                "is_index_slice": [
                    3152,
                    3189,
                    3159,
                    3151
                ],
                "is_int": [
                    3151
                ],
                "is_positional": [
                    3152,
                    3170,
                    3176,
                    3183
                ],
                "self.is_integer": [
                    3152,
                    3190,
                    3159
                ],
                "self.is_mixed": [
                    3170
                ],
                "self.get_loc": [
                    4450,
                    5124,
                    3173,
                    3175,
                    4682
                ],
                "self.slice_indexer": [
                    3187
                ],
                "keyarr": [
                    3299,
                    3300,
                    3238,
                    3239,
                    3213,
                    3214,
                    3216,
                    3280,
                    3218,
                    3219,
                    3282,
                    3286,
                    3258
                ],
                "self._convert_index_indexer": [
                    3214
                ],
                "self._convert_arr_indexer": [
                    3216
                ],
                "self._convert_list_indexer": [
                    3218
                ],
                "maybe_convert_indices": [
                    3296
                ],
                "form": [
                    5031,
                    3311
                ],
                "preserve_names": [
                    3353,
                    3389
                ],
                "_ensure_has_len": [
                    3356
                ],
                "attrs.pop": [
                    3360
                ],
                "_": [
                    3369,
                    3701,
                    4783
                ],
                "self._join_level": [
                    3369,
                    3497,
                    3647
                ],
                "self.get_indexer_non_unique": [
                    3387,
                    3414,
                    4783
                ],
                "target.nlevels": [
                    3389
                ],
                "target.name": [
                    3389,
                    3391
                ],
                "target.copy": [
                    3390
                ],
                "check": [
                    3424,
                    3425,
                    3426,
                    3445,
                    3415,
                    3416,
                    3449
                ],
                "new_labels": [
                    3428,
                    3429,
                    3430,
                    3416,
                    3451
                ],
                "self.take": [
                    4544,
                    3425,
                    3448,
                    4820,
                    3416
                ],
                "new_indexer": [
                    3449,
                    3436,
                    3437,
                    3438,
                    3448,
                    3417,
                    3452
                ],
                "length": [
                    3424,
                    3426,
                    3420
                ],
                "missing_labels": [
                    3430,
                    3423
                ],
                "target.take": [
                    3423
                ],
                "missing_indexer": [
                    3424,
                    3438,
                    3430
                ],
                "ensure_int64": [
                    3424,
                    3712,
                    3426,
                    3745,
                    3700,
                    3711
                ],
                "cur_labels": [
                    3425,
                    3437,
                    3429
                ],
                "cur_indexer": [
                    3426,
                    3437,
                    3429
                ],
                "target.is_unique": [
                    3433
                ],
                "self_is_mi": [
                    3496,
                    3599,
                    3602,
                    3640,
                    3482,
                    3487
                ],
                "other_is_mi": [
                    3496,
                    3600,
                    3602,
                    3483,
                    3487
                ],
                "other.names": [
                    3592,
                    3490,
                    3646
                ],
                "self._join_multi": [
                    3493
                ],
                "return_indexers": [
                    3552,
                    3648,
                    3522,
                    3524,
                    3493,
                    3498,
                    3532,
                    3821,
                    3856,
                    3505,
                    3538,
                    3573,
                    3543,
                    3672,
                    3513,
                    3547,
                    3807
                ],
                "join_index": [
                    3584,
                    3840,
                    3841,
                    3843,
                    3844,
                    3847,
                    3849,
                    3851,
                    3853,
                    3854,
                    3859,
                    3861,
                    3739,
                    3742,
                    3504,
                    3506,
                    3507,
                    3509,
                    3512,
                    3514,
                    3515,
                    3517,
                    3790,
                    3666,
                    3668,
                    3670,
                    3799,
                    3673,
                    3802,
                    3675,
                    3558,
                    3814,
                    3560,
                    3816,
                    3564,
                    3568,
                    3571,
                    3574,
                    3832,
                    3577,
                    3578,
                    3836,
                    3581,
                    3582
                ],
                "rindexer": [
                    3506,
                    3507,
                    3579,
                    3581,
                    3582
                ],
                "other._shallow_copy": [
                    3512
                ],
                "lindexer": [
                    3575,
                    3577,
                    3514,
                    3515,
                    3582
                ],
                "self._join_precedence": [
                    3519
                ],
                "other._join_precedence": [
                    3519
                ],
                "get": [
                    3520,
                    3722,
                    3644
                ],
                "other.join": [
                    3521
                ],
                "y": [
                    3525,
                    3526
                ],
                "z": [
                    3525,
                    3526
                ],
                "this.join": [
                    3532
                ],
                "_validate_join_method": [
                    3534
                ],
                "other.is_unique": [
                    3536,
                    3540,
                    3829
                ],
                "self._join_non_unique": [
                    3537,
                    3546
                ],
                "self._join_monotonic": [
                    3542,
                    3551
                ],
                "join_index.sort_values": [
                    3571
                ],
                "other.get_indexer": [
                    3581
                ],
                "self_names": [
                    3593,
                    3605,
                    3591
                ],
                "com.not_none": [
                    3592,
                    3591
                ],
                "other_names": [
                    3592,
                    3593,
                    3606
                ],
                "overlap": [
                    3593,
                    3596,
                    3635,
                    3605,
                    3606
                ],
                "ldrop_names": [
                    3608,
                    3620,
                    3605
                ],
                "rdrop_names": [
                    3609,
                    3620,
                    3606
                ],
                "self_jnlevels": [
                    3608,
                    3613
                ],
                "self.droplevel": [
                    3608
                ],
                "other_jnlevels": [
                    3609,
                    3614
                ],
                "other.droplevel": [
                    3609
                ],
                "join_idx": [
                    3613,
                    3623
                ],
                "lidx": [
                    3840,
                    3843,
                    3623,
                    3847,
                    3837,
                    3849,
                    3851,
                    3853,
                    3633,
                    3857,
                    3859,
                    3833,
                    3613
                ],
                "ridx": [
                    3840,
                    3843,
                    3623,
                    3847,
                    3849,
                    3851,
                    3853,
                    3633,
                    3858,
                    3859,
                    3834,
                    3613,
                    3838
                ],
                "self_jnlevels.join": [
                    3613
                ],
                "dropped_names": [
                    3620,
                    3623
                ],
                "levels": [
                    3628,
                    3622
                ],
                "codes": [
                    3628,
                    3622
                ],
                "_restore_dropped_levels_multijoin": [
                    3622
                ],
                "multi_join_idx": [
                    3633,
                    3627,
                    3631
                ],
                "multi_join_idx.remove_unused_levels": [
                    3631
                ],
                "jl": [
                    3635,
                    3646
                ],
                "flip_order": [
                    3651,
                    3719,
                    3720,
                    3639,
                    3642,
                    3804
                ],
                "other.names.index": [
                    3646
                ],
                "left_idx": [
                    3659,
                    3663,
                    3666,
                    3667,
                    3673
                ],
                "right_idx": [
                    3664,
                    3673,
                    3659,
                    3668
                ],
                "_get_join_indexers": [
                    3659
                ],
                "self._ndarray_values.take": [
                    3666
                ],
                "np.putmask": [
                    3668,
                    4335
                ],
                "other._ndarray_values.take": [
                    3668
                ],
                "self._wrap_joined_index": [
                    3841,
                    3844,
                    3670,
                    3854
                ],
                "size": [
                    3696
                ],
                "labels": [
                    5295,
                    3696,
                    5296,
                    3699,
                    3700,
                    5300,
                    3706,
                    3707,
                    3711
                ],
                "lab": [
                    3712,
                    3780,
                    3783,
                    3762,
                    3700,
                    3701,
                    3707,
                    3708,
                    3774,
                    3711
                ],
                "sorter": [
                    3701,
                    3702
                ],
                "libalgos.groupsort_indexer": [
                    3768,
                    3701
                ],
                "libalgos": [
                    3768,
                    3701
                ],
                "lab.max": [
                    3701
                ],
                "tic": [
                    3706,
                    3708,
                    3710
                ],
                "starts": [
                    3712,
                    3710
                ],
                "np.hstack": [
                    3710
                ],
                "lib.get_level_sorter": [
                    3712
                ],
                "left._get_level_number": [
                    3724
                ],
                "old_level": [
                    3746,
                    3732,
                    3725
                ],
                "left.levels": [
                    3755,
                    3725
                ],
                "right.is_unique": [
                    3727
                ],
                "new_level": [
                    3756,
                    3732
                ],
                "left_lev_indexer": [
                    3736,
                    3745,
                    3746,
                    3732
                ],
                "right_lev_indexer": [
                    3732,
                    3797,
                    3799
                ],
                "old_level.join": [
                    3732
                ],
                "keep_order": [
                    3737,
                    3758
                ],
                "_get_leaf_sorter": [
                    3741,
                    3782
                ],
                "left.codes": [
                    3752,
                    3741,
                    3749
                ],
                "rev_indexer": [
                    3746,
                    3749
                ],
                "lib.get_reverse_indexer": [
                    3746
                ],
                "new_lev_codes": [
                    3777,
                    3748,
                    3753,
                    3760,
                    3767,
                    3769
                ],
                "np.intp": [
                    3759
                ],
                "mask.all": [
                    3761,
                    3778
                ],
                "ngroups": [
                    3769,
                    3767
                ],
                "new_lev_codes.max": [
                    3767
                ],
                "counts": [
                    3768,
                    3773
                ],
                "mask_all": [
                    3778,
                    3779,
                    3787
                ],
                "mask.nonzero": [
                    3788
                ],
                "left.names": [
                    3793
                ],
                "join_index.codes": [
                    3802,
                    3799
                ],
                "ret_index": [
                    3824,
                    3820,
                    3822
                ],
                "sv": [
                    3840,
                    3843,
                    3847,
                    3849,
                    3851,
                    3853,
                    3826,
                    3834,
                    3837
                ],
                "ov": [
                    3840,
                    3843,
                    3847,
                    3849,
                    3851,
                    3853,
                    3827,
                    3834,
                    3837
                ],
                "self._left_indexer_unique": [
                    3834,
                    3837
                ],
                "self._left_indexer": [
                    3849,
                    3847
                ],
                "joined": [
                    3865
                ],
                "Union": [
                    3893
                ],
                "ExtensionArray": [
                    4674,
                    3893
                ],
                "self._internal_get_values": [
                    3973
                ],
                "memory_usage": [
                    3980
                ],
                "self._engine.sizeof": [
                    3983
                ],
                "IndexOpsMixin.memory_usage.__doc__": [
                    3978
                ],
                "IndexOpsMixin.memory_usage": [
                    3978
                ],
                "is_bool": [
                    4011
                ],
                "values.astype": [
                    4014
                ],
                "cond": [
                    4017
                ],
                "self._is_numeric_dtype": [
                    5379,
                    5361,
                    4019,
                    4119
                ],
                "np.any": [
                    4019,
                    5571
                ],
                "OverflowError": [
                    4200,
                    4057,
                    4066,
                    5015
                ],
                "cls.__name__": [
                    4075
                ],
                "repr": [
                    4075
                ],
                "item": [
                    5271,
                    4124,
                    5272,
                    4119
                ],
                "hash": [
                    4197
                ],
                "getitem": [
                    4258,
                    4242,
                    4252,
                    4247
                ],
                "self._data.__getitem__": [
                    4242
                ],
                "promote": [
                    4260,
                    4243,
                    4252
                ],
                "com.cast_scalar_indexer": [
                    4246
                ],
                "com.is_bool_indexer": [
                    4254
                ],
                "com.values_from_object": [
                    4257,
                    4366,
                    4690,
                    4691,
                    5397,
                    4727
                ],
                "self.is_categorical": [
                    4273
                ],
                "to_concat": [
                    4290,
                    4293,
                    4295,
                    4297,
                    4301,
                    4304,
                    4308,
                    4311,
                    4312,
                    4319
                ],
                "to_concat.append": [
                    4295
                ],
                "obj": [
                    4297,
                    4298,
                    4301
                ],
                "obj.name": [
                    4301
                ],
                "self._concat": [
                    4304
                ],
                "typs": [
                    4308,
                    4310
                ],
                "_concat.get_dtype_kinds": [
                    4308
                ],
                "_concat": [
                    4312,
                    4308,
                    4319
                ],
                "self._concat_same_dtype": [
                    4311
                ],
                "_concat._concat_index_asobject": [
                    4312,
                    4319
                ],
                "self._convert_for_op": [
                    4335
                ],
                "err": [
                    5130,
                    4339
                ],
                "putmask": [
                    4342
                ],
                "self.is_": [
                    4354
                ],
                "other.equals": [
                    4362
                ],
                "array_equivalent": [
                    4365
                ],
                "c": [
                    4386,
                    4387
                ],
                "self._comparables": [
                    4387
                ],
                "label": [
                    5120,
                    4450,
                    5124,
                    5127,
                    5065,
                    5067,
                    5116,
                    5071,
                    5072,
                    5074,
                    5078,
                    5084
                ],
                "loc.indices": [
                    4455
                ],
                "locs": [
                    4488,
                    4490,
                    4493,
                    4487
                ],
                "searchsorted": [
                    5083,
                    4487
                ],
                "where.values": [
                    4493,
                    4487
                ],
                "where": [
                    4493,
                    4487
                ],
                "first": [
                    4492,
                    4493
                ],
                "mask.argmax": [
                    4492
                ],
                "_as": [
                    4544,
                    4547,
                    4540,
                    4542
                ],
                "self.argsort": [
                    4540
                ],
                "sorted_index": [
                    4544,
                    4547,
                    4549
                ],
                "return_indexer": [
                    4546
                ],
                "self.asi8": [
                    4650
                ],
                "result.argsort": [
                    4653
                ],
                "args": [
                    4653
                ],
                "s": [
                    4673,
                    4674,
                    4683,
                    4688,
                    4690,
                    4695,
                    4701
                ],
                "series": [
                    4673,
                    4690,
                    4695
                ],
                "iloc": [
                    4682,
                    4683
                ],
                "self.is_boolean": [
                    4697,
                    4685
                ],
                "self._convert_scalar_indexer": [
                    4693
                ],
                "self._engine.get_value": [
                    4695
                ],
                "series.dtype": [
                    4695
                ],
                "libindex.get_value_box": [
                    4701
                ],
                "e1": [
                    4709,
                    4711
                ],
                "self._engine.set_value": [
                    4726
                ],
                "arr": [
                    4727
                ],
                "is_categorical": [
                    4755
                ],
                "target.dtype.categories.dtype": [
                    4756
                ],
                "target.dtype.categories": [
                    4756
                ],
                "pself.get_indexer_non_unique": [
                    4759
                ],
                "self.is_all_dates": [
                    4761
                ],
                "tgt_values": [
                    4762,
                    4764,
                    4766
                ],
                "target.asi8": [
                    4762
                ],
                "self._engine.get_indexer_non_unique": [
                    4766
                ],
                "values.values": [
                    4815
                ],
                "ensure_categorical": [
                    4816
                ],
                "values._reverse_indexer": [
                    4817
                ],
                "result.items": [
                    4820
                ],
                "new_values": [
                    4865,
                    4846,
                    4851,
                    4855,
                    4858,
                    4861
                ],
                "_map_values": [
                    4846
                ],
                "na_action": [
                    4846
                ],
                "new_values.size": [
                    4851,
                    4861
                ],
                "attributes.get": [
                    4854,
                    4855
                ],
                "algos.isin": [
                    4948
                ],
                "start_slice": [
                    5241,
                    4994,
                    4997,
                    5002,
                    5233,
                    5206,
                    5208,
                    5209,
                    5210,
                    5243,
                    5240
                ],
                "end_slice": [
                    5216,
                    4994,
                    4999,
                    5002,
                    5233,
                    5238,
                    5239,
                    5243,
                    5212,
                    5214,
                    5215
                ],
                "self.slice_locs": [
                    4994
                ],
                "end": [
                    4994,
                    5192,
                    5196,
                    5199,
                    5213,
                    5214
                ],
                "AssertionError": [
                    5000,
                    4998
                ],
                "ckey": [
                    5012,
                    5013,
                    5014
                ],
                "self.searchsorted": [
                    5078
                ],
                "pos": [
                    5083,
                    5086
                ],
                "original_label": [
                    5116,
                    5142
                ],
                "self._maybe_cast_slice_bound": [
                    5120
                ],
                "slc": [
                    5152,
                    5154,
                    5124,
                    5132,
                    5135,
                    5136,
                    5138,
                    5139,
                    5145,
                    5147,
                    5149
                ],
                "lib.maybe_booleans_to_slice": [
                    5136
                ],
                "slc.view": [
                    5136
                ],
                "lib.maybe_indices_to_slice": [
                    5138
                ],
                "slc.astype": [
                    5138
                ],
                "slc.start": [
                    5147
                ],
                "slc.stop": [
                    5149
                ],
                "inc": [
                    5218,
                    5188,
                    5190
                ],
                "datetime": [
                    5403,
                    5196
                ],
                "ts_start": [
                    5203,
                    5198
                ],
                "Timestamp": [
                    5198,
                    5199
                ],
                "ts_end": [
                    5203,
                    5199
                ],
                "tz_compare": [
                    5203
                ],
                "ts_start.tzinfo": [
                    5203
                ],
                "ts_end.tzinfo": [
                    5203
                ],
                "self.get_slice_bound": [
                    5208,
                    5214
                ],
                "np.delete": [
                    5253
                ],
                "_self": [
                    5272,
                    5270
                ],
                "self._coerce_scalar_to_index": [
                    5271
                ],
                "np.concatenate": [
                    5272
                ],
                "arr_dtype": [
                    5294,
                    5295
                ],
                "com.index_labels_to_array": [
                    5295
                ],
                "errors": [
                    5299
                ],
                "self.delete": [
                    5302
                ],
                "cls.__eq__": [
                    5312
                ],
                "_make_comparison_op": [
                    5312,
                    5313,
                    5314,
                    5315,
                    5316,
                    5317
                ],
                "operator.eq": [
                    5312
                ],
                "cls.__ne__": [
                    5313
                ],
                "operator.ne": [
                    5313
                ],
                "cls.__lt__": [
                    5314
                ],
                "cls.__gt__": [
                    5315
                ],
                "operator.gt": [
                    5315
                ],
                "cls.__le__": [
                    5316
                ],
                "cls.__ge__": [
                    5317
                ],
                "operator.ge": [
                    5317
                ],
                "cls.__add__": [
                    5417,
                    5324
                ],
                "make_invalid_op": [
                    5579,
                    5324,
                    5325,
                    5326,
                    5327,
                    5328,
                    5329,
                    5580,
                    5336,
                    5337,
                    5338,
                    5339,
                    5340,
                    5341,
                    5342,
                    5343,
                    5344,
                    5345,
                    5346,
                    5347,
                    5348,
                    5349
                ],
                "cls.__radd__": [
                    5418,
                    5325
                ],
                "cls.__iadd__": [
                    5326
                ],
                "cls.__sub__": [
                    5419,
                    5327
                ],
                "cls.__rsub__": [
                    5328,
                    5420
                ],
                "cls.__isub__": [
                    5329
                ],
                "cls.__pow__": [
                    5336,
                    5422
                ],
                "cls.__rpow__": [
                    5337,
                    5421
                ],
                "cls.__mul__": [
                    5432,
                    5338
                ],
                "cls.__rmul__": [
                    5433,
                    5339
                ],
                "cls.__floordiv__": [
                    5340,
                    5429
                ],
                "cls.__rfloordiv__": [
                    5341,
                    5430
                ],
                "cls.__truediv__": [
                    5424,
                    5342
                ],
                "cls.__rtruediv__": [
                    5425,
                    5343
                ],
                "cls.__mod__": [
                    5344,
                    5428
                ],
                "cls.__divmod__": [
                    5345,
                    5431
                ],
                "cls.__neg__": [
                    5346,
                    5452
                ],
                "cls.__pos__": [
                    5347,
                    5453
                ],
                "cls.__abs__": [
                    5348,
                    5454
                ],
                "cls.__inv__": [
                    5349,
                    5455
                ],
                "opstr": [
                    5376,
                    5444,
                    5382,
                    5449,
                    5389,
                    5364
                ],
                "other._is_numeric_dtype": [
                    5386
                ],
                "other.item": [
                    5392
                ],
                "other.dtype.kind": [
                    5398
                ],
                "ABCDateOffset": [
                    5400
                ],
                "np.timedelta64": [
                    5400
                ],
                "timedelta": [
                    5400
                ],
                "np.datetime64": [
                    5403
                ],
                "_make_arithmetic_op": [
                    5417,
                    5418,
                    5419,
                    5420,
                    5421,
                    5422,
                    5424,
                    5425,
                    5428,
                    5429,
                    5430,
                    5431,
                    5432,
                    5433
                ],
                "operator.add": [
                    5417
                ],
                "ops.radd": [
                    5418
                ],
                "operator.sub": [
                    5419
                ],
                "ops.rsub": [
                    5420
                ],
                "ops.rpow": [
                    5421
                ],
                "operator.pow": [
                    5422
                ],
                "operator.truediv": [
                    5424
                ],
                "ops.rtruediv": [
                    5425
                ],
                "operator.mod": [
                    5428
                ],
                "operator.floordiv": [
                    5429
                ],
                "ops.rfloordiv": [
                    5430
                ],
                "divmod": [
                    5431
                ],
                "operator.mul": [
                    5432
                ],
                "ops.rmul": [
                    5433
                ],
                "self._validate_for_numeric_unaryop": [
                    5444
                ],
                "_evaluate_numeric_unary.__name__": [
                    5449
                ],
                "_evaluate_numeric_unary": [
                    5449,
                    5450
                ],
                "_make_evaluate_unary": [
                    5452,
                    5453,
                    5454,
                    5455
                ],
                "operator.neg": [
                    5452
                ],
                "operator.pos": [
                    5453
                ],
                "np.abs": [
                    5454
                ],
                "cls._add_numeric_methods_unary": [
                    5459
                ],
                "cls._add_numeric_methods_binary": [
                    5460
                ],
                "_doc": [
                    5552,
                    5467
                ],
                "dedent": [
                    5482,
                    5524
                ],
                "f": [
                    5554
                ],
                "result.ndim": [
                    5557
                ],
                "result.dtype.type": [
                    5560
                ],
                "result.dtype": [
                    5560
                ],
                "result.item": [
                    5560
                ],
                "Substitution": [
                    5550
                ],
                "desc": [
                    5550
                ],
                "logical_func.__name__": [
                    5564
                ],
                "logical_func": [
                    5564,
                    5565
                ],
                "cls.all": [
                    5579,
                    5567
                ],
                "_make_logical_function": [
                    5570,
                    5567
                ],
                "np.all": [
                    5568
                ],
                "cls.any": [
                    5570,
                    5580
                ],
                "Index._add_numeric_methods_disabled": [
                    5590
                ],
                "Index._add_logical_methods": [
                    5591
                ],
                "Index._add_comparison_methods": [
                    5592
                ],
                "sequences": [
                    5633,
                    5628,
                    5631
                ],
                "MultiIndex.from_arrays": [
                    5633,
                    5689
                ],
                "index_like": [
                    5698,
                    5668,
                    5700,
                    5670,
                    5671,
                    5672,
                    5673,
                    5675,
                    5676,
                    5680,
                    5681,
                    5682,
                    5684,
                    5691
                ],
                "index_like.copy": [
                    5670
                ],
                "index_like.name": [
                    5673
                ],
                "converted": [
                    5689,
                    5691,
                    5684,
                    5686
                ],
                "all_arrays": [
                    5684,
                    5686
                ],
                "lib.clean_index_list": [
                    5684
                ],
                "seq": [
                    5712,
                    5708,
                    5710
                ],
                "trimmed": [
                    5720,
                    5721,
                    5722,
                    5719
                ],
                "strings": [
                    5720,
                    5719
                ],
                "n": [
                    5733
                ]
            },
            "filtered_variables_in_file": {
                "__all__": [
                    83
                ],
                "_unsortable_types": [
                    85
                ],
                "_index_doc_kwargs": [
                    4195,
                    937,
                    2123,
                    2927,
                    4752,
                    87,
                    855,
                    4667
                ],
                "_index_shared_docs": [
                    768,
                    3457,
                    898,
                    2818,
                    3074,
                    2565,
                    2061,
                    4752,
                    1682,
                    3986,
                    5524,
                    3221,
                    2072,
                    793,
                    3480,
                    4003,
                    3236,
                    2088,
                    937,
                    2858,
                    2603,
                    3113,
                    3241,
                    5034,
                    4655,
                    5551,
                    946,
                    2100,
                    3127,
                    3256,
                    827,
                    3260,
                    4667,
                    2878,
                    5057,
                    4163,
                    968,
                    2123,
                    3276,
                    595,
                    855,
                    95,
                    610,
                    4195,
                    5482,
                    2927,
                    3063,
                    2041,
                    4730,
                    1660
                ],
                "other": [
                    2560,
                    2563,
                    3592,
                    3600,
                    3609,
                    3623,
                    2606,
                    2607,
                    2609,
                    2610,
                    2612,
                    2614,
                    2615,
                    3641,
                    2622,
                    2623,
                    3646,
                    2625,
                    3648,
                    2627,
                    2630,
                    3660,
                    2642,
                    3668,
                    2646,
                    3670,
                    2652,
                    100,
                    101,
                    107,
                    111,
                    129,
                    3714,
                    3717,
                    134,
                    2698,
                    2700,
                    2704,
                    2708,
                    674,
                    4790,
                    4791,
                    4794,
                    4795,
                    4292,
                    4293,
                    4295,
                    2769,
                    2770,
                    2775,
                    2776,
                    2787,
                    3819,
                    3820,
                    2803,
                    3827,
                    3829,
                    2808,
                    2809,
                    2812,
                    2813,
                    3836,
                    3841,
                    4354,
                    3844,
                    4357,
                    4360,
                    5385,
                    4362,
                    5386,
                    5389,
                    3854,
                    4366,
                    5391,
                    5392,
                    5394,
                    5395,
                    5397,
                    5398,
                    3864,
                    5400,
                    2330,
                    5403,
                    2334,
                    4383,
                    5407,
                    4386,
                    2339,
                    5410,
                    4390,
                    2343,
                    2346,
                    2349,
                    2352,
                    2355,
                    2358,
                    2379,
                    2405,
                    2406,
                    2422,
                    3483,
                    3490,
                    3493,
                    4005,
                    4006,
                    3498,
                    4011,
                    3501,
                    3503,
                    4017,
                    2484,
                    2486,
                    2487,
                    3512,
                    2489,
                    3519,
                    3521,
                    3529,
                    3531,
                    3532,
                    2511,
                    2512,
                    3536,
                    3538,
                    2515,
                    3540,
                    3541,
                    3543,
                    2522,
                    2523,
                    3547,
                    2525,
                    3549,
                    2527,
                    3552,
                    3560,
                    2538,
                    3564,
                    3568,
                    3578,
                    3581
                ],
                "np.ndarray": [
                    1888,
                    4099,
                    100,
                    364,
                    5132,
                    5391,
                    3890,
                    5139,
                    5394,
                    3893,
                    5556,
                    1883
                ],
                "np": [
                    1922,
                    4099,
                    5253,
                    4488,
                    4106,
                    4490,
                    5132,
                    5391,
                    5394,
                    5139,
                    148,
                    1912,
                    5270,
                    2711,
                    5272,
                    409,
                    5400,
                    5403,
                    4255,
                    2980,
                    808,
                    2346,
                    555,
                    811,
                    557,
                    2349,
                    3759,
                    4652,
                    4017,
                    434,
                    3506,
                    3890,
                    3893,
                    4019,
                    567,
                    4335,
                    5556,
                    3514,
                    1086,
                    5568,
                    705,
                    5571,
                    3448,
                    1097,
                    5454,
                    3666,
                    3668,
                    1882,
                    1883,
                    2780,
                    2781,
                    3420,
                    351,
                    1887,
                    1888,
                    3041,
                    3299,
                    100,
                    3428,
                    3046,
                    106,
                    364,
                    493,
                    110,
                    111,
                    876,
                    1646,
                    1900,
                    3057,
                    3436,
                    3437,
                    1142,
                    3697,
                    1144,
                    2938,
                    3710
                ],
                "Index": [
                    512,
                    4865,
                    4099,
                    4357,
                    136,
                    137,
                    5385,
                    651,
                    3213,
                    5394,
                    2069,
                    3865,
                    4124,
                    2334,
                    3358,
                    2339,
                    5668,
                    5673,
                    2346,
                    811,
                    2349,
                    820,
                    5556,
                    4674,
                    452,
                    5700,
                    5447,
                    4298,
                    2635,
                    717,
                    2639,
                    5590,
                    5591,
                    5592,
                    100,
                    2405,
                    2406,
                    361,
                    364,
                    493,
                    118,
                    2808,
                    2809,
                    764,
                    5631
                ],
                "ABCSeries": [
                    129,
                    100,
                    4104,
                    364,
                    5394,
                    563,
                    5556,
                    2330
                ],
                "other.ndim": [
                    101,
                    5391
                ],
                "self": [
                    2063,
                    2064,
                    2065,
                    2069,
                    2070,
                    4117,
                    4119,
                    4124,
                    4130,
                    2093,
                    2094,
                    2095,
                    4155,
                    4161,
                    2126,
                    2128,
                    101,
                    4199,
                    104,
                    107,
                    111,
                    4221,
                    4224,
                    134,
                    4242,
                    4243,
                    4273,
                    4274,
                    4290,
                    4302,
                    4304,
                    4311,
                    4333,
                    4335,
                    4336,
                    4338,
                    2294,
                    4342,
                    4354,
                    2309,
                    2310,
                    2312,
                    4360,
                    2314,
                    2315,
                    4362,
                    4366,
                    2319,
                    2324,
                    2334,
                    4383,
                    4386,
                    2339,
                    4387,
                    4390,
                    2343,
                    2346,
                    2349,
                    2352,
                    2355,
                    2358,
                    2364,
                    2379,
                    2380,
                    2381,
                    2382,
                    4450,
                    2403,
                    4452,
                    4455,
                    4456,
                    2422,
                    4487,
                    4490,
                    4493,
                    2483,
                    2484,
                    2486,
                    2487,
                    2489,
                    4540,
                    4544,
                    2511,
                    2512,
                    2514,
                    2515,
                    2518,
                    2519,
                    2521,
                    2527,
                    2529,
                    2538,
                    2560,
                    2563,
                    4613,
                    4650,
                    4652,
                    2605,
                    2606,
                    2609,
                    2610,
                    2612,
                    2613,
                    2618,
                    2619,
                    2621,
                    2627,
                    2629,
                    2630,
                    584,
                    4682,
                    4685,
                    593,
                    4693,
                    2646,
                    4695,
                    2649,
                    2650,
                    4697,
                    2652,
                    613,
                    614,
                    617,
                    626,
                    4726,
                    641,
                    645,
                    646,
                    648,
                    2697,
                    2698,
                    2700,
                    2702,
                    2704,
                    2706,
                    4757,
                    4758,
                    4761,
                    4766,
                    674,
                    680,
                    681,
                    684,
                    4781,
                    4782,
                    4783,
                    689,
                    4790,
                    4791,
                    4792,
                    4793,
                    4794,
                    699,
                    4795,
                    705,
                    715,
                    716,
                    2768,
                    2769,
                    2770,
                    724,
                    4820,
                    2774,
                    739,
                    2796,
                    2800,
                    4848,
                    754,
                    4852,
                    4853,
                    761,
                    2809,
                    763,
                    2810,
                    765,
                    2812,
                    4863,
                    795,
                    796,
                    801,
                    808,
                    811,
                    818,
                    2867,
                    821,
                    2869,
                    2870,
                    825,
                    4947,
                    4948,
                    860,
                    861,
                    862,
                    866,
                    871,
                    872,
                    873,
                    2932,
                    2937,
                    2940,
                    2941,
                    2946,
                    2947,
                    4994,
                    2953,
                    2959,
                    2961,
                    5010,
                    2974,
                    5031,
                    2986,
                    2988,
                    941,
                    2990,
                    2994,
                    2996,
                    3015,
                    3017,
                    5066,
                    971,
                    5067,
                    973,
                    976,
                    5072,
                    3029,
                    5077,
                    5078,
                    984,
                    5079,
                    5083,
                    3038,
                    3039,
                    5086,
                    3042,
                    995,
                    3043,
                    3045,
                    1004,
                    1005,
                    1006,
                    1007,
                    3052,
                    3056,
                    5120,
                    5124,
                    3079,
                    5127,
                    3081,
                    3089,
                    3090,
                    1043,
                    5138,
                    1045,
                    3097,
                    1050,
                    1057,
                    3105,
                    3108,
                    1061,
                    3109,
                    1070,
                    1071,
                    1076,
                    1078,
                    1081,
                    3138,
                    3139,
                    3140,
                    3152,
                    3159,
                    5208,
                    3161,
                    3162,
                    3163,
                    5214,
                    5216,
                    3170,
                    3173,
                    3175,
                    3178,
                    1131,
                    3187,
                    1140,
                    1141,
                    1142,
                    3190,
                    1144,
                    5239,
                    5241,
                    5253,
                    1162,
                    1163,
                    1166,
                    3214,
                    3216,
                    3218,
                    1174,
                    1175,
                    5270,
                    5271,
                    5273,
                    1188,
                    5294,
                    5296,
                    5302,
                    1211,
                    3281,
                    1234,
                    1236,
                    3285,
                    1238,
                    3286,
                    3294,
                    3296,
                    3298,
                    3299,
                    3311,
                    5361,
                    5364,
                    5379,
                    3332,
                    5382,
                    1295,
                    1296,
                    1299,
                    5395,
                    3359,
                    3361,
                    3362,
                    1315,
                    3369,
                    3373,
                    1326,
                    3377,
                    3378,
                    3387,
                    3389,
                    3391,
                    5444,
                    5445,
                    5446,
                    5447,
                    1354,
                    1356,
                    3414,
                    3416,
                    3425,
                    3448,
                    3451,
                    1417,
                    1424,
                    1433,
                    3482,
                    1435,
                    3490,
                    3493,
                    3497,
                    3504,
                    5554,
                    3511,
                    3519,
                    3522,
                    3529,
                    3530,
                    3536,
                    1489,
                    3537,
                    5587,
                    3540,
                    3541,
                    3542,
                    3546,
                    3549,
                    3551,
                    1505,
                    3558,
                    3564,
                    3568,
                    1525,
                    3574,
                    1528,
                    3577,
                    1533,
                    3591,
                    3599,
                    1553,
                    3608,
                    3623,
                    1592,
                    1593,
                    3641,
                    3647,
                    3660,
                    3666,
                    1619,
                    1622,
                    1623,
                    3670,
                    1627,
                    1631,
                    1632,
                    1633,
                    3714,
                    3717,
                    3719,
                    1686,
                    1688,
                    1700,
                    1717,
                    1734,
                    1751,
                    1768,
                    3819,
                    3820,
                    1778,
                    3826,
                    3829,
                    1782,
                    3832,
                    1785,
                    3834,
                    1788,
                    3837,
                    1791,
                    3840,
                    3841,
                    1794,
                    3843,
                    3844,
                    1797,
                    3847,
                    3849,
                    3851,
                    3853,
                    3854,
                    3864,
                    1833,
                    1836,
                    1839,
                    3890,
                    1845,
                    1852,
                    1856,
                    1858,
                    1864,
                    1865,
                    1866,
                    3920,
                    1874,
                    1876,
                    1884,
                    1890,
                    1891,
                    1908,
                    1909,
                    1912,
                    1918,
                    1919,
                    3973,
                    3976,
                    1929,
                    1930,
                    3983,
                    4006,
                    4008,
                    4009,
                    4019,
                    4024,
                    1989,
                    2037
                ],
                "is_object_dtype": [
                    352,
                    1088,
                    1091,
                    1797,
                    104,
                    4360,
                    299,
                    558,
                    4338,
                    1045,
                    343,
                    4793
                ],
                "ABCMultiIndex": [
                    104,
                    1417,
                    3081,
                    4814,
                    3482,
                    3483
                ],
                "np.errstate": [
                    106,
                    110
                ],
                "result": [
                    2560,
                    2563,
                    2065,
                    2069,
                    4650,
                    4651,
                    4652,
                    4653,
                    569,
                    570,
                    3647,
                    576,
                    577,
                    579,
                    580,
                    3653,
                    2629,
                    2630,
                    1092,
                    1097,
                    1098,
                    1099,
                    3654,
                    3652,
                    1102,
                    1103,
                    2127,
                    2128,
                    107,
                    1644,
                    1646,
                    111,
                    1648,
                    1649,
                    115,
                    116,
                    118,
                    120,
                    134,
                    135,
                    136,
                    137,
                    4258,
                    4259,
                    4260,
                    4262,
                    711,
                    712,
                    713,
                    717,
                    4817,
                    4820,
                    4822,
                    761,
                    763,
                    764,
                    765,
                    766,
                    1296,
                    1299,
                    1300,
                    319,
                    320,
                    322,
                    325,
                    335,
                    336,
                    338,
                    341,
                    346,
                    347,
                    4490,
                    3980,
                    4493,
                    3983,
                    3984,
                    4495,
                    5554,
                    5556,
                    5557,
                    5560,
                    5562,
                    3521,
                    3525,
                    3526,
                    3527,
                    2529,
                    2532,
                    2536,
                    2543,
                    2546,
                    2550
                ],
                "ops._comp_method_OBJECT_ARRAY": [
                    107
                ],
                "ops": [
                    5418,
                    107,
                    5420,
                    5421,
                    5425,
                    5430,
                    5433
                ],
                "op": [
                    5376,
                    5444,
                    3045,
                    134,
                    3047,
                    5447,
                    107,
                    139,
                    111,
                    122
                ],
                "self.values": [
                    4487,
                    2312,
                    3976,
                    4493,
                    801,
                    1061,
                    4009,
                    2094,
                    818,
                    5554,
                    821,
                    1081,
                    1858,
                    5447,
                    1238,
                    862,
                    3042,
                    3043,
                    613,
                    872,
                    107,
                    4333,
                    111,
                    3056
                ],
                "np.asarray": [
                    4255,
                    705,
                    3041,
                    2980,
                    808,
                    4106,
                    811,
                    493,
                    111,
                    3666,
                    1142,
                    567,
                    5270,
                    351
                ],
                "is_bool_dtype": [
                    712,
                    4011,
                    5135,
                    434,
                    115
                ],
                "name": [
                    512,
                    388,
                    265,
                    266,
                    139,
                    396,
                    141,
                    1294,
                    1295,
                    1296,
                    276,
                    1173,
                    1174,
                    1175,
                    3864,
                    3865,
                    1050,
                    4304,
                    286,
                    288,
                    1312,
                    1314,
                    1188,
                    294,
                    425,
                    1321,
                    1322,
                    1068,
                    429,
                    1323,
                    303,
                    560,
                    433,
                    4274,
                    5550,
                    5551,
                    5564,
                    319,
                    448,
                    577,
                    323,
                    452,
                    1351,
                    1352,
                    457,
                    2379,
                    2380,
                    2381,
                    462,
                    335,
                    976,
                    1489,
                    4302,
                    339,
                    1235,
                    1236,
                    1238,
                    2647,
                    4056,
                    2649,
                    346,
                    474,
                    2650,
                    4311,
                    4312,
                    4319,
                    4065,
                    484,
                    487,
                    232,
                    361,
                    490,
                    493,
                    508,
                    122,
                    124
                ],
                "op.__name__": [
                    5376,
                    122,
                    139
                ],
                "set_function_name": [
                    124,
                    141
                ],
                "cmp_method": [
                    124
                ],
                "cls": [
                    387,
                    4101,
                    141,
                    276,
                    159,
                    162,
                    163,
                    5417,
                    5418,
                    5419,
                    5420,
                    5421,
                    5422,
                    559,
                    5424,
                    5425,
                    5580,
                    5428,
                    5429,
                    5430,
                    5431,
                    5432,
                    569,
                    5433,
                    5567,
                    448,
                    5312,
                    5313,
                    5314,
                    5315,
                    5316,
                    5317,
                    5570,
                    5579,
                    5324,
                    5325,
                    5326,
                    5327,
                    5328,
                    5329,
                    5452,
                    5453,
                    5454,
                    5455,
                    5459,
                    5460,
                    5336,
                    5337,
                    5338,
                    5339,
                    5340,
                    5341,
                    5342,
                    5343,
                    5344,
                    5345,
                    5346,
                    5347,
                    5348,
                    5349,
                    490,
                    4075,
                    495,
                    760,
                    761,
                    124
                ],
                "ABCDataFrame": [
                    129,
                    2330
                ],
                "ABCTimedeltaIndex": [
                    129
                ],
                "Series": [
                    2339,
                    1238,
                    134,
                    2334
                ],
                "index_arithmetic_method": [
                    141
                ],
                "_o_dtype": [
                    312,
                    148,
                    332
                ],
                "np.dtype": [
                    148
                ],
                "_Identity": [
                    680,
                    149
                ],
                "ABCPeriodIndex": [
                    3282,
                    159
                ],
                "_new_PeriodIndex": [
                    162
                ],
                "d": [
                    162,
                    163,
                    1864,
                    1865,
                    1866
                ],
                "cls.__new__": [
                    163
                ],
                "IndexOpsMixin": [
                    3978,
                    166
                ],
                "PandasObject": [
                    166
                ],
                "_deprecations": [
                    208
                ],
                "DirNamesMixin._deprecations": [
                    208
                ],
                "DirNamesMixin": [
                    208
                ],
                "_join_precedence": [
                    211
                ],
                "libjoin.left_join_indexer_unique": [
                    218
                ],
                "libjoin": [
                    224,
                    218,
                    227,
                    221
                ],
                "left": [
                    224,
                    227,
                    3717,
                    3741,
                    3749,
                    3752,
                    3721,
                    3755,
                    3724,
                    3725,
                    3759,
                    3793,
                    3737,
                    218,
                    3739,
                    221,
                    3742
                ],
                "right": [
                    224,
                    227,
                    3717,
                    3721,
                    3727,
                    3733,
                    218,
                    221
                ],
                "libjoin.left_join_indexer": [
                    221
                ],
                "libjoin.inner_join_indexer": [
                    224
                ],
                "libjoin.outer_join_indexer": [
                    227
                ],
                "_typ": [
                    229
                ],
                "_data": [
                    230
                ],
                "_id": [
                    231
                ],
                "_comparables": [
                    233
                ],
                "_attributes": [
                    234
                ],
                "_is_numeric_dtype": [
                    235
                ],
                "_can_hold_na": [
                    236
                ],
                "_defer_to_indexing": [
                    239
                ],
                "_infer_as_myclass": [
                    243
                ],
                "_engine_type": [
                    245
                ],
                "libindex.ObjectEngine": [
                    245
                ],
                "libindex": [
                    4701,
                    245
                ],
                "_accessors": [
                    247
                ],
                "CachedAccessor": [
                    249
                ],
                "StringMethods": [
                    249
                ],
                "data": [
                    4099,
                    4100,
                    4101,
                    4104,
                    4105,
                    4106,
                    4107,
                    265,
                    266,
                    276,
                    280,
                    282,
                    285,
                    286,
                    287,
                    288,
                    291,
                    294,
                    298,
                    303,
                    306,
                    319,
                    323,
                    327,
                    335,
                    339,
                    343,
                    346,
                    1882,
                    1883,
                    350,
                    351,
                    1887,
                    1888,
                    1890,
                    355,
                    356,
                    360,
                    361,
                    364,
                    374,
                    376,
                    378,
                    382,
                    388,
                    396,
                    401,
                    403,
                    407,
                    409,
                    422,
                    425,
                    426,
                    429,
                    430,
                    433,
                    434,
                    435,
                    437,
                    4054,
                    4055,
                    4063,
                    4064,
                    4075,
                    492,
                    493,
                    494,
                    495,
                    1005,
                    497,
                    499,
                    500,
                    1012,
                    502,
                    1013,
                    1015,
                    508,
                    511
                ],
                "data.name": [
                    266
                ],
                "fastpath": [
                    275,
                    268
                ],
                "warnings.warn": [
                    269,
                    2286,
                    4214,
                    3967,
                    2552,
                    733,
                    1183
                ],
                "warnings": [
                    269,
                    2286,
                    4214,
                    3967,
                    2552,
                    733,
                    1183
                ],
                "cls._simple_new": [
                    490,
                    276
                ],
                "ABCPandasArray": [
                    280
                ],
                "data.to_numpy": [
                    282
                ],
                "RangeIndex": [
                    288,
                    285,
                    286,
                    5733
                ],
                "copy": [
                    512,
                    388,
                    396,
                    409,
                    796,
                    286,
                    801,
                    5669,
                    294,
                    425,
                    5673,
                    811,
                    429,
                    303,
                    433,
                    818,
                    821,
                    441,
                    5695,
                    448,
                    5698,
                    323,
                    452,
                    457,
                    462,
                    339,
                    4056,
                    346,
                    474,
                    4065,
                    484,
                    361,
                    493,
                    376
                ],
                "dtype": [
                    512,
                    388,
                    396,
                    401,
                    402,
                    4117,
                    407,
                    409,
                    4122,
                    795,
                    4124,
                    286,
                    798,
                    288,
                    801,
                    802,
                    291,
                    294,
                    807,
                    4008,
                    425,
                    298,
                    299,
                    554,
                    429,
                    555,
                    303,
                    560,
                    433,
                    810,
                    307,
                    811,
                    814,
                    818,
                    821,
                    312,
                    825,
                    4022,
                    4024,
                    444,
                    448,
                    705,
                    323,
                    328,
                    332,
                    4050,
                    339,
                    979,
                    980,
                    343,
                    350,
                    352,
                    355,
                    356,
                    4015,
                    365,
                    493,
                    373,
                    376,
                    382
                ],
                "RangeIndex.from_range": [
                    288
                ],
                "is_categorical_dtype": [
                    291,
                    1085,
                    798
                ],
                "CategoricalIndex": [
                    801,
                    294
                ],
                "kwargs": [
                    512,
                    642,
                    644,
                    294,
                    4653,
                    302,
                    4782,
                    560,
                    4783,
                    308,
                    1078,
                    319,
                    578,
                    323,
                    335,
                    975,
                    339,
                    984,
                    857,
                    474,
                    346,
                    858,
                    484,
                    487,
                    615,
                    361,
                    616,
                    493,
                    1134,
                    508
                ],
                "is_interval_dtype": [
                    298
                ],
                "closed": [
                    302,
                    303
                ],
                "kwargs.get": [
                    508,
                    302,
                    975
                ],
                "IntervalIndex": [
                    462,
                    303
                ],
                "is_datetime64_any_dtype": [
                    306,
                    307
                ],
                "is_dtype_equal": [
                    2946,
                    3529,
                    332,
                    2612,
                    2422,
                    312,
                    795
                ],
                "DatetimeIndex": [
                    322,
                    808,
                    817,
                    4790,
                    4791,
                    474,
                    319
                ],
                "result.astype": [
                    320,
                    336
                ],
                "is_timedelta64_dtype": [
                    328,
                    327
                ],
                "TimedeltaIndex": [
                    338,
                    484,
                    335
                ],
                "is_period_dtype": [
                    2618,
                    2518,
                    343,
                    2522,
                    2622
                ],
                "PeriodIndex": [
                    346,
                    487
                ],
                "is_extension_array_dtype": [
                    810,
                    350
                ],
                "_from_sequence": [
                    355
                ],
                "dtype.construct_array_type": [
                    355
                ],
                "data.astype": [
                    360,
                    401,
                    435,
                    4054,
                    407,
                    4063
                ],
                "is_integer_dtype": [
                    3280,
                    373
                ],
                "inferred": [
                    481,
                    453,
                    485,
                    458,
                    398,
                    466,
                    403,
                    404,
                    469,
                    374,
                    375,
                    470,
                    377,
                    381,
                    446,
                    445
                ],
                "lib.infer_dtype": [
                    403,
                    1852,
                    445,
                    374
                ],
                "lib": [
                    3712,
                    1089,
                    3746,
                    711,
                    712,
                    5136,
                    5138,
                    403,
                    5684,
                    374,
                    1852,
                    445
                ],
                "maybe_cast_to_integer_array": [
                    376,
                    382
                ],
                "isna": [
                    1991,
                    1095,
                    2320,
                    4019,
                    1140,
                    1909,
                    4119,
                    378
                ],
                "cls._try_convert_to_int_index": [
                    448,
                    387
                ],
                "Float64Index": [
                    433,
                    396,
                    457
                ],
                "is_float_dtype": [
                    402,
                    430
                ],
                "np.array": [
                    1922,
                    1097,
                    2346,
                    4652,
                    557,
                    2349,
                    1144,
                    409,
                    1086
                ],
                "msg": [
                    870,
                    871,
                    1421,
                    1422,
                    4143,
                    4144,
                    886,
                    824,
                    825,
                    890,
                    412,
                    414,
                    415
                ],
                "e": [
                    2554,
                    412,
                    502
                ],
                "is_signed_integer_dtype": [
                    422
                ],
                "data.dtype": [
                    434,
                    426,
                    430,
                    422
                ],
                "Int64Index": [
                    4056,
                    425
                ],
                "is_unsigned_integer_dtype": [
                    4050,
                    426
                ],
                "UInt64Index": [
                    4065,
                    429
                ],
                "data.dtype.type": [
                    434
                ],
                "np.bool": [
                    434
                ],
                "subarr": [
                    448,
                    512,
                    452,
                    484,
                    487,
                    457,
                    490,
                    462,
                    474,
                    435,
                    437,
                    442,
                    445,
                    511
                ],
                "com.asarray_tuplesafe": [
                    437,
                    3238,
                    511
                ],
                "com": [
                    4257,
                    3238,
                    3591,
                    3592,
                    4366,
                    5295,
                    4690,
                    4691,
                    437,
                    4246,
                    4727,
                    5397,
                    4254,
                    511
                ],
                "subarr.copy": [
                    442
                ],
                "inferred.startswith": [
                    481,
                    470
                ],
                "OutOfBoundsDatetime": [
                    475
                ],
                "IncompatibleFrequency": [
                    488
                ],
                "is_scalar": [
                    4674,
                    4259,
                    4100,
                    4997,
                    4999,
                    4714,
                    4142,
                    494,
                    4245
                ],
                "cls._scalar_data_error": [
                    4101,
                    495
                ],
                "tupleize_cols": [
                    497
                ],
                "is_list_like": [
                    1344,
                    1317,
                    1321,
                    1420,
                    1424,
                    497,
                    1427,
                    2803,
                    1429
                ],
                "is_iterator": [
                    5675,
                    4706,
                    499
                ],
                "MultiIndex.from_tuples": [
                    4858,
                    507
                ],
                "MultiIndex": [
                    5633,
                    3714,
                    3719,
                    3627,
                    3790,
                    3599,
                    3600,
                    4852,
                    1653,
                    5689,
                    4858,
                    507
                ],
                "values": [
                    644,
                    648,
                    2312,
                    651,
                    2315,
                    2320,
                    1912,
                    2324,
                    1914,
                    3361,
                    3362,
                    553,
                    554,
                    555,
                    4009,
                    557,
                    558,
                    559,
                    560,
                    4014,
                    4017,
                    563,
                    4019,
                    567,
                    4024,
                    1081,
                    570,
                    1085,
                    1086,
                    576,
                    1088,
                    1089,
                    1091,
                    1092,
                    1344,
                    1346,
                    1095,
                    1347,
                    1351,
                    1356,
                    1102,
                    4814,
                    4815,
                    4816,
                    4817,
                    4948,
                    3425,
                    612,
                    613,
                    616,
                    1131,
                    620,
                    621,
                    1133,
                    1134,
                    624,
                    4333,
                    626,
                    4335,
                    4336,
                    1142,
                    1144,
                    1913,
                    1146,
                    1147,
                    892,
                    895
                ],
                "np.empty": [
                    3428,
                    555,
                    3697,
                    1912,
                    1882,
                    1887
                ],
                "_ndarray_values": [
                    5271,
                    559
                ],
                "ABCIndexClass": [
                    563,
                    3893
                ],
                "values._values": [
                    567
                ],
                "object.__new__": [
                    569
                ],
                "result._data": [
                    570
                ],
                "result._index_data": [
                    576
                ],
                "result.name": [
                    1648,
                    577
                ],
                "k": [
                    578,
                    579,
                    593,
                    1009,
                    1875,
                    1876,
                    4691,
                    4693,
                    4695,
                    4820
                ],
                "v": [
                    578,
                    579,
                    3148,
                    1009,
                    1875,
                    1876,
                    4820
                ],
                "kwargs.items": [
                    578
                ],
                "result._reset_identity": [
                    580
                ],
                "cache_readonly": [
                    1924,
                    582,
                    1773,
                    686,
                    719,
                    1903,
                    1847,
                    1916,
                    1854
                ],
                "self._attributes": [
                    593
                ],
                "attributes": [
                    641,
                    642,
                    643,
                    4865,
                    645,
                    614,
                    615,
                    648,
                    617,
                    651,
                    4848,
                    626,
                    4854,
                    4855,
                    4860,
                    4863
                ],
                "self._get_attributes_dict": [
                    641,
                    5445,
                    614,
                    1865,
                    715,
                    2796,
                    4848,
                    4124,
                    3359
                ],
                "attributes.update": [
                    642,
                    615
                ],
                "self.dtype": [
                    2946,
                    739,
                    3362,
                    1797,
                    645,
                    4008,
                    617,
                    3529,
                    5294,
                    2612,
                    4117,
                    2422,
                    4793,
                    795,
                    4863
                ],
                "ABCDatetimeArray": [
                    621
                ],
                "values.asi8": [
                    624
                ],
                "self._simple_new": [
                    626,
                    3362
                ],
                "Appender": [
                    3074,
                    3978,
                    2061,
                    4752,
                    1682,
                    3480,
                    793,
                    4003,
                    3236,
                    2088,
                    937,
                    2858,
                    2603,
                    5551,
                    5552,
                    3127,
                    3256,
                    4667,
                    5057,
                    968,
                    2123,
                    3276,
                    855,
                    610,
                    4195,
                    2927
                ],
                "self._infer_as_myclass": [
                    646
                ],
                "self._constructor": [
                    648,
                    2563
                ],
                "self._id": [
                    680,
                    674,
                    765
                ],
                "self._engine.clear_mapping": [
                    684
                ],
                "self._engine": [
                    1734,
                    4199,
                    4766,
                    684,
                    2988,
                    2990,
                    3983,
                    1778,
                    2867,
                    1717,
                    2869,
                    4695,
                    4726,
                    2974
                ],
                "self._engine_type": [
                    689
                ],
                "self._ndarray_values": [
                    3660,
                    689,
                    754,
                    3666,
                    3826,
                    2519,
                    2619
                ],
                "self._data": [
                    1856,
                    705,
                    1890,
                    3361,
                    5253,
                    1864,
                    971,
                    2702,
                    3920,
                    1874,
                    3890,
                    724,
                    4242,
                    761,
                    699
                ],
                "lib.item_from_zerodim": [
                    711
                ],
                "lib.is_scalar": [
                    712
                ],
                "attrs": [
                    3360,
                    3362,
                    5445,
                    5446,
                    5447,
                    715,
                    716,
                    717,
                    1006,
                    5355,
                    1009,
                    3359
                ],
                "self._maybe_update_attributes": [
                    716,
                    5446
                ],
                "self._data.dtype": [
                    724
                ],
                "self._ndarray_values.ravel": [
                    754
                ],
                "order": [
                    754
                ],
                "self._data.view": [
                    761,
                    3890
                ],
                "self._shallow_copy": [
                    5253,
                    2702,
                    4243,
                    2324,
                    2070,
                    1435,
                    941,
                    2094,
                    2095,
                    3504,
                    971,
                    973,
                    2381,
                    2128,
                    1234,
                    2650,
                    873,
                    4336,
                    763
                ],
                "result._id": [
                    765
                ],
                "self.copy": [
                    984,
                    995,
                    796
                ],
                "self.name": [
                    1295,
                    2069,
                    801,
                    1070,
                    1071,
                    1326,
                    818,
                    821,
                    3389,
                    3391,
                    1356,
                    2380,
                    4302,
                    1236,
                    2646,
                    2649,
                    1884,
                    2652,
                    1525,
                    1528,
                    2809,
                    2810
                ],
                "is_datetime64tz_dtype": [
                    2522,
                    802,
                    2518,
                    814
                ],
                "tz": [
                    808,
                    807
                ],
                "pandas_dtype": [
                    807
                ],
                "tz_convert": [
                    808
                ],
                "tz_localize": [
                    808
                ],
                "self.values.astype": [
                    821
                ],
                "msg.format": [
                    4144,
                    825,
                    871
                ],
                "nv.validate_take": [
                    858
                ],
                "nv": [
                    858,
                    940
                ],
                "indices": [
                    872,
                    881,
                    885,
                    895,
                    859,
                    892,
                    863
                ],
                "ensure_platform_int": [
                    2976,
                    3809,
                    3812,
                    939,
                    3663,
                    3664,
                    881,
                    3857,
                    3858,
                    2938,
                    859,
                    3422,
                    4767
                ],
                "self._can_hold_na": [
                    1908,
                    1929,
                    860,
                    1918
                ],
                "taken": [
                    896,
                    2653,
                    872,
                    873,
                    2655,
                    2642,
                    2645,
                    2650,
                    891,
                    861,
                    895
                ],
                "self._assert_take_fillable": [
                    861
                ],
                "allow_fill": [
                    864,
                    892,
                    884,
                    869
                ],
                "fill_value": [
                    865,
                    884,
                    869
                ],
                "self._na_value": [
                    866,
                    4452,
                    4006
                ],
                "self.__class__.__name__": [
                    1354,
                    1004,
                    2364,
                    871
                ],
                "self.__class__": [
                    871,
                    1354,
                    1866,
                    1004,
                    2364
                ],
                "self.values.take": [
                    872
                ],
                "np.nan": [
                    1900,
                    876,
                    1646
                ],
                "algos.take": [
                    891
                ],
                "algos": [
                    3748,
                    2542,
                    2639,
                    4948,
                    3798,
                    891
                ],
                "na_value": [
                    892
                ],
                "values.take": [
                    895
                ],
                "repeats": [
                    939,
                    941
                ],
                "nv.validate_repeat": [
                    940
                ],
                "axis": [
                    940
                ],
                "self._values.repeat": [
                    941
                ],
                "self._values": [
                    1296,
                    2521,
                    2621,
                    941
                ],
                "deep": [
                    1315,
                    970,
                    3980,
                    3983,
                    976
                ],
                "new_index": [
                    971,
                    973,
                    977,
                    980,
                    981,
                    3451,
                    3452
                ],
                "self._data.copy": [
                    971
                ],
                "names": [
                    5633,
                    1420,
                    1424,
                    1427,
                    1428,
                    1436,
                    1312,
                    1314,
                    1316,
                    1317,
                    3622,
                    1319,
                    3628,
                    4301,
                    1358,
                    975,
                    976,
                    977,
                    4302,
                    4853,
                    4855,
                    4857,
                    4858,
                    5629,
                    5630,
                    5631
                ],
                "self._validate_names": [
                    976
                ],
                "new_index.set_names": [
                    977
                ],
                "new_index.astype": [
                    980
                ],
                "memo": [
                    993,
                    994
                ],
                "klass": [
                    1004,
                    1015
                ],
                "self._format_data": [
                    1005
                ],
                "self._format_attrs": [
                    1006
                ],
                "space": [
                    1009,
                    1007
                ],
                "self._format_space": [
                    1007
                ],
                "prepr": [
                    1009,
                    1015
                ],
                "join": [
                    1009
                ],
                "res": [
                    4064,
                    4065,
                    1015,
                    4054,
                    4055,
                    4056,
                    1017,
                    4063
                ],
                "default_pprint": [
                    1034
                ],
                "is_justify": [
                    1042,
                    1050
                ],
                "self.inferred_type": [
                    4161,
                    1794,
                    3298,
                    1833,
                    3178,
                    1836,
                    4792,
                    1839,
                    1043,
                    1045,
                    1845,
                    3285,
                    4790,
                    1785,
                    1788,
                    3097,
                    1791
                ],
                "self.categories": [
                    1045
                ],
                "format_object_summary": [
                    1049
                ],
                "self._formatter_func": [
                    1050
                ],
                "format_object_attrs": [
                    1057
                ],
                "header": [
                    1067,
                    1069,
                    1103,
                    1076,
                    1078
                ],
                "header.append": [
                    1069
                ],
                "pprint_thing": [
                    1169,
                    1092,
                    1070
                ],
                "formatter": [
                    1075,
                    1076
                ],
                "self.map": [
                    1688,
                    1076
                ],
                "self._format_with_header": [
                    1078
                ],
                "values.dtype": [
                    1088,
                    1091,
                    1085
                ],
                "lib.maybe_convert_objects": [
                    1089
                ],
                "x": [
                    1092,
                    3525,
                    3526,
                    2536,
                    5455,
                    5720,
                    5721
                ],
                "mask": [
                    4487,
                    4490,
                    4492,
                    3760,
                    3761,
                    3762,
                    3763,
                    5297,
                    5298,
                    5300,
                    5301,
                    3777,
                    3778,
                    3780,
                    1095,
                    1096,
                    1098,
                    3788,
                    3667,
                    3668,
                    1643,
                    1645,
                    1646,
                    4335,
                    1140,
                    4342,
                    1146
                ],
                "mask.any": [
                    1096,
                    5298,
                    1645
                ],
                "na_rep": [
                    1098,
                    1146
                ],
                "result.tolist": [
                    1099
                ],
                "_trim_front": [
                    1102
                ],
                "format_array": [
                    1102
                ],
                "slicer": [
                    1132,
                    1133
                ],
                "values._format_native_types": [
                    1134
                ],
                "self.is_object": [
                    4273,
                    4155,
                    1141
                ],
                "quoting": [
                    1141
                ],
                "astype": [
                    2406,
                    2405,
                    1142
                ],
                "head": [
                    1169,
                    1163,
                    1164,
                    1165
                ],
                "head.format": [
                    1165
                ],
                "tail": [
                    1168,
                    1169,
                    1166,
                    1167
                ],
                "tail.format": [
                    1168
                ],
                "index_summary": [
                    1169,
                    1171,
                    1175
                ],
                "self._summary": [
                    1188
                ],
                "index": [
                    1233,
                    1234,
                    1298,
                    1238
                ],
                "self.values.copy": [
                    4333,
                    1238
                ],
                "DataFrame": [
                    1296
                ],
                "self._values.copy": [
                    1296
                ],
                "result.index": [
                    1299
                ],
                "deepcopy": [
                    1315
                ],
                "self.names": [
                    1633,
                    3490,
                    1315,
                    3591,
                    4853
                ],
                "FrozenList": [
                    1326
                ],
                "is_hashable": [
                    1352
                ],
                "_set_names": [
                    1358
                ],
                "_get_names": [
                    1358
                ],
                "level": [
                    1417,
                    1420,
                    3724,
                    3725,
                    1424,
                    1684,
                    1429,
                    1430,
                    1436,
                    3741,
                    3487,
                    3749,
                    3366,
                    3496,
                    3753,
                    3370,
                    3498,
                    3756,
                    3766,
                    1592,
                    3646,
                    3648,
                    3522,
                    3782,
                    2125,
                    2126,
                    1616,
                    1617,
                    4946,
                    1619,
                    4947,
                    1621,
                    1623,
                    3799,
                    3802,
                    1627,
                    1515,
                    1516,
                    1519,
                    1521,
                    1523,
                    1525,
                    1528,
                    1533
                ],
                "self.nlevels": [
                    1424,
                    1627,
                    1623
                ],
                "inplace": [
                    1432,
                    1489,
                    1437
                ],
                "idx": [
                    5273,
                    5272,
                    1433,
                    1435,
                    1436,
                    1438
                ],
                "idx._set_names": [
                    1436
                ],
                "self.set_names": [
                    1489
                ],
                "self._validate_index_level": [
                    1592,
                    4947,
                    1533,
                    2126
                ],
                "self.sort_values": [
                    1553
                ],
                "ascending": [
                    1553,
                    4541
                ],
                "get_level_values": [
                    1595
                ],
                "_get_level_values": [
                    1595
                ],
                "levnums": [
                    1635,
                    1619
                ],
                "self._get_level_number": [
                    1619
                ],
                "lev": [
                    1619
                ],
                "new_levels": [
                    1636,
                    1640,
                    3755,
                    1644,
                    3756,
                    3791,
                    1654,
                    1631
                ],
                "self.levels": [
                    1631
                ],
                "new_codes": [
                    1632,
                    3780,
                    1637,
                    3782,
                    3783,
                    3752,
                    3753,
                    1643,
                    1644,
                    3792,
                    3762,
                    1655,
                    3774
                ],
                "self.codes": [
                    1632
                ],
                "new_names": [
                    1648,
                    1633,
                    1656,
                    1638
                ],
                "i": [
                    1635,
                    1636,
                    1637,
                    1638
                ],
                "new_levels.pop": [
                    1636
                ],
                "new_codes.pop": [
                    1637
                ],
                "new_names.pop": [
                    1638
                ],
                "take": [
                    4490,
                    1644
                ],
                "result.putmask": [
                    1646
                ],
                "mapper": [
                    1688,
                    1685,
                    4846
                ],
                "grouper": [
                    1688,
                    1690,
                    1686
                ],
                "self.is_monotonic_increasing": [
                    1700,
                    3045,
                    2986,
                    5077,
                    1751
                ],
                "self._engine.is_monotonic_increasing": [
                    1717
                ],
                "self._engine.is_monotonic_decreasing": [
                    1734
                ],
                "self.is_unique": [
                    3332,
                    2309,
                    1768,
                    2953,
                    2314,
                    4781,
                    3536,
                    3377,
                    3540,
                    3829,
                    1782,
                    1751
                ],
                "self.is_monotonic_decreasing": [
                    1768,
                    5079
                ],
                "self._engine.is_unique": [
                    1778
                ],
                "is_datetime_array": [
                    1858
                ],
                "ensure_object": [
                    1858
                ],
                "d.update": [
                    1865
                ],
                "_new_Index": [
                    1866
                ],
                "state": [
                    1888,
                    1873,
                    1874,
                    1875,
                    1878,
                    1880,
                    1881,
                    1887
                ],
                "state.pop": [
                    1874
                ],
                "state.items": [
                    1875
                ],
                "nd_state": [
                    1881,
                    1882,
                    1883
                ],
                "own_state": [
                    1881,
                    1884
                ],
                "np.ndarray.__setstate__": [
                    1888,
                    1883
                ],
                "self._reset_identity": [
                    1891
                ],
                "_unpickle_compat": [
                    1895
                ],
                "__setstate__": [
                    1895
                ],
                "_na_value": [
                    1900
                ],
                "np.bool_": [
                    1912
                ],
                "values.fill": [
                    1913
                ],
                "w": [
                    1920,
                    1919
                ],
                "self._isnan.nonzero": [
                    1919
                ],
                "self._isnan": [
                    1989,
                    1930,
                    2094,
                    2065,
                    1919
                ],
                "np.int64": [
                    1922
                ],
                "self._isnan.any": [
                    1930
                ],
                "isnull": [
                    1991
                ],
                "self.isna": [
                    2037
                ],
                "notnull": [
                    2039
                ],
                "notna": [
                    2039
                ],
                "self._assert_can_do_op": [
                    2063
                ],
                "value": [
                    4136,
                    4142,
                    2063,
                    4144,
                    2065,
                    4335,
                    4342,
                    4727
                ],
                "self.hasnans": [
                    2064,
                    2093,
                    2319
                ],
                "self.putmask": [
                    2065
                ],
                "downcast": [
                    2066
                ],
                "how": [
                    3842,
                    3846,
                    3848,
                    3722,
                    3850,
                    3852,
                    3733,
                    3614,
                    3493,
                    3498,
                    2090,
                    2091,
                    3503,
                    3511,
                    3644,
                    3520,
                    3648,
                    3522,
                    3532,
                    3660,
                    3534,
                    3538,
                    3543,
                    3547,
                    3552,
                    3557,
                    3559,
                    3561,
                    3820,
                    3565,
                    3831,
                    3835,
                    3839
                ],
                "unique": [
                    2294,
                    2127
                ],
                "drop_duplicates": [
                    2176
                ],
                "keep": [
                    2176,
                    2232
                ],
                "duplicated": [
                    2232
                ],
                "self.duplicated": [
                    2294
                ],
                "dropna": [
                    2317,
                    2309
                ],
                "self.unique": [
                    2315
                ],
                "self.intersection": [
                    2352,
                    3564
                ],
                "self.union": [
                    3568,
                    2355
                ],
                "self.symmetric_difference": [
                    2358
                ],
                "__bool__": [
                    2368
                ],
                "__nonzero__": [
                    2368
                ],
                "get_op_result_name": [
                    2563,
                    3864,
                    2379,
                    2812
                ],
                "this": [
                    2403,
                    2947,
                    2949,
                    2406,
                    2711,
                    3530,
                    3532,
                    2776,
                    2706,
                    2783,
                    2708,
                    2613,
                    2774,
                    2615,
                    2712,
                    2781,
                    2719
                ],
                "self.astype": [
                    2403,
                    2947,
                    3530,
                    2613,
                    4342,
                    4794
                ],
                "Index.union": [
                    2406
                ],
                "sort": [
                    2615,
                    2406,
                    2790,
                    2697,
                    2489,
                    2605,
                    2768,
                    2713,
                    2483,
                    2548,
                    2644,
                    3570,
                    2487,
                    2425,
                    2428,
                    2527
                ],
                "other.dtype": [
                    3529,
                    2612,
                    2422,
                    5398
                ],
                "self._validate_sort_keyword": [
                    2768,
                    2697,
                    2483,
                    2605
                ],
                "self._assert_can_do_setop": [
                    2769,
                    2698,
                    2484,
                    2606
                ],
                "self._is_compatible_with_other": [
                    2486
                ],
                "self._union_incompatible_dtypes": [
                    2487
                ],
                "self._union": [
                    2489
                ],
                "self.equals": [
                    3819,
                    2700,
                    3373,
                    2511,
                    2609,
                    4383
                ],
                "self._get_reconciled_name_object": [
                    2512,
                    2610
                ],
                "other._get_reconciled_name_object": [
                    2515
                ],
                "lvals": [
                    2529,
                    2532,
                    2629,
                    2535,
                    2635,
                    2543,
                    2639,
                    2546,
                    2519,
                    2521,
                    2619,
                    2621
                ],
                "rvals": [
                    2529,
                    2625,
                    2629,
                    2536,
                    2635,
                    2542,
                    2639,
                    2523,
                    2525,
                    2623
                ],
                "other._ndarray_values": [
                    3660,
                    3827,
                    3668,
                    2523,
                    2623
                ],
                "other._values": [
                    2625,
                    2525
                ],
                "self.is_monotonic": [
                    3549,
                    2627,
                    3541,
                    2527
                ],
                "other.is_monotonic": [
                    3549,
                    2627,
                    3541,
                    2527
                ],
                "self._outer_indexer": [
                    2529,
                    3843,
                    3853
                ],
                "value_set": [
                    2536,
                    2535
                ],
                "result.extend": [
                    2536
                ],
                "indexer": [
                    3332,
                    3436,
                    2959,
                    2961,
                    3218,
                    3219,
                    2708,
                    2709,
                    5296,
                    2711,
                    2974,
                    4766,
                    2976,
                    4767,
                    3369,
                    3374,
                    4783,
                    2992,
                    4784,
                    2994,
                    3378,
                    2996,
                    2997,
                    2870,
                    2871,
                    2999,
                    2873,
                    5297,
                    3387,
                    5301,
                    5302,
                    3393,
                    3015,
                    3016,
                    3017,
                    2635,
                    2636,
                    2639,
                    2640,
                    3023,
                    2642,
                    3029,
                    3030,
                    3286,
                    2776,
                    3287,
                    3288,
                    2779,
                    3414,
                    3415,
                    3294,
                    3416,
                    3296,
                    3420,
                    2786,
                    3425,
                    3428,
                    3046,
                    2538,
                    2539,
                    3052,
                    2541,
                    2542,
                    3053,
                    3056,
                    3057,
                    3058,
                    3182,
                    3184,
                    3187,
                    3445,
                    3448,
                    3193,
                    3452,
                    3197
                ],
                "self.get_indexer": [
                    3015,
                    2538,
                    4782,
                    5296,
                    3378,
                    2870,
                    3286,
                    3577,
                    3038,
                    3039
                ],
                "nonzero": [
                    2786,
                    2539,
                    2636,
                    2709,
                    2779,
                    3710
                ],
                "other_diff": [
                    2542,
                    2543
                ],
                "algos.take_nd": [
                    3748,
                    3798,
                    2542
                ],
                "concat_compat": [
                    2789,
                    2543
                ],
                "sorting.safe_sort": [
                    2792,
                    2715,
                    2645,
                    2550
                ],
                "sorting": [
                    2792,
                    2715,
                    2645,
                    2550
                ],
                "self._wrap_setop_result": [
                    2560,
                    2630
                ],
                "ensure_index": [
                    3364,
                    3501,
                    2607,
                    2930,
                    4754,
                    3413
                ],
                "other.astype": [
                    4794,
                    3531,
                    2614
                ],
                "this.intersection": [
                    2615
                ],
                "self._inner_indexer": [
                    3840,
                    3851,
                    2629
                ],
                "get_indexer": [
                    2635
                ],
                "indexer.take": [
                    2779,
                    2636,
                    2709
                ],
                "algos.unique1d": [
                    2639
                ],
                "get_indexer_non_unique": [
                    2639
                ],
                "other.take": [
                    2642
                ],
                "taken.values": [
                    2645
                ],
                "other.name": [
                    2652,
                    2646
                ],
                "taken.name": [
                    2653
                ],
                "result_name": [
                    2797,
                    2704,
                    2771,
                    2772,
                    2810,
                    2812,
                    2813,
                    2719
                ],
                "self._convert_can_do_setop": [
                    2704,
                    2770
                ],
                "self._get_unique_index": [
                    2706,
                    2774
                ],
                "this.get_indexer": [
                    2776,
                    2708,
                    2949
                ],
                "label_diff": [
                    2712,
                    2711
                ],
                "np.setdiff1d": [
                    2780,
                    2711
                ],
                "np.arange": [
                    4490,
                    3436,
                    3437,
                    3759,
                    2711,
                    3448,
                    3420,
                    2781
                ],
                "this.size": [
                    2781,
                    2711
                ],
                "the_diff": [
                    2789,
                    2792,
                    2800,
                    2712,
                    2715,
                    2719
                ],
                "this.values.take": [
                    2712,
                    2783
                ],
                "this.values": [
                    2712,
                    2783
                ],
                "this._shallow_copy": [
                    2719
                ],
                "result_name_update": [
                    2770,
                    2772
                ],
                "other._get_unique_index": [
                    2775
                ],
                "common_indexer": [
                    2779,
                    2781
                ],
                "left_indexer": [
                    3738,
                    3741,
                    3742,
                    3759,
                    3763,
                    3768,
                    3773,
                    3774,
                    3782,
                    3783,
                    3788,
                    2780,
                    3805,
                    3038,
                    2783,
                    3808,
                    3809,
                    3042,
                    3814,
                    3048
                ],
                "left_diff": [
                    2789,
                    2783
                ],
                "right_indexer": [
                    2786,
                    2787,
                    3043,
                    3811,
                    3812,
                    3047,
                    3814,
                    3049,
                    3798,
                    3802,
                    3805,
                    3039
                ],
                "right_diff": [
                    2787,
                    2789
                ],
                "other.values.take": [
                    2787
                ],
                "other.values": [
                    2787
                ],
                "attribs": [
                    2796,
                    2797,
                    2798,
                    2799,
                    2800
                ],
                "self._shallow_copy_with_infer": [
                    2800,
                    5273,
                    3451,
                    4024
                ],
                "method": [
                    2950,
                    2958,
                    2959,
                    2960,
                    3367,
                    2987,
                    2860,
                    2989,
                    2992,
                    2994,
                    3379,
                    2870,
                    3382,
                    3009,
                    3012,
                    5726,
                    5727,
                    2929,
                    2943
                ],
                "tolerance": [
                    2980,
                    2981,
                    2950,
                    2983,
                    3051,
                    3052,
                    2861,
                    2959,
                    2961,
                    3057,
                    2931,
                    2932,
                    2963,
                    2870,
                    2995,
                    2997,
                    3379,
                    2943
                ],
                "self._engine.get_loc": [
                    2867,
                    2869
                ],
                "key": [
                    3079,
                    3088,
                    3090,
                    5010,
                    3092,
                    4245,
                    4246,
                    4247,
                    5012,
                    4249,
                    5013,
                    5014,
                    4252,
                    5017,
                    4254,
                    4255,
                    3105,
                    4257,
                    3107,
                    4258,
                    3109,
                    5026,
                    3111,
                    5028,
                    5031,
                    5032,
                    2867,
                    2869,
                    2870,
                    2875,
                    3132,
                    3133,
                    3138,
                    3139,
                    3140,
                    4674,
                    3144,
                    4682,
                    4687,
                    4688,
                    4691,
                    3161,
                    3162,
                    3163,
                    4701,
                    4706,
                    4707,
                    4197,
                    4199,
                    4714,
                    4715,
                    4716,
                    3182,
                    3311,
                    3184,
                    4727,
                    3193,
                    4221
                ],
                "self._maybe_cast_indexer": [
                    2869
                ],
                "indexer.ndim": [
                    2871
                ],
                "indexer.size": [
                    2871
                ],
                "loc": [
                    4450,
                    5253,
                    4454,
                    4455,
                    4456,
                    5272,
                    2873,
                    2874,
                    2876
                ],
                "indexer.item": [
                    2873
                ],
                "missing.clean_reindex_fill_method": [
                    2929
                ],
                "missing": [
                    4766,
                    4767,
                    2929,
                    3387,
                    3414,
                    3419,
                    3422,
                    3423
                ],
                "target": [
                    2946,
                    2948,
                    2950,
                    2959,
                    2961,
                    4754,
                    4755,
                    4756,
                    4757,
                    4758,
                    3353,
                    4762,
                    3356,
                    4764,
                    2974,
                    3358,
                    3362,
                    3364,
                    2981,
                    2986,
                    3370,
                    3373,
                    4782,
                    4783,
                    2992,
                    2994,
                    3379,
                    2997,
                    3387,
                    3389,
                    3390,
                    3391,
                    3393,
                    3015,
                    3017,
                    3413,
                    3414,
                    3038,
                    3039,
                    3423,
                    3041,
                    3042,
                    3043,
                    3433,
                    3052,
                    3056,
                    2930,
                    2932,
                    2937,
                    2938,
                    2940,
                    2941
                ],
                "self._convert_tolerance": [
                    2932
                ],
                "target.is_boolean": [
                    2937
                ],
                "self.is_numeric": [
                    2937
                ],
                "np.repeat": [
                    3506,
                    2938,
                    3514
                ],
                "target.size": [
                    2938,
                    2981
                ],
                "pself": [
                    4757,
                    4758,
                    4759,
                    2940,
                    2941,
                    2942
                ],
                "ptarget": [
                    4757,
                    4758,
                    4759,
                    2940,
                    2941,
                    2943
                ],
                "self._maybe_promote": [
                    2940,
                    4757
                ],
                "pself.get_indexer": [
                    2942
                ],
                "limit": [
                    2950,
                    2959,
                    2992,
                    2961,
                    2994,
                    3379,
                    3038,
                    3382,
                    2968,
                    3039,
                    3006,
                    2943
                ],
                "target.dtype": [
                    2946,
                    4756
                ],
                "target.astype": [
                    4756,
                    2948
                ],
                "InvalidIndexError": [
                    2954,
                    4707,
                    4716
                ],
                "self._get_fill_indexer": [
                    2959
                ],
                "self._get_nearest_indexer": [
                    2961
                ],
                "self._engine.get_indexer": [
                    2974
                ],
                "target._ndarray_values": [
                    2992,
                    4764,
                    2997,
                    2974
                ],
                "tolerance.size": [
                    2981
                ],
                "target.is_monotonic_increasing": [
                    2986
                ],
                "self._engine.get_pad_indexer": [
                    2988
                ],
                "self._engine.get_backfill_indexer": [
                    2990
                ],
                "self._get_fill_indexer_searchsorted": [
                    2994
                ],
                "self._filter_indexer_tolerance": [
                    2996,
                    3052
                ],
                "side": [
                    5120,
                    3012,
                    5127,
                    3017,
                    3018,
                    5078,
                    5110,
                    5142,
                    5113,
                    5146,
                    5084,
                    5151
                ],
                "nonexact": [
                    3016,
                    3017,
                    3023
                ],
                "self._searchsorted_monotonic": [
                    3017,
                    5127
                ],
                "left_distances": [
                    3042,
                    3047
                ],
                "right_distances": [
                    3043,
                    3047
                ],
                "operator.lt": [
                    5314,
                    3045
                ],
                "operator": [
                    5312,
                    5313,
                    5314,
                    5315,
                    5316,
                    3045,
                    5317,
                    5417,
                    5419,
                    5452,
                    5453,
                    5422,
                    5424,
                    5428,
                    5429,
                    5432
                ],
                "operator.le": [
                    5316,
                    3045
                ],
                "np.where": [
                    3299,
                    3046,
                    4488,
                    4017,
                    3057
                ],
                "distance": [
                    3056,
                    3057
                ],
                "kind": [
                    5120,
                    4994,
                    3076,
                    3078,
                    3079,
                    3088,
                    3218,
                    3092,
                    5024,
                    3107,
                    5030,
                    3129,
                    3136,
                    4161,
                    3138,
                    3139,
                    3140,
                    5059,
                    5066,
                    3279,
                    3154,
                    5208,
                    3161,
                    3162,
                    3163,
                    5214,
                    3187,
                    5108
                ],
                "self._validate_indexer": [
                    3138,
                    3139,
                    3140,
                    3079,
                    3161,
                    3162,
                    3163
                ],
                "is_float": [
                    5065,
                    3088,
                    5010,
                    3092,
                    5407
                ],
                "self.is_floating": [
                    3089,
                    5010,
                    5066,
                    3281
                ],
                "self._invalid_indexer": [
                    3105,
                    3109,
                    5031,
                    5067,
                    5072,
                    3090
                ],
                "is_integer": [
                    3107,
                    5028,
                    3148,
                    5071,
                    4687,
                    5407
                ],
                "self.holds_integer": [
                    4697,
                    5066,
                    3108,
                    4685
                ],
                "key.start": [
                    3144,
                    3161,
                    3138
                ],
                "key.stop": [
                    3144,
                    3162,
                    3139
                ],
                "key.step": [
                    3144,
                    3163,
                    3140
                ],
                "start": [
                    4994,
                    3172,
                    3173,
                    3144,
                    5192,
                    5196,
                    3150,
                    3151,
                    5198,
                    3187,
                    5207,
                    5208
                ],
                "stop": [
                    3174,
                    3175,
                    3144,
                    3150,
                    3151,
                    3187
                ],
                "step": [
                    4994,
                    5188,
                    3144,
                    5002,
                    3187
                ],
                "is_null_slicer": [
                    3181,
                    3150
                ],
                "is_index_slice": [
                    3152,
                    3189,
                    3159,
                    3151
                ],
                "is_int": [
                    3151
                ],
                "is_positional": [
                    3152,
                    3170,
                    3176,
                    3183
                ],
                "self.is_integer": [
                    3152,
                    3190,
                    3159
                ],
                "self.is_mixed": [
                    3170
                ],
                "self.get_loc": [
                    4450,
                    5124,
                    3173,
                    3175,
                    4682
                ],
                "self.slice_indexer": [
                    3187
                ],
                "keyarr": [
                    3299,
                    3300,
                    3238,
                    3239,
                    3213,
                    3214,
                    3216,
                    3280,
                    3218,
                    3219,
                    3282,
                    3286,
                    3258
                ],
                "self._convert_index_indexer": [
                    3214
                ],
                "self._convert_arr_indexer": [
                    3216
                ],
                "self._convert_list_indexer": [
                    3218
                ],
                "maybe_convert_indices": [
                    3296
                ],
                "form": [
                    5031,
                    3311
                ],
                "preserve_names": [
                    3353,
                    3389
                ],
                "_ensure_has_len": [
                    3356
                ],
                "attrs.pop": [
                    3360
                ],
                "_": [
                    3369,
                    3701,
                    4783
                ],
                "self._join_level": [
                    3369,
                    3497,
                    3647
                ],
                "self.get_indexer_non_unique": [
                    3387,
                    3414,
                    4783
                ],
                "target.nlevels": [
                    3389
                ],
                "target.name": [
                    3389,
                    3391
                ],
                "target.copy": [
                    3390
                ],
                "check": [
                    3424,
                    3425,
                    3426,
                    3445,
                    3415,
                    3416,
                    3449
                ],
                "new_labels": [
                    3428,
                    3429,
                    3430,
                    3416,
                    3451
                ],
                "self.take": [
                    4544,
                    3425,
                    3448,
                    4820,
                    3416
                ],
                "new_indexer": [
                    3449,
                    3436,
                    3437,
                    3438,
                    3448,
                    3417,
                    3452
                ],
                "length": [
                    3424,
                    3426,
                    3420
                ],
                "missing_labels": [
                    3430,
                    3423
                ],
                "target.take": [
                    3423
                ],
                "missing_indexer": [
                    3424,
                    3438,
                    3430
                ],
                "ensure_int64": [
                    3424,
                    3712,
                    3426,
                    3745,
                    3700,
                    3711
                ],
                "cur_labels": [
                    3425,
                    3437,
                    3429
                ],
                "cur_indexer": [
                    3426,
                    3437,
                    3429
                ],
                "target.is_unique": [
                    3433
                ],
                "self_is_mi": [
                    3496,
                    3599,
                    3602,
                    3640,
                    3482,
                    3487
                ],
                "other_is_mi": [
                    3496,
                    3600,
                    3602,
                    3483,
                    3487
                ],
                "other.names": [
                    3592,
                    3490,
                    3646
                ],
                "self._join_multi": [
                    3493
                ],
                "return_indexers": [
                    3552,
                    3648,
                    3522,
                    3524,
                    3493,
                    3498,
                    3532,
                    3821,
                    3856,
                    3505,
                    3538,
                    3573,
                    3543,
                    3672,
                    3513,
                    3547,
                    3807
                ],
                "join_index": [
                    3584,
                    3840,
                    3841,
                    3843,
                    3844,
                    3847,
                    3849,
                    3851,
                    3853,
                    3854,
                    3859,
                    3861,
                    3739,
                    3742,
                    3504,
                    3506,
                    3507,
                    3509,
                    3512,
                    3514,
                    3515,
                    3517,
                    3790,
                    3666,
                    3668,
                    3670,
                    3799,
                    3673,
                    3802,
                    3675,
                    3558,
                    3814,
                    3560,
                    3816,
                    3564,
                    3568,
                    3571,
                    3574,
                    3832,
                    3577,
                    3578,
                    3836,
                    3581,
                    3582
                ],
                "rindexer": [
                    3506,
                    3507,
                    3579,
                    3581,
                    3582
                ],
                "other._shallow_copy": [
                    3512
                ],
                "lindexer": [
                    3575,
                    3577,
                    3514,
                    3515,
                    3582
                ],
                "self._join_precedence": [
                    3519
                ],
                "other._join_precedence": [
                    3519
                ],
                "get": [
                    3520,
                    3722,
                    3644
                ],
                "other.join": [
                    3521
                ],
                "y": [
                    3525,
                    3526
                ],
                "z": [
                    3525,
                    3526
                ],
                "this.join": [
                    3532
                ],
                "_validate_join_method": [
                    3534
                ],
                "other.is_unique": [
                    3536,
                    3540,
                    3829
                ],
                "self._join_non_unique": [
                    3537,
                    3546
                ],
                "self._join_monotonic": [
                    3542,
                    3551
                ],
                "join_index.sort_values": [
                    3571
                ],
                "other.get_indexer": [
                    3581
                ],
                "self_names": [
                    3593,
                    3605,
                    3591
                ],
                "com.not_none": [
                    3592,
                    3591
                ],
                "other_names": [
                    3592,
                    3593,
                    3606
                ],
                "overlap": [
                    3593,
                    3596,
                    3635,
                    3605,
                    3606
                ],
                "ldrop_names": [
                    3608,
                    3620,
                    3605
                ],
                "rdrop_names": [
                    3609,
                    3620,
                    3606
                ],
                "self_jnlevels": [
                    3608,
                    3613
                ],
                "self.droplevel": [
                    3608
                ],
                "other_jnlevels": [
                    3609,
                    3614
                ],
                "other.droplevel": [
                    3609
                ],
                "join_idx": [
                    3613,
                    3623
                ],
                "lidx": [
                    3840,
                    3843,
                    3623,
                    3847,
                    3837,
                    3849,
                    3851,
                    3853,
                    3633,
                    3857,
                    3859,
                    3833,
                    3613
                ],
                "ridx": [
                    3840,
                    3843,
                    3623,
                    3847,
                    3849,
                    3851,
                    3853,
                    3633,
                    3858,
                    3859,
                    3834,
                    3613,
                    3838
                ],
                "self_jnlevels.join": [
                    3613
                ],
                "dropped_names": [
                    3620,
                    3623
                ],
                "levels": [
                    3628,
                    3622
                ],
                "codes": [
                    3628,
                    3622
                ],
                "_restore_dropped_levels_multijoin": [
                    3622
                ],
                "multi_join_idx": [
                    3633,
                    3627,
                    3631
                ],
                "multi_join_idx.remove_unused_levels": [
                    3631
                ],
                "jl": [
                    3635,
                    3646
                ],
                "flip_order": [
                    3651,
                    3719,
                    3720,
                    3639,
                    3642,
                    3804
                ],
                "other.names.index": [
                    3646
                ],
                "left_idx": [
                    3659,
                    3663,
                    3666,
                    3667,
                    3673
                ],
                "right_idx": [
                    3664,
                    3673,
                    3659,
                    3668
                ],
                "_get_join_indexers": [
                    3659
                ],
                "self._ndarray_values.take": [
                    3666
                ],
                "np.putmask": [
                    3668,
                    4335
                ],
                "other._ndarray_values.take": [
                    3668
                ],
                "self._wrap_joined_index": [
                    3841,
                    3844,
                    3670,
                    3854
                ],
                "size": [
                    3696
                ],
                "labels": [
                    5295,
                    3696,
                    5296,
                    3699,
                    3700,
                    5300,
                    3706,
                    3707,
                    3711
                ],
                "lab": [
                    3712,
                    3780,
                    3783,
                    3762,
                    3700,
                    3701,
                    3707,
                    3708,
                    3774,
                    3711
                ],
                "sorter": [
                    3701,
                    3702
                ],
                "libalgos.groupsort_indexer": [
                    3768,
                    3701
                ],
                "libalgos": [
                    3768,
                    3701
                ],
                "lab.max": [
                    3701
                ],
                "tic": [
                    3706,
                    3708,
                    3710
                ],
                "starts": [
                    3712,
                    3710
                ],
                "np.hstack": [
                    3710
                ],
                "lib.get_level_sorter": [
                    3712
                ],
                "left._get_level_number": [
                    3724
                ],
                "old_level": [
                    3746,
                    3732,
                    3725
                ],
                "left.levels": [
                    3755,
                    3725
                ],
                "right.is_unique": [
                    3727
                ],
                "new_level": [
                    3756,
                    3732
                ],
                "left_lev_indexer": [
                    3736,
                    3745,
                    3746,
                    3732
                ],
                "right_lev_indexer": [
                    3732,
                    3797,
                    3799
                ],
                "old_level.join": [
                    3732
                ],
                "keep_order": [
                    3737,
                    3758
                ],
                "_get_leaf_sorter": [
                    3741,
                    3782
                ],
                "left.codes": [
                    3752,
                    3741,
                    3749
                ],
                "rev_indexer": [
                    3746,
                    3749
                ],
                "lib.get_reverse_indexer": [
                    3746
                ],
                "new_lev_codes": [
                    3777,
                    3748,
                    3753,
                    3760,
                    3767,
                    3769
                ],
                "np.intp": [
                    3759
                ],
                "mask.all": [
                    3761,
                    3778
                ],
                "ngroups": [
                    3769,
                    3767
                ],
                "new_lev_codes.max": [
                    3767
                ],
                "counts": [
                    3768,
                    3773
                ],
                "mask_all": [
                    3778,
                    3779,
                    3787
                ],
                "mask.nonzero": [
                    3788
                ],
                "left.names": [
                    3793
                ],
                "join_index.codes": [
                    3802,
                    3799
                ],
                "ret_index": [
                    3824,
                    3820,
                    3822
                ],
                "sv": [
                    3840,
                    3843,
                    3847,
                    3849,
                    3851,
                    3853,
                    3826,
                    3834,
                    3837
                ],
                "ov": [
                    3840,
                    3843,
                    3847,
                    3849,
                    3851,
                    3853,
                    3827,
                    3834,
                    3837
                ],
                "self._left_indexer_unique": [
                    3834,
                    3837
                ],
                "self._left_indexer": [
                    3849,
                    3847
                ],
                "joined": [
                    3865
                ],
                "Union": [
                    3893
                ],
                "ExtensionArray": [
                    4674,
                    3893
                ],
                "self._internal_get_values": [
                    3973
                ],
                "memory_usage": [
                    3980
                ],
                "self._engine.sizeof": [
                    3983
                ],
                "IndexOpsMixin.memory_usage.__doc__": [
                    3978
                ],
                "IndexOpsMixin.memory_usage": [
                    3978
                ],
                "is_bool": [
                    4011
                ],
                "values.astype": [
                    4014
                ],
                "cond": [
                    4017
                ],
                "self._is_numeric_dtype": [
                    5379,
                    5361,
                    4019,
                    4119
                ],
                "np.any": [
                    4019,
                    5571
                ],
                "cls.__name__": [
                    4075
                ],
                "item": [
                    5271,
                    4124,
                    5272,
                    4119
                ],
                "getitem": [
                    4258,
                    4242,
                    4252,
                    4247
                ],
                "self._data.__getitem__": [
                    4242
                ],
                "promote": [
                    4260,
                    4243,
                    4252
                ],
                "com.cast_scalar_indexer": [
                    4246
                ],
                "com.is_bool_indexer": [
                    4254
                ],
                "com.values_from_object": [
                    4257,
                    4366,
                    4690,
                    4691,
                    5397,
                    4727
                ],
                "self.is_categorical": [
                    4273
                ],
                "to_concat": [
                    4290,
                    4293,
                    4295,
                    4297,
                    4301,
                    4304,
                    4308,
                    4311,
                    4312,
                    4319
                ],
                "to_concat.append": [
                    4295
                ],
                "obj": [
                    4297,
                    4298,
                    4301
                ],
                "obj.name": [
                    4301
                ],
                "self._concat": [
                    4304
                ],
                "typs": [
                    4308,
                    4310
                ],
                "_concat.get_dtype_kinds": [
                    4308
                ],
                "_concat": [
                    4312,
                    4308,
                    4319
                ],
                "self._concat_same_dtype": [
                    4311
                ],
                "_concat._concat_index_asobject": [
                    4312,
                    4319
                ],
                "self._convert_for_op": [
                    4335
                ],
                "err": [
                    5130,
                    4339
                ],
                "putmask": [
                    4342
                ],
                "self.is_": [
                    4354
                ],
                "other.equals": [
                    4362
                ],
                "array_equivalent": [
                    4365
                ],
                "c": [
                    4386,
                    4387
                ],
                "self._comparables": [
                    4387
                ],
                "label": [
                    5120,
                    4450,
                    5124,
                    5127,
                    5065,
                    5067,
                    5116,
                    5071,
                    5072,
                    5074,
                    5078,
                    5084
                ],
                "loc.indices": [
                    4455
                ],
                "locs": [
                    4488,
                    4490,
                    4493,
                    4487
                ],
                "searchsorted": [
                    5083,
                    4487
                ],
                "where.values": [
                    4493,
                    4487
                ],
                "where": [
                    4493,
                    4487
                ],
                "first": [
                    4492,
                    4493
                ],
                "mask.argmax": [
                    4492
                ],
                "_as": [
                    4544,
                    4547,
                    4540,
                    4542
                ],
                "self.argsort": [
                    4540
                ],
                "sorted_index": [
                    4544,
                    4547,
                    4549
                ],
                "return_indexer": [
                    4546
                ],
                "self.asi8": [
                    4650
                ],
                "result.argsort": [
                    4653
                ],
                "args": [
                    4653
                ],
                "s": [
                    4673,
                    4674,
                    4683,
                    4688,
                    4690,
                    4695,
                    4701
                ],
                "series": [
                    4673,
                    4690,
                    4695
                ],
                "iloc": [
                    4682,
                    4683
                ],
                "self.is_boolean": [
                    4697,
                    4685
                ],
                "self._convert_scalar_indexer": [
                    4693
                ],
                "self._engine.get_value": [
                    4695
                ],
                "series.dtype": [
                    4695
                ],
                "libindex.get_value_box": [
                    4701
                ],
                "e1": [
                    4709,
                    4711
                ],
                "self._engine.set_value": [
                    4726
                ],
                "arr": [
                    4727
                ],
                "is_categorical": [
                    4755
                ],
                "target.dtype.categories.dtype": [
                    4756
                ],
                "target.dtype.categories": [
                    4756
                ],
                "pself.get_indexer_non_unique": [
                    4759
                ],
                "self.is_all_dates": [
                    4761
                ],
                "tgt_values": [
                    4762,
                    4764,
                    4766
                ],
                "target.asi8": [
                    4762
                ],
                "self._engine.get_indexer_non_unique": [
                    4766
                ],
                "values.values": [
                    4815
                ],
                "ensure_categorical": [
                    4816
                ],
                "values._reverse_indexer": [
                    4817
                ],
                "result.items": [
                    4820
                ],
                "new_values": [
                    4865,
                    4846,
                    4851,
                    4855,
                    4858,
                    4861
                ],
                "_map_values": [
                    4846
                ],
                "na_action": [
                    4846
                ],
                "new_values.size": [
                    4851,
                    4861
                ],
                "attributes.get": [
                    4854,
                    4855
                ],
                "algos.isin": [
                    4948
                ],
                "start_slice": [
                    5241,
                    4994,
                    4997,
                    5002,
                    5233,
                    5206,
                    5208,
                    5209,
                    5210,
                    5243,
                    5240
                ],
                "end_slice": [
                    5216,
                    4994,
                    4999,
                    5002,
                    5233,
                    5238,
                    5239,
                    5243,
                    5212,
                    5214,
                    5215
                ],
                "self.slice_locs": [
                    4994
                ],
                "end": [
                    4994,
                    5192,
                    5196,
                    5199,
                    5213,
                    5214
                ],
                "ckey": [
                    5012,
                    5013,
                    5014
                ],
                "self.searchsorted": [
                    5078
                ],
                "pos": [
                    5083,
                    5086
                ],
                "original_label": [
                    5116,
                    5142
                ],
                "self._maybe_cast_slice_bound": [
                    5120
                ],
                "slc": [
                    5152,
                    5154,
                    5124,
                    5132,
                    5135,
                    5136,
                    5138,
                    5139,
                    5145,
                    5147,
                    5149
                ],
                "lib.maybe_booleans_to_slice": [
                    5136
                ],
                "slc.view": [
                    5136
                ],
                "lib.maybe_indices_to_slice": [
                    5138
                ],
                "slc.astype": [
                    5138
                ],
                "slc.start": [
                    5147
                ],
                "slc.stop": [
                    5149
                ],
                "inc": [
                    5218,
                    5188,
                    5190
                ],
                "datetime": [
                    5403,
                    5196
                ],
                "ts_start": [
                    5203,
                    5198
                ],
                "Timestamp": [
                    5198,
                    5199
                ],
                "ts_end": [
                    5203,
                    5199
                ],
                "tz_compare": [
                    5203
                ],
                "ts_start.tzinfo": [
                    5203
                ],
                "ts_end.tzinfo": [
                    5203
                ],
                "self.get_slice_bound": [
                    5208,
                    5214
                ],
                "np.delete": [
                    5253
                ],
                "_self": [
                    5272,
                    5270
                ],
                "self._coerce_scalar_to_index": [
                    5271
                ],
                "np.concatenate": [
                    5272
                ],
                "arr_dtype": [
                    5294,
                    5295
                ],
                "com.index_labels_to_array": [
                    5295
                ],
                "errors": [
                    5299
                ],
                "self.delete": [
                    5302
                ],
                "cls.__eq__": [
                    5312
                ],
                "_make_comparison_op": [
                    5312,
                    5313,
                    5314,
                    5315,
                    5316,
                    5317
                ],
                "operator.eq": [
                    5312
                ],
                "cls.__ne__": [
                    5313
                ],
                "operator.ne": [
                    5313
                ],
                "cls.__lt__": [
                    5314
                ],
                "cls.__gt__": [
                    5315
                ],
                "operator.gt": [
                    5315
                ],
                "cls.__le__": [
                    5316
                ],
                "cls.__ge__": [
                    5317
                ],
                "operator.ge": [
                    5317
                ],
                "cls.__add__": [
                    5417,
                    5324
                ],
                "make_invalid_op": [
                    5579,
                    5324,
                    5325,
                    5326,
                    5327,
                    5328,
                    5329,
                    5580,
                    5336,
                    5337,
                    5338,
                    5339,
                    5340,
                    5341,
                    5342,
                    5343,
                    5344,
                    5345,
                    5346,
                    5347,
                    5348,
                    5349
                ],
                "cls.__radd__": [
                    5418,
                    5325
                ],
                "cls.__iadd__": [
                    5326
                ],
                "cls.__sub__": [
                    5419,
                    5327
                ],
                "cls.__rsub__": [
                    5328,
                    5420
                ],
                "cls.__isub__": [
                    5329
                ],
                "cls.__pow__": [
                    5336,
                    5422
                ],
                "cls.__rpow__": [
                    5337,
                    5421
                ],
                "cls.__mul__": [
                    5432,
                    5338
                ],
                "cls.__rmul__": [
                    5433,
                    5339
                ],
                "cls.__floordiv__": [
                    5340,
                    5429
                ],
                "cls.__rfloordiv__": [
                    5341,
                    5430
                ],
                "cls.__truediv__": [
                    5424,
                    5342
                ],
                "cls.__rtruediv__": [
                    5425,
                    5343
                ],
                "cls.__mod__": [
                    5344,
                    5428
                ],
                "cls.__divmod__": [
                    5345,
                    5431
                ],
                "cls.__neg__": [
                    5346,
                    5452
                ],
                "cls.__pos__": [
                    5347,
                    5453
                ],
                "cls.__abs__": [
                    5348,
                    5454
                ],
                "cls.__inv__": [
                    5349,
                    5455
                ],
                "opstr": [
                    5376,
                    5444,
                    5382,
                    5449,
                    5389,
                    5364
                ],
                "other._is_numeric_dtype": [
                    5386
                ],
                "other.item": [
                    5392
                ],
                "other.dtype.kind": [
                    5398
                ],
                "ABCDateOffset": [
                    5400
                ],
                "np.timedelta64": [
                    5400
                ],
                "timedelta": [
                    5400
                ],
                "np.datetime64": [
                    5403
                ],
                "_make_arithmetic_op": [
                    5417,
                    5418,
                    5419,
                    5420,
                    5421,
                    5422,
                    5424,
                    5425,
                    5428,
                    5429,
                    5430,
                    5431,
                    5432,
                    5433
                ],
                "operator.add": [
                    5417
                ],
                "ops.radd": [
                    5418
                ],
                "operator.sub": [
                    5419
                ],
                "ops.rsub": [
                    5420
                ],
                "ops.rpow": [
                    5421
                ],
                "operator.pow": [
                    5422
                ],
                "operator.truediv": [
                    5424
                ],
                "ops.rtruediv": [
                    5425
                ],
                "operator.mod": [
                    5428
                ],
                "operator.floordiv": [
                    5429
                ],
                "ops.rfloordiv": [
                    5430
                ],
                "operator.mul": [
                    5432
                ],
                "ops.rmul": [
                    5433
                ],
                "self._validate_for_numeric_unaryop": [
                    5444
                ],
                "_evaluate_numeric_unary.__name__": [
                    5449
                ],
                "_evaluate_numeric_unary": [
                    5449,
                    5450
                ],
                "_make_evaluate_unary": [
                    5452,
                    5453,
                    5454,
                    5455
                ],
                "operator.neg": [
                    5452
                ],
                "operator.pos": [
                    5453
                ],
                "np.abs": [
                    5454
                ],
                "cls._add_numeric_methods_unary": [
                    5459
                ],
                "cls._add_numeric_methods_binary": [
                    5460
                ],
                "_doc": [
                    5552,
                    5467
                ],
                "dedent": [
                    5482,
                    5524
                ],
                "f": [
                    5554
                ],
                "result.ndim": [
                    5557
                ],
                "result.dtype.type": [
                    5560
                ],
                "result.dtype": [
                    5560
                ],
                "result.item": [
                    5560
                ],
                "Substitution": [
                    5550
                ],
                "desc": [
                    5550
                ],
                "logical_func.__name__": [
                    5564
                ],
                "logical_func": [
                    5564,
                    5565
                ],
                "cls.all": [
                    5579,
                    5567
                ],
                "_make_logical_function": [
                    5570,
                    5567
                ],
                "np.all": [
                    5568
                ],
                "cls.any": [
                    5570,
                    5580
                ],
                "Index._add_numeric_methods_disabled": [
                    5590
                ],
                "Index._add_logical_methods": [
                    5591
                ],
                "Index._add_comparison_methods": [
                    5592
                ],
                "sequences": [
                    5633,
                    5628,
                    5631
                ],
                "MultiIndex.from_arrays": [
                    5633,
                    5689
                ],
                "index_like": [
                    5698,
                    5668,
                    5700,
                    5670,
                    5671,
                    5672,
                    5673,
                    5675,
                    5676,
                    5680,
                    5681,
                    5682,
                    5684,
                    5691
                ],
                "index_like.copy": [
                    5670
                ],
                "index_like.name": [
                    5673
                ],
                "converted": [
                    5689,
                    5691,
                    5684,
                    5686
                ],
                "all_arrays": [
                    5684,
                    5686
                ],
                "lib.clean_index_list": [
                    5684
                ],
                "seq": [
                    5712,
                    5708,
                    5710
                ],
                "trimmed": [
                    5720,
                    5721,
                    5722,
                    5719
                ],
                "strings": [
                    5720,
                    5719
                ],
                "n": [
                    5733
                ]
            }
        },
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_167/pandas/core/indexes/datetimes.py": {
            "buggy_functions": [],
            "snippets": [
                {
                    "snippet_code": "_engine_type = libindex.DatetimeEngine",
                    "start_line": 240,
                    "end_line": 241
                }
            ],
            "inscope_functions": [
                "def _new_DatetimeIndex(cls, d):\n    \"\"\" This is called upon unpickling, rather than the default which doesn't\n    have arguments and breaks __new__ \"\"\"\n\n    if \"data\" in d and not isinstance(d[\"data\"], DatetimeIndex):\n        # Avoid need to verify integrity by calling simple_new directly\n        data = d.pop(\"data\")\n        result = cls._simple_new(data, **d)\n    else:\n        with warnings.catch_warnings():\n            # we ignore warnings from passing verify_integrity=False\n            # TODO: If we knew what was going in to **d, we might be able to\n            #  go through _simple_new instead\n            warnings.simplefilter(\"ignore\")\n            result = cls.__new__(cls, verify_integrity=False, **d)\n\n    return result",
                "def date_range(\n    start=None,\n    end=None,\n    periods=None,\n    freq=None,\n    tz=None,\n    normalize=False,\n    name=None,\n    closed=None,\n    **kwargs\n):\n    \"\"\"\n    Return a fixed frequency DatetimeIndex.\n\n    Parameters\n    ----------\n    start : str or datetime-like, optional\n        Left bound for generating dates.\n    end : str or datetime-like, optional\n        Right bound for generating dates.\n    periods : integer, optional\n        Number of periods to generate.\n    freq : str or DateOffset, default 'D'\n        Frequency strings can have multiples, e.g. '5H'. See\n        :ref:`here <timeseries.offset_aliases>` for a list of\n        frequency aliases.\n    tz : str or tzinfo, optional\n        Time zone name for returning localized DatetimeIndex, for example\n        'Asia/Hong_Kong'. By default, the resulting DatetimeIndex is\n        timezone-naive.\n    normalize : bool, default False\n        Normalize start/end dates to midnight before generating date range.\n    name : str, default None\n        Name of the resulting DatetimeIndex.\n    closed : {None, 'left', 'right'}, optional\n        Make the interval closed with respect to the given frequency to\n        the 'left', 'right', or both sides (None, the default).\n    **kwargs\n        For compatibility. Has no effect on the result.\n\n    Returns\n    -------\n    rng : DatetimeIndex\n\n    See Also\n    --------\n    DatetimeIndex : An immutable container for datetimes.\n    timedelta_range : Return a fixed frequency TimedeltaIndex.\n    period_range : Return a fixed frequency PeriodIndex.\n    interval_range : Return a fixed frequency IntervalIndex.\n\n    Notes\n    -----\n    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\n    exactly three must be specified. If ``freq`` is omitted, the resulting\n    ``DatetimeIndex`` will have ``periods`` linearly spaced elements between\n    ``start`` and ``end`` (closed on both sides).\n\n    To learn more about the frequency strings, please see `this link\n    <http://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\n\n    Examples\n    --------\n    **Specifying the values**\n\n    The next four examples generate the same `DatetimeIndex`, but vary\n    the combination of `start`, `end` and `periods`.\n\n    Specify `start` and `end`, with the default daily frequency.\n\n    >>> pd.date_range(start='1/1/2018', end='1/08/2018')\n    DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04',\n                   '2018-01-05', '2018-01-06', '2018-01-07', '2018-01-08'],\n                  dtype='datetime64[ns]', freq='D')\n\n    Specify `start` and `periods`, the number of periods (days).\n\n    >>> pd.date_range(start='1/1/2018', periods=8)\n    DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04',\n                   '2018-01-05', '2018-01-06', '2018-01-07', '2018-01-08'],\n                  dtype='datetime64[ns]', freq='D')\n\n    Specify `end` and `periods`, the number of periods (days).\n\n    >>> pd.date_range(end='1/1/2018', periods=8)\n    DatetimeIndex(['2017-12-25', '2017-12-26', '2017-12-27', '2017-12-28',\n                   '2017-12-29', '2017-12-30', '2017-12-31', '2018-01-01'],\n                  dtype='datetime64[ns]', freq='D')\n\n    Specify `start`, `end`, and `periods`; the frequency is generated\n    automatically (linearly spaced).\n\n    >>> pd.date_range(start='2018-04-24', end='2018-04-27', periods=3)\n    DatetimeIndex(['2018-04-24 00:00:00', '2018-04-25 12:00:00',\n                   '2018-04-27 00:00:00'],\n                  dtype='datetime64[ns]', freq=None)\n\n    **Other Parameters**\n\n    Changed the `freq` (frequency) to ``'M'`` (month end frequency).\n\n    >>> pd.date_range(start='1/1/2018', periods=5, freq='M')\n    DatetimeIndex(['2018-01-31', '2018-02-28', '2018-03-31', '2018-04-30',\n                   '2018-05-31'],\n                  dtype='datetime64[ns]', freq='M')\n\n    Multiples are allowed\n\n    >>> pd.date_range(start='1/1/2018', periods=5, freq='3M')\n    DatetimeIndex(['2018-01-31', '2018-04-30', '2018-07-31', '2018-10-31',\n                   '2019-01-31'],\n                  dtype='datetime64[ns]', freq='3M')\n\n    `freq` can also be specified as an Offset object.\n\n    >>> pd.date_range(start='1/1/2018', periods=5, freq=pd.offsets.MonthEnd(3))\n    DatetimeIndex(['2018-01-31', '2018-04-30', '2018-07-31', '2018-10-31',\n                   '2019-01-31'],\n                  dtype='datetime64[ns]', freq='3M')\n\n    Specify `tz` to set the timezone.\n\n    >>> pd.date_range(start='1/1/2018', periods=5, tz='Asia/Tokyo')\n    DatetimeIndex(['2018-01-01 00:00:00+09:00', '2018-01-02 00:00:00+09:00',\n                   '2018-01-03 00:00:00+09:00', '2018-01-04 00:00:00+09:00',\n                   '2018-01-05 00:00:00+09:00'],\n                  dtype='datetime64[ns, Asia/Tokyo]', freq='D')\n\n    `closed` controls whether to include `start` and `end` that are on the\n    boundary. The default includes boundary points on either end.\n\n    >>> pd.date_range(start='2017-01-01', end='2017-01-04', closed=None)\n    DatetimeIndex(['2017-01-01', '2017-01-02', '2017-01-03', '2017-01-04'],\n                  dtype='datetime64[ns]', freq='D')\n\n    Use ``closed='left'`` to exclude `end` if it falls on the boundary.\n\n    >>> pd.date_range(start='2017-01-01', end='2017-01-04', closed='left')\n    DatetimeIndex(['2017-01-01', '2017-01-02', '2017-01-03'],\n                  dtype='datetime64[ns]', freq='D')\n\n    Use ``closed='right'`` to exclude `start` if it falls on the boundary.\n\n    >>> pd.date_range(start='2017-01-01', end='2017-01-04', closed='right')\n    DatetimeIndex(['2017-01-02', '2017-01-03', '2017-01-04'],\n                  dtype='datetime64[ns]', freq='D')\n    \"\"\"\n\n    if freq is None and com.any_none(periods, start, end):\n        freq = \"D\"\n\n    dtarr = DatetimeArray._generate_range(\n        start=start,\n        end=end,\n        periods=periods,\n        freq=freq,\n        tz=tz,\n        normalize=normalize,\n        closed=closed,\n        **kwargs\n    )\n    return DatetimeIndex._simple_new(dtarr, tz=dtarr.tz, freq=dtarr.freq, name=name)",
                "def bdate_range(\n    start=None,\n    end=None,\n    periods=None,\n    freq=\"B\",\n    tz=None,\n    normalize=True,\n    name=None,\n    weekmask=None,\n    holidays=None,\n    closed=None,\n    **kwargs\n):\n    \"\"\"\n    Return a fixed frequency DatetimeIndex, with business day as the default\n    frequency\n\n    Parameters\n    ----------\n    start : string or datetime-like, default None\n        Left bound for generating dates.\n    end : string or datetime-like, default None\n        Right bound for generating dates.\n    periods : integer, default None\n        Number of periods to generate.\n    freq : string or DateOffset, default 'B' (business daily)\n        Frequency strings can have multiples, e.g. '5H'.\n    tz : string or None\n        Time zone name for returning localized DatetimeIndex, for example\n        Asia/Beijing.\n    normalize : bool, default False\n        Normalize start/end dates to midnight before generating date range.\n    name : string, default None\n        Name of the resulting DatetimeIndex.\n    weekmask : string or None, default None\n        Weekmask of valid business days, passed to ``numpy.busdaycalendar``,\n        only used when custom frequency strings are passed.  The default\n        value None is equivalent to 'Mon Tue Wed Thu Fri'.\n\n        .. versionadded:: 0.21.0\n\n    holidays : list-like or None, default None\n        Dates to exclude from the set of valid business days, passed to\n        ``numpy.busdaycalendar``, only used when custom frequency strings\n        are passed.\n\n        .. versionadded:: 0.21.0\n\n    closed : string, default None\n        Make the interval closed with respect to the given frequency to\n        the 'left', 'right', or both sides (None).\n    **kwargs\n        For compatibility. Has no effect on the result.\n\n    Returns\n    -------\n    DatetimeIndex\n\n    Notes\n    -----\n    Of the four parameters: ``start``, ``end``, ``periods``, and ``freq``,\n    exactly three must be specified.  Specifying ``freq`` is a requirement\n    for ``bdate_range``.  Use ``date_range`` if specifying ``freq`` is not\n    desired.\n\n    To learn more about the frequency strings, please see `this link\n    <http://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\n\n    Examples\n    --------\n    Note how the two weekend days are skipped in the result.\n\n    >>> pd.bdate_range(start='1/1/2018', end='1/08/2018')\n    DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04',\n               '2018-01-05', '2018-01-08'],\n              dtype='datetime64[ns]', freq='B')\n    \"\"\"\n    if freq is None:\n        msg = \"freq must be specified for bdate_range; use date_range instead\"\n        raise TypeError(msg)\n\n    if is_string_like(freq) and freq.startswith(\"C\"):\n        try:\n            weekmask = weekmask or \"Mon Tue Wed Thu Fri\"\n            freq = prefix_mapping[freq](holidays=holidays, weekmask=weekmask)\n        except (KeyError, TypeError):\n            msg = \"invalid custom frequency string: {freq}\".format(freq=freq)\n            raise ValueError(msg)\n    elif holidays or weekmask:\n        msg = (\n            \"a custom frequency string is required when holidays or \"\n            \"weekmask are passed, got frequency {freq}\"\n        ).format(freq=freq)\n        raise ValueError(msg)\n\n    return date_range(\n        start=start,\n        end=end,\n        periods=periods,\n        freq=freq,\n        tz=tz,\n        normalize=normalize,\n        name=name,\n        closed=closed,\n        **kwargs\n    )",
                "def _time_to_micros(time):\n    seconds = time.hour * 60 * 60 + 60 * time.minute + time.second\n    return 1000000 * seconds + time.microsecond",
                "def _join_i8_wrapper(joinf, **kwargs):\n    return DatetimeIndexOpsMixin._join_i8_wrapper(joinf, dtype=\"M8[ns]\", **kwargs)",
                "def __new__(\n    cls,\n    data=None,\n    freq=None,\n    start=None,\n    end=None,\n    periods=None,\n    tz=None,\n    normalize=False,\n    closed=None,\n    ambiguous=\"raise\",\n    dayfirst=False,\n    yearfirst=False,\n    dtype=None,\n    copy=False,\n    name=None,\n    verify_integrity=None,\n):\n\n    if verify_integrity is not None:\n        warnings.warn(\n            \"The 'verify_integrity' argument is deprecated, \"\n            \"will be removed in a future version.\",\n            FutureWarning,\n            stacklevel=2,\n        )\n    else:\n        verify_integrity = True\n\n    if data is None:\n        dtarr = DatetimeArray._generate_range(\n            start,\n            end,\n            periods,\n            freq=freq,\n            tz=tz,\n            normalize=normalize,\n            closed=closed,\n            ambiguous=ambiguous,\n        )\n        warnings.warn(\n            \"Creating a DatetimeIndex by passing range \"\n            \"endpoints is deprecated.  Use \"\n            \"`pandas.date_range` instead.\",\n            FutureWarning,\n            stacklevel=2,\n        )\n        return cls._simple_new(dtarr._data, freq=dtarr.freq, tz=dtarr.tz, name=name)\n\n    if is_scalar(data):\n        raise TypeError(\n            \"{cls}() must be called with a \"\n            \"collection of some kind, {data} was passed\".format(\n                cls=cls.__name__, data=repr(data)\n            )\n        )\n\n    # - Cases checked above all return/raise before reaching here - #\n\n    if name is None and hasattr(data, \"name\"):\n        name = data.name\n\n    dtarr = DatetimeArray._from_sequence(\n        data,\n        dtype=dtype,\n        copy=copy,\n        tz=tz,\n        freq=freq,\n        dayfirst=dayfirst,\n        yearfirst=yearfirst,\n        ambiguous=ambiguous,\n        int_as_wall_time=True,\n    )\n\n    subarr = cls._simple_new(dtarr, name=name, freq=dtarr.freq, tz=dtarr.tz)\n    return subarr",
                "@classmethod\ndef _simple_new(cls, values, name=None, freq=None, tz=None, dtype=None):\n    \"\"\"\n    we require the we have a dtype compat for the values\n    if we are passed a non-dtype compat, then coerce using the constructor\n    \"\"\"\n    if isinstance(values, DatetimeArray):\n        if tz:\n            tz = validate_tz_from_dtype(dtype, tz)\n            dtype = DatetimeTZDtype(tz=tz)\n        elif dtype is None:\n            dtype = _NS_DTYPE\n\n        values = DatetimeArray(values, freq=freq, dtype=dtype)\n        tz = values.tz\n        freq = values.freq\n        values = values._data\n\n    # DatetimeArray._simple_new will accept either i8 or M8[ns] dtypes\n    if isinstance(values, DatetimeIndex):\n        values = values._data\n\n    dtype = tz_to_dtype(tz)\n    dtarr = DatetimeArray._simple_new(values, freq=freq, dtype=dtype)\n    assert isinstance(dtarr, DatetimeArray)\n\n    result = object.__new__(cls)\n    result._data = dtarr\n    result.name = name\n    # For groupby perf. See note in indexes/base about _index_data\n    result._index_data = dtarr._data\n    result._reset_identity()\n    return result",
                "def __array__(self, dtype=None):\n    if (\n        dtype is None\n        and isinstance(self._data, DatetimeArray)\n        and getattr(self.dtype, \"tz\", None)\n    ):\n        msg = (\n            \"Converting timezone-aware DatetimeArray to timezone-naive \"\n            \"ndarray with 'datetime64[ns]' dtype. In the future, this \"\n            \"will return an ndarray with 'object' dtype where each \"\n            \"element is a 'pandas.Timestamp' with the correct 'tz'.\\n\\t\"\n            \"To accept the future behavior, pass 'dtype=object'.\\n\\t\"\n            \"To keep the old behavior, pass 'dtype=\\\"datetime64[ns]\\\"'.\"\n        )\n        warnings.warn(msg, FutureWarning, stacklevel=3)\n        dtype = \"M8[ns]\"\n    return np.asarray(self._data, dtype=dtype)",
                "@property\ndef dtype(self):\n    return self._data.dtype",
                "@property\ndef tz(self):\n    # GH 18595\n    return self._data.tz",
                "@tz.setter\ndef tz(self, value):\n    # GH 3746: Prevent localizing or converting the index by setting tz\n    raise AttributeError(\n        \"Cannot directly set timezone. Use tz_localize() \"\n        \"or tz_convert() as appropriate\"\n    )",
                "@cache_readonly\ndef _is_dates_only(self):\n    \"\"\"Return a boolean if we are only dates (and don't have a timezone)\"\"\"\n    from pandas.io.formats.format import _is_dates_only\n\n    return _is_dates_only(self.values) and self.tz is None",
                "def __reduce__(self):\n\n    # we use a special reduce here because we need\n    # to simply set the .tz (and not reinterpret it)\n\n    d = dict(data=self._data)\n    d.update(self._get_attributes_dict())\n    return _new_DatetimeIndex, (self.__class__, d), None",
                "def __setstate__(self, state):\n    \"\"\"Necessary for making this object picklable\"\"\"\n    if isinstance(state, dict):\n        super().__setstate__(state)\n\n    elif isinstance(state, tuple):\n\n        # < 0.15 compat\n        if len(state) == 2:\n            nd_state, own_state = state\n            data = np.empty(nd_state[1], dtype=nd_state[2])\n            np.ndarray.__setstate__(data, nd_state)\n\n            freq = own_state[1]\n            tz = timezones.tz_standardize(own_state[2])\n            dtype = tz_to_dtype(tz)\n            dtarr = DatetimeArray._simple_new(data, freq=freq, dtype=dtype)\n\n            self.name = own_state[0]\n\n        else:  # pragma: no cover\n            data = np.empty(state)\n            np.ndarray.__setstate__(data, state)\n            dtarr = DatetimeArray(data)\n\n        self._data = dtarr\n        self._reset_identity()\n\n    else:\n        raise Exception(\"invalid pickle state\")",
                "def _convert_for_op(self, value):\n    \"\"\" Convert value to be insertable to ndarray \"\"\"\n    if self._has_same_tz(value):\n        return _to_M8(value)\n    raise ValueError(\"Passed item and index have different timezone\")",
                "def _maybe_update_attributes(self, attrs):\n    \"\"\" Update Index attributes (e.g. freq) depending on op \"\"\"\n    freq = attrs.get(\"freq\", None)\n    if freq is not None:\n        # no need to infer if freq is None\n        attrs[\"freq\"] = \"infer\"\n    return attrs",
                "def _mpl_repr(self):\n    # how to represent ourselves to matplotlib\n    return libts.ints_to_pydatetime(self.asi8, self.tz)",
                "def _format_native_types(self, na_rep=\"NaT\", date_format=None, **kwargs):\n    from pandas.io.formats.format import _get_format_datetime64_from_values\n\n    fmt = _get_format_datetime64_from_values(self, date_format)\n\n    return libts.format_array_from_datetime(\n        self.asi8, tz=self.tz, format=fmt, na_rep=na_rep\n    )",
                "@property\ndef _formatter_func(self):\n    from pandas.io.formats.format import _get_format_datetime64\n\n    formatter = _get_format_datetime64(is_dates_only=self._is_dates_only)\n    return lambda x: \"'%s'\" % formatter(x, tz=self.tz)",
                "def _union(self, other, sort):\n    if not len(other) or self.equals(other) or not len(self):\n        return super()._union(other, sort=sort)\n\n    if len(other) == 0 or self.equals(other) or len(self) == 0:\n        return super().union(other, sort=sort)\n\n    if not isinstance(other, DatetimeIndex):\n        try:\n            other = DatetimeIndex(other)\n        except TypeError:\n            pass\n\n    this, other = self._maybe_utc_convert(other)\n\n    if this._can_fast_union(other):\n        return this._fast_union(other, sort=sort)\n    else:\n        result = Index._union(this, other, sort=sort)\n        if isinstance(result, DatetimeIndex):\n            # TODO: we shouldn't be setting attributes like this;\n            #  in all the tests this equality already holds\n            result._data._dtype = this.dtype\n            if result.freq is None and (\n                this.freq is not None or other.freq is not None\n            ):\n                result.freq = to_offset(result.inferred_freq)\n        return result",
                "def union_many(self, others):\n    \"\"\"\n    A bit of a hack to accelerate unioning a collection of indexes\n    \"\"\"\n    this = self\n\n    for other in others:\n        if not isinstance(this, DatetimeIndex):\n            this = Index.union(this, other)\n            continue\n\n        if not isinstance(other, DatetimeIndex):\n            try:\n                other = DatetimeIndex(other)\n            except TypeError:\n                pass\n\n        this, other = this._maybe_utc_convert(other)\n\n        if this._can_fast_union(other):\n            this = this._fast_union(other)\n        else:\n            dtype = this.dtype\n            this = Index.union(this, other)\n            if isinstance(this, DatetimeIndex):\n                # TODO: we shouldn't be setting attributes like this;\n                #  in all the tests this equality already holds\n                this._data._dtype = dtype\n    return this",
                "def _can_fast_union(self, other):\n    if not isinstance(other, DatetimeIndex):\n        return False\n\n    freq = self.freq\n\n    if freq is None or freq != other.freq:\n        return False\n\n    if not self.is_monotonic or not other.is_monotonic:\n        return False\n\n    if len(self) == 0 or len(other) == 0:\n        return True\n\n    # to make our life easier, \"sort\" the two ranges\n    if self[0] <= other[0]:\n        left, right = self, other\n    else:\n        left, right = other, self\n\n    right_start = right[0]\n    left_end = left[-1]\n\n    # Only need to \"adjoin\", not overlap\n    try:\n        return (right_start == left_end + freq) or right_start in left\n    except (ValueError):\n\n        # if we are comparing a freq that does not propagate timezones\n        # this will raise\n        return False",
                "def _fast_union(self, other, sort=None):\n    if len(other) == 0:\n        return self.view(type(self))\n\n    if len(self) == 0:\n        return other.view(type(self))\n\n    # Both DTIs are monotonic. Check if they are already\n    # in the \"correct\" order\n    if self[0] <= other[0]:\n        left, right = self, other\n    # DTIs are not in the \"correct\" order and we don't want\n    # to sort but want to remove overlaps\n    elif sort is False:\n        left, right = self, other\n        left_start = left[0]\n        loc = right.searchsorted(left_start, side=\"left\")\n        right_chunk = right.values[:loc]\n        dates = concat_compat((left.values, right_chunk))\n        return self._shallow_copy(dates)\n    # DTIs are not in the \"correct\" order and we want\n    # to sort\n    else:\n        left, right = other, self\n\n    left_end = left[-1]\n    right_end = right[-1]\n\n    # TODO: consider re-implementing freq._should_cache for fastpath\n\n    # concatenate dates\n    if left_end < right_end:\n        loc = right.searchsorted(left_end, side=\"right\")\n        right_chunk = right.values[loc:]\n        dates = concat_compat((left.values, right_chunk))\n        return self._shallow_copy(dates)\n    else:\n        return left",
                "def intersection(self, other, sort=False):\n    \"\"\"\n    Specialized intersection for DatetimeIndex objects.\n    May be much faster than Index.intersection\n\n    Parameters\n    ----------\n    other : DatetimeIndex or array-like\n    sort : False or None, default False\n        Sort the resulting index if possible.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default to ``False`` to match the behaviour\n           from before 0.24.0.\n\n    Returns\n    -------\n    y : Index or DatetimeIndex or TimedeltaIndex\n    \"\"\"\n    return super().intersection(other, sort=sort)",
                "def _wrap_setop_result(self, other, result):\n    name = get_op_result_name(self, other)\n    return self._shallow_copy(result, name=name, freq=None, tz=self.tz)",
                "def _get_time_micros(self):\n    values = self.asi8\n    if self.tz is not None and not timezones.is_utc(self.tz):\n        values = self._data._local_timestamps()\n    return fields.get_time_micros(values)",
                "def to_series(self, keep_tz=None, index=None, name=None):\n    \"\"\"\n    Create a Series with both index and values equal to the index keys\n    useful with map for returning an indexer based on an index\n\n    Parameters\n    ----------\n    keep_tz : optional, defaults False\n        Return the data keeping the timezone.\n\n        If keep_tz is True:\n\n          If the timezone is not set, the resulting\n          Series will have a datetime64[ns] dtype.\n\n          Otherwise the Series will have an datetime64[ns, tz] dtype; the\n          tz will be preserved.\n\n        If keep_tz is False:\n\n          Series will have a datetime64[ns] dtype. TZ aware\n          objects will have the tz removed.\n\n        .. versionchanged:: 0.24\n            The default value will change to True in a future release.\n            You can set ``keep_tz=True`` to already obtain the future\n            behaviour and silence the warning.\n\n    index : Index, optional\n        index of resulting Series. If None, defaults to original index\n    name : string, optional\n        name of resulting Series. If None, defaults to name of original\n        index\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series\n\n    if index is None:\n        index = self._shallow_copy()\n    if name is None:\n        name = self.name\n\n    if keep_tz is None and self.tz is not None:\n        warnings.warn(\n            \"The default of the 'keep_tz' keyword in \"\n            \"DatetimeIndex.to_series will change \"\n            \"to True in a future release. You can set \"\n            \"'keep_tz=True' to obtain the future behaviour and \"\n            \"silence this warning.\",\n            FutureWarning,\n            stacklevel=2,\n        )\n        keep_tz = False\n    elif keep_tz is False:\n        warnings.warn(\n            \"Specifying 'keep_tz=False' is deprecated and this \"\n            \"option will be removed in a future release. If \"\n            \"you want to remove the timezone information, you \"\n            \"can do 'idx.tz_convert(None)' before calling \"\n            \"'to_series'.\",\n            FutureWarning,\n            stacklevel=2,\n        )\n\n    if keep_tz and self.tz is not None:\n        # preserve the tz & copy\n        values = self.copy(deep=True)\n    else:\n        values = self.values.copy()\n\n    return Series(values, index=index, name=name)",
                "def snap(self, freq=\"S\"):\n    \"\"\"\n    Snap time stamps to nearest occurring frequency\n\n    Returns\n    -------\n    DatetimeIndex\n    \"\"\"\n    # Superdumb, punting on any optimizing\n    freq = to_offset(freq)\n\n    snapped = np.empty(len(self), dtype=_NS_DTYPE)\n\n    for i, v in enumerate(self):\n        s = v\n        if not freq.onOffset(s):\n            t0 = freq.rollback(s)\n            t1 = freq.rollforward(s)\n            if abs(s - t0) < abs(t1 - s):\n                s = t0\n            else:\n                s = t1\n        snapped[i] = s\n\n    # we know it conforms; skip check\n    return DatetimeIndex._simple_new(snapped, name=self.name, tz=self.tz, freq=freq)",
                "def join(self, other, how=\"left\", level=None, return_indexers=False, sort=False):\n    \"\"\"\n    See Index.join\n    \"\"\"\n    if (\n        not isinstance(other, DatetimeIndex)\n        and len(other) > 0\n        and other.inferred_type\n        not in (\n            \"floating\",\n            \"integer\",\n            \"integer-na\",\n            \"mixed-integer\",\n            \"mixed-integer-float\",\n            \"mixed\",\n        )\n    ):\n        try:\n            other = DatetimeIndex(other)\n        except (TypeError, ValueError):\n            pass\n\n    this, other = self._maybe_utc_convert(other)\n    return Index.join(\n        this,\n        other,\n        how=how,\n        level=level,\n        return_indexers=return_indexers,\n        sort=sort,\n    )",
                "def _maybe_utc_convert(self, other):\n    this = self\n    if isinstance(other, DatetimeIndex):\n        if self.tz is not None:\n            if other.tz is None:\n                raise TypeError(\"Cannot join tz-naive with tz-aware DatetimeIndex\")\n        elif other.tz is not None:\n            raise TypeError(\"Cannot join tz-naive with tz-aware DatetimeIndex\")\n\n        if not timezones.tz_compare(self.tz, other.tz):\n            this = self.tz_convert(\"UTC\")\n            other = other.tz_convert(\"UTC\")\n    return this, other",
                "def _wrap_joined_index(self, joined, other):\n    name = get_op_result_name(self, other)\n    if (\n        isinstance(other, DatetimeIndex)\n        and self.freq == other.freq\n        and self._can_fast_union(other)\n    ):\n        joined = self._shallow_copy(joined)\n        joined.name = name\n        return joined\n    else:\n        tz = getattr(other, \"tz\", None)\n        return self._simple_new(joined, name, tz=tz)",
                "def _parsed_string_to_bounds(self, reso, parsed):\n    \"\"\"\n    Calculate datetime bounds for parsed time string and its resolution.\n\n    Parameters\n    ----------\n    reso : Resolution\n        Resolution provided by parsed string.\n    parsed : datetime\n        Datetime from parsed string.\n\n    Returns\n    -------\n    lower, upper: pd.Timestamp\n\n    \"\"\"\n    valid_resos = {\n        \"year\",\n        \"month\",\n        \"quarter\",\n        \"day\",\n        \"hour\",\n        \"minute\",\n        \"second\",\n        \"minute\",\n        \"second\",\n        \"microsecond\",\n    }\n    if reso not in valid_resos:\n        raise KeyError\n    if reso == \"year\":\n        start = Timestamp(parsed.year, 1, 1)\n        end = Timestamp(parsed.year, 12, 31, 23, 59, 59, 999999)\n    elif reso == \"month\":\n        d = ccalendar.get_days_in_month(parsed.year, parsed.month)\n        start = Timestamp(parsed.year, parsed.month, 1)\n        end = Timestamp(parsed.year, parsed.month, d, 23, 59, 59, 999999)\n    elif reso == \"quarter\":\n        qe = (((parsed.month - 1) + 2) % 12) + 1  # two months ahead\n        d = ccalendar.get_days_in_month(parsed.year, qe)  # at end of month\n        start = Timestamp(parsed.year, parsed.month, 1)\n        end = Timestamp(parsed.year, qe, d, 23, 59, 59, 999999)\n    elif reso == \"day\":\n        start = Timestamp(parsed.year, parsed.month, parsed.day)\n        end = start + timedelta(days=1) - Nano(1)\n    elif reso == \"hour\":\n        start = Timestamp(parsed.year, parsed.month, parsed.day, parsed.hour)\n        end = start + timedelta(hours=1) - Nano(1)\n    elif reso == \"minute\":\n        start = Timestamp(\n            parsed.year, parsed.month, parsed.day, parsed.hour, parsed.minute\n        )\n        end = start + timedelta(minutes=1) - Nano(1)\n    elif reso == \"second\":\n        start = Timestamp(\n            parsed.year,\n            parsed.month,\n            parsed.day,\n            parsed.hour,\n            parsed.minute,\n            parsed.second,\n        )\n        end = start + timedelta(seconds=1) - Nano(1)\n    elif reso == \"microsecond\":\n        start = Timestamp(\n            parsed.year,\n            parsed.month,\n            parsed.day,\n            parsed.hour,\n            parsed.minute,\n            parsed.second,\n            parsed.microsecond,\n        )\n        end = start + timedelta(microseconds=1) - Nano(1)\n    # GH 24076\n    # If an incoming date string contained a UTC offset, need to localize\n    # the parsed date to this offset first before aligning with the index's\n    # timezone\n    if parsed.tzinfo is not None:\n        if self.tz is None:\n            raise ValueError(\n                \"The index must be timezone aware \"\n                \"when indexing with a date string with a \"\n                \"UTC offset\"\n            )\n        start = start.tz_localize(parsed.tzinfo).tz_convert(self.tz)\n        end = end.tz_localize(parsed.tzinfo).tz_convert(self.tz)\n    elif self.tz is not None:\n        start = start.tz_localize(self.tz)\n        end = end.tz_localize(self.tz)\n    return start, end",
                "def _partial_date_slice(self, reso, parsed, use_lhs=True, use_rhs=True):\n    is_monotonic = self.is_monotonic\n    if (\n        is_monotonic\n        and reso in [\"day\", \"hour\", \"minute\", \"second\"]\n        and self._resolution >= Resolution.get_reso(reso)\n    ):\n        # These resolution/monotonicity validations came from GH3931,\n        # GH3452 and GH2369.\n\n        # See also GH14826\n        raise KeyError\n\n    if reso == \"microsecond\":\n        # _partial_date_slice doesn't allow microsecond resolution, but\n        # _parsed_string_to_bounds allows it.\n        raise KeyError\n\n    t1, t2 = self._parsed_string_to_bounds(reso, parsed)\n    stamps = self.asi8\n\n    if is_monotonic:\n\n        # we are out of range\n        if len(stamps) and (\n            (use_lhs and t1.value < stamps[0] and t2.value < stamps[0])\n            or ((use_rhs and t1.value > stamps[-1] and t2.value > stamps[-1]))\n        ):\n            raise KeyError\n\n        # a monotonic (sorted) series can be sliced\n        left = stamps.searchsorted(t1.value, side=\"left\") if use_lhs else None\n        right = stamps.searchsorted(t2.value, side=\"right\") if use_rhs else None\n\n        return slice(left, right)\n\n    lhs_mask = (stamps >= t1.value) if use_lhs else True\n    rhs_mask = (stamps <= t2.value) if use_rhs else True\n\n    # try to find a the dates\n    return (lhs_mask & rhs_mask).nonzero()[0]",
                "def _maybe_promote(self, other):\n    if other.inferred_type == \"date\":\n        other = DatetimeIndex(other)\n    return self, other",
                "def get_value(self, series, key):\n    \"\"\"\n    Fast lookup of value from 1-dimensional ndarray. Only use this if you\n    know what you're doing\n    \"\"\"\n\n    if isinstance(key, datetime):\n\n        # needed to localize naive datetimes\n        if self.tz is not None:\n            if key.tzinfo is not None:\n                key = Timestamp(key).tz_convert(self.tz)\n            else:\n                key = Timestamp(key).tz_localize(self.tz)\n\n        return self.get_value_maybe_box(series, key)\n\n    if isinstance(key, time):\n        locs = self.indexer_at_time(key)\n        return series.take(locs)\n\n    try:\n        return com.maybe_box(self, Index.get_value(self, series, key), series, key)\n    except KeyError:\n        try:\n            loc = self._get_string_slice(key)\n            return series[loc]\n        except (TypeError, ValueError, KeyError):\n            pass\n\n        try:\n            return self.get_value_maybe_box(series, key)\n        except (TypeError, ValueError, KeyError):\n            raise KeyError(key)",
                "def get_value_maybe_box(self, series, key):\n    # needed to localize naive datetimes\n    if self.tz is not None:\n        key = Timestamp(key)\n        if key.tzinfo is not None:\n            key = key.tz_convert(self.tz)\n        else:\n            key = key.tz_localize(self.tz)\n    elif not isinstance(key, Timestamp):\n        key = Timestamp(key)\n    values = self._engine.get_value(com.values_from_object(series), key, tz=self.tz)\n    return com.maybe_box(self, values, series, key)",
                "def get_loc(self, key, method=None, tolerance=None):\n    \"\"\"\n    Get integer location for requested label\n\n    Returns\n    -------\n    loc : int\n    \"\"\"\n\n    if tolerance is not None:\n        # try converting tolerance now, so errors don't get swallowed by\n        # the try/except clauses below\n        tolerance = self._convert_tolerance(tolerance, np.asarray(key))\n\n    if isinstance(key, datetime):\n        # needed to localize naive datetimes\n        if key.tzinfo is None:\n            key = Timestamp(key, tz=self.tz)\n        else:\n            key = Timestamp(key).tz_convert(self.tz)\n        return Index.get_loc(self, key, method, tolerance)\n\n    elif isinstance(key, timedelta):\n        # GH#20464\n        raise TypeError(\n            \"Cannot index {cls} with {other}\".format(\n                cls=type(self).__name__, other=type(key).__name__\n            )\n        )\n\n    if isinstance(key, time):\n        if method is not None:\n            raise NotImplementedError(\n                \"cannot yet lookup inexact labels when key is a time object\"\n            )\n        return self.indexer_at_time(key)\n\n    try:\n        return Index.get_loc(self, key, method, tolerance)\n    except (KeyError, ValueError, TypeError):\n        try:\n            return self._get_string_slice(key)\n        except (TypeError, KeyError, ValueError, OverflowError):\n            pass\n\n        try:\n            stamp = Timestamp(key)\n            if stamp.tzinfo is not None and self.tz is not None:\n                stamp = stamp.tz_convert(self.tz)\n            else:\n                stamp = stamp.tz_localize(self.tz)\n            return Index.get_loc(self, stamp, method, tolerance)\n        except KeyError:\n            raise KeyError(key)\n        except ValueError as e:\n            # list-like tolerance size must match target index size\n            if \"list-like\" in str(e):\n                raise e\n            raise KeyError(key)",
                "def _maybe_cast_slice_bound(self, label, side, kind):\n    \"\"\"\n    If label is a string, cast it to datetime according to resolution.\n\n    Parameters\n    ----------\n    label : object\n    side : {'left', 'right'}\n    kind : {'ix', 'loc', 'getitem'}\n\n    Returns\n    -------\n    label :  object\n\n    Notes\n    -----\n    Value of `side` parameter should be validated in caller.\n\n    \"\"\"\n    assert kind in [\"ix\", \"loc\", \"getitem\", None]\n\n    if is_float(label) or isinstance(label, time) or is_integer(label):\n        self._invalid_indexer(\"slice\", label)\n\n    if isinstance(label, str):\n        freq = getattr(self, \"freqstr\", getattr(self, \"inferred_freq\", None))\n        _, parsed, reso = parsing.parse_time_string(label, freq)\n        lower, upper = self._parsed_string_to_bounds(reso, parsed)\n        # lower, upper form the half-open interval:\n        #   [parsed, parsed + 1 freq)\n        # because label may be passed to searchsorted\n        # the bounds need swapped if index is reverse sorted and has a\n        # length > 1 (is_monotonic_decreasing gives True for empty\n        # and length 1 index)\n        if self._is_strictly_monotonic_decreasing and len(self) > 1:\n            return upper if side == \"left\" else lower\n        return lower if side == \"left\" else upper\n    else:\n        return label",
                "def _get_string_slice(self, key, use_lhs=True, use_rhs=True):\n    freq = getattr(self, \"freqstr\", getattr(self, \"inferred_freq\", None))\n    _, parsed, reso = parsing.parse_time_string(key, freq)\n    loc = self._partial_date_slice(reso, parsed, use_lhs=use_lhs, use_rhs=use_rhs)\n    return loc",
                "def slice_indexer(self, start=None, end=None, step=None, kind=None):\n    \"\"\"\n    Return indexer for specified label slice.\n    Index.slice_indexer, customized to handle time slicing.\n\n    In addition to functionality provided by Index.slice_indexer, does the\n    following:\n\n    - if both `start` and `end` are instances of `datetime.time`, it\n      invokes `indexer_between_time`\n    - if `start` and `end` are both either string or None perform\n      value-based selection in non-monotonic cases.\n\n    \"\"\"\n    # For historical reasons DatetimeIndex supports slices between two\n    # instances of datetime.time as if it were applying a slice mask to\n    # an array of (self.hour, self.minute, self.seconds, self.microsecond).\n    if isinstance(start, time) and isinstance(end, time):\n        if step is not None and step != 1:\n            raise ValueError(\"Must have step size of 1 with time slices\")\n        return self.indexer_between_time(start, end)\n\n    if isinstance(start, time) or isinstance(end, time):\n        raise KeyError(\"Cannot mix time and non-time slice keys\")\n\n    try:\n        return Index.slice_indexer(self, start, end, step, kind=kind)\n    except KeyError:\n        # For historical reasons DatetimeIndex by default supports\n        # value-based partial (aka string) slices on non-monotonic arrays,\n        # let's try that.\n        if (start is None or isinstance(start, str)) and (\n            end is None or isinstance(end, str)\n        ):\n            mask = True\n            if start is not None:\n                start_casted = self._maybe_cast_slice_bound(start, \"left\", kind)\n                mask = start_casted <= self\n\n            if end is not None:\n                end_casted = self._maybe_cast_slice_bound(end, \"right\", kind)\n                mask = (self <= end_casted) & mask\n\n            indexer = mask.nonzero()[0][::step]\n            if len(indexer) == len(self):\n                return slice(None)\n            else:\n                return indexer\n        else:\n            raise",
                "@property\ndef offset(self):\n    \"\"\"\n    get/set the frequency of the instance\n    \"\"\"\n    msg = (\n        \"{cls}.offset has been deprecated and will be removed \"\n        \"in a future version; use {cls}.freq instead.\".format(\n            cls=type(self).__name__\n        )\n    )\n    warnings.warn(msg, FutureWarning, stacklevel=2)\n    return self.freq",
                "@offset.setter\ndef offset(self, value):\n    \"\"\"\n    get/set the frequency of the instance\n    \"\"\"\n    msg = (\n        \"{cls}.offset has been deprecated and will be removed \"\n        \"in a future version; use {cls}.freq instead.\".format(\n            cls=type(self).__name__\n        )\n    )\n    warnings.warn(msg, FutureWarning, stacklevel=2)\n    self.freq = value",
                "def __getitem__(self, key):\n    result = self._data.__getitem__(key)\n    if is_scalar(result):\n        return result\n    elif result.ndim > 1:\n        # To support MPL which performs slicing with 2 dim\n        # even though it only has 1 dim by definition\n        assert isinstance(result, np.ndarray), result\n        return result\n    return type(self)(result, name=self.name)",
                "@property\ndef _box_func(self):\n    return lambda x: Timestamp(x, tz=self.tz)",
                "@Substitution(klass=\"DatetimeIndex\")\n@Appender(_shared_docs[\"searchsorted\"])\ndef searchsorted(self, value, side=\"left\", sorter=None):\n    if isinstance(value, (np.ndarray, Index)):\n        value = np.array(value, dtype=_NS_DTYPE, copy=False)\n    else:\n        value = _to_M8(value, tz=self.tz)\n\n    return self.values.searchsorted(value, side=side)",
                "def is_type_compatible(self, typ):\n    return typ == self.inferred_type or typ == \"datetime\"",
                "@property\ndef inferred_type(self):\n    # b/c datetime is represented as microseconds since the epoch, make\n    # sure we can't have ambiguous indexing\n    return \"datetime64\"",
                "@property\ndef is_all_dates(self):\n    return True",
                "def insert(self, loc, item):\n    \"\"\"\n    Make new Index inserting new item at location\n\n    Parameters\n    ----------\n    loc : int\n    item : object\n        if not either a Python datetime or a numpy integer-like, returned\n        Index dtype will be object rather than datetime.\n\n    Returns\n    -------\n    new_index : Index\n    \"\"\"\n    if is_scalar(item) and isna(item):\n        # GH 18295\n        item = self._na_value\n\n    freq = None\n\n    if isinstance(item, (datetime, np.datetime64)):\n        self._assert_can_do_op(item)\n        if not self._has_same_tz(item) and not isna(item):\n            raise ValueError(\"Passed item and index have different timezone\")\n        # check freq can be preserved on edge cases\n        if self.size and self.freq is not None:\n            if (loc == 0 or loc == -len(self)) and item + self.freq == self[0]:\n                freq = self.freq\n            elif (loc == len(self)) and item - self.freq == self[-1]:\n                freq = self.freq\n        item = _to_M8(item, tz=self.tz)\n\n    try:\n        new_dates = np.concatenate(\n            (self[:loc].asi8, [item.view(np.int64)], self[loc:].asi8)\n        )\n        return self._shallow_copy(new_dates, freq=freq)\n    except (AttributeError, TypeError):\n\n        # fall back to object index\n        if isinstance(item, str):\n            return self.astype(object).insert(loc, item)\n        raise TypeError(\"cannot insert DatetimeIndex with incompatible label\")",
                "def delete(self, loc):\n    \"\"\"\n    Make a new DatetimeIndex with passed location(s) deleted.\n\n    Parameters\n    ----------\n    loc: int, slice or array of ints\n        Indicate which sub-arrays to remove.\n\n    Returns\n    -------\n    new_index : DatetimeIndex\n    \"\"\"\n    new_dates = np.delete(self.asi8, loc)\n\n    freq = None\n    if is_integer(loc):\n        if loc in (0, -len(self), -1, len(self) - 1):\n            freq = self.freq\n    else:\n        if is_list_like(loc):\n            loc = lib.maybe_indices_to_slice(ensure_int64(np.array(loc)), len(self))\n        if isinstance(loc, slice) and loc.step in (1, None):\n            if loc.start in (0, None) or loc.stop in (len(self), None):\n                freq = self.freq\n\n    return self._shallow_copy(new_dates, freq=freq)",
                "def indexer_at_time(self, time, asof=False):\n    \"\"\"\n    Return index locations of index values at particular time of day\n    (e.g. 9:30AM).\n\n    Parameters\n    ----------\n    time : datetime.time or string\n        datetime.time or string in appropriate format (\"%H:%M\", \"%H%M\",\n        \"%I:%M%p\", \"%I%M%p\", \"%H:%M:%S\", \"%H%M%S\", \"%I:%M:%S%p\",\n        \"%I%M%S%p\").\n\n    Returns\n    -------\n    values_at_time : array of integers\n\n    See Also\n    --------\n    indexer_between_time, DataFrame.at_time\n    \"\"\"\n    if asof:\n        raise NotImplementedError(\"'asof' argument is not supported\")\n\n    if isinstance(time, str):\n        from dateutil.parser import parse\n\n        time = parse(time).time()\n\n    if time.tzinfo:\n        if self.tz is None:\n            raise ValueError(\"Index must be timezone aware.\")\n        time_micros = self.tz_convert(time.tzinfo)._get_time_micros()\n    else:\n        time_micros = self._get_time_micros()\n    micros = _time_to_micros(time)\n    return (micros == time_micros).nonzero()[0]",
                "def indexer_between_time(\n    self, start_time, end_time, include_start=True, include_end=True\n):\n    \"\"\"\n    Return index locations of values between particular times of day\n    (e.g., 9:00-9:30AM).\n\n    Parameters\n    ----------\n    start_time, end_time : datetime.time, str\n        datetime.time or string in appropriate format (\"%H:%M\", \"%H%M\",\n        \"%I:%M%p\", \"%I%M%p\", \"%H:%M:%S\", \"%H%M%S\", \"%I:%M:%S%p\",\n        \"%I%M%S%p\").\n    include_start : boolean, default True\n    include_end : boolean, default True\n\n    Returns\n    -------\n    values_between_time : array of integers\n\n    See Also\n    --------\n    indexer_at_time, DataFrame.between_time\n    \"\"\"\n    start_time = tools.to_time(start_time)\n    end_time = tools.to_time(end_time)\n    time_micros = self._get_time_micros()\n    start_micros = _time_to_micros(start_time)\n    end_micros = _time_to_micros(end_time)\n\n    if include_start and include_end:\n        lop = rop = operator.le\n    elif include_start:\n        lop = operator.le\n        rop = operator.lt\n    elif include_end:\n        lop = operator.lt\n        rop = operator.le\n    else:\n        lop = rop = operator.lt\n\n    if start_time <= end_time:\n        join_op = operator.and_\n    else:\n        join_op = operator.or_\n\n    mask = join_op(lop(start_micros, time_micros), rop(time_micros, end_micros))\n\n    return mask.nonzero()[0]"
            ],
            "inscope_function_signatures": [
                "_new_DatetimeIndex(cls, d)",
                "date_range(start=None, end=None, periods=None, freq=None, tz=None, normalize=False, name=None, closed=None, **kwargs)",
                "bdate_range(start=None, end=None, periods=None, freq='B', tz=None, normalize=True, name=None, weekmask=None, holidays=None, closed=None, **kwargs)",
                "_time_to_micros(time)",
                "_join_i8_wrapper(joinf, **kwargs)",
                "__new__(cls, data=None, freq=None, start=None, end=None, periods=None, tz=None, normalize=False, closed=None, ambiguous='raise', dayfirst=False, yearfirst=False, dtype=None, copy=False, name=None, verify_integrity=None)",
                "_simple_new(cls, values, name=None, freq=None, tz=None, dtype=None)",
                "__array__(self, dtype=None)",
                "dtype(self)",
                "tz(self)",
                "tz(self, value)",
                "_is_dates_only(self)",
                "__reduce__(self)",
                "__setstate__(self, state)",
                "_convert_for_op(self, value)",
                "_maybe_update_attributes(self, attrs)",
                "_mpl_repr(self)",
                "_format_native_types(self, na_rep='NaT', date_format=None, **kwargs)",
                "_formatter_func(self)",
                "_union(self, other, sort)",
                "union_many(self, others)",
                "_can_fast_union(self, other)",
                "_fast_union(self, other, sort=None)",
                "intersection(self, other, sort=False)",
                "_wrap_setop_result(self, other, result)",
                "_get_time_micros(self)",
                "to_series(self, keep_tz=None, index=None, name=None)",
                "snap(self, freq='S')",
                "join(self, other, how='left', level=None, return_indexers=False, sort=False)",
                "_maybe_utc_convert(self, other)",
                "_wrap_joined_index(self, joined, other)",
                "_parsed_string_to_bounds(self, reso, parsed)",
                "_partial_date_slice(self, reso, parsed, use_lhs=True, use_rhs=True)",
                "_maybe_promote(self, other)",
                "get_value(self, series, key)",
                "get_value_maybe_box(self, series, key)",
                "get_loc(self, key, method=None, tolerance=None)",
                "_maybe_cast_slice_bound(self, label, side, kind)",
                "_get_string_slice(self, key, use_lhs=True, use_rhs=True)",
                "slice_indexer(self, start=None, end=None, step=None, kind=None)",
                "offset(self)",
                "offset(self, value)",
                "__getitem__(self, key)",
                "_box_func(self)",
                "searchsorted(self, value, side='left', sorter=None)",
                "is_type_compatible(self, typ)",
                "inferred_type(self)",
                "is_all_dates(self)",
                "insert(self, loc, item)",
                "delete(self, loc)",
                "indexer_at_time(self, time, asof=False)",
                "indexer_between_time(self, start_time, end_time, include_start=True, include_end=True)"
            ],
            "variables_in_file": {
                "d": [
                    864,
                    866,
                    869,
                    871,
                    424,
                    425,
                    426,
                    52,
                    54,
                    55,
                    62
                ],
                "isinstance": [
                    1154,
                    1155,
                    775,
                    520,
                    1031,
                    1039,
                    1298,
                    1047,
                    537,
                    541,
                    804,
                    554,
                    1324,
                    430,
                    433,
                    561,
                    819,
                    52,
                    1224,
                    1353,
                    1098,
                    1101,
                    975,
                    1237,
                    345,
                    986,
                    358,
                    363,
                    1012,
                    1140,
                    1145,
                    378,
                    508,
                    1278
                ],
                "DatetimeIndex": [
                    768,
                    775,
                    520,
                    1418,
                    1419,
                    1420,
                    1421,
                    788,
                    537,
                    541,
                    543,
                    804,
                    554,
                    561,
                    1585,
                    819,
                    52,
                    966,
                    358,
                    508,
                    510
                ],
                "data": [
                    321,
                    322,
                    291,
                    439,
                    325,
                    449,
                    450,
                    451,
                    55,
                    54,
                    311,
                    438,
                    315,
                    444
                ],
                "d.pop": [
                    54
                ],
                "result": [
                    519,
                    520,
                    523,
                    524,
                    527,
                    528,
                    658,
                    55,
                    62,
                    64,
                    1218,
                    1219,
                    1220,
                    1221,
                    1224,
                    1225,
                    1226,
                    365,
                    366,
                    367,
                    369,
                    370,
                    371
                ],
                "cls._simple_new": [
                    336,
                    309,
                    55
                ],
                "cls": [
                    365,
                    336,
                    309,
                    55,
                    315,
                    62
                ],
                "warnings.catch_warnings": [
                    57
                ],
                "warnings": [
                    389,
                    714,
                    302,
                    1200,
                    725,
                    57,
                    282,
                    61,
                    1214
                ],
                "warnings.simplefilter": [
                    61
                ],
                "cls.__new__": [
                    62
                ],
                "DatetimelikeDelegateMixin": [
                    67
                ],
                "_extra_methods": [
                    72,
                    77
                ],
                "_extra_raw_methods": [
                    73,
                    84,
                    77
                ],
                "_extra_raw_properties": [
                    74,
                    75,
                    82
                ],
                "_delegated_properties": [
                    75
                ],
                "DatetimeArray._datetimelike_ops": [
                    256,
                    75
                ],
                "DatetimeArray": [
                    256,
                    257,
                    1182,
                    1183,
                    1184,
                    1186,
                    1187,
                    292,
                    1575,
                    444,
                    451,
                    324,
                    75,
                    77,
                    81,
                    85,
                    345,
                    89,
                    92,
                    352,
                    362,
                    363,
                    378,
                    251,
                    253,
                    254,
                    255
                ],
                "_delegated_methods": [
                    76
                ],
                "DatetimeArray._datetimelike_methods": [
                    257,
                    77
                ],
                "_raw_properties": [
                    79
                ],
                "set": [
                    81,
                    82,
                    84
                ],
                "DatetimeArray._bool_ops": [
                    81,
                    253
                ],
                "_raw_methods": [
                    84
                ],
                "_delegate_class": [
                    85
                ],
                "DatetimeIndexOpsMixin": [
                    97,
                    231
                ],
                "Int64Index": [
                    97
                ],
                "DatetimeDelegateMixin": [
                    89,
                    97,
                    93
                ],
                "_typ": [
                    227
                ],
                "_join_precedence": [
                    228
                ],
                "DatetimeIndexOpsMixin._join_i8_wrapper": [
                    231
                ],
                "joinf": [
                    231
                ],
                "kwargs": [
                    1692,
                    1583,
                    231
                ],
                "_inner_indexer": [
                    233
                ],
                "_join_i8_wrapper": [
                    233,
                    234,
                    235,
                    236
                ],
                "libjoin.inner_join_indexer_int64": [
                    233
                ],
                "libjoin": [
                    233,
                    234,
                    235,
                    237
                ],
                "_outer_indexer": [
                    234
                ],
                "libjoin.outer_join_indexer_int64": [
                    234
                ],
                "_left_indexer": [
                    235
                ],
                "libjoin.left_join_indexer_int64": [
                    235
                ],
                "_left_indexer_unique": [
                    236
                ],
                "libjoin.left_join_indexer_unique_int64": [
                    237
                ],
                "_engine_type": [
                    240
                ],
                "libindex.DatetimeEngine": [
                    240
                ],
                "libindex": [
                    240
                ],
                "_tz": [
                    242
                ],
                "_freq": [
                    243
                ],
                "_comparables": [
                    244
                ],
                "_attributes": [
                    245
                ],
                "_is_numeric_dtype": [
                    247
                ],
                "_infer_as_myclass": [
                    248
                ],
                "__iter__": [
                    251
                ],
                "DatetimeArray.__iter__": [
                    251
                ],
                "_bool_ops": [
                    253
                ],
                "_object_ops": [
                    254
                ],
                "DatetimeArray._object_ops": [
                    254
                ],
                "_field_ops": [
                    255
                ],
                "DatetimeArray._field_ops": [
                    255
                ],
                "_datetimelike_ops": [
                    256
                ],
                "_datetimelike_methods": [
                    257
                ],
                "verify_integrity": [
                    281,
                    289
                ],
                "warnings.warn": [
                    389,
                    714,
                    302,
                    1200,
                    725,
                    282,
                    1214
                ],
                "FutureWarning": [
                    389,
                    720,
                    1200,
                    306,
                    731,
                    285,
                    1214
                ],
                "dtarr": [
                    451,
                    292,
                    324,
                    453,
                    1575,
                    362,
                    363,
                    366,
                    336,
                    369,
                    1585,
                    309,
                    444
                ],
                "DatetimeArray._generate_range": [
                    292,
                    1575
                ],
                "start": [
                    1154,
                    1158,
                    903,
                    1159,
                    915,
                    1684,
                    918,
                    920,
                    1572,
                    293,
                    1576,
                    861,
                    865,
                    870,
                    873,
                    874,
                    876,
                    877,
                    879,
                    882,
                    884,
                    1140,
                    1143,
                    1145,
                    892,
                    1149,
                    894
                ],
                "end": [
                    1155,
                    903,
                    1162,
                    1163,
                    916,
                    1685,
                    919,
                    920,
                    1572,
                    294,
                    1577,
                    862,
                    866,
                    871,
                    874,
                    877,
                    882,
                    1140,
                    1143,
                    1145,
                    892,
                    1149
                ],
                "periods": [
                    1578,
                    1572,
                    1686,
                    295
                ],
                "freq": [
                    768,
                    1665,
                    1285,
                    1669,
                    1287,
                    1672,
                    1674,
                    1294,
                    1680,
                    1687,
                    1572,
                    1317,
                    1573,
                    296,
                    1320,
                    1579,
                    1326,
                    1328,
                    564,
                    566,
                    441,
                    444,
                    329,
                    586,
                    1102,
                    1103,
                    469,
                    470,
                    1118,
                    1119,
                    352,
                    354,
                    362,
                    752,
                    758,
                    759,
                    760,
                    1276
                ],
                "tz": [
                    353,
                    827,
                    828,
                    328,
                    297,
                    361,
                    1580,
                    410,
                    442,
                    402,
                    443,
                    1688,
                    346,
                    347,
                    348
                ],
                "normalize": [
                    1689,
                    298,
                    1581
                ],
                "closed": [
                    299,
                    1691,
                    1582
                ],
                "ambiguous": [
                    300,
                    332
                ],
                "dtarr._data": [
                    369,
                    309
                ],
                "dtarr.freq": [
                    336,
                    1585,
                    309
                ],
                "dtarr.tz": [
                    336,
                    1585,
                    309
                ],
                "name": [
                    321,
                    322,
                    741,
                    710,
                    711,
                    367,
                    336,
                    657,
                    658,
                    817,
                    1585,
                    309,
                    824,
                    1690,
                    828
                ],
                "is_scalar": [
                    1272,
                    1219,
                    311
                ],
                "TypeError": [
                    544,
                    1056,
                    1059,
                    996,
                    1667,
                    807,
                    809,
                    1001,
                    1673,
                    1295,
                    1041,
                    1300,
                    789,
                    312,
                    511
                ],
                "format": [
                    1209,
                    1674,
                    1195,
                    1677,
                    1042,
                    313
                ],
                "cls.__name__": [
                    315
                ],
                "repr": [
                    315
                ],
                "hasattr": [
                    321
                ],
                "data.name": [
                    322
                ],
                "DatetimeArray._from_sequence": [
                    324
                ],
                "dtype": [
                    352,
                    326,
                    390,
                    391,
                    361,
                    362,
                    552,
                    557,
                    443,
                    377,
                    444,
                    347,
                    348,
                    349,
                    350
                ],
                "copy": [
                    327
                ],
                "dayfirst": [
                    330
                ],
                "yearfirst": [
                    331
                ],
                "subarr": [
                    336,
                    337
                ],
                "values": [
                    352,
                    353,
                    354,
                    355,
                    737,
                    739,
                    358,
                    359,
                    741,
                    362,
                    665,
                    1015,
                    1014,
                    663,
                    345,
                    666
                ],
                "validate_tz_from_dtype": [
                    347
                ],
                "DatetimeTZDtype": [
                    348
                ],
                "_NS_DTYPE": [
                    754,
                    1238,
                    350
                ],
                "values.tz": [
                    353
                ],
                "values.freq": [
                    354
                ],
                "values._data": [
                    355,
                    359
                ],
                "tz_to_dtype": [
                    361,
                    443
                ],
                "DatetimeArray._simple_new": [
                    362,
                    444
                ],
                "object.__new__": [
                    365
                ],
                "object": [
                    1299,
                    365
                ],
                "result._data": [
                    523,
                    366
                ],
                "result.name": [
                    367
                ],
                "result._index_data": [
                    369
                ],
                "result._reset_identity": [
                    370
                ],
                "classmethod": [
                    339
                ],
                "self._data": [
                    1218,
                    453,
                    391,
                    424,
                    395,
                    400,
                    665,
                    378
                ],
                "self": [
                    514,
                    1029,
                    1034,
                    1036,
                    1037,
                    1043,
                    534,
                    1052,
                    1055,
                    1058,
                    1064,
                    1065,
                    1067,
                    1068,
                    564,
                    569,
                    572,
                    576,
                    577,
                    579,
                    1099,
                    1102,
                    1104,
                    595,
                    597,
                    598,
                    1111,
                    602,
                    603,
                    1118,
                    607,
                    1120,
                    612,
                    616,
                    628,
                    1143,
                    1149,
                    1159,
                    1160,
                    1163,
                    1164,
                    1167,
                    657,
                    658,
                    663,
                    664,
                    665,
                    1197,
                    1201,
                    1211,
                    1215,
                    1218,
                    709,
                    711,
                    713,
                    1226,
                    1230,
                    1240,
                    1242,
                    1245,
                    735,
                    737,
                    739,
                    754,
                    756,
                    1274,
                    1279,
                    768,
                    1280,
                    1283,
                    1284,
                    1285,
                    1286,
                    1287,
                    1288,
                    1292,
                    1294,
                    1299,
                    792,
                    803,
                    1315,
                    805,
                    1319,
                    1320,
                    811,
                    812,
                    1323,
                    1325,
                    1326,
                    1328,
                    817,
                    820,
                    821,
                    823,
                    828,
                    1359,
                    1361,
                    1363,
                    1393,
                    378,
                    379,
                    391,
                    395,
                    909,
                    400,
                    915,
                    916,
                    917,
                    918,
                    919,
                    923,
                    927,
                    417,
                    424,
                    425,
                    426,
                    940,
                    941,
                    446,
                    453,
                    454,
                    967,
                    463,
                    978,
                    980,
                    982,
                    984,
                    987,
                    991,
                    480,
                    994,
                    485,
                    488,
                    1000,
                    1006,
                    495,
                    496,
                    1009,
                    1011,
                    1015,
                    502,
                    1014,
                    505
                ],
                "getattr": [
                    827,
                    379,
                    1102,
                    1118
                ],
                "self.dtype": [
                    379
                ],
                "msg": [
                    1666,
                    1667,
                    389,
                    1194,
                    1674,
                    1675,
                    1677,
                    1200,
                    1681,
                    1208,
                    381,
                    1214
                ],
                "np.asarray": [
                    1029,
                    391
                ],
                "np": [
                    449,
                    450,
                    1315,
                    1029,
                    391,
                    1224,
                    1291,
                    1292,
                    1323,
                    754,
                    1237,
                    438,
                    439,
                    1238,
                    1278
                ],
                "self._data.dtype": [
                    395
                ],
                "property": [
                    1189,
                    1253,
                    393,
                    491,
                    1228,
                    397,
                    1247
                ],
                "self._data.tz": [
                    400
                ],
                "AttributeError": [
                    405,
                    1295
                ],
                "tz.setter": [
                    402
                ],
                "tzinfo": [
                    410
                ],
                "_is_dates_only": [
                    417
                ],
                "self.values": [
                    417,
                    1242,
                    739
                ],
                "self.tz": [
                    768,
                    1288,
                    1034,
                    1036,
                    909,
                    658,
                    915,
                    916,
                    917,
                    918,
                    919,
                    664,
                    417,
                    805,
                    1064,
                    1065,
                    811,
                    1067,
                    713,
                    1230,
                    1359,
                    978,
                    980,
                    982,
                    1240,
                    735,
                    480,
                    488,
                    1006,
                    496,
                    1009,
                    1011,
                    1014
                ],
                "cache_readonly": [
                    1184,
                    412,
                    1182,
                    1183
                ],
                "dict": [
                    424,
                    430
                ],
                "d.update": [
                    425
                ],
                "self._get_attributes_dict": [
                    425
                ],
                "_new_DatetimeIndex": [
                    426
                ],
                "self.__class__": [
                    426
                ],
                "state": [
                    449,
                    450,
                    430,
                    431,
                    433,
                    436,
                    437
                ],
                "__setstate__": [
                    459,
                    431
                ],
                "super": [
                    506,
                    503,
                    654,
                    431
                ],
                "tuple": [
                    433
                ],
                "len": [
                    1284,
                    1286,
                    1319,
                    776,
                    1323,
                    1325,
                    1167,
                    594,
                    754,
                    436,
                    597,
                    502,
                    946,
                    1111,
                    505,
                    572
                ],
                "nd_state": [
                    437,
                    438,
                    439
                ],
                "own_state": [
                    441,
                    442,
                    437,
                    446
                ],
                "np.empty": [
                    449,
                    754,
                    438
                ],
                "np.ndarray.__setstate__": [
                    450,
                    439
                ],
                "np.ndarray": [
                    1224,
                    450,
                    1237,
                    439
                ],
                "timezones.tz_standardize": [
                    442
                ],
                "timezones": [
                    664,
                    442,
                    811
                ],
                "self.name": [
                    768,
                    1226,
                    446,
                    711
                ],
                "self._reset_identity": [
                    454
                ],
                "Exception": [
                    457
                ],
                "_unpickle_compat": [
                    459
                ],
                "self._has_same_tz": [
                    1280,
                    463
                ],
                "value": [
                    463,
                    464,
                    1237,
                    1238,
                    1240,
                    1242,
                    1215
                ],
                "_to_M8": [
                    464,
                    1288,
                    1240
                ],
                "ValueError": [
                    1056,
                    1281,
                    1059,
                    996,
                    1001,
                    587,
                    1675,
                    910,
                    1071,
                    1360,
                    465,
                    1681,
                    789,
                    1142
                ],
                "attrs.get": [
                    469
                ],
                "attrs": [
                    472,
                    473,
                    469
                ],
                "libts.ints_to_pydatetime": [
                    480
                ],
                "libts": [
                    480,
                    487
                ],
                "self.asi8": [
                    480,
                    1315,
                    488,
                    941,
                    663
                ],
                "fmt": [
                    488,
                    485
                ],
                "_get_format_datetime64_from_values": [
                    485
                ],
                "date_format": [
                    485
                ],
                "libts.format_array_from_datetime": [
                    487
                ],
                "na_rep": [
                    488
                ],
                "formatter": [
                    496,
                    495
                ],
                "_get_format_datetime64": [
                    495
                ],
                "self._is_dates_only": [
                    495
                ],
                "x": [
                    496,
                    1230
                ],
                "other": [
                    514,
                    516,
                    517,
                    519,
                    775,
                    776,
                    777,
                    525,
                    654,
                    657,
                    788,
                    536,
                    792,
                    538,
                    795,
                    541,
                    543,
                    547,
                    804,
                    549,
                    550,
                    806,
                    808,
                    553,
                    811,
                    813,
                    814,
                    561,
                    817,
                    819,
                    820,
                    821,
                    566,
                    569,
                    827,
                    572,
                    576,
                    577,
                    579,
                    965,
                    966,
                    967,
                    594,
                    598,
                    602,
                    603,
                    607,
                    616,
                    502,
                    503,
                    505,
                    506,
                    508,
                    510
                ],
                "self.equals": [
                    505,
                    502
                ],
                "_union": [
                    503
                ],
                "sort": [
                    517,
                    519,
                    654,
                    503,
                    506,
                    606,
                    799
                ],
                "union": [
                    506
                ],
                "this": [
                    514,
                    516,
                    517,
                    519,
                    523,
                    525,
                    534,
                    792,
                    537,
                    538,
                    794,
                    547,
                    803,
                    549,
                    550,
                    552,
                    553,
                    554,
                    812,
                    557,
                    558,
                    814
                ],
                "self._maybe_utc_convert": [
                    792,
                    514
                ],
                "this._can_fast_union": [
                    516,
                    549
                ],
                "this._fast_union": [
                    517,
                    550
                ],
                "Index._union": [
                    519
                ],
                "Index": [
                    519,
                    1178,
                    553,
                    1068,
                    1037,
                    1180,
                    1237,
                    793,
                    538,
                    1179,
                    1055,
                    1149,
                    991
                ],
                "result._data._dtype": [
                    523
                ],
                "this.dtype": [
                    552,
                    523
                ],
                "result.freq": [
                    524,
                    527
                ],
                "this.freq": [
                    525
                ],
                "other.freq": [
                    820,
                    525,
                    566
                ],
                "to_offset": [
                    752,
                    527
                ],
                "result.inferred_freq": [
                    527
                ],
                "others": [
                    536
                ],
                "Index.union": [
                    553,
                    538
                ],
                "this._maybe_utc_convert": [
                    547
                ],
                "this._data._dtype": [
                    557
                ],
                "this._data": [
                    557
                ],
                "self.freq": [
                    1283,
                    1284,
                    1285,
                    1286,
                    1287,
                    1320,
                    1326,
                    1201,
                    564,
                    820,
                    1215
                ],
                "self.is_monotonic": [
                    569,
                    923
                ],
                "other.is_monotonic": [
                    569
                ],
                "left": [
                    608,
                    577,
                    579,
                    611,
                    582,
                    616,
                    586,
                    618,
                    627,
                    630,
                    953,
                    603,
                    956,
                    607
                ],
                "right": [
                    577,
                    609,
                    579,
                    610,
                    581,
                    616,
                    619,
                    625,
                    626,
                    954,
                    603,
                    956,
                    607
                ],
                "right_start": [
                    586,
                    581
                ],
                "left_end": [
                    582,
                    586,
                    618,
                    624,
                    625
                ],
                "self.view": [
                    595
                ],
                "type": [
                    1226,
                    1197,
                    1043,
                    595,
                    598,
                    1211
                ],
                "other.view": [
                    598
                ],
                "left_start": [
                    608,
                    609
                ],
                "loc": [
                    1284,
                    1286,
                    1292,
                    1299,
                    1315,
                    1318,
                    1319,
                    1322,
                    1323,
                    1324,
                    1325,
                    1120,
                    609,
                    610,
                    994,
                    995,
                    1121,
                    625,
                    626
                ],
                "right.searchsorted": [
                    609,
                    625
                ],
                "right_chunk": [
                    627,
                    610,
                    611,
                    626
                ],
                "right.values": [
                    610,
                    626
                ],
                "dates": [
                    627,
                    628,
                    611,
                    612
                ],
                "concat_compat": [
                    627,
                    611
                ],
                "left.values": [
                    627,
                    611
                ],
                "self._shallow_copy": [
                    612,
                    709,
                    1294,
                    1328,
                    658,
                    628,
                    823
                ],
                "right_end": [
                    624,
                    619
                ],
                "intersection": [
                    654
                ],
                "get_op_result_name": [
                    657,
                    817
                ],
                "timezones.is_utc": [
                    664
                ],
                "self._data._local_timestamps": [
                    665
                ],
                "fields.get_time_micros": [
                    666
                ],
                "fields": [
                    666
                ],
                "index": [
                    741,
                    708,
                    709
                ],
                "keep_tz": [
                    713,
                    723,
                    724,
                    735
                ],
                "self.copy": [
                    737
                ],
                "self.values.copy": [
                    739
                ],
                "Series": [
                    741
                ],
                "snapped": [
                    768,
                    754,
                    765
                ],
                "i": [
                    756,
                    765
                ],
                "v": [
                    756,
                    757
                ],
                "enumerate": [
                    756
                ],
                "s": [
                    757,
                    758,
                    759,
                    760,
                    761,
                    762,
                    764,
                    765
                ],
                "freq.onOffset": [
                    758
                ],
                "t0": [
                    761,
                    762,
                    759
                ],
                "freq.rollback": [
                    759
                ],
                "t1": [
                    940,
                    947,
                    948,
                    760,
                    761,
                    953,
                    764,
                    958
                ],
                "freq.rollforward": [
                    760
                ],
                "abs": [
                    761
                ],
                "DatetimeIndex._simple_new": [
                    768,
                    1585
                ],
                "other.inferred_type": [
                    777,
                    965
                ],
                "Index.join": [
                    793
                ],
                "how": [
                    796
                ],
                "level": [
                    797
                ],
                "return_indexers": [
                    798
                ],
                "other.tz": [
                    808,
                    811,
                    806
                ],
                "timezones.tz_compare": [
                    811
                ],
                "self.tz_convert": [
                    1361,
                    812
                ],
                "other.tz_convert": [
                    813
                ],
                "self._can_fast_union": [
                    821
                ],
                "joined": [
                    824,
                    825,
                    828,
                    823
                ],
                "joined.name": [
                    824
                ],
                "self._simple_new": [
                    828
                ],
                "valid_resos": [
                    858,
                    846
                ],
                "reso": [
                    1120,
                    867,
                    935,
                    872,
                    875,
                    940,
                    878,
                    1103,
                    1104,
                    883,
                    927,
                    1119,
                    858,
                    860,
                    893,
                    926,
                    863
                ],
                "KeyError": [
                    992,
                    1056,
                    1059,
                    996,
                    933,
                    1001,
                    938,
                    1002,
                    1673,
                    1069,
                    1070,
                    1075,
                    950,
                    1146,
                    859,
                    1150
                ],
                "Timestamp": [
                    1034,
                    1036,
                    1063,
                    1230,
                    980,
                    982,
                    861,
                    862,
                    865,
                    866,
                    870,
                    871,
                    873,
                    876,
                    879,
                    1007,
                    884,
                    1012,
                    1013,
                    894
                ],
                "parsed.year": [
                    864,
                    865,
                    866,
                    869,
                    870,
                    871,
                    873,
                    876,
                    880,
                    885,
                    861,
                    862,
                    895
                ],
                "parsed": [
                    896,
                    897,
                    898,
                    899,
                    900,
                    901,
                    908,
                    915,
                    916,
                    940,
                    1103,
                    1104,
                    861,
                    862,
                    1119,
                    864,
                    865,
                    866,
                    1120,
                    868,
                    869,
                    870,
                    871,
                    873,
                    876,
                    880,
                    885,
                    886,
                    887,
                    888,
                    889,
                    890,
                    895
                ],
                "ccalendar.get_days_in_month": [
                    864,
                    869
                ],
                "ccalendar": [
                    864,
                    869
                ],
                "parsed.month": [
                    864,
                    865,
                    866,
                    896,
                    868,
                    870,
                    873,
                    876,
                    880,
                    886
                ],
                "qe": [
                    868,
                    869,
                    871
                ],
                "parsed.day": [
                    897,
                    873,
                    876,
                    880,
                    887
                ],
                "timedelta": [
                    903,
                    874,
                    877,
                    1039,
                    882,
                    892
                ],
                "Nano": [
                    903,
                    874,
                    877,
                    882,
                    892
                ],
                "parsed.hour": [
                    880,
                    898,
                    876,
                    888
                ],
                "parsed.minute": [
                    880,
                    889,
                    899
                ],
                "parsed.second": [
                    890,
                    900
                ],
                "parsed.microsecond": [
                    901
                ],
                "parsed.tzinfo": [
                    916,
                    915,
                    908
                ],
                "tz_convert": [
                    980,
                    915,
                    916,
                    1036
                ],
                "start.tz_localize": [
                    915,
                    918
                ],
                "end.tz_localize": [
                    916,
                    919
                ],
                "is_monotonic": [
                    923,
                    925,
                    943
                ],
                "self._resolution": [
                    927
                ],
                "Resolution.get_reso": [
                    927
                ],
                "Resolution": [
                    927
                ],
                "t2": [
                    940,
                    947,
                    948,
                    954,
                    959
                ],
                "self._parsed_string_to_bounds": [
                    1104,
                    940
                ],
                "stamps": [
                    941,
                    946,
                    947,
                    948,
                    953,
                    954,
                    958,
                    959
                ],
                "use_lhs": [
                    1120,
                    953,
                    947,
                    958
                ],
                "t1.value": [
                    953,
                    947,
                    948,
                    958
                ],
                "t2.value": [
                    954,
                    947,
                    948,
                    959
                ],
                "use_rhs": [
                    1120,
                    954,
                    948,
                    959
                ],
                "stamps.searchsorted": [
                    953,
                    954
                ],
                "slice": [
                    1168,
                    956,
                    1324
                ],
                "lhs_mask": [
                    962,
                    958
                ],
                "rhs_mask": [
                    962,
                    959
                ],
                "nonzero": [
                    962,
                    1365
                ],
                "key": [
                    1029,
                    1031,
                    1033,
                    1034,
                    1036,
                    1037,
                    1039,
                    1043,
                    1047,
                    1052,
                    1055,
                    1058,
                    1063,
                    1070,
                    1075,
                    1218,
                    975,
                    979,
                    980,
                    982,
                    984,
                    986,
                    987,
                    991,
                    1119,
                    994,
                    1000,
                    1002,
                    1007,
                    1008,
                    1009,
                    1011,
                    1012,
                    1013,
                    1014,
                    1015
                ],
                "datetime": [
                    1031,
                    1278,
                    975
                ],
                "key.tzinfo": [
                    1008,
                    1033,
                    979
                ],
                "tz_localize": [
                    982
                ],
                "self.get_value_maybe_box": [
                    984,
                    1000
                ],
                "series": [
                    995,
                    1000,
                    1014,
                    1015,
                    984,
                    988,
                    991
                ],
                "time": [
                    1697,
                    1698,
                    1353,
                    1098,
                    1356,
                    1358,
                    1361,
                    1140,
                    1364,
                    1047,
                    1145,
                    986
                ],
                "locs": [
                    987,
                    988
                ],
                "self.indexer_at_time": [
                    987,
                    1052
                ],
                "series.take": [
                    988
                ],
                "com.maybe_box": [
                    1015,
                    991
                ],
                "com": [
                    1015,
                    1572,
                    1014,
                    991
                ],
                "Index.get_value": [
                    991
                ],
                "self._get_string_slice": [
                    994,
                    1058
                ],
                "key.tz_convert": [
                    1009
                ],
                "key.tz_localize": [
                    1011
                ],
                "self._engine.get_value": [
                    1014
                ],
                "self._engine": [
                    1014
                ],
                "com.values_from_object": [
                    1014
                ],
                "tolerance": [
                    1026,
                    1029,
                    1068,
                    1037,
                    1055
                ],
                "self._convert_tolerance": [
                    1029
                ],
                "Index.get_loc": [
                    1068,
                    1037,
                    1055
                ],
                "method": [
                    1048,
                    1068,
                    1037,
                    1055
                ],
                "__name__": [
                    1211,
                    1043,
                    1197
                ],
                "NotImplementedError": [
                    1049,
                    1351
                ],
                "OverflowError": [
                    1059
                ],
                "stamp": [
                    1063,
                    1064,
                    1065,
                    1067,
                    1068
                ],
                "stamp.tzinfo": [
                    1064
                ],
                "stamp.tz_convert": [
                    1065
                ],
                "stamp.tz_localize": [
                    1067
                ],
                "str": [
                    1154,
                    1155,
                    1353,
                    1101,
                    1073,
                    1298
                ],
                "e": [
                    1073,
                    1074
                ],
                "kind": [
                    1096,
                    1163,
                    1149,
                    1159
                ],
                "is_float": [
                    1098
                ],
                "label": [
                    1098,
                    1099,
                    1101,
                    1103,
                    1115
                ],
                "is_integer": [
                    1098,
                    1318
                ],
                "self._invalid_indexer": [
                    1099
                ],
                "_": [
                    1119,
                    1103
                ],
                "parsing.parse_time_string": [
                    1119,
                    1103
                ],
                "parsing": [
                    1119,
                    1103
                ],
                "lower": [
                    1104,
                    1113,
                    1112
                ],
                "upper": [
                    1104,
                    1113,
                    1112
                ],
                "self._is_strictly_monotonic_decreasing": [
                    1111
                ],
                "side": [
                    1112,
                    1113,
                    1242
                ],
                "self._partial_date_slice": [
                    1120
                ],
                "step": [
                    1149,
                    1141,
                    1166
                ],
                "self.indexer_between_time": [
                    1143
                ],
                "Index.slice_indexer": [
                    1149
                ],
                "mask": [
                    1413,
                    1157,
                    1415,
                    1160,
                    1164,
                    1166
                ],
                "start_casted": [
                    1160,
                    1159
                ],
                "self._maybe_cast_slice_bound": [
                    1163,
                    1159
                ],
                "end_casted": [
                    1163,
                    1164
                ],
                "indexer": [
                    1170,
                    1166,
                    1167
                ],
                "mask.nonzero": [
                    1166,
                    1415
                ],
                "_is_monotonic_increasing": [
                    1178
                ],
                "Index.is_monotonic_increasing": [
                    1178
                ],
                "_is_monotonic_decreasing": [
                    1179
                ],
                "Index.is_monotonic_decreasing": [
                    1179
                ],
                "_is_unique": [
                    1180
                ],
                "Index.is_unique": [
                    1180
                ],
                "_timezone": [
                    1182
                ],
                "DatetimeArray._timezone.fget": [
                    1182
                ],
                "DatetimeArray._timezone": [
                    1182
                ],
                "is_normalized": [
                    1183
                ],
                "DatetimeArray.is_normalized.fget": [
                    1183
                ],
                "DatetimeArray.is_normalized": [
                    1183
                ],
                "_resolution": [
                    1184
                ],
                "DatetimeArray._resolution.fget": [
                    1184
                ],
                "DatetimeArray._resolution": [
                    1184
                ],
                "strftime": [
                    1186
                ],
                "ea_passthrough": [
                    1186,
                    1187
                ],
                "DatetimeArray.strftime": [
                    1186
                ],
                "_has_same_tz": [
                    1187
                ],
                "DatetimeArray._has_same_tz": [
                    1187
                ],
                "offset.setter": [
                    1203
                ],
                "offset": [
                    1203
                ],
                "self._data.__getitem__": [
                    1218
                ],
                "result.ndim": [
                    1221
                ],
                "np.array": [
                    1323,
                    1238
                ],
                "self.values.searchsorted": [
                    1242
                ],
                "Substitution": [
                    1234
                ],
                "Appender": [
                    1235
                ],
                "_shared_docs": [
                    1235
                ],
                "typ": [
                    1245
                ],
                "self.inferred_type": [
                    1245
                ],
                "item": [
                    1280,
                    1284,
                    1286,
                    1288,
                    1292,
                    1298,
                    1299,
                    1272,
                    1274,
                    1278,
                    1279
                ],
                "isna": [
                    1272,
                    1280
                ],
                "self._na_value": [
                    1274
                ],
                "np.datetime64": [
                    1278
                ],
                "self._assert_can_do_op": [
                    1279
                ],
                "self.size": [
                    1283
                ],
                "new_dates": [
                    1328,
                    1315,
                    1291,
                    1294
                ],
                "np.concatenate": [
                    1291
                ],
                "asi8": [
                    1292
                ],
                "item.view": [
                    1292
                ],
                "np.int64": [
                    1292
                ],
                "insert": [
                    1299
                ],
                "self.astype": [
                    1299
                ],
                "np.delete": [
                    1315
                ],
                "is_list_like": [
                    1322
                ],
                "lib.maybe_indices_to_slice": [
                    1323
                ],
                "lib": [
                    1323
                ],
                "ensure_int64": [
                    1323
                ],
                "loc.step": [
                    1324
                ],
                "loc.start": [
                    1325
                ],
                "loc.stop": [
                    1325
                ],
                "asof": [
                    1350
                ],
                "parse": [
                    1356
                ],
                "time.tzinfo": [
                    1361,
                    1358
                ],
                "time_micros": [
                    1413,
                    1361,
                    1393,
                    1363,
                    1365
                ],
                "_get_time_micros": [
                    1361
                ],
                "self._get_time_micros": [
                    1393,
                    1363
                ],
                "micros": [
                    1364,
                    1365
                ],
                "_time_to_micros": [
                    1394,
                    1395,
                    1364
                ],
                "start_time": [
                    1408,
                    1394,
                    1391
                ],
                "tools.to_time": [
                    1392,
                    1391
                ],
                "tools": [
                    1392,
                    1391
                ],
                "end_time": [
                    1392,
                    1395,
                    1408
                ],
                "start_micros": [
                    1394,
                    1413
                ],
                "end_micros": [
                    1395,
                    1413
                ],
                "include_start": [
                    1397,
                    1399
                ],
                "include_end": [
                    1402,
                    1397
                ],
                "lop": [
                    1413,
                    1398,
                    1400,
                    1403,
                    1406
                ],
                "rop": [
                    1413,
                    1398,
                    1401,
                    1404,
                    1406
                ],
                "operator.le": [
                    1400,
                    1404,
                    1398
                ],
                "operator": [
                    1409,
                    1411,
                    1398,
                    1400,
                    1401,
                    1403,
                    1404,
                    1406
                ],
                "operator.lt": [
                    1401,
                    1403,
                    1406
                ],
                "join_op": [
                    1409,
                    1411,
                    1413
                ],
                "operator.and_": [
                    1409
                ],
                "operator.or_": [
                    1411
                ],
                "delegate_names": [
                    88,
                    91
                ],
                "DatetimeDelegateMixin._delegated_properties": [
                    89
                ],
                "DatetimeDelegateMixin._delegated_methods": [
                    93
                ],
                "DatetimeIndex._add_comparison_ops": [
                    1418
                ],
                "DatetimeIndex._add_numeric_methods_disabled": [
                    1419
                ],
                "DatetimeIndex._add_logical_methods_disabled": [
                    1420
                ],
                "DatetimeIndex._add_datetimelike_methods": [
                    1421
                ],
                "com.any_none": [
                    1572
                ],
                "is_string_like": [
                    1669
                ],
                "freq.startswith": [
                    1669
                ],
                "weekmask": [
                    1672,
                    1676,
                    1671
                ],
                "prefix_mapping": [
                    1672
                ],
                "holidays": [
                    1672,
                    1676
                ],
                "date_range": [
                    1683
                ],
                "seconds": [
                    1697,
                    1698
                ],
                "time.hour": [
                    1697
                ],
                "time.minute": [
                    1697
                ],
                "time.second": [
                    1697
                ],
                "time.microsecond": [
                    1698
                ]
            },
            "filtered_variables_in_file": {
                "d": [
                    864,
                    866,
                    869,
                    871,
                    424,
                    425,
                    426,
                    52,
                    54,
                    55,
                    62
                ],
                "DatetimeIndex": [
                    768,
                    775,
                    520,
                    1418,
                    1419,
                    1420,
                    1421,
                    788,
                    537,
                    541,
                    543,
                    804,
                    554,
                    561,
                    1585,
                    819,
                    52,
                    966,
                    358,
                    508,
                    510
                ],
                "data": [
                    321,
                    322,
                    291,
                    439,
                    325,
                    449,
                    450,
                    451,
                    55,
                    54,
                    311,
                    438,
                    315,
                    444
                ],
                "d.pop": [
                    54
                ],
                "result": [
                    519,
                    520,
                    523,
                    524,
                    527,
                    528,
                    658,
                    55,
                    62,
                    64,
                    1218,
                    1219,
                    1220,
                    1221,
                    1224,
                    1225,
                    1226,
                    365,
                    366,
                    367,
                    369,
                    370,
                    371
                ],
                "cls._simple_new": [
                    336,
                    309,
                    55
                ],
                "cls": [
                    365,
                    336,
                    309,
                    55,
                    315,
                    62
                ],
                "warnings.catch_warnings": [
                    57
                ],
                "warnings": [
                    389,
                    714,
                    302,
                    1200,
                    725,
                    57,
                    282,
                    61,
                    1214
                ],
                "warnings.simplefilter": [
                    61
                ],
                "cls.__new__": [
                    62
                ],
                "DatetimelikeDelegateMixin": [
                    67
                ],
                "_extra_methods": [
                    72,
                    77
                ],
                "_extra_raw_methods": [
                    73,
                    84,
                    77
                ],
                "_extra_raw_properties": [
                    74,
                    75,
                    82
                ],
                "_delegated_properties": [
                    75
                ],
                "DatetimeArray._datetimelike_ops": [
                    256,
                    75
                ],
                "DatetimeArray": [
                    256,
                    257,
                    1182,
                    1183,
                    1184,
                    1186,
                    1187,
                    292,
                    1575,
                    444,
                    451,
                    324,
                    75,
                    77,
                    81,
                    85,
                    345,
                    89,
                    92,
                    352,
                    362,
                    363,
                    378,
                    251,
                    253,
                    254,
                    255
                ],
                "_delegated_methods": [
                    76
                ],
                "DatetimeArray._datetimelike_methods": [
                    257,
                    77
                ],
                "_raw_properties": [
                    79
                ],
                "DatetimeArray._bool_ops": [
                    81,
                    253
                ],
                "_raw_methods": [
                    84
                ],
                "_delegate_class": [
                    85
                ],
                "DatetimeIndexOpsMixin": [
                    97,
                    231
                ],
                "Int64Index": [
                    97
                ],
                "DatetimeDelegateMixin": [
                    89,
                    97,
                    93
                ],
                "_typ": [
                    227
                ],
                "_join_precedence": [
                    228
                ],
                "DatetimeIndexOpsMixin._join_i8_wrapper": [
                    231
                ],
                "joinf": [
                    231
                ],
                "kwargs": [
                    1692,
                    1583,
                    231
                ],
                "_inner_indexer": [
                    233
                ],
                "_join_i8_wrapper": [
                    233,
                    234,
                    235,
                    236
                ],
                "libjoin.inner_join_indexer_int64": [
                    233
                ],
                "libjoin": [
                    233,
                    234,
                    235,
                    237
                ],
                "_outer_indexer": [
                    234
                ],
                "libjoin.outer_join_indexer_int64": [
                    234
                ],
                "_left_indexer": [
                    235
                ],
                "libjoin.left_join_indexer_int64": [
                    235
                ],
                "_left_indexer_unique": [
                    236
                ],
                "libjoin.left_join_indexer_unique_int64": [
                    237
                ],
                "_engine_type": [
                    240
                ],
                "libindex.DatetimeEngine": [
                    240
                ],
                "libindex": [
                    240
                ],
                "_tz": [
                    242
                ],
                "_freq": [
                    243
                ],
                "_comparables": [
                    244
                ],
                "_attributes": [
                    245
                ],
                "_is_numeric_dtype": [
                    247
                ],
                "_infer_as_myclass": [
                    248
                ],
                "__iter__": [
                    251
                ],
                "DatetimeArray.__iter__": [
                    251
                ],
                "_bool_ops": [
                    253
                ],
                "_object_ops": [
                    254
                ],
                "DatetimeArray._object_ops": [
                    254
                ],
                "_field_ops": [
                    255
                ],
                "DatetimeArray._field_ops": [
                    255
                ],
                "_datetimelike_ops": [
                    256
                ],
                "_datetimelike_methods": [
                    257
                ],
                "verify_integrity": [
                    281,
                    289
                ],
                "warnings.warn": [
                    389,
                    714,
                    302,
                    1200,
                    725,
                    282,
                    1214
                ],
                "dtarr": [
                    451,
                    292,
                    324,
                    453,
                    1575,
                    362,
                    363,
                    366,
                    336,
                    369,
                    1585,
                    309,
                    444
                ],
                "DatetimeArray._generate_range": [
                    292,
                    1575
                ],
                "start": [
                    1154,
                    1158,
                    903,
                    1159,
                    915,
                    1684,
                    918,
                    920,
                    1572,
                    293,
                    1576,
                    861,
                    865,
                    870,
                    873,
                    874,
                    876,
                    877,
                    879,
                    882,
                    884,
                    1140,
                    1143,
                    1145,
                    892,
                    1149,
                    894
                ],
                "end": [
                    1155,
                    903,
                    1162,
                    1163,
                    916,
                    1685,
                    919,
                    920,
                    1572,
                    294,
                    1577,
                    862,
                    866,
                    871,
                    874,
                    877,
                    882,
                    1140,
                    1143,
                    1145,
                    892,
                    1149
                ],
                "periods": [
                    1578,
                    1572,
                    1686,
                    295
                ],
                "freq": [
                    768,
                    1665,
                    1285,
                    1669,
                    1287,
                    1672,
                    1674,
                    1294,
                    1680,
                    1687,
                    1572,
                    1317,
                    1573,
                    296,
                    1320,
                    1579,
                    1326,
                    1328,
                    564,
                    566,
                    441,
                    444,
                    329,
                    586,
                    1102,
                    1103,
                    469,
                    470,
                    1118,
                    1119,
                    352,
                    354,
                    362,
                    752,
                    758,
                    759,
                    760,
                    1276
                ],
                "tz": [
                    353,
                    827,
                    828,
                    328,
                    297,
                    361,
                    1580,
                    410,
                    442,
                    402,
                    443,
                    1688,
                    346,
                    347,
                    348
                ],
                "normalize": [
                    1689,
                    298,
                    1581
                ],
                "closed": [
                    299,
                    1691,
                    1582
                ],
                "ambiguous": [
                    300,
                    332
                ],
                "dtarr._data": [
                    369,
                    309
                ],
                "dtarr.freq": [
                    336,
                    1585,
                    309
                ],
                "dtarr.tz": [
                    336,
                    1585,
                    309
                ],
                "name": [
                    321,
                    322,
                    741,
                    710,
                    711,
                    367,
                    336,
                    657,
                    658,
                    817,
                    1585,
                    309,
                    824,
                    1690,
                    828
                ],
                "is_scalar": [
                    1272,
                    1219,
                    311
                ],
                "cls.__name__": [
                    315
                ],
                "data.name": [
                    322
                ],
                "DatetimeArray._from_sequence": [
                    324
                ],
                "dtype": [
                    352,
                    326,
                    390,
                    391,
                    361,
                    362,
                    552,
                    557,
                    443,
                    377,
                    444,
                    347,
                    348,
                    349,
                    350
                ],
                "copy": [
                    327
                ],
                "dayfirst": [
                    330
                ],
                "yearfirst": [
                    331
                ],
                "subarr": [
                    336,
                    337
                ],
                "values": [
                    352,
                    353,
                    354,
                    355,
                    737,
                    739,
                    358,
                    359,
                    741,
                    362,
                    665,
                    1015,
                    1014,
                    663,
                    345,
                    666
                ],
                "validate_tz_from_dtype": [
                    347
                ],
                "DatetimeTZDtype": [
                    348
                ],
                "_NS_DTYPE": [
                    754,
                    1238,
                    350
                ],
                "values.tz": [
                    353
                ],
                "values.freq": [
                    354
                ],
                "values._data": [
                    355,
                    359
                ],
                "tz_to_dtype": [
                    361,
                    443
                ],
                "DatetimeArray._simple_new": [
                    362,
                    444
                ],
                "object.__new__": [
                    365
                ],
                "result._data": [
                    523,
                    366
                ],
                "result.name": [
                    367
                ],
                "result._index_data": [
                    369
                ],
                "result._reset_identity": [
                    370
                ],
                "self._data": [
                    1218,
                    453,
                    391,
                    424,
                    395,
                    400,
                    665,
                    378
                ],
                "self": [
                    514,
                    1029,
                    1034,
                    1036,
                    1037,
                    1043,
                    534,
                    1052,
                    1055,
                    1058,
                    1064,
                    1065,
                    1067,
                    1068,
                    564,
                    569,
                    572,
                    576,
                    577,
                    579,
                    1099,
                    1102,
                    1104,
                    595,
                    597,
                    598,
                    1111,
                    602,
                    603,
                    1118,
                    607,
                    1120,
                    612,
                    616,
                    628,
                    1143,
                    1149,
                    1159,
                    1160,
                    1163,
                    1164,
                    1167,
                    657,
                    658,
                    663,
                    664,
                    665,
                    1197,
                    1201,
                    1211,
                    1215,
                    1218,
                    709,
                    711,
                    713,
                    1226,
                    1230,
                    1240,
                    1242,
                    1245,
                    735,
                    737,
                    739,
                    754,
                    756,
                    1274,
                    1279,
                    768,
                    1280,
                    1283,
                    1284,
                    1285,
                    1286,
                    1287,
                    1288,
                    1292,
                    1294,
                    1299,
                    792,
                    803,
                    1315,
                    805,
                    1319,
                    1320,
                    811,
                    812,
                    1323,
                    1325,
                    1326,
                    1328,
                    817,
                    820,
                    821,
                    823,
                    828,
                    1359,
                    1361,
                    1363,
                    1393,
                    378,
                    379,
                    391,
                    395,
                    909,
                    400,
                    915,
                    916,
                    917,
                    918,
                    919,
                    923,
                    927,
                    417,
                    424,
                    425,
                    426,
                    940,
                    941,
                    446,
                    453,
                    454,
                    967,
                    463,
                    978,
                    980,
                    982,
                    984,
                    987,
                    991,
                    480,
                    994,
                    485,
                    488,
                    1000,
                    1006,
                    495,
                    496,
                    1009,
                    1011,
                    1015,
                    502,
                    1014,
                    505
                ],
                "self.dtype": [
                    379
                ],
                "msg": [
                    1666,
                    1667,
                    389,
                    1194,
                    1674,
                    1675,
                    1677,
                    1200,
                    1681,
                    1208,
                    381,
                    1214
                ],
                "np.asarray": [
                    1029,
                    391
                ],
                "np": [
                    449,
                    450,
                    1315,
                    1029,
                    391,
                    1224,
                    1291,
                    1292,
                    1323,
                    754,
                    1237,
                    438,
                    439,
                    1238,
                    1278
                ],
                "self._data.dtype": [
                    395
                ],
                "self._data.tz": [
                    400
                ],
                "tz.setter": [
                    402
                ],
                "tzinfo": [
                    410
                ],
                "_is_dates_only": [
                    417
                ],
                "self.values": [
                    417,
                    1242,
                    739
                ],
                "self.tz": [
                    768,
                    1288,
                    1034,
                    1036,
                    909,
                    658,
                    915,
                    916,
                    917,
                    918,
                    919,
                    664,
                    417,
                    805,
                    1064,
                    1065,
                    811,
                    1067,
                    713,
                    1230,
                    1359,
                    978,
                    980,
                    982,
                    1240,
                    735,
                    480,
                    488,
                    1006,
                    496,
                    1009,
                    1011,
                    1014
                ],
                "cache_readonly": [
                    1184,
                    412,
                    1182,
                    1183
                ],
                "d.update": [
                    425
                ],
                "self._get_attributes_dict": [
                    425
                ],
                "_new_DatetimeIndex": [
                    426
                ],
                "self.__class__": [
                    426
                ],
                "state": [
                    449,
                    450,
                    430,
                    431,
                    433,
                    436,
                    437
                ],
                "__setstate__": [
                    459,
                    431
                ],
                "nd_state": [
                    437,
                    438,
                    439
                ],
                "own_state": [
                    441,
                    442,
                    437,
                    446
                ],
                "np.empty": [
                    449,
                    754,
                    438
                ],
                "np.ndarray.__setstate__": [
                    450,
                    439
                ],
                "np.ndarray": [
                    1224,
                    450,
                    1237,
                    439
                ],
                "timezones.tz_standardize": [
                    442
                ],
                "timezones": [
                    664,
                    442,
                    811
                ],
                "self.name": [
                    768,
                    1226,
                    446,
                    711
                ],
                "self._reset_identity": [
                    454
                ],
                "_unpickle_compat": [
                    459
                ],
                "self._has_same_tz": [
                    1280,
                    463
                ],
                "value": [
                    463,
                    464,
                    1237,
                    1238,
                    1240,
                    1242,
                    1215
                ],
                "_to_M8": [
                    464,
                    1288,
                    1240
                ],
                "attrs.get": [
                    469
                ],
                "attrs": [
                    472,
                    473,
                    469
                ],
                "libts.ints_to_pydatetime": [
                    480
                ],
                "libts": [
                    480,
                    487
                ],
                "self.asi8": [
                    480,
                    1315,
                    488,
                    941,
                    663
                ],
                "fmt": [
                    488,
                    485
                ],
                "_get_format_datetime64_from_values": [
                    485
                ],
                "date_format": [
                    485
                ],
                "libts.format_array_from_datetime": [
                    487
                ],
                "na_rep": [
                    488
                ],
                "formatter": [
                    496,
                    495
                ],
                "_get_format_datetime64": [
                    495
                ],
                "self._is_dates_only": [
                    495
                ],
                "x": [
                    496,
                    1230
                ],
                "other": [
                    514,
                    516,
                    517,
                    519,
                    775,
                    776,
                    777,
                    525,
                    654,
                    657,
                    788,
                    536,
                    792,
                    538,
                    795,
                    541,
                    543,
                    547,
                    804,
                    549,
                    550,
                    806,
                    808,
                    553,
                    811,
                    813,
                    814,
                    561,
                    817,
                    819,
                    820,
                    821,
                    566,
                    569,
                    827,
                    572,
                    576,
                    577,
                    579,
                    965,
                    966,
                    967,
                    594,
                    598,
                    602,
                    603,
                    607,
                    616,
                    502,
                    503,
                    505,
                    506,
                    508,
                    510
                ],
                "self.equals": [
                    505,
                    502
                ],
                "_union": [
                    503
                ],
                "sort": [
                    517,
                    519,
                    654,
                    503,
                    506,
                    606,
                    799
                ],
                "union": [
                    506
                ],
                "this": [
                    514,
                    516,
                    517,
                    519,
                    523,
                    525,
                    534,
                    792,
                    537,
                    538,
                    794,
                    547,
                    803,
                    549,
                    550,
                    552,
                    553,
                    554,
                    812,
                    557,
                    558,
                    814
                ],
                "self._maybe_utc_convert": [
                    792,
                    514
                ],
                "this._can_fast_union": [
                    516,
                    549
                ],
                "this._fast_union": [
                    517,
                    550
                ],
                "Index._union": [
                    519
                ],
                "Index": [
                    519,
                    1178,
                    553,
                    1068,
                    1037,
                    1180,
                    1237,
                    793,
                    538,
                    1179,
                    1055,
                    1149,
                    991
                ],
                "result._data._dtype": [
                    523
                ],
                "this.dtype": [
                    552,
                    523
                ],
                "result.freq": [
                    524,
                    527
                ],
                "this.freq": [
                    525
                ],
                "other.freq": [
                    820,
                    525,
                    566
                ],
                "to_offset": [
                    752,
                    527
                ],
                "result.inferred_freq": [
                    527
                ],
                "others": [
                    536
                ],
                "Index.union": [
                    553,
                    538
                ],
                "this._maybe_utc_convert": [
                    547
                ],
                "this._data._dtype": [
                    557
                ],
                "this._data": [
                    557
                ],
                "self.freq": [
                    1283,
                    1284,
                    1285,
                    1286,
                    1287,
                    1320,
                    1326,
                    1201,
                    564,
                    820,
                    1215
                ],
                "self.is_monotonic": [
                    569,
                    923
                ],
                "other.is_monotonic": [
                    569
                ],
                "left": [
                    608,
                    577,
                    579,
                    611,
                    582,
                    616,
                    586,
                    618,
                    627,
                    630,
                    953,
                    603,
                    956,
                    607
                ],
                "right": [
                    577,
                    609,
                    579,
                    610,
                    581,
                    616,
                    619,
                    625,
                    626,
                    954,
                    603,
                    956,
                    607
                ],
                "right_start": [
                    586,
                    581
                ],
                "left_end": [
                    582,
                    586,
                    618,
                    624,
                    625
                ],
                "self.view": [
                    595
                ],
                "other.view": [
                    598
                ],
                "left_start": [
                    608,
                    609
                ],
                "loc": [
                    1284,
                    1286,
                    1292,
                    1299,
                    1315,
                    1318,
                    1319,
                    1322,
                    1323,
                    1324,
                    1325,
                    1120,
                    609,
                    610,
                    994,
                    995,
                    1121,
                    625,
                    626
                ],
                "right.searchsorted": [
                    609,
                    625
                ],
                "right_chunk": [
                    627,
                    610,
                    611,
                    626
                ],
                "right.values": [
                    610,
                    626
                ],
                "dates": [
                    627,
                    628,
                    611,
                    612
                ],
                "concat_compat": [
                    627,
                    611
                ],
                "left.values": [
                    627,
                    611
                ],
                "self._shallow_copy": [
                    612,
                    709,
                    1294,
                    1328,
                    658,
                    628,
                    823
                ],
                "right_end": [
                    624,
                    619
                ],
                "intersection": [
                    654
                ],
                "get_op_result_name": [
                    657,
                    817
                ],
                "timezones.is_utc": [
                    664
                ],
                "self._data._local_timestamps": [
                    665
                ],
                "fields.get_time_micros": [
                    666
                ],
                "fields": [
                    666
                ],
                "index": [
                    741,
                    708,
                    709
                ],
                "keep_tz": [
                    713,
                    723,
                    724,
                    735
                ],
                "self.copy": [
                    737
                ],
                "self.values.copy": [
                    739
                ],
                "Series": [
                    741
                ],
                "snapped": [
                    768,
                    754,
                    765
                ],
                "i": [
                    756,
                    765
                ],
                "v": [
                    756,
                    757
                ],
                "s": [
                    757,
                    758,
                    759,
                    760,
                    761,
                    762,
                    764,
                    765
                ],
                "freq.onOffset": [
                    758
                ],
                "t0": [
                    761,
                    762,
                    759
                ],
                "freq.rollback": [
                    759
                ],
                "t1": [
                    940,
                    947,
                    948,
                    760,
                    761,
                    953,
                    764,
                    958
                ],
                "freq.rollforward": [
                    760
                ],
                "DatetimeIndex._simple_new": [
                    768,
                    1585
                ],
                "other.inferred_type": [
                    777,
                    965
                ],
                "Index.join": [
                    793
                ],
                "how": [
                    796
                ],
                "level": [
                    797
                ],
                "return_indexers": [
                    798
                ],
                "other.tz": [
                    808,
                    811,
                    806
                ],
                "timezones.tz_compare": [
                    811
                ],
                "self.tz_convert": [
                    1361,
                    812
                ],
                "other.tz_convert": [
                    813
                ],
                "self._can_fast_union": [
                    821
                ],
                "joined": [
                    824,
                    825,
                    828,
                    823
                ],
                "joined.name": [
                    824
                ],
                "self._simple_new": [
                    828
                ],
                "valid_resos": [
                    858,
                    846
                ],
                "reso": [
                    1120,
                    867,
                    935,
                    872,
                    875,
                    940,
                    878,
                    1103,
                    1104,
                    883,
                    927,
                    1119,
                    858,
                    860,
                    893,
                    926,
                    863
                ],
                "Timestamp": [
                    1034,
                    1036,
                    1063,
                    1230,
                    980,
                    982,
                    861,
                    862,
                    865,
                    866,
                    870,
                    871,
                    873,
                    876,
                    879,
                    1007,
                    884,
                    1012,
                    1013,
                    894
                ],
                "parsed.year": [
                    864,
                    865,
                    866,
                    869,
                    870,
                    871,
                    873,
                    876,
                    880,
                    885,
                    861,
                    862,
                    895
                ],
                "parsed": [
                    896,
                    897,
                    898,
                    899,
                    900,
                    901,
                    908,
                    915,
                    916,
                    940,
                    1103,
                    1104,
                    861,
                    862,
                    1119,
                    864,
                    865,
                    866,
                    1120,
                    868,
                    869,
                    870,
                    871,
                    873,
                    876,
                    880,
                    885,
                    886,
                    887,
                    888,
                    889,
                    890,
                    895
                ],
                "ccalendar.get_days_in_month": [
                    864,
                    869
                ],
                "ccalendar": [
                    864,
                    869
                ],
                "parsed.month": [
                    864,
                    865,
                    866,
                    896,
                    868,
                    870,
                    873,
                    876,
                    880,
                    886
                ],
                "qe": [
                    868,
                    869,
                    871
                ],
                "parsed.day": [
                    897,
                    873,
                    876,
                    880,
                    887
                ],
                "timedelta": [
                    903,
                    874,
                    877,
                    1039,
                    882,
                    892
                ],
                "Nano": [
                    903,
                    874,
                    877,
                    882,
                    892
                ],
                "parsed.hour": [
                    880,
                    898,
                    876,
                    888
                ],
                "parsed.minute": [
                    880,
                    889,
                    899
                ],
                "parsed.second": [
                    890,
                    900
                ],
                "parsed.microsecond": [
                    901
                ],
                "parsed.tzinfo": [
                    916,
                    915,
                    908
                ],
                "tz_convert": [
                    980,
                    915,
                    916,
                    1036
                ],
                "start.tz_localize": [
                    915,
                    918
                ],
                "end.tz_localize": [
                    916,
                    919
                ],
                "is_monotonic": [
                    923,
                    925,
                    943
                ],
                "self._resolution": [
                    927
                ],
                "Resolution.get_reso": [
                    927
                ],
                "Resolution": [
                    927
                ],
                "t2": [
                    940,
                    947,
                    948,
                    954,
                    959
                ],
                "self._parsed_string_to_bounds": [
                    1104,
                    940
                ],
                "stamps": [
                    941,
                    946,
                    947,
                    948,
                    953,
                    954,
                    958,
                    959
                ],
                "use_lhs": [
                    1120,
                    953,
                    947,
                    958
                ],
                "t1.value": [
                    953,
                    947,
                    948,
                    958
                ],
                "t2.value": [
                    954,
                    947,
                    948,
                    959
                ],
                "use_rhs": [
                    1120,
                    954,
                    948,
                    959
                ],
                "stamps.searchsorted": [
                    953,
                    954
                ],
                "lhs_mask": [
                    962,
                    958
                ],
                "rhs_mask": [
                    962,
                    959
                ],
                "nonzero": [
                    962,
                    1365
                ],
                "key": [
                    1029,
                    1031,
                    1033,
                    1034,
                    1036,
                    1037,
                    1039,
                    1043,
                    1047,
                    1052,
                    1055,
                    1058,
                    1063,
                    1070,
                    1075,
                    1218,
                    975,
                    979,
                    980,
                    982,
                    984,
                    986,
                    987,
                    991,
                    1119,
                    994,
                    1000,
                    1002,
                    1007,
                    1008,
                    1009,
                    1011,
                    1012,
                    1013,
                    1014,
                    1015
                ],
                "datetime": [
                    1031,
                    1278,
                    975
                ],
                "key.tzinfo": [
                    1008,
                    1033,
                    979
                ],
                "tz_localize": [
                    982
                ],
                "self.get_value_maybe_box": [
                    984,
                    1000
                ],
                "series": [
                    995,
                    1000,
                    1014,
                    1015,
                    984,
                    988,
                    991
                ],
                "time": [
                    1697,
                    1698,
                    1353,
                    1098,
                    1356,
                    1358,
                    1361,
                    1140,
                    1364,
                    1047,
                    1145,
                    986
                ],
                "locs": [
                    987,
                    988
                ],
                "self.indexer_at_time": [
                    987,
                    1052
                ],
                "series.take": [
                    988
                ],
                "com.maybe_box": [
                    1015,
                    991
                ],
                "com": [
                    1015,
                    1572,
                    1014,
                    991
                ],
                "Index.get_value": [
                    991
                ],
                "self._get_string_slice": [
                    994,
                    1058
                ],
                "key.tz_convert": [
                    1009
                ],
                "key.tz_localize": [
                    1011
                ],
                "self._engine.get_value": [
                    1014
                ],
                "self._engine": [
                    1014
                ],
                "com.values_from_object": [
                    1014
                ],
                "tolerance": [
                    1026,
                    1029,
                    1068,
                    1037,
                    1055
                ],
                "self._convert_tolerance": [
                    1029
                ],
                "Index.get_loc": [
                    1068,
                    1037,
                    1055
                ],
                "method": [
                    1048,
                    1068,
                    1037,
                    1055
                ],
                "stamp": [
                    1063,
                    1064,
                    1065,
                    1067,
                    1068
                ],
                "stamp.tzinfo": [
                    1064
                ],
                "stamp.tz_convert": [
                    1065
                ],
                "stamp.tz_localize": [
                    1067
                ],
                "e": [
                    1073,
                    1074
                ],
                "kind": [
                    1096,
                    1163,
                    1149,
                    1159
                ],
                "is_float": [
                    1098
                ],
                "label": [
                    1098,
                    1099,
                    1101,
                    1103,
                    1115
                ],
                "is_integer": [
                    1098,
                    1318
                ],
                "self._invalid_indexer": [
                    1099
                ],
                "_": [
                    1119,
                    1103
                ],
                "parsing.parse_time_string": [
                    1119,
                    1103
                ],
                "parsing": [
                    1119,
                    1103
                ],
                "lower": [
                    1104,
                    1113,
                    1112
                ],
                "upper": [
                    1104,
                    1113,
                    1112
                ],
                "self._is_strictly_monotonic_decreasing": [
                    1111
                ],
                "side": [
                    1112,
                    1113,
                    1242
                ],
                "self._partial_date_slice": [
                    1120
                ],
                "step": [
                    1149,
                    1141,
                    1166
                ],
                "self.indexer_between_time": [
                    1143
                ],
                "Index.slice_indexer": [
                    1149
                ],
                "mask": [
                    1413,
                    1157,
                    1415,
                    1160,
                    1164,
                    1166
                ],
                "start_casted": [
                    1160,
                    1159
                ],
                "self._maybe_cast_slice_bound": [
                    1163,
                    1159
                ],
                "end_casted": [
                    1163,
                    1164
                ],
                "indexer": [
                    1170,
                    1166,
                    1167
                ],
                "mask.nonzero": [
                    1166,
                    1415
                ],
                "_is_monotonic_increasing": [
                    1178
                ],
                "Index.is_monotonic_increasing": [
                    1178
                ],
                "_is_monotonic_decreasing": [
                    1179
                ],
                "Index.is_monotonic_decreasing": [
                    1179
                ],
                "_is_unique": [
                    1180
                ],
                "Index.is_unique": [
                    1180
                ],
                "_timezone": [
                    1182
                ],
                "DatetimeArray._timezone.fget": [
                    1182
                ],
                "DatetimeArray._timezone": [
                    1182
                ],
                "is_normalized": [
                    1183
                ],
                "DatetimeArray.is_normalized.fget": [
                    1183
                ],
                "DatetimeArray.is_normalized": [
                    1183
                ],
                "_resolution": [
                    1184
                ],
                "DatetimeArray._resolution.fget": [
                    1184
                ],
                "DatetimeArray._resolution": [
                    1184
                ],
                "strftime": [
                    1186
                ],
                "ea_passthrough": [
                    1186,
                    1187
                ],
                "DatetimeArray.strftime": [
                    1186
                ],
                "_has_same_tz": [
                    1187
                ],
                "DatetimeArray._has_same_tz": [
                    1187
                ],
                "offset.setter": [
                    1203
                ],
                "offset": [
                    1203
                ],
                "self._data.__getitem__": [
                    1218
                ],
                "result.ndim": [
                    1221
                ],
                "np.array": [
                    1323,
                    1238
                ],
                "self.values.searchsorted": [
                    1242
                ],
                "Substitution": [
                    1234
                ],
                "Appender": [
                    1235
                ],
                "_shared_docs": [
                    1235
                ],
                "typ": [
                    1245
                ],
                "self.inferred_type": [
                    1245
                ],
                "item": [
                    1280,
                    1284,
                    1286,
                    1288,
                    1292,
                    1298,
                    1299,
                    1272,
                    1274,
                    1278,
                    1279
                ],
                "isna": [
                    1272,
                    1280
                ],
                "self._na_value": [
                    1274
                ],
                "np.datetime64": [
                    1278
                ],
                "self._assert_can_do_op": [
                    1279
                ],
                "self.size": [
                    1283
                ],
                "new_dates": [
                    1328,
                    1315,
                    1291,
                    1294
                ],
                "np.concatenate": [
                    1291
                ],
                "asi8": [
                    1292
                ],
                "item.view": [
                    1292
                ],
                "np.int64": [
                    1292
                ],
                "insert": [
                    1299
                ],
                "self.astype": [
                    1299
                ],
                "np.delete": [
                    1315
                ],
                "is_list_like": [
                    1322
                ],
                "lib.maybe_indices_to_slice": [
                    1323
                ],
                "lib": [
                    1323
                ],
                "ensure_int64": [
                    1323
                ],
                "loc.step": [
                    1324
                ],
                "loc.start": [
                    1325
                ],
                "loc.stop": [
                    1325
                ],
                "asof": [
                    1350
                ],
                "parse": [
                    1356
                ],
                "time.tzinfo": [
                    1361,
                    1358
                ],
                "time_micros": [
                    1413,
                    1361,
                    1393,
                    1363,
                    1365
                ],
                "_get_time_micros": [
                    1361
                ],
                "self._get_time_micros": [
                    1393,
                    1363
                ],
                "micros": [
                    1364,
                    1365
                ],
                "_time_to_micros": [
                    1394,
                    1395,
                    1364
                ],
                "start_time": [
                    1408,
                    1394,
                    1391
                ],
                "tools.to_time": [
                    1392,
                    1391
                ],
                "tools": [
                    1392,
                    1391
                ],
                "end_time": [
                    1392,
                    1395,
                    1408
                ],
                "start_micros": [
                    1394,
                    1413
                ],
                "end_micros": [
                    1395,
                    1413
                ],
                "include_start": [
                    1397,
                    1399
                ],
                "include_end": [
                    1402,
                    1397
                ],
                "lop": [
                    1413,
                    1398,
                    1400,
                    1403,
                    1406
                ],
                "rop": [
                    1413,
                    1398,
                    1401,
                    1404,
                    1406
                ],
                "operator.le": [
                    1400,
                    1404,
                    1398
                ],
                "operator": [
                    1409,
                    1411,
                    1398,
                    1400,
                    1401,
                    1403,
                    1404,
                    1406
                ],
                "operator.lt": [
                    1401,
                    1403,
                    1406
                ],
                "join_op": [
                    1409,
                    1411,
                    1413
                ],
                "operator.and_": [
                    1409
                ],
                "operator.or_": [
                    1411
                ],
                "delegate_names": [
                    88,
                    91
                ],
                "DatetimeDelegateMixin._delegated_properties": [
                    89
                ],
                "DatetimeDelegateMixin._delegated_methods": [
                    93
                ],
                "DatetimeIndex._add_comparison_ops": [
                    1418
                ],
                "DatetimeIndex._add_numeric_methods_disabled": [
                    1419
                ],
                "DatetimeIndex._add_logical_methods_disabled": [
                    1420
                ],
                "DatetimeIndex._add_datetimelike_methods": [
                    1421
                ],
                "com.any_none": [
                    1572
                ],
                "is_string_like": [
                    1669
                ],
                "freq.startswith": [
                    1669
                ],
                "weekmask": [
                    1672,
                    1676,
                    1671
                ],
                "prefix_mapping": [
                    1672
                ],
                "holidays": [
                    1672,
                    1676
                ],
                "date_range": [
                    1683
                ],
                "seconds": [
                    1697,
                    1698
                ],
                "time.hour": [
                    1697
                ],
                "time.minute": [
                    1697
                ],
                "time.second": [
                    1697
                ],
                "time.microsecond": [
                    1698
                ]
            }
        },
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_167/pandas/core/indexes/period.py": {
            "buggy_functions": [],
            "snippets": [
                {
                    "snippet_code": "_engine_type = libindex.PeriodEngine",
                    "start_line": 175,
                    "end_line": 176
                }
            ],
            "inscope_functions": [
                "def _new_PeriodIndex(cls, **d):\n    # GH13277 for unpickling\n    values = d.pop(\"data\")\n    if values.dtype == \"int64\":\n        freq = d.pop(\"freq\", None)\n        values = PeriodArray(values, freq=freq)\n        return cls._simple_new(values, **d)\n    else:\n        return cls(values, **d)",
                "def period_range(start=None, end=None, periods=None, freq=None, name=None):\n    \"\"\"\n    Return a fixed frequency PeriodIndex, with day (calendar) as the default\n    frequency\n\n    Parameters\n    ----------\n    start : string or period-like, default None\n        Left bound for generating periods\n    end : string or period-like, default None\n        Right bound for generating periods\n    periods : integer, default None\n        Number of periods to generate\n    freq : string or DateOffset, optional\n        Frequency alias. By default the freq is taken from `start` or `end`\n        if those are Period objects. Otherwise, the default is ``\"D\"`` for\n        daily frequency.\n\n    name : string, default None\n        Name of the resulting PeriodIndex\n\n    Returns\n    -------\n    prng : PeriodIndex\n\n    Notes\n    -----\n    Of the three parameters: ``start``, ``end``, and ``periods``, exactly two\n    must be specified.\n\n    To learn more about the frequency strings, please see `this link\n    <http://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\n\n    Examples\n    --------\n\n    >>> pd.period_range(start='2017-01-01', end='2018-01-01', freq='M')\n    PeriodIndex(['2017-01', '2017-02', '2017-03', '2017-04', '2017-05',\n                 '2017-06', '2017-06', '2017-07', '2017-08', '2017-09',\n                 '2017-10', '2017-11', '2017-12', '2018-01'],\n                dtype='period[M]', freq='M')\n\n    If ``start`` or ``end`` are ``Period`` objects, they will be used as anchor\n    endpoints for a ``PeriodIndex`` with frequency matching that of the\n    ``period_range`` constructor.\n\n    >>> pd.period_range(start=pd.Period('2017Q1', freq='Q'),\n    ...                 end=pd.Period('2017Q2', freq='Q'), freq='M')\n    PeriodIndex(['2017-03', '2017-04', '2017-05', '2017-06'],\n                dtype='period[M]', freq='M')\n    \"\"\"\n    if com.count_not_none(start, end, periods) != 2:\n        raise ValueError(\n            \"Of the three parameters: start, end, and periods, \"\n            \"exactly two must be specified\"\n        )\n    if freq is None and (not isinstance(start, Period) and not isinstance(end, Period)):\n        freq = \"D\"\n\n    data, freq = PeriodArray._generate_range(start, end, periods, freq, fields={})\n    data = PeriodArray(data, freq=freq)\n    return PeriodIndex(data, name=name)",
                "def __new__(\n    cls,\n    data=None,\n    ordinal=None,\n    freq=None,\n    start=None,\n    end=None,\n    periods=None,\n    tz=None,\n    dtype=None,\n    copy=False,\n    name=None,\n    **fields\n):\n\n    valid_field_set = {\n        \"year\",\n        \"month\",\n        \"day\",\n        \"quarter\",\n        \"hour\",\n        \"minute\",\n        \"second\",\n    }\n\n    if not set(fields).issubset(valid_field_set):\n        raise TypeError(\n            \"__new__() got an unexpected keyword argument {}\".format(\n                list(set(fields) - valid_field_set)[0]\n            )\n        )\n\n    if name is None and hasattr(data, \"name\"):\n        name = data.name\n\n    if data is None and ordinal is None:\n        # range-based.\n        data, freq2 = PeriodArray._generate_range(start, end, periods, freq, fields)\n        # PeriodArray._generate range does validate that fields is\n        # empty when really using the range-based constructor.\n        if not fields:\n            msg = (\n                \"Creating a PeriodIndex by passing range \"\n                \"endpoints is deprecated.  Use \"\n                \"`pandas.period_range` instead.\"\n            )\n            # period_range differs from PeriodIndex for cases like\n            # start=\"2000\", periods=4\n            # PeriodIndex interprets that as A-DEC freq.\n            # period_range interprets it as 'D' freq.\n            cond = freq is None and (\n                (start and not isinstance(start, Period))\n                or (end and not isinstance(end, Period))\n            )\n            if cond:\n                msg += (\n                    \" Note that the default `freq` may differ. Pass \"\n                    \"'freq=\\\"{}\\\"' to ensure the same output.\"\n                ).format(freq2.freqstr)\n            warnings.warn(msg, FutureWarning, stacklevel=2)\n        freq = freq2\n\n        data = PeriodArray(data, freq=freq)\n    else:\n        freq = validate_dtype_freq(dtype, freq)\n\n        # PeriodIndex allow PeriodIndex(period_index, freq=different)\n        # Let's not encourage that kind of behavior in PeriodArray.\n\n        if freq and isinstance(data, cls) and data.freq != freq:\n            # TODO: We can do some of these with no-copy / coercion?\n            # e.g. D -> 2D seems to be OK\n            data = data.asfreq(freq)\n\n        if data is None and ordinal is not None:\n            # we strangely ignore `ordinal` if data is passed.\n            ordinal = np.asarray(ordinal, dtype=np.int64)\n            data = PeriodArray(ordinal, freq)\n        else:\n            # don't pass copy here, since we copy later.\n            data = period_array(data=data, freq=freq)\n\n    if copy:\n        data = data.copy()\n\n    return cls._simple_new(data, name=name)",
                "@classmethod\ndef _simple_new(cls, values, name=None, freq=None, **kwargs):\n    \"\"\"\n    Create a new PeriodIndex.\n\n    Parameters\n    ----------\n    values : PeriodArray, PeriodIndex, Index[int64], ndarray[int64]\n        Values that can be converted to a PeriodArray without inference\n        or coercion.\n\n    \"\"\"\n    # TODO: raising on floats is tested, but maybe not useful.\n    # Should the callers know not to pass floats?\n    # At the very least, I think we can ensure that lists aren't passed.\n    if isinstance(values, list):\n        values = np.asarray(values)\n    if is_float_dtype(values):\n        raise TypeError(\"PeriodIndex._simple_new does not accept floats.\")\n    if freq:\n        freq = Period._maybe_convert_freq(freq)\n    values = PeriodArray(values, freq=freq)\n\n    if not isinstance(values, PeriodArray):\n        raise TypeError(\"PeriodIndex._simple_new only accepts PeriodArray\")\n    result = object.__new__(cls)\n    result._data = values\n    # For groupby perf. See note in indexes/base about _index_data\n    result._index_data = values._data\n    result.name = name\n    result._reset_identity()\n    return result",
                "@property\ndef values(self):\n    return np.asarray(self)",
                "@property\ndef freq(self):\n    return self._data.freq",
                "@freq.setter\ndef freq(self, value):\n    value = Period._maybe_convert_freq(value)\n    # TODO: When this deprecation is enforced, PeriodIndex.freq can\n    # be removed entirely, and we'll just inherit.\n    msg = (\n        \"Setting {cls}.freq has been deprecated and will be \"\n        \"removed in a future version; use {cls}.asfreq instead. \"\n        \"The {cls}.freq setter is not guaranteed to work.\"\n    )\n    warnings.warn(msg.format(cls=type(self).__name__), FutureWarning, stacklevel=2)\n    # PeriodArray._freq isn't actually mutable. We set the private _freq\n    # here, but people shouldn't be doing this anyway.\n    self._data._freq = value",
                "def _shallow_copy(self, values=None, **kwargs):\n    # TODO: simplify, figure out type of values\n    if values is None:\n        values = self._data\n\n    if isinstance(values, type(self)):\n        values = values._values\n\n    if not isinstance(values, PeriodArray):\n        if isinstance(values, np.ndarray) and is_integer_dtype(values.dtype):\n            values = PeriodArray(values, freq=self.freq)\n        else:\n            # in particular, I would like to avoid period_array here.\n            # Some people seem to be calling use with unexpected types\n            # Index.difference -> ndarray[Period]\n            # DatetimelikeIndexOpsMixin.repeat -> ndarray[ordinal]\n            # I think that once all of Datetime* are EAs, we can simplify\n            # this quite a bit.\n            values = period_array(values, freq=self.freq)\n\n    # We don't allow changing `freq` in _shallow_copy.\n    validate_dtype_freq(self.dtype, kwargs.get(\"freq\"))\n    attributes = self._get_attributes_dict()\n\n    attributes.update(kwargs)\n    if not len(values) and \"dtype\" not in kwargs:\n        attributes[\"dtype\"] = self.dtype\n    return self._simple_new(values, **attributes)",
                "def _shallow_copy_with_infer(self, values=None, **kwargs):\n    \"\"\" we always want to return a PeriodIndex \"\"\"\n    return self._shallow_copy(values=values, **kwargs)",
                "@property\ndef _box_func(self):\n    \"\"\"Maybe box an ordinal or Period\"\"\"\n    # TODO(DatetimeArray): Avoid double-boxing\n    # PeriodArray takes care of boxing already, so we need to check\n    # whether we're given an ordinal or a Period. It seems like some\n    # places outside of indexes/period.py are calling this _box_func,\n    # but passing data that's already boxed.\n    def func(x):\n        if isinstance(x, Period) or x is NaT:\n            return x\n        else:\n            return Period._from_ordinal(ordinal=x, freq=self.freq)\n\n    return func",
                "def _maybe_convert_timedelta(self, other):\n    \"\"\"\n    Convert timedelta-like input to an integer multiple of self.freq\n\n    Parameters\n    ----------\n    other : timedelta, np.timedelta64, DateOffset, int, np.ndarray\n\n    Returns\n    -------\n    converted : int, np.ndarray[int64]\n\n    Raises\n    ------\n    IncompatibleFrequency : if the input cannot be written as a multiple\n        of self.freq.  Note IncompatibleFrequency subclasses ValueError.\n    \"\"\"\n    if isinstance(other, (timedelta, np.timedelta64, Tick, np.ndarray)):\n        offset = frequencies.to_offset(self.freq.rule_code)\n        if isinstance(offset, Tick):\n            # _check_timedeltalike_freq_compat will raise if incompatible\n            delta = self._data._check_timedeltalike_freq_compat(other)\n            return delta\n    elif isinstance(other, DateOffset):\n        freqstr = other.rule_code\n        base = libfrequencies.get_base_alias(freqstr)\n        if base == self.freq.rule_code:\n            return other.n\n\n        msg = DIFFERENT_FREQ.format(\n            cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr\n        )\n        raise IncompatibleFrequency(msg)\n    elif is_integer(other):\n        # integer is passed to .shift via\n        # _add_datetimelike_methods basically\n        # but ufunc may pass integer to _add_delta\n        return other\n\n    # raise when input doesn't have freq\n    msg = DIFFERENT_FREQ.format(\n        cls=type(self).__name__, own_freq=self.freqstr, other_freq=None\n    )\n    raise IncompatibleFrequency(msg)",
                "def _format_native_types(self, na_rep=\"NaT\", quoting=None, **kwargs):\n    # just dispatch, return ndarray\n    return self._data._format_native_types(na_rep=na_rep, quoting=quoting, **kwargs)",
                "def _mpl_repr(self):\n    # how to represent ourselves to matplotlib\n    return self.astype(object).values",
                "@property\ndef _formatter_func(self):\n    return self.array._formatter(boxed=False)",
                "@cache_readonly\ndef _engine(self):\n    return self._engine_type(lambda: self, len(self))",
                "@Appender(_index_shared_docs[\"contains\"])\ndef __contains__(self, key):\n    if isinstance(key, Period):\n        if key.freq != self.freq:\n            return False\n        else:\n            return key.ordinal in self._engine\n    else:\n        try:\n            self.get_loc(key)\n            return True\n        except Exception:\n            return False",
                "@cache_readonly\ndef _int64index(self):\n    return Int64Index._simple_new(self.asi8, name=self.name)",
                "def _coerce_scalar_to_index(self, item):\n    \"\"\"\n    we need to coerce a scalar to a compat for our index type\n\n    Parameters\n    ----------\n    item : scalar item to coerce\n    \"\"\"\n    return PeriodIndex([item], **self._get_attributes_dict())",
                "def __array__(self, dtype=None):\n    if is_integer_dtype(dtype):\n        return self.asi8\n    else:\n        return self.astype(object).values",
                "def __array_wrap__(self, result, context=None):\n    \"\"\"\n    Gets called after a ufunc. Needs additional handling as\n    PeriodIndex stores internal data as int dtype\n\n    Replace this to __numpy_ufunc__ in future version\n    \"\"\"\n    if isinstance(context, tuple) and len(context) > 0:\n        func = context[0]\n        if func is np.add:\n            pass\n        elif func is np.subtract:\n            name = self.name\n            left = context[1][0]\n            right = context[1][1]\n            if isinstance(left, PeriodIndex) and isinstance(right, PeriodIndex):\n                name = left.name if left.name == right.name else None\n                return Index(result, name=name)\n            elif isinstance(left, Period) or isinstance(right, Period):\n                return Index(result, name=name)\n        elif isinstance(func, np.ufunc):\n            if \"M->M\" not in func.types:\n                msg = \"ufunc '{0}' not supported for the PeriodIndex\"\n                # This should be TypeError, but TypeError cannot be raised\n                # from here because numpy catches.\n                raise ValueError(msg.format(func.__name__))\n\n    if is_bool_dtype(result):\n        return result\n    # the result is object dtype array of Period\n    # cannot pass _simple_new as it is\n    return type(self)(result, freq=self.freq, name=self.name)",
                "def asof_locs(self, where, mask):\n    \"\"\"\n    where : array of timestamps\n    mask : array of booleans where data is not NA\n\n    \"\"\"\n    where_idx = where\n    if isinstance(where_idx, DatetimeIndex):\n        where_idx = PeriodIndex(where_idx.values, freq=self.freq)\n\n    locs = self._ndarray_values[mask].searchsorted(\n        where_idx._ndarray_values, side=\"right\"\n    )\n\n    locs = np.where(locs > 0, locs - 1, 0)\n    result = np.arange(len(self))[mask].take(locs)\n\n    first = mask.argmax()\n    result[\n        (locs == 0) & (where_idx._ndarray_values < self._ndarray_values[first])\n    ] = -1\n\n    return result",
                "@Appender(_index_shared_docs[\"astype\"])\ndef astype(self, dtype, copy=True, how=\"start\"):\n    dtype = pandas_dtype(dtype)\n\n    if is_datetime64_any_dtype(dtype):\n        # 'how' is index-specific, isn't part of the EA interface.\n        tz = getattr(dtype, \"tz\", None)\n        return self.to_timestamp(how=how).tz_localize(tz)\n\n    # TODO: should probably raise on `how` here, so we don't ignore it.\n    return super().astype(dtype, copy=copy)",
                "@Substitution(klass=\"PeriodIndex\")\n@Appender(_shared_docs[\"searchsorted\"])\ndef searchsorted(self, value, side=\"left\", sorter=None):\n    if isinstance(value, Period):\n        if value.freq != self.freq:\n            msg = DIFFERENT_FREQ.format(\n                cls=type(self).__name__,\n                own_freq=self.freqstr,\n                other_freq=value.freqstr,\n            )\n            raise IncompatibleFrequency(msg)\n        value = value.ordinal\n    elif isinstance(value, str):\n        try:\n            value = Period(value, freq=self.freq).ordinal\n        except DateParseError:\n            raise KeyError(\"Cannot interpret '{}' as period\".format(value))\n\n    return self._ndarray_values.searchsorted(value, side=side, sorter=sorter)",
                "@property\ndef is_all_dates(self):\n    return True",
                "@property\ndef is_full(self):\n    \"\"\"\n    Returns True if this PeriodIndex is range-like in that all Periods\n    between start and end are present, in order.\n    \"\"\"\n    if len(self) == 0:\n        return True\n    if not self.is_monotonic:\n        raise ValueError(\"Index is not monotonic\")\n    values = self.asi8\n    return ((values[1:] - values[:-1]) < 2).all()",
                "@property\ndef inferred_type(self):\n    # b/c data is represented as ints make sure we can't have ambiguous\n    # indexing\n    return \"period\"",
                "def get_value(self, series, key):\n    \"\"\"\n    Fast lookup of value from 1-dimensional ndarray. Only use this if you\n    know what you're doing\n    \"\"\"\n    s = com.values_from_object(series)\n    try:\n        return com.maybe_box(self, super().get_value(s, key), series, key)\n    except (KeyError, IndexError):\n        try:\n            asdt, parsed, reso = parse_time_string(key, self.freq)\n            grp = resolution.Resolution.get_freq_group(reso)\n            freqn = resolution.get_freq_group(self.freq)\n\n            vals = self._ndarray_values\n\n            # if our data is higher resolution than requested key, slice\n            if grp < freqn:\n                iv = Period(asdt, freq=(grp, 1))\n                ord1 = iv.asfreq(self.freq, how=\"S\").ordinal\n                ord2 = iv.asfreq(self.freq, how=\"E\").ordinal\n\n                if ord2 < vals[0] or ord1 > vals[-1]:\n                    raise KeyError(key)\n\n                pos = np.searchsorted(self._ndarray_values, [ord1, ord2])\n                key = slice(pos[0], pos[1] + 1)\n                return series[key]\n            elif grp == freqn:\n                key = Period(asdt, freq=self.freq).ordinal\n                return com.maybe_box(\n                    self, self._int64index.get_value(s, key), series, key\n                )\n            else:\n                raise KeyError(key)\n        except TypeError:\n            pass\n\n        period = Period(key, self.freq)\n        key = period.value if isna(period) else period.ordinal\n        return com.maybe_box(self, self._int64index.get_value(s, key), series, key)",
                "@Appender(_index_shared_docs[\"get_indexer\"] % _index_doc_kwargs)\ndef get_indexer(self, target, method=None, limit=None, tolerance=None):\n    target = ensure_index(target)\n\n    if hasattr(target, \"freq\") and target.freq != self.freq:\n        msg = DIFFERENT_FREQ.format(\n            cls=type(self).__name__,\n            own_freq=self.freqstr,\n            other_freq=target.freqstr,\n        )\n        raise IncompatibleFrequency(msg)\n\n    if isinstance(target, PeriodIndex):\n        target = target.asi8\n\n    if tolerance is not None:\n        tolerance = self._convert_tolerance(tolerance, target)\n    return Index.get_indexer(self._int64index, target, method, limit, tolerance)",
                "@Appender(_index_shared_docs[\"get_indexer_non_unique\"] % _index_doc_kwargs)\ndef get_indexer_non_unique(self, target):\n    target = ensure_index(target)\n\n    if isinstance(target, PeriodIndex):\n        target = target.asi8\n        if hasattr(target, \"freq\") and target.freq != self.freq:\n            msg = DIFFERENT_FREQ.format(\n                cls=type(self).__name__,\n                own_freq=self.freqstr,\n                other_freq=target.freqstr,\n            )\n            raise IncompatibleFrequency(msg)\n\n    indexer, missing = self._int64index.get_indexer_non_unique(target)\n    return ensure_platform_int(indexer), missing",
                "def _get_unique_index(self, dropna=False):\n    \"\"\"\n    wrap Index._get_unique_index to handle NaT\n    \"\"\"\n    res = super()._get_unique_index(dropna=dropna)\n    if dropna:\n        res = res.dropna()\n    return res",
                "@Appender(Index.unique.__doc__)\ndef unique(self, level=None):\n    # override the Index.unique method for performance GH#23083\n    if level is not None:\n        # this should never occur, but is retained to make the signature\n        # match Index.unique\n        self._validate_index_level(level)\n\n    values = self._ndarray_values\n    result = unique1d(values)\n    return self._shallow_copy(result)",
                "def get_loc(self, key, method=None, tolerance=None):\n    \"\"\"\n    Get integer location for requested label\n\n    Returns\n    -------\n    loc : int\n    \"\"\"\n    try:\n        return self._engine.get_loc(key)\n    except KeyError:\n        if is_integer(key):\n            raise\n\n        try:\n            asdt, parsed, reso = parse_time_string(key, self.freq)\n            key = asdt\n        except TypeError:\n            pass\n        except DateParseError:\n            # A string with invalid format\n            raise KeyError(\"Cannot interpret '{}' as period\".format(key))\n\n        try:\n            key = Period(key, freq=self.freq)\n        except ValueError:\n            # we cannot construct the Period\n            # as we have an invalid type\n            raise KeyError(key)\n\n        try:\n            ordinal = iNaT if key is NaT else key.ordinal\n            if tolerance is not None:\n                tolerance = self._convert_tolerance(tolerance, np.asarray(key))\n            return self._int64index.get_loc(ordinal, method, tolerance)\n\n        except KeyError:\n            raise KeyError(key)",
                "def _maybe_cast_slice_bound(self, label, side, kind):\n    \"\"\"\n    If label is a string or a datetime, cast it to Period.ordinal according\n    to resolution.\n\n    Parameters\n    ----------\n    label : object\n    side : {'left', 'right'}\n    kind : {'ix', 'loc', 'getitem'}\n\n    Returns\n    -------\n    bound : Period or object\n\n    Notes\n    -----\n    Value of `side` parameter should be validated in caller.\n\n    \"\"\"\n    assert kind in [\"ix\", \"loc\", \"getitem\"]\n\n    if isinstance(label, datetime):\n        return Period(label, freq=self.freq)\n    elif isinstance(label, str):\n        try:\n            _, parsed, reso = parse_time_string(label, self.freq)\n            bounds = self._parsed_string_to_bounds(reso, parsed)\n            return bounds[0 if side == \"left\" else 1]\n        except Exception:\n            raise KeyError(label)\n    elif is_integer(label) or is_float(label):\n        self._invalid_indexer(\"slice\", label)\n\n    return label",
                "def _parsed_string_to_bounds(self, reso, parsed):\n    if reso == \"year\":\n        t1 = Period(year=parsed.year, freq=\"A\")\n    elif reso == \"month\":\n        t1 = Period(year=parsed.year, month=parsed.month, freq=\"M\")\n    elif reso == \"quarter\":\n        q = (parsed.month - 1) // 3 + 1\n        t1 = Period(year=parsed.year, quarter=q, freq=\"Q-DEC\")\n    elif reso == \"day\":\n        t1 = Period(year=parsed.year, month=parsed.month, day=parsed.day, freq=\"D\")\n    elif reso == \"hour\":\n        t1 = Period(\n            year=parsed.year,\n            month=parsed.month,\n            day=parsed.day,\n            hour=parsed.hour,\n            freq=\"H\",\n        )\n    elif reso == \"minute\":\n        t1 = Period(\n            year=parsed.year,\n            month=parsed.month,\n            day=parsed.day,\n            hour=parsed.hour,\n            minute=parsed.minute,\n            freq=\"T\",\n        )\n    elif reso == \"second\":\n        t1 = Period(\n            year=parsed.year,\n            month=parsed.month,\n            day=parsed.day,\n            hour=parsed.hour,\n            minute=parsed.minute,\n            second=parsed.second,\n            freq=\"S\",\n        )\n    else:\n        raise KeyError(reso)\n    return (t1.asfreq(self.freq, how=\"start\"), t1.asfreq(self.freq, how=\"end\"))",
                "def _get_string_slice(self, key):\n    if not self.is_monotonic:\n        raise ValueError(\"Partial indexing only valid for ordered time series\")\n\n    key, parsed, reso = parse_time_string(key, self.freq)\n    grp = resolution.Resolution.get_freq_group(reso)\n    freqn = resolution.get_freq_group(self.freq)\n    if reso in [\"day\", \"hour\", \"minute\", \"second\"] and not grp < freqn:\n        raise KeyError(key)\n\n    t1, t2 = self._parsed_string_to_bounds(reso, parsed)\n    return slice(\n        self.searchsorted(t1.ordinal, side=\"left\"),\n        self.searchsorted(t2.ordinal, side=\"right\"),\n    )",
                "def _convert_tolerance(self, tolerance, target):\n    tolerance = DatetimeIndexOpsMixin._convert_tolerance(self, tolerance, target)\n    if target.size != tolerance.size and tolerance.size > 1:\n        raise ValueError(\"list-like tolerance size must match target index size\")\n    return self._maybe_convert_timedelta(tolerance)",
                "def insert(self, loc, item):\n    if not isinstance(item, Period) or self.freq != item.freq:\n        return self.astype(object).insert(loc, item)\n\n    idx = np.concatenate(\n        (self[:loc].asi8, np.array([item.ordinal]), self[loc:].asi8)\n    )\n    return self._shallow_copy(idx)",
                "def join(self, other, how=\"left\", level=None, return_indexers=False, sort=False):\n    \"\"\"\n    See Index.join\n    \"\"\"\n    self._assert_can_do_setop(other)\n\n    if not isinstance(other, PeriodIndex):\n        return self.astype(object).join(\n            other, how=how, level=level, return_indexers=return_indexers, sort=sort\n        )\n\n    result = Int64Index.join(\n        self,\n        other,\n        how=how,\n        level=level,\n        return_indexers=return_indexers,\n        sort=sort,\n    )\n\n    if return_indexers:\n        result, lidx, ridx = result\n        return self._apply_meta(result), lidx, ridx\n    return self._apply_meta(result)",
                "@Appender(Index.intersection.__doc__)\ndef intersection(self, other, sort=False):\n    return Index.intersection(self, other, sort=sort)",
                "def _assert_can_do_setop(self, other):\n    super()._assert_can_do_setop(other)\n\n    # *Can't* use PeriodIndexes of different freqs\n    # *Can* use PeriodIndex/DatetimeIndex\n    if isinstance(other, PeriodIndex) and self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(\n            cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr\n        )\n        raise IncompatibleFrequency(msg)",
                "def _wrap_setop_result(self, other, result):\n    name = get_op_result_name(self, other)\n    result = self._apply_meta(result)\n    result.name = name\n    return result",
                "def _apply_meta(self, rawarr):\n    if not isinstance(rawarr, PeriodIndex):\n        rawarr = PeriodIndex._simple_new(rawarr, freq=self.freq, name=self.name)\n    return rawarr",
                "def __setstate__(self, state):\n    \"\"\"Necessary for making this object picklable\"\"\"\n\n    if isinstance(state, dict):\n        super().__setstate__(state)\n\n    elif isinstance(state, tuple):\n\n        # < 0.15 compat\n        if len(state) == 2:\n            nd_state, own_state = state\n            data = np.empty(nd_state[1], dtype=nd_state[2])\n            np.ndarray.__setstate__(data, nd_state)\n\n            # backcompat\n            freq = Period._maybe_convert_freq(own_state[1])\n\n        else:  # pragma: no cover\n            data = np.empty(state)\n            np.ndarray.__setstate__(self, state)\n            freq = None  # ?\n\n        data = PeriodArray(data, freq=freq)\n        self._data = data\n\n    else:\n        raise Exception(\"invalid pickle state\")",
                "@property\ndef flags(self):\n    \"\"\" return the ndarray.flags for the underlying data \"\"\"\n    warnings.warn(\n        \"{obj}.flags is deprecated and will be removed \"\n        \"in a future version\".format(obj=type(self).__name__),\n        FutureWarning,\n        stacklevel=2,\n    )\n    return self._ndarray_values.flags",
                "def item(self):\n    \"\"\"\n    return the first element of the underlying data as a python\n    scalar\n\n    .. deprecated:: 0.25.0\n\n    \"\"\"\n    warnings.warn(\n        \"`item` has been deprecated and will be removed in a future version\",\n        FutureWarning,\n        stacklevel=2,\n    )\n    # TODO(DatetimeArray): remove\n    if len(self) == 1:\n        return self[0]\n    else:\n        # TODO: is this still necessary?\n        # copy numpy's message here because Py26 raises an IndexError\n        raise ValueError(\"can only convert an array of size 1 to a Python scalar\")",
                "@property\ndef data(self):\n    \"\"\" return the data pointer of the underlying data \"\"\"\n    warnings.warn(\n        \"{obj}.data is deprecated and will be removed \"\n        \"in a future version\".format(obj=type(self).__name__),\n        FutureWarning,\n        stacklevel=2,\n    )\n    return np.asarray(self._data).data",
                "@property\ndef base(self):\n    \"\"\" return the base object if the memory of the underlying data is\n    shared\n    \"\"\"\n    warnings.warn(\n        \"{obj}.base is deprecated and will be removed \"\n        \"in a future version\".format(obj=type(self).__name__),\n        FutureWarning,\n        stacklevel=2,\n    )\n    return np.asarray(self._data)",
                "def memory_usage(self, deep=False):\n    result = super().memory_usage(deep=deep)\n    if hasattr(self, \"_cache\") and \"_int64index\" in self._cache:\n        result += self._int64index.memory_usage(deep=deep)\n    return result",
                "def func(x):\n    if isinstance(x, Period) or x is NaT:\n        return x\n    else:\n        return Period._from_ordinal(ordinal=x, freq=self.freq)"
            ],
            "inscope_function_signatures": [
                "_new_PeriodIndex(cls, **d)",
                "period_range(start=None, end=None, periods=None, freq=None, name=None)",
                "__new__(cls, data=None, ordinal=None, freq=None, start=None, end=None, periods=None, tz=None, dtype=None, copy=False, name=None, **fields)",
                "_simple_new(cls, values, name=None, freq=None, **kwargs)",
                "values(self)",
                "freq(self)",
                "freq(self, value)",
                "_shallow_copy(self, values=None, **kwargs)",
                "_shallow_copy_with_infer(self, values=None, **kwargs)",
                "_box_func(self)",
                "_maybe_convert_timedelta(self, other)",
                "_format_native_types(self, na_rep='NaT', quoting=None, **kwargs)",
                "_mpl_repr(self)",
                "_formatter_func(self)",
                "_engine(self)",
                "__contains__(self, key)",
                "_int64index(self)",
                "_coerce_scalar_to_index(self, item)",
                "__array__(self, dtype=None)",
                "__array_wrap__(self, result, context=None)",
                "asof_locs(self, where, mask)",
                "astype(self, dtype, copy=True, how='start')",
                "searchsorted(self, value, side='left', sorter=None)",
                "is_all_dates(self)",
                "is_full(self)",
                "inferred_type(self)",
                "get_value(self, series, key)",
                "get_indexer(self, target, method=None, limit=None, tolerance=None)",
                "get_indexer_non_unique(self, target)",
                "_get_unique_index(self, dropna=False)",
                "unique(self, level=None)",
                "get_loc(self, key, method=None, tolerance=None)",
                "_maybe_cast_slice_bound(self, label, side, kind)",
                "_parsed_string_to_bounds(self, reso, parsed)",
                "_get_string_slice(self, key)",
                "_convert_tolerance(self, tolerance, target)",
                "insert(self, loc, item)",
                "join(self, other, how='left', level=None, return_indexers=False, sort=False)",
                "intersection(self, other, sort=False)",
                "_assert_can_do_setop(self, other)",
                "_wrap_setop_result(self, other, result)",
                "_apply_meta(self, rawarr)",
                "__setstate__(self, state)",
                "flags(self)",
                "item(self)",
                "data(self)",
                "base(self)",
                "memory_usage(self, deep=False)",
                "func(x)"
            ],
            "variables_in_file": {
                "_index_doc_kwargs": [
                    41,
                    42,
                    652,
                    633
                ],
                "dict": [
                    41,
                    42,
                    891
                ],
                "ibase._index_doc_kwargs": [
                    41
                ],
                "ibase": [
                    41
                ],
                "_index_doc_kwargs.update": [
                    42
                ],
                "values": [
                    282,
                    283,
                    284,
                    288,
                    290,
                    293,
                    295,
                    429,
                    686,
                    687,
                    50,
                    51,
                    53,
                    54,
                    56,
                    582,
                    583,
                    328,
                    329,
                    331,
                    332,
                    334,
                    335,
                    336,
                    344,
                    477,
                    351,
                    353,
                    357
                ],
                "d.pop": [
                    50,
                    52
                ],
                "d": [
                    56,
                    50,
                    52,
                    54
                ],
                "values.dtype": [
                    51,
                    335
                ],
                "freq": [
                    257,
                    260,
                    903,
                    908,
                    910,
                    1043,
                    1044,
                    1046,
                    1047,
                    286,
                    287,
                    288,
                    52,
                    53,
                    311,
                    217,
                    230,
                    240,
                    242,
                    244,
                    249,
                    252
                ],
                "PeriodArray": [
                    64,
                    65,
                    66,
                    257,
                    288,
                    290,
                    70,
                    72,
                    334,
                    910,
                    336,
                    242,
                    53,
                    1046,
                    1047,
                    217
                ],
                "cls._simple_new": [
                    265,
                    54
                ],
                "cls": [
                    292,
                    265,
                    54,
                    56,
                    249
                ],
                "DatetimelikeDelegateMixin": [
                    59
                ],
                "_delegate_class": [
                    64
                ],
                "_delegated_properties": [
                    65
                ],
                "PeriodArray._datetimelike_ops": [
                    65
                ],
                "_delegated_methods": [
                    66
                ],
                "set": [
                    208,
                    66,
                    205
                ],
                "PeriodArray._datetimelike_methods": [
                    66
                ],
                "_raw_properties": [
                    67
                ],
                "DatetimeIndexOpsMixin": [
                    74,
                    823
                ],
                "Int64Index": [
                    848,
                    458,
                    74
                ],
                "PeriodDelegateMixin": [
                    72,
                    74,
                    70
                ],
                "_typ": [
                    166
                ],
                "_attributes": [
                    167
                ],
                "_is_numeric_dtype": [
                    170
                ],
                "_infer_as_myclass": [
                    171
                ],
                "_data": [
                    173
                ],
                "_engine_type": [
                    175
                ],
                "libindex.PeriodEngine": [
                    175
                ],
                "libindex": [
                    175
                ],
                "valid_field_set": [
                    208,
                    195,
                    205
                ],
                "issubset": [
                    205
                ],
                "fields": [
                    208,
                    217,
                    220,
                    205
                ],
                "TypeError": [
                    291,
                    707,
                    206,
                    626,
                    285
                ],
                "format": [
                    954,
                    711,
                    967,
                    235,
                    207,
                    564,
                    922
                ],
                "list": [
                    208,
                    282
                ],
                "name": [
                    296,
                    265,
                    491,
                    878,
                    495,
                    496,
                    880,
                    498,
                    212,
                    213,
                    1048
                ],
                "hasattr": [
                    976,
                    658,
                    212,
                    637
                ],
                "data": [
                    257,
                    899,
                    260,
                    900,
                    263,
                    265,
                    906,
                    910,
                    911,
                    1046,
                    1047,
                    1048,
                    959,
                    212,
                    213,
                    215,
                    217,
                    242,
                    249,
                    252,
                    254
                ],
                "data.name": [
                    213
                ],
                "ordinal": [
                    256,
                    257,
                    610,
                    611,
                    620,
                    721,
                    562,
                    724,
                    215,
                    254
                ],
                "freq2": [
                    240,
                    217,
                    238
                ],
                "PeriodArray._generate_range": [
                    217,
                    1046
                ],
                "start": [
                    231,
                    1038,
                    1043,
                    1046,
                    217
                ],
                "end": [
                    232,
                    1038,
                    1043,
                    1046,
                    217
                ],
                "periods": [
                    217,
                    1038,
                    1046
                ],
                "msg": [
                    643,
                    659,
                    404,
                    407,
                    664,
                    415,
                    418,
                    553,
                    558,
                    316,
                    321,
                    221,
                    872,
                    235,
                    875,
                    239,
                    501,
                    504,
                    638
                ],
                "cond": [
                    234,
                    230
                ],
                "isinstance": [
                    645,
                    519,
                    392,
                    394,
                    398,
                    656,
                    1043,
                    282,
                    290,
                    551,
                    560,
                    444,
                    829,
                    331,
                    843,
                    334,
                    335,
                    486,
                    231,
                    232,
                    871,
                    494,
                    751,
                    368,
                    497,
                    753,
                    499,
                    884,
                    249,
                    891,
                    894
                ],
                "Period": [
                    769,
                    772,
                    774,
                    903,
                    776,
                    784,
                    1043,
                    793,
                    287,
                    551,
                    562,
                    313,
                    444,
                    829,
                    714,
                    609,
                    231,
                    232,
                    620,
                    368,
                    497,
                    752,
                    371,
                    629,
                    767
                ],
                "freq2.freqstr": [
                    238
                ],
                "warnings.warn": [
                    321,
                    966,
                    937,
                    239,
                    953,
                    921
                ],
                "warnings": [
                    321,
                    966,
                    937,
                    239,
                    953,
                    921
                ],
                "FutureWarning": [
                    321,
                    924,
                    969,
                    939,
                    239,
                    956
                ],
                "validate_dtype_freq": [
                    347,
                    244
                ],
                "dtype": [
                    546,
                    538,
                    244,
                    474,
                    540,
                    542
                ],
                "data.freq": [
                    249
                ],
                "data.asfreq": [
                    252
                ],
                "np.asarray": [
                    256,
                    972,
                    305,
                    723,
                    283,
                    959
                ],
                "np": [
                    256,
                    899,
                    900,
                    392,
                    906,
                    907,
                    526,
                    527,
                    283,
                    305,
                    959,
                    832,
                    833,
                    972,
                    335,
                    723,
                    488,
                    616,
                    490,
                    499
                ],
                "np.int64": [
                    256
                ],
                "period_array": [
                    344,
                    260
                ],
                "copy": [
                    546,
                    262
                ],
                "data.copy": [
                    263
                ],
                "is_float_dtype": [
                    284
                ],
                "Period._maybe_convert_freq": [
                    903,
                    313,
                    287
                ],
                "result": [
                    527,
                    530,
                    534,
                    292,
                    293,
                    295,
                    296,
                    297,
                    298,
                    687,
                    688,
                    975,
                    848,
                    977,
                    978,
                    858,
                    859,
                    860,
                    879,
                    496,
                    880,
                    498,
                    881,
                    506,
                    507,
                    510
                ],
                "object.__new__": [
                    292
                ],
                "object": [
                    292,
                    844,
                    429,
                    477,
                    830
                ],
                "result._data": [
                    293
                ],
                "result._index_data": [
                    295
                ],
                "values._data": [
                    295
                ],
                "result.name": [
                    296,
                    880
                ],
                "result._reset_identity": [
                    297
                ],
                "classmethod": [
                    267
                ],
                "self": [
                    520,
                    522,
                    527,
                    531,
                    543,
                    552,
                    554,
                    555,
                    562,
                    566,
                    578,
                    580,
                    582,
                    598,
                    601,
                    603,
                    605,
                    610,
                    611,
                    616,
                    620,
                    622,
                    629,
                    631,
                    637,
                    639,
                    640,
                    649,
                    650,
                    658,
                    660,
                    661,
                    666,
                    684,
                    686,
                    688,
                    699,
                    705,
                    714,
                    723,
                    724,
                    752,
                    755,
                    756,
                    761,
                    804,
                    807,
                    810,
                    812,
                    816,
                    305,
                    818,
                    819,
                    309,
                    823,
                    826,
                    829,
                    830,
                    321,
                    833,
                    835,
                    324,
                    329,
                    841,
                    331,
                    844,
                    336,
                    849,
                    344,
                    347,
                    348,
                    859,
                    860,
                    352,
                    353,
                    864,
                    357,
                    871,
                    873,
                    878,
                    879,
                    371,
                    885,
                    393,
                    907,
                    396,
                    911,
                    401,
                    405,
                    923,
                    927,
                    416,
                    425,
                    429,
                    943,
                    944,
                    433,
                    440,
                    955,
                    445,
                    959,
                    448,
                    451,
                    968,
                    458,
                    972,
                    976,
                    977,
                    471,
                    475,
                    477,
                    491,
                    510
                ],
                "property": [
                    961,
                    359,
                    585,
                    431,
                    303,
                    307,
                    918,
                    950,
                    568,
                    572
                ],
                "self._data.freq": [
                    309
                ],
                "self._data": [
                    324,
                    329,
                    425,
                    396,
                    972,
                    911,
                    309,
                    959
                ],
                "value": [
                    324,
                    551,
                    552,
                    556,
                    559,
                    560,
                    562,
                    564,
                    566,
                    313
                ],
                "msg.format": [
                    504,
                    321
                ],
                "__name__": [
                    416,
                    321,
                    955,
                    968,
                    873,
                    554,
                    660,
                    405,
                    923,
                    639
                ],
                "type": [
                    416,
                    321,
                    955,
                    968,
                    873,
                    554,
                    331,
                    660,
                    405,
                    923,
                    510,
                    639
                ],
                "self._data._freq": [
                    324
                ],
                "freq.setter": [
                    311
                ],
                "values._values": [
                    332
                ],
                "np.ndarray": [
                    392,
                    907,
                    900,
                    335
                ],
                "is_integer_dtype": [
                    474,
                    335
                ],
                "self.freq": [
                    520,
                    393,
                    401,
                    658,
                    804,
                    552,
                    810,
                    812,
                    562,
                    445,
                    829,
                    705,
                    714,
                    336,
                    344,
                    601,
                    603,
                    610,
                    611,
                    871,
                    620,
                    752,
                    371,
                    755,
                    629,
                    885,
                    637,
                    510
                ],
                "self.dtype": [
                    352,
                    347
                ],
                "kwargs.get": [
                    347
                ],
                "kwargs": [
                    357,
                    425,
                    347,
                    350,
                    351
                ],
                "attributes": [
                    352,
                    353,
                    348,
                    350
                ],
                "self._get_attributes_dict": [
                    348,
                    471
                ],
                "attributes.update": [
                    350
                ],
                "len": [
                    897,
                    578,
                    486,
                    527,
                    943,
                    440,
                    351
                ],
                "self._simple_new": [
                    353
                ],
                "self._shallow_copy": [
                    688,
                    835,
                    357
                ],
                "x": [
                    368,
                    369,
                    371
                ],
                "NaT": [
                    368,
                    721
                ],
                "Period._from_ordinal": [
                    371
                ],
                "func": [
                    487,
                    488,
                    490,
                    499,
                    500,
                    373,
                    504
                ],
                "other": [
                    864,
                    867,
                    871,
                    392,
                    841,
                    873,
                    843,
                    396,
                    845,
                    398,
                    399,
                    878,
                    402,
                    850,
                    405,
                    408,
                    412
                ],
                "timedelta": [
                    392
                ],
                "np.timedelta64": [
                    392
                ],
                "Tick": [
                    392,
                    394
                ],
                "offset": [
                    393,
                    394
                ],
                "frequencies.to_offset": [
                    393
                ],
                "frequencies": [
                    393
                ],
                "self.freq.rule_code": [
                    393,
                    401
                ],
                "delta": [
                    396,
                    397
                ],
                "self._data._check_timedeltalike_freq_compat": [
                    396
                ],
                "DateOffset": [
                    398
                ],
                "freqstr": [
                    400,
                    399
                ],
                "other.rule_code": [
                    399
                ],
                "base": [
                    400,
                    401
                ],
                "libfrequencies.get_base_alias": [
                    400
                ],
                "libfrequencies": [
                    400
                ],
                "other.n": [
                    402
                ],
                "DIFFERENT_FREQ.format": [
                    872,
                    553,
                    659,
                    404,
                    638,
                    415
                ],
                "DIFFERENT_FREQ": [
                    872,
                    553,
                    659,
                    404,
                    638,
                    415
                ],
                "self.freqstr": [
                    416,
                    640,
                    873,
                    555,
                    405,
                    661
                ],
                "other.freqstr": [
                    873,
                    405
                ],
                "IncompatibleFrequency": [
                    418,
                    643,
                    875,
                    558,
                    407,
                    664
                ],
                "is_integer": [
                    408,
                    760,
                    701
                ],
                "self._data._format_native_types": [
                    425
                ],
                "na_rep": [
                    425
                ],
                "quoting": [
                    425
                ],
                "self.astype": [
                    477,
                    844,
                    429,
                    830
                ],
                "self.array._formatter": [
                    433
                ],
                "self.array": [
                    433
                ],
                "self._engine_type": [
                    440
                ],
                "cache_readonly": [
                    456,
                    438
                ],
                "key": [
                    810,
                    814,
                    699,
                    444,
                    701,
                    445,
                    448,
                    705,
                    706,
                    451,
                    711,
                    714,
                    718,
                    721,
                    723,
                    598,
                    727,
                    601,
                    614,
                    617,
                    618,
                    620,
                    622,
                    625,
                    629,
                    630,
                    631
                ],
                "key.freq": [
                    445
                ],
                "key.ordinal": [
                    448,
                    721
                ],
                "self._engine": [
                    448,
                    699
                ],
                "self.get_loc": [
                    451
                ],
                "Exception": [
                    914,
                    453,
                    758
                ],
                "Appender": [
                    549,
                    678,
                    652,
                    536,
                    633,
                    442,
                    862
                ],
                "_index_shared_docs": [
                    536,
                    633,
                    442,
                    652
                ],
                "Int64Index._simple_new": [
                    458
                ],
                "self.asi8": [
                    458,
                    475,
                    582
                ],
                "self.name": [
                    458,
                    491,
                    885,
                    510
                ],
                "PeriodIndex": [
                    645,
                    871,
                    520,
                    843,
                    494,
                    656,
                    983,
                    884,
                    885,
                    981,
                    471,
                    982,
                    984,
                    1048
                ],
                "item": [
                    833,
                    829,
                    830,
                    471
                ],
                "context": [
                    492,
                    493,
                    486,
                    487
                ],
                "tuple": [
                    894,
                    486
                ],
                "np.add": [
                    488
                ],
                "np.subtract": [
                    490
                ],
                "left": [
                    497,
                    492,
                    494,
                    495
                ],
                "right": [
                    497,
                    493,
                    494,
                    495
                ],
                "left.name": [
                    495
                ],
                "right.name": [
                    495
                ],
                "Index": [
                    864,
                    678,
                    650,
                    496,
                    498,
                    862
                ],
                "np.ufunc": [
                    499
                ],
                "func.types": [
                    500
                ],
                "ValueError": [
                    581,
                    808,
                    715,
                    1039,
                    948,
                    504,
                    825
                ],
                "func.__name__": [
                    504
                ],
                "is_bool_dtype": [
                    506
                ],
                "where_idx": [
                    518,
                    519,
                    520,
                    523,
                    531
                ],
                "where": [
                    518
                ],
                "DatetimeIndex": [
                    519
                ],
                "where_idx.values": [
                    520
                ],
                "locs": [
                    522,
                    531,
                    526,
                    527
                ],
                "searchsorted": [
                    522
                ],
                "self._ndarray_values": [
                    616,
                    522,
                    686,
                    531,
                    566,
                    605,
                    927
                ],
                "mask": [
                    529,
                    522,
                    527
                ],
                "where_idx._ndarray_values": [
                    531,
                    523
                ],
                "np.where": [
                    526
                ],
                "take": [
                    527
                ],
                "np.arange": [
                    527
                ],
                "first": [
                    529,
                    531
                ],
                "mask.argmax": [
                    529
                ],
                "pandas_dtype": [
                    538
                ],
                "is_datetime64_any_dtype": [
                    540
                ],
                "tz": [
                    542,
                    543
                ],
                "getattr": [
                    542
                ],
                "tz_localize": [
                    543
                ],
                "self.to_timestamp": [
                    543
                ],
                "how": [
                    851,
                    845,
                    543
                ],
                "astype": [
                    546
                ],
                "super": [
                    673,
                    546,
                    867,
                    975,
                    598,
                    892
                ],
                "value.freq": [
                    552
                ],
                "value.freqstr": [
                    556
                ],
                "value.ordinal": [
                    559
                ],
                "str": [
                    560,
                    753
                ],
                "DateParseError": [
                    563,
                    709
                ],
                "KeyError": [
                    803,
                    614,
                    711,
                    727,
                    759,
                    718,
                    814,
                    625,
                    564,
                    726,
                    599,
                    700
                ],
                "self._ndarray_values.searchsorted": [
                    566
                ],
                "side": [
                    757,
                    566
                ],
                "sorter": [
                    566
                ],
                "Substitution": [
                    548
                ],
                "_shared_docs": [
                    549
                ],
                "self.is_monotonic": [
                    580,
                    807
                ],
                "all": [
                    583
                ],
                "s": [
                    622,
                    596,
                    598,
                    631
                ],
                "com.values_from_object": [
                    596
                ],
                "com": [
                    621,
                    1038,
                    596,
                    598,
                    631
                ],
                "series": [
                    618,
                    622,
                    596,
                    598,
                    631
                ],
                "com.maybe_box": [
                    621,
                    598,
                    631
                ],
                "get_value": [
                    598
                ],
                "IndexError": [
                    599
                ],
                "asdt": [
                    705,
                    706,
                    609,
                    620,
                    601
                ],
                "parsed": [
                    769,
                    771,
                    772,
                    774,
                    777,
                    778,
                    779,
                    780,
                    785,
                    786,
                    787,
                    788,
                    789,
                    794,
                    795,
                    796,
                    797,
                    798,
                    799,
                    810,
                    816,
                    705,
                    601,
                    755,
                    756,
                    767
                ],
                "reso": [
                    768,
                    705,
                    770,
                    803,
                    773,
                    775,
                    810,
                    811,
                    813,
                    783,
                    816,
                    755,
                    756,
                    792,
                    601,
                    602,
                    766
                ],
                "parse_time_string": [
                    601,
                    810,
                    755,
                    705
                ],
                "grp": [
                    608,
                    609,
                    619,
                    811,
                    813,
                    602
                ],
                "resolution.Resolution.get_freq_group": [
                    602,
                    811
                ],
                "resolution.Resolution": [
                    602,
                    811
                ],
                "resolution": [
                    811,
                    602,
                    603,
                    812
                ],
                "freqn": [
                    608,
                    619,
                    812,
                    813,
                    603
                ],
                "resolution.get_freq_group": [
                    603,
                    812
                ],
                "vals": [
                    613,
                    605
                ],
                "iv": [
                    609,
                    610,
                    611
                ],
                "ord1": [
                    616,
                    610,
                    613
                ],
                "iv.asfreq": [
                    610,
                    611
                ],
                "ord2": [
                    616,
                    611,
                    613
                ],
                "pos": [
                    616,
                    617
                ],
                "np.searchsorted": [
                    616
                ],
                "slice": [
                    617,
                    817
                ],
                "self._int64index.get_value": [
                    622,
                    631
                ],
                "self._int64index": [
                    650,
                    622,
                    977,
                    724,
                    631,
                    666
                ],
                "period": [
                    629,
                    630
                ],
                "isna": [
                    630
                ],
                "period.value": [
                    630
                ],
                "period.ordinal": [
                    630
                ],
                "target": [
                    641,
                    645,
                    646,
                    649,
                    650,
                    654,
                    656,
                    657,
                    658,
                    662,
                    823,
                    824,
                    666,
                    635,
                    637
                ],
                "ensure_index": [
                    635,
                    654
                ],
                "target.freq": [
                    658,
                    637
                ],
                "target.freqstr": [
                    641,
                    662
                ],
                "target.asi8": [
                    657,
                    646
                ],
                "tolerance": [
                    648,
                    649,
                    650,
                    722,
                    723,
                    724,
                    823,
                    824,
                    826
                ],
                "self._convert_tolerance": [
                    649,
                    723
                ],
                "Index.get_indexer": [
                    650
                ],
                "method": [
                    650,
                    724
                ],
                "limit": [
                    650
                ],
                "indexer": [
                    666,
                    667
                ],
                "missing": [
                    666,
                    667
                ],
                "self._int64index.get_indexer_non_unique": [
                    666
                ],
                "ensure_platform_int": [
                    667
                ],
                "res": [
                    673,
                    675,
                    676
                ],
                "_get_unique_index": [
                    673
                ],
                "dropna": [
                    673,
                    674
                ],
                "res.dropna": [
                    675
                ],
                "level": [
                    681,
                    684,
                    845,
                    852
                ],
                "self._validate_index_level": [
                    684
                ],
                "unique1d": [
                    687
                ],
                "Index.unique.__doc__": [
                    678
                ],
                "Index.unique": [
                    678
                ],
                "self._engine.get_loc": [
                    699
                ],
                "iNaT": [
                    721
                ],
                "self._int64index.get_loc": [
                    724
                ],
                "kind": [
                    749
                ],
                "label": [
                    751,
                    752,
                    753,
                    755,
                    759,
                    760,
                    761,
                    763
                ],
                "datetime": [
                    751
                ],
                "_": [
                    755
                ],
                "bounds": [
                    756,
                    757
                ],
                "self._parsed_string_to_bounds": [
                    816,
                    756
                ],
                "is_float": [
                    760
                ],
                "self._invalid_indexer": [
                    761
                ],
                "t1": [
                    769,
                    772,
                    804,
                    774,
                    776,
                    784,
                    816,
                    818,
                    793,
                    767
                ],
                "parsed.year": [
                    769,
                    772,
                    774,
                    777,
                    785,
                    794,
                    767
                ],
                "parsed.month": [
                    769,
                    771,
                    774,
                    778,
                    786,
                    795
                ],
                "q": [
                    771,
                    772
                ],
                "parsed.day": [
                    787,
                    779,
                    796,
                    774
                ],
                "parsed.hour": [
                    797,
                    780,
                    788
                ],
                "parsed.minute": [
                    789,
                    798
                ],
                "parsed.second": [
                    799
                ],
                "t1.asfreq": [
                    804
                ],
                "t2": [
                    816,
                    819
                ],
                "self.searchsorted": [
                    818,
                    819
                ],
                "t1.ordinal": [
                    818
                ],
                "t2.ordinal": [
                    819
                ],
                "DatetimeIndexOpsMixin._convert_tolerance": [
                    823
                ],
                "target.size": [
                    824
                ],
                "tolerance.size": [
                    824
                ],
                "self._maybe_convert_timedelta": [
                    826
                ],
                "item.freq": [
                    829
                ],
                "insert": [
                    830
                ],
                "loc": [
                    833,
                    830
                ],
                "idx": [
                    832,
                    835
                ],
                "np.concatenate": [
                    832
                ],
                "asi8": [
                    833
                ],
                "np.array": [
                    833
                ],
                "item.ordinal": [
                    833
                ],
                "self._assert_can_do_setop": [
                    841
                ],
                "join": [
                    844
                ],
                "return_indexers": [
                    857,
                    853,
                    845
                ],
                "sort": [
                    864,
                    845,
                    854
                ],
                "Int64Index.join": [
                    848
                ],
                "lidx": [
                    858,
                    859
                ],
                "ridx": [
                    858,
                    859
                ],
                "self._apply_meta": [
                    859,
                    860,
                    879
                ],
                "Index.intersection": [
                    864,
                    862
                ],
                "Index.intersection.__doc__": [
                    862
                ],
                "_assert_can_do_setop": [
                    867
                ],
                "other.freq": [
                    871
                ],
                "get_op_result_name": [
                    878
                ],
                "rawarr": [
                    884,
                    885,
                    886
                ],
                "PeriodIndex._simple_new": [
                    885
                ],
                "state": [
                    897,
                    898,
                    906,
                    907,
                    891,
                    892,
                    894
                ],
                "__setstate__": [
                    916,
                    892
                ],
                "nd_state": [
                    898,
                    899,
                    900
                ],
                "own_state": [
                    898,
                    903
                ],
                "np.empty": [
                    906,
                    899
                ],
                "np.ndarray.__setstate__": [
                    907,
                    900
                ],
                "_unpickle_compat": [
                    916
                ],
                "self._ndarray_values.flags": [
                    927
                ],
                "memory_usage": [
                    975
                ],
                "deep": [
                    977,
                    975
                ],
                "self._cache": [
                    976
                ],
                "self._int64index.memory_usage": [
                    977
                ],
                "delegate_names": [
                    70,
                    71
                ],
                "PeriodDelegateMixin._delegated_properties": [
                    70
                ],
                "PeriodDelegateMixin._delegated_methods": [
                    72
                ],
                "PeriodIndex._add_comparison_ops": [
                    981
                ],
                "PeriodIndex._add_numeric_methods_disabled": [
                    982
                ],
                "PeriodIndex._add_logical_methods_disabled": [
                    983
                ],
                "PeriodIndex._add_datetimelike_methods": [
                    984
                ],
                "com.count_not_none": [
                    1038
                ]
            },
            "filtered_variables_in_file": {
                "_index_doc_kwargs": [
                    41,
                    42,
                    652,
                    633
                ],
                "ibase._index_doc_kwargs": [
                    41
                ],
                "ibase": [
                    41
                ],
                "_index_doc_kwargs.update": [
                    42
                ],
                "values": [
                    282,
                    283,
                    284,
                    288,
                    290,
                    293,
                    295,
                    429,
                    686,
                    687,
                    50,
                    51,
                    53,
                    54,
                    56,
                    582,
                    583,
                    328,
                    329,
                    331,
                    332,
                    334,
                    335,
                    336,
                    344,
                    477,
                    351,
                    353,
                    357
                ],
                "d.pop": [
                    50,
                    52
                ],
                "d": [
                    56,
                    50,
                    52,
                    54
                ],
                "values.dtype": [
                    51,
                    335
                ],
                "freq": [
                    257,
                    260,
                    903,
                    908,
                    910,
                    1043,
                    1044,
                    1046,
                    1047,
                    286,
                    287,
                    288,
                    52,
                    53,
                    311,
                    217,
                    230,
                    240,
                    242,
                    244,
                    249,
                    252
                ],
                "PeriodArray": [
                    64,
                    65,
                    66,
                    257,
                    288,
                    290,
                    70,
                    72,
                    334,
                    910,
                    336,
                    242,
                    53,
                    1046,
                    1047,
                    217
                ],
                "cls._simple_new": [
                    265,
                    54
                ],
                "cls": [
                    292,
                    265,
                    54,
                    56,
                    249
                ],
                "DatetimelikeDelegateMixin": [
                    59
                ],
                "_delegate_class": [
                    64
                ],
                "_delegated_properties": [
                    65
                ],
                "PeriodArray._datetimelike_ops": [
                    65
                ],
                "_delegated_methods": [
                    66
                ],
                "PeriodArray._datetimelike_methods": [
                    66
                ],
                "_raw_properties": [
                    67
                ],
                "DatetimeIndexOpsMixin": [
                    74,
                    823
                ],
                "Int64Index": [
                    848,
                    458,
                    74
                ],
                "PeriodDelegateMixin": [
                    72,
                    74,
                    70
                ],
                "_typ": [
                    166
                ],
                "_attributes": [
                    167
                ],
                "_is_numeric_dtype": [
                    170
                ],
                "_infer_as_myclass": [
                    171
                ],
                "_data": [
                    173
                ],
                "_engine_type": [
                    175
                ],
                "libindex.PeriodEngine": [
                    175
                ],
                "libindex": [
                    175
                ],
                "valid_field_set": [
                    208,
                    195,
                    205
                ],
                "issubset": [
                    205
                ],
                "fields": [
                    208,
                    217,
                    220,
                    205
                ],
                "name": [
                    296,
                    265,
                    491,
                    878,
                    495,
                    496,
                    880,
                    498,
                    212,
                    213,
                    1048
                ],
                "data": [
                    257,
                    899,
                    260,
                    900,
                    263,
                    265,
                    906,
                    910,
                    911,
                    1046,
                    1047,
                    1048,
                    959,
                    212,
                    213,
                    215,
                    217,
                    242,
                    249,
                    252,
                    254
                ],
                "data.name": [
                    213
                ],
                "ordinal": [
                    256,
                    257,
                    610,
                    611,
                    620,
                    721,
                    562,
                    724,
                    215,
                    254
                ],
                "freq2": [
                    240,
                    217,
                    238
                ],
                "PeriodArray._generate_range": [
                    217,
                    1046
                ],
                "start": [
                    231,
                    1038,
                    1043,
                    1046,
                    217
                ],
                "end": [
                    232,
                    1038,
                    1043,
                    1046,
                    217
                ],
                "periods": [
                    217,
                    1038,
                    1046
                ],
                "msg": [
                    643,
                    659,
                    404,
                    407,
                    664,
                    415,
                    418,
                    553,
                    558,
                    316,
                    321,
                    221,
                    872,
                    235,
                    875,
                    239,
                    501,
                    504,
                    638
                ],
                "cond": [
                    234,
                    230
                ],
                "Period": [
                    769,
                    772,
                    774,
                    903,
                    776,
                    784,
                    1043,
                    793,
                    287,
                    551,
                    562,
                    313,
                    444,
                    829,
                    714,
                    609,
                    231,
                    232,
                    620,
                    368,
                    497,
                    752,
                    371,
                    629,
                    767
                ],
                "freq2.freqstr": [
                    238
                ],
                "warnings.warn": [
                    321,
                    966,
                    937,
                    239,
                    953,
                    921
                ],
                "warnings": [
                    321,
                    966,
                    937,
                    239,
                    953,
                    921
                ],
                "validate_dtype_freq": [
                    347,
                    244
                ],
                "dtype": [
                    546,
                    538,
                    244,
                    474,
                    540,
                    542
                ],
                "data.freq": [
                    249
                ],
                "data.asfreq": [
                    252
                ],
                "np.asarray": [
                    256,
                    972,
                    305,
                    723,
                    283,
                    959
                ],
                "np": [
                    256,
                    899,
                    900,
                    392,
                    906,
                    907,
                    526,
                    527,
                    283,
                    305,
                    959,
                    832,
                    833,
                    972,
                    335,
                    723,
                    488,
                    616,
                    490,
                    499
                ],
                "np.int64": [
                    256
                ],
                "period_array": [
                    344,
                    260
                ],
                "copy": [
                    546,
                    262
                ],
                "data.copy": [
                    263
                ],
                "is_float_dtype": [
                    284
                ],
                "Period._maybe_convert_freq": [
                    903,
                    313,
                    287
                ],
                "result": [
                    527,
                    530,
                    534,
                    292,
                    293,
                    295,
                    296,
                    297,
                    298,
                    687,
                    688,
                    975,
                    848,
                    977,
                    978,
                    858,
                    859,
                    860,
                    879,
                    496,
                    880,
                    498,
                    881,
                    506,
                    507,
                    510
                ],
                "object.__new__": [
                    292
                ],
                "result._data": [
                    293
                ],
                "result._index_data": [
                    295
                ],
                "values._data": [
                    295
                ],
                "result.name": [
                    296,
                    880
                ],
                "result._reset_identity": [
                    297
                ],
                "self": [
                    520,
                    522,
                    527,
                    531,
                    543,
                    552,
                    554,
                    555,
                    562,
                    566,
                    578,
                    580,
                    582,
                    598,
                    601,
                    603,
                    605,
                    610,
                    611,
                    616,
                    620,
                    622,
                    629,
                    631,
                    637,
                    639,
                    640,
                    649,
                    650,
                    658,
                    660,
                    661,
                    666,
                    684,
                    686,
                    688,
                    699,
                    705,
                    714,
                    723,
                    724,
                    752,
                    755,
                    756,
                    761,
                    804,
                    807,
                    810,
                    812,
                    816,
                    305,
                    818,
                    819,
                    309,
                    823,
                    826,
                    829,
                    830,
                    321,
                    833,
                    835,
                    324,
                    329,
                    841,
                    331,
                    844,
                    336,
                    849,
                    344,
                    347,
                    348,
                    859,
                    860,
                    352,
                    353,
                    864,
                    357,
                    871,
                    873,
                    878,
                    879,
                    371,
                    885,
                    393,
                    907,
                    396,
                    911,
                    401,
                    405,
                    923,
                    927,
                    416,
                    425,
                    429,
                    943,
                    944,
                    433,
                    440,
                    955,
                    445,
                    959,
                    448,
                    451,
                    968,
                    458,
                    972,
                    976,
                    977,
                    471,
                    475,
                    477,
                    491,
                    510
                ],
                "self._data.freq": [
                    309
                ],
                "self._data": [
                    324,
                    329,
                    425,
                    396,
                    972,
                    911,
                    309,
                    959
                ],
                "value": [
                    324,
                    551,
                    552,
                    556,
                    559,
                    560,
                    562,
                    564,
                    566,
                    313
                ],
                "msg.format": [
                    504,
                    321
                ],
                "self._data._freq": [
                    324
                ],
                "freq.setter": [
                    311
                ],
                "values._values": [
                    332
                ],
                "np.ndarray": [
                    392,
                    907,
                    900,
                    335
                ],
                "is_integer_dtype": [
                    474,
                    335
                ],
                "self.freq": [
                    520,
                    393,
                    401,
                    658,
                    804,
                    552,
                    810,
                    812,
                    562,
                    445,
                    829,
                    705,
                    714,
                    336,
                    344,
                    601,
                    603,
                    610,
                    611,
                    871,
                    620,
                    752,
                    371,
                    755,
                    629,
                    885,
                    637,
                    510
                ],
                "self.dtype": [
                    352,
                    347
                ],
                "kwargs.get": [
                    347
                ],
                "kwargs": [
                    357,
                    425,
                    347,
                    350,
                    351
                ],
                "attributes": [
                    352,
                    353,
                    348,
                    350
                ],
                "self._get_attributes_dict": [
                    348,
                    471
                ],
                "attributes.update": [
                    350
                ],
                "self._simple_new": [
                    353
                ],
                "self._shallow_copy": [
                    688,
                    835,
                    357
                ],
                "x": [
                    368,
                    369,
                    371
                ],
                "NaT": [
                    368,
                    721
                ],
                "Period._from_ordinal": [
                    371
                ],
                "func": [
                    487,
                    488,
                    490,
                    499,
                    500,
                    373,
                    504
                ],
                "other": [
                    864,
                    867,
                    871,
                    392,
                    841,
                    873,
                    843,
                    396,
                    845,
                    398,
                    399,
                    878,
                    402,
                    850,
                    405,
                    408,
                    412
                ],
                "timedelta": [
                    392
                ],
                "np.timedelta64": [
                    392
                ],
                "Tick": [
                    392,
                    394
                ],
                "offset": [
                    393,
                    394
                ],
                "frequencies.to_offset": [
                    393
                ],
                "frequencies": [
                    393
                ],
                "self.freq.rule_code": [
                    393,
                    401
                ],
                "delta": [
                    396,
                    397
                ],
                "self._data._check_timedeltalike_freq_compat": [
                    396
                ],
                "DateOffset": [
                    398
                ],
                "freqstr": [
                    400,
                    399
                ],
                "other.rule_code": [
                    399
                ],
                "base": [
                    400,
                    401
                ],
                "libfrequencies.get_base_alias": [
                    400
                ],
                "libfrequencies": [
                    400
                ],
                "other.n": [
                    402
                ],
                "DIFFERENT_FREQ.format": [
                    872,
                    553,
                    659,
                    404,
                    638,
                    415
                ],
                "DIFFERENT_FREQ": [
                    872,
                    553,
                    659,
                    404,
                    638,
                    415
                ],
                "self.freqstr": [
                    416,
                    640,
                    873,
                    555,
                    405,
                    661
                ],
                "other.freqstr": [
                    873,
                    405
                ],
                "IncompatibleFrequency": [
                    418,
                    643,
                    875,
                    558,
                    407,
                    664
                ],
                "is_integer": [
                    408,
                    760,
                    701
                ],
                "self._data._format_native_types": [
                    425
                ],
                "na_rep": [
                    425
                ],
                "quoting": [
                    425
                ],
                "self.astype": [
                    477,
                    844,
                    429,
                    830
                ],
                "self.array._formatter": [
                    433
                ],
                "self.array": [
                    433
                ],
                "self._engine_type": [
                    440
                ],
                "cache_readonly": [
                    456,
                    438
                ],
                "key": [
                    810,
                    814,
                    699,
                    444,
                    701,
                    445,
                    448,
                    705,
                    706,
                    451,
                    711,
                    714,
                    718,
                    721,
                    723,
                    598,
                    727,
                    601,
                    614,
                    617,
                    618,
                    620,
                    622,
                    625,
                    629,
                    630,
                    631
                ],
                "key.freq": [
                    445
                ],
                "key.ordinal": [
                    448,
                    721
                ],
                "self._engine": [
                    448,
                    699
                ],
                "self.get_loc": [
                    451
                ],
                "Appender": [
                    549,
                    678,
                    652,
                    536,
                    633,
                    442,
                    862
                ],
                "_index_shared_docs": [
                    536,
                    633,
                    442,
                    652
                ],
                "Int64Index._simple_new": [
                    458
                ],
                "self.asi8": [
                    458,
                    475,
                    582
                ],
                "self.name": [
                    458,
                    491,
                    885,
                    510
                ],
                "PeriodIndex": [
                    645,
                    871,
                    520,
                    843,
                    494,
                    656,
                    983,
                    884,
                    885,
                    981,
                    471,
                    982,
                    984,
                    1048
                ],
                "item": [
                    833,
                    829,
                    830,
                    471
                ],
                "context": [
                    492,
                    493,
                    486,
                    487
                ],
                "np.add": [
                    488
                ],
                "np.subtract": [
                    490
                ],
                "left": [
                    497,
                    492,
                    494,
                    495
                ],
                "right": [
                    497,
                    493,
                    494,
                    495
                ],
                "left.name": [
                    495
                ],
                "right.name": [
                    495
                ],
                "Index": [
                    864,
                    678,
                    650,
                    496,
                    498,
                    862
                ],
                "np.ufunc": [
                    499
                ],
                "func.types": [
                    500
                ],
                "func.__name__": [
                    504
                ],
                "is_bool_dtype": [
                    506
                ],
                "where_idx": [
                    518,
                    519,
                    520,
                    523,
                    531
                ],
                "where": [
                    518
                ],
                "DatetimeIndex": [
                    519
                ],
                "where_idx.values": [
                    520
                ],
                "locs": [
                    522,
                    531,
                    526,
                    527
                ],
                "searchsorted": [
                    522
                ],
                "self._ndarray_values": [
                    616,
                    522,
                    686,
                    531,
                    566,
                    605,
                    927
                ],
                "mask": [
                    529,
                    522,
                    527
                ],
                "where_idx._ndarray_values": [
                    531,
                    523
                ],
                "np.where": [
                    526
                ],
                "take": [
                    527
                ],
                "np.arange": [
                    527
                ],
                "first": [
                    529,
                    531
                ],
                "mask.argmax": [
                    529
                ],
                "pandas_dtype": [
                    538
                ],
                "is_datetime64_any_dtype": [
                    540
                ],
                "tz": [
                    542,
                    543
                ],
                "tz_localize": [
                    543
                ],
                "self.to_timestamp": [
                    543
                ],
                "how": [
                    851,
                    845,
                    543
                ],
                "astype": [
                    546
                ],
                "value.freq": [
                    552
                ],
                "value.freqstr": [
                    556
                ],
                "value.ordinal": [
                    559
                ],
                "DateParseError": [
                    563,
                    709
                ],
                "self._ndarray_values.searchsorted": [
                    566
                ],
                "side": [
                    757,
                    566
                ],
                "sorter": [
                    566
                ],
                "Substitution": [
                    548
                ],
                "_shared_docs": [
                    549
                ],
                "self.is_monotonic": [
                    580,
                    807
                ],
                "s": [
                    622,
                    596,
                    598,
                    631
                ],
                "com.values_from_object": [
                    596
                ],
                "com": [
                    621,
                    1038,
                    596,
                    598,
                    631
                ],
                "series": [
                    618,
                    622,
                    596,
                    598,
                    631
                ],
                "com.maybe_box": [
                    621,
                    598,
                    631
                ],
                "get_value": [
                    598
                ],
                "asdt": [
                    705,
                    706,
                    609,
                    620,
                    601
                ],
                "parsed": [
                    769,
                    771,
                    772,
                    774,
                    777,
                    778,
                    779,
                    780,
                    785,
                    786,
                    787,
                    788,
                    789,
                    794,
                    795,
                    796,
                    797,
                    798,
                    799,
                    810,
                    816,
                    705,
                    601,
                    755,
                    756,
                    767
                ],
                "reso": [
                    768,
                    705,
                    770,
                    803,
                    773,
                    775,
                    810,
                    811,
                    813,
                    783,
                    816,
                    755,
                    756,
                    792,
                    601,
                    602,
                    766
                ],
                "parse_time_string": [
                    601,
                    810,
                    755,
                    705
                ],
                "grp": [
                    608,
                    609,
                    619,
                    811,
                    813,
                    602
                ],
                "resolution.Resolution.get_freq_group": [
                    602,
                    811
                ],
                "resolution.Resolution": [
                    602,
                    811
                ],
                "resolution": [
                    811,
                    602,
                    603,
                    812
                ],
                "freqn": [
                    608,
                    619,
                    812,
                    813,
                    603
                ],
                "resolution.get_freq_group": [
                    603,
                    812
                ],
                "vals": [
                    613,
                    605
                ],
                "iv": [
                    609,
                    610,
                    611
                ],
                "ord1": [
                    616,
                    610,
                    613
                ],
                "iv.asfreq": [
                    610,
                    611
                ],
                "ord2": [
                    616,
                    611,
                    613
                ],
                "pos": [
                    616,
                    617
                ],
                "np.searchsorted": [
                    616
                ],
                "self._int64index.get_value": [
                    622,
                    631
                ],
                "self._int64index": [
                    650,
                    622,
                    977,
                    724,
                    631,
                    666
                ],
                "period": [
                    629,
                    630
                ],
                "isna": [
                    630
                ],
                "period.value": [
                    630
                ],
                "period.ordinal": [
                    630
                ],
                "target": [
                    641,
                    645,
                    646,
                    649,
                    650,
                    654,
                    656,
                    657,
                    658,
                    662,
                    823,
                    824,
                    666,
                    635,
                    637
                ],
                "ensure_index": [
                    635,
                    654
                ],
                "target.freq": [
                    658,
                    637
                ],
                "target.freqstr": [
                    641,
                    662
                ],
                "target.asi8": [
                    657,
                    646
                ],
                "tolerance": [
                    648,
                    649,
                    650,
                    722,
                    723,
                    724,
                    823,
                    824,
                    826
                ],
                "self._convert_tolerance": [
                    649,
                    723
                ],
                "Index.get_indexer": [
                    650
                ],
                "method": [
                    650,
                    724
                ],
                "limit": [
                    650
                ],
                "indexer": [
                    666,
                    667
                ],
                "missing": [
                    666,
                    667
                ],
                "self._int64index.get_indexer_non_unique": [
                    666
                ],
                "ensure_platform_int": [
                    667
                ],
                "res": [
                    673,
                    675,
                    676
                ],
                "_get_unique_index": [
                    673
                ],
                "dropna": [
                    673,
                    674
                ],
                "res.dropna": [
                    675
                ],
                "level": [
                    681,
                    684,
                    845,
                    852
                ],
                "self._validate_index_level": [
                    684
                ],
                "unique1d": [
                    687
                ],
                "Index.unique.__doc__": [
                    678
                ],
                "Index.unique": [
                    678
                ],
                "self._engine.get_loc": [
                    699
                ],
                "iNaT": [
                    721
                ],
                "self._int64index.get_loc": [
                    724
                ],
                "kind": [
                    749
                ],
                "label": [
                    751,
                    752,
                    753,
                    755,
                    759,
                    760,
                    761,
                    763
                ],
                "datetime": [
                    751
                ],
                "_": [
                    755
                ],
                "bounds": [
                    756,
                    757
                ],
                "self._parsed_string_to_bounds": [
                    816,
                    756
                ],
                "is_float": [
                    760
                ],
                "self._invalid_indexer": [
                    761
                ],
                "t1": [
                    769,
                    772,
                    804,
                    774,
                    776,
                    784,
                    816,
                    818,
                    793,
                    767
                ],
                "parsed.year": [
                    769,
                    772,
                    774,
                    777,
                    785,
                    794,
                    767
                ],
                "parsed.month": [
                    769,
                    771,
                    774,
                    778,
                    786,
                    795
                ],
                "q": [
                    771,
                    772
                ],
                "parsed.day": [
                    787,
                    779,
                    796,
                    774
                ],
                "parsed.hour": [
                    797,
                    780,
                    788
                ],
                "parsed.minute": [
                    789,
                    798
                ],
                "parsed.second": [
                    799
                ],
                "t1.asfreq": [
                    804
                ],
                "t2": [
                    816,
                    819
                ],
                "self.searchsorted": [
                    818,
                    819
                ],
                "t1.ordinal": [
                    818
                ],
                "t2.ordinal": [
                    819
                ],
                "DatetimeIndexOpsMixin._convert_tolerance": [
                    823
                ],
                "target.size": [
                    824
                ],
                "tolerance.size": [
                    824
                ],
                "self._maybe_convert_timedelta": [
                    826
                ],
                "item.freq": [
                    829
                ],
                "insert": [
                    830
                ],
                "loc": [
                    833,
                    830
                ],
                "idx": [
                    832,
                    835
                ],
                "np.concatenate": [
                    832
                ],
                "asi8": [
                    833
                ],
                "np.array": [
                    833
                ],
                "item.ordinal": [
                    833
                ],
                "self._assert_can_do_setop": [
                    841
                ],
                "join": [
                    844
                ],
                "return_indexers": [
                    857,
                    853,
                    845
                ],
                "sort": [
                    864,
                    845,
                    854
                ],
                "Int64Index.join": [
                    848
                ],
                "lidx": [
                    858,
                    859
                ],
                "ridx": [
                    858,
                    859
                ],
                "self._apply_meta": [
                    859,
                    860,
                    879
                ],
                "Index.intersection": [
                    864,
                    862
                ],
                "Index.intersection.__doc__": [
                    862
                ],
                "_assert_can_do_setop": [
                    867
                ],
                "other.freq": [
                    871
                ],
                "get_op_result_name": [
                    878
                ],
                "rawarr": [
                    884,
                    885,
                    886
                ],
                "PeriodIndex._simple_new": [
                    885
                ],
                "state": [
                    897,
                    898,
                    906,
                    907,
                    891,
                    892,
                    894
                ],
                "__setstate__": [
                    916,
                    892
                ],
                "nd_state": [
                    898,
                    899,
                    900
                ],
                "own_state": [
                    898,
                    903
                ],
                "np.empty": [
                    906,
                    899
                ],
                "np.ndarray.__setstate__": [
                    907,
                    900
                ],
                "_unpickle_compat": [
                    916
                ],
                "self._ndarray_values.flags": [
                    927
                ],
                "memory_usage": [
                    975
                ],
                "deep": [
                    977,
                    975
                ],
                "self._cache": [
                    976
                ],
                "self._int64index.memory_usage": [
                    977
                ],
                "delegate_names": [
                    70,
                    71
                ],
                "PeriodDelegateMixin._delegated_properties": [
                    70
                ],
                "PeriodDelegateMixin._delegated_methods": [
                    72
                ],
                "PeriodIndex._add_comparison_ops": [
                    981
                ],
                "PeriodIndex._add_numeric_methods_disabled": [
                    982
                ],
                "PeriodIndex._add_logical_methods_disabled": [
                    983
                ],
                "PeriodIndex._add_datetimelike_methods": [
                    984
                ],
                "com.count_not_none": [
                    1038
                ]
            }
        },
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_167/pandas/core/indexing.py": {
            "buggy_functions": [
                {
                    "function_name": "_is_scalar_access",
                    "function_code": "def _is_scalar_access(self, key: Tuple):\n    # this is a shortcut accessor to both .loc and .iloc\n    # that provide the equivalent access of .at and .iat\n    # a) avoid getting things via sections and (to minimize dtype changes)\n    # b) provide a performant path\n    if len(key) != self.ndim:\n        return False\n\n    for i, k in enumerate(key):\n        if not is_scalar(k):\n            return False\n\n        ax = self.obj.axes[i]\n        if isinstance(ax, MultiIndex):\n            return False\n\n        if not ax.is_unique:\n            return False\n\n    return True\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 1691,
                    "end_line": 1710,
                    "variables": {
                        "Tuple": [
                            1691
                        ],
                        "len": [
                            1696
                        ],
                        "key": [
                            1696,
                            1699
                        ],
                        "self.ndim": [
                            1696
                        ],
                        "self": [
                            1696,
                            1703
                        ],
                        "i": [
                            1699,
                            1703
                        ],
                        "k": [
                            1699,
                            1700
                        ],
                        "enumerate": [
                            1699
                        ],
                        "is_scalar": [
                            1700
                        ],
                        "ax": [
                            1704,
                            1707,
                            1703
                        ],
                        "self.obj.axes": [
                            1703
                        ],
                        "self.obj": [
                            1703
                        ],
                        "isinstance": [
                            1704
                        ],
                        "MultiIndex": [
                            1704
                        ],
                        "ax.is_unique": [
                            1707
                        ]
                    },
                    "filtered_variables": {
                        "Tuple": [
                            1691
                        ],
                        "key": [
                            1696,
                            1699
                        ],
                        "self.ndim": [
                            1696
                        ],
                        "self": [
                            1696,
                            1703
                        ],
                        "i": [
                            1699,
                            1703
                        ],
                        "k": [
                            1699,
                            1700
                        ],
                        "is_scalar": [
                            1700
                        ],
                        "ax": [
                            1704,
                            1707,
                            1703
                        ],
                        "self.obj.axes": [
                            1703
                        ],
                        "self.obj": [
                            1703
                        ],
                        "MultiIndex": [
                            1704
                        ],
                        "ax.is_unique": [
                            1707
                        ]
                    },
                    "diff_line_number": 1706,
                    "class_data": {
                        "signature": "class _LocIndexer(_LocationIndexer)",
                        "docstring": "Access a group of rows and columns by label(s) or a boolean array.\n\n``.loc[]`` is primarily label based, but may also be used with a\nboolean array.\n\nAllowed inputs are:\n\n- A single label, e.g. ``5`` or ``'a'``, (note that ``5`` is\n  interpreted as a *label* of the index, and **never** as an\n  integer position along the index).\n- A list or array of labels, e.g. ``['a', 'b', 'c']``.\n- A slice object with labels, e.g. ``'a':'f'``.\n\n  .. warning:: Note that contrary to usual python slices, **both** the\n      start and the stop are included\n\n- A boolean array of the same length as the axis being sliced,\n  e.g. ``[True, False, True]``.\n- A ``callable`` function with one argument (the calling Series or\n  DataFrame) and that returns valid output for indexing (one of the above)\n\nSee more at :ref:`Selection by Label <indexing.label>`\n\nRaises\n------\nKeyError:\n    when any items are not found\n\nSee Also\n--------\nDataFrame.at : Access a single value for a row/column label pair.\nDataFrame.iloc : Access group of rows and columns by integer position(s).\nDataFrame.xs : Returns a cross-section (row(s) or column(s)) from the\n    Series/DataFrame.\nSeries.loc : Access group of values using labels.\n\nExamples\n--------\n**Getting values**\n\n>>> df = pd.DataFrame([[1, 2], [4, 5], [7, 8]],\n...      index=['cobra', 'viper', 'sidewinder'],\n...      columns=['max_speed', 'shield'])\n>>> df\n            max_speed  shield\ncobra               1       2\nviper               4       5\nsidewinder          7       8\n\nSingle label. Note this returns the row as a Series.\n\n>>> df.loc['viper']\nmax_speed    4\nshield       5\nName: viper, dtype: int64\n\nList of labels. Note using ``[[]]`` returns a DataFrame.\n\n>>> df.loc[['viper', 'sidewinder']]\n            max_speed  shield\nviper               4       5\nsidewinder          7       8\n\nSingle label for row and column\n\n>>> df.loc['cobra', 'shield']\n2\n\nSlice with labels for row and single label for column. As mentioned\nabove, note that both the start and stop of the slice are included.\n\n>>> df.loc['cobra':'viper', 'max_speed']\ncobra    1\nviper    4\nName: max_speed, dtype: int64\n\nBoolean list with the same length as the row axis\n\n>>> df.loc[[False, False, True]]\n            max_speed  shield\nsidewinder          7       8\n\nConditional that returns a boolean Series\n\n>>> df.loc[df['shield'] > 6]\n            max_speed  shield\nsidewinder          7       8\n\nConditional that returns a boolean Series with column labels specified\n\n>>> df.loc[df['shield'] > 6, ['max_speed']]\n            max_speed\nsidewinder          7\n\nCallable that returns a boolean Series\n\n>>> df.loc[lambda df: df['shield'] == 8]\n            max_speed  shield\nsidewinder          7       8\n\n**Setting values**\n\nSet value for all items matching the list of labels\n\n>>> df.loc[['viper', 'sidewinder'], ['shield']] = 50\n>>> df\n            max_speed  shield\ncobra               1       2\nviper               4      50\nsidewinder          7      50\n\nSet value for an entire row\n\n>>> df.loc['cobra'] = 10\n>>> df\n            max_speed  shield\ncobra              10      10\nviper               4      50\nsidewinder          7      50\n\nSet value for an entire column\n\n>>> df.loc[:, 'max_speed'] = 30\n>>> df\n            max_speed  shield\ncobra              30      10\nviper              30      50\nsidewinder         30      50\n\nSet value for rows matching callable condition\n\n>>> df.loc[df['shield'] > 35] = 0\n>>> df\n            max_speed  shield\ncobra              30      10\nviper               0       0\nsidewinder          0       0\n\n**Getting values on a DataFrame with an index that has integer labels**\n\nAnother example using integers for the index\n\n>>> df = pd.DataFrame([[1, 2], [4, 5], [7, 8]],\n...      index=[7, 8, 9], columns=['max_speed', 'shield'])\n>>> df\n   max_speed  shield\n7          1       2\n8          4       5\n9          7       8\n\nSlice with integer labels for rows. As mentioned above, note that both\nthe start and stop of the slice are included.\n\n>>> df.loc[7:9]\n   max_speed  shield\n7          1       2\n8          4       5\n9          7       8\n\n**Getting values with a MultiIndex**\n\nA number of examples using a DataFrame with a MultiIndex\n\n>>> tuples = [\n...    ('cobra', 'mark i'), ('cobra', 'mark ii'),\n...    ('sidewinder', 'mark i'), ('sidewinder', 'mark ii'),\n...    ('viper', 'mark ii'), ('viper', 'mark iii')\n... ]\n>>> index = pd.MultiIndex.from_tuples(tuples)\n>>> values = [[12, 2], [0, 4], [10, 20],\n...         [1, 4], [7, 1], [16, 36]]\n>>> df = pd.DataFrame(values, columns=['max_speed', 'shield'], index=index)\n>>> df\n                     max_speed  shield\ncobra      mark i           12       2\n           mark ii           0       4\nsidewinder mark i           10      20\n           mark ii           1       4\nviper      mark ii           7       1\n           mark iii         16      36\n\nSingle label. Note this returns a DataFrame with a single index.\n\n>>> df.loc['cobra']\n         max_speed  shield\nmark i          12       2\nmark ii          0       4\n\nSingle index tuple. Note this returns a Series.\n\n>>> df.loc[('cobra', 'mark ii')]\nmax_speed    0\nshield       4\nName: (cobra, mark ii), dtype: int64\n\nSingle label for row and column. Similar to passing in a tuple, this\nreturns a Series.\n\n>>> df.loc['cobra', 'mark i']\nmax_speed    12\nshield        2\nName: (cobra, mark i), dtype: int64\n\nSingle tuple. Note using ``[[]]`` returns a DataFrame.\n\n>>> df.loc[[('cobra', 'mark ii')]]\n               max_speed  shield\ncobra mark ii          0       4\n\nSingle tuple for the index with a single label for the column\n\n>>> df.loc[('cobra', 'mark i'), 'shield']\n2\n\nSlice from index tuple to single label\n\n>>> df.loc[('cobra', 'mark i'):'viper']\n                     max_speed  shield\ncobra      mark i           12       2\n           mark ii           0       4\nsidewinder mark i           10      20\n           mark ii           1       4\nviper      mark ii           7       1\n           mark iii         16      36\n\nSlice from index tuple to index tuple\n\n>>> df.loc[('cobra', 'mark i'):('viper', 'mark ii')]\n                    max_speed  shield\ncobra      mark i          12       2\n           mark ii          0       4\nsidewinder mark i          10      20\n           mark ii          1       4\nviper      mark ii          7       1",
                        "constructor_docstring": null,
                        "functions": [
                            "@Appender(_NDFrameIndexer._validate_key.__doc__)\ndef _validate_key(self, key, axis: int):\n    if isinstance(key, slice):\n        return\n    if com.is_bool_indexer(key):\n        return\n    if not is_list_like_indexer(key):\n        self._convert_scalar_indexer(key, axis)",
                            "def _is_scalar_access(self, key: Tuple):\n    if len(key) != self.ndim:\n        return False\n    for i, k in enumerate(key):\n        if not is_scalar(k):\n            return False\n        ax = self.obj.axes[i]\n        if isinstance(ax, MultiIndex):\n            return False\n        if not ax.is_unique:\n            return False\n    return True",
                            "def _getitem_scalar(self, key):\n    values = self.obj._get_value(*key)\n    return values",
                            "def _get_partial_string_timestamp_match_key(self, key, labels):\n    \"\"\"Translate any partial string timestamp matches in key, returning the\n    new key (GH 10331)\"\"\"\n    if isinstance(labels, MultiIndex):\n        if isinstance(key, str) and labels.levels[0].is_all_dates:\n            key = tuple([key] + [slice(None)] * (len(labels.levels) - 1))\n        if isinstance(key, tuple):\n            new_key = []\n            for i, component in enumerate(key):\n                if isinstance(component, str) and labels.levels[i].is_all_dates:\n                    new_key.append(slice(component, component, None))\n                else:\n                    new_key.append(component)\n            key = tuple(new_key)\n    return key",
                            "def _getitem_axis(self, key, axis: int):\n    key = item_from_zerodim(key)\n    if is_iterator(key):\n        key = list(key)\n    labels = self.obj._get_axis(axis)\n    key = self._get_partial_string_timestamp_match_key(key, labels)\n    if isinstance(key, slice):\n        self._validate_key(key, axis)\n        return self._get_slice_axis(key, axis=axis)\n    elif com.is_bool_indexer(key):\n        return self._getbool_axis(key, axis=axis)\n    elif is_list_like_indexer(key):\n        if isinstance(labels, MultiIndex):\n            if isinstance(key, (ABCSeries, np.ndarray)) and key.ndim <= 1:\n                key = list(key)\n            elif isinstance(key, ABCDataFrame):\n                raise NotImplementedError('Indexing a MultiIndex with a DataFrame key is not implemented')\n            elif hasattr(key, 'ndim') and key.ndim > 1:\n                raise NotImplementedError('Indexing a MultiIndex with a multidimensional key is not implemented')\n            if not isinstance(key, tuple) and len(key) and (not isinstance(key[0], tuple)):\n                key = tuple([key])\n        if not (isinstance(key, tuple) and isinstance(labels, MultiIndex)):\n            if hasattr(key, 'ndim') and key.ndim > 1:\n                raise ValueError('Cannot index with multidimensional key')\n            return self._getitem_iterable(key, axis=axis)\n        if is_nested_tuple(key, labels):\n            locs = labels.get_locs(key)\n            indexer = [slice(None)] * self.ndim\n            indexer[axis] = locs\n            return self.obj.iloc[tuple(indexer)]\n    self._validate_key(key, axis)\n    return self._get_label(key, axis=axis)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_valid_types",
                            "_exception"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_validate_key(self, key, axis: int)",
                            "_is_scalar_access(self, key: Tuple)",
                            "_getitem_scalar(self, key)",
                            "_get_partial_string_timestamp_match_key(self, key, labels)",
                            "_getitem_axis(self, key, axis: int)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "Tuple": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "('2000', 'A')",
                                    "variable_type": "tuple",
                                    "variable_shape": "2"
                                },
                                "self.ndim": {
                                    "variable_value": "2",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x115c670e0>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "i": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "k": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ax": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.obj.axes": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.obj": {
                                    "variable_value": "             A\n2000-01-31   0\n2000-02-29   1\n2000-03-31   2\n2000-04-30   3\n2000-05-31   4\n2000-06-30   5\n2000-07-31   6\n2000-08-31   7\n2000-09-30   8\n2000-10-31   9\n2000-11-30  10\n2000-12-31  11\n2001-01-31  12\n2001-02-28  13\n2001-03-31  14\n2001-04-30  15\n2001-05-31  16\n2001-06-30  17\n2001-07-31  18\n2001-08-31  19\n2001-09-30  20\n2001-10-31  21\n2001-11-30  22\n2001-12-31  23",
                                    "variable_type": "DataFrame",
                                    "variable_shape": "(24, 1)"
                                },
                                "MultiIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ax.is_unique": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "Tuple": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "('2000', 'A')",
                                    "variable_type": "tuple",
                                    "variable_shape": "2"
                                },
                                "self.ndim": {
                                    "variable_value": "2",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x115c670e0>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "i": {
                                    "variable_value": "1",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "k": {
                                    "variable_value": "'A'",
                                    "variable_type": "str",
                                    "variable_shape": "1"
                                },
                                "is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ax": {
                                    "variable_value": "Index(['A'], dtype='object')",
                                    "variable_type": "Index",
                                    "variable_shape": "(1,)"
                                },
                                "self.obj.axes": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.obj": {
                                    "variable_value": "             A\n2000-01-31   0\n2000-02-29   1\n2000-03-31   2\n2000-04-30   3\n2000-05-31   4\n2000-06-30   5\n2000-07-31   6\n2000-08-31   7\n2000-09-30   8\n2000-10-31   9\n2000-11-30  10\n2000-12-31  11\n2001-01-31  12\n2001-02-28  13\n2001-03-31  14\n2001-04-30  15\n2001-05-31  16\n2001-06-30  17\n2001-07-31  18\n2001-08-31  19\n2001-09-30  20\n2001-10-31  21\n2001-11-30  22\n2001-12-31  23",
                                    "variable_type": "DataFrame",
                                    "variable_shape": "(24, 1)"
                                },
                                "MultiIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ax.is_unique": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "Tuple": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "('2000', 'A')",
                                    "variable_type": "tuple",
                                    "variable_shape": "2"
                                },
                                "self.ndim": {
                                    "variable_value": "2",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x1194c7950>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "i": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "k": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ax": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.obj.axes": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.obj": {
                                    "variable_value": "             A\n2000-01-31   0\n2000-02-29   1\n2000-03-31   2\n2000-04-30   3\n2000-05-31   4\n2000-06-30   5\n2000-07-31   6\n2000-08-31   7\n2000-09-30   8\n2000-10-31   9\n2000-11-30  10\n2000-12-31  11\n2001-01-31  12\n2001-02-28  13\n2001-03-31  14\n2001-04-30  15\n2001-05-31  16\n2001-06-30  17\n2001-07-31  18\n2001-08-31  19\n2001-09-30  20\n2001-10-31  21\n2001-11-30  22\n2001-12-31  23",
                                    "variable_type": "DataFrame",
                                    "variable_shape": "(24, 1)"
                                },
                                "MultiIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ax._supports_partial_string_indexing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ax.is_unique": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "Tuple": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "('2000', 'A')",
                                    "variable_type": "tuple",
                                    "variable_shape": "2"
                                },
                                "self.ndim": {
                                    "variable_value": "2",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x1194c7950>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "i": {
                                    "variable_value": "0",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "k": {
                                    "variable_value": "'2000'",
                                    "variable_type": "str",
                                    "variable_shape": "4"
                                },
                                "is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ax": {
                                    "variable_value": "DatetimeIndex(['2000-01-31', '2000-02-29', '2000-03-31', '2000-04-30',\n               '2000-05-31', '2000-06-30', '2000-07-31', '2000-08-31',\n               '2000-09-30', '2000-10-31', '2000-11-30', '2000-12-31',\n               '2001-01-31', '2001-02-28', '2001-03-31', '2001-04-30',\n               '2001-05-31', '2001-06-30', '2001-07-31', '2001-08-31',\n               '2001-09-30', '2001-10-31', '2001-11-30', '2001-12-31'],\n              dtype='datetime64[ns]', freq='M')",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "(24,)"
                                },
                                "self.obj.axes": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.obj": {
                                    "variable_value": "             A\n2000-01-31   0\n2000-02-29   1\n2000-03-31   2\n2000-04-30   3\n2000-05-31   4\n2000-06-30   5\n2000-07-31   6\n2000-08-31   7\n2000-09-30   8\n2000-10-31   9\n2000-11-30  10\n2000-12-31  11\n2001-01-31  12\n2001-02-28  13\n2001-03-31  14\n2001-04-30  15\n2001-05-31  16\n2001-06-30  17\n2001-07-31  18\n2001-08-31  19\n2001-09-30  20\n2001-10-31  21\n2001-11-30  22\n2001-12-31  23",
                                    "variable_type": "DataFrame",
                                    "variable_shape": "(24, 1)"
                                },
                                "MultiIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ax._supports_partial_string_indexing": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "ax.is_unique": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "Tuple": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "(slice(None, None, None), 'A')",
                                    "variable_type": "tuple",
                                    "variable_shape": "2"
                                },
                                "self.ndim": {
                                    "variable_value": "2",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x11946b2c0>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "i": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "k": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ax": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.obj.axes": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.obj": {
                                    "variable_value": "             A\n2000-01-31   0\n2000-02-29   1\n2000-03-31   2\n2000-04-30   3\n2000-05-31   4\n2000-06-30   5\n2000-07-31   6\n2000-08-31   7\n2000-09-30   8\n2000-10-31   9\n2000-11-30  10\n2000-12-31  11",
                                    "variable_type": "DataFrame",
                                    "variable_shape": "(12, 1)"
                                },
                                "MultiIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ax._supports_partial_string_indexing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ax.is_unique": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "Tuple": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "(slice(None, None, None), 'A')",
                                    "variable_type": "tuple",
                                    "variable_shape": "2"
                                },
                                "self.ndim": {
                                    "variable_value": "2",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<pandas.core.indexing._LocIndexer object at 0x11946b2c0>",
                                    "variable_type": "_LocIndexer",
                                    "variable_shape": null
                                },
                                "i": {
                                    "variable_value": "0",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "k": {
                                    "variable_value": "slice(None, None, None)",
                                    "variable_type": "slice",
                                    "variable_shape": null
                                },
                                "is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ax": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.obj.axes": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.obj": {
                                    "variable_value": "             A\n2000-01-31   0\n2000-02-29   1\n2000-03-31   2\n2000-04-30   3\n2000-05-31   4\n2000-06-30   5\n2000-07-31   6\n2000-08-31   7\n2000-09-30   8\n2000-10-31   9\n2000-11-30  10\n2000-12-31  11",
                                    "variable_type": "DataFrame",
                                    "variable_shape": "(12, 1)"
                                },
                                "MultiIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ax._supports_partial_string_indexing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ax.is_unique": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "_get_partial_string_timestamp_match_key",
                    "function_code": "def _get_partial_string_timestamp_match_key(self, key, labels):\n    \"\"\"Translate any partial string timestamp matches in key, returning the\n    new key (GH 10331)\"\"\"\n    if isinstance(labels, MultiIndex):\n        if isinstance(key, str) and labels.levels[0].is_all_dates:\n            # Convert key '2016-01-01' to\n            # ('2016-01-01'[, slice(None, None, None)]+)\n            key = tuple([key] + [slice(None)] * (len(labels.levels) - 1))\n\n        if isinstance(key, tuple):\n            # Convert (..., '2016-01-01', ...) in tuple to\n            # (..., slice('2016-01-01', '2016-01-01', None), ...)\n            new_key = []\n            for i, component in enumerate(key):\n                if isinstance(component, str) and labels.levels[i].is_all_dates:\n                    new_key.append(slice(component, component, None))\n                else:\n                    new_key.append(component)\n            key = tuple(new_key)\n\n    return key\n",
                    "decorators": [],
                    "docstring": "Translate any partial string timestamp matches in key, returning the\nnew key (GH 10331)",
                    "start_line": 1718,
                    "end_line": 1738,
                    "variables": {
                        "isinstance": [
                            1721,
                            1722,
                            1732,
                            1727
                        ],
                        "labels": [
                            1721,
                            1722,
                            1732,
                            1725
                        ],
                        "MultiIndex": [
                            1721
                        ],
                        "key": [
                            1731,
                            1736,
                            1738,
                            1722,
                            1725,
                            1727
                        ],
                        "str": [
                            1722,
                            1732
                        ],
                        "is_all_dates": [
                            1722,
                            1732
                        ],
                        "labels.levels": [
                            1722,
                            1732,
                            1725
                        ],
                        "tuple": [
                            1736,
                            1725,
                            1727
                        ],
                        "slice": [
                            1733,
                            1725
                        ],
                        "len": [
                            1725
                        ],
                        "new_key": [
                            1736,
                            1730,
                            1733,
                            1735
                        ],
                        "i": [
                            1731,
                            1732
                        ],
                        "component": [
                            1731,
                            1732,
                            1733,
                            1735
                        ],
                        "enumerate": [
                            1731
                        ],
                        "new_key.append": [
                            1733,
                            1735
                        ]
                    },
                    "filtered_variables": {
                        "labels": [
                            1721,
                            1722,
                            1732,
                            1725
                        ],
                        "MultiIndex": [
                            1721
                        ],
                        "key": [
                            1731,
                            1736,
                            1738,
                            1722,
                            1725,
                            1727
                        ],
                        "is_all_dates": [
                            1722,
                            1732
                        ],
                        "labels.levels": [
                            1722,
                            1732,
                            1725
                        ],
                        "new_key": [
                            1736,
                            1730,
                            1733,
                            1735
                        ],
                        "i": [
                            1731,
                            1732
                        ],
                        "component": [
                            1731,
                            1732,
                            1733,
                            1735
                        ],
                        "new_key.append": [
                            1733,
                            1735
                        ]
                    },
                    "diff_line_number": 1722,
                    "class_data": {
                        "signature": "class _LocIndexer(_LocationIndexer)",
                        "docstring": "Access a group of rows and columns by label(s) or a boolean array.\n\n``.loc[]`` is primarily label based, but may also be used with a\nboolean array.\n\nAllowed inputs are:\n\n- A single label, e.g. ``5`` or ``'a'``, (note that ``5`` is\n  interpreted as a *label* of the index, and **never** as an\n  integer position along the index).\n- A list or array of labels, e.g. ``['a', 'b', 'c']``.\n- A slice object with labels, e.g. ``'a':'f'``.\n\n  .. warning:: Note that contrary to usual python slices, **both** the\n      start and the stop are included\n\n- A boolean array of the same length as the axis being sliced,\n  e.g. ``[True, False, True]``.\n- A ``callable`` function with one argument (the calling Series or\n  DataFrame) and that returns valid output for indexing (one of the above)\n\nSee more at :ref:`Selection by Label <indexing.label>`\n\nRaises\n------\nKeyError:\n    when any items are not found\n\nSee Also\n--------\nDataFrame.at : Access a single value for a row/column label pair.\nDataFrame.iloc : Access group of rows and columns by integer position(s).\nDataFrame.xs : Returns a cross-section (row(s) or column(s)) from the\n    Series/DataFrame.\nSeries.loc : Access group of values using labels.\n\nExamples\n--------\n**Getting values**\n\n>>> df = pd.DataFrame([[1, 2], [4, 5], [7, 8]],\n...      index=['cobra', 'viper', 'sidewinder'],\n...      columns=['max_speed', 'shield'])\n>>> df\n            max_speed  shield\ncobra               1       2\nviper               4       5\nsidewinder          7       8\n\nSingle label. Note this returns the row as a Series.\n\n>>> df.loc['viper']\nmax_speed    4\nshield       5\nName: viper, dtype: int64\n\nList of labels. Note using ``[[]]`` returns a DataFrame.\n\n>>> df.loc[['viper', 'sidewinder']]\n            max_speed  shield\nviper               4       5\nsidewinder          7       8\n\nSingle label for row and column\n\n>>> df.loc['cobra', 'shield']\n2\n\nSlice with labels for row and single label for column. As mentioned\nabove, note that both the start and stop of the slice are included.\n\n>>> df.loc['cobra':'viper', 'max_speed']\ncobra    1\nviper    4\nName: max_speed, dtype: int64\n\nBoolean list with the same length as the row axis\n\n>>> df.loc[[False, False, True]]\n            max_speed  shield\nsidewinder          7       8\n\nConditional that returns a boolean Series\n\n>>> df.loc[df['shield'] > 6]\n            max_speed  shield\nsidewinder          7       8\n\nConditional that returns a boolean Series with column labels specified\n\n>>> df.loc[df['shield'] > 6, ['max_speed']]\n            max_speed\nsidewinder          7\n\nCallable that returns a boolean Series\n\n>>> df.loc[lambda df: df['shield'] == 8]\n            max_speed  shield\nsidewinder          7       8\n\n**Setting values**\n\nSet value for all items matching the list of labels\n\n>>> df.loc[['viper', 'sidewinder'], ['shield']] = 50\n>>> df\n            max_speed  shield\ncobra               1       2\nviper               4      50\nsidewinder          7      50\n\nSet value for an entire row\n\n>>> df.loc['cobra'] = 10\n>>> df\n            max_speed  shield\ncobra              10      10\nviper               4      50\nsidewinder          7      50\n\nSet value for an entire column\n\n>>> df.loc[:, 'max_speed'] = 30\n>>> df\n            max_speed  shield\ncobra              30      10\nviper              30      50\nsidewinder         30      50\n\nSet value for rows matching callable condition\n\n>>> df.loc[df['shield'] > 35] = 0\n>>> df\n            max_speed  shield\ncobra              30      10\nviper               0       0\nsidewinder          0       0\n\n**Getting values on a DataFrame with an index that has integer labels**\n\nAnother example using integers for the index\n\n>>> df = pd.DataFrame([[1, 2], [4, 5], [7, 8]],\n...      index=[7, 8, 9], columns=['max_speed', 'shield'])\n>>> df\n   max_speed  shield\n7          1       2\n8          4       5\n9          7       8\n\nSlice with integer labels for rows. As mentioned above, note that both\nthe start and stop of the slice are included.\n\n>>> df.loc[7:9]\n   max_speed  shield\n7          1       2\n8          4       5\n9          7       8\n\n**Getting values with a MultiIndex**\n\nA number of examples using a DataFrame with a MultiIndex\n\n>>> tuples = [\n...    ('cobra', 'mark i'), ('cobra', 'mark ii'),\n...    ('sidewinder', 'mark i'), ('sidewinder', 'mark ii'),\n...    ('viper', 'mark ii'), ('viper', 'mark iii')\n... ]\n>>> index = pd.MultiIndex.from_tuples(tuples)\n>>> values = [[12, 2], [0, 4], [10, 20],\n...         [1, 4], [7, 1], [16, 36]]\n>>> df = pd.DataFrame(values, columns=['max_speed', 'shield'], index=index)\n>>> df\n                     max_speed  shield\ncobra      mark i           12       2\n           mark ii           0       4\nsidewinder mark i           10      20\n           mark ii           1       4\nviper      mark ii           7       1\n           mark iii         16      36\n\nSingle label. Note this returns a DataFrame with a single index.\n\n>>> df.loc['cobra']\n         max_speed  shield\nmark i          12       2\nmark ii          0       4\n\nSingle index tuple. Note this returns a Series.\n\n>>> df.loc[('cobra', 'mark ii')]\nmax_speed    0\nshield       4\nName: (cobra, mark ii), dtype: int64\n\nSingle label for row and column. Similar to passing in a tuple, this\nreturns a Series.\n\n>>> df.loc['cobra', 'mark i']\nmax_speed    12\nshield        2\nName: (cobra, mark i), dtype: int64\n\nSingle tuple. Note using ``[[]]`` returns a DataFrame.\n\n>>> df.loc[[('cobra', 'mark ii')]]\n               max_speed  shield\ncobra mark ii          0       4\n\nSingle tuple for the index with a single label for the column\n\n>>> df.loc[('cobra', 'mark i'), 'shield']\n2\n\nSlice from index tuple to single label\n\n>>> df.loc[('cobra', 'mark i'):'viper']\n                     max_speed  shield\ncobra      mark i           12       2\n           mark ii           0       4\nsidewinder mark i           10      20\n           mark ii           1       4\nviper      mark ii           7       1\n           mark iii         16      36\n\nSlice from index tuple to index tuple\n\n>>> df.loc[('cobra', 'mark i'):('viper', 'mark ii')]\n                    max_speed  shield\ncobra      mark i          12       2\n           mark ii          0       4\nsidewinder mark i          10      20\n           mark ii          1       4\nviper      mark ii          7       1",
                        "constructor_docstring": null,
                        "functions": [
                            "@Appender(_NDFrameIndexer._validate_key.__doc__)\ndef _validate_key(self, key, axis: int):\n    if isinstance(key, slice):\n        return\n    if com.is_bool_indexer(key):\n        return\n    if not is_list_like_indexer(key):\n        self._convert_scalar_indexer(key, axis)",
                            "def _is_scalar_access(self, key: Tuple):\n    if len(key) != self.ndim:\n        return False\n    for i, k in enumerate(key):\n        if not is_scalar(k):\n            return False\n        ax = self.obj.axes[i]\n        if isinstance(ax, MultiIndex):\n            return False\n        if not ax.is_unique:\n            return False\n    return True",
                            "def _getitem_scalar(self, key):\n    values = self.obj._get_value(*key)\n    return values",
                            "def _get_partial_string_timestamp_match_key(self, key, labels):\n    \"\"\"Translate any partial string timestamp matches in key, returning the\n    new key (GH 10331)\"\"\"\n    if isinstance(labels, MultiIndex):\n        if isinstance(key, str) and labels.levels[0].is_all_dates:\n            key = tuple([key] + [slice(None)] * (len(labels.levels) - 1))\n        if isinstance(key, tuple):\n            new_key = []\n            for i, component in enumerate(key):\n                if isinstance(component, str) and labels.levels[i].is_all_dates:\n                    new_key.append(slice(component, component, None))\n                else:\n                    new_key.append(component)\n            key = tuple(new_key)\n    return key",
                            "def _getitem_axis(self, key, axis: int):\n    key = item_from_zerodim(key)\n    if is_iterator(key):\n        key = list(key)\n    labels = self.obj._get_axis(axis)\n    key = self._get_partial_string_timestamp_match_key(key, labels)\n    if isinstance(key, slice):\n        self._validate_key(key, axis)\n        return self._get_slice_axis(key, axis=axis)\n    elif com.is_bool_indexer(key):\n        return self._getbool_axis(key, axis=axis)\n    elif is_list_like_indexer(key):\n        if isinstance(labels, MultiIndex):\n            if isinstance(key, (ABCSeries, np.ndarray)) and key.ndim <= 1:\n                key = list(key)\n            elif isinstance(key, ABCDataFrame):\n                raise NotImplementedError('Indexing a MultiIndex with a DataFrame key is not implemented')\n            elif hasattr(key, 'ndim') and key.ndim > 1:\n                raise NotImplementedError('Indexing a MultiIndex with a multidimensional key is not implemented')\n            if not isinstance(key, tuple) and len(key) and (not isinstance(key[0], tuple)):\n                key = tuple([key])\n        if not (isinstance(key, tuple) and isinstance(labels, MultiIndex)):\n            if hasattr(key, 'ndim') and key.ndim > 1:\n                raise ValueError('Cannot index with multidimensional key')\n            return self._getitem_iterable(key, axis=axis)\n        if is_nested_tuple(key, labels):\n            locs = labels.get_locs(key)\n            indexer = [slice(None)] * self.ndim\n            indexer[axis] = locs\n            return self.obj.iloc[tuple(indexer)]\n    self._validate_key(key, axis)\n    return self._get_label(key, axis=axis)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_valid_types",
                            "_exception"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_validate_key(self, key, axis: int)",
                            "_is_scalar_access(self, key: Tuple)",
                            "_getitem_scalar(self, key)",
                            "_get_partial_string_timestamp_match_key(self, key, labels)",
                            "_getitem_axis(self, key, axis: int)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "labels": {
                                    "variable_value": "DatetimeIndex(['2000-01-31', '2000-02-29', '2000-03-31', '2000-04-30',\n               '2000-05-31', '2000-06-30', '2000-07-31', '2000-08-31',\n               '2000-09-30', '2000-10-31', '2000-11-30', '2000-12-31',\n               '2001-01-31', '2001-02-28', '2001-03-31', '2001-04-30',\n               '2001-05-31', '2001-06-30', '2001-07-31', '2001-08-31',\n               '2001-09-30', '2001-10-31', '2001-11-30', '2001-12-31'],\n              dtype='datetime64[ns]', freq='M')",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "(24,)"
                                },
                                "MultiIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "'2000'",
                                    "variable_type": "str",
                                    "variable_shape": "4"
                                },
                                "_supports_partial_string_indexing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "labels.levels": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "new_key": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "i": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "component": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "new_key.append": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "labels": {
                                    "variable_value": "DatetimeIndex(['2000-01-31', '2000-02-29', '2000-03-31', '2000-04-30',\n               '2000-05-31', '2000-06-30', '2000-07-31', '2000-08-31',\n               '2000-09-30', '2000-10-31', '2000-11-30', '2000-12-31',\n               '2001-01-31', '2001-02-28', '2001-03-31', '2001-04-30',\n               '2001-05-31', '2001-06-30', '2001-07-31', '2001-08-31',\n               '2001-09-30', '2001-10-31', '2001-11-30', '2001-12-31'],\n              dtype='datetime64[ns]', freq='M')",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "(24,)"
                                },
                                "MultiIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "'2000'",
                                    "variable_type": "str",
                                    "variable_shape": "4"
                                },
                                "_supports_partial_string_indexing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "labels.levels": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "new_key": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "i": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "component": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "new_key.append": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "labels": {
                                    "variable_value": "Index(['A'], dtype='object')",
                                    "variable_type": "Index",
                                    "variable_shape": "(1,)"
                                },
                                "MultiIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "'A'",
                                    "variable_type": "str",
                                    "variable_shape": "1"
                                },
                                "_supports_partial_string_indexing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "labels.levels": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "new_key": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "i": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "component": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "new_key.append": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "labels": {
                                    "variable_value": "Index(['A'], dtype='object')",
                                    "variable_type": "Index",
                                    "variable_shape": "(1,)"
                                },
                                "MultiIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "'A'",
                                    "variable_type": "str",
                                    "variable_shape": "1"
                                },
                                "_supports_partial_string_indexing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "labels.levels": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "new_key": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "i": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "component": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "new_key.append": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "convert_to_index_sliceable",
                    "function_code": "def convert_to_index_sliceable(obj, key):\n    \"\"\"\n    if we are index sliceable, then return my slicer, otherwise return None\n    \"\"\"\n    idx = obj.index\n    if isinstance(key, slice):\n        return idx._convert_slice_indexer(key, kind=\"getitem\")\n\n    elif isinstance(key, str):\n\n        # we are an actual column\n        if key in obj._data.items:\n            return None\n\n        # We might have a datetimelike string that we can translate to a\n        # slice here via partial string indexing\n        if idx.is_all_dates:\n            try:\n                return idx._get_string_slice(key)\n            except (KeyError, ValueError, NotImplementedError):\n                return None\n\n    return None\n",
                    "decorators": [],
                    "docstring": "if we are index sliceable, then return my slicer, otherwise return None",
                    "start_line": 2321,
                    "end_line": 2343,
                    "variables": {
                        "idx": [
                            2337,
                            2339,
                            2325,
                            2327
                        ],
                        "obj.index": [
                            2325
                        ],
                        "obj": [
                            2332,
                            2325
                        ],
                        "isinstance": [
                            2329,
                            2326
                        ],
                        "key": [
                            2339,
                            2326,
                            2327,
                            2329,
                            2332
                        ],
                        "slice": [
                            2326
                        ],
                        "idx._convert_slice_indexer": [
                            2327
                        ],
                        "str": [
                            2329
                        ],
                        "obj._data.items": [
                            2332
                        ],
                        "obj._data": [
                            2332
                        ],
                        "idx.is_all_dates": [
                            2337
                        ],
                        "idx._get_string_slice": [
                            2339
                        ],
                        "KeyError": [
                            2340
                        ],
                        "ValueError": [
                            2340
                        ],
                        "NotImplementedError": [
                            2340
                        ]
                    },
                    "filtered_variables": {
                        "idx": [
                            2337,
                            2339,
                            2325,
                            2327
                        ],
                        "obj.index": [
                            2325
                        ],
                        "obj": [
                            2332,
                            2325
                        ],
                        "key": [
                            2339,
                            2326,
                            2327,
                            2329,
                            2332
                        ],
                        "idx._convert_slice_indexer": [
                            2327
                        ],
                        "obj._data.items": [
                            2332
                        ],
                        "obj._data": [
                            2332
                        ],
                        "idx.is_all_dates": [
                            2337
                        ],
                        "idx._get_string_slice": [
                            2339
                        ]
                    },
                    "diff_line_number": 2337,
                    "class_data": null,
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def get_indexers_list():\n\n    return [\n        (\"ix\", _IXIndexer),\n        (\"iloc\", _iLocIndexer),\n        (\"loc\", _LocIndexer),\n        (\"at\", _AtIndexer),\n        (\"iat\", _iAtIndexer),\n    ]",
                "def _tuplify(ndim: int, loc) -> tuple:\n    \"\"\"\n    Given an indexer for the first dimension, create an equivalent tuple\n    for indexing over all dimensions.\n\n    Parameters\n    ----------\n    ndim : int\n    loc : object\n\n    Returns\n    -------\n    tuple\n    \"\"\"\n    tup = [slice(None, None) for _ in range(ndim)]\n    tup[0] = loc\n    return tuple(tup)",
                "def convert_to_index_sliceable(obj, key):\n    \"\"\"\n    if we are index sliceable, then return my slicer, otherwise return None\n    \"\"\"\n    idx = obj.index\n    if isinstance(key, slice):\n        return idx._convert_slice_indexer(key, kind=\"getitem\")\n\n    elif isinstance(key, str):\n\n        # we are an actual column\n        if key in obj._data.items:\n            return None\n\n        # We might have a datetimelike string that we can translate to a\n        # slice here via partial string indexing\n        if idx.is_all_dates:\n            try:\n                return idx._get_string_slice(key)\n            except (KeyError, ValueError, NotImplementedError):\n                return None\n\n    return None",
                "def check_bool_indexer(index: Index, key) -> np.ndarray:\n    \"\"\"\n    Check if key is a valid boolean indexer for an object with such index and\n    perform reindexing or conversion if needed.\n\n    This function assumes that is_bool_indexer(key) == True.\n\n    Parameters\n    ----------\n    index : Index\n        Index of the object on which the indexing is done\n    key : list-like\n        Boolean indexer to check\n\n    Returns\n    -------\n    result: np.array\n        Resulting key\n\n    Raises\n    ------\n    IndexError\n        If the key does not have the same length as index\n\n    IndexingError\n        If the index of the key is unalignable to index\n\n    \"\"\"\n    result = key\n    if isinstance(key, ABCSeries) and not key.index.equals(index):\n        result = result.reindex(index)\n        mask = isna(result._values)\n        if mask.any():\n            raise IndexingError(\n                \"Unalignable boolean Series provided as \"\n                \"indexer (index of the boolean Series and of \"\n                \"the indexed object do not match).\"\n            )\n        result = result.astype(bool)._values\n    else:\n        if is_sparse(result):\n            result = result.to_dense()\n        result = np.asarray(result, dtype=bool)\n\n        # GH26658\n        if len(result) != len(index):\n            raise IndexError(\n                \"Item wrong length {} instead of {}.\".format(len(result), len(index))\n            )\n\n    return result",
                "def convert_missing_indexer(indexer):\n    \"\"\"\n    reverse convert a missing indexer, which is a dict\n    return the scalar indexer and a boolean indicating if we converted\n    \"\"\"\n\n    if isinstance(indexer, dict):\n\n        # a missing key (but not a tuple indexer)\n        indexer = indexer[\"key\"]\n\n        if isinstance(indexer, bool):\n            raise KeyError(\"cannot use a single bool to index into setitem\")\n        return indexer, True\n\n    return indexer, False",
                "def convert_from_missing_indexer_tuple(indexer, axes):\n    \"\"\"\n    create a filtered indexer that doesn't have any missing indexers\n    \"\"\"\n\n    def get_indexer(_i, _idx):\n        return axes[_i].get_loc(_idx[\"key\"]) if isinstance(_idx, dict) else _idx\n\n    return tuple(get_indexer(_i, _idx) for _i, _idx in enumerate(indexer))",
                "def maybe_convert_ix(*args):\n    \"\"\"\n    We likely want to take the cross-product\n    \"\"\"\n\n    ixify = True\n    for arg in args:\n        if not isinstance(arg, (np.ndarray, list, ABCSeries, Index)):\n            ixify = False\n\n    if ixify:\n        return np.ix_(*args)\n    else:\n        return args",
                "def is_nested_tuple(tup, labels):\n    # check for a compatible nested tuple and multiindexes among the axes\n    if not isinstance(tup, tuple):\n        return False\n\n    for i, k in enumerate(tup):\n\n        if is_list_like(k) or isinstance(k, slice):\n            return isinstance(labels, MultiIndex)\n\n    return False",
                "def is_label_like(key):\n    # select a label or row\n    return not isinstance(key, slice) and not is_list_like_indexer(key)",
                "def need_slice(obj):\n    return (\n        obj.start is not None\n        or obj.stop is not None\n        or (obj.step is not None and obj.step != 1)\n    )",
                "def _non_reducing_slice(slice_):\n    \"\"\"\n    Ensurse that a slice doesn't reduce to a Series or Scalar.\n\n    Any user-paseed `subset` should have this called on it\n    to make sure we're always working with DataFrames.\n    \"\"\"\n    # default to column slice, like DataFrame\n    # ['A', 'B'] -> IndexSlices[:, ['A', 'B']]\n    kinds = (ABCSeries, np.ndarray, Index, list, str)\n    if isinstance(slice_, kinds):\n        slice_ = IndexSlice[:, slice_]\n\n    def pred(part):\n        # true when slice does *not* reduce, False when part is a tuple,\n        # i.e. MultiIndex slice\n        return (isinstance(part, slice) or is_list_like(part)) and not isinstance(\n            part, tuple\n        )\n\n    if not is_list_like(slice_):\n        if not isinstance(slice_, slice):\n            # a 1-d slice, like df.loc[1]\n            slice_ = [[slice_]]\n        else:\n            # slice(a, b, c)\n            slice_ = [slice_]  # to tuplize later\n    else:\n        slice_ = [part if pred(part) else [part] for part in slice_]\n    return tuple(slice_)",
                "def _maybe_numeric_slice(df, slice_, include_bool=False):\n    \"\"\"\n    want nice defaults for background_gradient that don't break\n    with non-numeric data. But if slice_ is passed go with that.\n    \"\"\"\n    if slice_ is None:\n        dtypes = [np.number]\n        if include_bool:\n            dtypes.append(bool)\n        slice_ = IndexSlice[:, df.select_dtypes(include=dtypes).columns]\n    return slice_",
                "def _can_do_equal_len(labels, value, plane_indexer, lplane_indexer, obj):\n    \"\"\" return True if we have an equal len settable \"\"\"\n    if not len(labels) == 1 or not np.iterable(value) or is_scalar(plane_indexer[0]):\n        return False\n\n    item = labels[0]\n    index = obj[item].index\n\n    values_len = len(value)\n    # equal len list/ndarray\n    if len(index) == values_len:\n        return True\n    elif lplane_indexer == values_len:\n        return True\n\n    return False",
                "def __getitem__(self, arg):\n    return arg",
                "def __call__(self, axis=None):\n    # we need to return a copy of ourselves\n    new_self = self.__class__(self.name, self.obj)\n\n    if axis is not None:\n        axis = self.obj._get_axis_number(axis)\n    new_self.axis = axis\n    return new_self",
                "def __iter__(self):\n    raise NotImplementedError(\"ix is not iterable\")",
                "def __getitem__(self, key):\n    # Used in ix and downstream in geopandas _CoordinateIndexer\n    if type(key) is tuple:\n        # Note: we check the type exactly instead of with isinstance\n        #  because NamedTuple is checked separately.\n        key = tuple(com.apply_if_callable(x, self.obj) for x in key)\n        try:\n            values = self.obj._get_value(*key)\n        except (KeyError, TypeError, InvalidIndexError):\n            # TypeError occurs here if the key has non-hashable entries,\n            #  generally slice or list.\n            # TODO(ix): most/all of the TypeError cases here are for ix,\n            #  so this check can be removed once ix is removed.\n            # The InvalidIndexError is only catched for compatibility\n            #  with geopandas, see\n            #  https://github.com/pandas-dev/pandas/issues/27258\n            pass\n        else:\n            if is_scalar(values):\n                return values\n\n        return self._getitem_tuple(key)\n    else:\n        # we by definition only have the 0th axis\n        axis = self.axis or 0\n\n        key = com.apply_if_callable(key, self.obj)\n        return self._getitem_axis(key, axis=axis)",
                "def _get_label(self, label, axis: int):\n    if self.ndim == 1:\n        # for perf reasons we want to try _xs first\n        # as its basically direct indexing\n        # but will fail when the index is not present\n        # see GH5667\n        return self.obj._xs(label, axis=axis)\n    elif isinstance(label, tuple) and isinstance(label[axis], slice):\n        raise IndexingError(\"no slices here, handle elsewhere\")\n\n    return self.obj._xs(label, axis=axis)",
                "def _get_loc(self, key: int, axis: int):\n    return self.obj._ixs(key, axis=axis)",
                "def _slice(self, obj, axis: int, kind=None):\n    return self.obj._slice(obj, axis=axis, kind=kind)",
                "def _get_setitem_indexer(self, key):\n    if self.axis is not None:\n        return self._convert_tuple(key)\n\n    ax = self.obj._get_axis(0)\n\n    if isinstance(ax, MultiIndex) and self.name != \"iloc\":\n        try:\n            return ax.get_loc(key)\n        except Exception:\n            pass\n\n    if isinstance(key, tuple):\n        try:\n            return self._convert_tuple(key)\n        except IndexingError:\n            pass\n\n    if isinstance(key, range):\n        return list(key)\n\n    axis = self.axis or 0\n    try:\n        return self._convert_to_indexer(key, axis=axis)\n    except TypeError as e:\n\n        # invalid indexer type vs 'other' indexing errors\n        if \"cannot do\" in str(e):\n            raise\n        raise IndexingError(key)",
                "def __setitem__(self, key, value):\n    if isinstance(key, tuple):\n        key = tuple(com.apply_if_callable(x, self.obj) for x in key)\n    else:\n        key = com.apply_if_callable(key, self.obj)\n    indexer = self._get_setitem_indexer(key)\n    self._setitem_with_indexer(indexer, value)",
                "def _validate_key(self, key, axis: int):\n    \"\"\"\n    Ensure that key is valid for current indexer.\n\n    Parameters\n    ----------\n    key : scalar, slice or list-like\n        The key requested\n    axis : int\n        Dimension on which the indexing is being made\n\n    Raises\n    ------\n    TypeError\n        If the key (or some element of it) has wrong type\n    IndexError\n        If the key (or some element of it) is out of bounds\n    KeyError\n        If the key was not found\n    \"\"\"\n    raise AbstractMethodError(self)",
                "def _has_valid_tuple(self, key: Tuple):\n    \"\"\" check the key for valid keys across my indexer \"\"\"\n    for i, k in enumerate(key):\n        if i >= self.ndim:\n            raise IndexingError(\"Too many indexers\")\n        try:\n            self._validate_key(k, i)\n        except ValueError:\n            raise ValueError(\n                \"Location based indexing can only have \"\n                \"[{types}] types\".format(types=self._valid_types)\n            )",
                "def _is_nested_tuple_indexer(self, tup: Tuple):\n    if any(isinstance(ax, MultiIndex) for ax in self.obj.axes):\n        return any(is_nested_tuple(tup, ax) for ax in self.obj.axes)\n    return False",
                "def _convert_tuple(self, key):\n    keyidx = []\n    if self.axis is not None:\n        axis = self.obj._get_axis_number(self.axis)\n        for i in range(self.ndim):\n            if i == axis:\n                keyidx.append(self._convert_to_indexer(key, axis=axis))\n            else:\n                keyidx.append(slice(None))\n    else:\n        for i, k in enumerate(key):\n            if i >= self.ndim:\n                raise IndexingError(\"Too many indexers\")\n            idx = self._convert_to_indexer(k, axis=i)\n            keyidx.append(idx)\n    return tuple(keyidx)",
                "def _convert_scalar_indexer(self, key, axis: int):\n    # if we are accessing via lowered dim, use the last dim\n    ax = self.obj._get_axis(min(axis, self.ndim - 1))\n    # a scalar\n    return ax._convert_scalar_indexer(key, kind=self.name)",
                "def _convert_slice_indexer(self, key: slice, axis: int):\n    # if we are accessing via lowered dim, use the last dim\n    ax = self.obj._get_axis(min(axis, self.ndim - 1))\n    return ax._convert_slice_indexer(key, kind=self.name)",
                "def _has_valid_setitem_indexer(self, indexer):\n    return True",
                "def _has_valid_positional_setitem_indexer(self, indexer):\n    \"\"\" validate that an positional indexer cannot enlarge its target\n    will raise if needed, does not modify the indexer externally\n    \"\"\"\n    if isinstance(indexer, dict):\n        raise IndexError(\"{0} cannot enlarge its target object\".format(self.name))\n    else:\n        if not isinstance(indexer, tuple):\n            indexer = _tuplify(self.ndim, indexer)\n        for ax, i in zip(self.obj.axes, indexer):\n            if isinstance(i, slice):\n                # should check the stop slice?\n                pass\n            elif is_list_like_indexer(i):\n                # should check the elements?\n                pass\n            elif is_integer(i):\n                if i >= len(ax):\n                    raise IndexError(\n                        \"{name} cannot enlarge its target \"\n                        \"object\".format(name=self.name)\n                    )\n            elif isinstance(i, dict):\n                raise IndexError(\n                    \"{name} cannot enlarge its target object\".format(name=self.name)\n                )\n\n    return True",
                "def _setitem_with_indexer(self, indexer, value):\n    self._has_valid_setitem_indexer(indexer)\n\n    # also has the side effect of consolidating in-place\n    from pandas import Series\n\n    info_axis = self.obj._info_axis_number\n\n    # maybe partial set\n    take_split_path = self.obj._is_mixed_type\n\n    # if there is only one block/type, still have to take split path\n    # unless the block is one-dimensional or it can hold the value\n    if not take_split_path and self.obj._data.blocks:\n        blk, = self.obj._data.blocks\n        if 1 < blk.ndim:  # in case of dict, keys are indices\n            val = list(value.values()) if isinstance(value, dict) else value\n            take_split_path = not blk._can_hold_element(val)\n\n    if isinstance(indexer, tuple):\n        nindexer = []\n        for i, idx in enumerate(indexer):\n            if isinstance(idx, dict):\n\n                # reindex the axis to the new value\n                # and set inplace\n                key, _ = convert_missing_indexer(idx)\n\n                # if this is the items axes, then take the main missing\n                # path first\n                # this correctly sets the dtype and avoids cache issues\n                # essentially this separates out the block that is needed\n                # to possibly be modified\n                if self.ndim > 1 and i == self.obj._info_axis_number:\n\n                    # add the new item, and set the value\n                    # must have all defined axes if we have a scalar\n                    # or a list-like on the non-info axes if we have a\n                    # list-like\n                    len_non_info_axes = (\n                        len(_ax) for _i, _ax in enumerate(self.obj.axes) if _i != i\n                    )\n                    if any(not l for l in len_non_info_axes):\n                        if not is_list_like_indexer(value):\n                            raise ValueError(\n                                \"cannot set a frame with no \"\n                                \"defined index and a scalar\"\n                            )\n                        self.obj[key] = value\n                        return self.obj\n\n                    # add a new item with the dtype setup\n                    self.obj[key] = _infer_fill_value(value)\n\n                    new_indexer = convert_from_missing_indexer_tuple(\n                        indexer, self.obj.axes\n                    )\n                    self._setitem_with_indexer(new_indexer, value)\n\n                    return self.obj\n\n                # reindex the axis\n                # make sure to clear the cache because we are\n                # just replacing the block manager here\n                # so the object is the same\n                index = self.obj._get_axis(i)\n                labels = index.insert(len(index), key)\n                self.obj._data = self.obj.reindex(labels, axis=i)._data\n                self.obj._maybe_update_cacher(clear=True)\n                self.obj._is_copy = None\n\n                nindexer.append(labels.get_loc(key))\n\n            else:\n                nindexer.append(idx)\n\n        indexer = tuple(nindexer)\n    else:\n\n        indexer, missing = convert_missing_indexer(indexer)\n\n        if missing:\n            return self._setitem_with_indexer_missing(indexer, value)\n\n    # set\n    item_labels = self.obj._get_axis(info_axis)\n\n    # align and set the values\n    if take_split_path:\n        # Above we only set take_split_path to True for 2D cases\n        assert self.ndim == 2\n        assert info_axis == 1\n\n        if not isinstance(indexer, tuple):\n            indexer = _tuplify(self.ndim, indexer)\n\n        if isinstance(value, ABCSeries):\n            value = self._align_series(indexer, value)\n\n        info_idx = indexer[info_axis]\n        if is_integer(info_idx):\n            info_idx = [info_idx]\n        labels = item_labels[info_idx]\n\n        # if we have a partial multiindex, then need to adjust the plane\n        # indexer here\n        if len(labels) == 1 and isinstance(self.obj[labels[0]].axes[0], MultiIndex):\n            item = labels[0]\n            obj = self.obj[item]\n            index = obj.index\n            idx = indexer[:info_axis][0]\n\n            plane_indexer = tuple([idx]) + indexer[info_axis + 1 :]\n            lplane_indexer = length_of_indexer(plane_indexer[0], index)\n\n            # require that we are setting the right number of values that\n            # we are indexing\n            if (\n                is_list_like_indexer(value)\n                and np.iterable(value)\n                and lplane_indexer != len(value)\n            ):\n\n                if len(obj[idx]) != len(value):\n                    raise ValueError(\n                        \"cannot set using a multi-index \"\n                        \"selection indexer with a different \"\n                        \"length than the value\"\n                    )\n\n                # make sure we have an ndarray\n                value = getattr(value, \"values\", value).ravel()\n\n                # we can directly set the series here\n                # as we select a slice indexer on the mi\n                idx = index._convert_slice_indexer(idx)\n                obj._consolidate_inplace()\n                obj = obj.copy()\n                obj._data = obj._data.setitem(indexer=tuple([idx]), value=value)\n                self.obj[item] = obj\n                return\n\n        # non-mi\n        else:\n            plane_indexer = indexer[:info_axis] + indexer[info_axis + 1 :]\n            plane_axis = self.obj.axes[:info_axis][0]\n            lplane_indexer = length_of_indexer(plane_indexer[0], plane_axis)\n\n        def setter(item, v):\n            s = self.obj[item]\n            pi = plane_indexer[0] if lplane_indexer == 1 else plane_indexer\n\n            # perform the equivalent of a setitem on the info axis\n            # as we have a null slice or a slice with full bounds\n            # which means essentially reassign to the columns of a\n            # multi-dim object\n            # GH6149 (null slice), GH10408 (full bounds)\n            if isinstance(pi, tuple) and all(\n                com.is_null_slice(idx) or com.is_full_slice(idx, len(self.obj))\n                for idx in pi\n            ):\n                s = v\n            else:\n                # set the item, possibly having a dtype change\n                s._consolidate_inplace()\n                s = s.copy()\n                s._data = s._data.setitem(indexer=pi, value=v)\n                s._maybe_update_cacher(clear=True)\n\n            # reset the sliced object if unique\n            self.obj[item] = s\n\n        # we need an iterable, with a ndim of at least 1\n        # eg. don't pass through np.array(0)\n        if is_list_like_indexer(value) and getattr(value, \"ndim\", 1) > 0:\n\n            # we have an equal len Frame\n            if isinstance(value, ABCDataFrame):\n                sub_indexer = list(indexer)\n                multiindex_indexer = isinstance(labels, MultiIndex)\n\n                for item in labels:\n                    if item in value:\n                        sub_indexer[info_axis] = item\n                        v = self._align_series(\n                            tuple(sub_indexer), value[item], multiindex_indexer\n                        )\n                    else:\n                        v = np.nan\n\n                    setter(item, v)\n\n            # we have an equal len ndarray/convertible to our labels\n            # hasattr first, to avoid coercing to ndarray without reason.\n            # But we may be relying on the ndarray coercion to check ndim.\n            # Why not just convert to an ndarray earlier on if needed?\n            elif np.ndim(value) == 2:\n\n                # note that this coerces the dtype if we are mixed\n                # GH 7551\n                value = np.array(value, dtype=object)\n                if len(labels) != value.shape[1]:\n                    raise ValueError(\n                        \"Must have equal len keys and value \"\n                        \"when setting with an ndarray\"\n                    )\n\n                for i, item in enumerate(labels):\n\n                    # setting with a list, recoerces\n                    setter(item, value[:, i].tolist())\n\n            # we have an equal len list/ndarray\n            elif _can_do_equal_len(\n                labels, value, plane_indexer, lplane_indexer, self.obj\n            ):\n                setter(labels[0], value)\n\n            # per label values\n            else:\n\n                if len(labels) != len(value):\n                    raise ValueError(\n                        \"Must have equal len keys and value \"\n                        \"when setting with an iterable\"\n                    )\n\n                for item, v in zip(labels, value):\n                    setter(item, v)\n        else:\n\n            # scalar\n            for item in labels:\n                setter(item, value)\n\n    else:\n        if isinstance(indexer, tuple):\n            indexer = maybe_convert_ix(*indexer)\n\n            # if we are setting on the info axis ONLY\n            # set using those methods to avoid block-splitting\n            # logic here\n            if (\n                len(indexer) > info_axis\n                and is_integer(indexer[info_axis])\n                and all(\n                    com.is_null_slice(idx)\n                    for i, idx in enumerate(indexer)\n                    if i != info_axis\n                )\n                and item_labels.is_unique\n            ):\n                self.obj[item_labels[indexer[info_axis]]] = value\n                return\n\n        if isinstance(value, (ABCSeries, dict)):\n            # TODO(EA): ExtensionBlock.setitem this causes issues with\n            # setting for extensionarrays that store dicts. Need to decide\n            # if it's worth supporting that.\n            value = self._align_series(indexer, Series(value))\n\n        elif isinstance(value, ABCDataFrame):\n            value = self._align_frame(indexer, value)\n\n        # check for chained assignment\n        self.obj._check_is_chained_assignment_possible()\n\n        # actually do the set\n        self.obj._consolidate_inplace()\n        self.obj._data = self.obj._data.setitem(indexer=indexer, value=value)\n        self.obj._maybe_update_cacher(clear=True)",
                "def _setitem_with_indexer_missing(self, indexer, value):\n    \"\"\"\n    Insert new row(s) or column(s) into the Series or DataFrame.\n    \"\"\"\n    from pandas import Series\n\n    # reindex the axis to the new value\n    # and set inplace\n    if self.ndim == 1:\n        index = self.obj.index\n        new_index = index.insert(len(index), indexer)\n\n        # we have a coerced indexer, e.g. a float\n        # that matches in an Int64Index, so\n        # we will not create a duplicate index, rather\n        # index to that element\n        # e.g. 0.0 -> 0\n        # GH#12246\n        if index.is_unique:\n            new_indexer = index.get_indexer([new_index[-1]])\n            if (new_indexer != -1).any():\n                return self._setitem_with_indexer(new_indexer, value)\n\n        # this preserves dtype of the value\n        new_values = Series([value])._values\n        if len(self.obj._values):\n            # GH#22717 handle casting compatibility that np.concatenate\n            #  does incorrectly\n            new_values = concat_compat([self.obj._values, new_values])\n        self.obj._data = self.obj._constructor(\n            new_values, index=new_index, name=self.obj.name\n        )._data\n        self.obj._maybe_update_cacher(clear=True)\n        return self.obj\n\n    elif self.ndim == 2:\n\n        if not len(self.obj.columns):\n            # no columns and scalar\n            raise ValueError(\"cannot set a frame with no defined columns\")\n\n        if isinstance(value, ABCSeries):\n            # append a Series\n            value = value.reindex(index=self.obj.columns, copy=True)\n            value.name = indexer\n\n        else:\n            # a list-list\n            if is_list_like_indexer(value):\n                # must have conforming columns\n                if len(value) != len(self.obj.columns):\n                    raise ValueError(\"cannot set a row with mismatched columns\")\n\n            value = Series(value, index=self.obj.columns, name=indexer)\n\n        self.obj._data = self.obj.append(value)._data\n        self.obj._maybe_update_cacher(clear=True)\n        return self.obj",
                "def _align_series(self, indexer, ser: ABCSeries, multiindex_indexer: bool = False):\n    \"\"\"\n    Parameters\n    ----------\n    indexer : tuple, slice, scalar\n        The indexer used to get the locations that will be set to\n        `ser`\n    ser : pd.Series\n        The values to assign to the locations specified by `indexer`\n    multiindex_indexer : boolean, optional\n        Defaults to False. Should be set to True if `indexer` was from\n        a `pd.MultiIndex`, to avoid unnecessary broadcasting.\n\n    Returns\n    -------\n    `np.array` of `ser` broadcast to the appropriate shape for assignment\n    to the locations selected by `indexer`\n    \"\"\"\n    if isinstance(indexer, (slice, np.ndarray, list, Index)):\n        indexer = tuple([indexer])\n\n    if isinstance(indexer, tuple):\n\n        # flatten np.ndarray indexers\n        def ravel(i):\n            return i.ravel() if isinstance(i, np.ndarray) else i\n\n        indexer = tuple(map(ravel, indexer))\n\n        aligners = [not com.is_null_slice(idx) for idx in indexer]\n        sum_aligners = sum(aligners)\n        single_aligner = sum_aligners == 1\n        is_frame = self.ndim == 2\n        obj = self.obj\n\n        # are we a single alignable value on a non-primary\n        # dim (e.g. panel: 1,2, or frame: 0) ?\n        # hence need to align to a single axis dimension\n        # rather that find all valid dims\n\n        # frame\n        if is_frame:\n            single_aligner = single_aligner and aligners[0]\n\n        # we have a frame, with multiple indexers on both axes; and a\n        # series, so need to broadcast (see GH5206)\n        if sum_aligners == self.ndim and all(is_sequence(_) for _ in indexer):\n            ser = ser.reindex(obj.axes[0][indexer[0]], copy=True)._values\n\n            # single indexer\n            if len(indexer) > 1 and not multiindex_indexer:\n                len_indexer = len(indexer[1])\n                ser = np.tile(ser, len_indexer).reshape(len_indexer, -1).T\n\n            return ser\n\n        for i, idx in enumerate(indexer):\n            ax = obj.axes[i]\n\n            # multiple aligners (or null slices)\n            if is_sequence(idx) or isinstance(idx, slice):\n                if single_aligner and com.is_null_slice(idx):\n                    continue\n                new_ix = ax[idx]\n                if not is_list_like_indexer(new_ix):\n                    new_ix = Index([new_ix])\n                else:\n                    new_ix = Index(new_ix)\n                if ser.index.equals(new_ix) or not len(new_ix):\n                    return ser._values.copy()\n\n                return ser.reindex(new_ix)._values\n\n            # 2 dims\n            elif single_aligner:\n\n                # reindex along index\n                ax = self.obj.axes[1]\n                if ser.index.equals(ax) or not len(ax):\n                    return ser._values.copy()\n                return ser.reindex(ax)._values\n\n    elif is_scalar(indexer):\n        ax = self.obj._get_axis(1)\n\n        if ser.index.equals(ax):\n            return ser._values.copy()\n\n        return ser.reindex(ax)._values\n\n    raise ValueError(\"Incompatible indexer with Series\")",
                "def _align_frame(self, indexer, df: ABCDataFrame):\n    is_frame = self.ndim == 2\n\n    if isinstance(indexer, tuple):\n\n        idx, cols = None, None\n        sindexers = []\n        for i, ix in enumerate(indexer):\n            ax = self.obj.axes[i]\n            if is_sequence(ix) or isinstance(ix, slice):\n                if isinstance(ix, np.ndarray):\n                    ix = ix.ravel()\n                if idx is None:\n                    idx = ax[ix]\n                elif cols is None:\n                    cols = ax[ix]\n                else:\n                    break\n            else:\n                sindexers.append(i)\n\n        if idx is not None and cols is not None:\n\n            if df.index.equals(idx) and df.columns.equals(cols):\n                val = df.copy()._values\n            else:\n                val = df.reindex(idx, columns=cols)._values\n            return val\n\n    elif (isinstance(indexer, slice) or is_list_like_indexer(indexer)) and is_frame:\n        ax = self.obj.index[indexer]\n        if df.index.equals(ax):\n            val = df.copy()._values\n        else:\n\n            # we have a multi-index and are trying to align\n            # with a particular, level GH3738\n            if (\n                isinstance(ax, MultiIndex)\n                and isinstance(df.index, MultiIndex)\n                and ax.nlevels != df.index.nlevels\n            ):\n                raise TypeError(\n                    \"cannot align on a multi-index with out \"\n                    \"specifying the join levels\"\n                )\n\n            val = df.reindex(index=ax)._values\n        return val\n\n    raise ValueError(\"Incompatible indexer with DataFrame\")",
                "def _getitem_tuple(self, tup: Tuple):\n    try:\n        return self._getitem_lowerdim(tup)\n    except IndexingError:\n        pass\n\n    # no multi-index, so validate all of the indexers\n    self._has_valid_tuple(tup)\n\n    # ugly hack for GH #836\n    if self._multi_take_opportunity(tup):\n        return self._multi_take(tup)\n\n    # no shortcut needed\n    retval = self.obj\n    for i, key in enumerate(tup):\n        if com.is_null_slice(key):\n            continue\n\n        retval = getattr(retval, self.name)._getitem_axis(key, axis=i)\n\n    return retval",
                "def _multi_take_opportunity(self, tup: Tuple):\n    \"\"\"\n    Check whether there is the possibility to use ``_multi_take``.\n    Currently the limit is that all axes being indexed must be indexed with\n    list-likes.\n\n    Parameters\n    ----------\n    tup : tuple\n        Tuple of indexers, one per axis\n\n    Returns\n    -------\n    boolean: Whether the current indexing can be passed through _multi_take\n    \"\"\"\n    if not all(is_list_like_indexer(x) for x in tup):\n        return False\n\n    # just too complicated\n    if any(com.is_bool_indexer(x) for x in tup):\n        return False\n\n    return True",
                "def _multi_take(self, tup: Tuple):\n    \"\"\"\n    Create the indexers for the passed tuple of keys, and execute the take\n    operation. This allows the take operation to be executed all at once -\n    rather than once for each dimension - improving efficiency.\n\n    Parameters\n    ----------\n    tup : tuple\n        Tuple of indexers, one per axis\n\n    Returns\n    -------\n    values: same type as the object being indexed\n    \"\"\"\n    # GH 836\n    o = self.obj\n    d = {\n        axis: self._get_listlike_indexer(key, axis)\n        for (key, axis) in zip(tup, o._AXIS_ORDERS)\n    }\n    return o._reindex_with_indexers(d, copy=True, allow_dups=True)",
                "def _convert_for_reindex(self, key, axis: int):\n    return key",
                "def _handle_lowerdim_multi_index_axis0(self, tup: Tuple):\n    # we have an axis0 multi-index, handle or raise\n    axis = self.axis or 0\n    try:\n        # fast path for series or for tup devoid of slices\n        return self._get_label(tup, axis=axis)\n    except TypeError:\n        # slices are unhashable\n        pass\n    except KeyError as ek:\n        # raise KeyError if number of indexers match\n        # else IndexingError will be raised\n        if len(tup) <= self.obj.index.nlevels and len(tup) > self.ndim:\n            raise ek\n    except Exception as e1:\n        if isinstance(tup[0], (slice, Index)):\n            raise IndexingError(\"Handle elsewhere\")\n\n        # raise the error if we are not sorted\n        ax0 = self.obj._get_axis(0)\n        if not ax0.is_lexsorted_for_tuple(tup):\n            raise e1\n\n    return None",
                "def _getitem_lowerdim(self, tup: Tuple):\n\n    # we can directly get the axis result since the axis is specified\n    if self.axis is not None:\n        axis = self.obj._get_axis_number(self.axis)\n        return self._getitem_axis(tup, axis=axis)\n\n    # we may have a nested tuples indexer here\n    if self._is_nested_tuple_indexer(tup):\n        return self._getitem_nested_tuple(tup)\n\n    # we maybe be using a tuple to represent multiple dimensions here\n    ax0 = self.obj._get_axis(0)\n    # ...but iloc should handle the tuple as simple integer-location\n    # instead of checking it as multiindex representation (GH 13797)\n    if isinstance(ax0, MultiIndex) and self.name != \"iloc\":\n        result = self._handle_lowerdim_multi_index_axis0(tup)\n        if result is not None:\n            return result\n\n    if len(tup) > self.ndim:\n        raise IndexingError(\"Too many indexers. handle elsewhere\")\n\n    # to avoid wasted computation\n    # df.ix[d1:d2, 0] -> columns first (True)\n    # df.ix[0, ['C', 'B', A']] -> rows first (False)\n    for i, key in enumerate(tup):\n        if is_label_like(key) or isinstance(key, tuple):\n            section = self._getitem_axis(key, axis=i)\n\n            # we have yielded a scalar ?\n            if not is_list_like_indexer(section):\n                return section\n\n            elif section.ndim == self.ndim:\n                # we're in the middle of slicing through a MultiIndex\n                # revise the key wrt to `section` by inserting an _NS\n                new_key = tup[:i] + (_NS,) + tup[i + 1 :]\n\n            else:\n                new_key = tup[:i] + tup[i + 1 :]\n\n                # unfortunately need an odious kludge here because of\n                # DataFrame transposing convention\n                if (\n                    isinstance(section, ABCDataFrame)\n                    and i > 0\n                    and len(new_key) == 2\n                ):\n                    a, b = new_key\n                    new_key = b, a\n\n                if len(new_key) == 1:\n                    new_key = new_key[0]\n\n            # Slices should return views, but calling iloc/loc with a null\n            # slice returns a new object.\n            if com.is_null_slice(new_key):\n                return section\n            # This is an elided recursive call to iloc/loc/etc'\n            return getattr(section, self.name)[new_key]\n\n    raise IndexingError(\"not applicable\")",
                "def _getitem_nested_tuple(self, tup: Tuple):\n    # we have a nested tuple so have at least 1 multi-index level\n    # we should be able to match up the dimensionality here\n\n    # we have too many indexers for our dim, but have at least 1\n    # multi-index dimension, try to see if we have something like\n    # a tuple passed to a series with a multi-index\n    if len(tup) > self.ndim:\n        result = self._handle_lowerdim_multi_index_axis0(tup)\n        if result is not None:\n            return result\n\n        # this is a series with a multi-index specified a tuple of\n        # selectors\n        axis = self.axis or 0\n        return self._getitem_axis(tup, axis=axis)\n\n    # handle the multi-axis by taking sections and reducing\n    # this is iterative\n    obj = self.obj\n    axis = 0\n    for i, key in enumerate(tup):\n\n        if com.is_null_slice(key):\n            axis += 1\n            continue\n\n        current_ndim = obj.ndim\n        obj = getattr(obj, self.name)._getitem_axis(key, axis=axis)\n        axis += 1\n\n        # if we have a scalar, we are done\n        if is_scalar(obj) or not hasattr(obj, \"ndim\"):\n            break\n\n        # has the dim of the obj changed?\n        # GH 7199\n        if obj.ndim < current_ndim:\n            axis -= 1\n\n    return obj",
                "def _getitem_axis(self, key, axis: int):\n    if is_iterator(key):\n        key = list(key)\n    self._validate_key(key, axis)\n\n    labels = self.obj._get_axis(axis)\n    if isinstance(key, slice):\n        return self._get_slice_axis(key, axis=axis)\n    elif is_list_like_indexer(key) and not (\n        isinstance(key, tuple) and isinstance(labels, MultiIndex)\n    ):\n\n        if hasattr(key, \"ndim\") and key.ndim > 1:\n            raise ValueError(\"Cannot index with multidimensional key\")\n\n        return self._getitem_iterable(key, axis=axis)\n    else:\n\n        # maybe coerce a float scalar to integer\n        key = labels._maybe_cast_indexer(key)\n\n        if is_integer(key):\n            if axis == 0 and isinstance(labels, MultiIndex):\n                try:\n                    return self._get_label(key, axis=axis)\n                except (KeyError, TypeError):\n                    if self.obj.index.levels[0].is_integer():\n                        raise\n\n            # this is the fallback! (for a non-float, non-integer index)\n            if not labels.is_floating() and not labels.is_integer():\n                return self._get_loc(key, axis=axis)\n\n        return self._get_label(key, axis=axis)",
                "def _get_listlike_indexer(self, key, axis: int, raise_missing: bool = False):\n    \"\"\"\n    Transform a list-like of keys into a new index and an indexer.\n\n    Parameters\n    ----------\n    key : list-like\n        Target labels\n    axis: int\n        Dimension on which the indexing is being made\n    raise_missing: bool\n        Whether to raise a KeyError if some labels are not found. Will be\n        removed in the future, and then this method will always behave as\n        if raise_missing=True.\n\n    Raises\n    ------\n    KeyError\n        If at least one key was requested but none was found, and\n        raise_missing=True.\n\n    Returns\n    -------\n    keyarr: Index\n        New index (coinciding with 'key' if the axis is unique)\n    values : array-like\n        An indexer for the return object; -1 denotes keys not found\n    \"\"\"\n    o = self.obj\n    ax = o._get_axis(axis)\n\n    # Have the index compute an indexer or return None\n    # if it cannot handle:\n    indexer, keyarr = ax._convert_listlike_indexer(key, kind=self.name)\n    # We only act on all found values:\n    if indexer is not None and (indexer != -1).all():\n        self._validate_read_indexer(key, indexer, axis, raise_missing=raise_missing)\n        return ax[indexer], indexer\n\n    if ax.is_unique and not getattr(ax, \"is_overlapping\", False):\n        # If we are trying to get actual keys from empty Series, we\n        # patiently wait for a KeyError later on - otherwise, convert\n        if len(ax) or not len(key):\n            key = self._convert_for_reindex(key, axis)\n        indexer = ax.get_indexer_for(key)\n        keyarr = ax.reindex(keyarr)[0]\n    else:\n        keyarr, indexer, new_indexer = ax._reindex_non_unique(keyarr)\n\n    self._validate_read_indexer(\n        keyarr, indexer, o._get_axis_number(axis), raise_missing=raise_missing\n    )\n    return keyarr, indexer",
                "def _getitem_iterable(self, key, axis: int):\n    \"\"\"\n    Index current object with an an iterable key (which can be a boolean\n    indexer, or a collection of keys).\n\n    Parameters\n    ----------\n    key : iterable\n        Target labels, or boolean indexer\n    axis: int\n        Dimension on which the indexing is being made\n\n    Raises\n    ------\n    KeyError\n        If no key was found. Will change in the future to raise if not all\n        keys were found.\n    IndexingError\n        If the boolean indexer is unalignable with the object being\n        indexed.\n\n    Returns\n    -------\n    scalar, DataFrame, or Series: indexed value(s),\n    \"\"\"\n    # caller is responsible for ensuring non-None axis\n    self._validate_key(key, axis)\n\n    labels = self.obj._get_axis(axis)\n\n    if com.is_bool_indexer(key):\n        # A boolean indexer\n        key = check_bool_indexer(labels, key)\n        inds, = key.nonzero()\n        return self.obj.take(inds, axis=axis)\n    else:\n        # A collection of keys\n        keyarr, indexer = self._get_listlike_indexer(key, axis, raise_missing=False)\n        return self.obj._reindex_with_indexers(\n            {axis: [keyarr, indexer]}, copy=True, allow_dups=True\n        )",
                "def _validate_read_indexer(\n    self, key, indexer, axis: int, raise_missing: bool = False\n):\n    \"\"\"\n    Check that indexer can be used to return a result (e.g. at least one\n    element was found, unless the list of keys was actually empty).\n\n    Parameters\n    ----------\n    key : list-like\n        Target labels (only used to show correct error message)\n    indexer: array-like of booleans\n        Indices corresponding to the key (with -1 indicating not found)\n    axis: int\n        Dimension on which the indexing is being made\n    raise_missing: bool\n        Whether to raise a KeyError if some labels are not found. Will be\n        removed in the future, and then this method will always behave as\n        if raise_missing=True.\n\n    Raises\n    ------\n    KeyError\n        If at least one key was requested but none was found, and\n        raise_missing=True.\n    \"\"\"\n\n    ax = self.obj._get_axis(axis)\n\n    if len(key) == 0:\n        return\n\n    # Count missing values:\n    missing = (indexer < 0).sum()\n\n    if missing:\n        if missing == len(indexer):\n            raise KeyError(\n                \"None of [{key}] are in the [{axis}]\".format(\n                    key=key, axis=self.obj._get_axis_name(axis)\n                )\n            )\n\n        # We (temporarily) allow for some missing keys with .loc, except in\n        # some cases (e.g. setting) in which \"raise_missing\" will be False\n        if not (self.name == \"loc\" and not raise_missing):\n            not_found = list(set(key) - set(ax))\n            raise KeyError(\"{} not in index\".format(not_found))\n\n        # we skip the warning on Categorical/Interval\n        # as this check is actually done (check for\n        # non-missing values), but a bit later in the\n        # code, so we want to avoid warning & then\n        # just raising\n\n        _missing_key_warning = textwrap.dedent(\n            \"\"\"\n        Passing list-likes to .loc or [] with any missing label will raise\n        KeyError in the future, you can use .reindex() as an alternative.\n\n        See the documentation here:\n        https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#deprecate-loc-reindex-listlike\"\"\"  # noqa: E501\n        )\n\n        if not (ax.is_categorical() or ax.is_interval()):\n            warnings.warn(_missing_key_warning, FutureWarning, stacklevel=6)",
                "def _convert_to_indexer(self, obj, axis: int, raise_missing: bool = False):\n    \"\"\"\n    Convert indexing key into something we can use to do actual fancy\n    indexing on an ndarray\n\n    Examples\n    ix[:5] -> slice(0, 5)\n    ix[[1,2,3]] -> [1,2,3]\n    ix[['foo', 'bar', 'baz']] -> [i, j, k] (indices of foo, bar, baz)\n\n    Going by Zen of Python?\n    'In the face of ambiguity, refuse the temptation to guess.'\n    raise AmbiguousIndexError with integer labels?\n    - No, prefer label-based indexing\n    \"\"\"\n    labels = self.obj._get_axis(axis)\n\n    if isinstance(obj, slice):\n        return self._convert_slice_indexer(obj, axis)\n\n    # try to find out correct indexer, if not type correct raise\n    try:\n        obj = self._convert_scalar_indexer(obj, axis)\n    except TypeError:\n        # but we will allow setting\n        pass\n\n    # see if we are positional in nature\n    is_int_index = labels.is_integer()\n    is_int_positional = is_integer(obj) and not is_int_index\n\n    # if we are a label return me\n    try:\n        return labels.get_loc(obj)\n    except LookupError:\n        if isinstance(obj, tuple) and isinstance(labels, MultiIndex):\n            if len(obj) == labels.nlevels:\n                return {\"key\": obj}\n            raise\n    except TypeError:\n        pass\n    except ValueError:\n        if not is_int_positional:\n            raise\n\n    # a positional\n    if is_int_positional:\n\n        # if we are setting and its not a valid location\n        # its an insert which fails by definition\n\n        if self.name == \"loc\":\n            # always valid\n            return {\"key\": obj}\n\n        if obj >= self.obj.shape[axis] and not isinstance(labels, MultiIndex):\n            # a positional\n            raise ValueError(\"cannot set by positional indexing with enlargement\")\n\n        return obj\n\n    if is_nested_tuple(obj, labels):\n        return labels.get_locs(obj)\n\n    elif is_list_like_indexer(obj):\n\n        if com.is_bool_indexer(obj):\n            obj = check_bool_indexer(labels, obj)\n            inds, = obj.nonzero()\n            return inds\n        else:\n            # When setting, missing keys are not allowed, even with .loc:\n            return self._get_listlike_indexer(obj, axis, raise_missing=True)[1]\n    else:\n        try:\n            return labels.get_loc(obj)\n        except LookupError:\n            # allow a not found key only if we are a setter\n            if not is_list_like_indexer(obj):\n                return {\"key\": obj}\n            raise",
                "def _get_slice_axis(self, slice_obj: slice, axis: int):\n    # caller is responsible for ensuring non-None axis\n    obj = self.obj\n\n    if not need_slice(slice_obj):\n        return obj.copy(deep=False)\n\n    indexer = self._convert_slice_indexer(slice_obj, axis)\n    return self._slice(indexer, axis=axis, kind=\"iloc\")",
                "def __init__(self, name, obj):\n    warnings.warn(self._ix_deprecation_warning, FutureWarning, stacklevel=2)\n    super().__init__(name, obj)",
                "@Appender(_NDFrameIndexer._validate_key.__doc__)\ndef _validate_key(self, key, axis: int):\n    if isinstance(key, slice):\n        return True\n\n    elif com.is_bool_indexer(key):\n        return True\n\n    elif is_list_like_indexer(key):\n        return True\n\n    else:\n\n        self._convert_scalar_indexer(key, axis)\n\n    return True",
                "def _convert_for_reindex(self, key, axis: int):\n    \"\"\"\n    Transform a list of keys into a new array ready to be used as axis of\n    the object we return (e.g. including NaNs).\n\n    Parameters\n    ----------\n    key : list-like\n        Target labels\n    axis: int\n        Where the indexing is being made\n\n    Returns\n    -------\n    list-like of labels\n    \"\"\"\n    labels = self.obj._get_axis(axis)\n\n    if com.is_bool_indexer(key):\n        key = check_bool_indexer(labels, key)\n        return labels[key]\n\n    if isinstance(key, Index):\n        keyarr = labels._convert_index_indexer(key)\n    else:\n        # asarray can be unsafe, NumPy strings are weird\n        keyarr = com.asarray_tuplesafe(key)\n\n    if is_integer_dtype(keyarr):\n        # Cast the indexer to uint64 if possible so\n        # that the values returned from indexing are\n        # also uint64.\n        keyarr = labels._convert_arr_indexer(keyarr)\n\n        if not labels.is_integer():\n            keyarr = ensure_platform_int(keyarr)\n            return labels.take(keyarr)\n\n    return keyarr",
                "def __getitem__(self, key):\n    if type(key) is tuple:\n        key = tuple(com.apply_if_callable(x, self.obj) for x in key)\n        if self._is_scalar_access(key):\n            try:\n                return self._getitem_scalar(key)\n            except (KeyError, IndexError, AttributeError):\n                pass\n        return self._getitem_tuple(key)\n    else:\n        # we by definition only have the 0th axis\n        axis = self.axis or 0\n\n        maybe_callable = com.apply_if_callable(key, self.obj)\n        return self._getitem_axis(maybe_callable, axis=axis)",
                "def _is_scalar_access(self, key: Tuple):\n    raise NotImplementedError()",
                "def _getitem_scalar(self, key):\n    raise NotImplementedError()",
                "def _getitem_axis(self, key, axis: int):\n    raise NotImplementedError()",
                "def _getbool_axis(self, key, axis: int):\n    # caller is responsible for ensuring non-None axis\n    labels = self.obj._get_axis(axis)\n    key = check_bool_indexer(labels, key)\n    inds = key.nonzero()[0]\n    try:\n        return self.obj.take(inds, axis=axis)\n    except Exception as detail:\n        raise self._exception(detail)",
                "def _get_slice_axis(self, slice_obj: slice, axis: int):\n    \"\"\" this is pretty simple as we just have to deal with labels \"\"\"\n    # caller is responsible for ensuring non-None axis\n    obj = self.obj\n    if not need_slice(slice_obj):\n        return obj.copy(deep=False)\n\n    labels = obj._get_axis(axis)\n    indexer = labels.slice_indexer(\n        slice_obj.start, slice_obj.stop, slice_obj.step, kind=self.name\n    )\n\n    if isinstance(indexer, slice):\n        return self._slice(indexer, axis=axis, kind=\"iloc\")\n    else:\n        # DatetimeIndex overrides Index.slice_indexer and may\n        #  return a DatetimeIndex instead of a slice object.\n        return self.obj.take(indexer, axis=axis)",
                "@Appender(_NDFrameIndexer._validate_key.__doc__)\ndef _validate_key(self, key, axis: int):\n\n    # valid for a collection of labels (we check their presence later)\n    # slice of labels (where start-end in labels)\n    # slice of integers (only if in the labels)\n    # boolean\n\n    if isinstance(key, slice):\n        return\n\n    if com.is_bool_indexer(key):\n        return\n\n    if not is_list_like_indexer(key):\n        self._convert_scalar_indexer(key, axis)",
                "def _is_scalar_access(self, key: Tuple):\n    # this is a shortcut accessor to both .loc and .iloc\n    # that provide the equivalent access of .at and .iat\n    # a) avoid getting things via sections and (to minimize dtype changes)\n    # b) provide a performant path\n    if len(key) != self.ndim:\n        return False\n\n    for i, k in enumerate(key):\n        if not is_scalar(k):\n            return False\n\n        ax = self.obj.axes[i]\n        if isinstance(ax, MultiIndex):\n            return False\n\n        if not ax.is_unique:\n            return False\n\n    return True",
                "def _getitem_scalar(self, key):\n    # a fast-path to scalar access\n    # if not, raise\n    values = self.obj._get_value(*key)\n    return values",
                "def _get_partial_string_timestamp_match_key(self, key, labels):\n    \"\"\"Translate any partial string timestamp matches in key, returning the\n    new key (GH 10331)\"\"\"\n    if isinstance(labels, MultiIndex):\n        if isinstance(key, str) and labels.levels[0].is_all_dates:\n            # Convert key '2016-01-01' to\n            # ('2016-01-01'[, slice(None, None, None)]+)\n            key = tuple([key] + [slice(None)] * (len(labels.levels) - 1))\n\n        if isinstance(key, tuple):\n            # Convert (..., '2016-01-01', ...) in tuple to\n            # (..., slice('2016-01-01', '2016-01-01', None), ...)\n            new_key = []\n            for i, component in enumerate(key):\n                if isinstance(component, str) and labels.levels[i].is_all_dates:\n                    new_key.append(slice(component, component, None))\n                else:\n                    new_key.append(component)\n            key = tuple(new_key)\n\n    return key",
                "def _getitem_axis(self, key, axis: int):\n    key = item_from_zerodim(key)\n    if is_iterator(key):\n        key = list(key)\n\n    labels = self.obj._get_axis(axis)\n    key = self._get_partial_string_timestamp_match_key(key, labels)\n\n    if isinstance(key, slice):\n        self._validate_key(key, axis)\n        return self._get_slice_axis(key, axis=axis)\n    elif com.is_bool_indexer(key):\n        return self._getbool_axis(key, axis=axis)\n    elif is_list_like_indexer(key):\n\n        # convert various list-like indexers\n        # to a list of keys\n        # we will use the *values* of the object\n        # and NOT the index if its a PandasObject\n        if isinstance(labels, MultiIndex):\n\n            if isinstance(key, (ABCSeries, np.ndarray)) and key.ndim <= 1:\n                # Series, or 0,1 ndim ndarray\n                # GH 14730\n                key = list(key)\n            elif isinstance(key, ABCDataFrame):\n                # GH 15438\n                raise NotImplementedError(\n                    \"Indexing a MultiIndex with a \"\n                    \"DataFrame key is not \"\n                    \"implemented\"\n                )\n            elif hasattr(key, \"ndim\") and key.ndim > 1:\n                raise NotImplementedError(\n                    \"Indexing a MultiIndex with a \"\n                    \"multidimensional key is not \"\n                    \"implemented\"\n                )\n\n            if (\n                not isinstance(key, tuple)\n                and len(key)\n                and not isinstance(key[0], tuple)\n            ):\n                key = tuple([key])\n\n        # an iterable multi-selection\n        if not (isinstance(key, tuple) and isinstance(labels, MultiIndex)):\n\n            if hasattr(key, \"ndim\") and key.ndim > 1:\n                raise ValueError(\"Cannot index with multidimensional key\")\n\n            return self._getitem_iterable(key, axis=axis)\n\n        # nested tuple slicing\n        if is_nested_tuple(key, labels):\n            locs = labels.get_locs(key)\n            indexer = [slice(None)] * self.ndim\n            indexer[axis] = locs\n            return self.obj.iloc[tuple(indexer)]\n\n    # fall thru to straight lookup\n    self._validate_key(key, axis)\n    return self._get_label(key, axis=axis)",
                "def _validate_key(self, key, axis: int):\n    if com.is_bool_indexer(key):\n        if hasattr(key, \"index\") and isinstance(key.index, Index):\n            if key.index.inferred_type == \"integer\":\n                raise NotImplementedError(\n                    \"iLocation based boolean \"\n                    \"indexing on an integer type \"\n                    \"is not available\"\n                )\n            raise ValueError(\n                \"iLocation based boolean indexing cannot use \"\n                \"an indexable as a mask\"\n            )\n        return\n\n    if isinstance(key, slice):\n        return\n    elif is_integer(key):\n        self._validate_integer(key, axis)\n    elif isinstance(key, tuple):\n        # a tuple should already have been caught by this point\n        # so don't treat a tuple as a valid indexer\n        raise IndexingError(\"Too many indexers\")\n    elif is_list_like_indexer(key):\n        arr = np.array(key)\n        len_axis = len(self.obj._get_axis(axis))\n\n        # check that the key has a numeric dtype\n        if not is_numeric_dtype(arr.dtype):\n            raise IndexError(\n                \".iloc requires numeric indexers, got {arr}\".format(arr=arr)\n            )\n\n        # check that the key does not exceed the maximum size of the index\n        if len(arr) and (arr.max() >= len_axis or arr.min() < -len_axis):\n            raise IndexError(\"positional indexers are out-of-bounds\")\n    else:\n        raise ValueError(\n            \"Can only index by location with \"\n            \"a [{types}]\".format(types=self._valid_types)\n        )",
                "def _has_valid_setitem_indexer(self, indexer):\n    self._has_valid_positional_setitem_indexer(indexer)",
                "def _is_scalar_access(self, key: Tuple):\n    # this is a shortcut accessor to both .loc and .iloc\n    # that provide the equivalent access of .at and .iat\n    # a) avoid getting things via sections and (to minimize dtype changes)\n    # b) provide a performant path\n    if len(key) != self.ndim:\n        return False\n\n    for i, k in enumerate(key):\n        if not is_integer(k):\n            return False\n\n        ax = self.obj.axes[i]\n        if not ax.is_unique:\n            return False\n\n    return True",
                "def _getitem_scalar(self, key):\n    # a fast-path to scalar access\n    # if not, raise\n    values = self.obj._get_value(*key, takeable=True)\n    return values",
                "def _validate_integer(self, key: int, axis: int):\n    \"\"\"\n    Check that 'key' is a valid position in the desired axis.\n\n    Parameters\n    ----------\n    key : int\n        Requested position\n    axis : int\n        Desired axis\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    IndexError\n        If 'key' is not a valid position in axis 'axis'\n    \"\"\"\n\n    len_axis = len(self.obj._get_axis(axis))\n    if key >= len_axis or key < -len_axis:\n        raise IndexError(\"single positional indexer is out-of-bounds\")",
                "def _getitem_tuple(self, tup: Tuple):\n\n    self._has_valid_tuple(tup)\n    try:\n        return self._getitem_lowerdim(tup)\n    except IndexingError:\n        pass\n\n    retval = self.obj\n    axis = 0\n    for i, key in enumerate(tup):\n        if com.is_null_slice(key):\n            axis += 1\n            continue\n\n        retval = getattr(retval, self.name)._getitem_axis(key, axis=axis)\n\n        # if the dim was reduced, then pass a lower-dim the next time\n        if retval.ndim < self.ndim:\n            # TODO: this is never reached in tests; can we confirm that\n            #  it is impossible?\n            axis -= 1\n\n        # try to get for the next axis\n        axis += 1\n\n    return retval",
                "def _get_list_axis(self, key, axis: int):\n    \"\"\"\n    Return Series values by list or array of integers\n\n    Parameters\n    ----------\n    key : list-like positional indexer\n    axis : int (can only be zero)\n\n    Returns\n    -------\n    Series object\n    \"\"\"\n    try:\n        return self.obj.take(key, axis=axis)\n    except IndexError:\n        # re-raise with different error message\n        raise IndexError(\"positional indexers are out-of-bounds\")",
                "def _getitem_axis(self, key, axis: int):\n    if isinstance(key, slice):\n        return self._get_slice_axis(key, axis=axis)\n\n    if isinstance(key, list):\n        key = np.asarray(key)\n\n    if com.is_bool_indexer(key):\n        self._validate_key(key, axis)\n        return self._getbool_axis(key, axis=axis)\n\n    # a list of integers\n    elif is_list_like_indexer(key):\n        return self._get_list_axis(key, axis=axis)\n\n    # a single integer\n    else:\n        key = item_from_zerodim(key)\n        if not is_integer(key):\n            raise TypeError(\"Cannot index by location index with a non-integer key\")\n\n        # validate the location\n        self._validate_integer(key, axis)\n\n        return self._get_loc(key, axis=axis)",
                "def _convert_to_indexer(self, obj, axis: int, raise_missing: bool = False):\n    \"\"\" much simpler as we only have to deal with our valid types \"\"\"\n\n    # make need to convert a float key\n    if isinstance(obj, slice):\n        return self._convert_slice_indexer(obj, axis)\n\n    elif is_float(obj):\n        return self._convert_scalar_indexer(obj, axis)\n\n    try:\n        self._validate_key(obj, axis)\n        return obj\n    except ValueError:\n        raise ValueError(\n            \"Can only index by location with \"\n            \"a [{types}]\".format(types=self._valid_types)\n        )",
                "def _convert_key(self, key, is_setter: bool = False):\n    raise AbstractMethodError(self)",
                "def __getitem__(self, key):\n    if not isinstance(key, tuple):\n\n        # we could have a convertible item here (e.g. Timestamp)\n        if not is_list_like_indexer(key):\n            key = tuple([key])\n        else:\n            raise ValueError(\"Invalid call for scalar access (getting)!\")\n\n    key = self._convert_key(key)\n    return self.obj._get_value(*key, takeable=self._takeable)",
                "def __setitem__(self, key, value):\n    if isinstance(key, tuple):\n        key = tuple(com.apply_if_callable(x, self.obj) for x in key)\n    else:\n        # scalar callable may return tuple\n        key = com.apply_if_callable(key, self.obj)\n\n    if not isinstance(key, tuple):\n        key = _tuplify(self.ndim, key)\n    if len(key) != self.ndim:\n        raise ValueError(\"Not enough indexers for scalar access (setting)!\")\n    key = list(self._convert_key(key, is_setter=True))\n    key.append(value)\n    self.obj._set_value(*key, takeable=self._takeable)",
                "def _convert_key(self, key, is_setter: bool = False):\n    \"\"\" require they keys to be the same type as the index (so we don't\n    fallback)\n    \"\"\"\n\n    # allow arbitrary setting\n    if is_setter:\n        return list(key)\n\n    for ax, i in zip(self.obj.axes, key):\n        if ax.is_integer():\n            if not is_integer(i):\n                raise ValueError(\n                    \"At based indexing on an integer index \"\n                    \"can only have integer indexers\"\n                )\n        else:\n            if is_integer(i) and not ax.holds_integer():\n                raise ValueError(\n                    \"At based indexing on an non-integer \"\n                    \"index can only have non-integer \"\n                    \"indexers\"\n                )\n    return key",
                "def _convert_key(self, key, is_setter: bool = False):\n    \"\"\" require integer args (and convert to label arguments) \"\"\"\n    for a, i in zip(self.obj.axes, key):\n        if not is_integer(i):\n            raise ValueError(\"iAt based indexing can only have integer indexers\")\n    return key",
                "def get_indexer(_i, _idx):\n    return axes[_i].get_loc(_idx[\"key\"]) if isinstance(_idx, dict) else _idx",
                "def pred(part):\n    # true when slice does *not* reduce, False when part is a tuple,\n    # i.e. MultiIndex slice\n    return (isinstance(part, slice) or is_list_like(part)) and not isinstance(\n        part, tuple\n    )",
                "def setter(item, v):\n    s = self.obj[item]\n    pi = plane_indexer[0] if lplane_indexer == 1 else plane_indexer\n\n    # perform the equivalent of a setitem on the info axis\n    # as we have a null slice or a slice with full bounds\n    # which means essentially reassign to the columns of a\n    # multi-dim object\n    # GH6149 (null slice), GH10408 (full bounds)\n    if isinstance(pi, tuple) and all(\n        com.is_null_slice(idx) or com.is_full_slice(idx, len(self.obj))\n        for idx in pi\n    ):\n        s = v\n    else:\n        # set the item, possibly having a dtype change\n        s._consolidate_inplace()\n        s = s.copy()\n        s._data = s._data.setitem(indexer=pi, value=v)\n        s._maybe_update_cacher(clear=True)\n\n    # reset the sliced object if unique\n    self.obj[item] = s",
                "def ravel(i):\n    return i.ravel() if isinstance(i, np.ndarray) else i"
            ],
            "inscope_function_signatures": [
                "get_indexers_list()",
                "_tuplify(ndim: int, loc) -> tuple",
                "convert_to_index_sliceable(obj, key)",
                "check_bool_indexer(index: Index, key) -> np.ndarray",
                "convert_missing_indexer(indexer)",
                "convert_from_missing_indexer_tuple(indexer, axes)",
                "maybe_convert_ix(*args)",
                "is_nested_tuple(tup, labels)",
                "is_label_like(key)",
                "need_slice(obj)",
                "_non_reducing_slice(slice_)",
                "_maybe_numeric_slice(df, slice_, include_bool=False)",
                "_can_do_equal_len(labels, value, plane_indexer, lplane_indexer, obj)",
                "__getitem__(self, arg)",
                "__call__(self, axis=None)",
                "__iter__(self)",
                "__getitem__(self, key)",
                "_get_label(self, label, axis: int)",
                "_get_loc(self, key: int, axis: int)",
                "_slice(self, obj, axis: int, kind=None)",
                "_get_setitem_indexer(self, key)",
                "__setitem__(self, key, value)",
                "_validate_key(self, key, axis: int)",
                "_has_valid_tuple(self, key: Tuple)",
                "_is_nested_tuple_indexer(self, tup: Tuple)",
                "_convert_tuple(self, key)",
                "_convert_scalar_indexer(self, key, axis: int)",
                "_convert_slice_indexer(self, key: slice, axis: int)",
                "_has_valid_setitem_indexer(self, indexer)",
                "_has_valid_positional_setitem_indexer(self, indexer)",
                "_setitem_with_indexer(self, indexer, value)",
                "_setitem_with_indexer_missing(self, indexer, value)",
                "_align_series(self, indexer, ser: ABCSeries, multiindex_indexer: bool=False)",
                "_align_frame(self, indexer, df: ABCDataFrame)",
                "_getitem_tuple(self, tup: Tuple)",
                "_multi_take_opportunity(self, tup: Tuple)",
                "_multi_take(self, tup: Tuple)",
                "_convert_for_reindex(self, key, axis: int)",
                "_handle_lowerdim_multi_index_axis0(self, tup: Tuple)",
                "_getitem_lowerdim(self, tup: Tuple)",
                "_getitem_nested_tuple(self, tup: Tuple)",
                "_getitem_axis(self, key, axis: int)",
                "_get_listlike_indexer(self, key, axis: int, raise_missing: bool=False)",
                "_getitem_iterable(self, key, axis: int)",
                "_validate_read_indexer(self, key, indexer, axis: int, raise_missing: bool=False)",
                "_convert_to_indexer(self, obj, axis: int, raise_missing: bool=False)",
                "_get_slice_axis(self, slice_obj: slice, axis: int)",
                "__init__(self, name, obj)",
                "_validate_key(self, key, axis: int)",
                "_convert_for_reindex(self, key, axis: int)",
                "__getitem__(self, key)",
                "_is_scalar_access(self, key: Tuple)",
                "_getitem_scalar(self, key)",
                "_getitem_axis(self, key, axis: int)",
                "_getbool_axis(self, key, axis: int)",
                "_get_slice_axis(self, slice_obj: slice, axis: int)",
                "_validate_key(self, key, axis: int)",
                "_is_scalar_access(self, key: Tuple)",
                "_getitem_scalar(self, key)",
                "_get_partial_string_timestamp_match_key(self, key, labels)",
                "_getitem_axis(self, key, axis: int)",
                "_validate_key(self, key, axis: int)",
                "_has_valid_setitem_indexer(self, indexer)",
                "_is_scalar_access(self, key: Tuple)",
                "_getitem_scalar(self, key)",
                "_validate_integer(self, key: int, axis: int)",
                "_getitem_tuple(self, tup: Tuple)",
                "_get_list_axis(self, key, axis: int)",
                "_getitem_axis(self, key, axis: int)",
                "_convert_to_indexer(self, obj, axis: int, raise_missing: bool=False)",
                "_convert_key(self, key, is_setter: bool=False)",
                "__getitem__(self, key)",
                "__setitem__(self, key, value)",
                "_convert_key(self, key, is_setter: bool=False)",
                "_convert_key(self, key, is_setter: bool=False)",
                "get_indexer(_i, _idx)",
                "pred(part)",
                "setter(item, v)",
                "ravel(i)"
            ],
            "variables_in_file": {
                "_IXIndexer": [
                    37
                ],
                "_iLocIndexer": [
                    38
                ],
                "_LocIndexer": [
                    39
                ],
                "_AtIndexer": [
                    40
                ],
                "_iAtIndexer": [
                    41
                ],
                "_NS": [
                    915,
                    46
                ],
                "slice": [
                    1409,
                    1797,
                    268,
                    1421,
                    654,
                    2316,
                    1682,
                    2451,
                    2326,
                    155,
                    2459,
                    286,
                    1315,
                    2091,
                    1964,
                    46,
                    1199,
                    2486,
                    696,
                    2491,
                    1725,
                    1733,
                    2121,
                    1748,
                    990,
                    737,
                    868,
                    1264,
                    757,
                    253
                ],
                "arg": [
                    2434,
                    2435,
                    92
                ],
                "IndexSlice": [
                    2481,
                    2511,
                    95
                ],
                "_IndexSlice": [
                    95
                ],
                "Exception": [
                    98,
                    867,
                    104,
                    175,
                    1372,
                    1406
                ],
                "_NDFrameIndexerBase": [
                    2137,
                    102
                ],
                "_valid_types": [
                    1667,
                    1942,
                    103
                ],
                "_exception": [
                    104,
                    1946,
                    1372,
                    1672
                ],
                "axis": [
                    2052,
                    2055,
                    2058,
                    2064,
                    2039,
                    2067,
                    1048,
                    1055,
                    2085,
                    1062,
                    2092,
                    1069,
                    2098,
                    2099,
                    2103,
                    2112,
                    2114,
                    2122,
                    1099,
                    1101,
                    2125,
                    2128,
                    1107,
                    1110,
                    1112,
                    105,
                    111,
                    112,
                    113,
                    1142,
                    1154,
                    143,
                    146,
                    1689,
                    154,
                    155,
                    158,
                    161,
                    164,
                    1197,
                    1200,
                    1204,
                    187,
                    189,
                    1745,
                    1237,
                    1749,
                    1750,
                    1752,
                    1254,
                    1271,
                    1272,
                    248,
                    250,
                    251,
                    1792,
                    1798,
                    264,
                    1802,
                    1803,
                    270,
                    1326,
                    1346,
                    845,
                    846,
                    855,
                    858,
                    1385,
                    1388,
                    882,
                    883,
                    1401,
                    1405,
                    1416,
                    1422,
                    1426,
                    1967,
                    1974,
                    956,
                    957,
                    962,
                    966,
                    970,
                    971,
                    980,
                    987,
                    989,
                    991,
                    999,
                    1006,
                    1008,
                    1015,
                    1017
                ],
                "new_self": [
                    113,
                    114,
                    109
                ],
                "self.__class__": [
                    109
                ],
                "self": [
                    2051,
                    519,
                    2058,
                    2061,
                    2039,
                    1047,
                    1052,
                    1055,
                    2085,
                    1062,
                    1068,
                    557,
                    2092,
                    2098,
                    2099,
                    564,
                    567,
                    2103,
                    570,
                    573,
                    574,
                    575,
                    2112,
                    2114,
                    585,
                    586,
                    1099,
                    2122,
                    1101,
                    2125,
                    2128,
                    1107,
                    2133,
                    598,
                    1110,
                    1111,
                    602,
                    605,
                    606,
                    607,
                    2141,
                    609,
                    610,
                    612,
                    614,
                    2152,
                    2153,
                    620,
                    109,
                    2157,
                    112,
                    2160,
                    627,
                    2163,
                    2164,
                    630,
                    1142,
                    632,
                    633,
                    634,
                    2166,
                    124,
                    2168,
                    126,
                    1154,
                    1160,
                    140,
                    143,
                    145,
                    146,
                    149,
                    1689,
                    154,
                    668,
                    669,
                    158,
                    1696,
                    161,
                    164,
                    167,
                    168,
                    1703,
                    170,
                    682,
                    172,
                    1197,
                    1200,
                    1715,
                    180,
                    1204,
                    2229,
                    187,
                    189,
                    199,
                    201,
                    202,
                    203,
                    713,
                    719,
                    1233,
                    1745,
                    1746,
                    1237,
                    1749,
                    1750,
                    1752,
                    729,
                    736,
                    225,
                    230,
                    1254,
                    233,
                    237,
                    241,
                    242,
                    1266,
                    758,
                    247,
                    248,
                    249,
                    1271,
                    251,
                    1272,
                    2296,
                    256,
                    1792,
                    258,
                    1797,
                    1799,
                    264,
                    266,
                    1802,
                    1803,
                    270,
                    271,
                    782,
                    787,
                    790,
                    791,
                    281,
                    794,
                    284,
                    285,
                    1310,
                    799,
                    296,
                    300,
                    1326,
                    306,
                    311,
                    314,
                    318,
                    319,
                    1346,
                    843,
                    845,
                    338,
                    855,
                    345,
                    858,
                    1376,
                    353,
                    354,
                    865,
                    1377,
                    357,
                    1379,
                    1382,
                    360,
                    872,
                    362,
                    1385,
                    364,
                    1387,
                    1388,
                    881,
                    370,
                    882,
                    372,
                    373,
                    374,
                    883,
                    886,
                    887,
                    890,
                    1401,
                    893,
                    894,
                    1405,
                    1407,
                    898,
                    387,
                    1412,
                    390,
                    906,
                    395,
                    1418,
                    1422,
                    399,
                    912,
                    402,
                    1426,
                    411,
                    413,
                    938,
                    1967,
                    949,
                    950,
                    1974,
                    444,
                    956,
                    957,
                    961,
                    450,
                    1988,
                    454,
                    1992,
                    970,
                    463,
                    1999,
                    2006,
                    475,
                    987,
                    989,
                    991,
                    2015,
                    999,
                    489,
                    1008,
                    1010,
                    1015,
                    1017,
                    2045,
                    2047
                ],
                "self.name": [
                    296,
                    1160,
                    266,
                    938,
                    172,
                    109,
                    300,
                    271,
                    970,
                    1233,
                    1418,
                    2058,
                    281,
                    1052,
                    893,
                    799
                ],
                "self.obj": [
                    2051,
                    519,
                    1047,
                    2085,
                    557,
                    570,
                    573,
                    574,
                    575,
                    586,
                    1101,
                    1107,
                    1111,
                    602,
                    605,
                    606,
                    607,
                    609,
                    610,
                    614,
                    2153,
                    620,
                    109,
                    2157,
                    112,
                    2160,
                    627,
                    630,
                    1142,
                    632,
                    633,
                    634,
                    2168,
                    124,
                    126,
                    1154,
                    145,
                    154,
                    669,
                    158,
                    161,
                    164,
                    1703,
                    170,
                    1197,
                    1715,
                    2229,
                    199,
                    201,
                    713,
                    719,
                    1745,
                    1237,
                    736,
                    241,
                    242,
                    1266,
                    758,
                    248,
                    2296,
                    1799,
                    264,
                    270,
                    794,
                    285,
                    311,
                    314,
                    318,
                    319,
                    1346,
                    843,
                    338,
                    345,
                    1376,
                    353,
                    354,
                    865,
                    357,
                    360,
                    872,
                    1387,
                    364,
                    882,
                    370,
                    372,
                    373,
                    374,
                    1401,
                    890,
                    1405,
                    1412,
                    390,
                    1426,
                    411,
                    413,
                    1974,
                    444,
                    961,
                    450,
                    454,
                    463,
                    2006,
                    475,
                    989,
                    2015,
                    1010,
                    2039
                ],
                "self.obj._get_axis_number": [
                    112,
                    248,
                    882
                ],
                "new_self.axis": [
                    113
                ],
                "NotImplementedError": [
                    1953,
                    2340,
                    1767,
                    1773,
                    1391,
                    1394,
                    1397,
                    117
                ],
                "type": [
                    121,
                    1375
                ],
                "key": [
                    2053,
                    2054,
                    2058,
                    1052,
                    1055,
                    1061,
                    1062,
                    1063,
                    2085,
                    2091,
                    2092,
                    2094,
                    2095,
                    2097,
                    2098,
                    2099,
                    2102,
                    2103,
                    2107,
                    2108,
                    2112,
                    2114,
                    1099,
                    1103,
                    1105,
                    1106,
                    1110,
                    2144,
                    2147,
                    2148,
                    2152,
                    2153,
                    2156,
                    2157,
                    2160,
                    2162,
                    2163,
                    2164,
                    2166,
                    2167,
                    1144,
                    121,
                    2168,
                    124,
                    126,
                    1154,
                    1161,
                    140,
                    145,
                    146,
                    1682,
                    1685,
                    1688,
                    1689,
                    1696,
                    161,
                    1699,
                    168,
                    174,
                    178,
                    1715,
                    180,
                    2227,
                    2229,
                    184,
                    185,
                    1722,
                    189,
                    1725,
                    1727,
                    195,
                    1731,
                    2243,
                    198,
                    199,
                    1736,
                    201,
                    202,
                    1738,
                    1741,
                    1742,
                    1743,
                    1746,
                    1748,
                    1749,
                    1750,
                    1751,
                    1752,
                    1753,
                    1761,
                    1764,
                    229,
                    1765,
                    1772,
                    1780,
                    1781,
                    1782,
                    1784,
                    2296,
                    251,
                    1787,
                    1789,
                    2299,
                    255,
                    1792,
                    1795,
                    1796,
                    266,
                    1802,
                    1803,
                    271,
                    2326,
                    2327,
                    2329,
                    795,
                    796,
                    2332,
                    799,
                    1315,
                    2339,
                    1318,
                    1321,
                    1326,
                    1348,
                    1349,
                    1350,
                    2374,
                    1352,
                    1353,
                    2375,
                    331,
                    1356,
                    845,
                    846,
                    851,
                    1375,
                    1376,
                    353,
                    1377,
                    1379,
                    357,
                    1382,
                    1387,
                    371,
                    376,
                    1402,
                    1403,
                    904,
                    905,
                    906,
                    2459,
                    1950,
                    1951,
                    1952,
                    1964,
                    1966,
                    1967,
                    1968,
                    1972,
                    1973,
                    963,
                    965,
                    970,
                    1999,
                    2002,
                    985,
                    986,
                    987,
                    990,
                    991,
                    992,
                    993,
                    2015,
                    996,
                    999,
                    1003,
                    1005,
                    1008,
                    1015,
                    2040,
                    1017
                ],
                "tuple": [
                    260,
                    1799,
                    905,
                    398,
                    655,
                    2318,
                    657,
                    2446,
                    663,
                    283,
                    155,
                    541,
                    417,
                    2425,
                    1968,
                    178,
                    2487,
                    443,
                    1725,
                    1727,
                    1217,
                    2499,
                    324,
                    198,
                    199,
                    1736,
                    462,
                    731,
                    1375,
                    1376,
                    993,
                    2144,
                    2148,
                    490,
                    2156,
                    2157,
                    2162,
                    1780,
                    1782,
                    1784,
                    121,
                    1787,
                    124,
                    381,
                    2302
                ],
                "com.apply_if_callable": [
                    1376,
                    199,
                    201,
                    1387,
                    2157,
                    2160,
                    145,
                    124
                ],
                "com": [
                    2054,
                    145,
                    1685,
                    665,
                    796,
                    1950,
                    1318,
                    551,
                    935,
                    2097,
                    822,
                    697,
                    1348,
                    965,
                    199,
                    201,
                    1356,
                    463,
                    1103,
                    1751,
                    1248,
                    1376,
                    1387,
                    2157,
                    2160,
                    124
                ],
                "x": [
                    1376,
                    199,
                    2157,
                    818,
                    822,
                    124
                ],
                "values": [
                    2016,
                    137,
                    138,
                    1715,
                    1716,
                    126,
                    2015
                ],
                "self.obj._get_value": [
                    2153,
                    1715,
                    126,
                    2015
                ],
                "KeyError": [
                    1152,
                    1380,
                    2340,
                    1672,
                    1162,
                    2411,
                    1009,
                    862,
                    127
                ],
                "TypeError": [
                    770,
                    1221,
                    1009,
                    1205,
                    859,
                    2109,
                    190,
                    127
                ],
                "InvalidIndexError": [
                    127
                ],
                "is_scalar": [
                    1700,
                    137,
                    974,
                    718,
                    2517
                ],
                "self._getitem_tuple": [
                    140,
                    1382
                ],
                "self.axis": [
                    167,
                    1385,
                    855,
                    143,
                    881,
                    882,
                    247,
                    248,
                    187,
                    956
                ],
                "self._getitem_axis": [
                    906,
                    1388,
                    146,
                    883,
                    957
                ],
                "int": [
                    1409,
                    262,
                    1675,
                    268,
                    148,
                    2071,
                    1949,
                    1182,
                    160,
                    1314,
                    163,
                    2090,
                    1073,
                    1330,
                    2117,
                    1740,
                    205,
                    850,
                    984,
                    1116,
                    2018,
                    1264,
                    1396,
                    1399,
                    1019,
                    2302
                ],
                "self.ndim": [
                    256,
                    898,
                    1797,
                    264,
                    395,
                    2061,
                    270,
                    399,
                    912,
                    149,
                    668,
                    284,
                    1696,
                    682,
                    949,
                    585,
                    1999,
                    338,
                    729,
                    865,
                    612,
                    230,
                    2163,
                    2164,
                    249
                ],
                "self.obj._xs": [
                    154,
                    158
                ],
                "label": [
                    154,
                    155,
                    158
                ],
                "isinstance": [
                    541,
                    2091,
                    2094,
                    560,
                    566,
                    2121,
                    2144,
                    618,
                    2156,
                    2162,
                    654,
                    657,
                    1682,
                    661,
                    155,
                    1704,
                    172,
                    1199,
                    178,
                    184,
                    696,
                    1721,
                    1722,
                    1727,
                    1217,
                    1732,
                    198,
                    1748,
                    1237,
                    731,
                    1759,
                    737,
                    738,
                    1761,
                    1765,
                    241,
                    1780,
                    757,
                    1782,
                    1787,
                    766,
                    767,
                    2326,
                    280,
                    2329,
                    283,
                    286,
                    1315,
                    298,
                    321,
                    324,
                    327,
                    1352,
                    2375,
                    868,
                    2405,
                    2410,
                    2423,
                    893,
                    2435,
                    905,
                    1421,
                    398,
                    2446,
                    401,
                    2451,
                    2452,
                    411,
                    923,
                    2459,
                    1951,
                    1964,
                    1968,
                    2480,
                    2486,
                    2491,
                    462,
                    990,
                    993,
                    482,
                    484,
                    1006
                ],
                "IndexingError": [
                    2048,
                    257,
                    195,
                    899,
                    869,
                    231,
                    2379,
                    940,
                    783,
                    1971,
                    181,
                    156
                ],
                "self.obj._ixs": [
                    161
                ],
                "self.obj._slice": [
                    164
                ],
                "obj": [
                    1412,
                    1414,
                    1416,
                    2325,
                    2332,
                    669,
                    413,
                    414,
                    1311,
                    2464,
                    2465,
                    2466,
                    164,
                    683,
                    428,
                    1199,
                    1200,
                    1204,
                    693,
                    441,
                    442,
                    443,
                    444,
                    1211,
                    1215,
                    961,
                    1217,
                    1218,
                    1219,
                    969,
                    970,
                    2121,
                    2122,
                    2124,
                    974,
                    2125,
                    2128,
                    2129,
                    979,
                    1235,
                    1237,
                    982,
                    1241,
                    2521,
                    1243,
                    1244,
                    1246,
                    1248,
                    1249,
                    1250,
                    1254,
                    1257,
                    1260,
                    1261,
                    1266,
                    1269
                ],
                "kind": [
                    164
                ],
                "self._convert_tuple": [
                    168,
                    180
                ],
                "ax": [
                    768,
                    775,
                    264,
                    1161,
                    266,
                    270,
                    271,
                    1048,
                    1179,
                    1052,
                    285,
                    1056,
                    1058,
                    293,
                    1061,
                    1063,
                    1064,
                    1703,
                    170,
                    1066,
                    172,
                    1704,
                    174,
                    1707,
                    693,
                    2229,
                    2230,
                    699,
                    2237,
                    713,
                    714,
                    716,
                    719,
                    721,
                    724,
                    2006,
                    2007,
                    736,
                    741,
                    743,
                    241,
                    242,
                    758,
                    759,
                    1142,
                    766
                ],
                "self.obj._get_axis": [
                    1346,
                    390,
                    264,
                    872,
                    170,
                    1101,
                    270,
                    719,
                    1197,
                    1745,
                    370,
                    2039,
                    1142,
                    1974,
                    1401,
                    890,
                    989
                ],
                "MultiIndex": [
                    993,
                    1217,
                    484,
                    1704,
                    172,
                    1006,
                    241,
                    1759,
                    1787,
                    2452,
                    1237,
                    1721,
                    411,
                    893,
                    766,
                    767
                ],
                "ax.get_loc": [
                    174
                ],
                "range": [
                    184,
                    249,
                    2316
                ],
                "list": [
                    321,
                    483,
                    1764,
                    2435,
                    1161,
                    654,
                    1743,
                    2094,
                    2479,
                    2227,
                    2166,
                    185,
                    986
                ],
                "self._convert_to_indexer": [
                    258,
                    251,
                    189
                ],
                "str": [
                    193,
                    1732,
                    2479,
                    2329,
                    1722
                ],
                "e": [
                    193
                ],
                "indexer": [
                    384,
                    387,
                    1797,
                    1798,
                    1799,
                    1417,
                    1421,
                    398,
                    399,
                    654,
                    655,
                    402,
                    657,
                    404,
                    1422,
                    1426,
                    663,
                    280,
                    665,
                    283,
                    284,
                    285,
                    541,
                    415,
                    542,
                    417,
                    1052,
                    1054,
                    548,
                    549,
                    1055,
                    1056,
                    552,
                    1063,
                    682,
                    683,
                    1066,
                    557,
                    686,
                    687,
                    1069,
                    1071,
                    306,
                    564,
                    692,
                    567,
                    574,
                    449,
                    324,
                    326,
                    1992,
                    202,
                    203,
                    587,
                    718,
                    1110,
                    1112,
                    731,
                    735,
                    483,
                    2405,
                    360,
                    2408,
                    2410,
                    2412,
                    621,
                    2414,
                    757,
                    630,
                    758,
                    1272,
                    2425,
                    1271,
                    1148,
                    381,
                    1151
                ],
                "self._get_setitem_indexer": [
                    202
                ],
                "self._setitem_with_indexer": [
                    362,
                    203,
                    598
                ],
                "value": [
                    387,
                    515,
                    519,
                    521,
                    526,
                    401,
                    402,
                    532,
                    538,
                    423,
                    424,
                    425,
                    428,
                    557,
                    560,
                    436,
                    564,
                    566,
                    567,
                    443,
                    574,
                    321,
                    203,
                    2517,
                    598,
                    601,
                    2523,
                    348,
                    479,
                    353,
                    482,
                    357,
                    487,
                    362,
                    490,
                    618,
                    620,
                    621,
                    625,
                    627,
                    501,
                    630,
                    2167,
                    632,
                    505,
                    506
                ],
                "AbstractMethodError": [
                    225,
                    2141
                ],
                "Tuple": [
                    803,
                    227,
                    2043,
                    1994,
                    780,
                    878,
                    942,
                    240,
                    1390,
                    853,
                    827,
                    1691
                ],
                "i": [
                    256,
                    512,
                    258,
                    515,
                    2053,
                    904,
                    906,
                    2449,
                    915,
                    661,
                    918,
                    795,
                    924,
                    285,
                    286,
                    799,
                    289,
                    1699,
                    292,
                    293,
                    2297,
                    1703,
                    552,
                    553,
                    298,
                    692,
                    693,
                    2229,
                    2231,
                    2237,
                    963,
                    1731,
                    1732,
                    326,
                    338,
                    2002,
                    2006,
                    345,
                    735,
                    736,
                    229,
                    230,
                    233,
                    747,
                    370,
                    372,
                    2296,
                    249,
                    250,
                    255
                ],
                "k": [
                    258,
                    1699,
                    1700,
                    229,
                    233,
                    2449,
                    2002,
                    2003,
                    2451,
                    255
                ],
                "enumerate": [
                    512,
                    963,
                    1699,
                    229,
                    326,
                    1731,
                    552,
                    904,
                    2053,
                    2425,
                    2449,
                    735,
                    2002,
                    692,
                    345,
                    795,
                    255
                ],
                "self._validate_key": [
                    233,
                    1802,
                    1099,
                    2128,
                    2098,
                    1749,
                    987
                ],
                "ValueError": [
                    778,
                    527,
                    2340,
                    1958,
                    429,
                    2232,
                    2238,
                    1986,
                    1223,
                    2130,
                    2131,
                    726,
                    1239,
                    349,
                    997,
                    2150,
                    616,
                    234,
                    235,
                    628,
                    2165,
                    2298,
                    507,
                    1790
                ],
                "format": [
                    1153,
                    1987,
                    295,
                    2393,
                    1162,
                    236,
                    300,
                    2132,
                    281,
                    1979
                ],
                "self._valid_types": [
                    1988,
                    237,
                    2133
                ],
                "any": [
                    241,
                    242,
                    597,
                    822,
                    347
                ],
                "self.obj.axes": [
                    736,
                    450,
                    1703,
                    360,
                    713,
                    241,
                    242,
                    2229,
                    2006,
                    2296,
                    345,
                    285
                ],
                "is_nested_tuple": [
                    1795,
                    242,
                    1243
                ],
                "tup": [
                    898,
                    2053,
                    904,
                    2316,
                    2317,
                    782,
                    2318,
                    2446,
                    2449,
                    787,
                    915,
                    790,
                    791,
                    918,
                    795,
                    818,
                    949,
                    822,
                    950,
                    957,
                    963,
                    846,
                    858,
                    865,
                    868,
                    873,
                    242,
                    883,
                    886,
                    887,
                    2045,
                    894,
                    2047
                ],
                "keyidx": [
                    259,
                    260,
                    246,
                    251,
                    253
                ],
                "keyidx.append": [
                    259,
                    251,
                    253
                ],
                "idx": [
                    258,
                    259,
                    2325,
                    2327,
                    665,
                    415,
                    417,
                    2337,
                    2339,
                    551,
                    552,
                    428,
                    692,
                    696,
                    697,
                    440,
                    443,
                    699,
                    326,
                    327,
                    331,
                    463,
                    464,
                    733,
                    740,
                    741,
                    749,
                    751,
                    754,
                    379
                ],
                "min": [
                    264,
                    270
                ],
                "ax._convert_scalar_indexer": [
                    266
                ],
                "ax._convert_slice_indexer": [
                    271
                ],
                "dict": [
                    321,
                    2405,
                    327,
                    298,
                    560,
                    2423,
                    280
                ],
                "IndexError": [
                    1978,
                    1984,
                    1380,
                    294,
                    2086,
                    2088,
                    299,
                    2392,
                    281,
                    1946,
                    2041
                ],
                "_tuplify": [
                    2163,
                    284,
                    399
                ],
                "zip": [
                    846,
                    532,
                    2229,
                    2296,
                    285
                ],
                "is_list_like_indexer": [
                    909,
                    1688,
                    2459,
                    289,
                    423,
                    1321,
                    818,
                    1972,
                    2102,
                    700,
                    1753,
                    348,
                    1246,
                    479,
                    992,
                    2147,
                    1260,
                    625,
                    757
                ],
                "is_integer": [
                    292,
                    549,
                    1005,
                    1966,
                    1010,
                    2003,
                    405,
                    2231,
                    2297,
                    1211,
                    2108,
                    2237
                ],
                "len": [
                    898,
                    526,
                    411,
                    925,
                    1696,
                    930,
                    548,
                    293,
                    1061,
                    425,
                    428,
                    686,
                    687,
                    949,
                    1974,
                    1725,
                    1983,
                    704,
                    1218,
                    714,
                    587,
                    463,
                    1999,
                    2517,
                    2391,
                    345,
                    602,
                    2393,
                    2523,
                    2525,
                    865,
                    614,
                    371,
                    627,
                    1781,
                    2164,
                    2039,
                    1144,
                    506,
                    1151
                ],
                "self._has_valid_setitem_indexer": [
                    306
                ],
                "info_axis": [
                    417,
                    449,
                    450,
                    548,
                    549,
                    390,
                    488,
                    553,
                    396,
                    557,
                    404,
                    311,
                    415
                ],
                "self.obj._info_axis_number": [
                    338,
                    311
                ],
                "take_split_path": [
                    393,
                    314,
                    322,
                    318
                ],
                "self.obj._is_mixed_type": [
                    314
                ],
                "self.obj._data.blocks": [
                    318,
                    319
                ],
                "self.obj._data": [
                    318,
                    606,
                    372,
                    632,
                    574,
                    319
                ],
                "blk": [
                    320,
                    322,
                    319
                ],
                "blk.ndim": [
                    320
                ],
                "val": [
                    321,
                    322,
                    775,
                    776,
                    752,
                    754,
                    755,
                    760
                ],
                "value.values": [
                    321
                ],
                "blk._can_hold_element": [
                    322
                ],
                "nindexer": [
                    376,
                    381,
                    379,
                    325
                ],
                "_": [
                    682,
                    331,
                    2316
                ],
                "convert_missing_indexer": [
                    384,
                    331
                ],
                "len_non_info_axes": [
                    344,
                    347
                ],
                "_ax": [
                    345
                ],
                "_i": [
                    2425,
                    345,
                    2423
                ],
                "l": [
                    347
                ],
                "_infer_fill_value": [
                    357
                ],
                "new_indexer": [
                    359,
                    362,
                    1066,
                    596,
                    597,
                    598
                ],
                "convert_from_missing_indexer_tuple": [
                    359
                ],
                "index": [
                    418,
                    2375,
                    2376,
                    586,
                    587,
                    2521,
                    370,
                    371,
                    595,
                    596,
                    2391,
                    440,
                    2393,
                    2525,
                    414
                ],
                "labels": [
                    512,
                    1795,
                    1796,
                    519,
                    1416,
                    521,
                    1417,
                    526,
                    1402,
                    532,
                    2452,
                    407,
                    537,
                    411,
                    412,
                    1197,
                    1721,
                    1210,
                    1722,
                    1725,
                    1215,
                    1217,
                    1218,
                    1346,
                    1732,
                    1349,
                    1350,
                    1353,
                    1101,
                    1105,
                    1362,
                    1745,
                    1364,
                    1237,
                    1366,
                    1746,
                    2517,
                    2520,
                    1243,
                    1244,
                    989,
                    1759,
                    993,
                    1249,
                    484,
                    486,
                    1257,
                    1003,
                    1006,
                    371,
                    372,
                    1014,
                    376,
                    1401,
                    506,
                    1787
                ],
                "index.insert": [
                    587,
                    371
                ],
                "_data": [
                    632,
                    372,
                    606
                ],
                "self.obj.reindex": [
                    372
                ],
                "self.obj._maybe_update_cacher": [
                    609,
                    373,
                    633,
                    575
                ],
                "self.obj._is_copy": [
                    374
                ],
                "nindexer.append": [
                    376,
                    379
                ],
                "labels.get_loc": [
                    376,
                    1257,
                    1215
                ],
                "missing": [
                    384,
                    386,
                    1148,
                    1150,
                    1151
                ],
                "self._setitem_with_indexer_missing": [
                    387
                ],
                "item_labels": [
                    555,
                    557,
                    390,
                    407
                ],
                "ABCSeries": [
                    1761,
                    2435,
                    2375,
                    618,
                    2479,
                    560,
                    401,
                    636
                ],
                "self._align_series": [
                    489,
                    402,
                    564
                ],
                "info_idx": [
                    404,
                    405,
                    406,
                    407
                ],
                "axes": [
                    411,
                    2423
                ],
                "item": [
                    512,
                    515,
                    454,
                    486,
                    487,
                    488,
                    490,
                    2521,
                    537,
                    495,
                    532,
                    533,
                    2520,
                    412,
                    538,
                    475,
                    444,
                    413
                ],
                "obj.index": [
                    2325,
                    414
                ],
                "plane_indexer": [
                    417,
                    418,
                    451,
                    449,
                    455,
                    519,
                    2517
                ],
                "lplane_indexer": [
                    418,
                    451,
                    519,
                    455,
                    425,
                    2527
                ],
                "length_of_indexer": [
                    418,
                    451
                ],
                "np.iterable": [
                    424,
                    2517
                ],
                "np": [
                    1761,
                    738,
                    2435,
                    2439,
                    424,
                    2346,
                    2508,
                    493,
                    654,
                    2095,
                    688,
                    2479,
                    2388,
                    501,
                    661,
                    1973,
                    2517,
                    505
                ],
                "ravel": [
                    436,
                    663
                ],
                "getattr": [
                    1058,
                    970,
                    938,
                    479,
                    2058,
                    436,
                    799
                ],
                "index._convert_slice_indexer": [
                    440
                ],
                "obj._consolidate_inplace": [
                    441
                ],
                "obj.copy": [
                    442,
                    1269,
                    1414
                ],
                "obj._data": [
                    443,
                    2332
                ],
                "obj._data.setitem": [
                    443
                ],
                "plane_axis": [
                    450,
                    451
                ],
                "s": [
                    454,
                    466,
                    469,
                    470,
                    471,
                    472,
                    475
                ],
                "pi": [
                    464,
                    471,
                    462,
                    455
                ],
                "all": [
                    550,
                    682,
                    462,
                    818,
                    1054
                ],
                "com.is_null_slice": [
                    965,
                    2054,
                    551,
                    935,
                    463,
                    697,
                    665,
                    796
                ],
                "com.is_full_slice": [
                    463
                ],
                "v": [
                    489,
                    493,
                    495,
                    466,
                    532,
                    533,
                    471
                ],
                "s._consolidate_inplace": [
                    469
                ],
                "s.copy": [
                    470
                ],
                "s._data": [
                    471
                ],
                "s._data.setitem": [
                    471
                ],
                "s._maybe_update_cacher": [
                    472
                ],
                "ABCDataFrame": [
                    482,
                    1765,
                    566,
                    728,
                    923
                ],
                "sub_indexer": [
                    488,
                    490,
                    483
                ],
                "multiindex_indexer": [
                    490,
                    484,
                    686
                ],
                "np.nan": [
                    493
                ],
                "setter": [
                    515,
                    521,
                    495,
                    533,
                    538
                ],
                "np.ndim": [
                    501
                ],
                "np.array": [
                    505,
                    1973
                ],
                "object": [
                    505
                ],
                "value.shape": [
                    506
                ],
                "tolist": [
                    515
                ],
                "_can_do_equal_len": [
                    518
                ],
                "maybe_convert_ix": [
                    542
                ],
                "item_labels.is_unique": [
                    555
                ],
                "Series": [
                    601,
                    564,
                    630
                ],
                "self._align_frame": [
                    567
                ],
                "self.obj._check_is_chained_assignment_possible": [
                    570
                ],
                "self.obj._consolidate_inplace": [
                    573
                ],
                "self.obj._data.setitem": [
                    574
                ],
                "self.obj.index": [
                    865,
                    586,
                    1010,
                    758
                ],
                "new_index": [
                    587,
                    596,
                    607
                ],
                "index.is_unique": [
                    595
                ],
                "index.get_indexer": [
                    596
                ],
                "new_values": [
                    601,
                    605,
                    607
                ],
                "_values": [
                    707,
                    775,
                    683,
                    716,
                    752,
                    2384,
                    754,
                    724,
                    760,
                    601
                ],
                "self.obj._values": [
                    602,
                    605
                ],
                "concat_compat": [
                    605
                ],
                "self.obj._constructor": [
                    606
                ],
                "self.obj.name": [
                    607
                ],
                "self.obj.columns": [
                    630,
                    627,
                    620,
                    614
                ],
                "value.reindex": [
                    620
                ],
                "value.name": [
                    621
                ],
                "self.obj.append": [
                    632
                ],
                "bool": [
                    2117,
                    2410,
                    2220,
                    2510,
                    1116,
                    2140,
                    2384,
                    2388,
                    2294,
                    1019,
                    636,
                    1182
                ],
                "np.ndarray": [
                    1761,
                    738,
                    2435,
                    2346,
                    654,
                    2479,
                    661
                ],
                "Index": [
                    2435,
                    868,
                    1352,
                    2346,
                    654,
                    2479,
                    1951,
                    701,
                    703
                ],
                "i.ravel": [
                    661
                ],
                "map": [
                    663
                ],
                "aligners": [
                    665,
                    666,
                    678
                ],
                "sum_aligners": [
                    682,
                    666,
                    667
                ],
                "sum": [
                    666,
                    1148
                ],
                "single_aligner": [
                    697,
                    667,
                    710,
                    678
                ],
                "is_frame": [
                    729,
                    668,
                    677,
                    757
                ],
                "is_sequence": [
                    696,
                    737,
                    682
                ],
                "ser": [
                    704,
                    705,
                    707,
                    714,
                    683,
                    715,
                    716,
                    688,
                    721,
                    690,
                    722,
                    724
                ],
                "ser.reindex": [
                    724,
                    683,
                    716,
                    707
                ],
                "obj.axes": [
                    683,
                    693
                ],
                "len_indexer": [
                    688,
                    687
                ],
                "T": [
                    688
                ],
                "reshape": [
                    688
                ],
                "np.tile": [
                    688
                ],
                "new_ix": [
                    704,
                    707,
                    699,
                    700,
                    701,
                    703
                ],
                "ser.index.equals": [
                    704,
                    721,
                    714
                ],
                "ser.index": [
                    704,
                    721,
                    714
                ],
                "ser._values.copy": [
                    705,
                    722,
                    715
                ],
                "ser._values": [
                    705,
                    722,
                    715
                ],
                "cols": [
                    742,
                    743,
                    749,
                    751,
                    754,
                    733
                ],
                "sindexers": [
                    747,
                    734
                ],
                "ix": [
                    737,
                    738,
                    739,
                    741,
                    743,
                    735
                ],
                "ix.ravel": [
                    739
                ],
                "sindexers.append": [
                    747
                ],
                "df.index.equals": [
                    759,
                    751
                ],
                "df.index": [
                    767,
                    768,
                    759,
                    751
                ],
                "df": [
                    768,
                    775,
                    751,
                    752,
                    2511,
                    754,
                    759,
                    760,
                    767
                ],
                "df.columns.equals": [
                    751
                ],
                "df.columns": [
                    751
                ],
                "df.copy": [
                    752,
                    760
                ],
                "df.reindex": [
                    754,
                    775
                ],
                "ax.nlevels": [
                    768
                ],
                "df.index.nlevels": [
                    768
                ],
                "self._getitem_lowerdim": [
                    782,
                    2047
                ],
                "self._has_valid_tuple": [
                    787,
                    2045
                ],
                "self._multi_take_opportunity": [
                    790
                ],
                "self._multi_take": [
                    791
                ],
                "retval": [
                    801,
                    2051,
                    2058,
                    2061,
                    2069,
                    794,
                    799
                ],
                "_getitem_axis": [
                    970,
                    2058,
                    799
                ],
                "com.is_bool_indexer": [
                    1248,
                    1348,
                    1318,
                    1103,
                    2097,
                    1685,
                    822,
                    1751,
                    1950
                ],
                "o": [
                    843,
                    1069,
                    846,
                    848,
                    1047,
                    1048
                ],
                "d": [
                    848,
                    844
                ],
                "self._get_listlike_indexer": [
                    1254,
                    845,
                    1110
                ],
                "o._AXIS_ORDERS": [
                    846
                ],
                "o._reindex_with_indexers": [
                    848
                ],
                "self._get_label": [
                    1008,
                    1017,
                    858,
                    1803
                ],
                "self.obj.index.nlevels": [
                    865
                ],
                "ek": [
                    866
                ],
                "ax0": [
                    872,
                    873,
                    890,
                    893
                ],
                "ax0.is_lexsorted_for_tuple": [
                    873
                ],
                "e1": [
                    874
                ],
                "self._is_nested_tuple_indexer": [
                    886
                ],
                "self._getitem_nested_tuple": [
                    887
                ],
                "result": [
                    896,
                    2374,
                    2376,
                    2377,
                    2393,
                    2384,
                    2386,
                    2387,
                    2388,
                    950,
                    951,
                    952,
                    2391,
                    2396,
                    894,
                    895
                ],
                "self._handle_lowerdim_multi_index_axis0": [
                    950,
                    894
                ],
                "is_label_like": [
                    905
                ],
                "section": [
                    936,
                    906,
                    938,
                    909,
                    910,
                    912,
                    923
                ],
                "section.ndim": [
                    912
                ],
                "new_key": [
                    928,
                    930,
                    931,
                    1730,
                    1733,
                    935,
                    1735,
                    1736,
                    938,
                    915,
                    918,
                    925,
                    927
                ],
                "a": [
                    928,
                    2296,
                    927
                ],
                "b": [
                    928,
                    927
                ],
                "current_ndim": [
                    969,
                    979
                ],
                "obj.ndim": [
                    969,
                    979
                ],
                "hasattr": [
                    996,
                    1772,
                    974,
                    1789,
                    1951
                ],
                "is_iterator": [
                    985,
                    1742
                ],
                "self._get_slice_axis": [
                    2092,
                    1750,
                    991
                ],
                "key.ndim": [
                    1761,
                    996,
                    1789,
                    1772
                ],
                "self._getitem_iterable": [
                    1792,
                    999
                ],
                "labels._maybe_cast_indexer": [
                    1003
                ],
                "self.obj.index.levels": [
                    1010
                ],
                "labels.is_floating": [
                    1014
                ],
                "labels.is_integer": [
                    1210,
                    1364,
                    1014
                ],
                "self._get_loc": [
                    2114,
                    1015
                ],
                "o._get_axis": [
                    1048
                ],
                "keyarr": [
                    1368,
                    1064,
                    1353,
                    1066,
                    1356,
                    1069,
                    1358,
                    1071,
                    1362,
                    1365,
                    1110,
                    1366,
                    1112,
                    1052
                ],
                "ax._convert_listlike_indexer": [
                    1052
                ],
                "self._validate_read_indexer": [
                    1068,
                    1055
                ],
                "raise_missing": [
                    1160,
                    1069,
                    1055
                ],
                "ax.is_unique": [
                    1058,
                    1707,
                    2007
                ],
                "self._convert_for_reindex": [
                    1062
                ],
                "ax.get_indexer_for": [
                    1063
                ],
                "ax.reindex": [
                    1064
                ],
                "ax._reindex_non_unique": [
                    1066
                ],
                "o._get_axis_number": [
                    1069
                ],
                "check_bool_indexer": [
                    1105,
                    1402,
                    1349,
                    1249
                ],
                "inds": [
                    1250,
                    1251,
                    1106,
                    1107,
                    1403,
                    1405
                ],
                "key.nonzero": [
                    1106,
                    1403
                ],
                "self.obj.take": [
                    2085,
                    1426,
                    1107,
                    1405
                ],
                "self.obj._reindex_with_indexers": [
                    1111
                ],
                "self.obj._get_axis_name": [
                    1154
                ],
                "not_found": [
                    1161,
                    1162
                ],
                "set": [
                    1161
                ],
                "_missing_key_warning": [
                    1170,
                    1180
                ],
                "textwrap.dedent": [
                    1170,
                    1299
                ],
                "textwrap": [
                    1170,
                    1299
                ],
                "ax.is_categorical": [
                    1179
                ],
                "ax.is_interval": [
                    1179
                ],
                "warnings.warn": [
                    1180,
                    1310
                ],
                "warnings": [
                    1180,
                    1310
                ],
                "FutureWarning": [
                    1180,
                    1310
                ],
                "self._convert_slice_indexer": [
                    1200,
                    2122,
                    1271
                ],
                "self._convert_scalar_indexer": [
                    1689,
                    1204,
                    2125,
                    1326
                ],
                "is_int_index": [
                    1210,
                    1211
                ],
                "is_int_positional": [
                    1224,
                    1211,
                    1228
                ],
                "LookupError": [
                    1216,
                    1258
                ],
                "labels.nlevels": [
                    1218
                ],
                "self.obj.shape": [
                    1237
                ],
                "labels.get_locs": [
                    1244,
                    1796
                ],
                "obj.nonzero": [
                    1250
                ],
                "need_slice": [
                    1268,
                    1413
                ],
                "slice_obj": [
                    1418,
                    1268,
                    1413,
                    1271
                ],
                "self._slice": [
                    1272,
                    1422
                ],
                "_NDFrameIndexer": [
                    1313,
                    1947,
                    1674,
                    1275,
                    1371
                ],
                "_ix_deprecation_warning": [
                    1299
                ],
                "self._ix_deprecation_warning": [
                    1310
                ],
                "__init__": [
                    1311
                ],
                "super": [
                    1311
                ],
                "name": [
                    1311
                ],
                "Appender": [
                    1313,
                    1674
                ],
                "_NDFrameIndexer._validate_key.__doc__": [
                    1313,
                    1674
                ],
                "_NDFrameIndexer._validate_key": [
                    1313,
                    1674
                ],
                "labels._convert_index_indexer": [
                    1353
                ],
                "com.asarray_tuplesafe": [
                    1356
                ],
                "is_integer_dtype": [
                    1358
                ],
                "labels._convert_arr_indexer": [
                    1362
                ],
                "ensure_platform_int": [
                    1365
                ],
                "labels.take": [
                    1366
                ],
                "self._is_scalar_access": [
                    1377
                ],
                "self._getitem_scalar": [
                    1379
                ],
                "AttributeError": [
                    1380
                ],
                "maybe_callable": [
                    1387,
                    1388
                ],
                "self._exception": [
                    1407
                ],
                "detail": [
                    1407
                ],
                "obj._get_axis": [
                    1416
                ],
                "labels.slice_indexer": [
                    1417
                ],
                "slice_obj.start": [
                    1418
                ],
                "slice_obj.stop": [
                    1418
                ],
                "slice_obj.step": [
                    1418
                ],
                "_LocationIndexer": [
                    1429,
                    1806
                ],
                "is_all_dates": [
                    1722,
                    1732
                ],
                "labels.levels": [
                    1722,
                    1732,
                    1725
                ],
                "component": [
                    1731,
                    1732,
                    1733,
                    1735
                ],
                "new_key.append": [
                    1733,
                    1735
                ],
                "item_from_zerodim": [
                    2107,
                    1741
                ],
                "self._get_partial_string_timestamp_match_key": [
                    1746
                ],
                "self._getbool_axis": [
                    1752,
                    2099
                ],
                "locs": [
                    1796,
                    1798
                ],
                "self.obj.iloc": [
                    1799
                ],
                "_get_slice_axis": [
                    1947
                ],
                "_NDFrameIndexer._get_slice_axis": [
                    1947
                ],
                "key.index": [
                    1952,
                    2375,
                    1951
                ],
                "key.index.inferred_type": [
                    1952
                ],
                "self._validate_integer": [
                    2112,
                    1967
                ],
                "arr": [
                    1977,
                    1979,
                    1973,
                    1983
                ],
                "len_axis": [
                    2040,
                    2039,
                    1974,
                    1983
                ],
                "is_numeric_dtype": [
                    1977
                ],
                "arr.dtype": [
                    1977
                ],
                "arr.max": [
                    1983
                ],
                "arr.min": [
                    1983
                ],
                "self._has_valid_positional_setitem_indexer": [
                    1992
                ],
                "retval.ndim": [
                    2061
                ],
                "np.asarray": [
                    2388,
                    2095
                ],
                "self._get_list_axis": [
                    2103
                ],
                "is_float": [
                    2124
                ],
                "self._convert_key": [
                    2152,
                    2166
                ],
                "self._takeable": [
                    2168,
                    2153
                ],
                "key.append": [
                    2167
                ],
                "self.obj._set_value": [
                    2168
                ],
                "_ScalarAccessIndexer": [
                    2171,
                    2246
                ],
                "_takeable": [
                    2218,
                    2292
                ],
                "is_setter": [
                    2226
                ],
                "ax.is_integer": [
                    2230
                ],
                "ax.holds_integer": [
                    2237
                ],
                "ndim": [
                    2316
                ],
                "loc": [
                    2317
                ],
                "idx._convert_slice_indexer": [
                    2327
                ],
                "obj._data.items": [
                    2332
                ],
                "idx.is_all_dates": [
                    2337
                ],
                "idx._get_string_slice": [
                    2339
                ],
                "key.index.equals": [
                    2375
                ],
                "result.reindex": [
                    2376
                ],
                "mask": [
                    2377,
                    2378
                ],
                "isna": [
                    2377
                ],
                "result._values": [
                    2377
                ],
                "mask.any": [
                    2378
                ],
                "result.astype": [
                    2384
                ],
                "is_sparse": [
                    2386
                ],
                "result.to_dense": [
                    2387
                ],
                "_idx": [
                    2425,
                    2423
                ],
                "get_loc": [
                    2423
                ],
                "get_indexer": [
                    2425
                ],
                "ixify": [
                    2433,
                    2436,
                    2438
                ],
                "args": [
                    2441,
                    2434,
                    2439
                ],
                "np.ix_": [
                    2439
                ],
                "is_list_like": [
                    2490,
                    2451,
                    2486
                ],
                "obj.start": [
                    2464
                ],
                "obj.stop": [
                    2465
                ],
                "obj.step": [
                    2466
                ],
                "kinds": [
                    2480,
                    2479
                ],
                "slice_": [
                    2496,
                    2498,
                    2499,
                    2507,
                    2511,
                    2480,
                    2481,
                    2512,
                    2490,
                    2491,
                    2493
                ],
                "part": [
                    2498,
                    2486,
                    2487
                ],
                "pred": [
                    2498
                ],
                "dtypes": [
                    2508,
                    2510,
                    2511
                ],
                "np.number": [
                    2508
                ],
                "include_bool": [
                    2509
                ],
                "dtypes.append": [
                    2510
                ],
                "columns": [
                    2511
                ],
                "df.select_dtypes": [
                    2511
                ],
                "values_len": [
                    2523,
                    2525,
                    2527
                ]
            },
            "filtered_variables_in_file": {
                "_IXIndexer": [
                    37
                ],
                "_iLocIndexer": [
                    38
                ],
                "_LocIndexer": [
                    39
                ],
                "_AtIndexer": [
                    40
                ],
                "_iAtIndexer": [
                    41
                ],
                "_NS": [
                    915,
                    46
                ],
                "arg": [
                    2434,
                    2435,
                    92
                ],
                "IndexSlice": [
                    2481,
                    2511,
                    95
                ],
                "_IndexSlice": [
                    95
                ],
                "_NDFrameIndexerBase": [
                    2137,
                    102
                ],
                "_valid_types": [
                    1667,
                    1942,
                    103
                ],
                "_exception": [
                    104,
                    1946,
                    1372,
                    1672
                ],
                "axis": [
                    2052,
                    2055,
                    2058,
                    2064,
                    2039,
                    2067,
                    1048,
                    1055,
                    2085,
                    1062,
                    2092,
                    1069,
                    2098,
                    2099,
                    2103,
                    2112,
                    2114,
                    2122,
                    1099,
                    1101,
                    2125,
                    2128,
                    1107,
                    1110,
                    1112,
                    105,
                    111,
                    112,
                    113,
                    1142,
                    1154,
                    143,
                    146,
                    1689,
                    154,
                    155,
                    158,
                    161,
                    164,
                    1197,
                    1200,
                    1204,
                    187,
                    189,
                    1745,
                    1237,
                    1749,
                    1750,
                    1752,
                    1254,
                    1271,
                    1272,
                    248,
                    250,
                    251,
                    1792,
                    1798,
                    264,
                    1802,
                    1803,
                    270,
                    1326,
                    1346,
                    845,
                    846,
                    855,
                    858,
                    1385,
                    1388,
                    882,
                    883,
                    1401,
                    1405,
                    1416,
                    1422,
                    1426,
                    1967,
                    1974,
                    956,
                    957,
                    962,
                    966,
                    970,
                    971,
                    980,
                    987,
                    989,
                    991,
                    999,
                    1006,
                    1008,
                    1015,
                    1017
                ],
                "new_self": [
                    113,
                    114,
                    109
                ],
                "self.__class__": [
                    109
                ],
                "self": [
                    2051,
                    519,
                    2058,
                    2061,
                    2039,
                    1047,
                    1052,
                    1055,
                    2085,
                    1062,
                    1068,
                    557,
                    2092,
                    2098,
                    2099,
                    564,
                    567,
                    2103,
                    570,
                    573,
                    574,
                    575,
                    2112,
                    2114,
                    585,
                    586,
                    1099,
                    2122,
                    1101,
                    2125,
                    2128,
                    1107,
                    2133,
                    598,
                    1110,
                    1111,
                    602,
                    605,
                    606,
                    607,
                    2141,
                    609,
                    610,
                    612,
                    614,
                    2152,
                    2153,
                    620,
                    109,
                    2157,
                    112,
                    2160,
                    627,
                    2163,
                    2164,
                    630,
                    1142,
                    632,
                    633,
                    634,
                    2166,
                    124,
                    2168,
                    126,
                    1154,
                    1160,
                    140,
                    143,
                    145,
                    146,
                    149,
                    1689,
                    154,
                    668,
                    669,
                    158,
                    1696,
                    161,
                    164,
                    167,
                    168,
                    1703,
                    170,
                    682,
                    172,
                    1197,
                    1200,
                    1715,
                    180,
                    1204,
                    2229,
                    187,
                    189,
                    199,
                    201,
                    202,
                    203,
                    713,
                    719,
                    1233,
                    1745,
                    1746,
                    1237,
                    1749,
                    1750,
                    1752,
                    729,
                    736,
                    225,
                    230,
                    1254,
                    233,
                    237,
                    241,
                    242,
                    1266,
                    758,
                    247,
                    248,
                    249,
                    1271,
                    251,
                    1272,
                    2296,
                    256,
                    1792,
                    258,
                    1797,
                    1799,
                    264,
                    266,
                    1802,
                    1803,
                    270,
                    271,
                    782,
                    787,
                    790,
                    791,
                    281,
                    794,
                    284,
                    285,
                    1310,
                    799,
                    296,
                    300,
                    1326,
                    306,
                    311,
                    314,
                    318,
                    319,
                    1346,
                    843,
                    845,
                    338,
                    855,
                    345,
                    858,
                    1376,
                    353,
                    354,
                    865,
                    1377,
                    357,
                    1379,
                    1382,
                    360,
                    872,
                    362,
                    1385,
                    364,
                    1387,
                    1388,
                    881,
                    370,
                    882,
                    372,
                    373,
                    374,
                    883,
                    886,
                    887,
                    890,
                    1401,
                    893,
                    894,
                    1405,
                    1407,
                    898,
                    387,
                    1412,
                    390,
                    906,
                    395,
                    1418,
                    1422,
                    399,
                    912,
                    402,
                    1426,
                    411,
                    413,
                    938,
                    1967,
                    949,
                    950,
                    1974,
                    444,
                    956,
                    957,
                    961,
                    450,
                    1988,
                    454,
                    1992,
                    970,
                    463,
                    1999,
                    2006,
                    475,
                    987,
                    989,
                    991,
                    2015,
                    999,
                    489,
                    1008,
                    1010,
                    1015,
                    1017,
                    2045,
                    2047
                ],
                "self.name": [
                    296,
                    1160,
                    266,
                    938,
                    172,
                    109,
                    300,
                    271,
                    970,
                    1233,
                    1418,
                    2058,
                    281,
                    1052,
                    893,
                    799
                ],
                "self.obj": [
                    2051,
                    519,
                    1047,
                    2085,
                    557,
                    570,
                    573,
                    574,
                    575,
                    586,
                    1101,
                    1107,
                    1111,
                    602,
                    605,
                    606,
                    607,
                    609,
                    610,
                    614,
                    2153,
                    620,
                    109,
                    2157,
                    112,
                    2160,
                    627,
                    630,
                    1142,
                    632,
                    633,
                    634,
                    2168,
                    124,
                    126,
                    1154,
                    145,
                    154,
                    669,
                    158,
                    161,
                    164,
                    1703,
                    170,
                    1197,
                    1715,
                    2229,
                    199,
                    201,
                    713,
                    719,
                    1745,
                    1237,
                    736,
                    241,
                    242,
                    1266,
                    758,
                    248,
                    2296,
                    1799,
                    264,
                    270,
                    794,
                    285,
                    311,
                    314,
                    318,
                    319,
                    1346,
                    843,
                    338,
                    345,
                    1376,
                    353,
                    354,
                    865,
                    357,
                    360,
                    872,
                    1387,
                    364,
                    882,
                    370,
                    372,
                    373,
                    374,
                    1401,
                    890,
                    1405,
                    1412,
                    390,
                    1426,
                    411,
                    413,
                    1974,
                    444,
                    961,
                    450,
                    454,
                    463,
                    2006,
                    475,
                    989,
                    2015,
                    1010,
                    2039
                ],
                "self.obj._get_axis_number": [
                    112,
                    248,
                    882
                ],
                "new_self.axis": [
                    113
                ],
                "key": [
                    2053,
                    2054,
                    2058,
                    1052,
                    1055,
                    1061,
                    1062,
                    1063,
                    2085,
                    2091,
                    2092,
                    2094,
                    2095,
                    2097,
                    2098,
                    2099,
                    2102,
                    2103,
                    2107,
                    2108,
                    2112,
                    2114,
                    1099,
                    1103,
                    1105,
                    1106,
                    1110,
                    2144,
                    2147,
                    2148,
                    2152,
                    2153,
                    2156,
                    2157,
                    2160,
                    2162,
                    2163,
                    2164,
                    2166,
                    2167,
                    1144,
                    121,
                    2168,
                    124,
                    126,
                    1154,
                    1161,
                    140,
                    145,
                    146,
                    1682,
                    1685,
                    1688,
                    1689,
                    1696,
                    161,
                    1699,
                    168,
                    174,
                    178,
                    1715,
                    180,
                    2227,
                    2229,
                    184,
                    185,
                    1722,
                    189,
                    1725,
                    1727,
                    195,
                    1731,
                    2243,
                    198,
                    199,
                    1736,
                    201,
                    202,
                    1738,
                    1741,
                    1742,
                    1743,
                    1746,
                    1748,
                    1749,
                    1750,
                    1751,
                    1752,
                    1753,
                    1761,
                    1764,
                    229,
                    1765,
                    1772,
                    1780,
                    1781,
                    1782,
                    1784,
                    2296,
                    251,
                    1787,
                    1789,
                    2299,
                    255,
                    1792,
                    1795,
                    1796,
                    266,
                    1802,
                    1803,
                    271,
                    2326,
                    2327,
                    2329,
                    795,
                    796,
                    2332,
                    799,
                    1315,
                    2339,
                    1318,
                    1321,
                    1326,
                    1348,
                    1349,
                    1350,
                    2374,
                    1352,
                    1353,
                    2375,
                    331,
                    1356,
                    845,
                    846,
                    851,
                    1375,
                    1376,
                    353,
                    1377,
                    1379,
                    357,
                    1382,
                    1387,
                    371,
                    376,
                    1402,
                    1403,
                    904,
                    905,
                    906,
                    2459,
                    1950,
                    1951,
                    1952,
                    1964,
                    1966,
                    1967,
                    1968,
                    1972,
                    1973,
                    963,
                    965,
                    970,
                    1999,
                    2002,
                    985,
                    986,
                    987,
                    990,
                    991,
                    992,
                    993,
                    2015,
                    996,
                    999,
                    1003,
                    1005,
                    1008,
                    1015,
                    2040,
                    1017
                ],
                "com.apply_if_callable": [
                    1376,
                    199,
                    201,
                    1387,
                    2157,
                    2160,
                    145,
                    124
                ],
                "com": [
                    2054,
                    145,
                    1685,
                    665,
                    796,
                    1950,
                    1318,
                    551,
                    935,
                    2097,
                    822,
                    697,
                    1348,
                    965,
                    199,
                    201,
                    1356,
                    463,
                    1103,
                    1751,
                    1248,
                    1376,
                    1387,
                    2157,
                    2160,
                    124
                ],
                "x": [
                    1376,
                    199,
                    2157,
                    818,
                    822,
                    124
                ],
                "values": [
                    2016,
                    137,
                    138,
                    1715,
                    1716,
                    126,
                    2015
                ],
                "self.obj._get_value": [
                    2153,
                    1715,
                    126,
                    2015
                ],
                "InvalidIndexError": [
                    127
                ],
                "is_scalar": [
                    1700,
                    137,
                    974,
                    718,
                    2517
                ],
                "self._getitem_tuple": [
                    140,
                    1382
                ],
                "self.axis": [
                    167,
                    1385,
                    855,
                    143,
                    881,
                    882,
                    247,
                    248,
                    187,
                    956
                ],
                "self._getitem_axis": [
                    906,
                    1388,
                    146,
                    883,
                    957
                ],
                "self.ndim": [
                    256,
                    898,
                    1797,
                    264,
                    395,
                    2061,
                    270,
                    399,
                    912,
                    149,
                    668,
                    284,
                    1696,
                    682,
                    949,
                    585,
                    1999,
                    338,
                    729,
                    865,
                    612,
                    230,
                    2163,
                    2164,
                    249
                ],
                "self.obj._xs": [
                    154,
                    158
                ],
                "label": [
                    154,
                    155,
                    158
                ],
                "IndexingError": [
                    2048,
                    257,
                    195,
                    899,
                    869,
                    231,
                    2379,
                    940,
                    783,
                    1971,
                    181,
                    156
                ],
                "self.obj._ixs": [
                    161
                ],
                "self.obj._slice": [
                    164
                ],
                "obj": [
                    1412,
                    1414,
                    1416,
                    2325,
                    2332,
                    669,
                    413,
                    414,
                    1311,
                    2464,
                    2465,
                    2466,
                    164,
                    683,
                    428,
                    1199,
                    1200,
                    1204,
                    693,
                    441,
                    442,
                    443,
                    444,
                    1211,
                    1215,
                    961,
                    1217,
                    1218,
                    1219,
                    969,
                    970,
                    2121,
                    2122,
                    2124,
                    974,
                    2125,
                    2128,
                    2129,
                    979,
                    1235,
                    1237,
                    982,
                    1241,
                    2521,
                    1243,
                    1244,
                    1246,
                    1248,
                    1249,
                    1250,
                    1254,
                    1257,
                    1260,
                    1261,
                    1266,
                    1269
                ],
                "kind": [
                    164
                ],
                "self._convert_tuple": [
                    168,
                    180
                ],
                "ax": [
                    768,
                    775,
                    264,
                    1161,
                    266,
                    270,
                    271,
                    1048,
                    1179,
                    1052,
                    285,
                    1056,
                    1058,
                    293,
                    1061,
                    1063,
                    1064,
                    1703,
                    170,
                    1066,
                    172,
                    1704,
                    174,
                    1707,
                    693,
                    2229,
                    2230,
                    699,
                    2237,
                    713,
                    714,
                    716,
                    719,
                    721,
                    724,
                    2006,
                    2007,
                    736,
                    741,
                    743,
                    241,
                    242,
                    758,
                    759,
                    1142,
                    766
                ],
                "self.obj._get_axis": [
                    1346,
                    390,
                    264,
                    872,
                    170,
                    1101,
                    270,
                    719,
                    1197,
                    1745,
                    370,
                    2039,
                    1142,
                    1974,
                    1401,
                    890,
                    989
                ],
                "MultiIndex": [
                    993,
                    1217,
                    484,
                    1704,
                    172,
                    1006,
                    241,
                    1759,
                    1787,
                    2452,
                    1237,
                    1721,
                    411,
                    893,
                    766,
                    767
                ],
                "ax.get_loc": [
                    174
                ],
                "self._convert_to_indexer": [
                    258,
                    251,
                    189
                ],
                "e": [
                    193
                ],
                "indexer": [
                    384,
                    387,
                    1797,
                    1798,
                    1799,
                    1417,
                    1421,
                    398,
                    399,
                    654,
                    655,
                    402,
                    657,
                    404,
                    1422,
                    1426,
                    663,
                    280,
                    665,
                    283,
                    284,
                    285,
                    541,
                    415,
                    542,
                    417,
                    1052,
                    1054,
                    548,
                    549,
                    1055,
                    1056,
                    552,
                    1063,
                    682,
                    683,
                    1066,
                    557,
                    686,
                    687,
                    1069,
                    1071,
                    306,
                    564,
                    692,
                    567,
                    574,
                    449,
                    324,
                    326,
                    1992,
                    202,
                    203,
                    587,
                    718,
                    1110,
                    1112,
                    731,
                    735,
                    483,
                    2405,
                    360,
                    2408,
                    2410,
                    2412,
                    621,
                    2414,
                    757,
                    630,
                    758,
                    1272,
                    2425,
                    1271,
                    1148,
                    381,
                    1151
                ],
                "self._get_setitem_indexer": [
                    202
                ],
                "self._setitem_with_indexer": [
                    362,
                    203,
                    598
                ],
                "value": [
                    387,
                    515,
                    519,
                    521,
                    526,
                    401,
                    402,
                    532,
                    538,
                    423,
                    424,
                    425,
                    428,
                    557,
                    560,
                    436,
                    564,
                    566,
                    567,
                    443,
                    574,
                    321,
                    203,
                    2517,
                    598,
                    601,
                    2523,
                    348,
                    479,
                    353,
                    482,
                    357,
                    487,
                    362,
                    490,
                    618,
                    620,
                    621,
                    625,
                    627,
                    501,
                    630,
                    2167,
                    632,
                    505,
                    506
                ],
                "AbstractMethodError": [
                    225,
                    2141
                ],
                "Tuple": [
                    803,
                    227,
                    2043,
                    1994,
                    780,
                    878,
                    942,
                    240,
                    1390,
                    853,
                    827,
                    1691
                ],
                "i": [
                    256,
                    512,
                    258,
                    515,
                    2053,
                    904,
                    906,
                    2449,
                    915,
                    661,
                    918,
                    795,
                    924,
                    285,
                    286,
                    799,
                    289,
                    1699,
                    292,
                    293,
                    2297,
                    1703,
                    552,
                    553,
                    298,
                    692,
                    693,
                    2229,
                    2231,
                    2237,
                    963,
                    1731,
                    1732,
                    326,
                    338,
                    2002,
                    2006,
                    345,
                    735,
                    736,
                    229,
                    230,
                    233,
                    747,
                    370,
                    372,
                    2296,
                    249,
                    250,
                    255
                ],
                "k": [
                    258,
                    1699,
                    1700,
                    229,
                    233,
                    2449,
                    2002,
                    2003,
                    2451,
                    255
                ],
                "self._validate_key": [
                    233,
                    1802,
                    1099,
                    2128,
                    2098,
                    1749,
                    987
                ],
                "self._valid_types": [
                    1988,
                    237,
                    2133
                ],
                "self.obj.axes": [
                    736,
                    450,
                    1703,
                    360,
                    713,
                    241,
                    242,
                    2229,
                    2006,
                    2296,
                    345,
                    285
                ],
                "is_nested_tuple": [
                    1795,
                    242,
                    1243
                ],
                "tup": [
                    898,
                    2053,
                    904,
                    2316,
                    2317,
                    782,
                    2318,
                    2446,
                    2449,
                    787,
                    915,
                    790,
                    791,
                    918,
                    795,
                    818,
                    949,
                    822,
                    950,
                    957,
                    963,
                    846,
                    858,
                    865,
                    868,
                    873,
                    242,
                    883,
                    886,
                    887,
                    2045,
                    894,
                    2047
                ],
                "keyidx": [
                    259,
                    260,
                    246,
                    251,
                    253
                ],
                "keyidx.append": [
                    259,
                    251,
                    253
                ],
                "idx": [
                    258,
                    259,
                    2325,
                    2327,
                    665,
                    415,
                    417,
                    2337,
                    2339,
                    551,
                    552,
                    428,
                    692,
                    696,
                    697,
                    440,
                    443,
                    699,
                    326,
                    327,
                    331,
                    463,
                    464,
                    733,
                    740,
                    741,
                    749,
                    751,
                    754,
                    379
                ],
                "ax._convert_scalar_indexer": [
                    266
                ],
                "ax._convert_slice_indexer": [
                    271
                ],
                "_tuplify": [
                    2163,
                    284,
                    399
                ],
                "is_list_like_indexer": [
                    909,
                    1688,
                    2459,
                    289,
                    423,
                    1321,
                    818,
                    1972,
                    2102,
                    700,
                    1753,
                    348,
                    1246,
                    479,
                    992,
                    2147,
                    1260,
                    625,
                    757
                ],
                "is_integer": [
                    292,
                    549,
                    1005,
                    1966,
                    1010,
                    2003,
                    405,
                    2231,
                    2297,
                    1211,
                    2108,
                    2237
                ],
                "self._has_valid_setitem_indexer": [
                    306
                ],
                "info_axis": [
                    417,
                    449,
                    450,
                    548,
                    549,
                    390,
                    488,
                    553,
                    396,
                    557,
                    404,
                    311,
                    415
                ],
                "self.obj._info_axis_number": [
                    338,
                    311
                ],
                "take_split_path": [
                    393,
                    314,
                    322,
                    318
                ],
                "self.obj._is_mixed_type": [
                    314
                ],
                "self.obj._data.blocks": [
                    318,
                    319
                ],
                "self.obj._data": [
                    318,
                    606,
                    372,
                    632,
                    574,
                    319
                ],
                "blk": [
                    320,
                    322,
                    319
                ],
                "blk.ndim": [
                    320
                ],
                "val": [
                    321,
                    322,
                    775,
                    776,
                    752,
                    754,
                    755,
                    760
                ],
                "value.values": [
                    321
                ],
                "blk._can_hold_element": [
                    322
                ],
                "nindexer": [
                    376,
                    381,
                    379,
                    325
                ],
                "_": [
                    682,
                    331,
                    2316
                ],
                "convert_missing_indexer": [
                    384,
                    331
                ],
                "len_non_info_axes": [
                    344,
                    347
                ],
                "_ax": [
                    345
                ],
                "_i": [
                    2425,
                    345,
                    2423
                ],
                "l": [
                    347
                ],
                "_infer_fill_value": [
                    357
                ],
                "new_indexer": [
                    359,
                    362,
                    1066,
                    596,
                    597,
                    598
                ],
                "convert_from_missing_indexer_tuple": [
                    359
                ],
                "index": [
                    418,
                    2375,
                    2376,
                    586,
                    587,
                    2521,
                    370,
                    371,
                    595,
                    596,
                    2391,
                    440,
                    2393,
                    2525,
                    414
                ],
                "labels": [
                    512,
                    1795,
                    1796,
                    519,
                    1416,
                    521,
                    1417,
                    526,
                    1402,
                    532,
                    2452,
                    407,
                    537,
                    411,
                    412,
                    1197,
                    1721,
                    1210,
                    1722,
                    1725,
                    1215,
                    1217,
                    1218,
                    1346,
                    1732,
                    1349,
                    1350,
                    1353,
                    1101,
                    1105,
                    1362,
                    1745,
                    1364,
                    1237,
                    1366,
                    1746,
                    2517,
                    2520,
                    1243,
                    1244,
                    989,
                    1759,
                    993,
                    1249,
                    484,
                    486,
                    1257,
                    1003,
                    1006,
                    371,
                    372,
                    1014,
                    376,
                    1401,
                    506,
                    1787
                ],
                "index.insert": [
                    587,
                    371
                ],
                "_data": [
                    632,
                    372,
                    606
                ],
                "self.obj.reindex": [
                    372
                ],
                "self.obj._maybe_update_cacher": [
                    609,
                    373,
                    633,
                    575
                ],
                "self.obj._is_copy": [
                    374
                ],
                "nindexer.append": [
                    376,
                    379
                ],
                "labels.get_loc": [
                    376,
                    1257,
                    1215
                ],
                "missing": [
                    384,
                    386,
                    1148,
                    1150,
                    1151
                ],
                "self._setitem_with_indexer_missing": [
                    387
                ],
                "item_labels": [
                    555,
                    557,
                    390,
                    407
                ],
                "ABCSeries": [
                    1761,
                    2435,
                    2375,
                    618,
                    2479,
                    560,
                    401,
                    636
                ],
                "self._align_series": [
                    489,
                    402,
                    564
                ],
                "info_idx": [
                    404,
                    405,
                    406,
                    407
                ],
                "axes": [
                    411,
                    2423
                ],
                "item": [
                    512,
                    515,
                    454,
                    486,
                    487,
                    488,
                    490,
                    2521,
                    537,
                    495,
                    532,
                    533,
                    2520,
                    412,
                    538,
                    475,
                    444,
                    413
                ],
                "obj.index": [
                    2325,
                    414
                ],
                "plane_indexer": [
                    417,
                    418,
                    451,
                    449,
                    455,
                    519,
                    2517
                ],
                "lplane_indexer": [
                    418,
                    451,
                    519,
                    455,
                    425,
                    2527
                ],
                "length_of_indexer": [
                    418,
                    451
                ],
                "np.iterable": [
                    424,
                    2517
                ],
                "np": [
                    1761,
                    738,
                    2435,
                    2439,
                    424,
                    2346,
                    2508,
                    493,
                    654,
                    2095,
                    688,
                    2479,
                    2388,
                    501,
                    661,
                    1973,
                    2517,
                    505
                ],
                "ravel": [
                    436,
                    663
                ],
                "index._convert_slice_indexer": [
                    440
                ],
                "obj._consolidate_inplace": [
                    441
                ],
                "obj.copy": [
                    442,
                    1269,
                    1414
                ],
                "obj._data": [
                    443,
                    2332
                ],
                "obj._data.setitem": [
                    443
                ],
                "plane_axis": [
                    450,
                    451
                ],
                "s": [
                    454,
                    466,
                    469,
                    470,
                    471,
                    472,
                    475
                ],
                "pi": [
                    464,
                    471,
                    462,
                    455
                ],
                "com.is_null_slice": [
                    965,
                    2054,
                    551,
                    935,
                    463,
                    697,
                    665,
                    796
                ],
                "com.is_full_slice": [
                    463
                ],
                "v": [
                    489,
                    493,
                    495,
                    466,
                    532,
                    533,
                    471
                ],
                "s._consolidate_inplace": [
                    469
                ],
                "s.copy": [
                    470
                ],
                "s._data": [
                    471
                ],
                "s._data.setitem": [
                    471
                ],
                "s._maybe_update_cacher": [
                    472
                ],
                "ABCDataFrame": [
                    482,
                    1765,
                    566,
                    728,
                    923
                ],
                "sub_indexer": [
                    488,
                    490,
                    483
                ],
                "multiindex_indexer": [
                    490,
                    484,
                    686
                ],
                "np.nan": [
                    493
                ],
                "setter": [
                    515,
                    521,
                    495,
                    533,
                    538
                ],
                "np.ndim": [
                    501
                ],
                "np.array": [
                    505,
                    1973
                ],
                "value.shape": [
                    506
                ],
                "tolist": [
                    515
                ],
                "_can_do_equal_len": [
                    518
                ],
                "maybe_convert_ix": [
                    542
                ],
                "item_labels.is_unique": [
                    555
                ],
                "Series": [
                    601,
                    564,
                    630
                ],
                "self._align_frame": [
                    567
                ],
                "self.obj._check_is_chained_assignment_possible": [
                    570
                ],
                "self.obj._consolidate_inplace": [
                    573
                ],
                "self.obj._data.setitem": [
                    574
                ],
                "self.obj.index": [
                    865,
                    586,
                    1010,
                    758
                ],
                "new_index": [
                    587,
                    596,
                    607
                ],
                "index.is_unique": [
                    595
                ],
                "index.get_indexer": [
                    596
                ],
                "new_values": [
                    601,
                    605,
                    607
                ],
                "_values": [
                    707,
                    775,
                    683,
                    716,
                    752,
                    2384,
                    754,
                    724,
                    760,
                    601
                ],
                "self.obj._values": [
                    602,
                    605
                ],
                "concat_compat": [
                    605
                ],
                "self.obj._constructor": [
                    606
                ],
                "self.obj.name": [
                    607
                ],
                "self.obj.columns": [
                    630,
                    627,
                    620,
                    614
                ],
                "value.reindex": [
                    620
                ],
                "value.name": [
                    621
                ],
                "self.obj.append": [
                    632
                ],
                "np.ndarray": [
                    1761,
                    738,
                    2435,
                    2346,
                    654,
                    2479,
                    661
                ],
                "Index": [
                    2435,
                    868,
                    1352,
                    2346,
                    654,
                    2479,
                    1951,
                    701,
                    703
                ],
                "i.ravel": [
                    661
                ],
                "aligners": [
                    665,
                    666,
                    678
                ],
                "sum_aligners": [
                    682,
                    666,
                    667
                ],
                "single_aligner": [
                    697,
                    667,
                    710,
                    678
                ],
                "is_frame": [
                    729,
                    668,
                    677,
                    757
                ],
                "is_sequence": [
                    696,
                    737,
                    682
                ],
                "ser": [
                    704,
                    705,
                    707,
                    714,
                    683,
                    715,
                    716,
                    688,
                    721,
                    690,
                    722,
                    724
                ],
                "ser.reindex": [
                    724,
                    683,
                    716,
                    707
                ],
                "obj.axes": [
                    683,
                    693
                ],
                "len_indexer": [
                    688,
                    687
                ],
                "T": [
                    688
                ],
                "reshape": [
                    688
                ],
                "np.tile": [
                    688
                ],
                "new_ix": [
                    704,
                    707,
                    699,
                    700,
                    701,
                    703
                ],
                "ser.index.equals": [
                    704,
                    721,
                    714
                ],
                "ser.index": [
                    704,
                    721,
                    714
                ],
                "ser._values.copy": [
                    705,
                    722,
                    715
                ],
                "ser._values": [
                    705,
                    722,
                    715
                ],
                "cols": [
                    742,
                    743,
                    749,
                    751,
                    754,
                    733
                ],
                "sindexers": [
                    747,
                    734
                ],
                "ix": [
                    737,
                    738,
                    739,
                    741,
                    743,
                    735
                ],
                "ix.ravel": [
                    739
                ],
                "sindexers.append": [
                    747
                ],
                "df.index.equals": [
                    759,
                    751
                ],
                "df.index": [
                    767,
                    768,
                    759,
                    751
                ],
                "df": [
                    768,
                    775,
                    751,
                    752,
                    2511,
                    754,
                    759,
                    760,
                    767
                ],
                "df.columns.equals": [
                    751
                ],
                "df.columns": [
                    751
                ],
                "df.copy": [
                    752,
                    760
                ],
                "df.reindex": [
                    754,
                    775
                ],
                "ax.nlevels": [
                    768
                ],
                "df.index.nlevels": [
                    768
                ],
                "self._getitem_lowerdim": [
                    782,
                    2047
                ],
                "self._has_valid_tuple": [
                    787,
                    2045
                ],
                "self._multi_take_opportunity": [
                    790
                ],
                "self._multi_take": [
                    791
                ],
                "retval": [
                    801,
                    2051,
                    2058,
                    2061,
                    2069,
                    794,
                    799
                ],
                "_getitem_axis": [
                    970,
                    2058,
                    799
                ],
                "com.is_bool_indexer": [
                    1248,
                    1348,
                    1318,
                    1103,
                    2097,
                    1685,
                    822,
                    1751,
                    1950
                ],
                "o": [
                    843,
                    1069,
                    846,
                    848,
                    1047,
                    1048
                ],
                "d": [
                    848,
                    844
                ],
                "self._get_listlike_indexer": [
                    1254,
                    845,
                    1110
                ],
                "o._AXIS_ORDERS": [
                    846
                ],
                "o._reindex_with_indexers": [
                    848
                ],
                "self._get_label": [
                    1008,
                    1017,
                    858,
                    1803
                ],
                "self.obj.index.nlevels": [
                    865
                ],
                "ek": [
                    866
                ],
                "ax0": [
                    872,
                    873,
                    890,
                    893
                ],
                "ax0.is_lexsorted_for_tuple": [
                    873
                ],
                "e1": [
                    874
                ],
                "self._is_nested_tuple_indexer": [
                    886
                ],
                "self._getitem_nested_tuple": [
                    887
                ],
                "result": [
                    896,
                    2374,
                    2376,
                    2377,
                    2393,
                    2384,
                    2386,
                    2387,
                    2388,
                    950,
                    951,
                    952,
                    2391,
                    2396,
                    894,
                    895
                ],
                "self._handle_lowerdim_multi_index_axis0": [
                    950,
                    894
                ],
                "is_label_like": [
                    905
                ],
                "section": [
                    936,
                    906,
                    938,
                    909,
                    910,
                    912,
                    923
                ],
                "section.ndim": [
                    912
                ],
                "new_key": [
                    928,
                    930,
                    931,
                    1730,
                    1733,
                    935,
                    1735,
                    1736,
                    938,
                    915,
                    918,
                    925,
                    927
                ],
                "a": [
                    928,
                    2296,
                    927
                ],
                "b": [
                    928,
                    927
                ],
                "current_ndim": [
                    969,
                    979
                ],
                "obj.ndim": [
                    969,
                    979
                ],
                "is_iterator": [
                    985,
                    1742
                ],
                "self._get_slice_axis": [
                    2092,
                    1750,
                    991
                ],
                "key.ndim": [
                    1761,
                    996,
                    1789,
                    1772
                ],
                "self._getitem_iterable": [
                    1792,
                    999
                ],
                "labels._maybe_cast_indexer": [
                    1003
                ],
                "self.obj.index.levels": [
                    1010
                ],
                "labels.is_floating": [
                    1014
                ],
                "labels.is_integer": [
                    1210,
                    1364,
                    1014
                ],
                "self._get_loc": [
                    2114,
                    1015
                ],
                "o._get_axis": [
                    1048
                ],
                "keyarr": [
                    1368,
                    1064,
                    1353,
                    1066,
                    1356,
                    1069,
                    1358,
                    1071,
                    1362,
                    1365,
                    1110,
                    1366,
                    1112,
                    1052
                ],
                "ax._convert_listlike_indexer": [
                    1052
                ],
                "self._validate_read_indexer": [
                    1068,
                    1055
                ],
                "raise_missing": [
                    1160,
                    1069,
                    1055
                ],
                "ax.is_unique": [
                    1058,
                    1707,
                    2007
                ],
                "self._convert_for_reindex": [
                    1062
                ],
                "ax.get_indexer_for": [
                    1063
                ],
                "ax.reindex": [
                    1064
                ],
                "ax._reindex_non_unique": [
                    1066
                ],
                "o._get_axis_number": [
                    1069
                ],
                "check_bool_indexer": [
                    1105,
                    1402,
                    1349,
                    1249
                ],
                "inds": [
                    1250,
                    1251,
                    1106,
                    1107,
                    1403,
                    1405
                ],
                "key.nonzero": [
                    1106,
                    1403
                ],
                "self.obj.take": [
                    2085,
                    1426,
                    1107,
                    1405
                ],
                "self.obj._reindex_with_indexers": [
                    1111
                ],
                "self.obj._get_axis_name": [
                    1154
                ],
                "not_found": [
                    1161,
                    1162
                ],
                "_missing_key_warning": [
                    1170,
                    1180
                ],
                "textwrap.dedent": [
                    1170,
                    1299
                ],
                "textwrap": [
                    1170,
                    1299
                ],
                "ax.is_categorical": [
                    1179
                ],
                "ax.is_interval": [
                    1179
                ],
                "warnings.warn": [
                    1180,
                    1310
                ],
                "warnings": [
                    1180,
                    1310
                ],
                "self._convert_slice_indexer": [
                    1200,
                    2122,
                    1271
                ],
                "self._convert_scalar_indexer": [
                    1689,
                    1204,
                    2125,
                    1326
                ],
                "is_int_index": [
                    1210,
                    1211
                ],
                "is_int_positional": [
                    1224,
                    1211,
                    1228
                ],
                "labels.nlevels": [
                    1218
                ],
                "self.obj.shape": [
                    1237
                ],
                "labels.get_locs": [
                    1244,
                    1796
                ],
                "obj.nonzero": [
                    1250
                ],
                "need_slice": [
                    1268,
                    1413
                ],
                "slice_obj": [
                    1418,
                    1268,
                    1413,
                    1271
                ],
                "self._slice": [
                    1272,
                    1422
                ],
                "_NDFrameIndexer": [
                    1313,
                    1947,
                    1674,
                    1275,
                    1371
                ],
                "_ix_deprecation_warning": [
                    1299
                ],
                "self._ix_deprecation_warning": [
                    1310
                ],
                "__init__": [
                    1311
                ],
                "name": [
                    1311
                ],
                "Appender": [
                    1313,
                    1674
                ],
                "_NDFrameIndexer._validate_key.__doc__": [
                    1313,
                    1674
                ],
                "_NDFrameIndexer._validate_key": [
                    1313,
                    1674
                ],
                "labels._convert_index_indexer": [
                    1353
                ],
                "com.asarray_tuplesafe": [
                    1356
                ],
                "is_integer_dtype": [
                    1358
                ],
                "labels._convert_arr_indexer": [
                    1362
                ],
                "ensure_platform_int": [
                    1365
                ],
                "labels.take": [
                    1366
                ],
                "self._is_scalar_access": [
                    1377
                ],
                "self._getitem_scalar": [
                    1379
                ],
                "maybe_callable": [
                    1387,
                    1388
                ],
                "self._exception": [
                    1407
                ],
                "detail": [
                    1407
                ],
                "obj._get_axis": [
                    1416
                ],
                "labels.slice_indexer": [
                    1417
                ],
                "slice_obj.start": [
                    1418
                ],
                "slice_obj.stop": [
                    1418
                ],
                "slice_obj.step": [
                    1418
                ],
                "_LocationIndexer": [
                    1429,
                    1806
                ],
                "is_all_dates": [
                    1722,
                    1732
                ],
                "labels.levels": [
                    1722,
                    1732,
                    1725
                ],
                "component": [
                    1731,
                    1732,
                    1733,
                    1735
                ],
                "new_key.append": [
                    1733,
                    1735
                ],
                "item_from_zerodim": [
                    2107,
                    1741
                ],
                "self._get_partial_string_timestamp_match_key": [
                    1746
                ],
                "self._getbool_axis": [
                    1752,
                    2099
                ],
                "locs": [
                    1796,
                    1798
                ],
                "self.obj.iloc": [
                    1799
                ],
                "_get_slice_axis": [
                    1947
                ],
                "_NDFrameIndexer._get_slice_axis": [
                    1947
                ],
                "key.index": [
                    1952,
                    2375,
                    1951
                ],
                "key.index.inferred_type": [
                    1952
                ],
                "self._validate_integer": [
                    2112,
                    1967
                ],
                "arr": [
                    1977,
                    1979,
                    1973,
                    1983
                ],
                "len_axis": [
                    2040,
                    2039,
                    1974,
                    1983
                ],
                "is_numeric_dtype": [
                    1977
                ],
                "arr.dtype": [
                    1977
                ],
                "arr.max": [
                    1983
                ],
                "arr.min": [
                    1983
                ],
                "self._has_valid_positional_setitem_indexer": [
                    1992
                ],
                "retval.ndim": [
                    2061
                ],
                "np.asarray": [
                    2388,
                    2095
                ],
                "self._get_list_axis": [
                    2103
                ],
                "is_float": [
                    2124
                ],
                "self._convert_key": [
                    2152,
                    2166
                ],
                "self._takeable": [
                    2168,
                    2153
                ],
                "key.append": [
                    2167
                ],
                "self.obj._set_value": [
                    2168
                ],
                "_ScalarAccessIndexer": [
                    2171,
                    2246
                ],
                "_takeable": [
                    2218,
                    2292
                ],
                "is_setter": [
                    2226
                ],
                "ax.is_integer": [
                    2230
                ],
                "ax.holds_integer": [
                    2237
                ],
                "ndim": [
                    2316
                ],
                "loc": [
                    2317
                ],
                "idx._convert_slice_indexer": [
                    2327
                ],
                "obj._data.items": [
                    2332
                ],
                "idx.is_all_dates": [
                    2337
                ],
                "idx._get_string_slice": [
                    2339
                ],
                "key.index.equals": [
                    2375
                ],
                "result.reindex": [
                    2376
                ],
                "mask": [
                    2377,
                    2378
                ],
                "isna": [
                    2377
                ],
                "result._values": [
                    2377
                ],
                "mask.any": [
                    2378
                ],
                "result.astype": [
                    2384
                ],
                "is_sparse": [
                    2386
                ],
                "result.to_dense": [
                    2387
                ],
                "_idx": [
                    2425,
                    2423
                ],
                "get_loc": [
                    2423
                ],
                "get_indexer": [
                    2425
                ],
                "ixify": [
                    2433,
                    2436,
                    2438
                ],
                "args": [
                    2441,
                    2434,
                    2439
                ],
                "np.ix_": [
                    2439
                ],
                "is_list_like": [
                    2490,
                    2451,
                    2486
                ],
                "obj.start": [
                    2464
                ],
                "obj.stop": [
                    2465
                ],
                "obj.step": [
                    2466
                ],
                "kinds": [
                    2480,
                    2479
                ],
                "slice_": [
                    2496,
                    2498,
                    2499,
                    2507,
                    2511,
                    2480,
                    2481,
                    2512,
                    2490,
                    2491,
                    2493
                ],
                "part": [
                    2498,
                    2486,
                    2487
                ],
                "pred": [
                    2498
                ],
                "dtypes": [
                    2508,
                    2510,
                    2511
                ],
                "np.number": [
                    2508
                ],
                "include_bool": [
                    2509
                ],
                "dtypes.append": [
                    2510
                ],
                "columns": [
                    2511
                ],
                "df.select_dtypes": [
                    2511
                ],
                "values_len": [
                    2523,
                    2525,
                    2527
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_167/pandas/tests/indexes/datetimes/test_partial_slicing.py",
                "test_function": "test_slice_reduce_to_series",
                "test_function_code": "    def test_slice_reduce_to_series(self):\n        # GH 27516\n        df = pd.DataFrame(\n            {\"A\": range(24)}, index=pd.date_range(\"2000\", periods=24, freq=\"M\")\n        )\n        expected = pd.Series(\n            range(12), index=pd.date_range(\"2000\", periods=12, freq=\"M\"), name=\"A\"\n        )\n        result = df.loc[\"2000\", \"A\"]\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series Expected type <class 'pandas.core.series.Series'>, found <class 'numpy.ndarray'> instead",
                "full_test_error": "self = <pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing object at 0x120910130>\n\n    def test_slice_reduce_to_series(self):\n        # GH 27516\n        df = pd.DataFrame(\n            {\"A\": range(24)}, index=pd.date_range(\"2000\", periods=24, freq=\"M\")\n        )\n        expected = pd.Series(\n            range(12), index=pd.date_range(\"2000\", periods=12, freq=\"M\"), name=\"A\"\n        )\n        result = df.loc[\"2000\", \"A\"]\n>       tm.assert_series_equal(result, expected)\n\npandas/tests/indexes/datetimes/test_partial_slicing.py:481: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])\nright = 2000-01-31     0\n2000-02-29     1\n2000-03-31     2\n2000-04-30     3\n2000-05-31     4\n2000-06-30     5\n2000-07-31     6\n2000-08-31     7\n2000-09-30     8\n2000-10-31     9\n2000-11-30    10\n2000-12-31    11\nFreq: M, Name: A, dtype: int64\ncls = <class 'pandas.core.series.Series'>\n\n    def _check_isinstance(left, right, cls):\n        \"\"\"\n        Helper method for our assert_* methods that ensures that\n        the two objects being compared have the right type before\n        proceeding with the comparison.\n    \n        Parameters\n        ----------\n        left : The first object being compared.\n        right : The second object being compared.\n        cls : The class type to check against.\n    \n        Raises\n        ------\n        AssertionError : Either `left` or `right` is not an instance of `cls`.\n        \"\"\"\n    \n        err_msg = \"{name} Expected type {exp_type}, found {act_type} instead\"\n        cls_name = cls.__name__\n    \n        if not isinstance(left, cls):\n>           raise AssertionError(\n                err_msg.format(name=cls_name, exp_type=cls, act_type=type(left))\n            )\nE           AssertionError: Series Expected type <class 'pandas.core.series.Series'>, found <class 'numpy.ndarray'> instead\n\npandas/util/testing.py:391: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            }
        ]
    }
}