{
    "1.1.1": "def _try_convert_to_date(self, data):\n    \n    # no conversion on empty\n    if not len(data):\n        return data, False\n\n    new_data = data\n    if new_data.dtype == \"object\":\n        try:\n            new_data = data.astype(\"int64\")\n        except (TypeError, ValueError, OverflowError):\n            pass\n\n    # ignore numbers that are out of range\n    if issubclass(new_data.dtype.type, np.number):\n        in_range = (\n            isna(new_data._values)\n            | (new_data > self.min_stamp)\n            | (new_data._values == iNaT)\n        )\n        if not in_range.all():\n            return data, False\n\n    date_units = (self.date_unit,) if self.date_unit else self._STAMP_UNITS\n    for date_unit in date_units:\n        try:\n            new_data = to_datetime(new_data, errors=\"raise\", unit=date_unit)\n        except (ValueError, OverflowError):\n            continue\n        return new_data, True\n    return data, False\n",
    "1.1.2": "Try to parse a ndarray like into a date column.\n\nTry to coerce object in epoch/iso formats and integer/float in epoch\nformats. Return a boolean if parsing was successful.",
    "1.2.1": "class Parser()",
    "1.2.2": null,
    "1.2.3": null,
    "1.3.1": "/Volumes/JerrySSD/bgp_envs/repos/pandas_30/pandas/io/json/_json.py",
    "1.3.2": null,
    "1.4.1": [
        "    def test_readjson_bool_series(self):\n        # GH31464\n        result = read_json(\"[true, true, false]\", typ=\"series\")\n        expected = pd.Series([True, True, False])\n        tm.assert_series_equal(result, expected)"
    ],
    "1.4.2": [
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_30/pandas/tests/io/json/test_pandas.py"
    ],
    "2.1.1": [
        [
            "E   TypeError: <class 'bool'> is not convertible to datetime"
        ]
    ],
    "2.1.2": [
        [
            "self = <pandas.tests.io.json.test_pandas.TestPandasContainer object at 0x11b8fb670>\n\n    def test_readjson_bool_series(self):\n        # GH31464\n>       result = read_json(\"[true, true, false]\", typ=\"series\")\n\npandas/tests/io/json/test_pandas.py:1665: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:212: in wrapper\n    return func(*args, **kwargs)\npandas/util/_decorators.py:311: in wrapper\n    return func(*args, **kwargs)\npandas/io/json/_json.py:608: in read_json\n    result = json_reader.read()\npandas/io/json/_json.py:731: in read\n    obj = self._get_object_parser(self.data)\npandas/io/json/_json.py:758: in _get_object_parser\n    obj = SeriesParser(json, **kwargs).parse()\npandas/io/json/_json.py:863: in parse\n    self._try_convert_types()\npandas/io/json/_json.py:1031: in _try_convert_types\n    obj, result = self._try_convert_data(\npandas/io/json/_json.py:903: in _try_convert_data\n    new_data, result = self._try_convert_to_date(data)\npandas/io/json/_json.py:984: in _try_convert_to_date\n    new_data = to_datetime(new_data, errors=\"raise\", unit=date_unit)\npandas/core/tools/datetimes.py:747: in to_datetime\n    values = convert_listlike(arg._values, format)\npandas/core/tools/datetimes.py:329: in _convert_listlike_datetimes\n    result, tz_parsed = tslib.array_with_unit_to_datetime(\npandas/_libs/tslib.pyx:405: in pandas._libs.tslib.array_with_unit_to_datetime\n    result, tz = array_to_datetime(values.astype(object), errors=errors)\npandas/_libs/tslib.pyx:760: in pandas._libs.tslib.array_to_datetime\n    return array_to_datetime_object(values, errors, dayfirst, yearfirst)\npandas/_libs/tslib.pyx:899: in pandas._libs.tslib.array_to_datetime_object\n    raise\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>   raise TypeError(f\"{type(val)} is not convertible to datetime\")",
            "\npandas/_libs/tslib.pyx:733: TypeError"
        ]
    ],
    "2.1.3": [
        [
            {
                "data": "RangeIndex(start=0, stop=3, step=1)",
                "data.astype": "<bound method Index.astype of RangeIndex(start=0, stop=3, step=1)>",
                "self.min_stamp": "31536000",
                "self": "<pandas.io.json._json.SeriesParser object at 0x1161c97c0>",
                "self._STAMP_UNITS": "('s', 'ms', 'us', 'ns')"
            },
            {
                "new_data": "RangeIndex(start=0, stop=3, step=1)",
                "new_data.dtype": "dtype('int64')",
                "in_range": "array([False, False, False])",
                "new_data._values": "array([0, 1, 2])"
            }
        ]
    ],
    "2.1.4": [
        [
            {
                "data": "RangeIndex",
                "data.astype": "method",
                "self.min_stamp": "int",
                "self": "SeriesParser",
                "self._STAMP_UNITS": "tuple"
            },
            {
                "new_data": "RangeIndex",
                "new_data.dtype": "dtype",
                "in_range": "ndarray",
                "new_data._values": "ndarray"
            }
        ]
    ],
    "2.1.5": [
        [
            {
                "data": "RangeIndex(start=0, stop=3, step=1)",
                "data.astype": "<bound method Index.astype of RangeIndex(start=0, stop=3, step=1)>",
                "self.min_stamp": "31536000",
                "self": "<pandas.io.json._json.SeriesParser object at 0x112ae6c10>",
                "self._STAMP_UNITS": "('s', 'ms', 'us', 'ns')"
            },
            {
                "new_data": "RangeIndex(start=0, stop=3, step=1)",
                "new_data.dtype": "dtype('int64')",
                "in_range": "array([False, False, False])",
                "new_data._values": "array([0, 1, 2])"
            }
        ],
        [
            {
                "data": "0     True\n1     True\n2    False\ndtype: bool",
                "data.astype": "<bound method NDFrame.astype of 0     True\n1     True\n2    False\ndtype: bool>",
                "self.min_stamp": "31536000",
                "self": "<pandas.io.json._json.SeriesParser object at 0x112ae6c10>",
                "self._STAMP_UNITS": "('s', 'ms', 'us', 'ns')"
            },
            {
                "new_data": "0     True\n1     True\n2    False\ndtype: bool",
                "new_data.dtype": "dtype('bool')",
                "new_data._values": "array([ True,  True, False])",
                "date_units": "('s', 'ms', 'us', 'ns')",
                "date_unit": "'ns'"
            }
        ]
    ],
    "2.1.6": [
        [
            {
                "data": "RangeIndex",
                "data.astype": "method",
                "self.min_stamp": "int",
                "self": "SeriesParser",
                "self._STAMP_UNITS": "tuple"
            },
            {
                "new_data": "RangeIndex",
                "new_data.dtype": "dtype",
                "in_range": "ndarray",
                "new_data._values": "ndarray"
            }
        ],
        [
            {
                "data": "Series",
                "data.astype": "method",
                "self.min_stamp": "int",
                "self": "SeriesParser",
                "self._STAMP_UNITS": "tuple"
            },
            {
                "new_data": "Series",
                "new_data.dtype": "dtype",
                "new_data._values": "ndarray",
                "date_units": "tuple",
                "date_unit": "str"
            }
        ]
    ],
    "3.1.1": null,
    "3.1.2": null
}