The issue description is:

```text
Code Sample, a copy-pastable example if possible
import pandas as pd

# broken after pandas 0.23.4 if only "a" is replaced
def return_replace(initial):
	return initial.replace({"a": 1.0, "b": 0.0})

# working
def return_replace_just_one(initial):
	return initial.replace({"a": 1.0})

# the following should all be float64
print("problem:", return_replace(pd.DataFrame(["a"])).dtypes[0])
print("works:", return_replace(pd.DataFrame(["b"])).dtypes[0])
print("works:", return_replace_just_one(pd.DataFrame(["a"])).dtypes[0])
print("works:", return_replace(pd.DataFrame(["a", "b"])).dtypes[0])
Problem description
The behaviour shown above is inconsistent and hard to spot. In my case, it broke one of my tests due to mismatching types (as I was expecting a float64).
The problem seems to involve a regression when upgrading from pandas 0.23.4 to any later version (tested with 0.24.0, 0.24.1 and 0.24.2, all of which have the same issue).
Returning back to the old behaviour of changing the type also in the first case where it fails above (i.e. changing the type whenever possible?) would be more consistent and not require a manual type definition.

This is probably related to #23305.

Expected Output
problem: float64
works: float64
works: float64
works: float64
```
