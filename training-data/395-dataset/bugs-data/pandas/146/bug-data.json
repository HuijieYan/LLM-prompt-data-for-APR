{
    "pandas:146": {
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_146/pandas/core/dtypes/missing.py": {
            "buggy_functions": [
                {
                    "function_name": "array_equivalent",
                    "function_code": "def array_equivalent(left, right, strict_nan=False):\n    \"\"\"\n    True if two arrays, left and right, have equal non-NaN elements, and NaNs\n    in corresponding locations.  False otherwise. It is assumed that left and\n    right are NumPy arrays of the same dtype. The behavior of this function\n    (particularly with respect to NaNs) is not defined if the dtypes are\n    different.\n\n    Parameters\n    ----------\n    left, right : ndarrays\n    strict_nan : bool, default False\n        If True, consider NaN and None to be different.\n\n    Returns\n    -------\n    b : bool\n        Returns True if the arrays are equivalent.\n\n    Examples\n    --------\n    >>> array_equivalent(\n    ...     np.array([1, 2, np.nan]),\n    ...     np.array([1, 2, np.nan]))\n    True\n    >>> array_equivalent(\n    ...     np.array([1, np.nan, 2]),\n    ...     np.array([1, 2, np.nan]))\n    False\n    \"\"\"\n\n    left, right = np.asarray(left), np.asarray(right)\n\n    # shape compat\n    if left.shape != right.shape:\n        return False\n\n    # Object arrays can contain None, NaN and NaT.\n    # string dtypes must be come to this path for NumPy 1.7.1 compat\n    if is_string_dtype(left) or is_string_dtype(right):\n\n        if not strict_nan:\n            # isna considers NaN and None to be equivalent.\n            return lib.array_equivalent_object(\n                ensure_object(left.ravel()), ensure_object(right.ravel())\n            )\n\n        for left_value, right_value in zip(left, right):\n            if left_value is NaT and right_value is not NaT:\n                return False\n\n            elif isinstance(left_value, float) and np.isnan(left_value):\n                if not isinstance(right_value, float) or not np.isnan(right_value):\n                    return False\n            else:\n                if np.any(left_value != right_value):\n                    return False\n        return True\n\n    # NaNs can occur in float and complex arrays.\n    if is_float_dtype(left) or is_complex_dtype(left):\n\n        # empty\n        if not (np.prod(left.shape) and np.prod(right.shape)):\n            return True\n        return ((left == right) | (isna(left) & isna(right))).all()\n\n    # numpy will will not allow this type of datetimelike vs integer comparison\n    elif is_datetimelike_v_numeric(left, right):\n        return False\n\n    # M8/m8\n    elif needs_i8_conversion(left) and needs_i8_conversion(right):\n        if not is_dtype_equal(left.dtype, right.dtype):\n            return False\n\n        left = left.view(\"i8\")\n        right = right.view(\"i8\")\n\n    # if we have structured dtypes, compare first\n    if left.dtype.type is np.void or right.dtype.type is np.void:\n        if left.dtype != right.dtype:\n            return False\n\n    return np.array_equal(left, right)\n",
                    "decorators": [],
                    "docstring": "True if two arrays, left and right, have equal non-NaN elements, and NaNs\nin corresponding locations.  False otherwise. It is assumed that left and\nright are NumPy arrays of the same dtype. The behavior of this function\n(particularly with respect to NaNs) is not defined if the dtypes are\ndifferent.\n\nParameters\n----------\nleft, right : ndarrays\nstrict_nan : bool, default False\n    If True, consider NaN and None to be different.\n\nReturns\n-------\nb : bool\n    Returns True if the arrays are equivalent.\n\nExamples\n--------\n>>> array_equivalent(\n...     np.array([1, 2, np.nan]),\n...     np.array([1, 2, np.nan]))\nTrue\n>>> array_equivalent(\n...     np.array([1, np.nan, 2]),\n...     np.array([1, 2, np.nan]))\nFalse",
                    "start_line": 393,
                    "end_line": 477,
                    "variables": {
                        "left": [
                            453,
                            424,
                            456,
                            458,
                            427,
                            461,
                            432,
                            465,
                            466,
                            437,
                            469,
                            440,
                            473,
                            474,
                            477
                        ],
                        "right": [
                            424,
                            456,
                            458,
                            427,
                            461,
                            432,
                            465,
                            466,
                            437,
                            470,
                            440,
                            473,
                            474,
                            477
                        ],
                        "np.asarray": [
                            424
                        ],
                        "np": [
                            448,
                            477,
                            424,
                            456,
                            473,
                            444,
                            445
                        ],
                        "left.shape": [
                            456,
                            427
                        ],
                        "right.shape": [
                            456,
                            427
                        ],
                        "is_string_dtype": [
                            432
                        ],
                        "strict_nan": [
                            434
                        ],
                        "lib.array_equivalent_object": [
                            436
                        ],
                        "lib": [
                            436
                        ],
                        "ensure_object": [
                            437
                        ],
                        "left.ravel": [
                            437
                        ],
                        "right.ravel": [
                            437
                        ],
                        "left_value": [
                            440,
                            441,
                            444,
                            448
                        ],
                        "right_value": [
                            440,
                            441,
                            445,
                            448
                        ],
                        "zip": [
                            440
                        ],
                        "NaT": [
                            441
                        ],
                        "isinstance": [
                            444,
                            445
                        ],
                        "float": [
                            444,
                            445
                        ],
                        "np.isnan": [
                            444,
                            445
                        ],
                        "np.any": [
                            448
                        ],
                        "is_float_dtype": [
                            453
                        ],
                        "is_complex_dtype": [
                            453
                        ],
                        "np.prod": [
                            456
                        ],
                        "all": [
                            458
                        ],
                        "isna": [
                            458
                        ],
                        "is_datetimelike_v_numeric": [
                            461
                        ],
                        "needs_i8_conversion": [
                            465
                        ],
                        "is_dtype_equal": [
                            466
                        ],
                        "left.dtype": [
                            473,
                            466,
                            474
                        ],
                        "right.dtype": [
                            473,
                            466,
                            474
                        ],
                        "left.view": [
                            469
                        ],
                        "right.view": [
                            470
                        ],
                        "left.dtype.type": [
                            473
                        ],
                        "np.void": [
                            473
                        ],
                        "right.dtype.type": [
                            473
                        ],
                        "np.array_equal": [
                            477
                        ]
                    },
                    "filtered_variables": {
                        "left": [
                            453,
                            424,
                            456,
                            458,
                            427,
                            461,
                            432,
                            465,
                            466,
                            437,
                            469,
                            440,
                            473,
                            474,
                            477
                        ],
                        "right": [
                            424,
                            456,
                            458,
                            427,
                            461,
                            432,
                            465,
                            466,
                            437,
                            470,
                            440,
                            473,
                            474,
                            477
                        ],
                        "np.asarray": [
                            424
                        ],
                        "np": [
                            448,
                            477,
                            424,
                            456,
                            473,
                            444,
                            445
                        ],
                        "left.shape": [
                            456,
                            427
                        ],
                        "right.shape": [
                            456,
                            427
                        ],
                        "is_string_dtype": [
                            432
                        ],
                        "strict_nan": [
                            434
                        ],
                        "lib.array_equivalent_object": [
                            436
                        ],
                        "lib": [
                            436
                        ],
                        "ensure_object": [
                            437
                        ],
                        "left.ravel": [
                            437
                        ],
                        "right.ravel": [
                            437
                        ],
                        "left_value": [
                            440,
                            441,
                            444,
                            448
                        ],
                        "right_value": [
                            440,
                            441,
                            445,
                            448
                        ],
                        "NaT": [
                            441
                        ],
                        "np.isnan": [
                            444,
                            445
                        ],
                        "np.any": [
                            448
                        ],
                        "is_float_dtype": [
                            453
                        ],
                        "is_complex_dtype": [
                            453
                        ],
                        "np.prod": [
                            456
                        ],
                        "isna": [
                            458
                        ],
                        "is_datetimelike_v_numeric": [
                            461
                        ],
                        "needs_i8_conversion": [
                            465
                        ],
                        "is_dtype_equal": [
                            466
                        ],
                        "left.dtype": [
                            473,
                            466,
                            474
                        ],
                        "right.dtype": [
                            473,
                            466,
                            474
                        ],
                        "left.view": [
                            469
                        ],
                        "right.view": [
                            470
                        ],
                        "left.dtype.type": [
                            473
                        ],
                        "np.void": [
                            473
                        ],
                        "right.dtype.type": [
                            473
                        ],
                        "np.array_equal": [
                            477
                        ]
                    },
                    "diff_line_number": 448,
                    "class_data": null,
                    "variable_values": [
                        [
                            {
                                "left": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 40, 352243)], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:40.352282+0000', tz='UTC')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x115f5e620>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x115f5e5d0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x115f5e620>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x115f5e5d0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 40, 352243)], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:40.352282+0000', tz='UTC')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x115f5e620>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x115f5e5d0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": "datetime.datetime(2023, 12, 11, 19, 48, 40, 352243)",
                                    "variable_type": "datetime",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": "Timestamp('2023-12-11 19:48:40.352282+0000', tz='UTC')",
                                    "variable_type": "Timestamp",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x115f5e620>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x115f5e5d0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 40, 352243)], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:40.352282+0000', tz='UTC')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x115f5e620>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x115f5e5d0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x115f5e620>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x115f5e5d0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 40, 352243)], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:40.352282+0000', tz='UTC')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x115f5e620>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x115f5e5d0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x115f5e620>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x115f5e5d0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left": {
                                    "variable_value": "array([numpy.datetime64('2023-12-11T19:48:40.352243000')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 40, 352282, tzinfo=<UTC>)],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x115f12990>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x115f12c60>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x115f12990>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x115f12c60>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left": {
                                    "variable_value": "array([numpy.datetime64('2023-12-11T19:48:40.352243000')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 40, 352282, tzinfo=<UTC>)],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x115f12990>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x115f12c60>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": "numpy.datetime64('2023-12-11T19:48:40.352243000')",
                                    "variable_type": "datetime64",
                                    "variable_shape": "()"
                                },
                                "right_value": {
                                    "variable_value": "datetime.datetime(2023, 12, 11, 19, 48, 40, 352282, tzinfo=<UTC>)",
                                    "variable_type": "datetime",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x115f12990>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x115f12c60>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left": {
                                    "variable_value": "array([numpy.datetime64('2023-12-11T19:48:40.352243000')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 40, 352282, tzinfo=<UTC>)],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x115f12990>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x115f12c60>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x115f12990>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x115f12c60>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left": {
                                    "variable_value": "array([numpy.datetime64('2023-12-11T19:48:40.352243000')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 40, 352282, tzinfo=<UTC>)],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x115f12990>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x115f12c60>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x115f12990>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x115f12c60>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 40, 352243)], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 40, 352282, tzinfo=<UTC>)],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x1072bd7b0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x1072bd4e0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x1072bd7b0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x1072bd4e0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 40, 352243)], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 40, 352282, tzinfo=<UTC>)],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x1072bd7b0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x1072bd4e0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": "datetime.datetime(2023, 12, 11, 19, 48, 40, 352243)",
                                    "variable_type": "datetime",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": "datetime.datetime(2023, 12, 11, 19, 48, 40, 352282, tzinfo=<UTC>)",
                                    "variable_type": "datetime",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x1072bd7b0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x1072bd4e0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 40, 352243)], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 40, 352282, tzinfo=<UTC>)],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x1072bd7b0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x1072bd4e0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x1072bd7b0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x1072bd4e0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 40, 352243)], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 40, 352282, tzinfo=<UTC>)],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x1072bd7b0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x1072bd4e0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x1072bd7b0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x1072bd4e0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "left": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681232')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681378+0000', tz='UTC')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x1238273a0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x1238273f0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x1238273a0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x1238273f0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681232')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681378+0000', tz='UTC')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x1238273a0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x1238273f0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": "Timestamp('2023-12-11 19:48:47.681232')",
                                    "variable_type": "Timestamp",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": "Timestamp('2023-12-11 19:48:47.681378+0000', tz='UTC')",
                                    "variable_type": "Timestamp",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": "TypeError('Cannot compare tz-naive and tz-aware timestamps')",
                                    "variable_type": "TypeError",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x1238273a0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x1238273f0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681232')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681378+0000', tz='UTC')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x1238273a0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x1238273f0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x1238273a0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x1238273f0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681232')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681378+0000', tz='UTC')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x1238273a0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x1238273f0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x1238273a0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x1238273f0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left": {
                                    "variable_value": "array([numpy.datetime64('2023-12-11T19:48:47.681232000')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681378+0000', tz='UTC')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827490>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x1238277b0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827490>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x1238277b0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left": {
                                    "variable_value": "array([numpy.datetime64('2023-12-11T19:48:47.681232000')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681378+0000', tz='UTC')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827490>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x1238277b0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": "numpy.datetime64('2023-12-11T19:48:47.681232000')",
                                    "variable_type": "datetime64",
                                    "variable_shape": "()"
                                },
                                "right_value": {
                                    "variable_value": "Timestamp('2023-12-11 19:48:47.681378+0000', tz='UTC')",
                                    "variable_type": "Timestamp",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": "TypeError('Cannot compare tz-naive and tz-aware timestamps')",
                                    "variable_type": "TypeError",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827490>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x1238277b0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left": {
                                    "variable_value": "array([numpy.datetime64('2023-12-11T19:48:47.681232000')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681378+0000', tz='UTC')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827490>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x1238277b0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827490>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x1238277b0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left": {
                                    "variable_value": "array([numpy.datetime64('2023-12-11T19:48:47.681232000')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681378+0000', tz='UTC')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827490>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x1238277b0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827490>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x1238277b0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 47, 681232)], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681378+0000', tz='UTC')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827e40>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827df0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827e40>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827df0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 47, 681232)], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681378+0000', tz='UTC')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827e40>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827df0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": "datetime.datetime(2023, 12, 11, 19, 48, 47, 681232)",
                                    "variable_type": "datetime",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": "Timestamp('2023-12-11 19:48:47.681378+0000', tz='UTC')",
                                    "variable_type": "Timestamp",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827e40>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827df0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 47, 681232)], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681378+0000', tz='UTC')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827e40>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827df0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827e40>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827df0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 47, 681232)], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681378+0000', tz='UTC')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827e40>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827df0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827e40>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827df0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681232')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681378+0000', tz='UTC')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827bc0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827c10>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827bc0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827c10>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681232')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681378+0000', tz='UTC')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827bc0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827c10>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": "Timestamp('2023-12-11 19:48:47.681232')",
                                    "variable_type": "Timestamp",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": "Timestamp('2023-12-11 19:48:47.681378+0000', tz='UTC')",
                                    "variable_type": "Timestamp",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": "TypeError('Cannot compare tz-naive and tz-aware timestamps')",
                                    "variable_type": "TypeError",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827bc0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827c10>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681232')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681378+0000', tz='UTC')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827bc0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827c10>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827bc0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827c10>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681232')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([Timestamp('2023-12-11 19:48:47.681378+0000', tz='UTC')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827bc0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827c10>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827bc0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827c10>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left": {
                                    "variable_value": "array([numpy.datetime64('2023-12-11T19:48:47.681232000')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 47, 681378, tzinfo=<UTC>)],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827080>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827800>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827080>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827800>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left": {
                                    "variable_value": "array([numpy.datetime64('2023-12-11T19:48:47.681232000')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 47, 681378, tzinfo=<UTC>)],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827080>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827800>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": "numpy.datetime64('2023-12-11T19:48:47.681232000')",
                                    "variable_type": "datetime64",
                                    "variable_shape": "()"
                                },
                                "right_value": {
                                    "variable_value": "datetime.datetime(2023, 12, 11, 19, 48, 47, 681378, tzinfo=<UTC>)",
                                    "variable_type": "datetime",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827080>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827800>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left": {
                                    "variable_value": "array([numpy.datetime64('2023-12-11T19:48:47.681232000')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 47, 681378, tzinfo=<UTC>)],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827080>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827800>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827080>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827800>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left": {
                                    "variable_value": "array([numpy.datetime64('2023-12-11T19:48:47.681232000')], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 47, 681378, tzinfo=<UTC>)],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827080>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827800>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827080>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827800>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 47, 681232)], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 47, 681378, tzinfo=<UTC>)],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827530>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827850>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827530>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827850>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 47, 681232)], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 47, 681378, tzinfo=<UTC>)],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827530>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827850>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": "datetime.datetime(2023, 12, 11, 19, 48, 47, 681232)",
                                    "variable_type": "datetime",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": "datetime.datetime(2023, 12, 11, 19, 48, 47, 681378, tzinfo=<UTC>)",
                                    "variable_type": "datetime",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827530>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827850>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 47, 681232)], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 47, 681378, tzinfo=<UTC>)],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827530>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827850>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827530>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827850>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 47, 681232)], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "right": {
                                    "variable_value": "array([datetime.datetime(2023, 12, 11, 19, 48, 47, 681378, tzinfo=<UTC>)],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "right.shape": {
                                    "variable_value": "(1,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "strict_nan": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.array_equivalent_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827530>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.ravel": {
                                    "variable_value": "<built-in method ravel of numpy.ndarray object at 0x123827850>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "err": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_complex_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.prod": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetimelike_v_numeric": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "needs_i8_conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "left.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "left.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827530>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "right.view": {
                                    "variable_value": "<built-in method view of numpy.ndarray object at 0x123827850>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "left.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.void": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.array_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def isna(obj):\n    \"\"\"\n    Detect missing values for an array-like object.\n\n    This function takes a scalar or array-like object and indicates\n    whether values are missing (``NaN`` in numeric arrays, ``None`` or ``NaN``\n    in object arrays, ``NaT`` in datetimelike).\n\n    Parameters\n    ----------\n    obj : scalar or array-like\n        Object to check for null or missing values.\n\n    Returns\n    -------\n    bool or array-like of bool\n        For scalar input, returns a scalar boolean.\n        For array input, returns an array of boolean indicating whether each\n        corresponding element is missing.\n\n    See Also\n    --------\n    notna : Boolean inverse of pandas.isna.\n    Series.isna : Detect missing values in a Series.\n    DataFrame.isna : Detect missing values in a DataFrame.\n    Index.isna : Detect missing values in an Index.\n\n    Examples\n    --------\n    Scalar arguments (including strings) result in a scalar boolean.\n\n    >>> pd.isna('dog')\n    False\n\n    >>> pd.isna(np.nan)\n    True\n\n    ndarrays result in an ndarray of booleans.\n\n    >>> array = np.array([[1, np.nan, 3], [4, 5, np.nan]])\n    >>> array\n    array([[ 1., nan,  3.],\n           [ 4.,  5., nan]])\n    >>> pd.isna(array)\n    array([[False,  True, False],\n           [False, False,  True]])\n\n    For indexes, an ndarray of booleans is returned.\n\n    >>> index = pd.DatetimeIndex([\"2017-07-05\", \"2017-07-06\", None,\n    ...                           \"2017-07-08\"])\n    >>> index\n    DatetimeIndex(['2017-07-05', '2017-07-06', 'NaT', '2017-07-08'],\n                  dtype='datetime64[ns]', freq=None)\n    >>> pd.isna(index)\n    array([False, False,  True, False])\n\n    For Series and DataFrame, the same type is returned, containing booleans.\n\n    >>> df = pd.DataFrame([['ant', 'bee', 'cat'], ['dog', None, 'fly']])\n    >>> df\n         0     1    2\n    0  ant   bee  cat\n    1  dog  None  fly\n    >>> pd.isna(df)\n           0      1      2\n    0  False  False  False\n    1  False   True  False\n\n    >>> pd.isna(df[1])\n    0    False\n    1     True\n    Name: 1, dtype: bool\n    \"\"\"\n    return _isna(obj)",
                "def _isna_new(obj):\n    if is_scalar(obj):\n        return libmissing.checknull(obj)\n    # hack (for now) because MI registers as ndarray\n    elif isinstance(obj, ABCMultiIndex):\n        raise NotImplementedError(\"isna is not defined for MultiIndex\")\n    elif isinstance(obj, type):\n        return False\n    elif isinstance(\n        obj,\n        (\n            ABCSeries,\n            np.ndarray,\n            ABCIndexClass,\n            ABCExtensionArray,\n            ABCDatetimeArray,\n            ABCTimedeltaArray,\n        ),\n    ):\n        return _isna_ndarraylike(obj)\n    elif isinstance(obj, ABCGeneric):\n        return obj._constructor(obj._data.isna(func=isna))\n    elif isinstance(obj, list):\n        return _isna_ndarraylike(np.asarray(obj, dtype=object))\n    elif hasattr(obj, \"__array__\"):\n        return _isna_ndarraylike(np.asarray(obj))\n    else:\n        return obj is None",
                "def _isna_old(obj):\n    \"\"\"Detect missing values. Treat None, NaN, INF, -INF as null.\n\n    Parameters\n    ----------\n    arr: ndarray or object value\n\n    Returns\n    -------\n    boolean ndarray or boolean\n    \"\"\"\n    if is_scalar(obj):\n        return libmissing.checknull_old(obj)\n    # hack (for now) because MI registers as ndarray\n    elif isinstance(obj, ABCMultiIndex):\n        raise NotImplementedError(\"isna is not defined for MultiIndex\")\n    elif isinstance(obj, type):\n        return False\n    elif isinstance(obj, (ABCSeries, np.ndarray, ABCIndexClass)):\n        return _isna_ndarraylike_old(obj)\n    elif isinstance(obj, ABCGeneric):\n        return obj._constructor(obj._data.isna(func=_isna_old))\n    elif isinstance(obj, list):\n        return _isna_ndarraylike_old(np.asarray(obj, dtype=object))\n    elif hasattr(obj, \"__array__\"):\n        return _isna_ndarraylike_old(np.asarray(obj))\n    else:\n        return obj is None",
                "def _use_inf_as_na(key):\n    \"\"\"Option change callback for na/inf behaviour\n    Choose which replacement for numpy.isnan / -numpy.isfinite is used.\n\n    Parameters\n    ----------\n    flag: bool\n        True means treat None, NaN, INF, -INF as null (old way),\n        False means None and NaN are null, but INF, -INF are not null\n        (new way).\n\n    Notes\n    -----\n    This approach to setting global module values is discussed and\n    approved here:\n\n    * http://stackoverflow.com/questions/4859217/\n      programmatically-creating-variables-in-python/4859312#4859312\n    \"\"\"\n    flag = get_option(key)\n    if flag:\n        globals()[\"_isna\"] = _isna_old\n    else:\n        globals()[\"_isna\"] = _isna_new",
                "def _isna_ndarraylike(obj):\n    is_extension = is_extension_array_dtype(obj)\n\n    if not is_extension:\n        # Avoid accessing `.values` on things like\n        # PeriodIndex, which may be expensive.\n        values = getattr(obj, \"values\", obj)\n    else:\n        values = obj\n\n    dtype = values.dtype\n\n    if is_extension:\n        if isinstance(obj, (ABCIndexClass, ABCSeries)):\n            values = obj._values\n        else:\n            values = obj\n        result = values.isna()\n    elif isinstance(obj, ABCDatetimeArray):\n        return obj.isna()\n    elif is_string_dtype(dtype):\n        # Working around NumPy ticket 1542\n        shape = values.shape\n\n        if is_string_like_dtype(dtype):\n            # object array of strings\n            result = np.zeros(values.shape, dtype=bool)\n        else:\n            # object array of non-strings\n            result = np.empty(shape, dtype=bool)\n            vec = libmissing.isnaobj(values.ravel())\n            result[...] = vec.reshape(shape)\n\n    elif needs_i8_conversion(dtype):\n        # this is the NaT pattern\n        result = values.view(\"i8\") == iNaT\n    else:\n        result = np.isnan(values)\n\n    # box\n    if isinstance(obj, ABCSeries):\n        result = obj._constructor(result, index=obj.index, name=obj.name, copy=False)\n\n    return result",
                "def _isna_ndarraylike_old(obj):\n    values = getattr(obj, \"values\", obj)\n    dtype = values.dtype\n\n    if is_string_dtype(dtype):\n        # Working around NumPy ticket 1542\n        shape = values.shape\n\n        if is_string_like_dtype(dtype):\n            result = np.zeros(values.shape, dtype=bool)\n        else:\n            result = np.empty(shape, dtype=bool)\n            vec = libmissing.isnaobj_old(values.ravel())\n            result[:] = vec.reshape(shape)\n\n    elif is_datetime64_dtype(dtype):\n        # this is the NaT pattern\n        result = values.view(\"i8\") == iNaT\n    else:\n        result = ~np.isfinite(values)\n\n    # box\n    if isinstance(obj, ABCSeries):\n        result = obj._constructor(result, index=obj.index, name=obj.name, copy=False)\n\n    return result",
                "def notna(obj):\n    \"\"\"\n    Detect non-missing values for an array-like object.\n\n    This function takes a scalar or array-like object and indicates\n    whether values are valid (not missing, which is ``NaN`` in numeric\n    arrays, ``None`` or ``NaN`` in object arrays, ``NaT`` in datetimelike).\n\n    Parameters\n    ----------\n    obj : array-like or object value\n        Object to check for *not* null or *non*-missing values.\n\n    Returns\n    -------\n    bool or array-like of bool\n        For scalar input, returns a scalar boolean.\n        For array input, returns an array of boolean indicating whether each\n        corresponding element is valid.\n\n    See Also\n    --------\n    isna : Boolean inverse of pandas.notna.\n    Series.notna : Detect valid values in a Series.\n    DataFrame.notna : Detect valid values in a DataFrame.\n    Index.notna : Detect valid values in an Index.\n\n    Examples\n    --------\n    Scalar arguments (including strings) result in a scalar boolean.\n\n    >>> pd.notna('dog')\n    True\n\n    >>> pd.notna(np.nan)\n    False\n\n    ndarrays result in an ndarray of booleans.\n\n    >>> array = np.array([[1, np.nan, 3], [4, 5, np.nan]])\n    >>> array\n    array([[ 1., nan,  3.],\n           [ 4.,  5., nan]])\n    >>> pd.notna(array)\n    array([[ True, False,  True],\n           [ True,  True, False]])\n\n    For indexes, an ndarray of booleans is returned.\n\n    >>> index = pd.DatetimeIndex([\"2017-07-05\", \"2017-07-06\", None,\n    ...                          \"2017-07-08\"])\n    >>> index\n    DatetimeIndex(['2017-07-05', '2017-07-06', 'NaT', '2017-07-08'],\n                  dtype='datetime64[ns]', freq=None)\n    >>> pd.notna(index)\n    array([ True,  True, False,  True])\n\n    For Series and DataFrame, the same type is returned, containing booleans.\n\n    >>> df = pd.DataFrame([['ant', 'bee', 'cat'], ['dog', None, 'fly']])\n    >>> df\n         0     1    2\n    0  ant   bee  cat\n    1  dog  None  fly\n    >>> pd.notna(df)\n          0      1     2\n    0  True   True  True\n    1  True  False  True\n\n    >>> pd.notna(df[1])\n    0     True\n    1    False\n    Name: 1, dtype: bool\n    \"\"\"\n    res = isna(obj)\n    if is_scalar(res):\n        return not res\n    return ~res",
                "def _isna_compat(arr, fill_value=np.nan):\n    \"\"\"\n    Parameters\n    ----------\n    arr: a numpy array\n    fill_value: fill value, default to np.nan\n\n    Returns\n    -------\n    True if we can fill using this fill_value\n    \"\"\"\n    dtype = arr.dtype\n    if isna(fill_value):\n        return not (is_bool_dtype(dtype) or is_integer_dtype(dtype))\n    return True",
                "def array_equivalent(left, right, strict_nan=False):\n    \"\"\"\n    True if two arrays, left and right, have equal non-NaN elements, and NaNs\n    in corresponding locations.  False otherwise. It is assumed that left and\n    right are NumPy arrays of the same dtype. The behavior of this function\n    (particularly with respect to NaNs) is not defined if the dtypes are\n    different.\n\n    Parameters\n    ----------\n    left, right : ndarrays\n    strict_nan : bool, default False\n        If True, consider NaN and None to be different.\n\n    Returns\n    -------\n    b : bool\n        Returns True if the arrays are equivalent.\n\n    Examples\n    --------\n    >>> array_equivalent(\n    ...     np.array([1, 2, np.nan]),\n    ...     np.array([1, 2, np.nan]))\n    True\n    >>> array_equivalent(\n    ...     np.array([1, np.nan, 2]),\n    ...     np.array([1, 2, np.nan]))\n    False\n    \"\"\"\n\n    left, right = np.asarray(left), np.asarray(right)\n\n    # shape compat\n    if left.shape != right.shape:\n        return False\n\n    # Object arrays can contain None, NaN and NaT.\n    # string dtypes must be come to this path for NumPy 1.7.1 compat\n    if is_string_dtype(left) or is_string_dtype(right):\n\n        if not strict_nan:\n            # isna considers NaN and None to be equivalent.\n            return lib.array_equivalent_object(\n                ensure_object(left.ravel()), ensure_object(right.ravel())\n            )\n\n        for left_value, right_value in zip(left, right):\n            if left_value is NaT and right_value is not NaT:\n                return False\n\n            elif isinstance(left_value, float) and np.isnan(left_value):\n                if not isinstance(right_value, float) or not np.isnan(right_value):\n                    return False\n            else:\n                if np.any(left_value != right_value):\n                    return False\n        return True\n\n    # NaNs can occur in float and complex arrays.\n    if is_float_dtype(left) or is_complex_dtype(left):\n\n        # empty\n        if not (np.prod(left.shape) and np.prod(right.shape)):\n            return True\n        return ((left == right) | (isna(left) & isna(right))).all()\n\n    # numpy will will not allow this type of datetimelike vs integer comparison\n    elif is_datetimelike_v_numeric(left, right):\n        return False\n\n    # M8/m8\n    elif needs_i8_conversion(left) and needs_i8_conversion(right):\n        if not is_dtype_equal(left.dtype, right.dtype):\n            return False\n\n        left = left.view(\"i8\")\n        right = right.view(\"i8\")\n\n    # if we have structured dtypes, compare first\n    if left.dtype.type is np.void or right.dtype.type is np.void:\n        if left.dtype != right.dtype:\n            return False\n\n    return np.array_equal(left, right)",
                "def _infer_fill_value(val):\n    \"\"\"\n    infer the fill value for the nan/NaT from the provided\n    scalar/ndarray/list-like if we are a NaT, return the correct dtyped\n    element to provide proper block construction\n    \"\"\"\n\n    if not is_list_like(val):\n        val = [val]\n    val = np.array(val, copy=False)\n    if is_datetimelike(val):\n        return np.array(\"NaT\", dtype=val.dtype)\n    elif is_object_dtype(val.dtype):\n        dtype = lib.infer_dtype(ensure_object(val), skipna=False)\n        if dtype in [\"datetime\", \"datetime64\"]:\n            return np.array(\"NaT\", dtype=_NS_DTYPE)\n        elif dtype in [\"timedelta\", \"timedelta64\"]:\n            return np.array(\"NaT\", dtype=_TD_DTYPE)\n    return np.nan",
                "def _maybe_fill(arr, fill_value=np.nan):\n    \"\"\"\n    if we have a compatible fill_value and arr dtype, then fill\n    \"\"\"\n    if _isna_compat(arr, fill_value):\n        arr.fill(fill_value)\n    return arr",
                "def na_value_for_dtype(dtype, compat=True):\n    \"\"\"\n    Return a dtype compat na value\n\n    Parameters\n    ----------\n    dtype : string / dtype\n    compat : boolean, default True\n\n    Returns\n    -------\n    np.dtype or a pandas dtype\n\n    Examples\n    --------\n    >>> na_value_for_dtype(np.dtype('int64'))\n    0\n    >>> na_value_for_dtype(np.dtype('int64'), compat=False)\n    nan\n    >>> na_value_for_dtype(np.dtype('float64'))\n    nan\n    >>> na_value_for_dtype(np.dtype('bool'))\n    False\n    >>> na_value_for_dtype(np.dtype('datetime64[ns]'))\n    NaT\n    \"\"\"\n    dtype = pandas_dtype(dtype)\n\n    if is_extension_array_dtype(dtype):\n        return dtype.na_value\n    if (\n        is_datetime64_dtype(dtype)\n        or is_datetime64tz_dtype(dtype)\n        or is_timedelta64_dtype(dtype)\n        or is_period_dtype(dtype)\n    ):\n        return NaT\n    elif is_float_dtype(dtype):\n        return np.nan\n    elif is_integer_dtype(dtype):\n        if compat:\n            return 0\n        return np.nan\n    elif is_bool_dtype(dtype):\n        return False\n    return np.nan",
                "def remove_na_arraylike(arr):\n    \"\"\"\n    Return array-like containing only true/non-NaN values, possibly empty.\n    \"\"\"\n    if is_extension_array_dtype(arr):\n        return arr[notna(arr)]\n    else:\n        return arr[notna(lib.values_from_object(arr))]",
                "def is_valid_nat_for_dtype(obj, dtype):\n    \"\"\"\n    isna check that excludes incompatible dtypes\n\n    Parameters\n    ----------\n    obj : object\n    dtype : np.datetime64, np.timedelta64, DatetimeTZDtype, or PeriodDtype\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    if not lib.is_scalar(obj) or not isna(obj):\n        return False\n    if dtype.kind == \"M\":\n        return not isinstance(obj, np.timedelta64)\n    if dtype.kind == \"m\":\n        return not isinstance(obj, np.datetime64)\n\n    # must be PeriodDType\n    return not isinstance(obj, (np.datetime64, np.timedelta64))"
            ],
            "inscope_function_signatures": [
                "isna(obj)",
                "_isna_new(obj)",
                "_isna_old(obj)",
                "_use_inf_as_na(key)",
                "_isna_ndarraylike(obj)",
                "_isna_ndarraylike_old(obj)",
                "notna(obj)",
                "_isna_compat(arr, fill_value=np.nan)",
                "array_equivalent(left, right, strict_nan=False)",
                "_infer_fill_value(val)",
                "_maybe_fill(arr, fill_value=np.nan)",
                "na_value_for_dtype(dtype, compat=True)",
                "remove_na_arraylike(arr)",
                "is_valid_nat_for_dtype(obj, dtype)"
            ],
            "variables_in_file": {
                "isposinf_scalar": [
                    46
                ],
                "libmissing.isposinf_scalar": [
                    46
                ],
                "libmissing": [
                    132,
                    172,
                    46,
                    47,
                    277,
                    249
                ],
                "isneginf_scalar": [
                    47
                ],
                "libmissing.isneginf_scalar": [
                    47
                ],
                "_isna": [
                    124,
                    190
                ],
                "obj": [
                    131,
                    132,
                    259,
                    134,
                    260,
                    136,
                    266,
                    139,
                    149,
                    150,
                    151,
                    152,
                    153,
                    154,
                    155,
                    157,
                    287,
                    288,
                    171,
                    172,
                    174,
                    176,
                    178,
                    179,
                    180,
                    181,
                    182,
                    183,
                    184,
                    185,
                    187,
                    581,
                    584,
                    586,
                    589,
                    220,
                    225,
                    227,
                    232,
                    233,
                    235,
                    237,
                    238,
                    367,
                    124
                ],
                "isnull": [
                    127
                ],
                "isna": [
                    388,
                    581,
                    458,
                    367,
                    151,
                    127
                ],
                "is_scalar": [
                    368,
                    131,
                    171
                ],
                "libmissing.checknull": [
                    132
                ],
                "isinstance": [
                    259,
                    134,
                    136,
                    138,
                    150,
                    152,
                    287,
                    174,
                    176,
                    178,
                    180,
                    182,
                    444,
                    445,
                    584,
                    586,
                    589,
                    232,
                    237
                ],
                "ABCMultiIndex": [
                    174,
                    134
                ],
                "NotImplementedError": [
                    175,
                    135
                ],
                "type": [
                    136,
                    176
                ],
                "ABCSeries": [
                    259,
                    232,
                    141,
                    178,
                    287
                ],
                "np.ndarray": [
                    178,
                    142
                ],
                "np": [
                    256,
                    142,
                    274,
                    276,
                    153,
                    155,
                    284,
                    548,
                    424,
                    552,
                    555,
                    178,
                    183,
                    185,
                    444,
                    445,
                    448,
                    456,
                    584,
                    586,
                    589,
                    473,
                    477,
                    248,
                    489,
                    491,
                    495,
                    497,
                    498,
                    245,
                    501,
                    376
                ],
                "ABCIndexClass": [
                    232,
                    178,
                    143
                ],
                "ABCExtensionArray": [
                    144
                ],
                "ABCDatetimeArray": [
                    145,
                    237
                ],
                "ABCTimedeltaArray": [
                    146
                ],
                "_isna_ndarraylike": [
                    153,
                    155,
                    149
                ],
                "ABCGeneric": [
                    180,
                    150
                ],
                "obj._constructor": [
                    288,
                    260,
                    181,
                    151
                ],
                "obj._data.isna": [
                    181,
                    151
                ],
                "obj._data": [
                    181,
                    151
                ],
                "list": [
                    152,
                    182
                ],
                "np.asarray": [
                    153,
                    424,
                    183,
                    185,
                    155
                ],
                "object": [
                    153,
                    183
                ],
                "hasattr": [
                    184,
                    154
                ],
                "libmissing.checknull_old": [
                    172
                ],
                "_isna_ndarraylike_old": [
                    185,
                    179,
                    183
                ],
                "_isna_old": [
                    181,
                    214
                ],
                "_isna_new": [
                    216,
                    190
                ],
                "flag": [
                    212,
                    213
                ],
                "get_option": [
                    212
                ],
                "key": [
                    212
                ],
                "globals": [
                    216,
                    214
                ],
                "is_extension": [
                    220,
                    222,
                    231
                ],
                "is_extension_array_dtype": [
                    538,
                    220,
                    562
                ],
                "values": [
                    256,
                    225,
                    227,
                    229,
                    233,
                    266,
                    235,
                    236,
                    267,
                    271,
                    241,
                    274,
                    245,
                    277,
                    249,
                    282,
                    284,
                    254
                ],
                "getattr": [
                    225,
                    266
                ],
                "dtype": [
                    387,
                    389,
                    267,
                    269,
                    273,
                    536,
                    280,
                    538,
                    539,
                    541,
                    542,
                    543,
                    544,
                    547,
                    549,
                    553,
                    583,
                    585,
                    229,
                    493,
                    494,
                    239,
                    496,
                    243,
                    252
                ],
                "values.dtype": [
                    267,
                    229
                ],
                "obj._values": [
                    233
                ],
                "result": [
                    256,
                    288,
                    290,
                    260,
                    262,
                    282,
                    236,
                    274,
                    276,
                    245,
                    278,
                    248,
                    250,
                    284,
                    254
                ],
                "values.isna": [
                    236
                ],
                "obj.isna": [
                    238
                ],
                "is_string_dtype": [
                    432,
                    269,
                    239
                ],
                "shape": [
                    271,
                    241,
                    276,
                    278,
                    248,
                    250
                ],
                "values.shape": [
                    241,
                    274,
                    245,
                    271
                ],
                "is_string_like_dtype": [
                    273,
                    243
                ],
                "np.zeros": [
                    274,
                    245
                ],
                "bool": [
                    248,
                    274,
                    276,
                    245
                ],
                "np.empty": [
                    248,
                    276
                ],
                "vec": [
                    249,
                    250,
                    277,
                    278
                ],
                "libmissing.isnaobj": [
                    249
                ],
                "values.ravel": [
                    249,
                    277
                ],
                "vec.reshape": [
                    250,
                    278
                ],
                "needs_i8_conversion": [
                    465,
                    252
                ],
                "values.view": [
                    282,
                    254
                ],
                "iNaT": [
                    282,
                    254
                ],
                "np.isnan": [
                    256,
                    444,
                    445
                ],
                "obj.index": [
                    288,
                    260
                ],
                "obj.name": [
                    288,
                    260
                ],
                "libmissing.isnaobj_old": [
                    277
                ],
                "is_datetime64_dtype": [
                    280,
                    541
                ],
                "np.isfinite": [
                    284
                ],
                "res": [
                    368,
                    369,
                    370,
                    367
                ],
                "notnull": [
                    373
                ],
                "notna": [
                    565,
                    563,
                    373
                ],
                "np.nan": [
                    548,
                    552,
                    555,
                    498,
                    501,
                    376
                ],
                "arr.dtype": [
                    387
                ],
                "arr": [
                    387,
                    562,
                    563,
                    565,
                    505,
                    506,
                    507
                ],
                "fill_value": [
                    505,
                    506,
                    388
                ],
                "is_bool_dtype": [
                    553,
                    389
                ],
                "is_integer_dtype": [
                    549,
                    389
                ],
                "left": [
                    453,
                    424,
                    456,
                    458,
                    427,
                    461,
                    432,
                    465,
                    466,
                    437,
                    469,
                    440,
                    473,
                    474,
                    477
                ],
                "right": [
                    424,
                    456,
                    458,
                    427,
                    461,
                    432,
                    465,
                    466,
                    437,
                    470,
                    440,
                    473,
                    474,
                    477
                ],
                "left.shape": [
                    456,
                    427
                ],
                "right.shape": [
                    456,
                    427
                ],
                "strict_nan": [
                    434
                ],
                "lib.array_equivalent_object": [
                    436
                ],
                "lib": [
                    581,
                    565,
                    436,
                    493
                ],
                "ensure_object": [
                    493,
                    437
                ],
                "left.ravel": [
                    437
                ],
                "right.ravel": [
                    437
                ],
                "left_value": [
                    440,
                    441,
                    444,
                    448
                ],
                "right_value": [
                    440,
                    441,
                    445,
                    448
                ],
                "zip": [
                    440
                ],
                "NaT": [
                    441,
                    546
                ],
                "float": [
                    444,
                    445
                ],
                "np.any": [
                    448
                ],
                "is_float_dtype": [
                    547,
                    453
                ],
                "is_complex_dtype": [
                    453
                ],
                "np.prod": [
                    456
                ],
                "all": [
                    458
                ],
                "is_datetimelike_v_numeric": [
                    461
                ],
                "is_dtype_equal": [
                    466
                ],
                "left.dtype": [
                    473,
                    466,
                    474
                ],
                "right.dtype": [
                    473,
                    466,
                    474
                ],
                "left.view": [
                    469
                ],
                "right.view": [
                    470
                ],
                "left.dtype.type": [
                    473
                ],
                "np.void": [
                    473
                ],
                "right.dtype.type": [
                    473
                ],
                "np.array_equal": [
                    477
                ],
                "is_list_like": [
                    487
                ],
                "val": [
                    487,
                    488,
                    489,
                    490,
                    491,
                    492,
                    493
                ],
                "np.array": [
                    489,
                    491,
                    497,
                    495
                ],
                "is_datetimelike": [
                    490
                ],
                "val.dtype": [
                    491,
                    492
                ],
                "is_object_dtype": [
                    492
                ],
                "lib.infer_dtype": [
                    493
                ],
                "_NS_DTYPE": [
                    495
                ],
                "_TD_DTYPE": [
                    497
                ],
                "_isna_compat": [
                    505
                ],
                "arr.fill": [
                    506
                ],
                "pandas_dtype": [
                    536
                ],
                "dtype.na_value": [
                    539
                ],
                "is_datetime64tz_dtype": [
                    542
                ],
                "is_timedelta64_dtype": [
                    543
                ],
                "is_period_dtype": [
                    544
                ],
                "compat": [
                    550
                ],
                "lib.values_from_object": [
                    565
                ],
                "lib.is_scalar": [
                    581
                ],
                "dtype.kind": [
                    585,
                    583
                ],
                "np.timedelta64": [
                    584,
                    589
                ],
                "np.datetime64": [
                    586,
                    589
                ]
            },
            "filtered_variables_in_file": {
                "isposinf_scalar": [
                    46
                ],
                "libmissing.isposinf_scalar": [
                    46
                ],
                "libmissing": [
                    132,
                    172,
                    46,
                    47,
                    277,
                    249
                ],
                "isneginf_scalar": [
                    47
                ],
                "libmissing.isneginf_scalar": [
                    47
                ],
                "_isna": [
                    124,
                    190
                ],
                "obj": [
                    131,
                    132,
                    259,
                    134,
                    260,
                    136,
                    266,
                    139,
                    149,
                    150,
                    151,
                    152,
                    153,
                    154,
                    155,
                    157,
                    287,
                    288,
                    171,
                    172,
                    174,
                    176,
                    178,
                    179,
                    180,
                    181,
                    182,
                    183,
                    184,
                    185,
                    187,
                    581,
                    584,
                    586,
                    589,
                    220,
                    225,
                    227,
                    232,
                    233,
                    235,
                    237,
                    238,
                    367,
                    124
                ],
                "isnull": [
                    127
                ],
                "isna": [
                    388,
                    581,
                    458,
                    367,
                    151,
                    127
                ],
                "is_scalar": [
                    368,
                    131,
                    171
                ],
                "libmissing.checknull": [
                    132
                ],
                "ABCMultiIndex": [
                    174,
                    134
                ],
                "ABCSeries": [
                    259,
                    232,
                    141,
                    178,
                    287
                ],
                "np.ndarray": [
                    178,
                    142
                ],
                "np": [
                    256,
                    142,
                    274,
                    276,
                    153,
                    155,
                    284,
                    548,
                    424,
                    552,
                    555,
                    178,
                    183,
                    185,
                    444,
                    445,
                    448,
                    456,
                    584,
                    586,
                    589,
                    473,
                    477,
                    248,
                    489,
                    491,
                    495,
                    497,
                    498,
                    245,
                    501,
                    376
                ],
                "ABCIndexClass": [
                    232,
                    178,
                    143
                ],
                "ABCExtensionArray": [
                    144
                ],
                "ABCDatetimeArray": [
                    145,
                    237
                ],
                "ABCTimedeltaArray": [
                    146
                ],
                "_isna_ndarraylike": [
                    153,
                    155,
                    149
                ],
                "ABCGeneric": [
                    180,
                    150
                ],
                "obj._constructor": [
                    288,
                    260,
                    181,
                    151
                ],
                "obj._data.isna": [
                    181,
                    151
                ],
                "obj._data": [
                    181,
                    151
                ],
                "np.asarray": [
                    153,
                    424,
                    183,
                    185,
                    155
                ],
                "libmissing.checknull_old": [
                    172
                ],
                "_isna_ndarraylike_old": [
                    185,
                    179,
                    183
                ],
                "_isna_old": [
                    181,
                    214
                ],
                "_isna_new": [
                    216,
                    190
                ],
                "flag": [
                    212,
                    213
                ],
                "get_option": [
                    212
                ],
                "key": [
                    212
                ],
                "is_extension": [
                    220,
                    222,
                    231
                ],
                "is_extension_array_dtype": [
                    538,
                    220,
                    562
                ],
                "values": [
                    256,
                    225,
                    227,
                    229,
                    233,
                    266,
                    235,
                    236,
                    267,
                    271,
                    241,
                    274,
                    245,
                    277,
                    249,
                    282,
                    284,
                    254
                ],
                "dtype": [
                    387,
                    389,
                    267,
                    269,
                    273,
                    536,
                    280,
                    538,
                    539,
                    541,
                    542,
                    543,
                    544,
                    547,
                    549,
                    553,
                    583,
                    585,
                    229,
                    493,
                    494,
                    239,
                    496,
                    243,
                    252
                ],
                "values.dtype": [
                    267,
                    229
                ],
                "obj._values": [
                    233
                ],
                "result": [
                    256,
                    288,
                    290,
                    260,
                    262,
                    282,
                    236,
                    274,
                    276,
                    245,
                    278,
                    248,
                    250,
                    284,
                    254
                ],
                "values.isna": [
                    236
                ],
                "obj.isna": [
                    238
                ],
                "is_string_dtype": [
                    432,
                    269,
                    239
                ],
                "shape": [
                    271,
                    241,
                    276,
                    278,
                    248,
                    250
                ],
                "values.shape": [
                    241,
                    274,
                    245,
                    271
                ],
                "is_string_like_dtype": [
                    273,
                    243
                ],
                "np.zeros": [
                    274,
                    245
                ],
                "np.empty": [
                    248,
                    276
                ],
                "vec": [
                    249,
                    250,
                    277,
                    278
                ],
                "libmissing.isnaobj": [
                    249
                ],
                "values.ravel": [
                    249,
                    277
                ],
                "vec.reshape": [
                    250,
                    278
                ],
                "needs_i8_conversion": [
                    465,
                    252
                ],
                "values.view": [
                    282,
                    254
                ],
                "iNaT": [
                    282,
                    254
                ],
                "np.isnan": [
                    256,
                    444,
                    445
                ],
                "obj.index": [
                    288,
                    260
                ],
                "obj.name": [
                    288,
                    260
                ],
                "libmissing.isnaobj_old": [
                    277
                ],
                "is_datetime64_dtype": [
                    280,
                    541
                ],
                "np.isfinite": [
                    284
                ],
                "res": [
                    368,
                    369,
                    370,
                    367
                ],
                "notnull": [
                    373
                ],
                "notna": [
                    565,
                    563,
                    373
                ],
                "np.nan": [
                    548,
                    552,
                    555,
                    498,
                    501,
                    376
                ],
                "arr.dtype": [
                    387
                ],
                "arr": [
                    387,
                    562,
                    563,
                    565,
                    505,
                    506,
                    507
                ],
                "fill_value": [
                    505,
                    506,
                    388
                ],
                "is_bool_dtype": [
                    553,
                    389
                ],
                "is_integer_dtype": [
                    549,
                    389
                ],
                "left": [
                    453,
                    424,
                    456,
                    458,
                    427,
                    461,
                    432,
                    465,
                    466,
                    437,
                    469,
                    440,
                    473,
                    474,
                    477
                ],
                "right": [
                    424,
                    456,
                    458,
                    427,
                    461,
                    432,
                    465,
                    466,
                    437,
                    470,
                    440,
                    473,
                    474,
                    477
                ],
                "left.shape": [
                    456,
                    427
                ],
                "right.shape": [
                    456,
                    427
                ],
                "strict_nan": [
                    434
                ],
                "lib.array_equivalent_object": [
                    436
                ],
                "lib": [
                    581,
                    565,
                    436,
                    493
                ],
                "ensure_object": [
                    493,
                    437
                ],
                "left.ravel": [
                    437
                ],
                "right.ravel": [
                    437
                ],
                "left_value": [
                    440,
                    441,
                    444,
                    448
                ],
                "right_value": [
                    440,
                    441,
                    445,
                    448
                ],
                "NaT": [
                    441,
                    546
                ],
                "np.any": [
                    448
                ],
                "is_float_dtype": [
                    547,
                    453
                ],
                "is_complex_dtype": [
                    453
                ],
                "np.prod": [
                    456
                ],
                "is_datetimelike_v_numeric": [
                    461
                ],
                "is_dtype_equal": [
                    466
                ],
                "left.dtype": [
                    473,
                    466,
                    474
                ],
                "right.dtype": [
                    473,
                    466,
                    474
                ],
                "left.view": [
                    469
                ],
                "right.view": [
                    470
                ],
                "left.dtype.type": [
                    473
                ],
                "np.void": [
                    473
                ],
                "right.dtype.type": [
                    473
                ],
                "np.array_equal": [
                    477
                ],
                "is_list_like": [
                    487
                ],
                "val": [
                    487,
                    488,
                    489,
                    490,
                    491,
                    492,
                    493
                ],
                "np.array": [
                    489,
                    491,
                    497,
                    495
                ],
                "is_datetimelike": [
                    490
                ],
                "val.dtype": [
                    491,
                    492
                ],
                "is_object_dtype": [
                    492
                ],
                "lib.infer_dtype": [
                    493
                ],
                "_NS_DTYPE": [
                    495
                ],
                "_TD_DTYPE": [
                    497
                ],
                "_isna_compat": [
                    505
                ],
                "arr.fill": [
                    506
                ],
                "pandas_dtype": [
                    536
                ],
                "dtype.na_value": [
                    539
                ],
                "is_datetime64tz_dtype": [
                    542
                ],
                "is_timedelta64_dtype": [
                    543
                ],
                "is_period_dtype": [
                    544
                ],
                "compat": [
                    550
                ],
                "lib.values_from_object": [
                    565
                ],
                "lib.is_scalar": [
                    581
                ],
                "dtype.kind": [
                    585,
                    583
                ],
                "np.timedelta64": [
                    584,
                    589
                ],
                "np.datetime64": [
                    586,
                    589
                ]
            }
        },
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_146/pandas/core/indexes/base.py": {
            "buggy_functions": [
                {
                    "function_name": "equals",
                    "function_code": "def equals(self, other):\n    \"\"\"\n    Determine if two Index objects contain the same elements.\n\n    Returns\n    -------\n    bool\n        True if \"other\" is an Index and it has the same elements as calling\n        index; False otherwise.\n    \"\"\"\n    if self.is_(other):\n        return True\n\n    if not isinstance(other, Index):\n        return False\n\n    if is_object_dtype(self) and not is_object_dtype(other):\n        # if other is not object, use other's logic for coercion\n        return other.equals(self)\n\n    try:\n        return array_equivalent(\n            com.values_from_object(self), com.values_from_object(other)\n        )\n    except Exception:\n        return False\n",
                    "decorators": [],
                    "docstring": "Determine if two Index objects contain the same elements.\n\nReturns\n-------\nbool\n    True if \"other\" is an Index and it has the same elements as calling\n    index; False otherwise.",
                    "start_line": 4307,
                    "end_line": 4332,
                    "variables": {
                        "self.is_": [
                            4317
                        ],
                        "self": [
                            4325,
                            4323,
                            4317,
                            4329
                        ],
                        "other": [
                            4320,
                            4323,
                            4325,
                            4329,
                            4317
                        ],
                        "isinstance": [
                            4320
                        ],
                        "Index": [
                            4320
                        ],
                        "is_object_dtype": [
                            4323
                        ],
                        "other.equals": [
                            4325
                        ],
                        "array_equivalent": [
                            4328
                        ],
                        "com.values_from_object": [
                            4329
                        ],
                        "com": [
                            4329
                        ],
                        "Exception": [
                            4331
                        ]
                    },
                    "filtered_variables": {
                        "self.is_": [
                            4317
                        ],
                        "self": [
                            4325,
                            4323,
                            4317,
                            4329
                        ],
                        "other": [
                            4320,
                            4323,
                            4325,
                            4329,
                            4317
                        ],
                        "Index": [
                            4320
                        ],
                        "is_object_dtype": [
                            4323
                        ],
                        "other.equals": [
                            4325
                        ],
                        "array_equivalent": [
                            4328
                        ],
                        "com.values_from_object": [
                            4329
                        ],
                        "com": [
                            4329
                        ]
                    },
                    "diff_line_number": 4327,
                    "class_data": {
                        "signature": "class Index(IndexOpsMixin, PandasObject)",
                        "docstring": "Immutable ndarray implementing an ordered, sliceable set. The basic object\nstoring axis labels for all pandas objects.\n\nParameters\n----------\ndata : array-like (1-dimensional)\ndtype : NumPy dtype (default: object)\n    If dtype is None, we find the dtype that best fits the data.\n    If an actual dtype is provided, we coerce to that dtype if it's safe.\n    Otherwise, an error will be raised.\ncopy : bool\n    Make a copy of input ndarray\nname : object\n    Name to be stored in the index\ntupleize_cols : bool (default: True)\n    When True, attempt to create a MultiIndex if possible\n\nSee Also\n--------\nRangeIndex : Index implementing a monotonic integer range.\nCategoricalIndex : Index of :class:`Categorical` s.\nMultiIndex : A multi-level, or hierarchical, Index.\nIntervalIndex : An Index of :class:`Interval` s.\nDatetimeIndex, TimedeltaIndex, PeriodIndex\nInt64Index, UInt64Index,  Float64Index\n\nNotes\n-----\nAn Index instance can **only** contain hashable objects\n\nExamples\n--------\n>>> pd.Index([1, 2, 3])\nInt64Index([1, 2, 3], dtype='int64')\n\n>>> pd.Index(list('abc'))\nIndex(['a', 'b', 'c'], dtype='object')",
                        "constructor_docstring": null,
                        "functions": [
                            "def _left_indexer_unique(self, left, right):\n    return libjoin.left_join_indexer_unique(left, right)",
                            "def _left_indexer(self, left, right):\n    return libjoin.left_join_indexer(left, right)",
                            "def _inner_indexer(self, left, right):\n    return libjoin.inner_join_indexer(left, right)",
                            "def _outer_indexer(self, left, right):\n    return libjoin.outer_join_indexer(left, right)",
                            "def __new__(cls, data=None, dtype=None, copy=False, name=None, fastpath=None, tupleize_cols=True, **kwargs) -> 'Index':\n    from .range import RangeIndex\n    from pandas import PeriodIndex, DatetimeIndex, TimedeltaIndex\n    from .numeric import Float64Index, Int64Index, UInt64Index\n    from .interval import IntervalIndex\n    from .category import CategoricalIndex\n    if name is None and hasattr(data, 'name'):\n        name = data.name\n    if fastpath is not None:\n        warnings.warn(\"The 'fastpath' keyword is deprecated, and will be removed in a future version.\", FutureWarning, stacklevel=2)\n        if fastpath:\n            return cls._simple_new(data, name)\n    if isinstance(data, ABCPandasArray):\n        data = data.to_numpy()\n    if isinstance(data, RangeIndex):\n        return RangeIndex(start=data, copy=copy, dtype=dtype, name=name)\n    elif isinstance(data, range):\n        return RangeIndex.from_range(data, dtype=dtype, name=name)\n    elif is_categorical_dtype(data) or is_categorical_dtype(dtype):\n        return CategoricalIndex(data, dtype=dtype, copy=copy, name=name, **kwargs)\n    elif (is_interval_dtype(data) or is_interval_dtype(dtype)) and (not is_object_dtype(dtype)):\n        closed = kwargs.get('closed', None)\n        return IntervalIndex(data, dtype=dtype, name=name, copy=copy, closed=closed)\n    elif is_datetime64_any_dtype(data) or is_datetime64_any_dtype(dtype) or 'tz' in kwargs:\n        if is_dtype_equal(_o_dtype, dtype):\n            result = DatetimeIndex(data, copy=False, name=name, **kwargs)\n            return result.astype(object)\n        else:\n            return DatetimeIndex(data, copy=copy, name=name, dtype=dtype, **kwargs)\n    elif is_timedelta64_dtype(data) or is_timedelta64_dtype(dtype):\n        if is_dtype_equal(_o_dtype, dtype):\n            result = TimedeltaIndex(data, copy=False, name=name, **kwargs)\n            return result.astype(object)\n        else:\n            return TimedeltaIndex(data, copy=copy, name=name, dtype=dtype, **kwargs)\n    elif is_period_dtype(data) and (not is_object_dtype(dtype)):\n        return PeriodIndex(data, copy=copy, name=name, **kwargs)\n    elif is_extension_array_dtype(data) or is_extension_array_dtype(dtype):\n        data = np.asarray(data)\n        if not (dtype is None or is_object_dtype(dtype)):\n            ea_cls = dtype.construct_array_type()\n            data = ea_cls._from_sequence(data, dtype=dtype, copy=False)\n        data = data.astype(object)\n        return Index(data, dtype=object, copy=copy, name=name, **kwargs)\n    elif isinstance(data, (np.ndarray, Index, ABCSeries)):\n        if dtype is not None:\n            if is_integer_dtype(dtype):\n                inferred = lib.infer_dtype(data, skipna=False)\n                if inferred == 'integer':\n                    data = maybe_cast_to_integer_array(data, dtype, copy=copy)\n                elif inferred in ['floating', 'mixed-integer-float']:\n                    if isna(data).any():\n                        raise ValueError('cannot convert float NaN to integer')\n                    if inferred == 'mixed-integer-float':\n                        data = maybe_cast_to_integer_array(data, dtype)\n                    try:\n                        return cls._try_convert_to_int_index(data, copy, name, dtype)\n                    except ValueError:\n                        pass\n                    return Float64Index(data, copy=copy, dtype=dtype, name=name)\n                elif inferred == 'string':\n                    pass\n                else:\n                    data = data.astype(dtype)\n            elif is_float_dtype(dtype):\n                inferred = lib.infer_dtype(data, skipna=False)\n                if inferred == 'string':\n                    pass\n                else:\n                    data = data.astype(dtype)\n            else:\n                data = np.array(data, dtype=dtype, copy=copy)\n        if is_signed_integer_dtype(data.dtype):\n            return Int64Index(data, copy=copy, dtype=dtype, name=name)\n        elif is_unsigned_integer_dtype(data.dtype):\n            return UInt64Index(data, copy=copy, dtype=dtype, name=name)\n        elif is_float_dtype(data.dtype):\n            return Float64Index(data, copy=copy, dtype=dtype, name=name)\n        elif issubclass(data.dtype.type, np.bool) or is_bool_dtype(data):\n            subarr = data.astype('object')\n        else:\n            subarr = com.asarray_tuplesafe(data, dtype=object)\n        if copy:\n            subarr = subarr.copy()\n        if dtype is None:\n            inferred = lib.infer_dtype(subarr, skipna=False)\n            if inferred == 'integer':\n                try:\n                    return cls._try_convert_to_int_index(subarr, copy, name, dtype)\n                except ValueError:\n                    pass\n                return Index(subarr, copy=copy, dtype=object, name=name)\n            elif inferred in ['floating', 'mixed-integer-float', 'integer-na']:\n                return Float64Index(subarr, copy=copy, name=name)\n            elif inferred == 'interval':\n                try:\n                    return IntervalIndex(subarr, name=name, copy=copy)\n                except ValueError:\n                    pass\n            elif inferred == 'boolean':\n                pass\n            elif inferred != 'string':\n                if inferred.startswith('datetime'):\n                    try:\n                        return DatetimeIndex(subarr, copy=copy, name=name, **kwargs)\n                    except (ValueError, OutOfBoundsDatetime):\n                        pass\n                elif inferred.startswith('timedelta'):\n                    return TimedeltaIndex(subarr, copy=copy, name=name, **kwargs)\n                elif inferred == 'period':\n                    try:\n                        return PeriodIndex(subarr, name=name, **kwargs)\n                    except IncompatibleFrequency:\n                        pass\n        return cls._simple_new(subarr, name)\n    elif hasattr(data, '__array__'):\n        return Index(np.asarray(data), dtype=dtype, copy=copy, name=name, **kwargs)\n    elif data is None or is_scalar(data):\n        raise cls._scalar_data_error(data)\n    else:\n        if tupleize_cols and is_list_like(data):\n            if is_iterator(data):\n                data = list(data)\n            if data and all((isinstance(e, tuple) for e in data)):\n                from .multi import MultiIndex\n                return MultiIndex.from_tuples(data, names=name or kwargs.get('names'))\n        subarr = com.asarray_tuplesafe(data, dtype=object)\n        return Index(subarr, dtype=dtype, copy=copy, name=name, **kwargs)",
                            "@property\ndef asi8(self):\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return None",
                            "@classmethod\ndef _simple_new(cls, values, name=None, dtype=None, **kwargs):\n    \"\"\"\n    We require that we have a dtype compat for the values. If we are passed\n    a non-dtype compat, then coerce using the constructor.\n\n    Must be careful not to recurse.\n    \"\"\"\n    if isinstance(values, (ABCSeries, ABCIndexClass)):\n        values = np.asarray(values._values)\n    result = object.__new__(cls)\n    result._data = values\n    result._index_data = values\n    result.name = name\n    for k, v in kwargs.items():\n        setattr(result, k, v)\n    return result._reset_identity()",
                            "@cache_readonly\ndef _constructor(self):\n    return type(self)",
                            "def _get_attributes_dict(self):\n    \"\"\"\n    Return an attributes dict for my class.\n    \"\"\"\n    return {k: getattr(self, k, None) for k in self._attributes}",
                            "@Appender(_index_shared_docs['_shallow_copy'])\ndef _shallow_copy(self, values=None, **kwargs):\n    if values is None:\n        values = self.values\n    attributes = self._get_attributes_dict()\n    attributes.update(kwargs)\n    if not len(values) and 'dtype' not in kwargs:\n        attributes['dtype'] = self.dtype\n    values = getattr(values, '_values', values)\n    if isinstance(values, ABCDatetimeArray):\n        values = values.asi8\n    return self._simple_new(values, **attributes)",
                            "def _shallow_copy_with_infer(self, values, **kwargs):\n    \"\"\"\n    Create a new Index inferring the class with passed value, don't copy\n    the data, use the same object attributes with passed in attributes\n    taking precedence.\n\n    *this is an internal non-public method*\n\n    Parameters\n    ----------\n    values : the values to create the new Index, optional\n    kwargs : updates the default attributes for this Index\n    \"\"\"\n    attributes = self._get_attributes_dict()\n    attributes.update(kwargs)\n    attributes['copy'] = False\n    if not len(values) and 'dtype' not in kwargs:\n        attributes['dtype'] = self.dtype\n    if self._infer_as_myclass:\n        try:\n            return self._constructor(values, **attributes)\n        except (TypeError, ValueError):\n            pass\n    return Index(values, **attributes)",
                            "def _update_inplace(self, result, **kwargs):\n    raise TypeError(\"Index can't be updated inplace\")",
                            "def is_(self, other):\n    \"\"\"\n    More flexible, faster check like ``is`` but that works through views.\n\n    Note: this is *not* the same as ``Index.identical()``, which checks\n    that metadata is also the same.\n\n    Parameters\n    ----------\n    other : object\n        other object to compare against.\n\n    Returns\n    -------\n    True if both have same underlying data, False otherwise : bool\n    \"\"\"\n    return self._id is getattr(other, '_id', Ellipsis) and self._id is not None",
                            "def _reset_identity(self):\n    \"\"\"\n    Initializes or resets ``_id`` attribute with new object.\n    \"\"\"\n    self._id = _Identity()\n    return self",
                            "def _cleanup(self):\n    self._engine.clear_mapping()",
                            "@cache_readonly\ndef _engine(self):\n    _ndarray_values = self._ndarray_values\n    return self._engine_type(lambda: _ndarray_values, len(self))",
                            "def __len__(self):\n    \"\"\"\n    Return the length of the Index.\n    \"\"\"\n    return len(self._data)",
                            "def __array__(self, dtype=None):\n    \"\"\"\n    The array interface, return my values.\n    \"\"\"\n    return np.asarray(self._data, dtype=dtype)",
                            "def __array_wrap__(self, result, context=None):\n    \"\"\"\n    Gets called after a ufunc.\n    \"\"\"\n    result = lib.item_from_zerodim(result)\n    if is_bool_dtype(result) or lib.is_scalar(result):\n        return result\n    attrs = self._get_attributes_dict()\n    return Index(result, **attrs)",
                            "@cache_readonly\ndef dtype(self):\n    \"\"\"\n    Return the dtype object of the underlying data.\n    \"\"\"\n    return self._data.dtype",
                            "@property\ndef dtype_str(self):\n    \"\"\"\n    Return the dtype str of the underlying data.\n\n    .. deprecated:: 0.25.0\n    \"\"\"\n    warnings.warn('`dtype_str` has been deprecated. Call `str` on the dtype attribute instead.', FutureWarning, stacklevel=2)\n    return str(self.dtype)",
                            "def ravel(self, order='C'):\n    \"\"\"\n    Return an ndarray of the flattened values of the underlying data.\n\n    Returns\n    -------\n    numpy.ndarray\n        Flattened array.\n\n    See Also\n    --------\n    numpy.ndarray.ravel\n    \"\"\"\n    return self._ndarray_values.ravel(order=order)",
                            "def view(self, cls=None):\n    if cls is not None and (not hasattr(cls, '_typ')):\n        result = self._data.view(cls)\n    else:\n        result = self._shallow_copy()\n    if isinstance(result, Index):\n        result._id = self._id\n    return result",
                            "@Appender(_index_shared_docs['astype'])\ndef astype(self, dtype, copy=True):\n    if is_dtype_equal(self.dtype, dtype):\n        return self.copy() if copy else self\n    elif is_categorical_dtype(dtype):\n        from .category import CategoricalIndex\n        return CategoricalIndex(self.values, name=self.name, dtype=dtype, copy=copy)\n    elif is_datetime64tz_dtype(dtype):\n        from pandas import DatetimeIndex\n        tz = pandas_dtype(dtype).tz\n        return DatetimeIndex(np.asarray(self)).tz_localize('UTC').tz_convert(tz)\n    elif is_extension_array_dtype(dtype):\n        return Index(np.asarray(self), dtype=dtype, copy=copy)\n    try:\n        if is_datetime64tz_dtype(dtype):\n            from pandas import DatetimeIndex\n            return DatetimeIndex(self.values, name=self.name, dtype=dtype, copy=copy)\n        return Index(self.values.astype(dtype, copy=copy), name=self.name, dtype=dtype)\n    except (TypeError, ValueError):\n        msg = 'Cannot cast {name} to dtype {dtype}'\n        raise TypeError(msg.format(name=type(self).__name__, dtype=dtype))",
                            "@Appender(_index_shared_docs['take'] % _index_doc_kwargs)\ndef take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs):\n    if kwargs:\n        nv.validate_take(tuple(), kwargs)\n    indices = ensure_platform_int(indices)\n    if self._can_hold_na:\n        taken = self._assert_take_fillable(self.values, indices, allow_fill=allow_fill, fill_value=fill_value, na_value=self._na_value)\n    else:\n        if allow_fill and fill_value is not None:\n            msg = 'Unable to fill values because {0} cannot contain NA'\n            raise ValueError(msg.format(self.__class__.__name__))\n        taken = self.values.take(indices)\n    return self._shallow_copy(taken)",
                            "def _assert_take_fillable(self, values, indices, allow_fill=True, fill_value=None, na_value=np.nan):\n    \"\"\"\n    Internal method to handle NA filling of take.\n    \"\"\"\n    indices = ensure_platform_int(indices)\n    if allow_fill and fill_value is not None:\n        if (indices < -1).any():\n            msg = 'When allow_fill=True and fill_value is not None, all indices must be >= -1'\n            raise ValueError(msg)\n        taken = algos.take(values, indices, allow_fill=allow_fill, fill_value=na_value)\n    else:\n        taken = values.take(indices)\n    return taken",
                            "@Appender(_index_shared_docs['repeat'] % _index_doc_kwargs)\ndef repeat(self, repeats, axis=None):\n    repeats = ensure_platform_int(repeats)\n    nv.validate_repeat(tuple(), dict(axis=axis))\n    return self._shallow_copy(self._values.repeat(repeats))",
                            "@Appender(_index_shared_docs['copy'])\ndef copy(self, name=None, deep=False, dtype=None, **kwargs):\n    if deep:\n        new_index = self._shallow_copy(self._data.copy())\n    else:\n        new_index = self._shallow_copy()\n    names = kwargs.get('names')\n    names = self._validate_names(name=name, names=names, deep=deep)\n    new_index = new_index.set_names(names)\n    if dtype:\n        new_index = new_index.astype(dtype)\n    return new_index",
                            "def __copy__(self, **kwargs):\n    return self.copy(**kwargs)",
                            "def __deepcopy__(self, memo=None):\n    \"\"\"\n    Parameters\n    ----------\n    memo, default None\n        Standard signature. Unused\n    \"\"\"\n    if memo is None:\n        memo = {}\n    return self.copy(deep=True)",
                            "def __repr__(self):\n    \"\"\"\n    Return a string representation for this object.\n    \"\"\"\n    klass = self.__class__.__name__\n    data = self._format_data()\n    attrs = self._format_attrs()\n    space = self._format_space()\n    prepr = (',%s' % space).join(('%s=%s' % (k, v) for k, v in attrs))\n    if data is None:\n        data = ''\n    res = '%s(%s%s)' % (klass, data, prepr)\n    return res",
                            "def _format_space(self):\n    return ' '",
                            "@property\ndef _formatter_func(self):\n    \"\"\"\n    Return the formatter function.\n    \"\"\"\n    return default_pprint",
                            "def _format_data(self, name=None):\n    \"\"\"\n    Return the formatted data as a unicode string.\n    \"\"\"\n    is_justify = not (self.inferred_type in ('string', 'unicode') or (self.inferred_type == 'categorical' and is_object_dtype(self.categories)))\n    return format_object_summary(self, self._formatter_func, is_justify=is_justify, name=name)",
                            "def _format_attrs(self):\n    \"\"\"\n    Return a list of tuples of the (attr,formatted_value).\n    \"\"\"\n    return format_object_attrs(self)",
                            "def _mpl_repr(self):\n    return self.values",
                            "def format(self, name=False, formatter=None, **kwargs):\n    \"\"\"\n    Render a string representation of the Index.\n    \"\"\"\n    header = []\n    if name:\n        header.append(pprint_thing(self.name, escape_chars=('\\t', '\\r', '\\n')) if self.name is not None else '')\n    if formatter is not None:\n        return header + list(self.map(formatter))\n    return self._format_with_header(header, **kwargs)",
                            "def _format_with_header(self, header, na_rep='NaN', **kwargs):\n    values = self.values\n    from pandas.io.formats.format import format_array\n    if is_categorical_dtype(values.dtype):\n        values = np.array(values)\n    elif is_object_dtype(values.dtype):\n        values = lib.maybe_convert_objects(values, safe=1)\n    if is_object_dtype(values.dtype):\n        result = [pprint_thing(x, escape_chars=('\\t', '\\r', '\\n')) for x in values]\n        mask = isna(values)\n        if mask.any():\n            result = np.array(result)\n            result[mask] = na_rep\n            result = result.tolist()\n    else:\n        result = _trim_front(format_array(values, None, justify='left'))\n    return header + result",
                            "def to_native_types(self, slicer=None, **kwargs):\n    \"\"\"\n    Format specified values of `self` and return them.\n\n    Parameters\n    ----------\n    slicer : int, array-like\n        An indexer into `self` that specifies which values\n        are used in the formatting process.\n    kwargs : dict\n        Options for specifying how the values should be formatted.\n        These options include the following:\n\n        1) na_rep : str\n            The value that serves as a placeholder for NULL values\n        2) quoting : bool or None\n            Whether or not there are quoted values in `self`\n        3) date_format : str\n            The format used to represent date-like values\n\n    Returns\n    -------\n    numpy.ndarray\n        Formatted values.\n    \"\"\"\n    values = self\n    if slicer is not None:\n        values = values[slicer]\n    return values._format_native_types(**kwargs)",
                            "def _format_native_types(self, na_rep='', quoting=None, **kwargs):\n    \"\"\"\n    Actually format specific types of the index.\n    \"\"\"\n    mask = isna(self)\n    if not self.is_object() and (not quoting):\n        values = np.asarray(self).astype(str)\n    else:\n        values = np.array(self, dtype=object, copy=True)\n    values[mask] = na_rep\n    return values",
                            "def _summary(self, name=None):\n    \"\"\"\n    Return a summarized representation.\n\n    Parameters\n    ----------\n    name : str\n        name to use in the summary representation\n\n    Returns\n    -------\n    String with a summarized representation of the index\n    \"\"\"\n    if len(self) > 0:\n        head = self[0]\n        if hasattr(head, 'format') and (not isinstance(head, str)):\n            head = head.format()\n        tail = self[-1]\n        if hasattr(tail, 'format') and (not isinstance(tail, str)):\n            tail = tail.format()\n        index_summary = ', %s to %s' % (pprint_thing(head), pprint_thing(tail))\n    else:\n        index_summary = ''\n    if name is None:\n        name = type(self).__name__\n    return '%s: %s entries%s' % (name, len(self), index_summary)",
                            "def summary(self, name=None):\n    \"\"\"\n    Return a summarized representation.\n\n    .. deprecated:: 0.23.0\n    \"\"\"\n    warnings.warn(\"'summary' is deprecated and will be removed in a future version.\", FutureWarning, stacklevel=2)\n    return self._summary(name)",
                            "def to_flat_index(self):\n    \"\"\"\n    Identity method.\n\n    .. versionadded:: 0.24.0\n\n    This is implemented for compatibility with subclass implementations\n    when chaining.\n\n    Returns\n    -------\n    pd.Index\n        Caller.\n\n    See Also\n    --------\n    MultiIndex.to_flat_index : Subclass implementation.\n    \"\"\"\n    return self",
                            "def to_series(self, index=None, name=None):\n    \"\"\"\n    Create a Series with both index and values equal to the index keys\n    useful with map for returning an indexer based on an index.\n\n    Parameters\n    ----------\n    index : Index, optional\n        index of resulting Series. If None, defaults to original index\n    name : string, optional\n        name of resulting Series. If None, defaults to name of original\n        index\n\n    Returns\n    -------\n    Series : dtype will be based on the type of the Index values.\n    \"\"\"\n    from pandas import Series\n    if index is None:\n        index = self._shallow_copy()\n    if name is None:\n        name = self.name\n    return Series(self.values.copy(), index=index, name=name)",
                            "def to_frame(self, index=True, name=None):\n    \"\"\"\n    Create a DataFrame with a column containing the Index.\n\n    .. versionadded:: 0.24.0\n\n    Parameters\n    ----------\n    index : boolean, default True\n        Set the index of the returned DataFrame as the original Index.\n\n    name : object, default None\n        The passed name should substitute for the index name (if it has\n        one).\n\n    Returns\n    -------\n    DataFrame\n        DataFrame containing the original Index data.\n\n    See Also\n    --------\n    Index.to_series : Convert an Index to a Series.\n    Series.to_frame : Convert Series to DataFrame.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['Ant', 'Bear', 'Cow'], name='animal')\n    >>> idx.to_frame()\n           animal\n    animal\n    Ant       Ant\n    Bear     Bear\n    Cow       Cow\n\n    By default, the original Index is reused. To enforce a new Index:\n\n    >>> idx.to_frame(index=False)\n        animal\n    0   Ant\n    1  Bear\n    2   Cow\n\n    To override the name of the resulting column, specify `name`:\n\n    >>> idx.to_frame(index=False, name='zoo')\n        zoo\n    0   Ant\n    1  Bear\n    2   Cow\n    \"\"\"\n    from pandas import DataFrame\n    if name is None:\n        name = self.name or 0\n    result = DataFrame({name: self._values.copy()})\n    if index:\n        result.index = self\n    return result",
                            "def _validate_names(self, name=None, names=None, deep=False):\n    \"\"\"\n    Handles the quirks of having a singular 'name' parameter for general\n    Index and plural 'names' parameter for MultiIndex.\n    \"\"\"\n    from copy import deepcopy\n    if names is not None and name is not None:\n        raise TypeError('Can only provide one of `names` and `name`')\n    elif names is None and name is None:\n        return deepcopy(self.names) if deep else self.names\n    elif names is not None:\n        if not is_list_like(names):\n            raise TypeError('Must pass list-like as `names`.')\n        return names\n    else:\n        if not is_list_like(name):\n            return [name]\n        return name",
                            "def _get_names(self):\n    return FrozenList((self.name,))",
                            "def _set_names(self, values, level=None):\n    \"\"\"\n    Set new names on index. Each name has to be a hashable type.\n\n    Parameters\n    ----------\n    values : str or sequence\n        name(s) to set\n    level : int, level name, or sequence of int/level names (default None)\n        If the index is a MultiIndex (hierarchical), level(s) to set (None\n        for all levels).  Otherwise level must be None\n\n    Raises\n    ------\n    TypeError if each name is not hashable.\n    \"\"\"\n    if not is_list_like(values):\n        raise ValueError('Names must be a list-like')\n    if len(values) != 1:\n        raise ValueError('Length of new names must be 1, got %d' % len(values))\n    for name in values:\n        if not is_hashable(name):\n            raise TypeError('{}.name must be a hashable type'.format(self.__class__.__name__))\n    self.name = values[0]",
                            "def set_names(self, names, level=None, inplace=False):\n    \"\"\"\n    Set Index or MultiIndex name.\n\n    Able to set new names partially and by level.\n\n    Parameters\n    ----------\n    names : label or list of label\n        Name(s) to set.\n    level : int, label or list of int or label, optional\n        If the index is a MultiIndex, level(s) to set (None for all\n        levels). Otherwise level must be None.\n    inplace : bool, default False\n        Modifies the object directly, instead of creating a new Index or\n        MultiIndex.\n\n    Returns\n    -------\n    Index\n        The same type as the caller or None if inplace is True.\n\n    See Also\n    --------\n    Index.rename : Able to set new names without level.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1, 2, 3, 4])\n    >>> idx\n    Int64Index([1, 2, 3, 4], dtype='int64')\n    >>> idx.set_names('quarter')\n    Int64Index([1, 2, 3, 4], dtype='int64', name='quarter')\n\n    >>> idx = pd.MultiIndex.from_product([['python', 'cobra'],\n    ...                                   [2018, 2019]])\n    >>> idx\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               )\n    >>> idx.set_names(['kind', 'year'], inplace=True)\n    >>> idx\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['kind', 'year'])\n    >>> idx.set_names('species', level=0)\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['species', 'year'])\n    \"\"\"\n    if level is not None and (not isinstance(self, ABCMultiIndex)):\n        raise ValueError('Level must be None for non-MultiIndex')\n    if level is not None and (not is_list_like(level)) and is_list_like(names):\n        msg = 'Names must be a string when a single level is provided.'\n        raise TypeError(msg)\n    if not is_list_like(names) and level is None and (self.nlevels > 1):\n        raise TypeError('Must pass list-like as `names`.')\n    if not is_list_like(names):\n        names = [names]\n    if level is not None and (not is_list_like(level)):\n        level = [level]\n    if inplace:\n        idx = self\n    else:\n        idx = self._shallow_copy()\n    idx._set_names(names, level=level)\n    if not inplace:\n        return idx",
                            "def rename(self, name, inplace=False):\n    \"\"\"\n    Alter Index or MultiIndex name.\n\n    Able to set new names without level. Defaults to returning new index.\n    Length of names must match number of levels in MultiIndex.\n\n    Parameters\n    ----------\n    name : label or list of labels\n        Name(s) to set.\n    inplace : boolean, default False\n        Modifies the object directly, instead of creating a new Index or\n        MultiIndex.\n\n    Returns\n    -------\n    Index\n        The same type as the caller or None if inplace is True.\n\n    See Also\n    --------\n    Index.set_names : Able to set new names partially and by level.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['A', 'C', 'A', 'B'], name='score')\n    >>> idx.rename('grade')\n    Index(['A', 'C', 'A', 'B'], dtype='object', name='grade')\n\n    >>> idx = pd.MultiIndex.from_product([['python', 'cobra'],\n    ...                                   [2018, 2019]],\n    ...                                   names=['kind', 'year'])\n    >>> idx\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['kind', 'year'])\n    >>> idx.rename(['species', 'year'])\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['species', 'year'])\n    >>> idx.rename('species')\n    Traceback (most recent call last):\n    TypeError: Must pass list-like as `names`.\n    \"\"\"\n    return self.set_names([name], inplace=inplace)",
                            "@property\ndef nlevels(self):\n    \"\"\"\n    Number of levels.\n    \"\"\"\n    return 1",
                            "def _sort_levels_monotonic(self):\n    \"\"\"\n    Compat with MultiIndex.\n    \"\"\"\n    return self",
                            "def _validate_index_level(self, level):\n    \"\"\"\n    Validate index level.\n\n    For single-level Index getting level number is a no-op, but some\n    verification must be done like in MultiIndex.\n\n    \"\"\"\n    if isinstance(level, int):\n        if level < 0 and level != -1:\n            raise IndexError('Too many levels: Index has only 1 level, %d is not a valid level number' % (level,))\n        elif level > 0:\n            raise IndexError('Too many levels: Index has only 1 level, not %d' % (level + 1))\n    elif level != self.name:\n        raise KeyError('Requested level ({}) does not match index name ({})'.format(level, self.name))",
                            "def _get_level_number(self, level):\n    self._validate_index_level(level)\n    return 0",
                            "def sortlevel(self, level=None, ascending=True, sort_remaining=None):\n    \"\"\"\n    For internal compatibility with with the Index API.\n\n    Sort the Index. This is for compat with MultiIndex\n\n    Parameters\n    ----------\n    ascending : boolean, default True\n        False to sort in descending order\n\n    level, sort_remaining are compat parameters\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    return self.sort_values(return_indexer=True, ascending=ascending)",
                            "def _get_level_values(self, level):\n    \"\"\"\n    Return an Index of values for requested level.\n\n    This is primarily useful to get an individual level of values from a\n    MultiIndex, but is provided on Index as well for compatibility.\n\n    Parameters\n    ----------\n    level : int or str\n        It is either the integer position or the name of the level.\n\n    Returns\n    -------\n    Index\n        Calling object, as there is only one level in the Index.\n\n    See Also\n    --------\n    MultiIndex.get_level_values : Get values for a level of a MultiIndex.\n\n    Notes\n    -----\n    For Index, level should be 0, since there are no multiple levels.\n\n    Examples\n    --------\n\n    >>> idx = pd.Index(list('abc'))\n    >>> idx\n    Index(['a', 'b', 'c'], dtype='object')\n\n    Get level values by supplying `level` as integer:\n\n    >>> idx.get_level_values(0)\n    Index(['a', 'b', 'c'], dtype='object')\n    \"\"\"\n    self._validate_index_level(level)\n    return self",
                            "def droplevel(self, level=0):\n    \"\"\"\n    Return index with requested level(s) removed.\n\n    If resulting index has only 1 level left, the result will be\n    of Index type, not MultiIndex.\n\n    .. versionadded:: 0.23.1 (support for non-MultiIndex)\n\n    Parameters\n    ----------\n    level : int, str, or list-like, default 0\n        If a string is given, must be the name of a level\n        If list-like, elements must be names or indexes of levels.\n\n    Returns\n    -------\n    Index or MultiIndex\n    \"\"\"\n    if not isinstance(level, (tuple, list)):\n        level = [level]\n    levnums = sorted((self._get_level_number(lev) for lev in level))[::-1]\n    if len(level) == 0:\n        return self\n    if len(level) >= self.nlevels:\n        raise ValueError('Cannot remove {} levels from an index with {} levels: at least one level must be left.'.format(len(level), self.nlevels))\n    new_levels = list(self.levels)\n    new_codes = list(self.codes)\n    new_names = list(self.names)\n    for i in levnums:\n        new_levels.pop(i)\n        new_codes.pop(i)\n        new_names.pop(i)\n    if len(new_levels) == 1:\n        mask = new_codes[0] == -1\n        result = new_levels[0].take(new_codes[0])\n        if mask.any():\n            result = result.putmask(mask, np.nan)\n        result.name = new_names[0]\n        return result\n    else:\n        from .multi import MultiIndex\n        return MultiIndex(levels=new_levels, codes=new_codes, names=new_names, verify_integrity=False)",
                            "@Appender(_index_shared_docs['_get_grouper_for_level'])\ndef _get_grouper_for_level(self, mapper, level=None):\n    assert level is None or level == 0\n    if mapper is None:\n        grouper = self\n    else:\n        grouper = self.map(mapper)\n    return (grouper, None, None)",
                            "@property\ndef is_monotonic(self):\n    \"\"\"\n    Alias for is_monotonic_increasing.\n    \"\"\"\n    return self.is_monotonic_increasing",
                            "@property\ndef is_monotonic_increasing(self):\n    \"\"\"\n    Return if the index is monotonic increasing (only equal or\n    increasing) values.\n\n    Examples\n    --------\n    >>> Index([1, 2, 3]).is_monotonic_increasing\n    True\n    >>> Index([1, 2, 2]).is_monotonic_increasing\n    True\n    >>> Index([1, 3, 2]).is_monotonic_increasing\n    False\n    \"\"\"\n    return self._engine.is_monotonic_increasing",
                            "@property\ndef is_monotonic_decreasing(self):\n    \"\"\"\n    Return if the index is monotonic decreasing (only equal or\n    decreasing) values.\n\n    Examples\n    --------\n    >>> Index([3, 2, 1]).is_monotonic_decreasing\n    True\n    >>> Index([3, 2, 2]).is_monotonic_decreasing\n    True\n    >>> Index([3, 1, 2]).is_monotonic_decreasing\n    False\n    \"\"\"\n    return self._engine.is_monotonic_decreasing",
                            "@property\ndef _is_strictly_monotonic_increasing(self):\n    \"\"\"\n    Return if the index is strictly monotonic increasing\n    (only increasing) values.\n\n    Examples\n    --------\n    >>> Index([1, 2, 3])._is_strictly_monotonic_increasing\n    True\n    >>> Index([1, 2, 2])._is_strictly_monotonic_increasing\n    False\n    >>> Index([1, 3, 2])._is_strictly_monotonic_increasing\n    False\n    \"\"\"\n    return self.is_unique and self.is_monotonic_increasing",
                            "@property\ndef _is_strictly_monotonic_decreasing(self):\n    \"\"\"\n    Return if the index is strictly monotonic decreasing\n    (only decreasing) values.\n\n    Examples\n    --------\n    >>> Index([3, 2, 1])._is_strictly_monotonic_decreasing\n    True\n    >>> Index([3, 2, 2])._is_strictly_monotonic_decreasing\n    False\n    >>> Index([3, 1, 2])._is_strictly_monotonic_decreasing\n    False\n    \"\"\"\n    return self.is_unique and self.is_monotonic_decreasing",
                            "def is_lexsorted_for_tuple(self, tup):\n    return True",
                            "@cache_readonly\ndef is_unique(self):\n    \"\"\"\n    Return if the index has unique values.\n    \"\"\"\n    return self._engine.is_unique",
                            "@property\ndef has_duplicates(self):\n    return not self.is_unique",
                            "def is_boolean(self):\n    return self.inferred_type in ['boolean']",
                            "def is_integer(self):\n    return self.inferred_type in ['integer']",
                            "def is_floating(self):\n    return self.inferred_type in ['floating', 'mixed-integer-float', 'integer-na']",
                            "def is_numeric(self):\n    return self.inferred_type in ['integer', 'floating']",
                            "def is_object(self):\n    return is_object_dtype(self.dtype)",
                            "def is_categorical(self):\n    \"\"\"\n    Check if the Index holds categorical data.\n\n    Returns\n    -------\n    boolean\n        True if the Index is categorical.\n\n    See Also\n    --------\n    CategoricalIndex : Index for categorical data.\n\n    Examples\n    --------\n    >>> idx = pd.Index([\"Watermelon\", \"Orange\", \"Apple\",\n    ...                 \"Watermelon\"]).astype(\"category\")\n    >>> idx.is_categorical()\n    True\n\n    >>> idx = pd.Index([1, 3, 5, 7])\n    >>> idx.is_categorical()\n    False\n\n    >>> s = pd.Series([\"Peter\", \"Victor\", \"Elisabeth\", \"Mar\"])\n    >>> s\n    0        Peter\n    1       Victor\n    2    Elisabeth\n    3          Mar\n    dtype: object\n    >>> s.index.is_categorical()\n    False\n    \"\"\"\n    return self.inferred_type in ['categorical']",
                            "def is_interval(self):\n    return self.inferred_type in ['interval']",
                            "def is_mixed(self):\n    return self.inferred_type in ['mixed']",
                            "def holds_integer(self):\n    \"\"\"\n    Whether the type is an integer type.\n    \"\"\"\n    return self.inferred_type in ['integer', 'mixed-integer']",
                            "@cache_readonly\ndef inferred_type(self):\n    \"\"\"\n    Return a string of the type inferred from the values.\n    \"\"\"\n    return lib.infer_dtype(self, skipna=False)",
                            "@cache_readonly\ndef is_all_dates(self):\n    return is_datetime_array(ensure_object(self.values))",
                            "def __reduce__(self):\n    d = dict(data=self._data)\n    d.update(self._get_attributes_dict())\n    return (_new_Index, (self.__class__, d), None)",
                            "def __setstate__(self, state):\n    \"\"\"\n    Necessary for making this object picklable.\n    \"\"\"\n    if isinstance(state, dict):\n        self._data = state.pop('data')\n        for k, v in state.items():\n            setattr(self, k, v)\n    elif isinstance(state, tuple):\n        if len(state) == 2:\n            nd_state, own_state = state\n            data = np.empty(nd_state[1], dtype=nd_state[2])\n            np.ndarray.__setstate__(data, nd_state)\n            self.name = own_state[0]\n        else:\n            data = np.empty(state)\n            np.ndarray.__setstate__(data, state)\n        self._data = data\n        self._reset_identity()\n    else:\n        raise Exception('invalid pickle state')",
                            "@cache_readonly\ndef _isnan(self):\n    \"\"\"\n    Return if each value is NaN.\n    \"\"\"\n    if self._can_hold_na:\n        return isna(self)\n    else:\n        values = np.empty(len(self), dtype=np.bool_)\n        values.fill(False)\n        return values",
                            "@cache_readonly\ndef _nan_idxs(self):\n    if self._can_hold_na:\n        w, = self._isnan.nonzero()\n        return w\n    else:\n        return np.array([], dtype=np.int64)",
                            "@cache_readonly\ndef hasnans(self):\n    \"\"\"\n    Return if I have any nans; enables various perf speedups.\n    \"\"\"\n    if self._can_hold_na:\n        return bool(self._isnan.any())\n    else:\n        return False",
                            "def isna(self):\n    \"\"\"\n    Detect missing values.\n\n    Return a boolean same-sized object indicating if the values are NA.\n    NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get\n    mapped to ``True`` values.\n    Everything else get mapped to ``False`` values. Characters such as\n    empty strings `''` or :attr:`numpy.inf` are not considered NA values\n    (unless you set ``pandas.options.mode.use_inf_as_na = True``).\n\n    .. versionadded:: 0.20.0\n\n    Returns\n    -------\n    numpy.ndarray\n        A boolean array of whether my values are NA.\n\n    See Also\n    --------\n    Index.notna : Boolean inverse of isna.\n    Index.dropna : Omit entries with missing values.\n    isna : Top-level isna.\n    Series.isna : Detect missing values in Series object.\n\n    Examples\n    --------\n    Show which entries in a pandas.Index are NA. The result is an\n    array.\n\n    >>> idx = pd.Index([5.2, 6.0, np.NaN])\n    >>> idx\n    Float64Index([5.2, 6.0, nan], dtype='float64')\n    >>> idx.isna()\n    array([False, False,  True], dtype=bool)\n\n    Empty strings are not considered NA values. None is considered an NA\n    value.\n\n    >>> idx = pd.Index(['black', '', 'red', None])\n    >>> idx\n    Index(['black', '', 'red', None], dtype='object')\n    >>> idx.isna()\n    array([False, False, False,  True], dtype=bool)\n\n    For datetimes, `NaT` (Not a Time) is considered as an NA value.\n\n    >>> idx = pd.DatetimeIndex([pd.Timestamp('1940-04-25'),\n    ...                         pd.Timestamp(''), None, pd.NaT])\n    >>> idx\n    DatetimeIndex(['1940-04-25', 'NaT', 'NaT', 'NaT'],\n                  dtype='datetime64[ns]', freq=None)\n    >>> idx.isna()\n    array([False,  True,  True,  True], dtype=bool)\n    \"\"\"\n    return self._isnan",
                            "def notna(self):\n    \"\"\"\n    Detect existing (non-missing) values.\n\n    Return a boolean same-sized object indicating if the values are not NA.\n    Non-missing values get mapped to ``True``. Characters such as empty\n    strings ``''`` or :attr:`numpy.inf` are not considered NA values\n    (unless you set ``pandas.options.mode.use_inf_as_na = True``).\n    NA values, such as None or :attr:`numpy.NaN`, get mapped to ``False``\n    values.\n\n    .. versionadded:: 0.20.0\n\n    Returns\n    -------\n    numpy.ndarray\n        Boolean array to indicate which entries are not NA.\n\n    See Also\n    --------\n    Index.notnull : Alias of notna.\n    Index.isna: Inverse of notna.\n    notna : Top-level notna.\n\n    Examples\n    --------\n    Show which entries in an Index are not NA. The result is an\n    array.\n\n    >>> idx = pd.Index([5.2, 6.0, np.NaN])\n    >>> idx\n    Float64Index([5.2, 6.0, nan], dtype='float64')\n    >>> idx.notna()\n    array([ True,  True, False])\n\n    Empty strings are not considered NA values. None is considered a NA\n    value.\n\n    >>> idx = pd.Index(['black', '', 'red', None])\n    >>> idx\n    Index(['black', '', 'red', None], dtype='object')\n    >>> idx.notna()\n    array([ True,  True,  True, False])\n    \"\"\"\n    return ~self.isna()",
                            "@Appender(_index_shared_docs['fillna'])\ndef fillna(self, value=None, downcast=None):\n    self._assert_can_do_op(value)\n    if self.hasnans:\n        result = self.putmask(self._isnan, value)\n        if downcast is None:\n            return Index(result, name=self.name)\n    return self._shallow_copy()",
                            "@Appender(_index_shared_docs['dropna'])\ndef dropna(self, how='any'):\n    if how not in ('any', 'all'):\n        raise ValueError('invalid how option: {0}'.format(how))\n    if self.hasnans:\n        return self._shallow_copy(self.values[~self._isnan])\n    return self._shallow_copy()",
                            "@Appender(_index_shared_docs['index_unique'] % _index_doc_kwargs)\ndef unique(self, level=None):\n    if level is not None:\n        self._validate_index_level(level)\n    result = super().unique()\n    return self._shallow_copy(result)",
                            "def drop_duplicates(self, keep='first'):\n    \"\"\"\n    Return Index with duplicate values removed.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', ``False``}, default 'first'\n        - 'first' : Drop duplicates except for the first occurrence.\n        - 'last' : Drop duplicates except for the last occurrence.\n        - ``False`` : Drop all duplicates.\n\n    Returns\n    -------\n    deduplicated : Index\n\n    See Also\n    --------\n    Series.drop_duplicates : Equivalent method on Series.\n    DataFrame.drop_duplicates : Equivalent method on DataFrame.\n    Index.duplicated : Related method on Index, indicating duplicate\n        Index values.\n\n    Examples\n    --------\n    Generate an pandas.Index with duplicate values.\n\n    >>> idx = pd.Index(['lama', 'cow', 'lama', 'beetle', 'lama', 'hippo'])\n\n    The `keep` parameter controls  which duplicate values are removed.\n    The value 'first' keeps the first occurrence for each\n    set of duplicated entries. The default value of keep is 'first'.\n\n    >>> idx.drop_duplicates(keep='first')\n    Index(['lama', 'cow', 'beetle', 'hippo'], dtype='object')\n\n    The value 'last' keeps the last occurrence for each set of duplicated\n    entries.\n\n    >>> idx.drop_duplicates(keep='last')\n    Index(['cow', 'beetle', 'lama', 'hippo'], dtype='object')\n\n    The value ``False`` discards all sets of duplicated entries.\n\n    >>> idx.drop_duplicates(keep=False)\n    Index(['cow', 'beetle', 'hippo'], dtype='object')\n    \"\"\"\n    return super().drop_duplicates(keep=keep)",
                            "def duplicated(self, keep='first'):\n    \"\"\"\n    Indicate duplicate index values.\n\n    Duplicated values are indicated as ``True`` values in the resulting\n    array. Either all duplicates, all except the first, or all except the\n    last occurrence of duplicates can be indicated.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', False}, default 'first'\n        The value or values in a set of duplicates to mark as missing.\n\n        - 'first' : Mark duplicates as ``True`` except for the first\n          occurrence.\n        - 'last' : Mark duplicates as ``True`` except for the last\n          occurrence.\n        - ``False`` : Mark all duplicates as ``True``.\n\n    Returns\n    -------\n    numpy.ndarray\n\n    See Also\n    --------\n    Series.duplicated : Equivalent method on pandas.Series.\n    DataFrame.duplicated : Equivalent method on pandas.DataFrame.\n    Index.drop_duplicates : Remove duplicate values from Index.\n\n    Examples\n    --------\n    By default, for each set of duplicated values, the first occurrence is\n    set to False and all others to True:\n\n    >>> idx = pd.Index(['lama', 'cow', 'lama', 'beetle', 'lama'])\n    >>> idx.duplicated()\n    array([False, False,  True, False,  True])\n\n    which is equivalent to\n\n    >>> idx.duplicated(keep='first')\n    array([False, False,  True, False,  True])\n\n    By using 'last', the last occurrence of each set of duplicated values\n    is set on False and all others on True:\n\n    >>> idx.duplicated(keep='last')\n    array([ True, False,  True, False, False])\n\n    By setting keep on ``False``, all duplicates are True:\n\n    >>> idx.duplicated(keep=False)\n    array([ True, False,  True, False,  True])\n    \"\"\"\n    return super().duplicated(keep=keep)",
                            "def get_duplicates(self):\n    \"\"\"\n    Extract duplicated index elements.\n\n    .. deprecated:: 0.23.0\n        Use idx[idx.duplicated()].unique() instead\n\n    Returns a sorted list of index elements which appear more than once in\n    the index.\n\n    Returns\n    -------\n    array-like\n        List of duplicated indexes.\n\n    See Also\n    --------\n    Index.duplicated : Return boolean array denoting duplicates.\n    Index.drop_duplicates : Return Index with duplicates removed.\n\n    Examples\n    --------\n\n    Works on different Index of types.\n\n    >>> pd.Index([1, 2, 2, 3, 3, 3, 4]).get_duplicates()  # doctest: +SKIP\n    [2, 3]\n\n    Note that for a DatetimeIndex, it does not return a list but a new\n    DatetimeIndex:\n\n    >>> dates = pd.to_datetime(['2018-01-01', '2018-01-02', '2018-01-03',\n    ...                         '2018-01-03', '2018-01-04', '2018-01-04'],\n    ...                        format='%Y-%m-%d')\n    >>> pd.Index(dates).get_duplicates()  # doctest: +SKIP\n    DatetimeIndex(['2018-01-03', '2018-01-04'],\n                  dtype='datetime64[ns]', freq=None)\n\n    Sorts duplicated elements even when indexes are unordered.\n\n    >>> pd.Index([1, 2, 3, 2, 3, 4, 3]).get_duplicates()  # doctest: +SKIP\n    [2, 3]\n\n    Return empty array-like structure when all elements are unique.\n\n    >>> pd.Index([1, 2, 3, 4]).get_duplicates()  # doctest: +SKIP\n    []\n    >>> dates = pd.to_datetime(['2018-01-01', '2018-01-02', '2018-01-03'],\n    ...                        format='%Y-%m-%d')\n    >>> pd.Index(dates).get_duplicates()  # doctest: +SKIP\n    DatetimeIndex([], dtype='datetime64[ns]', freq=None)\n    \"\"\"\n    warnings.warn(\"'get_duplicates' is deprecated and will be removed in a future release. You can use idx[idx.duplicated()].unique() instead\", FutureWarning, stacklevel=2)\n    return self[self.duplicated()].unique()",
                            "def _get_unique_index(self, dropna=False):\n    \"\"\"\n    Returns an index containing unique values.\n\n    Parameters\n    ----------\n    dropna : bool\n        If True, NaN values are dropped.\n\n    Returns\n    -------\n    uniques : index\n    \"\"\"\n    if self.is_unique and (not dropna):\n        return self\n    values = self.values\n    if not self.is_unique:\n        values = self.unique()\n    if dropna:\n        try:\n            if self.hasnans:\n                values = values[~isna(values)]\n        except NotImplementedError:\n            pass\n    return self._shallow_copy(values)",
                            "def __add__(self, other):\n    if isinstance(other, (ABCSeries, ABCDataFrame)):\n        return NotImplemented\n    from pandas import Series\n    return Index(Series(self) + other)",
                            "def __radd__(self, other):\n    from pandas import Series\n    return Index(other + Series(self))",
                            "def __iadd__(self, other):\n    return self + other",
                            "def __sub__(self, other):\n    return Index(np.array(self) - other)",
                            "def __rsub__(self, other):\n    from pandas import Series\n    return Index(other - Series(self))",
                            "def __and__(self, other):\n    return self.intersection(other)",
                            "def __or__(self, other):\n    return self.union(other)",
                            "def __xor__(self, other):\n    return self.symmetric_difference(other)",
                            "def __nonzero__(self):\n    raise ValueError('The truth value of a {0} is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().'.format(self.__class__.__name__))",
                            "def _get_reconciled_name_object(self, other):\n    \"\"\"\n    If the result of a set operation will be self,\n    return self, unless the name changes, in which\n    case make a shallow copy of self.\n    \"\"\"\n    name = get_op_result_name(self, other)\n    if self.name != name:\n        return self._shallow_copy(name=name)\n    return self",
                            "def _union_incompatible_dtypes(self, other, sort):\n    \"\"\"\n    Casts this and other index to object dtype to allow the formation\n    of a union between incompatible types.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : False or None, default False\n        Whether to sort the resulting index.\n\n        * False : do not sort the result.\n        * None : sort the result, except when `self` and `other` are equal\n          or when the values cannot be compared.\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    this = self.astype(object, copy=False)\n    other = Index(other).astype(object, copy=False)\n    return Index.union(this, other, sort=sort).astype(object, copy=False)",
                            "def _is_compatible_with_other(self, other):\n    \"\"\"\n    Check whether this and the other dtype are compatible with each other.\n    Meaning a union can be formed between them without needing to be cast\n    to dtype object.\n\n    Parameters\n    ----------\n    other : Index or array-like\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    return type(self) is type(other) and is_dtype_equal(self.dtype, other.dtype)",
                            "def _validate_sort_keyword(self, sort):\n    if sort not in [None, False]:\n        raise ValueError(\"The 'sort' keyword only takes the values of None or False; {0} was passed.\".format(sort))",
                            "def union(self, other, sort=None):\n    \"\"\"\n    Form the union of two Index objects.\n\n    If the Index objects are incompatible, both Index objects will be\n    cast to dtype('object') first.\n\n        .. versionchanged:: 0.25.0\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : bool or None, default None\n        Whether to sort the resulting Index.\n\n        * None : Sort the result, except when\n\n          1. `self` and `other` are equal.\n          2. `self` or `other` has length 0.\n          3. Some values in `self` or `other` cannot be compared.\n             A RuntimeWarning is issued in this case.\n\n        * False : do not sort the result.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    union : Index\n\n    Examples\n    --------\n\n    Union matching dtypes\n\n    >>> idx1 = pd.Index([1, 2, 3, 4])\n    >>> idx2 = pd.Index([3, 4, 5, 6])\n    >>> idx1.union(idx2)\n    Int64Index([1, 2, 3, 4, 5, 6], dtype='int64')\n\n    Union mismatched dtypes\n\n    >>> idx1 = pd.Index(['a', 'b', 'c', 'd'])\n    >>> idx2 = pd.Index([1, 2, 3, 4])\n    >>> idx1.union(idx2)\n    Index(['a', 'b', 'c', 'd', 1, 2, 3, 4], dtype='object')\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    if not self._is_compatible_with_other(other):\n        return self._union_incompatible_dtypes(other, sort=sort)\n    return self._union(other, sort=sort)",
                            "def _union(self, other, sort):\n    \"\"\"\n    Specific union logic should go here. In subclasses, union behavior\n    should be overwritten here rather than in `self.union`.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : False or None, default False\n        Whether to sort the resulting index.\n\n        * False : do not sort the result.\n        * None : sort the result, except when `self` and `other` are equal\n          or when the values cannot be compared.\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    if not len(other) or self.equals(other):\n        return self._get_reconciled_name_object(other)\n    if not len(self):\n        return other._get_reconciled_name_object(self)\n    if is_period_dtype(self) or is_datetime64tz_dtype(self):\n        lvals = self._ndarray_values\n    else:\n        lvals = self._values\n    if is_period_dtype(other) or is_datetime64tz_dtype(other):\n        rvals = other._ndarray_values\n    else:\n        rvals = other._values\n    if sort is None and self.is_monotonic and other.is_monotonic:\n        try:\n            result = self._outer_indexer(lvals, rvals)[0]\n        except TypeError:\n            result = list(lvals)\n            value_set = set(lvals)\n            result.extend([x for x in rvals if x not in value_set])\n    else:\n        indexer = self.get_indexer(other)\n        indexer, = (indexer == -1).nonzero()\n        if len(indexer) > 0:\n            other_diff = algos.take_nd(rvals, indexer, allow_fill=False)\n            result = concat_compat((lvals, other_diff))\n        else:\n            result = lvals\n        if sort is None:\n            try:\n                result = sorting.safe_sort(result)\n            except TypeError as e:\n                warnings.warn('{}, sort order is undefined for incomparable objects'.format(e), RuntimeWarning, stacklevel=3)\n    return self._wrap_setop_result(other, result)",
                            "def _wrap_setop_result(self, other, result):\n    return self._constructor(result, name=get_op_result_name(self, other))",
                            "@Appender(_index_shared_docs['intersection'])\ndef intersection(self, other, sort=False):\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other = ensure_index(other)\n    if self.equals(other):\n        return self._get_reconciled_name_object(other)\n    if not is_dtype_equal(self.dtype, other.dtype):\n        this = self.astype('O')\n        other = other.astype('O')\n        return this.intersection(other, sort=sort)\n    if is_period_dtype(self):\n        lvals = self._ndarray_values\n    else:\n        lvals = self._values\n    if is_period_dtype(other):\n        rvals = other._ndarray_values\n    else:\n        rvals = other._values\n    if self.is_monotonic and other.is_monotonic:\n        try:\n            result = self._inner_indexer(lvals, rvals)[0]\n            return self._wrap_setop_result(other, result)\n        except TypeError:\n            pass\n    try:\n        indexer = Index(rvals).get_indexer(lvals)\n        indexer = indexer.take((indexer != -1).nonzero()[0])\n    except Exception:\n        indexer = algos.unique1d(Index(rvals).get_indexer_non_unique(lvals)[0])\n        indexer = indexer[indexer != -1]\n    taken = other.take(indexer)\n    if sort is None:\n        taken = sorting.safe_sort(taken.values)\n        if self.name != other.name:\n            name = None\n        else:\n            name = self.name\n        return self._shallow_copy(taken, name=name)\n    if self.name != other.name:\n        taken.name = None\n    return taken",
                            "def difference(self, other, sort=None):\n    \"\"\"\n    Return a new Index with elements from the index that are not in\n    `other`.\n\n    This is the set difference of two Index objects.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : False or None, default None\n        Whether to sort the resulting index. By default, the\n        values are attempted to be sorted, but any TypeError from\n        incomparable elements is caught by pandas.\n\n        * None : Attempt to sort the result, but catch any TypeErrors\n          from comparing incomparable elements.\n        * False : Do not sort the result.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    difference : Index\n\n    Examples\n    --------\n\n    >>> idx1 = pd.Index([2, 1, 3, 4])\n    >>> idx2 = pd.Index([3, 4, 5, 6])\n    >>> idx1.difference(idx2)\n    Int64Index([1, 2], dtype='int64')\n    >>> idx1.difference(idx2, sort=False)\n    Int64Index([2, 1], dtype='int64')\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    if self.equals(other):\n        return self._shallow_copy(self._data[:0])\n    other, result_name = self._convert_can_do_setop(other)\n    this = self._get_unique_index()\n    indexer = this.get_indexer(other)\n    indexer = indexer.take((indexer != -1).nonzero()[0])\n    label_diff = np.setdiff1d(np.arange(this.size), indexer, assume_unique=True)\n    the_diff = this.values.take(label_diff)\n    if sort is None:\n        try:\n            the_diff = sorting.safe_sort(the_diff)\n        except TypeError:\n            pass\n    return this._shallow_copy(the_diff, name=result_name, freq=None)",
                            "def symmetric_difference(self, other, result_name=None, sort=None):\n    \"\"\"\n    Compute the symmetric difference of two Index objects.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    result_name : str\n    sort : False or None, default None\n        Whether to sort the resulting index. By default, the\n        values are attempted to be sorted, but any TypeError from\n        incomparable elements is caught by pandas.\n\n        * None : Attempt to sort the result, but catch any TypeErrors\n          from comparing incomparable elements.\n        * False : Do not sort the result.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    symmetric_difference : Index\n\n    Notes\n    -----\n    ``symmetric_difference`` contains elements that appear in either\n    ``idx1`` or ``idx2`` but not both. Equivalent to the Index created by\n    ``idx1.difference(idx2) | idx2.difference(idx1)`` with duplicates\n    dropped.\n\n    Examples\n    --------\n    >>> idx1 = pd.Index([1, 2, 3, 4])\n    >>> idx2 = pd.Index([2, 3, 4, 5])\n    >>> idx1.symmetric_difference(idx2)\n    Int64Index([1, 5], dtype='int64')\n\n    You can also use the ``^`` operator:\n\n    >>> idx1 ^ idx2\n    Int64Index([1, 5], dtype='int64')\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other, result_name_update = self._convert_can_do_setop(other)\n    if result_name is None:\n        result_name = result_name_update\n    this = self._get_unique_index()\n    other = other._get_unique_index()\n    indexer = this.get_indexer(other)\n    common_indexer = indexer.take((indexer != -1).nonzero()[0])\n    left_indexer = np.setdiff1d(np.arange(this.size), common_indexer, assume_unique=True)\n    left_diff = this.values.take(left_indexer)\n    right_indexer = (indexer == -1).nonzero()[0]\n    right_diff = other.values.take(right_indexer)\n    the_diff = concat_compat([left_diff, right_diff])\n    if sort is None:\n        try:\n            the_diff = sorting.safe_sort(the_diff)\n        except TypeError:\n            pass\n    attribs = self._get_attributes_dict()\n    attribs['name'] = result_name\n    if 'freq' in attribs:\n        attribs['freq'] = None\n    return self._shallow_copy_with_infer(the_diff, **attribs)",
                            "def _assert_can_do_setop(self, other):\n    if not is_list_like(other):\n        raise TypeError('Input must be Index or array-like')\n    return True",
                            "def _convert_can_do_setop(self, other):\n    if not isinstance(other, Index):\n        other = Index(other, name=self.name)\n        result_name = self.name\n    else:\n        result_name = get_op_result_name(self, other)\n    return (other, result_name)",
                            "@Appender(_index_shared_docs['get_loc'])\ndef get_loc(self, key, method=None, tolerance=None):\n    if method is None:\n        if tolerance is not None:\n            raise ValueError('tolerance argument only valid if using pad, backfill or nearest lookups')\n        try:\n            return self._engine.get_loc(key)\n        except KeyError:\n            return self._engine.get_loc(self._maybe_cast_indexer(key))\n    indexer = self.get_indexer([key], method=method, tolerance=tolerance)\n    if indexer.ndim > 1 or indexer.size > 1:\n        raise TypeError('get_loc requires scalar valued input')\n    loc = indexer.item()\n    if loc == -1:\n        raise KeyError(key)\n    return loc",
                            "@Appender(_index_shared_docs['get_indexer'] % _index_doc_kwargs)\ndef get_indexer(self, target, method=None, limit=None, tolerance=None):\n    method = missing.clean_reindex_fill_method(method)\n    target = ensure_index(target)\n    if tolerance is not None:\n        tolerance = self._convert_tolerance(tolerance, target)\n    if target.is_boolean() and self.is_numeric():\n        return ensure_platform_int(np.repeat(-1, target.size))\n    pself, ptarget = self._maybe_promote(target)\n    if pself is not self or ptarget is not target:\n        return pself.get_indexer(ptarget, method=method, limit=limit, tolerance=tolerance)\n    if not is_dtype_equal(self.dtype, target.dtype):\n        this = self.astype(object)\n        target = target.astype(object)\n        return this.get_indexer(target, method=method, limit=limit, tolerance=tolerance)\n    if not self.is_unique:\n        raise InvalidIndexError('Reindexing only valid with uniquely valued Index objects')\n    if method == 'pad' or method == 'backfill':\n        indexer = self._get_fill_indexer(target, method, limit, tolerance)\n    elif method == 'nearest':\n        indexer = self._get_nearest_indexer(target, limit, tolerance)\n    else:\n        if tolerance is not None:\n            raise ValueError('tolerance argument only valid if doing pad, backfill or nearest reindexing')\n        if limit is not None:\n            raise ValueError('limit argument only valid if doing pad, backfill or nearest reindexing')\n        indexer = self._engine.get_indexer(target._ndarray_values)\n    return ensure_platform_int(indexer)",
                            "def _convert_tolerance(self, tolerance, target):\n    tolerance = np.asarray(tolerance)\n    if target.size != tolerance.size and tolerance.size > 1:\n        raise ValueError('list-like tolerance size must match target index size')\n    return tolerance",
                            "def _get_fill_indexer(self, target, method, limit=None, tolerance=None):\n    if self.is_monotonic_increasing and target.is_monotonic_increasing:\n        method = self._engine.get_pad_indexer if method == 'pad' else self._engine.get_backfill_indexer\n        indexer = method(target._ndarray_values, limit)\n    else:\n        indexer = self._get_fill_indexer_searchsorted(target, method, limit)\n    if tolerance is not None:\n        indexer = self._filter_indexer_tolerance(target._ndarray_values, indexer, tolerance)\n    return indexer",
                            "def _get_fill_indexer_searchsorted(self, target, method, limit=None):\n    \"\"\"\n    Fallback pad/backfill get_indexer that works for monotonic decreasing\n    indexes and non-monotonic targets.\n    \"\"\"\n    if limit is not None:\n        raise ValueError('limit argument for %r method only well-defined if index and target are monotonic' % method)\n    side = 'left' if method == 'pad' else 'right'\n    indexer = self.get_indexer(target)\n    nonexact = indexer == -1\n    indexer[nonexact] = self._searchsorted_monotonic(target[nonexact], side)\n    if side == 'left':\n        indexer[nonexact] -= 1\n    else:\n        indexer[indexer == len(self)] = -1\n    return indexer",
                            "def _get_nearest_indexer(self, target, limit, tolerance):\n    \"\"\"\n    Get the indexer for the nearest index labels; requires an index with\n    values that can be subtracted from each other (e.g., not strings or\n    tuples).\n    \"\"\"\n    left_indexer = self.get_indexer(target, 'pad', limit=limit)\n    right_indexer = self.get_indexer(target, 'backfill', limit=limit)\n    target = np.asarray(target)\n    left_distances = abs(self.values[left_indexer] - target)\n    right_distances = abs(self.values[right_indexer] - target)\n    op = operator.lt if self.is_monotonic_increasing else operator.le\n    indexer = np.where(op(left_distances, right_distances) | (right_indexer == -1), left_indexer, right_indexer)\n    if tolerance is not None:\n        indexer = self._filter_indexer_tolerance(target, indexer, tolerance)\n    return indexer",
                            "def _filter_indexer_tolerance(self, target, indexer, tolerance):\n    distance = abs(self.values[indexer] - target)\n    indexer = np.where(distance <= tolerance, indexer, -1)\n    return indexer",
                            "@Appender(_index_shared_docs['_convert_scalar_indexer'])\ndef _convert_scalar_indexer(self, key, kind=None):\n    assert kind in ['ix', 'loc', 'getitem', 'iloc', None]\n    if kind == 'iloc':\n        return self._validate_indexer('positional', key, kind)\n    if len(self) and (not isinstance(self, ABCMultiIndex)):\n        if kind in ['getitem', 'ix'] and is_float(key):\n            if not self.is_floating():\n                return self._invalid_indexer('label', key)\n        elif kind in ['loc'] and is_float(key):\n            if self.inferred_type not in ['floating', 'mixed-integer-float', 'integer-na', 'string', 'unicode', 'mixed']:\n                return self._invalid_indexer('label', key)\n        elif kind in ['loc'] and is_integer(key):\n            if not self.holds_integer():\n                return self._invalid_indexer('label', key)\n    return key",
                            "@Appender(_index_shared_docs['_convert_slice_indexer'])\ndef _convert_slice_indexer(self, key: slice, kind=None):\n    assert kind in ['ix', 'loc', 'getitem', 'iloc', None]\n    if kind == 'iloc':\n        return slice(self._validate_indexer('slice', key.start, kind), self._validate_indexer('slice', key.stop, kind), self._validate_indexer('slice', key.step, kind))\n    start, stop, step = (key.start, key.stop, key.step)\n\n    def is_int(v):\n        return v is None or is_integer(v)\n    is_null_slicer = start is None and stop is None\n    is_index_slice = is_int(start) and is_int(stop)\n    is_positional = is_index_slice and (not self.is_integer())\n    if kind == 'getitem':\n        '\\n            called from the getitem slicers, validate that we are in fact\\n            integers\\n            '\n        if self.is_integer() or is_index_slice:\n            return slice(self._validate_indexer('slice', key.start, kind), self._validate_indexer('slice', key.stop, kind), self._validate_indexer('slice', key.step, kind))\n    try:\n        if is_positional and self.is_mixed():\n            if start is not None:\n                self.get_loc(start)\n            if stop is not None:\n                self.get_loc(stop)\n            is_positional = False\n    except KeyError:\n        if self.inferred_type in ['mixed-integer-float', 'integer-na']:\n            raise\n    if is_null_slicer:\n        indexer = key\n    elif is_positional:\n        indexer = key\n    else:\n        try:\n            indexer = self.slice_indexer(start, stop, step, kind=kind)\n        except Exception:\n            if is_index_slice:\n                if self.is_integer():\n                    raise\n                else:\n                    indexer = key\n            else:\n                raise\n    return indexer",
                            "def _convert_listlike_indexer(self, keyarr, kind=None):\n    \"\"\"\n    Parameters\n    ----------\n    keyarr : list-like\n        Indexer to convert.\n\n    Returns\n    -------\n    indexer : numpy.ndarray or None\n        Return an ndarray or None if cannot convert.\n    keyarr : numpy.ndarray\n        Return tuple-safe keys.\n    \"\"\"\n    if isinstance(keyarr, Index):\n        keyarr = self._convert_index_indexer(keyarr)\n    else:\n        keyarr = self._convert_arr_indexer(keyarr)\n    indexer = self._convert_list_indexer(keyarr, kind=kind)\n    return (indexer, keyarr)",
                            "@Appender(_index_shared_docs['_convert_arr_indexer'])\ndef _convert_arr_indexer(self, keyarr):\n    keyarr = com.asarray_tuplesafe(keyarr)\n    return keyarr",
                            "@Appender(_index_shared_docs['_convert_index_indexer'])\ndef _convert_index_indexer(self, keyarr):\n    return keyarr",
                            "@Appender(_index_shared_docs['_convert_list_indexer'])\ndef _convert_list_indexer(self, keyarr, kind=None):\n    if kind in [None, 'iloc', 'ix'] and is_integer_dtype(keyarr) and (not self.is_floating()) and (not isinstance(keyarr, ABCPeriodIndex)):\n        if self.inferred_type == 'mixed-integer':\n            indexer = self.get_indexer(keyarr)\n            if (indexer >= 0).all():\n                return indexer\n            indexer[indexer < 0] = len(self)\n            return maybe_convert_indices(indexer, len(self))\n        elif not self.inferred_type == 'integer':\n            keyarr = np.where(keyarr < 0, len(self) + keyarr, keyarr)\n            return keyarr\n    return None",
                            "def _invalid_indexer(self, form, key):\n    \"\"\"\n    Consistent invalid indexer message.\n    \"\"\"\n    raise TypeError('cannot do {form} indexing on {klass} with these indexers [{key}] of {kind}'.format(form=form, klass=type(self), key=key, kind=type(key)))",
                            "def _can_reindex(self, indexer):\n    \"\"\"\n    Check if we are allowing reindexing with this particular indexer.\n\n    Parameters\n    ----------\n    indexer : an integer indexer\n\n    Raises\n    ------\n    ValueError if its a duplicate axis\n    \"\"\"\n    if not self.is_unique and len(indexer):\n        raise ValueError('cannot reindex from a duplicate axis')",
                            "def reindex(self, target, method=None, level=None, limit=None, tolerance=None):\n    \"\"\"\n    Create index with target's values (move/add/delete values\n    as necessary).\n\n    Parameters\n    ----------\n    target : an iterable\n\n    Returns\n    -------\n    new_index : pd.Index\n        Resulting index.\n    indexer : np.ndarray or None\n        Indices of output values in original index.\n    \"\"\"\n    preserve_names = not hasattr(target, 'name')\n    target = _ensure_has_len(target)\n    if not isinstance(target, Index) and len(target) == 0:\n        attrs = self._get_attributes_dict()\n        attrs.pop('freq', None)\n        values = self._data[:0]\n        target = self._simple_new(values, dtype=self.dtype, **attrs)\n    else:\n        target = ensure_index(target)\n    if level is not None:\n        if method is not None:\n            raise TypeError('Fill method not supported if level passed')\n        _, indexer, _ = self._join_level(target, level, how='right', return_indexers=True)\n    elif self.equals(target):\n        indexer = None\n    elif self.is_unique and (not getattr(self, 'is_overlapping', False)):\n        indexer = self.get_indexer(target, method=method, limit=limit, tolerance=tolerance)\n    else:\n        if method is not None or limit is not None:\n            raise ValueError('cannot reindex a non-unique index with a method or limit')\n        indexer, missing = self.get_indexer_non_unique(target)\n    if preserve_names and target.nlevels == 1 and (target.name != self.name):\n        target = target.copy()\n        target.name = self.name\n    return (target, indexer)",
                            "def _reindex_non_unique(self, target):\n    \"\"\"\n    Create a new index with target's values (move/add/delete values as\n    necessary) use with non-unique Index and a possibly non-unique target.\n\n    Parameters\n    ----------\n    target : an iterable\n\n    Returns\n    -------\n    new_index : pd.Index\n        Resulting index.\n    indexer : np.ndarray or None\n        Indices of output values in original index.\n\n    \"\"\"\n    target = ensure_index(target)\n    indexer, missing = self.get_indexer_non_unique(target)\n    check = indexer != -1\n    new_labels = self.take(indexer[check])\n    new_indexer = None\n    if len(missing):\n        length = np.arange(len(indexer))\n        missing = ensure_platform_int(missing)\n        missing_labels = target.take(missing)\n        missing_indexer = ensure_int64(length[~check])\n        cur_labels = self.take(indexer[check]).values\n        cur_indexer = ensure_int64(length[check])\n        new_labels = np.empty(tuple([len(indexer)]), dtype=object)\n        new_labels[cur_indexer] = cur_labels\n        new_labels[missing_indexer] = missing_labels\n        if target.is_unique:\n            new_indexer = np.arange(len(indexer))\n            new_indexer[cur_indexer] = np.arange(len(cur_labels))\n            new_indexer[missing_indexer] = -1\n        else:\n            indexer[~check] = -1\n            new_indexer = np.arange(len(self.take(indexer)))\n            new_indexer[~check] = -1\n    new_index = self._shallow_copy_with_infer(new_labels, freq=None)\n    return (new_index, indexer, new_indexer)",
                            "@Appender(_index_shared_docs['join'])\ndef join(self, other, how='left', level=None, return_indexers=False, sort=False):\n    self_is_mi = isinstance(self, ABCMultiIndex)\n    other_is_mi = isinstance(other, ABCMultiIndex)\n    if level is None and (self_is_mi or other_is_mi):\n        if self.names == other.names:\n            pass\n        else:\n            return self._join_multi(other, how=how, return_indexers=return_indexers)\n    if level is not None and (self_is_mi or other_is_mi):\n        return self._join_level(other, level, how=how, return_indexers=return_indexers)\n    other = ensure_index(other)\n    if len(other) == 0 and how in ('left', 'outer'):\n        join_index = self._shallow_copy()\n        if return_indexers:\n            rindexer = np.repeat(-1, len(join_index))\n            return (join_index, None, rindexer)\n        else:\n            return join_index\n    if len(self) == 0 and how in ('right', 'outer'):\n        join_index = other._shallow_copy()\n        if return_indexers:\n            lindexer = np.repeat(-1, len(join_index))\n            return (join_index, lindexer, None)\n        else:\n            return join_index\n    if self._join_precedence < other._join_precedence:\n        how = {'right': 'left', 'left': 'right'}.get(how, how)\n        result = other.join(self, how=how, level=level, return_indexers=return_indexers)\n        if return_indexers:\n            x, y, z = result\n            result = (x, z, y)\n        return result\n    if not is_dtype_equal(self.dtype, other.dtype):\n        this = self.astype('O')\n        other = other.astype('O')\n        return this.join(other, how=how, return_indexers=return_indexers)\n    _validate_join_method(how)\n    if not self.is_unique and (not other.is_unique):\n        return self._join_non_unique(other, how=how, return_indexers=return_indexers)\n    elif not self.is_unique or not other.is_unique:\n        if self.is_monotonic and other.is_monotonic:\n            return self._join_monotonic(other, how=how, return_indexers=return_indexers)\n        else:\n            return self._join_non_unique(other, how=how, return_indexers=return_indexers)\n    elif self.is_monotonic and other.is_monotonic:\n        try:\n            return self._join_monotonic(other, how=how, return_indexers=return_indexers)\n        except TypeError:\n            pass\n    if how == 'left':\n        join_index = self\n    elif how == 'right':\n        join_index = other\n    elif how == 'inner':\n        join_index = self.intersection(other, sort=False)\n    elif how == 'outer':\n        join_index = self.union(other)\n    if sort:\n        join_index = join_index.sort_values()\n    if return_indexers:\n        if join_index is self:\n            lindexer = None\n        else:\n            lindexer = self.get_indexer(join_index)\n        if join_index is other:\n            rindexer = None\n        else:\n            rindexer = other.get_indexer(join_index)\n        return (join_index, lindexer, rindexer)\n    else:\n        return join_index",
                            "def _join_multi(self, other, how, return_indexers=True):\n    from .multi import MultiIndex\n    from pandas.core.reshape.merge import _restore_dropped_levels_multijoin\n    self_names = set(com.not_none(*self.names))\n    other_names = set(com.not_none(*other.names))\n    overlap = self_names & other_names\n    if not overlap:\n        raise ValueError('cannot join with no overlapping index names')\n    self_is_mi = isinstance(self, MultiIndex)\n    other_is_mi = isinstance(other, MultiIndex)\n    if self_is_mi and other_is_mi:\n        ldrop_names = list(self_names - overlap)\n        rdrop_names = list(other_names - overlap)\n        self_jnlevels = self.droplevel(ldrop_names)\n        other_jnlevels = other.droplevel(rdrop_names)\n        join_idx, lidx, ridx = self_jnlevels.join(other_jnlevels, how, return_indexers=True)\n        dropped_names = ldrop_names + rdrop_names\n        levels, codes, names = _restore_dropped_levels_multijoin(self, other, dropped_names, join_idx, lidx, ridx)\n        multi_join_idx = MultiIndex(levels=levels, codes=codes, names=names, verify_integrity=False)\n        multi_join_idx = multi_join_idx.remove_unused_levels()\n        return (multi_join_idx, lidx, ridx)\n    jl = list(overlap)[0]\n    flip_order = False\n    if self_is_mi:\n        self, other = (other, self)\n        flip_order = True\n        how = {'right': 'left', 'left': 'right'}.get(how, how)\n    level = other.names.index(jl)\n    result = self._join_level(other, level, how=how, return_indexers=return_indexers)\n    if flip_order:\n        if isinstance(result, tuple):\n            return (result[0], result[2], result[1])\n    return result",
                            "def _join_non_unique(self, other, how='left', return_indexers=False):\n    from pandas.core.reshape.merge import _get_join_indexers\n    left_idx, right_idx = _get_join_indexers([self._ndarray_values], [other._ndarray_values], how=how, sort=True)\n    left_idx = ensure_platform_int(left_idx)\n    right_idx = ensure_platform_int(right_idx)\n    join_index = np.asarray(self._ndarray_values.take(left_idx))\n    mask = left_idx == -1\n    np.putmask(join_index, mask, other._ndarray_values.take(right_idx))\n    join_index = self._wrap_joined_index(join_index, other)\n    if return_indexers:\n        return (join_index, left_idx, right_idx)\n    else:\n        return join_index",
                            "def _join_level(self, other, level, how='left', return_indexers=False, keep_order=True):\n    \"\"\"\n    The join method *only* affects the level of the resulting\n    MultiIndex. Otherwise it just exactly aligns the Index data to the\n    labels of the level in the MultiIndex.\n\n    If ```keep_order == True```, the order of the data indexed by the\n    MultiIndex will not be changed; otherwise, it will tie out\n    with `other`.\n    \"\"\"\n    from .multi import MultiIndex\n\n    def _get_leaf_sorter(labels):\n        \"\"\"\n        Returns sorter for the inner most level while preserving the\n        order of higher levels.\n        \"\"\"\n        if labels[0].size == 0:\n            return np.empty(0, dtype='int64')\n        if len(labels) == 1:\n            lab = ensure_int64(labels[0])\n            sorter, _ = libalgos.groupsort_indexer(lab, 1 + lab.max())\n            return sorter\n        tic = labels[0][:-1] != labels[0][1:]\n        for lab in labels[1:-1]:\n            tic |= lab[:-1] != lab[1:]\n        starts = np.hstack(([True], tic, [True])).nonzero()[0]\n        lab = ensure_int64(labels[-1])\n        return lib.get_level_sorter(lab, ensure_int64(starts))\n    if isinstance(self, MultiIndex) and isinstance(other, MultiIndex):\n        raise TypeError('Join on level between two MultiIndex objects is ambiguous')\n    left, right = (self, other)\n    flip_order = not isinstance(self, MultiIndex)\n    if flip_order:\n        left, right = (right, left)\n        how = {'right': 'left', 'left': 'right'}.get(how, how)\n    level = left._get_level_number(level)\n    old_level = left.levels[level]\n    if not right.is_unique:\n        raise NotImplementedError('Index._join_level on non-unique index is not implemented')\n    new_level, left_lev_indexer, right_lev_indexer = old_level.join(right, how=how, return_indexers=True)\n    if left_lev_indexer is None:\n        if keep_order or len(left) == 0:\n            left_indexer = None\n            join_index = left\n        else:\n            left_indexer = _get_leaf_sorter(left.codes[:level + 1])\n            join_index = left[left_indexer]\n    else:\n        left_lev_indexer = ensure_int64(left_lev_indexer)\n        rev_indexer = lib.get_reverse_indexer(left_lev_indexer, len(old_level))\n        new_lev_codes = algos.take_nd(rev_indexer, left.codes[level], allow_fill=False)\n        new_codes = list(left.codes)\n        new_codes[level] = new_lev_codes\n        new_levels = list(left.levels)\n        new_levels[level] = new_level\n        if keep_order:\n            left_indexer = np.arange(len(left), dtype=np.intp)\n            mask = new_lev_codes != -1\n            if not mask.all():\n                new_codes = [lab[mask] for lab in new_codes]\n                left_indexer = left_indexer[mask]\n        elif level == 0:\n            ngroups = 1 + new_lev_codes.max()\n            left_indexer, counts = libalgos.groupsort_indexer(new_lev_codes, ngroups)\n            left_indexer = left_indexer[counts[0]:]\n            new_codes = [lab[left_indexer] for lab in new_codes]\n        else:\n            mask = new_lev_codes != -1\n            mask_all = mask.all()\n            if not mask_all:\n                new_codes = [lab[mask] for lab in new_codes]\n            left_indexer = _get_leaf_sorter(new_codes[:level + 1])\n            new_codes = [lab[left_indexer] for lab in new_codes]\n            if not mask_all:\n                left_indexer = mask.nonzero()[0][left_indexer]\n        join_index = MultiIndex(levels=new_levels, codes=new_codes, names=left.names, verify_integrity=False)\n    if right_lev_indexer is not None:\n        right_indexer = algos.take_nd(right_lev_indexer, join_index.codes[level], allow_fill=False)\n    else:\n        right_indexer = join_index.codes[level]\n    if flip_order:\n        left_indexer, right_indexer = (right_indexer, left_indexer)\n    if return_indexers:\n        left_indexer = None if left_indexer is None else ensure_platform_int(left_indexer)\n        right_indexer = None if right_indexer is None else ensure_platform_int(right_indexer)\n        return (join_index, left_indexer, right_indexer)\n    else:\n        return join_index",
                            "def _join_monotonic(self, other, how='left', return_indexers=False):\n    if self.equals(other):\n        ret_index = other if how == 'right' else self\n        if return_indexers:\n            return (ret_index, None, None)\n        else:\n            return ret_index\n    sv = self._ndarray_values\n    ov = other._ndarray_values\n    if self.is_unique and other.is_unique:\n        if how == 'left':\n            join_index = self\n            lidx = None\n            ridx = self._left_indexer_unique(sv, ov)\n        elif how == 'right':\n            join_index = other\n            lidx = self._left_indexer_unique(ov, sv)\n            ridx = None\n        elif how == 'inner':\n            join_index, lidx, ridx = self._inner_indexer(sv, ov)\n            join_index = self._wrap_joined_index(join_index, other)\n        elif how == 'outer':\n            join_index, lidx, ridx = self._outer_indexer(sv, ov)\n            join_index = self._wrap_joined_index(join_index, other)\n    else:\n        if how == 'left':\n            join_index, lidx, ridx = self._left_indexer(sv, ov)\n        elif how == 'right':\n            join_index, ridx, lidx = self._left_indexer(ov, sv)\n        elif how == 'inner':\n            join_index, lidx, ridx = self._inner_indexer(sv, ov)\n        elif how == 'outer':\n            join_index, lidx, ridx = self._outer_indexer(sv, ov)\n        join_index = self._wrap_joined_index(join_index, other)\n    if return_indexers:\n        lidx = None if lidx is None else ensure_platform_int(lidx)\n        ridx = None if ridx is None else ensure_platform_int(ridx)\n        return (join_index, lidx, ridx)\n    else:\n        return join_index",
                            "def _wrap_joined_index(self, joined, other):\n    name = get_op_result_name(self, other)\n    return Index(joined, name=name)",
                            "@property\ndef values(self):\n    \"\"\"\n    Return an array representing the data in the Index.\n\n    .. warning::\n\n       We recommend using :attr:`Index.array` or\n       :meth:`Index.to_numpy`, depending on whether you need\n       a reference to the underlying data or a NumPy array.\n\n    Returns\n    -------\n    array: numpy.ndarray or ExtensionArray\n\n    See Also\n    --------\n    Index.array : Reference to the underlying data.\n    Index.to_numpy : A NumPy array representing the underlying data.\n    \"\"\"\n    return self._data.view(np.ndarray)",
                            "@property\ndef _values(self) -> Union[ExtensionArray, ABCIndexClass, np.ndarray]:\n    \"\"\"\n    The best array representation.\n\n    This is an ndarray, ExtensionArray, or Index subclass. This differs\n    from ``_ndarray_values``, which always returns an ndarray.\n\n    Both ``_values`` and ``_ndarray_values`` are consistent between\n    ``Series`` and ``Index``.\n\n    It may differ from the public '.values' method.\n\n    index             | values          | _values       | _ndarray_values |\n    ----------------- | --------------- | ------------- | --------------- |\n    Index             | ndarray         | ndarray       | ndarray         |\n    CategoricalIndex  | Categorical     | Categorical   | ndarray[int]    |\n    DatetimeIndex     | ndarray[M8ns]   | ndarray[M8ns] | ndarray[M8ns]   |\n    DatetimeIndex[tz] | ndarray[M8ns]   | DTI[tz]       | ndarray[M8ns]   |\n    PeriodIndex       | ndarray[object] | PeriodArray   | ndarray[int]    |\n    IntervalIndex     | IntervalArray   | IntervalArray | ndarray[object] |\n\n    See Also\n    --------\n    values\n    _ndarray_values\n    \"\"\"\n    return self._data",
                            "def get_values(self):\n    \"\"\"\n    Return `Index` data as an `numpy.ndarray`.\n\n    .. deprecated:: 0.25.0\n        Use :meth:`Index.to_numpy` or :attr:`Index.array` instead.\n\n    Returns\n    -------\n    numpy.ndarray\n        A one-dimensional numpy array of the `Index` values.\n\n    See Also\n    --------\n    Index.values : The attribute that get_values wraps.\n\n    Examples\n    --------\n    Getting the `Index` values of a `DataFrame`:\n\n    >>> df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n    ...                    index=['a', 'b', 'c'], columns=['A', 'B', 'C'])\n    >>> df\n       A  B  C\n    a  1  2  3\n    b  4  5  6\n    c  7  8  9\n    >>> df.index.get_values()\n    array(['a', 'b', 'c'], dtype=object)\n\n    Standalone `Index` values:\n\n    >>> idx = pd.Index(['1', '2', '3'])\n    >>> idx.get_values()\n    array(['1', '2', '3'], dtype=object)\n\n    `MultiIndex` arrays also have only one dimension:\n\n    >>> midx = pd.MultiIndex.from_arrays([[1, 2, 3], ['a', 'b', 'c']],\n    ...                                  names=('number', 'letter'))\n    >>> midx.get_values()\n    array([(1, 'a'), (2, 'b'), (3, 'c')], dtype=object)\n    >>> midx.get_values().ndim\n    1\n    \"\"\"\n    warnings.warn(\"The 'get_values' method is deprecated and will be removed in a future version. Use '.to_numpy()' or '.array' instead.\", FutureWarning, stacklevel=2)\n    return self._internal_get_values()",
                            "def _internal_get_values(self):\n    return self.values",
                            "@Appender(IndexOpsMixin.memory_usage.__doc__)\ndef memory_usage(self, deep=False):\n    result = super().memory_usage(deep=deep)\n    result += self._engine.sizeof(deep=deep)\n    return result",
                            "@Appender(_index_shared_docs['where'])\ndef where(self, cond, other=None):\n    if other is None:\n        other = self._na_value\n    dtype = self.dtype\n    values = self.values\n    if is_bool(other) or is_bool_dtype(other):\n        values = values.astype(object)\n        dtype = None\n    values = np.where(cond, values, other)\n    if self._is_numeric_dtype and np.any(isna(values)):\n        dtype = None\n    return self._shallow_copy_with_infer(values, dtype=dtype)",
                            "@classmethod\ndef _try_convert_to_int_index(cls, data, copy, name, dtype):\n    \"\"\"\n    Attempt to convert an array of data into an integer index.\n\n    Parameters\n    ----------\n    data : The data to convert.\n    copy : Whether to copy the data or not.\n    name : The name of the index returned.\n\n    Returns\n    -------\n    int_index : data converted to either an Int64Index or a\n                UInt64Index\n\n    Raises\n    ------\n    ValueError if the conversion was not successful.\n    \"\"\"\n    from .numeric import Int64Index, UInt64Index\n    if not is_unsigned_integer_dtype(dtype):\n        try:\n            res = data.astype('i8', copy=False)\n            if (res == data).all():\n                return Int64Index(res, copy=copy, name=name)\n        except (OverflowError, TypeError, ValueError):\n            pass\n    try:\n        res = data.astype('u8', copy=False)\n        if (res == data).all():\n            return UInt64Index(res, copy=copy, name=name)\n    except (OverflowError, TypeError, ValueError):\n        pass\n    raise ValueError",
                            "@classmethod\ndef _scalar_data_error(cls, data):\n    return TypeError('{0}(...) must be called with a collection of some kind, {1} was passed'.format(cls.__name__, repr(data)))",
                            "@classmethod\ndef _string_data_error(cls, data):\n    raise TypeError('String dtype not supported, you may need to explicitly cast to a numeric type')",
                            "@classmethod\ndef _coerce_to_ndarray(cls, data):\n    \"\"\"\n    Coerces data to ndarray.\n\n    Converts other iterables to list first and then to array.\n    Does not touch ndarrays.\n\n    Raises\n    ------\n    TypeError\n        When the data passed in is a scalar.\n    \"\"\"\n    if not isinstance(data, (np.ndarray, Index)):\n        if data is None or is_scalar(data):\n            raise cls._scalar_data_error(data)\n        if not isinstance(data, (ABCSeries, list, tuple)):\n            data = list(data)\n        data = np.asarray(data)\n    return data",
                            "def _coerce_scalar_to_index(self, item):\n    \"\"\"\n    We need to coerce a scalar to a compat for our index type.\n\n    Parameters\n    ----------\n    item : scalar item to coerce\n    \"\"\"\n    dtype = self.dtype\n    if self._is_numeric_dtype and isna(item):\n        dtype = None\n    return Index([item], dtype=dtype, **self._get_attributes_dict())",
                            "def _to_safe_for_reshape(self):\n    \"\"\"\n    Convert to object if we are a categorical.\n    \"\"\"\n    return self",
                            "def _convert_for_op(self, value):\n    \"\"\"\n    Convert value to be insertable to ndarray.\n    \"\"\"\n    return value",
                            "def _assert_can_do_op(self, value):\n    \"\"\"\n    Check value is valid for scalar op.\n    \"\"\"\n    if not is_scalar(value):\n        msg = \"'value' must be a scalar, passed: {0}\"\n        raise TypeError(msg.format(type(value).__name__))",
                            "@property\ndef _has_complex_internals(self):\n    return False",
                            "def _is_memory_usage_qualified(self):\n    \"\"\"\n    Return a boolean if we need a qualified .info display.\n    \"\"\"\n    return self.is_object()",
                            "def is_type_compatible(self, kind):\n    \"\"\"\n    Whether the index type is compatible with the provided type.\n    \"\"\"\n    return kind == self.inferred_type",
                            "@Appender(_index_shared_docs['contains'] % _index_doc_kwargs)\ndef __contains__(self, key):\n    hash(key)\n    try:\n        return key in self._engine\n    except (OverflowError, TypeError, ValueError):\n        return False",
                            "def contains(self, key):\n    \"\"\"\n    Return a boolean indicating whether the provided key is in the index.\n\n    .. deprecated:: 0.25.0\n        Use ``key in index`` instead of ``index.contains(key)``.\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    warnings.warn(\"The 'contains' method is deprecated and will be removed in a future version. Use 'key in index' instead of 'index.contains(key)'\", FutureWarning, stacklevel=2)\n    return key in self",
                            "def __hash__(self):\n    raise TypeError('unhashable type: %r' % type(self).__name__)",
                            "def __setitem__(self, key, value):\n    raise TypeError('Index does not support mutable operations')",
                            "def __getitem__(self, key):\n    \"\"\"\n    Override numpy.ndarray's __getitem__ method to work as desired.\n\n    This function adds lists and Series as valid boolean indexers\n    (ndarrays only supports ndarray with dtype=bool).\n\n    If resulting ndim != 1, plain ndarray is returned instead of\n    corresponding `Index` subclass.\n\n    \"\"\"\n    getitem = self._data.__getitem__\n    promote = self._shallow_copy\n    if is_scalar(key):\n        key = com.cast_scalar_indexer(key)\n        return getitem(key)\n    if isinstance(key, slice):\n        return promote(getitem(key))\n    if com.is_bool_indexer(key):\n        key = np.asarray(key, dtype=bool)\n    key = com.values_from_object(key)\n    result = getitem(key)\n    if not is_scalar(result):\n        return promote(result)\n    else:\n        return result",
                            "def _can_hold_identifiers_and_holds_name(self, name):\n    \"\"\"\n    Faster check for ``name in self`` when we know `name` is a Python\n    identifier (e.g. in NDFrame.__getattr__, which hits this to support\n    . key lookup). For indexes that can't hold identifiers (everything\n    but object & categorical) we just return False.\n\n    https://github.com/pandas-dev/pandas/issues/19764\n    \"\"\"\n    if self.is_object() or self.is_categorical():\n        return name in self\n    return False",
                            "def append(self, other):\n    \"\"\"\n    Append a collection of Index options together.\n\n    Parameters\n    ----------\n    other : Index or list/tuple of indices\n\n    Returns\n    -------\n    appended : Index\n    \"\"\"\n    to_concat = [self]\n    if isinstance(other, (list, tuple)):\n        to_concat = to_concat + list(other)\n    else:\n        to_concat.append(other)\n    for obj in to_concat:\n        if not isinstance(obj, Index):\n            raise TypeError('all inputs must be Index')\n    names = {obj.name for obj in to_concat}\n    name = None if len(names) > 1 else self.name\n    return self._concat(to_concat, name)",
                            "def _concat(self, to_concat, name):\n    typs = _concat.get_dtype_kinds(to_concat)\n    if len(typs) == 1:\n        return self._concat_same_dtype(to_concat, name=name)\n    return Index._concat_same_dtype(self, to_concat, name=name)",
                            "def _concat_same_dtype(self, to_concat, name):\n    \"\"\"\n    Concatenate to_concat which has the same class.\n    \"\"\"\n    klasses = (ABCDatetimeIndex, ABCTimedeltaIndex, ABCPeriodIndex, ExtensionArray)\n    to_concat = [x.astype(object) if isinstance(x, klasses) else x for x in to_concat]\n    self = to_concat[0]\n    attribs = self._get_attributes_dict()\n    attribs['name'] = name\n    to_concat = [x._values if isinstance(x, Index) else x for x in to_concat]\n    return self._shallow_copy_with_infer(np.concatenate(to_concat), **attribs)",
                            "def putmask(self, mask, value):\n    \"\"\"\n    Return a new Index of the values set with the mask.\n\n    Returns\n    -------\n    Index\n\n    See Also\n    --------\n    numpy.ndarray.putmask\n    \"\"\"\n    values = self.values.copy()\n    try:\n        np.putmask(values, mask, self._convert_for_op(value))\n        return self._shallow_copy(values)\n    except (ValueError, TypeError) as err:\n        if is_object_dtype(self):\n            raise err\n        return self.astype(object).putmask(mask, value)",
                            "def equals(self, other):\n    \"\"\"\n    Determine if two Index objects contain the same elements.\n\n    Returns\n    -------\n    bool\n        True if \"other\" is an Index and it has the same elements as calling\n        index; False otherwise.\n    \"\"\"\n    if self.is_(other):\n        return True\n    if not isinstance(other, Index):\n        return False\n    if is_object_dtype(self) and (not is_object_dtype(other)):\n        return other.equals(self)\n    try:\n        return array_equivalent(com.values_from_object(self), com.values_from_object(other))\n    except Exception:\n        return False",
                            "def identical(self, other):\n    \"\"\"\n    Similar to equals, but check that other comparable attributes are\n    also equal.\n\n    Returns\n    -------\n    bool\n        If two Index objects have equal elements and same type True,\n        otherwise False.\n    \"\"\"\n    return self.equals(other) and all((getattr(self, c, None) == getattr(other, c, None) for c in self._comparables)) and (type(self) == type(other))",
                            "def asof(self, label):\n    \"\"\"\n    Return the label from the index, or, if not present, the previous one.\n\n    Assuming that the index is sorted, return the passed index label if it\n    is in the index, or return the previous index label if the passed one\n    is not in the index.\n\n    Parameters\n    ----------\n    label : object\n        The label up to which the method returns the latest index label.\n\n    Returns\n    -------\n    object\n        The passed label if it is in the index. The previous label if the\n        passed label is not in the sorted index or `NaN` if there is no\n        such label.\n\n    See Also\n    --------\n    Series.asof : Return the latest value in a Series up to the\n        passed index.\n    merge_asof : Perform an asof merge (similar to left join but it\n        matches on nearest key rather than equal key).\n    Index.get_loc : An `asof` is a thin wrapper around `get_loc`\n        with method='pad'.\n\n    Examples\n    --------\n    `Index.asof` returns the latest index label up to the passed label.\n\n    >>> idx = pd.Index(['2013-12-31', '2014-01-02', '2014-01-03'])\n    >>> idx.asof('2014-01-01')\n    '2013-12-31'\n\n    If the label is in the index, the method returns the passed label.\n\n    >>> idx.asof('2014-01-02')\n    '2014-01-02'\n\n    If all of the labels in the index are later than the passed label,\n    NaN is returned.\n\n    >>> idx.asof('1999-01-02')\n    nan\n\n    If the index is not sorted, an error is raised.\n\n    >>> idx_not_sorted = pd.Index(['2013-12-31', '2015-01-02',\n    ...                            '2014-01-03'])\n    >>> idx_not_sorted.asof('2013-12-31')\n    Traceback (most recent call last):\n    ValueError: index must be monotonic increasing or decreasing\n    \"\"\"\n    try:\n        loc = self.get_loc(label, method='pad')\n    except KeyError:\n        return self._na_value\n    else:\n        if isinstance(loc, slice):\n            loc = loc.indices(len(self))[-1]\n        return self[loc]",
                            "def asof_locs(self, where, mask):\n    \"\"\"\n    Find the locations (indices) of the labels from the index for\n    every entry in the `where` argument.\n\n    As in the `asof` function, if the label (a particular entry in\n    `where`) is not in the index, the latest index label upto the\n    passed label is chosen and its index returned.\n\n    If all of the labels in the index are later than a label in `where`,\n    -1 is returned.\n\n    `mask` is used to ignore NA values in the index during calculation.\n\n    Parameters\n    ----------\n    where : Index\n        An Index consisting of an array of timestamps.\n    mask : array-like\n        Array of booleans denoting where values in the original\n        data are not NA.\n\n    Returns\n    -------\n    numpy.ndarray\n        An array of locations (indices) of the labels from the Index\n        which correspond to the return values of the `asof` function\n        for every element in `where`.\n    \"\"\"\n    locs = self.values[mask].searchsorted(where.values, side='right')\n    locs = np.where(locs > 0, locs - 1, 0)\n    result = np.arange(len(self))[mask].take(locs)\n    first = mask.argmax()\n    result[(locs == 0) & (where.values < self.values[first])] = -1\n    return result",
                            "def sort_values(self, return_indexer=False, ascending=True):\n    \"\"\"\n    Return a sorted copy of the index.\n\n    Return a sorted copy of the index, and optionally return the indices\n    that sorted the index itself.\n\n    Parameters\n    ----------\n    return_indexer : bool, default False\n        Should the indices that would sort the index be returned.\n    ascending : bool, default True\n        Should the index values be sorted in an ascending order.\n\n    Returns\n    -------\n    sorted_index : pandas.Index\n        Sorted copy of the index.\n    indexer : numpy.ndarray, optional\n        The indices that the index itself was sorted by.\n\n    See Also\n    --------\n    Series.sort_values : Sort values of a Series.\n    DataFrame.sort_values : Sort values in a DataFrame.\n\n    Examples\n    --------\n    >>> idx = pd.Index([10, 100, 1, 1000])\n    >>> idx\n    Int64Index([10, 100, 1, 1000], dtype='int64')\n\n    Sort values in ascending order (default behavior).\n\n    >>> idx.sort_values()\n    Int64Index([1, 10, 100, 1000], dtype='int64')\n\n    Sort values in descending order, and also get the indices `idx` was\n    sorted by.\n\n    >>> idx.sort_values(ascending=False, return_indexer=True)\n    (Int64Index([1000, 100, 10, 1], dtype='int64'), array([3, 1, 0, 2]))\n    \"\"\"\n    _as = self.argsort()\n    if not ascending:\n        _as = _as[::-1]\n    sorted_index = self.take(_as)\n    if return_indexer:\n        return (sorted_index, _as)\n    else:\n        return sorted_index",
                            "def sort(self, *args, **kwargs):\n    \"\"\"\n    Use sort_values instead.\n    \"\"\"\n    raise TypeError('cannot sort an Index object in-place, use sort_values instead')",
                            "def shift(self, periods=1, freq=None):\n    \"\"\"\n    Shift index by desired number of time frequency increments.\n\n    This method is for shifting the values of datetime-like indexes\n    by a specified time increment a given number of times.\n\n    Parameters\n    ----------\n    periods : int, default 1\n        Number of periods (or increments) to shift by,\n        can be positive or negative.\n    freq : pandas.DateOffset, pandas.Timedelta or string, optional\n        Frequency increment to shift by.\n        If None, the index is shifted by its own `freq` attribute.\n        Offset aliases are valid strings, e.g., 'D', 'W', 'M' etc.\n\n    Returns\n    -------\n    pandas.Index\n        Shifted index.\n\n    See Also\n    --------\n    Series.shift : Shift values of Series.\n\n    Notes\n    -----\n    This method is only implemented for datetime-like index classes,\n    i.e., DatetimeIndex, PeriodIndex and TimedeltaIndex.\n\n    Examples\n    --------\n    Put the first 5 month starts of 2011 into an index.\n\n    >>> month_starts = pd.date_range('1/1/2011', periods=5, freq='MS')\n    >>> month_starts\n    DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01', '2011-04-01',\n                   '2011-05-01'],\n                  dtype='datetime64[ns]', freq='MS')\n\n    Shift the index by 10 days.\n\n    >>> month_starts.shift(10, freq='D')\n    DatetimeIndex(['2011-01-11', '2011-02-11', '2011-03-11', '2011-04-11',\n                   '2011-05-11'],\n                  dtype='datetime64[ns]', freq=None)\n\n    The default value of `freq` is the `freq` attribute of the index,\n    which is 'MS' (month start) in this example.\n\n    >>> month_starts.shift(10)\n    DatetimeIndex(['2011-11-01', '2011-12-01', '2012-01-01', '2012-02-01',\n                   '2012-03-01'],\n                  dtype='datetime64[ns]', freq='MS')\n    \"\"\"\n    raise NotImplementedError('Not supported for type %s' % type(self).__name__)",
                            "def argsort(self, *args, **kwargs):\n    \"\"\"\n    Return the integer indices that would sort the index.\n\n    Parameters\n    ----------\n    *args\n        Passed to `numpy.ndarray.argsort`.\n    **kwargs\n        Passed to `numpy.ndarray.argsort`.\n\n    Returns\n    -------\n    numpy.ndarray\n        Integer indices that would sort the index if used as\n        an indexer.\n\n    See Also\n    --------\n    numpy.argsort : Similar method for NumPy arrays.\n    Index.sort_values : Return sorted copy of Index.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['b', 'a', 'd', 'c'])\n    >>> idx\n    Index(['b', 'a', 'd', 'c'], dtype='object')\n\n    >>> order = idx.argsort()\n    >>> order\n    array([1, 0, 3, 2])\n\n    >>> idx[order]\n    Index(['a', 'b', 'c', 'd'], dtype='object')\n    \"\"\"\n    result = self.asi8\n    if result is None:\n        result = np.array(self)\n    return result.argsort(*args, **kwargs)",
                            "@Appender(_index_shared_docs['get_value'] % _index_doc_kwargs)\ndef get_value(self, series, key):\n    s = getattr(series, '_values', series)\n    if isinstance(s, (ExtensionArray, Index)) and is_scalar(key):\n        try:\n            iloc = self.get_loc(key)\n            return s[iloc]\n        except KeyError:\n            if len(self) > 0 and (self.holds_integer() or self.is_boolean()):\n                raise\n            elif is_integer(key):\n                return s[key]\n    s = com.values_from_object(series)\n    k = com.values_from_object(key)\n    k = self._convert_scalar_indexer(k, kind='getitem')\n    try:\n        return self._engine.get_value(s, k, tz=getattr(series.dtype, 'tz', None))\n    except KeyError as e1:\n        if len(self) > 0 and (self.holds_integer() or self.is_boolean()):\n            raise\n        try:\n            return libindex.get_value_at(s, key)\n        except IndexError:\n            raise\n        except TypeError:\n            if is_iterator(key):\n                raise InvalidIndexError(key)\n            else:\n                raise e1\n        except Exception:\n            raise e1\n    except TypeError:\n        if is_scalar(key):\n            raise IndexError(key)\n        raise InvalidIndexError(key)",
                            "def set_value(self, arr, key, value):\n    \"\"\"\n    Fast lookup of value from 1-dimensional ndarray.\n\n    Notes\n    -----\n    Only use this if you know what you're doing.\n    \"\"\"\n    self._engine.set_value(com.values_from_object(arr), com.values_from_object(key), value)",
                            "@Appender(_index_shared_docs['get_indexer_non_unique'] % _index_doc_kwargs)\ndef get_indexer_non_unique(self, target):\n    target = ensure_index(target)\n    pself, ptarget = self._maybe_promote(target)\n    if pself is not self or ptarget is not target:\n        return pself.get_indexer_non_unique(ptarget)\n    if is_categorical(target):\n        tgt_values = np.asarray(target)\n    elif self.is_all_dates:\n        tgt_values = target.asi8\n    else:\n        tgt_values = target._ndarray_values\n    indexer, missing = self._engine.get_indexer_non_unique(tgt_values)\n    return (ensure_platform_int(indexer), missing)",
                            "def get_indexer_for(self, target, **kwargs):\n    \"\"\"\n    Guaranteed return of an indexer even when non-unique.\n\n    This dispatches to get_indexer or get_indexer_non_unique\n    as appropriate.\n\n    Returns\n    -------\n    numpy.ndarray\n        List of indices.\n    \"\"\"\n    if self.is_unique:\n        return self.get_indexer(target, **kwargs)\n    indexer, _ = self.get_indexer_non_unique(target, **kwargs)\n    return indexer",
                            "def _maybe_promote(self, other):\n    from pandas import DatetimeIndex\n    if self.inferred_type == 'date' and isinstance(other, DatetimeIndex):\n        return (DatetimeIndex(self), other)\n    elif self.inferred_type == 'boolean':\n        if not is_object_dtype(self.dtype):\n            return (self.astype('object'), other.astype('object'))\n    return (self, other)",
                            "def groupby(self, values):\n    \"\"\"\n    Group the index labels by a given array of values.\n\n    Parameters\n    ----------\n    values : array\n        Values used to determine the groups.\n\n    Returns\n    -------\n    groups : dict\n        {group name -> group labels}\n    \"\"\"\n    if isinstance(values, ABCMultiIndex):\n        values = values.values\n    values = ensure_categorical(values)\n    result = values._reverse_indexer()\n    result = {k: self.take(v) for k, v in result.items()}\n    return result",
                            "def map(self, mapper, na_action=None):\n    \"\"\"\n    Map values using input correspondence (a dict, Series, or function).\n\n    Parameters\n    ----------\n    mapper : function, dict, or Series\n        Mapping correspondence.\n    na_action : {None, 'ignore'}\n        If 'ignore', propagate NA values, without passing them to the\n        mapping correspondence.\n\n    Returns\n    -------\n    applied : Union[Index, MultiIndex], inferred\n        The output of the mapping function applied to the index.\n        If the function returns a tuple with more than one element\n        a MultiIndex will be returned.\n    \"\"\"\n    from .multi import MultiIndex\n    new_values = super()._map_values(mapper, na_action=na_action)\n    attributes = self._get_attributes_dict()\n    if new_values.size and isinstance(new_values[0], tuple):\n        if isinstance(self, MultiIndex):\n            names = self.names\n        elif attributes.get('name'):\n            names = [attributes.get('name')] * len(new_values[0])\n        else:\n            names = None\n        return MultiIndex.from_tuples(new_values, names=names)\n    attributes['copy'] = False\n    if not new_values.size:\n        attributes['dtype'] = self.dtype\n    return Index(new_values, **attributes)",
                            "def isin(self, values, level=None):\n    \"\"\"\n    Return a boolean array where the index values are in `values`.\n\n    Compute boolean array of whether each index value is found in the\n    passed set of values. The length of the returned boolean array matches\n    the length of the index.\n\n    Parameters\n    ----------\n    values : set or list-like\n        Sought values.\n    level : str or int, optional\n        Name or position of the index level to use (if the index is a\n        `MultiIndex`).\n\n    Returns\n    -------\n    is_contained : ndarray\n        NumPy array of boolean values.\n\n    See Also\n    --------\n    Series.isin : Same for Series.\n    DataFrame.isin : Same method for DataFrames.\n\n    Notes\n    -----\n    In the case of `MultiIndex` you must either specify `values` as a\n    list-like object containing tuples that are the same length as the\n    number of levels, or specify `level`. Otherwise it will raise a\n    ``ValueError``.\n\n    If `level` is specified:\n\n    - if it is the name of one *and only one* index level, use that level;\n    - otherwise it should be a number indicating level position.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1,2,3])\n    >>> idx\n    Int64Index([1, 2, 3], dtype='int64')\n\n    Check whether each index value in a list of values.\n    >>> idx.isin([1, 4])\n    array([ True, False, False])\n\n    >>> midx = pd.MultiIndex.from_arrays([[1,2,3],\n    ...                                  ['red', 'blue', 'green']],\n    ...                                  names=('number', 'color'))\n    >>> midx\n    MultiIndex(levels=[[1, 2, 3], ['blue', 'green', 'red']],\n               codes=[[0, 1, 2], [2, 0, 1]],\n               names=['number', 'color'])\n\n    Check whether the strings in the 'color' level of the MultiIndex\n    are in a list of colors.\n\n    >>> midx.isin(['red', 'orange', 'yellow'], level='color')\n    array([ True, False, False])\n\n    To check across the levels of a MultiIndex, pass a list of tuples:\n\n    >>> midx.isin([(1, 'red'), (3, 'red')])\n    array([ True, False, False])\n\n    For a DatetimeIndex, string values in `values` are converted to\n    Timestamps.\n\n    >>> dates = ['2000-03-11', '2000-03-12', '2000-03-13']\n    >>> dti = pd.to_datetime(dates)\n    >>> dti\n    DatetimeIndex(['2000-03-11', '2000-03-12', '2000-03-13'],\n    dtype='datetime64[ns]', freq=None)\n\n    >>> dti.isin(['2000-03-11'])\n    array([ True, False, False])\n    \"\"\"\n    if level is not None:\n        self._validate_index_level(level)\n    return algos.isin(self, values)",
                            "def _get_string_slice(self, key, use_lhs=True, use_rhs=True):\n    raise NotImplementedError",
                            "def slice_indexer(self, start=None, end=None, step=None, kind=None):\n    \"\"\"\n    For an ordered or unique index, compute the slice indexer for input\n    labels and step.\n\n    Parameters\n    ----------\n    start : label, default None\n        If None, defaults to the beginning\n    end : label, default None\n        If None, defaults to the end\n    step : int, default None\n    kind : string, default None\n\n    Returns\n    -------\n    indexer : slice\n\n    Raises\n    ------\n    KeyError : If key does not exist, or key is not unique and index is\n        not ordered.\n\n    Notes\n    -----\n    This function assumes that the data is sorted, so use at your own peril\n\n    Examples\n    --------\n    This is a method on all index types. For example you can do:\n\n    >>> idx = pd.Index(list('abcd'))\n    >>> idx.slice_indexer(start='b', end='c')\n    slice(1, 3)\n\n    >>> idx = pd.MultiIndex.from_arrays([list('abcd'), list('efgh')])\n    >>> idx.slice_indexer(start='b', end=('c', 'g'))\n    slice(1, 3)\n    \"\"\"\n    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)\n    if not is_scalar(start_slice):\n        raise AssertionError('Start slice bound is non-scalar')\n    if not is_scalar(end_slice):\n        raise AssertionError('End slice bound is non-scalar')\n    return slice(start_slice, end_slice, step)",
                            "def _maybe_cast_indexer(self, key):\n    \"\"\"\n    If we have a float key and are not a floating index, then try to cast\n    to an int if equivalent.\n    \"\"\"\n    if is_float(key) and (not self.is_floating()):\n        try:\n            ckey = int(key)\n            if ckey == key:\n                key = ckey\n        except (OverflowError, ValueError, TypeError):\n            pass\n    return key",
                            "def _validate_indexer(self, form, key, kind):\n    \"\"\"\n    If we are positional indexer, validate that we have appropriate\n    typed bounds must be an integer.\n    \"\"\"\n    assert kind in ['ix', 'loc', 'getitem', 'iloc']\n    if key is None:\n        pass\n    elif is_integer(key):\n        pass\n    elif kind in ['iloc', 'getitem']:\n        self._invalid_indexer(form, key)\n    return key",
                            "@Appender(_index_shared_docs['_maybe_cast_slice_bound'])\ndef _maybe_cast_slice_bound(self, label, side, kind):\n    assert kind in ['ix', 'loc', 'getitem', None]\n    if is_float(label):\n        if not (kind in ['ix'] and (self.holds_integer() or self.is_floating())):\n            self._invalid_indexer('slice', label)\n    elif is_integer(label):\n        self._invalid_indexer('slice', label)\n    return label",
                            "def _searchsorted_monotonic(self, label, side='left'):\n    if self.is_monotonic_increasing:\n        return self.searchsorted(label, side=side)\n    elif self.is_monotonic_decreasing:\n        pos = self[::-1].searchsorted(label, side='right' if side == 'left' else 'left')\n        return len(self) - pos\n    raise ValueError('index must be monotonic increasing or decreasing')",
                            "def get_slice_bound(self, label, side, kind):\n    \"\"\"\n    Calculate slice bound that corresponds to given label.\n\n    Returns leftmost (one-past-the-rightmost if ``side=='right'``) position\n    of given label.\n\n    Parameters\n    ----------\n    label : object\n    side : {'left', 'right'}\n    kind : {'ix', 'loc', 'getitem'}\n\n    Returns\n    -------\n    int\n        Index of label.\n    \"\"\"\n    assert kind in ['ix', 'loc', 'getitem', None]\n    if side not in ('left', 'right'):\n        raise ValueError(\"Invalid value for side kwarg, must be either 'left' or 'right': %s\" % (side,))\n    original_label = label\n    label = self._maybe_cast_slice_bound(label, side, kind)\n    try:\n        slc = self.get_loc(label)\n    except KeyError as err:\n        try:\n            return self._searchsorted_monotonic(label, side)\n        except ValueError:\n            raise err\n    if isinstance(slc, np.ndarray):\n        if is_bool_dtype(slc):\n            slc = lib.maybe_booleans_to_slice(slc.view('u1'))\n        else:\n            slc = lib.maybe_indices_to_slice(slc.astype('i8'), len(self))\n        if isinstance(slc, np.ndarray):\n            raise KeyError('Cannot get %s slice bound for non-unique label: %r' % (side, original_label))\n    if isinstance(slc, slice):\n        if side == 'left':\n            return slc.start\n        else:\n            return slc.stop\n    elif side == 'right':\n        return slc + 1\n    else:\n        return slc",
                            "def slice_locs(self, start=None, end=None, step=None, kind=None):\n    \"\"\"\n    Compute slice locations for input labels.\n\n    Parameters\n    ----------\n    start : label, default None\n        If None, defaults to the beginning\n    end : label, default None\n        If None, defaults to the end\n    step : int, defaults None\n        If None, defaults to 1\n    kind : {'ix', 'loc', 'getitem'} or None\n\n    Returns\n    -------\n    start, end : int\n\n    See Also\n    --------\n    Index.get_loc : Get location for a single label.\n\n    Notes\n    -----\n    This method only works if the index is monotonic or unique.\n\n    Examples\n    --------\n    >>> idx = pd.Index(list('abcd'))\n    >>> idx.slice_locs(start='b', end='c')\n    (1, 3)\n    \"\"\"\n    inc = step is None or step >= 0\n    if not inc:\n        start, end = (end, start)\n    if isinstance(start, (str, datetime)) and isinstance(end, (str, datetime)):\n        try:\n            ts_start = Timestamp(start)\n            ts_end = Timestamp(end)\n        except (ValueError, TypeError):\n            pass\n        else:\n            if not tz_compare(ts_start.tzinfo, ts_end.tzinfo):\n                raise ValueError('Both dates must have the same UTC offset')\n    start_slice = None\n    if start is not None:\n        start_slice = self.get_slice_bound(start, 'left', kind)\n    if start_slice is None:\n        start_slice = 0\n    end_slice = None\n    if end is not None:\n        end_slice = self.get_slice_bound(end, 'right', kind)\n    if end_slice is None:\n        end_slice = len(self)\n    if not inc:\n        end_slice, start_slice = (start_slice - 1, end_slice - 1)\n        if end_slice == -1:\n            end_slice -= len(self)\n        if start_slice == -1:\n            start_slice -= len(self)\n    return (start_slice, end_slice)",
                            "def delete(self, loc):\n    \"\"\"\n    Make new Index with passed location(-s) deleted.\n\n    Returns\n    -------\n    new_index : Index\n    \"\"\"\n    return self._shallow_copy(np.delete(self._data, loc))",
                            "def insert(self, loc, item):\n    \"\"\"\n    Make new Index inserting new item at location.\n\n    Follows Python list.append semantics for negative values.\n\n    Parameters\n    ----------\n    loc : int\n    item : object\n\n    Returns\n    -------\n    new_index : Index\n    \"\"\"\n    _self = np.asarray(self)\n    item = self._coerce_scalar_to_index(item)._ndarray_values\n    idx = np.concatenate((_self[:loc], item, _self[loc:]))\n    return self._shallow_copy_with_infer(idx)",
                            "def drop(self, labels, errors='raise'):\n    \"\"\"\n    Make new Index with passed list of labels deleted.\n\n    Parameters\n    ----------\n    labels : array-like\n    errors : {'ignore', 'raise'}, default 'raise'\n        If 'ignore', suppress error and existing labels are dropped.\n\n    Returns\n    -------\n    dropped : Index\n\n    Raises\n    ------\n    KeyError\n        If not all of the labels are found in the selected axis\n    \"\"\"\n    arr_dtype = 'object' if self.dtype == 'object' else None\n    labels = com.index_labels_to_array(labels, dtype=arr_dtype)\n    indexer = self.get_indexer(labels)\n    mask = indexer == -1\n    if mask.any():\n        if errors != 'ignore':\n            raise KeyError('{} not found in axis'.format(labels[mask]))\n        indexer = indexer[~mask]\n    return self.delete(indexer)",
                            "@classmethod\ndef _add_comparison_methods(cls):\n    \"\"\"\n    Add in comparison methods.\n    \"\"\"\n    cls.__eq__ = _make_comparison_op(operator.eq, cls)\n    cls.__ne__ = _make_comparison_op(operator.ne, cls)\n    cls.__lt__ = _make_comparison_op(operator.lt, cls)\n    cls.__gt__ = _make_comparison_op(operator.gt, cls)\n    cls.__le__ = _make_comparison_op(operator.le, cls)\n    cls.__ge__ = _make_comparison_op(operator.ge, cls)",
                            "@classmethod\ndef _add_numeric_methods_add_sub_disabled(cls):\n    \"\"\"\n    Add in the numeric add/sub methods to disable.\n    \"\"\"\n    cls.__add__ = make_invalid_op('__add__')\n    cls.__radd__ = make_invalid_op('__radd__')\n    cls.__iadd__ = make_invalid_op('__iadd__')\n    cls.__sub__ = make_invalid_op('__sub__')\n    cls.__rsub__ = make_invalid_op('__rsub__')\n    cls.__isub__ = make_invalid_op('__isub__')",
                            "@classmethod\ndef _add_numeric_methods_disabled(cls):\n    \"\"\"\n    Add in numeric methods to disable other than add/sub.\n    \"\"\"\n    cls.__pow__ = make_invalid_op('__pow__')\n    cls.__rpow__ = make_invalid_op('__rpow__')\n    cls.__mul__ = make_invalid_op('__mul__')\n    cls.__rmul__ = make_invalid_op('__rmul__')\n    cls.__floordiv__ = make_invalid_op('__floordiv__')\n    cls.__rfloordiv__ = make_invalid_op('__rfloordiv__')\n    cls.__truediv__ = make_invalid_op('__truediv__')\n    cls.__rtruediv__ = make_invalid_op('__rtruediv__')\n    cls.__mod__ = make_invalid_op('__mod__')\n    cls.__divmod__ = make_invalid_op('__divmod__')\n    cls.__neg__ = make_invalid_op('__neg__')\n    cls.__pos__ = make_invalid_op('__pos__')\n    cls.__abs__ = make_invalid_op('__abs__')\n    cls.__inv__ = make_invalid_op('__inv__')",
                            "@classmethod\ndef _add_numeric_methods_binary(cls):\n    \"\"\"\n    Add in numeric methods.\n    \"\"\"\n    cls.__add__ = _make_arithmetic_op(operator.add, cls)\n    cls.__radd__ = _make_arithmetic_op(ops.radd, cls)\n    cls.__sub__ = _make_arithmetic_op(operator.sub, cls)\n    cls.__rsub__ = _make_arithmetic_op(ops.rsub, cls)\n    cls.__rpow__ = _make_arithmetic_op(ops.rpow, cls)\n    cls.__pow__ = _make_arithmetic_op(operator.pow, cls)\n    cls.__truediv__ = _make_arithmetic_op(operator.truediv, cls)\n    cls.__rtruediv__ = _make_arithmetic_op(ops.rtruediv, cls)\n    cls.__mod__ = _make_arithmetic_op(operator.mod, cls)\n    cls.__floordiv__ = _make_arithmetic_op(operator.floordiv, cls)\n    cls.__rfloordiv__ = _make_arithmetic_op(ops.rfloordiv, cls)\n    cls.__divmod__ = _make_arithmetic_op(divmod, cls)\n    cls.__mul__ = _make_arithmetic_op(operator.mul, cls)\n    cls.__rmul__ = _make_arithmetic_op(ops.rmul, cls)",
                            "@classmethod\ndef _add_numeric_methods_unary(cls):\n    \"\"\"\n    Add in numeric unary methods.\n    \"\"\"\n\n    def _make_evaluate_unary(op, opstr):\n\n        def _evaluate_numeric_unary(self):\n            attrs = self._get_attributes_dict()\n            return Index(op(self.values), **attrs)\n        _evaluate_numeric_unary.__name__ = opstr\n        return _evaluate_numeric_unary\n    cls.__neg__ = _make_evaluate_unary(operator.neg, '__neg__')\n    cls.__pos__ = _make_evaluate_unary(operator.pos, '__pos__')\n    cls.__abs__ = _make_evaluate_unary(np.abs, '__abs__')\n    cls.__inv__ = _make_evaluate_unary(lambda x: -x, '__inv__')",
                            "@classmethod\ndef _add_numeric_methods(cls):\n    cls._add_numeric_methods_unary()\n    cls._add_numeric_methods_binary()",
                            "@classmethod\ndef _add_logical_methods(cls):\n    \"\"\"\n    Add in logical methods.\n    \"\"\"\n    _doc = '\\n        %(desc)s\\n\\n        Parameters\\n        ----------\\n        *args\\n            These parameters will be passed to numpy.%(outname)s.\\n        **kwargs\\n            These parameters will be passed to numpy.%(outname)s.\\n\\n        Returns\\n        -------\\n        %(outname)s : bool or array_like (if axis is specified)\\n            A single element array_like may be converted to bool.'\n    _index_shared_docs['index_all'] = dedent('\\n\\n        See Also\\n        --------\\n        Index.any : Return whether any element in an Index is True.\\n        Series.any : Return whether any element in a Series is True.\\n        Series.all : Return whether all elements in a Series are True.\\n\\n        Notes\\n        -----\\n        Not a Number (NaN), positive infinity and negative infinity\\n        evaluate to True because these are not equal to zero.\\n\\n        Examples\\n        --------\\n        **all**\\n\\n        True, because nonzero integers are considered True.\\n\\n        >>> pd.Index([1, 2, 3]).all()\\n        True\\n\\n        False, because ``0`` is considered False.\\n\\n        >>> pd.Index([0, 1, 2]).all()\\n        False\\n\\n        **any**\\n\\n        True, because ``1`` is considered True.\\n\\n        >>> pd.Index([0, 0, 1]).any()\\n        True\\n\\n        False, because ``0`` is considered False.\\n\\n        >>> pd.Index([0, 0, 0]).any()\\n        False\\n        ')\n    _index_shared_docs['index_any'] = dedent('\\n\\n        See Also\\n        --------\\n        Index.all : Return whether all elements are True.\\n        Series.all : Return whether all elements are True.\\n\\n        Notes\\n        -----\\n        Not a Number (NaN), positive infinity and negative infinity\\n        evaluate to True because these are not equal to zero.\\n\\n        Examples\\n        --------\\n        >>> index = pd.Index([0, 1, 2])\\n        >>> index.any()\\n        True\\n\\n        >>> index = pd.Index([0, 0, 0])\\n        >>> index.any()\\n        False\\n        ')\n\n    def _make_logical_function(name, desc, f):\n\n        @Substitution(outname=name, desc=desc)\n        @Appender(_index_shared_docs['index_' + name])\n        @Appender(_doc)\n        def logical_func(self, *args, **kwargs):\n            result = f(self.values)\n            if isinstance(result, (np.ndarray, ABCSeries, Index)) and result.ndim == 0:\n                return result.dtype.type(result.item())\n            else:\n                return result\n        logical_func.__name__ = name\n        return logical_func\n    cls.all = _make_logical_function('all', 'Return whether all elements are True.', np.all)\n    cls.any = _make_logical_function('any', 'Return whether any element is True.', np.any)",
                            "@classmethod\ndef _add_logical_methods_disabled(cls):\n    \"\"\"\n    Add in logical methods to disable.\n    \"\"\"\n    cls.all = make_invalid_op('all')\n    cls.any = make_invalid_op('any')",
                            "@property\ndef shape(self):\n    \"\"\"\n    Return a tuple of the shape of the underlying data.\n    \"\"\"\n    return self._values.shape",
                            "def is_int(v):\n    return v is None or is_integer(v)",
                            "def _get_leaf_sorter(labels):\n    \"\"\"\n    Returns sorter for the inner most level while preserving the\n    order of higher levels.\n    \"\"\"\n    if labels[0].size == 0:\n        return np.empty(0, dtype='int64')\n    if len(labels) == 1:\n        lab = ensure_int64(labels[0])\n        sorter, _ = libalgos.groupsort_indexer(lab, 1 + lab.max())\n        return sorter\n    tic = labels[0][:-1] != labels[0][1:]\n    for lab in labels[1:-1]:\n        tic |= lab[:-1] != lab[1:]\n    starts = np.hstack(([True], tic, [True])).nonzero()[0]\n    lab = ensure_int64(labels[-1])\n    return lib.get_level_sorter(lab, ensure_int64(starts))",
                            "def _make_evaluate_unary(op, opstr):\n\n    def _evaluate_numeric_unary(self):\n        attrs = self._get_attributes_dict()\n        return Index(op(self.values), **attrs)\n    _evaluate_numeric_unary.__name__ = opstr\n    return _evaluate_numeric_unary",
                            "def _make_logical_function(name, desc, f):\n\n    @Substitution(outname=name, desc=desc)\n    @Appender(_index_shared_docs['index_' + name])\n    @Appender(_doc)\n    def logical_func(self, *args, **kwargs):\n        result = f(self.values)\n        if isinstance(result, (np.ndarray, ABCSeries, Index)) and result.ndim == 0:\n            return result.dtype.type(result.item())\n        else:\n            return result\n    logical_func.__name__ = name\n    return logical_func",
                            "def _evaluate_numeric_unary(self):\n    attrs = self._get_attributes_dict()\n    return Index(op(self.values), **attrs)",
                            "@Substitution(outname=name, desc=desc)\n@Appender(_index_shared_docs['index_' + name])\n@Appender(_doc)\ndef logical_func(self, *args, **kwargs):\n    result = f(self.values)\n    if isinstance(result, (np.ndarray, ABCSeries, Index)) and result.ndim == 0:\n        return result.dtype.type(result.item())\n    else:\n        return result"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_deprecations",
                            "_join_precedence",
                            "_typ",
                            "_data",
                            "_id",
                            "name",
                            "_comparables",
                            "_attributes",
                            "_is_numeric_dtype",
                            "_can_hold_na",
                            "_defer_to_indexing",
                            "_infer_as_myclass",
                            "_engine_type",
                            "_supports_partial_string_indexing",
                            "_accessors",
                            "str",
                            "names",
                            "get_level_values",
                            "_unpickle_compat",
                            "_na_value",
                            "isnull",
                            "notnull",
                            "__bool__"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_left_indexer_unique(self, left, right)",
                            "_left_indexer(self, left, right)",
                            "_inner_indexer(self, left, right)",
                            "_outer_indexer(self, left, right)",
                            "__new__(cls, data=None, dtype=None, copy=False, name=None, fastpath=None, tupleize_cols=True, **kwargs) -> 'Index'",
                            "asi8(self)",
                            "_simple_new(cls, values, name=None, dtype=None, **kwargs)",
                            "_constructor(self)",
                            "_get_attributes_dict(self)",
                            "_shallow_copy(self, values=None, **kwargs)",
                            "_shallow_copy_with_infer(self, values, **kwargs)",
                            "_update_inplace(self, result, **kwargs)",
                            "is_(self, other)",
                            "_reset_identity(self)",
                            "_cleanup(self)",
                            "_engine(self)",
                            "__len__(self)",
                            "__array__(self, dtype=None)",
                            "__array_wrap__(self, result, context=None)",
                            "dtype(self)",
                            "dtype_str(self)",
                            "ravel(self, order='C')",
                            "view(self, cls=None)",
                            "astype(self, dtype, copy=True)",
                            "take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs)",
                            "_assert_take_fillable(self, values, indices, allow_fill=True, fill_value=None, na_value=np.nan)",
                            "repeat(self, repeats, axis=None)",
                            "copy(self, name=None, deep=False, dtype=None, **kwargs)",
                            "__copy__(self, **kwargs)",
                            "__deepcopy__(self, memo=None)",
                            "__repr__(self)",
                            "_format_space(self)",
                            "_formatter_func(self)",
                            "_format_data(self, name=None)",
                            "_format_attrs(self)",
                            "_mpl_repr(self)",
                            "format(self, name=False, formatter=None, **kwargs)",
                            "_format_with_header(self, header, na_rep='NaN', **kwargs)",
                            "to_native_types(self, slicer=None, **kwargs)",
                            "_format_native_types(self, na_rep='', quoting=None, **kwargs)",
                            "_summary(self, name=None)",
                            "summary(self, name=None)",
                            "to_flat_index(self)",
                            "to_series(self, index=None, name=None)",
                            "to_frame(self, index=True, name=None)",
                            "_validate_names(self, name=None, names=None, deep=False)",
                            "_get_names(self)",
                            "_set_names(self, values, level=None)",
                            "set_names(self, names, level=None, inplace=False)",
                            "rename(self, name, inplace=False)",
                            "nlevels(self)",
                            "_sort_levels_monotonic(self)",
                            "_validate_index_level(self, level)",
                            "_get_level_number(self, level)",
                            "sortlevel(self, level=None, ascending=True, sort_remaining=None)",
                            "_get_level_values(self, level)",
                            "droplevel(self, level=0)",
                            "_get_grouper_for_level(self, mapper, level=None)",
                            "is_monotonic(self)",
                            "is_monotonic_increasing(self)",
                            "is_monotonic_decreasing(self)",
                            "_is_strictly_monotonic_increasing(self)",
                            "_is_strictly_monotonic_decreasing(self)",
                            "is_lexsorted_for_tuple(self, tup)",
                            "is_unique(self)",
                            "has_duplicates(self)",
                            "is_boolean(self)",
                            "is_integer(self)",
                            "is_floating(self)",
                            "is_numeric(self)",
                            "is_object(self)",
                            "is_categorical(self)",
                            "is_interval(self)",
                            "is_mixed(self)",
                            "holds_integer(self)",
                            "inferred_type(self)",
                            "is_all_dates(self)",
                            "__reduce__(self)",
                            "__setstate__(self, state)",
                            "_isnan(self)",
                            "_nan_idxs(self)",
                            "hasnans(self)",
                            "isna(self)",
                            "notna(self)",
                            "fillna(self, value=None, downcast=None)",
                            "dropna(self, how='any')",
                            "unique(self, level=None)",
                            "drop_duplicates(self, keep='first')",
                            "duplicated(self, keep='first')",
                            "get_duplicates(self)",
                            "_get_unique_index(self, dropna=False)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__iadd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__and__(self, other)",
                            "__or__(self, other)",
                            "__xor__(self, other)",
                            "__nonzero__(self)",
                            "_get_reconciled_name_object(self, other)",
                            "_union_incompatible_dtypes(self, other, sort)",
                            "_is_compatible_with_other(self, other)",
                            "_validate_sort_keyword(self, sort)",
                            "union(self, other, sort=None)",
                            "_union(self, other, sort)",
                            "_wrap_setop_result(self, other, result)",
                            "intersection(self, other, sort=False)",
                            "difference(self, other, sort=None)",
                            "symmetric_difference(self, other, result_name=None, sort=None)",
                            "_assert_can_do_setop(self, other)",
                            "_convert_can_do_setop(self, other)",
                            "get_loc(self, key, method=None, tolerance=None)",
                            "get_indexer(self, target, method=None, limit=None, tolerance=None)",
                            "_convert_tolerance(self, tolerance, target)",
                            "_get_fill_indexer(self, target, method, limit=None, tolerance=None)",
                            "_get_fill_indexer_searchsorted(self, target, method, limit=None)",
                            "_get_nearest_indexer(self, target, limit, tolerance)",
                            "_filter_indexer_tolerance(self, target, indexer, tolerance)",
                            "_convert_scalar_indexer(self, key, kind=None)",
                            "_convert_slice_indexer(self, key: slice, kind=None)",
                            "_convert_listlike_indexer(self, keyarr, kind=None)",
                            "_convert_arr_indexer(self, keyarr)",
                            "_convert_index_indexer(self, keyarr)",
                            "_convert_list_indexer(self, keyarr, kind=None)",
                            "_invalid_indexer(self, form, key)",
                            "_can_reindex(self, indexer)",
                            "reindex(self, target, method=None, level=None, limit=None, tolerance=None)",
                            "_reindex_non_unique(self, target)",
                            "join(self, other, how='left', level=None, return_indexers=False, sort=False)",
                            "_join_multi(self, other, how, return_indexers=True)",
                            "_join_non_unique(self, other, how='left', return_indexers=False)",
                            "_join_level(self, other, level, how='left', return_indexers=False, keep_order=True)",
                            "_join_monotonic(self, other, how='left', return_indexers=False)",
                            "_wrap_joined_index(self, joined, other)",
                            "values(self)",
                            "_values(self) -> Union[ExtensionArray, ABCIndexClass, np.ndarray]",
                            "get_values(self)",
                            "_internal_get_values(self)",
                            "memory_usage(self, deep=False)",
                            "where(self, cond, other=None)",
                            "_try_convert_to_int_index(cls, data, copy, name, dtype)",
                            "_scalar_data_error(cls, data)",
                            "_string_data_error(cls, data)",
                            "_coerce_to_ndarray(cls, data)",
                            "_coerce_scalar_to_index(self, item)",
                            "_to_safe_for_reshape(self)",
                            "_convert_for_op(self, value)",
                            "_assert_can_do_op(self, value)",
                            "_has_complex_internals(self)",
                            "_is_memory_usage_qualified(self)",
                            "is_type_compatible(self, kind)",
                            "__contains__(self, key)",
                            "contains(self, key)",
                            "__hash__(self)",
                            "__setitem__(self, key, value)",
                            "__getitem__(self, key)",
                            "_can_hold_identifiers_and_holds_name(self, name)",
                            "append(self, other)",
                            "_concat(self, to_concat, name)",
                            "_concat_same_dtype(self, to_concat, name)",
                            "putmask(self, mask, value)",
                            "equals(self, other)",
                            "identical(self, other)",
                            "asof(self, label)",
                            "asof_locs(self, where, mask)",
                            "sort_values(self, return_indexer=False, ascending=True)",
                            "sort(self, *args, **kwargs)",
                            "shift(self, periods=1, freq=None)",
                            "argsort(self, *args, **kwargs)",
                            "get_value(self, series, key)",
                            "set_value(self, arr, key, value)",
                            "get_indexer_non_unique(self, target)",
                            "get_indexer_for(self, target, **kwargs)",
                            "_maybe_promote(self, other)",
                            "groupby(self, values)",
                            "map(self, mapper, na_action=None)",
                            "isin(self, values, level=None)",
                            "_get_string_slice(self, key, use_lhs=True, use_rhs=True)",
                            "slice_indexer(self, start=None, end=None, step=None, kind=None)",
                            "_maybe_cast_indexer(self, key)",
                            "_validate_indexer(self, form, key, kind)",
                            "_maybe_cast_slice_bound(self, label, side, kind)",
                            "_searchsorted_monotonic(self, label, side='left')",
                            "get_slice_bound(self, label, side, kind)",
                            "slice_locs(self, start=None, end=None, step=None, kind=None)",
                            "delete(self, loc)",
                            "insert(self, loc, item)",
                            "drop(self, labels, errors='raise')",
                            "_add_comparison_methods(cls)",
                            "_add_numeric_methods_add_sub_disabled(cls)",
                            "_add_numeric_methods_disabled(cls)",
                            "_add_numeric_methods_binary(cls)",
                            "_add_numeric_methods_unary(cls)",
                            "_add_numeric_methods(cls)",
                            "_add_logical_methods(cls)",
                            "_add_logical_methods_disabled(cls)",
                            "shape(self)",
                            "is_int(v)",
                            "_get_leaf_sorter(labels)",
                            "_make_evaluate_unary(op, opstr)",
                            "_make_logical_function(name, desc, f)",
                            "_evaluate_numeric_unary(self)",
                            "logical_func(self, *args, **kwargs)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def _make_comparison_op(op, cls):\n    def cmp_method(self, other):\n        if isinstance(other, (np.ndarray, Index, ABCSeries, ExtensionArray)):\n            if other.ndim > 0 and len(self) != len(other):\n                raise ValueError(\"Lengths must match to compare\")\n\n        if is_object_dtype(self) and isinstance(other, ABCCategorical):\n            left = type(other)(self._values, dtype=other.dtype)\n            return op(left, other)\n        elif is_object_dtype(self) and not isinstance(self, ABCMultiIndex):\n            # don't pass MultiIndex\n            with np.errstate(all=\"ignore\"):\n                result = ops.comp_method_OBJECT_ARRAY(op, self.values, other)\n\n        else:\n            with np.errstate(all=\"ignore\"):\n                result = op(self.values, np.asarray(other))\n\n        if is_bool_dtype(result):\n            return result\n        return ops.invalid_comparison(self, other, op)\n\n    name = \"__{name}__\".format(name=op.__name__)\n    return set_function_name(cmp_method, name, cls)",
                "def _make_arithmetic_op(op, cls):\n    def index_arithmetic_method(self, other):\n        if isinstance(other, (ABCSeries, ABCDataFrame, ABCTimedeltaIndex)):\n            return NotImplemented\n\n        from pandas import Series\n\n        result = op(Series(self), other)\n        if isinstance(result, tuple):\n            return (Index(result[0]), Index(result[1]))\n        return Index(result)\n\n    name = \"__{name}__\".format(name=op.__name__)\n    # TODO: docstring?\n    return set_function_name(index_arithmetic_method, name, cls)",
                "def _new_Index(cls, d):\n    \"\"\"\n    This is called upon unpickling, rather than the default which doesn't\n    have arguments and breaks __new__.\n    \"\"\"\n    # required for backward compat, because PI can't be instantiated with\n    # ordinals through __new__ GH #13277\n    if issubclass(cls, ABCPeriodIndex):\n        from pandas.core.indexes.period import _new_PeriodIndex\n\n        return _new_PeriodIndex(cls, **d)\n    return cls.__new__(cls, **d)",
                "def ensure_index_from_sequences(sequences, names=None):\n    \"\"\"\n    Construct an index from sequences of data.\n\n    A single sequence returns an Index. Many sequences returns a\n    MultiIndex.\n\n    Parameters\n    ----------\n    sequences : sequence of sequences\n    names : sequence of str\n\n    Returns\n    -------\n    index : Index or MultiIndex\n\n    Examples\n    --------\n    >>> ensure_index_from_sequences([[1, 2, 3]], names=['name'])\n    Int64Index([1, 2, 3], dtype='int64', name='name')\n\n    >>> ensure_index_from_sequences([['a', 'a'], ['a', 'b']],\n                                    names=['L1', 'L2'])\n    MultiIndex([('a', 'a'),\n                ('a', 'b')],\n               names=['L1', 'L2'])\n\n    See Also\n    --------\n    ensure_index\n    \"\"\"\n    from .multi import MultiIndex\n\n    if len(sequences) == 1:\n        if names is not None:\n            names = names[0]\n        return Index(sequences[0], name=names)\n    else:\n        return MultiIndex.from_arrays(sequences, names=names)",
                "def ensure_index(index_like, copy=False):\n    \"\"\"\n    Ensure that we have an index from some index-like object.\n\n    Parameters\n    ----------\n    index : sequence\n        An Index or other sequence\n    copy : bool\n\n    Returns\n    -------\n    index : Index or MultiIndex\n\n    Examples\n    --------\n    >>> ensure_index(['a', 'b'])\n    Index(['a', 'b'], dtype='object')\n\n    >>> ensure_index([('a', 'a'),  ('b', 'c')])\n    Index([('a', 'a'), ('b', 'c')], dtype='object')\n\n    >>> ensure_index([['a', 'a'], ['b', 'c']])\n    MultiIndex([('a', 'b'),\n                ('a', 'c')],\n               dtype='object')\n               )\n\n    See Also\n    --------\n    ensure_index_from_sequences\n    \"\"\"\n    if isinstance(index_like, Index):\n        if copy:\n            index_like = index_like.copy()\n        return index_like\n    if hasattr(index_like, \"name\"):\n        return Index(index_like, name=index_like.name, copy=copy)\n\n    if is_iterator(index_like):\n        index_like = list(index_like)\n\n    # must check for exactly list here because of strict type\n    # check in clean_index_list\n    if isinstance(index_like, list):\n        if type(index_like) != list:\n            index_like = list(index_like)\n\n        converted, all_arrays = lib.clean_index_list(index_like)\n\n        if len(converted) > 0 and all_arrays:\n            from .multi import MultiIndex\n\n            return MultiIndex.from_arrays(converted)\n        else:\n            index_like = converted\n    else:\n        # clean_index_list does the equivalent of copying\n        # so only need to do this if not list instance\n        if copy:\n            from copy import copy\n\n            index_like = copy(index_like)\n\n    return Index(index_like)",
                "def _ensure_has_len(seq):\n    \"\"\"\n    If seq is an iterator, put its values into a list.\n    \"\"\"\n    try:\n        len(seq)\n    except TypeError:\n        return list(seq)\n    else:\n        return seq",
                "def _trim_front(strings):\n    \"\"\"\n    Trims zeros and decimal points.\n    \"\"\"\n    trimmed = strings\n    while len(strings) > 0 and all(x[0] == \" \" for x in trimmed):\n        trimmed = [x[1:] for x in trimmed]\n    return trimmed",
                "def _validate_join_method(method):\n    if method not in [\"left\", \"right\", \"inner\", \"outer\"]:\n        raise ValueError(\"do not recognize join method %s\" % method)",
                "def default_index(n):\n    from pandas.core.index import RangeIndex\n\n    return RangeIndex(0, n, name=None)",
                "def cmp_method(self, other):\n    if isinstance(other, (np.ndarray, Index, ABCSeries, ExtensionArray)):\n        if other.ndim > 0 and len(self) != len(other):\n            raise ValueError(\"Lengths must match to compare\")\n\n    if is_object_dtype(self) and isinstance(other, ABCCategorical):\n        left = type(other)(self._values, dtype=other.dtype)\n        return op(left, other)\n    elif is_object_dtype(self) and not isinstance(self, ABCMultiIndex):\n        # don't pass MultiIndex\n        with np.errstate(all=\"ignore\"):\n            result = ops.comp_method_OBJECT_ARRAY(op, self.values, other)\n\n    else:\n        with np.errstate(all=\"ignore\"):\n            result = op(self.values, np.asarray(other))\n\n    if is_bool_dtype(result):\n        return result\n    return ops.invalid_comparison(self, other, op)",
                "def index_arithmetic_method(self, other):\n    if isinstance(other, (ABCSeries, ABCDataFrame, ABCTimedeltaIndex)):\n        return NotImplemented\n\n    from pandas import Series\n\n    result = op(Series(self), other)\n    if isinstance(result, tuple):\n        return (Index(result[0]), Index(result[1]))\n    return Index(result)",
                "def _left_indexer_unique(self, left, right):\n    return libjoin.left_join_indexer_unique(left, right)",
                "def _left_indexer(self, left, right):\n    return libjoin.left_join_indexer(left, right)",
                "def _inner_indexer(self, left, right):\n    return libjoin.inner_join_indexer(left, right)",
                "def _outer_indexer(self, left, right):\n    return libjoin.outer_join_indexer(left, right)",
                "def __new__(\n    cls,\n    data=None,\n    dtype=None,\n    copy=False,\n    name=None,\n    fastpath=None,\n    tupleize_cols=True,\n    **kwargs\n) -> \"Index\":\n\n    from .range import RangeIndex\n    from pandas import PeriodIndex, DatetimeIndex, TimedeltaIndex\n    from .numeric import Float64Index, Int64Index, UInt64Index\n    from .interval import IntervalIndex\n    from .category import CategoricalIndex\n\n    if name is None and hasattr(data, \"name\"):\n        name = data.name\n\n    if fastpath is not None:\n        warnings.warn(\n            \"The 'fastpath' keyword is deprecated, and will be \"\n            \"removed in a future version.\",\n            FutureWarning,\n            stacklevel=2,\n        )\n        if fastpath:\n            return cls._simple_new(data, name)\n\n    if isinstance(data, ABCPandasArray):\n        # ensure users don't accidentally put a PandasArray in an index.\n        data = data.to_numpy()\n\n    # range\n    if isinstance(data, RangeIndex):\n        return RangeIndex(start=data, copy=copy, dtype=dtype, name=name)\n    elif isinstance(data, range):\n        return RangeIndex.from_range(data, dtype=dtype, name=name)\n\n    # categorical\n    elif is_categorical_dtype(data) or is_categorical_dtype(dtype):\n        return CategoricalIndex(data, dtype=dtype, copy=copy, name=name, **kwargs)\n\n    # interval\n    elif (\n        is_interval_dtype(data) or is_interval_dtype(dtype)\n    ) and not is_object_dtype(dtype):\n        closed = kwargs.get(\"closed\", None)\n        return IntervalIndex(data, dtype=dtype, name=name, copy=copy, closed=closed)\n\n    elif (\n        is_datetime64_any_dtype(data)\n        or is_datetime64_any_dtype(dtype)\n        or \"tz\" in kwargs\n    ):\n        if is_dtype_equal(_o_dtype, dtype):\n            # GH#23524 passing `dtype=object` to DatetimeIndex is invalid,\n            #  will raise in the where `data` is already tz-aware.  So\n            #  we leave it out of this step and cast to object-dtype after\n            #  the DatetimeIndex construction.\n            # Note we can pass copy=False because the .astype below\n            #  will always make a copy\n            result = DatetimeIndex(\n                data, copy=False, name=name, **kwargs\n            )  # type: \"Index\"\n            return result.astype(object)\n        else:\n            return DatetimeIndex(data, copy=copy, name=name, dtype=dtype, **kwargs)\n\n    elif is_timedelta64_dtype(data) or is_timedelta64_dtype(dtype):\n        if is_dtype_equal(_o_dtype, dtype):\n            # Note we can pass copy=False because the .astype below\n            #  will always make a copy\n            result = TimedeltaIndex(data, copy=False, name=name, **kwargs)\n            return result.astype(object)\n        else:\n            return TimedeltaIndex(data, copy=copy, name=name, dtype=dtype, **kwargs)\n\n    elif is_period_dtype(data) and not is_object_dtype(dtype):\n        return PeriodIndex(data, copy=copy, name=name, **kwargs)\n\n    # extension dtype\n    elif is_extension_array_dtype(data) or is_extension_array_dtype(dtype):\n        data = np.asarray(data)\n        if not (dtype is None or is_object_dtype(dtype)):\n            # coerce to the provided dtype\n            ea_cls = dtype.construct_array_type()\n            data = ea_cls._from_sequence(data, dtype=dtype, copy=False)\n\n        # coerce to the object dtype\n        data = data.astype(object)\n        return Index(data, dtype=object, copy=copy, name=name, **kwargs)\n\n    # index-like\n    elif isinstance(data, (np.ndarray, Index, ABCSeries)):\n        if dtype is not None:\n            # we need to avoid having numpy coerce\n            # things that look like ints/floats to ints unless\n            # they are actually ints, e.g. '0' and 0.0\n            # should not be coerced\n            # GH 11836\n            if is_integer_dtype(dtype):\n                inferred = lib.infer_dtype(data, skipna=False)\n                if inferred == \"integer\":\n                    data = maybe_cast_to_integer_array(data, dtype, copy=copy)\n                elif inferred in [\"floating\", \"mixed-integer-float\"]:\n                    if isna(data).any():\n                        raise ValueError(\"cannot convert float NaN to integer\")\n\n                    if inferred == \"mixed-integer-float\":\n                        data = maybe_cast_to_integer_array(data, dtype)\n\n                    # If we are actually all equal to integers,\n                    # then coerce to integer.\n                    try:\n                        return cls._try_convert_to_int_index(\n                            data, copy, name, dtype\n                        )\n                    except ValueError:\n                        pass\n\n                    # Return an actual float index.\n                    return Float64Index(data, copy=copy, dtype=dtype, name=name)\n\n                elif inferred == \"string\":\n                    pass\n                else:\n                    data = data.astype(dtype)\n            elif is_float_dtype(dtype):\n                inferred = lib.infer_dtype(data, skipna=False)\n                if inferred == \"string\":\n                    pass\n                else:\n                    data = data.astype(dtype)\n            else:\n                data = np.array(data, dtype=dtype, copy=copy)\n\n        # maybe coerce to a sub-class\n        if is_signed_integer_dtype(data.dtype):\n            return Int64Index(data, copy=copy, dtype=dtype, name=name)\n        elif is_unsigned_integer_dtype(data.dtype):\n            return UInt64Index(data, copy=copy, dtype=dtype, name=name)\n        elif is_float_dtype(data.dtype):\n            return Float64Index(data, copy=copy, dtype=dtype, name=name)\n        elif issubclass(data.dtype.type, np.bool) or is_bool_dtype(data):\n            subarr = data.astype(\"object\")\n        else:\n            subarr = com.asarray_tuplesafe(data, dtype=object)\n\n        # asarray_tuplesafe does not always copy underlying data,\n        # so need to make sure that this happens\n        if copy:\n            subarr = subarr.copy()\n\n        if dtype is None:\n            inferred = lib.infer_dtype(subarr, skipna=False)\n            if inferred == \"integer\":\n                try:\n                    return cls._try_convert_to_int_index(subarr, copy, name, dtype)\n                except ValueError:\n                    pass\n\n                return Index(subarr, copy=copy, dtype=object, name=name)\n            elif inferred in [\"floating\", \"mixed-integer-float\", \"integer-na\"]:\n                # TODO: Returns IntegerArray for integer-na case in the future\n                return Float64Index(subarr, copy=copy, name=name)\n            elif inferred == \"interval\":\n                try:\n                    return IntervalIndex(subarr, name=name, copy=copy)\n                except ValueError:\n                    # GH27172: mixed closed Intervals --> object dtype\n                    pass\n            elif inferred == \"boolean\":\n                # don't support boolean explicitly ATM\n                pass\n            elif inferred != \"string\":\n                if inferred.startswith(\"datetime\"):\n                    try:\n                        return DatetimeIndex(subarr, copy=copy, name=name, **kwargs)\n                    except (ValueError, OutOfBoundsDatetime):\n                        # GH 27011\n                        # If we have mixed timezones, just send it\n                        # down the base constructor\n                        pass\n\n                elif inferred.startswith(\"timedelta\"):\n                    return TimedeltaIndex(subarr, copy=copy, name=name, **kwargs)\n                elif inferred == \"period\":\n                    try:\n                        return PeriodIndex(subarr, name=name, **kwargs)\n                    except IncompatibleFrequency:\n                        pass\n        return cls._simple_new(subarr, name)\n\n    elif hasattr(data, \"__array__\"):\n        return Index(np.asarray(data), dtype=dtype, copy=copy, name=name, **kwargs)\n    elif data is None or is_scalar(data):\n        raise cls._scalar_data_error(data)\n    else:\n        if tupleize_cols and is_list_like(data):\n            # GH21470: convert iterable to list before determining if empty\n            if is_iterator(data):\n                data = list(data)\n\n            if data and all(isinstance(e, tuple) for e in data):\n                # we must be all tuples, otherwise don't construct\n                # 10697\n                from .multi import MultiIndex\n\n                return MultiIndex.from_tuples(\n                    data, names=name or kwargs.get(\"names\")\n                )\n        # other iterable of some kind\n        subarr = com.asarray_tuplesafe(data, dtype=object)\n        return Index(subarr, dtype=dtype, copy=copy, name=name, **kwargs)",
                "@property\ndef asi8(self):\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return None",
                "@classmethod\ndef _simple_new(cls, values, name=None, dtype=None, **kwargs):\n    \"\"\"\n    We require that we have a dtype compat for the values. If we are passed\n    a non-dtype compat, then coerce using the constructor.\n\n    Must be careful not to recurse.\n    \"\"\"\n    if isinstance(values, (ABCSeries, ABCIndexClass)):\n        # Index._data must always be an ndarray.\n        # This is no-copy for when _values is an ndarray,\n        # which should be always at this point.\n        values = np.asarray(values._values)\n\n    result = object.__new__(cls)\n    result._data = values\n    # _index_data is a (temporary?) fix to ensure that the direct data\n    # manipulation we do in `_libs/reduction.pyx` continues to work.\n    # We need access to the actual ndarray, since we're messing with\n    # data buffers and strides. We don't re-use `_ndarray_values`, since\n    # we actually set this value too.\n    result._index_data = values\n    result.name = name\n    for k, v in kwargs.items():\n        setattr(result, k, v)\n    return result._reset_identity()",
                "@cache_readonly\ndef _constructor(self):\n    return type(self)",
                "def _get_attributes_dict(self):\n    \"\"\"\n    Return an attributes dict for my class.\n    \"\"\"\n    return {k: getattr(self, k, None) for k in self._attributes}",
                "@Appender(_index_shared_docs[\"_shallow_copy\"])\ndef _shallow_copy(self, values=None, **kwargs):\n    if values is None:\n        values = self.values\n    attributes = self._get_attributes_dict()\n    attributes.update(kwargs)\n    if not len(values) and \"dtype\" not in kwargs:\n        attributes[\"dtype\"] = self.dtype\n\n    # _simple_new expects an the type of self._data\n    values = getattr(values, \"_values\", values)\n    if isinstance(values, ABCDatetimeArray):\n        # `self.values` returns `self` for tz-aware, so we need to unwrap\n        #  more specifically\n        values = values.asi8\n\n    return self._simple_new(values, **attributes)",
                "def _shallow_copy_with_infer(self, values, **kwargs):\n    \"\"\"\n    Create a new Index inferring the class with passed value, don't copy\n    the data, use the same object attributes with passed in attributes\n    taking precedence.\n\n    *this is an internal non-public method*\n\n    Parameters\n    ----------\n    values : the values to create the new Index, optional\n    kwargs : updates the default attributes for this Index\n    \"\"\"\n    attributes = self._get_attributes_dict()\n    attributes.update(kwargs)\n    attributes[\"copy\"] = False\n    if not len(values) and \"dtype\" not in kwargs:\n        attributes[\"dtype\"] = self.dtype\n    if self._infer_as_myclass:\n        try:\n            return self._constructor(values, **attributes)\n        except (TypeError, ValueError):\n            pass\n    return Index(values, **attributes)",
                "def _update_inplace(self, result, **kwargs):\n    # guard when called from IndexOpsMixin\n    raise TypeError(\"Index can't be updated inplace\")",
                "def is_(self, other):\n    \"\"\"\n    More flexible, faster check like ``is`` but that works through views.\n\n    Note: this is *not* the same as ``Index.identical()``, which checks\n    that metadata is also the same.\n\n    Parameters\n    ----------\n    other : object\n        other object to compare against.\n\n    Returns\n    -------\n    True if both have same underlying data, False otherwise : bool\n    \"\"\"\n    # use something other than None to be clearer\n    return self._id is getattr(other, \"_id\", Ellipsis) and self._id is not None",
                "def _reset_identity(self):\n    \"\"\"\n    Initializes or resets ``_id`` attribute with new object.\n    \"\"\"\n    self._id = _Identity()\n    return self",
                "def _cleanup(self):\n    self._engine.clear_mapping()",
                "@cache_readonly\ndef _engine(self):\n    # property, for now, slow to look up\n\n    # to avoid a reference cycle, bind `_ndarray_values` to a local variable, so\n    # `self` is not passed into the lambda.\n    _ndarray_values = self._ndarray_values\n    return self._engine_type(lambda: _ndarray_values, len(self))",
                "def __len__(self):\n    \"\"\"\n    Return the length of the Index.\n    \"\"\"\n    return len(self._data)",
                "def __array__(self, dtype=None):\n    \"\"\"\n    The array interface, return my values.\n    \"\"\"\n    return np.asarray(self._data, dtype=dtype)",
                "def __array_wrap__(self, result, context=None):\n    \"\"\"\n    Gets called after a ufunc.\n    \"\"\"\n    result = lib.item_from_zerodim(result)\n    if is_bool_dtype(result) or lib.is_scalar(result):\n        return result\n\n    attrs = self._get_attributes_dict()\n    return Index(result, **attrs)",
                "@cache_readonly\ndef dtype(self):\n    \"\"\"\n    Return the dtype object of the underlying data.\n    \"\"\"\n    return self._data.dtype",
                "@property\ndef dtype_str(self):\n    \"\"\"\n    Return the dtype str of the underlying data.\n\n    .. deprecated:: 0.25.0\n    \"\"\"\n    warnings.warn(\n        \"`dtype_str` has been deprecated. Call `str` on the \"\n        \"dtype attribute instead.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n    return str(self.dtype)",
                "def ravel(self, order=\"C\"):\n    \"\"\"\n    Return an ndarray of the flattened values of the underlying data.\n\n    Returns\n    -------\n    numpy.ndarray\n        Flattened array.\n\n    See Also\n    --------\n    numpy.ndarray.ravel\n    \"\"\"\n    return self._ndarray_values.ravel(order=order)",
                "def view(self, cls=None):\n\n    # we need to see if we are subclassing an\n    # index type here\n    if cls is not None and not hasattr(cls, \"_typ\"):\n        result = self._data.view(cls)\n    else:\n        result = self._shallow_copy()\n    if isinstance(result, Index):\n        result._id = self._id\n    return result",
                "@Appender(_index_shared_docs[\"astype\"])\ndef astype(self, dtype, copy=True):\n    if is_dtype_equal(self.dtype, dtype):\n        return self.copy() if copy else self\n\n    elif is_categorical_dtype(dtype):\n        from .category import CategoricalIndex\n\n        return CategoricalIndex(self.values, name=self.name, dtype=dtype, copy=copy)\n    elif is_datetime64tz_dtype(dtype):\n        # TODO(GH-24559): Remove this block, use the following elif.\n        # avoid FutureWarning from DatetimeIndex constructor.\n        from pandas import DatetimeIndex\n\n        tz = pandas_dtype(dtype).tz\n        return DatetimeIndex(np.asarray(self)).tz_localize(\"UTC\").tz_convert(tz)\n\n    elif is_extension_array_dtype(dtype):\n        return Index(np.asarray(self), dtype=dtype, copy=copy)\n\n    try:\n        if is_datetime64tz_dtype(dtype):\n            from pandas import DatetimeIndex\n\n            return DatetimeIndex(\n                self.values, name=self.name, dtype=dtype, copy=copy\n            )\n        return Index(\n            self.values.astype(dtype, copy=copy), name=self.name, dtype=dtype\n        )\n    except (TypeError, ValueError):\n        msg = \"Cannot cast {name} to dtype {dtype}\"\n        raise TypeError(msg.format(name=type(self).__name__, dtype=dtype))",
                "@Appender(_index_shared_docs[\"take\"] % _index_doc_kwargs)\ndef take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs):\n    if kwargs:\n        nv.validate_take(tuple(), kwargs)\n    indices = ensure_platform_int(indices)\n    if self._can_hold_na:\n        taken = self._assert_take_fillable(\n            self.values,\n            indices,\n            allow_fill=allow_fill,\n            fill_value=fill_value,\n            na_value=self._na_value,\n        )\n    else:\n        if allow_fill and fill_value is not None:\n            msg = \"Unable to fill values because {0} cannot contain NA\"\n            raise ValueError(msg.format(self.__class__.__name__))\n        taken = self.values.take(indices)\n    return self._shallow_copy(taken)",
                "def _assert_take_fillable(\n    self, values, indices, allow_fill=True, fill_value=None, na_value=np.nan\n):\n    \"\"\"\n    Internal method to handle NA filling of take.\n    \"\"\"\n    indices = ensure_platform_int(indices)\n\n    # only fill if we are passing a non-None fill_value\n    if allow_fill and fill_value is not None:\n        if (indices < -1).any():\n            msg = (\n                \"When allow_fill=True and fill_value is not None, \"\n                \"all indices must be >= -1\"\n            )\n            raise ValueError(msg)\n        taken = algos.take(\n            values, indices, allow_fill=allow_fill, fill_value=na_value\n        )\n    else:\n        taken = values.take(indices)\n    return taken",
                "@Appender(_index_shared_docs[\"repeat\"] % _index_doc_kwargs)\ndef repeat(self, repeats, axis=None):\n    repeats = ensure_platform_int(repeats)\n    nv.validate_repeat(tuple(), dict(axis=axis))\n    return self._shallow_copy(self._values.repeat(repeats))",
                "@Appender(_index_shared_docs[\"copy\"])\ndef copy(self, name=None, deep=False, dtype=None, **kwargs):\n    if deep:\n        new_index = self._shallow_copy(self._data.copy())\n    else:\n        new_index = self._shallow_copy()\n\n    names = kwargs.get(\"names\")\n    names = self._validate_names(name=name, names=names, deep=deep)\n    new_index = new_index.set_names(names)\n\n    if dtype:\n        new_index = new_index.astype(dtype)\n    return new_index",
                "def __copy__(self, **kwargs):\n    return self.copy(**kwargs)",
                "def __deepcopy__(self, memo=None):\n    \"\"\"\n    Parameters\n    ----------\n    memo, default None\n        Standard signature. Unused\n    \"\"\"\n    if memo is None:\n        memo = {}\n    return self.copy(deep=True)",
                "def __repr__(self):\n    \"\"\"\n    Return a string representation for this object.\n    \"\"\"\n    klass = self.__class__.__name__\n    data = self._format_data()\n    attrs = self._format_attrs()\n    space = self._format_space()\n\n    prepr = (\",%s\" % space).join(\"%s=%s\" % (k, v) for k, v in attrs)\n\n    # no data provided, just attributes\n    if data is None:\n        data = \"\"\n\n    res = \"%s(%s%s)\" % (klass, data, prepr)\n\n    return res",
                "def _format_space(self):\n\n    # using space here controls if the attributes\n    # are line separated or not (the default)\n\n    # max_seq_items = get_option('display.max_seq_items')\n    # if len(self) > max_seq_items:\n    #    space = \"\\n%s\" % (' ' * (len(klass) + 1))\n    return \" \"",
                "@property\ndef _formatter_func(self):\n    \"\"\"\n    Return the formatter function.\n    \"\"\"\n    return default_pprint",
                "def _format_data(self, name=None):\n    \"\"\"\n    Return the formatted data as a unicode string.\n    \"\"\"\n\n    # do we want to justify (only do so for non-objects)\n    is_justify = not (\n        self.inferred_type in (\"string\", \"unicode\")\n        or (\n            self.inferred_type == \"categorical\" and is_object_dtype(self.categories)\n        )\n    )\n\n    return format_object_summary(\n        self, self._formatter_func, is_justify=is_justify, name=name\n    )",
                "def _format_attrs(self):\n    \"\"\"\n    Return a list of tuples of the (attr,formatted_value).\n    \"\"\"\n    return format_object_attrs(self)",
                "def _mpl_repr(self):\n    # how to represent ourselves to matplotlib\n    return self.values",
                "def format(self, name=False, formatter=None, **kwargs):\n    \"\"\"\n    Render a string representation of the Index.\n    \"\"\"\n    header = []\n    if name:\n        header.append(\n            pprint_thing(self.name, escape_chars=(\"\\t\", \"\\r\", \"\\n\"))\n            if self.name is not None\n            else \"\"\n        )\n\n    if formatter is not None:\n        return header + list(self.map(formatter))\n\n    return self._format_with_header(header, **kwargs)",
                "def _format_with_header(self, header, na_rep=\"NaN\", **kwargs):\n    values = self.values\n\n    from pandas.io.formats.format import format_array\n\n    if is_categorical_dtype(values.dtype):\n        values = np.array(values)\n\n    elif is_object_dtype(values.dtype):\n        values = lib.maybe_convert_objects(values, safe=1)\n\n    if is_object_dtype(values.dtype):\n        result = [pprint_thing(x, escape_chars=(\"\\t\", \"\\r\", \"\\n\")) for x in values]\n\n        # could have nans\n        mask = isna(values)\n        if mask.any():\n            result = np.array(result)\n            result[mask] = na_rep\n            result = result.tolist()\n\n    else:\n        result = _trim_front(format_array(values, None, justify=\"left\"))\n    return header + result",
                "def to_native_types(self, slicer=None, **kwargs):\n    \"\"\"\n    Format specified values of `self` and return them.\n\n    Parameters\n    ----------\n    slicer : int, array-like\n        An indexer into `self` that specifies which values\n        are used in the formatting process.\n    kwargs : dict\n        Options for specifying how the values should be formatted.\n        These options include the following:\n\n        1) na_rep : str\n            The value that serves as a placeholder for NULL values\n        2) quoting : bool or None\n            Whether or not there are quoted values in `self`\n        3) date_format : str\n            The format used to represent date-like values\n\n    Returns\n    -------\n    numpy.ndarray\n        Formatted values.\n    \"\"\"\n\n    values = self\n    if slicer is not None:\n        values = values[slicer]\n    return values._format_native_types(**kwargs)",
                "def _format_native_types(self, na_rep=\"\", quoting=None, **kwargs):\n    \"\"\"\n    Actually format specific types of the index.\n    \"\"\"\n    mask = isna(self)\n    if not self.is_object() and not quoting:\n        values = np.asarray(self).astype(str)\n    else:\n        values = np.array(self, dtype=object, copy=True)\n\n    values[mask] = na_rep\n    return values",
                "def _summary(self, name=None):\n    \"\"\"\n    Return a summarized representation.\n\n    Parameters\n    ----------\n    name : str\n        name to use in the summary representation\n\n    Returns\n    -------\n    String with a summarized representation of the index\n    \"\"\"\n    if len(self) > 0:\n        head = self[0]\n        if hasattr(head, \"format\") and not isinstance(head, str):\n            head = head.format()\n        tail = self[-1]\n        if hasattr(tail, \"format\") and not isinstance(tail, str):\n            tail = tail.format()\n        index_summary = \", %s to %s\" % (pprint_thing(head), pprint_thing(tail))\n    else:\n        index_summary = \"\"\n\n    if name is None:\n        name = type(self).__name__\n    return \"%s: %s entries%s\" % (name, len(self), index_summary)",
                "def summary(self, name=None):\n    \"\"\"\n    Return a summarized representation.\n\n    .. deprecated:: 0.23.0\n    \"\"\"\n    warnings.warn(\n        \"'summary' is deprecated and will be removed in a future version.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n    return self._summary(name)",
                "def to_flat_index(self):\n    \"\"\"\n    Identity method.\n\n    .. versionadded:: 0.24.0\n\n    This is implemented for compatibility with subclass implementations\n    when chaining.\n\n    Returns\n    -------\n    pd.Index\n        Caller.\n\n    See Also\n    --------\n    MultiIndex.to_flat_index : Subclass implementation.\n    \"\"\"\n    return self",
                "def to_series(self, index=None, name=None):\n    \"\"\"\n    Create a Series with both index and values equal to the index keys\n    useful with map for returning an indexer based on an index.\n\n    Parameters\n    ----------\n    index : Index, optional\n        index of resulting Series. If None, defaults to original index\n    name : string, optional\n        name of resulting Series. If None, defaults to name of original\n        index\n\n    Returns\n    -------\n    Series : dtype will be based on the type of the Index values.\n    \"\"\"\n\n    from pandas import Series\n\n    if index is None:\n        index = self._shallow_copy()\n    if name is None:\n        name = self.name\n\n    return Series(self.values.copy(), index=index, name=name)",
                "def to_frame(self, index=True, name=None):\n    \"\"\"\n    Create a DataFrame with a column containing the Index.\n\n    .. versionadded:: 0.24.0\n\n    Parameters\n    ----------\n    index : boolean, default True\n        Set the index of the returned DataFrame as the original Index.\n\n    name : object, default None\n        The passed name should substitute for the index name (if it has\n        one).\n\n    Returns\n    -------\n    DataFrame\n        DataFrame containing the original Index data.\n\n    See Also\n    --------\n    Index.to_series : Convert an Index to a Series.\n    Series.to_frame : Convert Series to DataFrame.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['Ant', 'Bear', 'Cow'], name='animal')\n    >>> idx.to_frame()\n           animal\n    animal\n    Ant       Ant\n    Bear     Bear\n    Cow       Cow\n\n    By default, the original Index is reused. To enforce a new Index:\n\n    >>> idx.to_frame(index=False)\n        animal\n    0   Ant\n    1  Bear\n    2   Cow\n\n    To override the name of the resulting column, specify `name`:\n\n    >>> idx.to_frame(index=False, name='zoo')\n        zoo\n    0   Ant\n    1  Bear\n    2   Cow\n    \"\"\"\n\n    from pandas import DataFrame\n\n    if name is None:\n        name = self.name or 0\n    result = DataFrame({name: self._values.copy()})\n\n    if index:\n        result.index = self\n    return result",
                "def _validate_names(self, name=None, names=None, deep=False):\n    \"\"\"\n    Handles the quirks of having a singular 'name' parameter for general\n    Index and plural 'names' parameter for MultiIndex.\n    \"\"\"\n    from copy import deepcopy\n\n    if names is not None and name is not None:\n        raise TypeError(\"Can only provide one of `names` and `name`\")\n    elif names is None and name is None:\n        return deepcopy(self.names) if deep else self.names\n    elif names is not None:\n        if not is_list_like(names):\n            raise TypeError(\"Must pass list-like as `names`.\")\n        return names\n    else:\n        if not is_list_like(name):\n            return [name]\n        return name",
                "def _get_names(self):\n    return FrozenList((self.name,))",
                "def _set_names(self, values, level=None):\n    \"\"\"\n    Set new names on index. Each name has to be a hashable type.\n\n    Parameters\n    ----------\n    values : str or sequence\n        name(s) to set\n    level : int, level name, or sequence of int/level names (default None)\n        If the index is a MultiIndex (hierarchical), level(s) to set (None\n        for all levels).  Otherwise level must be None\n\n    Raises\n    ------\n    TypeError if each name is not hashable.\n    \"\"\"\n    if not is_list_like(values):\n        raise ValueError(\"Names must be a list-like\")\n    if len(values) != 1:\n        raise ValueError(\"Length of new names must be 1, got %d\" % len(values))\n\n    # GH 20527\n    # All items in 'name' need to be hashable:\n    for name in values:\n        if not is_hashable(name):\n            raise TypeError(\n                \"{}.name must be a hashable type\".format(self.__class__.__name__)\n            )\n    self.name = values[0]",
                "def set_names(self, names, level=None, inplace=False):\n    \"\"\"\n    Set Index or MultiIndex name.\n\n    Able to set new names partially and by level.\n\n    Parameters\n    ----------\n    names : label or list of label\n        Name(s) to set.\n    level : int, label or list of int or label, optional\n        If the index is a MultiIndex, level(s) to set (None for all\n        levels). Otherwise level must be None.\n    inplace : bool, default False\n        Modifies the object directly, instead of creating a new Index or\n        MultiIndex.\n\n    Returns\n    -------\n    Index\n        The same type as the caller or None if inplace is True.\n\n    See Also\n    --------\n    Index.rename : Able to set new names without level.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1, 2, 3, 4])\n    >>> idx\n    Int64Index([1, 2, 3, 4], dtype='int64')\n    >>> idx.set_names('quarter')\n    Int64Index([1, 2, 3, 4], dtype='int64', name='quarter')\n\n    >>> idx = pd.MultiIndex.from_product([['python', 'cobra'],\n    ...                                   [2018, 2019]])\n    >>> idx\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               )\n    >>> idx.set_names(['kind', 'year'], inplace=True)\n    >>> idx\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['kind', 'year'])\n    >>> idx.set_names('species', level=0)\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['species', 'year'])\n    \"\"\"\n\n    if level is not None and not isinstance(self, ABCMultiIndex):\n        raise ValueError(\"Level must be None for non-MultiIndex\")\n\n    if level is not None and not is_list_like(level) and is_list_like(names):\n        msg = \"Names must be a string when a single level is provided.\"\n        raise TypeError(msg)\n\n    if not is_list_like(names) and level is None and self.nlevels > 1:\n        raise TypeError(\"Must pass list-like as `names`.\")\n\n    if not is_list_like(names):\n        names = [names]\n    if level is not None and not is_list_like(level):\n        level = [level]\n\n    if inplace:\n        idx = self\n    else:\n        idx = self._shallow_copy()\n    idx._set_names(names, level=level)\n    if not inplace:\n        return idx",
                "def rename(self, name, inplace=False):\n    \"\"\"\n    Alter Index or MultiIndex name.\n\n    Able to set new names without level. Defaults to returning new index.\n    Length of names must match number of levels in MultiIndex.\n\n    Parameters\n    ----------\n    name : label or list of labels\n        Name(s) to set.\n    inplace : boolean, default False\n        Modifies the object directly, instead of creating a new Index or\n        MultiIndex.\n\n    Returns\n    -------\n    Index\n        The same type as the caller or None if inplace is True.\n\n    See Also\n    --------\n    Index.set_names : Able to set new names partially and by level.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['A', 'C', 'A', 'B'], name='score')\n    >>> idx.rename('grade')\n    Index(['A', 'C', 'A', 'B'], dtype='object', name='grade')\n\n    >>> idx = pd.MultiIndex.from_product([['python', 'cobra'],\n    ...                                   [2018, 2019]],\n    ...                                   names=['kind', 'year'])\n    >>> idx\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['kind', 'year'])\n    >>> idx.rename(['species', 'year'])\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['species', 'year'])\n    >>> idx.rename('species')\n    Traceback (most recent call last):\n    TypeError: Must pass list-like as `names`.\n    \"\"\"\n    return self.set_names([name], inplace=inplace)",
                "@property\ndef nlevels(self):\n    \"\"\"\n    Number of levels.\n    \"\"\"\n    return 1",
                "def _sort_levels_monotonic(self):\n    \"\"\"\n    Compat with MultiIndex.\n    \"\"\"\n    return self",
                "def _validate_index_level(self, level):\n    \"\"\"\n    Validate index level.\n\n    For single-level Index getting level number is a no-op, but some\n    verification must be done like in MultiIndex.\n\n    \"\"\"\n    if isinstance(level, int):\n        if level < 0 and level != -1:\n            raise IndexError(\n                \"Too many levels: Index has only 1 level,\"\n                \" %d is not a valid level number\" % (level,)\n            )\n        elif level > 0:\n            raise IndexError(\n                \"Too many levels: Index has only 1 level, not %d\" % (level + 1)\n            )\n    elif level != self.name:\n        raise KeyError(\n            \"Requested level ({}) does not match index name ({})\".format(\n                level, self.name\n            )\n        )",
                "def _get_level_number(self, level):\n    self._validate_index_level(level)\n    return 0",
                "def sortlevel(self, level=None, ascending=True, sort_remaining=None):\n    \"\"\"\n    For internal compatibility with with the Index API.\n\n    Sort the Index. This is for compat with MultiIndex\n\n    Parameters\n    ----------\n    ascending : boolean, default True\n        False to sort in descending order\n\n    level, sort_remaining are compat parameters\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    return self.sort_values(return_indexer=True, ascending=ascending)",
                "def _get_level_values(self, level):\n    \"\"\"\n    Return an Index of values for requested level.\n\n    This is primarily useful to get an individual level of values from a\n    MultiIndex, but is provided on Index as well for compatibility.\n\n    Parameters\n    ----------\n    level : int or str\n        It is either the integer position or the name of the level.\n\n    Returns\n    -------\n    Index\n        Calling object, as there is only one level in the Index.\n\n    See Also\n    --------\n    MultiIndex.get_level_values : Get values for a level of a MultiIndex.\n\n    Notes\n    -----\n    For Index, level should be 0, since there are no multiple levels.\n\n    Examples\n    --------\n\n    >>> idx = pd.Index(list('abc'))\n    >>> idx\n    Index(['a', 'b', 'c'], dtype='object')\n\n    Get level values by supplying `level` as integer:\n\n    >>> idx.get_level_values(0)\n    Index(['a', 'b', 'c'], dtype='object')\n    \"\"\"\n    self._validate_index_level(level)\n    return self",
                "def droplevel(self, level=0):\n    \"\"\"\n    Return index with requested level(s) removed.\n\n    If resulting index has only 1 level left, the result will be\n    of Index type, not MultiIndex.\n\n    .. versionadded:: 0.23.1 (support for non-MultiIndex)\n\n    Parameters\n    ----------\n    level : int, str, or list-like, default 0\n        If a string is given, must be the name of a level\n        If list-like, elements must be names or indexes of levels.\n\n    Returns\n    -------\n    Index or MultiIndex\n    \"\"\"\n    if not isinstance(level, (tuple, list)):\n        level = [level]\n\n    levnums = sorted(self._get_level_number(lev) for lev in level)[::-1]\n\n    if len(level) == 0:\n        return self\n    if len(level) >= self.nlevels:\n        raise ValueError(\n            \"Cannot remove {} levels from an index with {} \"\n            \"levels: at least one level must be \"\n            \"left.\".format(len(level), self.nlevels)\n        )\n    # The two checks above guarantee that here self is a MultiIndex\n\n    new_levels = list(self.levels)\n    new_codes = list(self.codes)\n    new_names = list(self.names)\n\n    for i in levnums:\n        new_levels.pop(i)\n        new_codes.pop(i)\n        new_names.pop(i)\n\n    if len(new_levels) == 1:\n\n        # set nan if needed\n        mask = new_codes[0] == -1\n        result = new_levels[0].take(new_codes[0])\n        if mask.any():\n            result = result.putmask(mask, np.nan)\n\n        result.name = new_names[0]\n        return result\n    else:\n        from .multi import MultiIndex\n\n        return MultiIndex(\n            levels=new_levels,\n            codes=new_codes,\n            names=new_names,\n            verify_integrity=False,\n        )",
                "@Appender(_index_shared_docs[\"_get_grouper_for_level\"])\ndef _get_grouper_for_level(self, mapper, level=None):\n    assert level is None or level == 0\n    if mapper is None:\n        grouper = self\n    else:\n        grouper = self.map(mapper)\n\n    return grouper, None, None",
                "@property\ndef is_monotonic(self):\n    \"\"\"\n    Alias for is_monotonic_increasing.\n    \"\"\"\n    return self.is_monotonic_increasing",
                "@property\ndef is_monotonic_increasing(self):\n    \"\"\"\n    Return if the index is monotonic increasing (only equal or\n    increasing) values.\n\n    Examples\n    --------\n    >>> Index([1, 2, 3]).is_monotonic_increasing\n    True\n    >>> Index([1, 2, 2]).is_monotonic_increasing\n    True\n    >>> Index([1, 3, 2]).is_monotonic_increasing\n    False\n    \"\"\"\n    return self._engine.is_monotonic_increasing",
                "@property\ndef is_monotonic_decreasing(self):\n    \"\"\"\n    Return if the index is monotonic decreasing (only equal or\n    decreasing) values.\n\n    Examples\n    --------\n    >>> Index([3, 2, 1]).is_monotonic_decreasing\n    True\n    >>> Index([3, 2, 2]).is_monotonic_decreasing\n    True\n    >>> Index([3, 1, 2]).is_monotonic_decreasing\n    False\n    \"\"\"\n    return self._engine.is_monotonic_decreasing",
                "@property\ndef _is_strictly_monotonic_increasing(self):\n    \"\"\"\n    Return if the index is strictly monotonic increasing\n    (only increasing) values.\n\n    Examples\n    --------\n    >>> Index([1, 2, 3])._is_strictly_monotonic_increasing\n    True\n    >>> Index([1, 2, 2])._is_strictly_monotonic_increasing\n    False\n    >>> Index([1, 3, 2])._is_strictly_monotonic_increasing\n    False\n    \"\"\"\n    return self.is_unique and self.is_monotonic_increasing",
                "@property\ndef _is_strictly_monotonic_decreasing(self):\n    \"\"\"\n    Return if the index is strictly monotonic decreasing\n    (only decreasing) values.\n\n    Examples\n    --------\n    >>> Index([3, 2, 1])._is_strictly_monotonic_decreasing\n    True\n    >>> Index([3, 2, 2])._is_strictly_monotonic_decreasing\n    False\n    >>> Index([3, 1, 2])._is_strictly_monotonic_decreasing\n    False\n    \"\"\"\n    return self.is_unique and self.is_monotonic_decreasing",
                "def is_lexsorted_for_tuple(self, tup):\n    return True",
                "@cache_readonly\ndef is_unique(self):\n    \"\"\"\n    Return if the index has unique values.\n    \"\"\"\n    return self._engine.is_unique",
                "@property\ndef has_duplicates(self):\n    return not self.is_unique",
                "def is_boolean(self):\n    return self.inferred_type in [\"boolean\"]",
                "def is_integer(self):\n    return self.inferred_type in [\"integer\"]",
                "def is_floating(self):\n    return self.inferred_type in [\"floating\", \"mixed-integer-float\", \"integer-na\"]",
                "def is_numeric(self):\n    return self.inferred_type in [\"integer\", \"floating\"]",
                "def is_object(self):\n    return is_object_dtype(self.dtype)",
                "def is_categorical(self):\n    \"\"\"\n    Check if the Index holds categorical data.\n\n    Returns\n    -------\n    boolean\n        True if the Index is categorical.\n\n    See Also\n    --------\n    CategoricalIndex : Index for categorical data.\n\n    Examples\n    --------\n    >>> idx = pd.Index([\"Watermelon\", \"Orange\", \"Apple\",\n    ...                 \"Watermelon\"]).astype(\"category\")\n    >>> idx.is_categorical()\n    True\n\n    >>> idx = pd.Index([1, 3, 5, 7])\n    >>> idx.is_categorical()\n    False\n\n    >>> s = pd.Series([\"Peter\", \"Victor\", \"Elisabeth\", \"Mar\"])\n    >>> s\n    0        Peter\n    1       Victor\n    2    Elisabeth\n    3          Mar\n    dtype: object\n    >>> s.index.is_categorical()\n    False\n    \"\"\"\n    return self.inferred_type in [\"categorical\"]",
                "def is_interval(self):\n    return self.inferred_type in [\"interval\"]",
                "def is_mixed(self):\n    return self.inferred_type in [\"mixed\"]",
                "def holds_integer(self):\n    \"\"\"\n    Whether the type is an integer type.\n    \"\"\"\n    return self.inferred_type in [\"integer\", \"mixed-integer\"]",
                "@cache_readonly\ndef inferred_type(self):\n    \"\"\"\n    Return a string of the type inferred from the values.\n    \"\"\"\n    return lib.infer_dtype(self, skipna=False)",
                "@cache_readonly\ndef is_all_dates(self):\n    return is_datetime_array(ensure_object(self.values))",
                "def __reduce__(self):\n    d = dict(data=self._data)\n    d.update(self._get_attributes_dict())\n    return _new_Index, (self.__class__, d), None",
                "def __setstate__(self, state):\n    \"\"\"\n    Necessary for making this object picklable.\n    \"\"\"\n\n    if isinstance(state, dict):\n        self._data = state.pop(\"data\")\n        for k, v in state.items():\n            setattr(self, k, v)\n\n    elif isinstance(state, tuple):\n\n        if len(state) == 2:\n            nd_state, own_state = state\n            data = np.empty(nd_state[1], dtype=nd_state[2])\n            np.ndarray.__setstate__(data, nd_state)\n            self.name = own_state[0]\n\n        else:  # pragma: no cover\n            data = np.empty(state)\n            np.ndarray.__setstate__(data, state)\n\n        self._data = data\n        self._reset_identity()\n    else:\n        raise Exception(\"invalid pickle state\")",
                "@cache_readonly\ndef _isnan(self):\n    \"\"\"\n    Return if each value is NaN.\n    \"\"\"\n    if self._can_hold_na:\n        return isna(self)\n    else:\n        # shouldn't reach to this condition by checking hasnans beforehand\n        values = np.empty(len(self), dtype=np.bool_)\n        values.fill(False)\n        return values",
                "@cache_readonly\ndef _nan_idxs(self):\n    if self._can_hold_na:\n        w, = self._isnan.nonzero()\n        return w\n    else:\n        return np.array([], dtype=np.int64)",
                "@cache_readonly\ndef hasnans(self):\n    \"\"\"\n    Return if I have any nans; enables various perf speedups.\n    \"\"\"\n    if self._can_hold_na:\n        return bool(self._isnan.any())\n    else:\n        return False",
                "def isna(self):\n    \"\"\"\n    Detect missing values.\n\n    Return a boolean same-sized object indicating if the values are NA.\n    NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get\n    mapped to ``True`` values.\n    Everything else get mapped to ``False`` values. Characters such as\n    empty strings `''` or :attr:`numpy.inf` are not considered NA values\n    (unless you set ``pandas.options.mode.use_inf_as_na = True``).\n\n    .. versionadded:: 0.20.0\n\n    Returns\n    -------\n    numpy.ndarray\n        A boolean array of whether my values are NA.\n\n    See Also\n    --------\n    Index.notna : Boolean inverse of isna.\n    Index.dropna : Omit entries with missing values.\n    isna : Top-level isna.\n    Series.isna : Detect missing values in Series object.\n\n    Examples\n    --------\n    Show which entries in a pandas.Index are NA. The result is an\n    array.\n\n    >>> idx = pd.Index([5.2, 6.0, np.NaN])\n    >>> idx\n    Float64Index([5.2, 6.0, nan], dtype='float64')\n    >>> idx.isna()\n    array([False, False,  True], dtype=bool)\n\n    Empty strings are not considered NA values. None is considered an NA\n    value.\n\n    >>> idx = pd.Index(['black', '', 'red', None])\n    >>> idx\n    Index(['black', '', 'red', None], dtype='object')\n    >>> idx.isna()\n    array([False, False, False,  True], dtype=bool)\n\n    For datetimes, `NaT` (Not a Time) is considered as an NA value.\n\n    >>> idx = pd.DatetimeIndex([pd.Timestamp('1940-04-25'),\n    ...                         pd.Timestamp(''), None, pd.NaT])\n    >>> idx\n    DatetimeIndex(['1940-04-25', 'NaT', 'NaT', 'NaT'],\n                  dtype='datetime64[ns]', freq=None)\n    >>> idx.isna()\n    array([False,  True,  True,  True], dtype=bool)\n    \"\"\"\n    return self._isnan",
                "def notna(self):\n    \"\"\"\n    Detect existing (non-missing) values.\n\n    Return a boolean same-sized object indicating if the values are not NA.\n    Non-missing values get mapped to ``True``. Characters such as empty\n    strings ``''`` or :attr:`numpy.inf` are not considered NA values\n    (unless you set ``pandas.options.mode.use_inf_as_na = True``).\n    NA values, such as None or :attr:`numpy.NaN`, get mapped to ``False``\n    values.\n\n    .. versionadded:: 0.20.0\n\n    Returns\n    -------\n    numpy.ndarray\n        Boolean array to indicate which entries are not NA.\n\n    See Also\n    --------\n    Index.notnull : Alias of notna.\n    Index.isna: Inverse of notna.\n    notna : Top-level notna.\n\n    Examples\n    --------\n    Show which entries in an Index are not NA. The result is an\n    array.\n\n    >>> idx = pd.Index([5.2, 6.0, np.NaN])\n    >>> idx\n    Float64Index([5.2, 6.0, nan], dtype='float64')\n    >>> idx.notna()\n    array([ True,  True, False])\n\n    Empty strings are not considered NA values. None is considered a NA\n    value.\n\n    >>> idx = pd.Index(['black', '', 'red', None])\n    >>> idx\n    Index(['black', '', 'red', None], dtype='object')\n    >>> idx.notna()\n    array([ True,  True,  True, False])\n    \"\"\"\n    return ~self.isna()",
                "@Appender(_index_shared_docs[\"fillna\"])\ndef fillna(self, value=None, downcast=None):\n    self._assert_can_do_op(value)\n    if self.hasnans:\n        result = self.putmask(self._isnan, value)\n        if downcast is None:\n            # no need to care metadata other than name\n            # because it can't have freq if\n            return Index(result, name=self.name)\n    return self._shallow_copy()",
                "@Appender(_index_shared_docs[\"dropna\"])\ndef dropna(self, how=\"any\"):\n    if how not in (\"any\", \"all\"):\n        raise ValueError(\"invalid how option: {0}\".format(how))\n\n    if self.hasnans:\n        return self._shallow_copy(self.values[~self._isnan])\n    return self._shallow_copy()",
                "@Appender(_index_shared_docs[\"index_unique\"] % _index_doc_kwargs)\ndef unique(self, level=None):\n    if level is not None:\n        self._validate_index_level(level)\n    result = super().unique()\n    return self._shallow_copy(result)",
                "def drop_duplicates(self, keep=\"first\"):\n    \"\"\"\n    Return Index with duplicate values removed.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', ``False``}, default 'first'\n        - 'first' : Drop duplicates except for the first occurrence.\n        - 'last' : Drop duplicates except for the last occurrence.\n        - ``False`` : Drop all duplicates.\n\n    Returns\n    -------\n    deduplicated : Index\n\n    See Also\n    --------\n    Series.drop_duplicates : Equivalent method on Series.\n    DataFrame.drop_duplicates : Equivalent method on DataFrame.\n    Index.duplicated : Related method on Index, indicating duplicate\n        Index values.\n\n    Examples\n    --------\n    Generate an pandas.Index with duplicate values.\n\n    >>> idx = pd.Index(['lama', 'cow', 'lama', 'beetle', 'lama', 'hippo'])\n\n    The `keep` parameter controls  which duplicate values are removed.\n    The value 'first' keeps the first occurrence for each\n    set of duplicated entries. The default value of keep is 'first'.\n\n    >>> idx.drop_duplicates(keep='first')\n    Index(['lama', 'cow', 'beetle', 'hippo'], dtype='object')\n\n    The value 'last' keeps the last occurrence for each set of duplicated\n    entries.\n\n    >>> idx.drop_duplicates(keep='last')\n    Index(['cow', 'beetle', 'lama', 'hippo'], dtype='object')\n\n    The value ``False`` discards all sets of duplicated entries.\n\n    >>> idx.drop_duplicates(keep=False)\n    Index(['cow', 'beetle', 'hippo'], dtype='object')\n    \"\"\"\n    return super().drop_duplicates(keep=keep)",
                "def duplicated(self, keep=\"first\"):\n    \"\"\"\n    Indicate duplicate index values.\n\n    Duplicated values are indicated as ``True`` values in the resulting\n    array. Either all duplicates, all except the first, or all except the\n    last occurrence of duplicates can be indicated.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', False}, default 'first'\n        The value or values in a set of duplicates to mark as missing.\n\n        - 'first' : Mark duplicates as ``True`` except for the first\n          occurrence.\n        - 'last' : Mark duplicates as ``True`` except for the last\n          occurrence.\n        - ``False`` : Mark all duplicates as ``True``.\n\n    Returns\n    -------\n    numpy.ndarray\n\n    See Also\n    --------\n    Series.duplicated : Equivalent method on pandas.Series.\n    DataFrame.duplicated : Equivalent method on pandas.DataFrame.\n    Index.drop_duplicates : Remove duplicate values from Index.\n\n    Examples\n    --------\n    By default, for each set of duplicated values, the first occurrence is\n    set to False and all others to True:\n\n    >>> idx = pd.Index(['lama', 'cow', 'lama', 'beetle', 'lama'])\n    >>> idx.duplicated()\n    array([False, False,  True, False,  True])\n\n    which is equivalent to\n\n    >>> idx.duplicated(keep='first')\n    array([False, False,  True, False,  True])\n\n    By using 'last', the last occurrence of each set of duplicated values\n    is set on False and all others on True:\n\n    >>> idx.duplicated(keep='last')\n    array([ True, False,  True, False, False])\n\n    By setting keep on ``False``, all duplicates are True:\n\n    >>> idx.duplicated(keep=False)\n    array([ True, False,  True, False,  True])\n    \"\"\"\n    return super().duplicated(keep=keep)",
                "def get_duplicates(self):\n    \"\"\"\n    Extract duplicated index elements.\n\n    .. deprecated:: 0.23.0\n        Use idx[idx.duplicated()].unique() instead\n\n    Returns a sorted list of index elements which appear more than once in\n    the index.\n\n    Returns\n    -------\n    array-like\n        List of duplicated indexes.\n\n    See Also\n    --------\n    Index.duplicated : Return boolean array denoting duplicates.\n    Index.drop_duplicates : Return Index with duplicates removed.\n\n    Examples\n    --------\n\n    Works on different Index of types.\n\n    >>> pd.Index([1, 2, 2, 3, 3, 3, 4]).get_duplicates()  # doctest: +SKIP\n    [2, 3]\n\n    Note that for a DatetimeIndex, it does not return a list but a new\n    DatetimeIndex:\n\n    >>> dates = pd.to_datetime(['2018-01-01', '2018-01-02', '2018-01-03',\n    ...                         '2018-01-03', '2018-01-04', '2018-01-04'],\n    ...                        format='%Y-%m-%d')\n    >>> pd.Index(dates).get_duplicates()  # doctest: +SKIP\n    DatetimeIndex(['2018-01-03', '2018-01-04'],\n                  dtype='datetime64[ns]', freq=None)\n\n    Sorts duplicated elements even when indexes are unordered.\n\n    >>> pd.Index([1, 2, 3, 2, 3, 4, 3]).get_duplicates()  # doctest: +SKIP\n    [2, 3]\n\n    Return empty array-like structure when all elements are unique.\n\n    >>> pd.Index([1, 2, 3, 4]).get_duplicates()  # doctest: +SKIP\n    []\n    >>> dates = pd.to_datetime(['2018-01-01', '2018-01-02', '2018-01-03'],\n    ...                        format='%Y-%m-%d')\n    >>> pd.Index(dates).get_duplicates()  # doctest: +SKIP\n    DatetimeIndex([], dtype='datetime64[ns]', freq=None)\n    \"\"\"\n    warnings.warn(\n        \"'get_duplicates' is deprecated and will be removed in \"\n        \"a future release. You can use \"\n        \"idx[idx.duplicated()].unique() instead\",\n        FutureWarning,\n        stacklevel=2,\n    )\n\n    return self[self.duplicated()].unique()",
                "def _get_unique_index(self, dropna=False):\n    \"\"\"\n    Returns an index containing unique values.\n\n    Parameters\n    ----------\n    dropna : bool\n        If True, NaN values are dropped.\n\n    Returns\n    -------\n    uniques : index\n    \"\"\"\n    if self.is_unique and not dropna:\n        return self\n\n    values = self.values\n\n    if not self.is_unique:\n        values = self.unique()\n\n    if dropna:\n        try:\n            if self.hasnans:\n                values = values[~isna(values)]\n        except NotImplementedError:\n            pass\n\n    return self._shallow_copy(values)",
                "def __add__(self, other):\n    if isinstance(other, (ABCSeries, ABCDataFrame)):\n        return NotImplemented\n    from pandas import Series\n\n    return Index(Series(self) + other)",
                "def __radd__(self, other):\n    from pandas import Series\n\n    return Index(other + Series(self))",
                "def __iadd__(self, other):\n    # alias for __add__\n    return self + other",
                "def __sub__(self, other):\n    return Index(np.array(self) - other)",
                "def __rsub__(self, other):\n    # wrap Series to ensure we pin name correctly\n    from pandas import Series\n\n    return Index(other - Series(self))",
                "def __and__(self, other):\n    return self.intersection(other)",
                "def __or__(self, other):\n    return self.union(other)",
                "def __xor__(self, other):\n    return self.symmetric_difference(other)",
                "def __nonzero__(self):\n    raise ValueError(\n        \"The truth value of a {0} is ambiguous. \"\n        \"Use a.empty, a.bool(), a.item(), a.any() or a.all().\".format(\n            self.__class__.__name__\n        )\n    )",
                "def _get_reconciled_name_object(self, other):\n    \"\"\"\n    If the result of a set operation will be self,\n    return self, unless the name changes, in which\n    case make a shallow copy of self.\n    \"\"\"\n    name = get_op_result_name(self, other)\n    if self.name != name:\n        return self._shallow_copy(name=name)\n    return self",
                "def _union_incompatible_dtypes(self, other, sort):\n    \"\"\"\n    Casts this and other index to object dtype to allow the formation\n    of a union between incompatible types.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : False or None, default False\n        Whether to sort the resulting index.\n\n        * False : do not sort the result.\n        * None : sort the result, except when `self` and `other` are equal\n          or when the values cannot be compared.\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    this = self.astype(object, copy=False)\n    # cast to Index for when `other` is list-like\n    other = Index(other).astype(object, copy=False)\n    return Index.union(this, other, sort=sort).astype(object, copy=False)",
                "def _is_compatible_with_other(self, other):\n    \"\"\"\n    Check whether this and the other dtype are compatible with each other.\n    Meaning a union can be formed between them without needing to be cast\n    to dtype object.\n\n    Parameters\n    ----------\n    other : Index or array-like\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    return type(self) is type(other) and is_dtype_equal(self.dtype, other.dtype)",
                "def _validate_sort_keyword(self, sort):\n    if sort not in [None, False]:\n        raise ValueError(\n            \"The 'sort' keyword only takes the values of \"\n            \"None or False; {0} was passed.\".format(sort)\n        )",
                "def union(self, other, sort=None):\n    \"\"\"\n    Form the union of two Index objects.\n\n    If the Index objects are incompatible, both Index objects will be\n    cast to dtype('object') first.\n\n        .. versionchanged:: 0.25.0\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : bool or None, default None\n        Whether to sort the resulting Index.\n\n        * None : Sort the result, except when\n\n          1. `self` and `other` are equal.\n          2. `self` or `other` has length 0.\n          3. Some values in `self` or `other` cannot be compared.\n             A RuntimeWarning is issued in this case.\n\n        * False : do not sort the result.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    union : Index\n\n    Examples\n    --------\n\n    Union matching dtypes\n\n    >>> idx1 = pd.Index([1, 2, 3, 4])\n    >>> idx2 = pd.Index([3, 4, 5, 6])\n    >>> idx1.union(idx2)\n    Int64Index([1, 2, 3, 4, 5, 6], dtype='int64')\n\n    Union mismatched dtypes\n\n    >>> idx1 = pd.Index(['a', 'b', 'c', 'd'])\n    >>> idx2 = pd.Index([1, 2, 3, 4])\n    >>> idx1.union(idx2)\n    Index(['a', 'b', 'c', 'd', 1, 2, 3, 4], dtype='object')\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n\n    if not self._is_compatible_with_other(other):\n        return self._union_incompatible_dtypes(other, sort=sort)\n\n    return self._union(other, sort=sort)",
                "def _union(self, other, sort):\n    \"\"\"\n    Specific union logic should go here. In subclasses, union behavior\n    should be overwritten here rather than in `self.union`.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : False or None, default False\n        Whether to sort the resulting index.\n\n        * False : do not sort the result.\n        * None : sort the result, except when `self` and `other` are equal\n          or when the values cannot be compared.\n\n    Returns\n    -------\n    Index\n    \"\"\"\n\n    if not len(other) or self.equals(other):\n        return self._get_reconciled_name_object(other)\n\n    if not len(self):\n        return other._get_reconciled_name_object(self)\n\n    # TODO(EA): setops-refactor, clean all this up\n    if is_period_dtype(self) or is_datetime64tz_dtype(self):\n        lvals = self._ndarray_values\n    else:\n        lvals = self._values\n    if is_period_dtype(other) or is_datetime64tz_dtype(other):\n        rvals = other._ndarray_values\n    else:\n        rvals = other._values\n\n    if sort is None and self.is_monotonic and other.is_monotonic:\n        try:\n            result = self._outer_indexer(lvals, rvals)[0]\n        except TypeError:\n            # incomparable objects\n            result = list(lvals)\n\n            # worth making this faster? a very unusual case\n            value_set = set(lvals)\n            result.extend([x for x in rvals if x not in value_set])\n    else:\n        indexer = self.get_indexer(other)\n        indexer, = (indexer == -1).nonzero()\n\n        if len(indexer) > 0:\n            other_diff = algos.take_nd(rvals, indexer, allow_fill=False)\n            result = concat_compat((lvals, other_diff))\n\n        else:\n            result = lvals\n\n        if sort is None:\n            try:\n                result = sorting.safe_sort(result)\n            except TypeError as e:\n                warnings.warn(\n                    \"{}, sort order is undefined for \"\n                    \"incomparable objects\".format(e),\n                    RuntimeWarning,\n                    stacklevel=3,\n                )\n\n    # for subclasses\n    return self._wrap_setop_result(other, result)",
                "def _wrap_setop_result(self, other, result):\n    return self._constructor(result, name=get_op_result_name(self, other))",
                "@Appender(_index_shared_docs[\"intersection\"])\ndef intersection(self, other, sort=False):\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other = ensure_index(other)\n\n    if self.equals(other):\n        return self._get_reconciled_name_object(other)\n\n    if not is_dtype_equal(self.dtype, other.dtype):\n        this = self.astype(\"O\")\n        other = other.astype(\"O\")\n        return this.intersection(other, sort=sort)\n\n    # TODO(EA): setops-refactor, clean all this up\n    if is_period_dtype(self):\n        lvals = self._ndarray_values\n    else:\n        lvals = self._values\n    if is_period_dtype(other):\n        rvals = other._ndarray_values\n    else:\n        rvals = other._values\n\n    if self.is_monotonic and other.is_monotonic:\n        try:\n            result = self._inner_indexer(lvals, rvals)[0]\n            return self._wrap_setop_result(other, result)\n        except TypeError:\n            pass\n\n    try:\n        indexer = Index(rvals).get_indexer(lvals)\n        indexer = indexer.take((indexer != -1).nonzero()[0])\n    except Exception:\n        # duplicates\n        indexer = algos.unique1d(Index(rvals).get_indexer_non_unique(lvals)[0])\n        indexer = indexer[indexer != -1]\n\n    taken = other.take(indexer)\n\n    if sort is None:\n        taken = sorting.safe_sort(taken.values)\n        if self.name != other.name:\n            name = None\n        else:\n            name = self.name\n        return self._shallow_copy(taken, name=name)\n\n    if self.name != other.name:\n        taken.name = None\n\n    return taken",
                "def difference(self, other, sort=None):\n    \"\"\"\n    Return a new Index with elements from the index that are not in\n    `other`.\n\n    This is the set difference of two Index objects.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : False or None, default None\n        Whether to sort the resulting index. By default, the\n        values are attempted to be sorted, but any TypeError from\n        incomparable elements is caught by pandas.\n\n        * None : Attempt to sort the result, but catch any TypeErrors\n          from comparing incomparable elements.\n        * False : Do not sort the result.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    difference : Index\n\n    Examples\n    --------\n\n    >>> idx1 = pd.Index([2, 1, 3, 4])\n    >>> idx2 = pd.Index([3, 4, 5, 6])\n    >>> idx1.difference(idx2)\n    Int64Index([1, 2], dtype='int64')\n    >>> idx1.difference(idx2, sort=False)\n    Int64Index([2, 1], dtype='int64')\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n\n    if self.equals(other):\n        # pass an empty np.ndarray with the appropriate dtype\n        return self._shallow_copy(self._data[:0])\n\n    other, result_name = self._convert_can_do_setop(other)\n\n    this = self._get_unique_index()\n\n    indexer = this.get_indexer(other)\n    indexer = indexer.take((indexer != -1).nonzero()[0])\n\n    label_diff = np.setdiff1d(np.arange(this.size), indexer, assume_unique=True)\n    the_diff = this.values.take(label_diff)\n    if sort is None:\n        try:\n            the_diff = sorting.safe_sort(the_diff)\n        except TypeError:\n            pass\n\n    return this._shallow_copy(the_diff, name=result_name, freq=None)",
                "def symmetric_difference(self, other, result_name=None, sort=None):\n    \"\"\"\n    Compute the symmetric difference of two Index objects.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    result_name : str\n    sort : False or None, default None\n        Whether to sort the resulting index. By default, the\n        values are attempted to be sorted, but any TypeError from\n        incomparable elements is caught by pandas.\n\n        * None : Attempt to sort the result, but catch any TypeErrors\n          from comparing incomparable elements.\n        * False : Do not sort the result.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    symmetric_difference : Index\n\n    Notes\n    -----\n    ``symmetric_difference`` contains elements that appear in either\n    ``idx1`` or ``idx2`` but not both. Equivalent to the Index created by\n    ``idx1.difference(idx2) | idx2.difference(idx1)`` with duplicates\n    dropped.\n\n    Examples\n    --------\n    >>> idx1 = pd.Index([1, 2, 3, 4])\n    >>> idx2 = pd.Index([2, 3, 4, 5])\n    >>> idx1.symmetric_difference(idx2)\n    Int64Index([1, 5], dtype='int64')\n\n    You can also use the ``^`` operator:\n\n    >>> idx1 ^ idx2\n    Int64Index([1, 5], dtype='int64')\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other, result_name_update = self._convert_can_do_setop(other)\n    if result_name is None:\n        result_name = result_name_update\n\n    this = self._get_unique_index()\n    other = other._get_unique_index()\n    indexer = this.get_indexer(other)\n\n    # {this} minus {other}\n    common_indexer = indexer.take((indexer != -1).nonzero()[0])\n    left_indexer = np.setdiff1d(\n        np.arange(this.size), common_indexer, assume_unique=True\n    )\n    left_diff = this.values.take(left_indexer)\n\n    # {other} minus {this}\n    right_indexer = (indexer == -1).nonzero()[0]\n    right_diff = other.values.take(right_indexer)\n\n    the_diff = concat_compat([left_diff, right_diff])\n    if sort is None:\n        try:\n            the_diff = sorting.safe_sort(the_diff)\n        except TypeError:\n            pass\n\n    attribs = self._get_attributes_dict()\n    attribs[\"name\"] = result_name\n    if \"freq\" in attribs:\n        attribs[\"freq\"] = None\n    return self._shallow_copy_with_infer(the_diff, **attribs)",
                "def _assert_can_do_setop(self, other):\n    if not is_list_like(other):\n        raise TypeError(\"Input must be Index or array-like\")\n    return True",
                "def _convert_can_do_setop(self, other):\n    if not isinstance(other, Index):\n        other = Index(other, name=self.name)\n        result_name = self.name\n    else:\n        result_name = get_op_result_name(self, other)\n    return other, result_name",
                "@Appender(_index_shared_docs[\"get_loc\"])\ndef get_loc(self, key, method=None, tolerance=None):\n    if method is None:\n        if tolerance is not None:\n            raise ValueError(\n                \"tolerance argument only valid if using pad, \"\n                \"backfill or nearest lookups\"\n            )\n        try:\n            return self._engine.get_loc(key)\n        except KeyError:\n            return self._engine.get_loc(self._maybe_cast_indexer(key))\n    indexer = self.get_indexer([key], method=method, tolerance=tolerance)\n    if indexer.ndim > 1 or indexer.size > 1:\n        raise TypeError(\"get_loc requires scalar valued input\")\n    loc = indexer.item()\n    if loc == -1:\n        raise KeyError(key)\n    return loc",
                "@Appender(_index_shared_docs[\"get_indexer\"] % _index_doc_kwargs)\ndef get_indexer(self, target, method=None, limit=None, tolerance=None):\n    method = missing.clean_reindex_fill_method(method)\n    target = ensure_index(target)\n    if tolerance is not None:\n        tolerance = self._convert_tolerance(tolerance, target)\n\n    # Treat boolean labels passed to a numeric index as not found. Without\n    # this fix False and True would be treated as 0 and 1 respectively.\n    # (GH #16877)\n    if target.is_boolean() and self.is_numeric():\n        return ensure_platform_int(np.repeat(-1, target.size))\n\n    pself, ptarget = self._maybe_promote(target)\n    if pself is not self or ptarget is not target:\n        return pself.get_indexer(\n            ptarget, method=method, limit=limit, tolerance=tolerance\n        )\n\n    if not is_dtype_equal(self.dtype, target.dtype):\n        this = self.astype(object)\n        target = target.astype(object)\n        return this.get_indexer(\n            target, method=method, limit=limit, tolerance=tolerance\n        )\n\n    if not self.is_unique:\n        raise InvalidIndexError(\n            \"Reindexing only valid with uniquely valued Index objects\"\n        )\n\n    if method == \"pad\" or method == \"backfill\":\n        indexer = self._get_fill_indexer(target, method, limit, tolerance)\n    elif method == \"nearest\":\n        indexer = self._get_nearest_indexer(target, limit, tolerance)\n    else:\n        if tolerance is not None:\n            raise ValueError(\n                \"tolerance argument only valid if doing pad, \"\n                \"backfill or nearest reindexing\"\n            )\n        if limit is not None:\n            raise ValueError(\n                \"limit argument only valid if doing pad, \"\n                \"backfill or nearest reindexing\"\n            )\n\n        indexer = self._engine.get_indexer(target._ndarray_values)\n\n    return ensure_platform_int(indexer)",
                "def _convert_tolerance(self, tolerance, target):\n    # override this method on subclasses\n    tolerance = np.asarray(tolerance)\n    if target.size != tolerance.size and tolerance.size > 1:\n        raise ValueError(\"list-like tolerance size must match target index size\")\n    return tolerance",
                "def _get_fill_indexer(self, target, method, limit=None, tolerance=None):\n    if self.is_monotonic_increasing and target.is_monotonic_increasing:\n        method = (\n            self._engine.get_pad_indexer\n            if method == \"pad\"\n            else self._engine.get_backfill_indexer\n        )\n        indexer = method(target._ndarray_values, limit)\n    else:\n        indexer = self._get_fill_indexer_searchsorted(target, method, limit)\n    if tolerance is not None:\n        indexer = self._filter_indexer_tolerance(\n            target._ndarray_values, indexer, tolerance\n        )\n    return indexer",
                "def _get_fill_indexer_searchsorted(self, target, method, limit=None):\n    \"\"\"\n    Fallback pad/backfill get_indexer that works for monotonic decreasing\n    indexes and non-monotonic targets.\n    \"\"\"\n    if limit is not None:\n        raise ValueError(\n            \"limit argument for %r method only well-defined \"\n            \"if index and target are monotonic\" % method\n        )\n\n    side = \"left\" if method == \"pad\" else \"right\"\n\n    # find exact matches first (this simplifies the algorithm)\n    indexer = self.get_indexer(target)\n    nonexact = indexer == -1\n    indexer[nonexact] = self._searchsorted_monotonic(target[nonexact], side)\n    if side == \"left\":\n        # searchsorted returns \"indices into a sorted array such that,\n        # if the corresponding elements in v were inserted before the\n        # indices, the order of a would be preserved\".\n        # Thus, we need to subtract 1 to find values to the left.\n        indexer[nonexact] -= 1\n        # This also mapped not found values (values of 0 from\n        # np.searchsorted) to -1, which conveniently is also our\n        # sentinel for missing values\n    else:\n        # Mark indices to the right of the largest value as not found\n        indexer[indexer == len(self)] = -1\n    return indexer",
                "def _get_nearest_indexer(self, target, limit, tolerance):\n    \"\"\"\n    Get the indexer for the nearest index labels; requires an index with\n    values that can be subtracted from each other (e.g., not strings or\n    tuples).\n    \"\"\"\n    left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n    right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n\n    target = np.asarray(target)\n    left_distances = abs(self.values[left_indexer] - target)\n    right_distances = abs(self.values[right_indexer] - target)\n\n    op = operator.lt if self.is_monotonic_increasing else operator.le\n    indexer = np.where(\n        op(left_distances, right_distances) | (right_indexer == -1),\n        left_indexer,\n        right_indexer,\n    )\n    if tolerance is not None:\n        indexer = self._filter_indexer_tolerance(target, indexer, tolerance)\n    return indexer",
                "def _filter_indexer_tolerance(self, target, indexer, tolerance):\n    distance = abs(self.values[indexer] - target)\n    indexer = np.where(distance <= tolerance, indexer, -1)\n    return indexer",
                "@Appender(_index_shared_docs[\"_convert_scalar_indexer\"])\ndef _convert_scalar_indexer(self, key, kind=None):\n    assert kind in [\"ix\", \"loc\", \"getitem\", \"iloc\", None]\n\n    if kind == \"iloc\":\n        return self._validate_indexer(\"positional\", key, kind)\n\n    if len(self) and not isinstance(self, ABCMultiIndex):\n\n        # we can raise here if we are definitive that this\n        # is positional indexing (eg. .ix on with a float)\n        # or label indexing if we are using a type able\n        # to be represented in the index\n\n        if kind in [\"getitem\", \"ix\"] and is_float(key):\n            if not self.is_floating():\n                return self._invalid_indexer(\"label\", key)\n\n        elif kind in [\"loc\"] and is_float(key):\n\n            # we want to raise KeyError on string/mixed here\n            # technically we *could* raise a TypeError\n            # on anything but mixed though\n            if self.inferred_type not in [\n                \"floating\",\n                \"mixed-integer-float\",\n                \"integer-na\",\n                \"string\",\n                \"unicode\",\n                \"mixed\",\n            ]:\n                return self._invalid_indexer(\"label\", key)\n\n        elif kind in [\"loc\"] and is_integer(key):\n            if not self.holds_integer():\n                return self._invalid_indexer(\"label\", key)\n\n    return key",
                "@Appender(_index_shared_docs[\"_convert_slice_indexer\"])\ndef _convert_slice_indexer(self, key: slice, kind=None):\n    assert kind in [\"ix\", \"loc\", \"getitem\", \"iloc\", None]\n\n    # validate iloc\n    if kind == \"iloc\":\n        return slice(\n            self._validate_indexer(\"slice\", key.start, kind),\n            self._validate_indexer(\"slice\", key.stop, kind),\n            self._validate_indexer(\"slice\", key.step, kind),\n        )\n\n    # potentially cast the bounds to integers\n    start, stop, step = key.start, key.stop, key.step\n\n    # figure out if this is a positional indexer\n    def is_int(v):\n        return v is None or is_integer(v)\n\n    is_null_slicer = start is None and stop is None\n    is_index_slice = is_int(start) and is_int(stop)\n    is_positional = is_index_slice and not self.is_integer()\n\n    if kind == \"getitem\":\n        \"\"\"\n        called from the getitem slicers, validate that we are in fact\n        integers\n        \"\"\"\n        if self.is_integer() or is_index_slice:\n            return slice(\n                self._validate_indexer(\"slice\", key.start, kind),\n                self._validate_indexer(\"slice\", key.stop, kind),\n                self._validate_indexer(\"slice\", key.step, kind),\n            )\n\n    # convert the slice to an indexer here\n\n    # if we are mixed and have integers\n    try:\n        if is_positional and self.is_mixed():\n            # Validate start & stop\n            if start is not None:\n                self.get_loc(start)\n            if stop is not None:\n                self.get_loc(stop)\n            is_positional = False\n    except KeyError:\n        if self.inferred_type in [\"mixed-integer-float\", \"integer-na\"]:\n            raise\n\n    if is_null_slicer:\n        indexer = key\n    elif is_positional:\n        indexer = key\n    else:\n        try:\n            indexer = self.slice_indexer(start, stop, step, kind=kind)\n        except Exception:\n            if is_index_slice:\n                if self.is_integer():\n                    raise\n                else:\n                    indexer = key\n            else:\n                raise\n\n    return indexer",
                "def _convert_listlike_indexer(self, keyarr, kind=None):\n    \"\"\"\n    Parameters\n    ----------\n    keyarr : list-like\n        Indexer to convert.\n\n    Returns\n    -------\n    indexer : numpy.ndarray or None\n        Return an ndarray or None if cannot convert.\n    keyarr : numpy.ndarray\n        Return tuple-safe keys.\n    \"\"\"\n    if isinstance(keyarr, Index):\n        keyarr = self._convert_index_indexer(keyarr)\n    else:\n        keyarr = self._convert_arr_indexer(keyarr)\n\n    indexer = self._convert_list_indexer(keyarr, kind=kind)\n    return indexer, keyarr",
                "@Appender(_index_shared_docs[\"_convert_arr_indexer\"])\ndef _convert_arr_indexer(self, keyarr):\n    keyarr = com.asarray_tuplesafe(keyarr)\n    return keyarr",
                "@Appender(_index_shared_docs[\"_convert_index_indexer\"])\ndef _convert_index_indexer(self, keyarr):\n    return keyarr",
                "@Appender(_index_shared_docs[\"_convert_list_indexer\"])\ndef _convert_list_indexer(self, keyarr, kind=None):\n    if (\n        kind in [None, \"iloc\", \"ix\"]\n        and is_integer_dtype(keyarr)\n        and not self.is_floating()\n        and not isinstance(keyarr, ABCPeriodIndex)\n    ):\n\n        if self.inferred_type == \"mixed-integer\":\n            indexer = self.get_indexer(keyarr)\n            if (indexer >= 0).all():\n                return indexer\n            # missing values are flagged as -1 by get_indexer and negative\n            # indices are already converted to positive indices in the\n            # above if-statement, so the negative flags are changed to\n            # values outside the range of indices so as to trigger an\n            # IndexError in maybe_convert_indices\n            indexer[indexer < 0] = len(self)\n\n            return maybe_convert_indices(indexer, len(self))\n\n        elif not self.inferred_type == \"integer\":\n            keyarr = np.where(keyarr < 0, len(self) + keyarr, keyarr)\n            return keyarr\n\n    return None",
                "def _invalid_indexer(self, form, key):\n    \"\"\"\n    Consistent invalid indexer message.\n    \"\"\"\n    raise TypeError(\n        \"cannot do {form} indexing on {klass} with these \"\n        \"indexers [{key}] of {kind}\".format(\n            form=form, klass=type(self), key=key, kind=type(key)\n        )\n    )",
                "def _can_reindex(self, indexer):\n    \"\"\"\n    Check if we are allowing reindexing with this particular indexer.\n\n    Parameters\n    ----------\n    indexer : an integer indexer\n\n    Raises\n    ------\n    ValueError if its a duplicate axis\n    \"\"\"\n\n    # trying to reindex on an axis with duplicates\n    if not self.is_unique and len(indexer):\n        raise ValueError(\"cannot reindex from a duplicate axis\")",
                "def reindex(self, target, method=None, level=None, limit=None, tolerance=None):\n    \"\"\"\n    Create index with target's values (move/add/delete values\n    as necessary).\n\n    Parameters\n    ----------\n    target : an iterable\n\n    Returns\n    -------\n    new_index : pd.Index\n        Resulting index.\n    indexer : np.ndarray or None\n        Indices of output values in original index.\n    \"\"\"\n    # GH6552: preserve names when reindexing to non-named target\n    # (i.e. neither Index nor Series).\n    preserve_names = not hasattr(target, \"name\")\n\n    # GH7774: preserve dtype/tz if target is empty and not an Index.\n    target = _ensure_has_len(target)  # target may be an iterator\n\n    if not isinstance(target, Index) and len(target) == 0:\n        attrs = self._get_attributes_dict()\n        attrs.pop(\"freq\", None)  # don't preserve freq\n        values = self._data[:0]  # appropriately-dtyped empty array\n        target = self._simple_new(values, dtype=self.dtype, **attrs)\n    else:\n        target = ensure_index(target)\n\n    if level is not None:\n        if method is not None:\n            raise TypeError(\"Fill method not supported if level passed\")\n        _, indexer, _ = self._join_level(\n            target, level, how=\"right\", return_indexers=True\n        )\n    else:\n        if self.equals(target):\n            indexer = None\n        else:\n            # check is_overlapping for IntervalIndex compat\n            if self.is_unique and not getattr(self, \"is_overlapping\", False):\n                indexer = self.get_indexer(\n                    target, method=method, limit=limit, tolerance=tolerance\n                )\n            else:\n                if method is not None or limit is not None:\n                    raise ValueError(\n                        \"cannot reindex a non-unique index \"\n                        \"with a method or limit\"\n                    )\n                indexer, missing = self.get_indexer_non_unique(target)\n\n    if preserve_names and target.nlevels == 1 and target.name != self.name:\n        target = target.copy()\n        target.name = self.name\n\n    return target, indexer",
                "def _reindex_non_unique(self, target):\n    \"\"\"\n    Create a new index with target's values (move/add/delete values as\n    necessary) use with non-unique Index and a possibly non-unique target.\n\n    Parameters\n    ----------\n    target : an iterable\n\n    Returns\n    -------\n    new_index : pd.Index\n        Resulting index.\n    indexer : np.ndarray or None\n        Indices of output values in original index.\n\n    \"\"\"\n\n    target = ensure_index(target)\n    indexer, missing = self.get_indexer_non_unique(target)\n    check = indexer != -1\n    new_labels = self.take(indexer[check])\n    new_indexer = None\n\n    if len(missing):\n        length = np.arange(len(indexer))\n\n        missing = ensure_platform_int(missing)\n        missing_labels = target.take(missing)\n        missing_indexer = ensure_int64(length[~check])\n        cur_labels = self.take(indexer[check]).values\n        cur_indexer = ensure_int64(length[check])\n\n        new_labels = np.empty(tuple([len(indexer)]), dtype=object)\n        new_labels[cur_indexer] = cur_labels\n        new_labels[missing_indexer] = missing_labels\n\n        # a unique indexer\n        if target.is_unique:\n\n            # see GH5553, make sure we use the right indexer\n            new_indexer = np.arange(len(indexer))\n            new_indexer[cur_indexer] = np.arange(len(cur_labels))\n            new_indexer[missing_indexer] = -1\n\n        # we have a non_unique selector, need to use the original\n        # indexer here\n        else:\n\n            # need to retake to have the same size as the indexer\n            indexer[~check] = -1\n\n            # reset the new indexer to account for the new size\n            new_indexer = np.arange(len(self.take(indexer)))\n            new_indexer[~check] = -1\n\n    new_index = self._shallow_copy_with_infer(new_labels, freq=None)\n    return new_index, indexer, new_indexer",
                "@Appender(_index_shared_docs[\"join\"])\ndef join(self, other, how=\"left\", level=None, return_indexers=False, sort=False):\n    self_is_mi = isinstance(self, ABCMultiIndex)\n    other_is_mi = isinstance(other, ABCMultiIndex)\n\n    # try to figure out the join level\n    # GH3662\n    if level is None and (self_is_mi or other_is_mi):\n\n        # have the same levels/names so a simple join\n        if self.names == other.names:\n            pass\n        else:\n            return self._join_multi(other, how=how, return_indexers=return_indexers)\n\n    # join on the level\n    if level is not None and (self_is_mi or other_is_mi):\n        return self._join_level(\n            other, level, how=how, return_indexers=return_indexers\n        )\n\n    other = ensure_index(other)\n\n    if len(other) == 0 and how in (\"left\", \"outer\"):\n        join_index = self._shallow_copy()\n        if return_indexers:\n            rindexer = np.repeat(-1, len(join_index))\n            return join_index, None, rindexer\n        else:\n            return join_index\n\n    if len(self) == 0 and how in (\"right\", \"outer\"):\n        join_index = other._shallow_copy()\n        if return_indexers:\n            lindexer = np.repeat(-1, len(join_index))\n            return join_index, lindexer, None\n        else:\n            return join_index\n\n    if self._join_precedence < other._join_precedence:\n        how = {\"right\": \"left\", \"left\": \"right\"}.get(how, how)\n        result = other.join(\n            self, how=how, level=level, return_indexers=return_indexers\n        )\n        if return_indexers:\n            x, y, z = result\n            result = x, z, y\n        return result\n\n    if not is_dtype_equal(self.dtype, other.dtype):\n        this = self.astype(\"O\")\n        other = other.astype(\"O\")\n        return this.join(other, how=how, return_indexers=return_indexers)\n\n    _validate_join_method(how)\n\n    if not self.is_unique and not other.is_unique:\n        return self._join_non_unique(\n            other, how=how, return_indexers=return_indexers\n        )\n    elif not self.is_unique or not other.is_unique:\n        if self.is_monotonic and other.is_monotonic:\n            return self._join_monotonic(\n                other, how=how, return_indexers=return_indexers\n            )\n        else:\n            return self._join_non_unique(\n                other, how=how, return_indexers=return_indexers\n            )\n    elif self.is_monotonic and other.is_monotonic:\n        try:\n            return self._join_monotonic(\n                other, how=how, return_indexers=return_indexers\n            )\n        except TypeError:\n            pass\n\n    if how == \"left\":\n        join_index = self\n    elif how == \"right\":\n        join_index = other\n    elif how == \"inner\":\n        # TODO: sort=False here for backwards compat. It may\n        # be better to use the sort parameter passed into join\n        join_index = self.intersection(other, sort=False)\n    elif how == \"outer\":\n        # TODO: sort=True here for backwards compat. It may\n        # be better to use the sort parameter passed into join\n        join_index = self.union(other)\n\n    if sort:\n        join_index = join_index.sort_values()\n\n    if return_indexers:\n        if join_index is self:\n            lindexer = None\n        else:\n            lindexer = self.get_indexer(join_index)\n        if join_index is other:\n            rindexer = None\n        else:\n            rindexer = other.get_indexer(join_index)\n        return join_index, lindexer, rindexer\n    else:\n        return join_index",
                "def _join_multi(self, other, how, return_indexers=True):\n    from .multi import MultiIndex\n    from pandas.core.reshape.merge import _restore_dropped_levels_multijoin\n\n    # figure out join names\n    self_names = set(com.not_none(*self.names))\n    other_names = set(com.not_none(*other.names))\n    overlap = self_names & other_names\n\n    # need at least 1 in common\n    if not overlap:\n        raise ValueError(\"cannot join with no overlapping index names\")\n\n    self_is_mi = isinstance(self, MultiIndex)\n    other_is_mi = isinstance(other, MultiIndex)\n\n    if self_is_mi and other_is_mi:\n\n        # Drop the non-matching levels from left and right respectively\n        ldrop_names = list(self_names - overlap)\n        rdrop_names = list(other_names - overlap)\n\n        self_jnlevels = self.droplevel(ldrop_names)\n        other_jnlevels = other.droplevel(rdrop_names)\n\n        # Join left and right\n        # Join on same leveled multi-index frames is supported\n        join_idx, lidx, ridx = self_jnlevels.join(\n            other_jnlevels, how, return_indexers=True\n        )\n\n        # Restore the dropped levels\n        # Returned index level order is\n        # common levels, ldrop_names, rdrop_names\n        dropped_names = ldrop_names + rdrop_names\n\n        levels, codes, names = _restore_dropped_levels_multijoin(\n            self, other, dropped_names, join_idx, lidx, ridx\n        )\n\n        # Re-create the multi-index\n        multi_join_idx = MultiIndex(\n            levels=levels, codes=codes, names=names, verify_integrity=False\n        )\n\n        multi_join_idx = multi_join_idx.remove_unused_levels()\n\n        return multi_join_idx, lidx, ridx\n\n    jl = list(overlap)[0]\n\n    # Case where only one index is multi\n    # make the indices into mi's that match\n    flip_order = False\n    if self_is_mi:\n        self, other = other, self\n        flip_order = True\n        # flip if join method is right or left\n        how = {\"right\": \"left\", \"left\": \"right\"}.get(how, how)\n\n    level = other.names.index(jl)\n    result = self._join_level(\n        other, level, how=how, return_indexers=return_indexers\n    )\n\n    if flip_order:\n        if isinstance(result, tuple):\n            return result[0], result[2], result[1]\n    return result",
                "def _join_non_unique(self, other, how=\"left\", return_indexers=False):\n    from pandas.core.reshape.merge import _get_join_indexers\n\n    left_idx, right_idx = _get_join_indexers(\n        [self._ndarray_values], [other._ndarray_values], how=how, sort=True\n    )\n\n    left_idx = ensure_platform_int(left_idx)\n    right_idx = ensure_platform_int(right_idx)\n\n    join_index = np.asarray(self._ndarray_values.take(left_idx))\n    mask = left_idx == -1\n    np.putmask(join_index, mask, other._ndarray_values.take(right_idx))\n\n    join_index = self._wrap_joined_index(join_index, other)\n\n    if return_indexers:\n        return join_index, left_idx, right_idx\n    else:\n        return join_index",
                "def _join_level(\n    self, other, level, how=\"left\", return_indexers=False, keep_order=True\n):\n    \"\"\"\n    The join method *only* affects the level of the resulting\n    MultiIndex. Otherwise it just exactly aligns the Index data to the\n    labels of the level in the MultiIndex.\n\n    If ```keep_order == True```, the order of the data indexed by the\n    MultiIndex will not be changed; otherwise, it will tie out\n    with `other`.\n    \"\"\"\n    from .multi import MultiIndex\n\n    def _get_leaf_sorter(labels):\n        \"\"\"\n        Returns sorter for the inner most level while preserving the\n        order of higher levels.\n        \"\"\"\n        if labels[0].size == 0:\n            return np.empty(0, dtype=\"int64\")\n\n        if len(labels) == 1:\n            lab = ensure_int64(labels[0])\n            sorter, _ = libalgos.groupsort_indexer(lab, 1 + lab.max())\n            return sorter\n\n        # find indexers of beginning of each set of\n        # same-key labels w.r.t all but last level\n        tic = labels[0][:-1] != labels[0][1:]\n        for lab in labels[1:-1]:\n            tic |= lab[:-1] != lab[1:]\n\n        starts = np.hstack(([True], tic, [True])).nonzero()[0]\n        lab = ensure_int64(labels[-1])\n        return lib.get_level_sorter(lab, ensure_int64(starts))\n\n    if isinstance(self, MultiIndex) and isinstance(other, MultiIndex):\n        raise TypeError(\"Join on level between two MultiIndex objects is ambiguous\")\n\n    left, right = self, other\n\n    flip_order = not isinstance(self, MultiIndex)\n    if flip_order:\n        left, right = right, left\n        how = {\"right\": \"left\", \"left\": \"right\"}.get(how, how)\n\n    level = left._get_level_number(level)\n    old_level = left.levels[level]\n\n    if not right.is_unique:\n        raise NotImplementedError(\n            \"Index._join_level on non-unique index is not implemented\"\n        )\n\n    new_level, left_lev_indexer, right_lev_indexer = old_level.join(\n        right, how=how, return_indexers=True\n    )\n\n    if left_lev_indexer is None:\n        if keep_order or len(left) == 0:\n            left_indexer = None\n            join_index = left\n        else:  # sort the leaves\n            left_indexer = _get_leaf_sorter(left.codes[: level + 1])\n            join_index = left[left_indexer]\n\n    else:\n        left_lev_indexer = ensure_int64(left_lev_indexer)\n        rev_indexer = lib.get_reverse_indexer(left_lev_indexer, len(old_level))\n\n        new_lev_codes = algos.take_nd(\n            rev_indexer, left.codes[level], allow_fill=False\n        )\n\n        new_codes = list(left.codes)\n        new_codes[level] = new_lev_codes\n\n        new_levels = list(left.levels)\n        new_levels[level] = new_level\n\n        if keep_order:  # just drop missing values. o.w. keep order\n            left_indexer = np.arange(len(left), dtype=np.intp)\n            mask = new_lev_codes != -1\n            if not mask.all():\n                new_codes = [lab[mask] for lab in new_codes]\n                left_indexer = left_indexer[mask]\n\n        else:  # tie out the order with other\n            if level == 0:  # outer most level, take the fast route\n                ngroups = 1 + new_lev_codes.max()\n                left_indexer, counts = libalgos.groupsort_indexer(\n                    new_lev_codes, ngroups\n                )\n\n                # missing values are placed first; drop them!\n                left_indexer = left_indexer[counts[0] :]\n                new_codes = [lab[left_indexer] for lab in new_codes]\n\n            else:  # sort the leaves\n                mask = new_lev_codes != -1\n                mask_all = mask.all()\n                if not mask_all:\n                    new_codes = [lab[mask] for lab in new_codes]\n\n                left_indexer = _get_leaf_sorter(new_codes[: level + 1])\n                new_codes = [lab[left_indexer] for lab in new_codes]\n\n                # left_indexers are w.r.t masked frame.\n                # reverse to original frame!\n                if not mask_all:\n                    left_indexer = mask.nonzero()[0][left_indexer]\n\n        join_index = MultiIndex(\n            levels=new_levels,\n            codes=new_codes,\n            names=left.names,\n            verify_integrity=False,\n        )\n\n    if right_lev_indexer is not None:\n        right_indexer = algos.take_nd(\n            right_lev_indexer, join_index.codes[level], allow_fill=False\n        )\n    else:\n        right_indexer = join_index.codes[level]\n\n    if flip_order:\n        left_indexer, right_indexer = right_indexer, left_indexer\n\n    if return_indexers:\n        left_indexer = (\n            None if left_indexer is None else ensure_platform_int(left_indexer)\n        )\n        right_indexer = (\n            None if right_indexer is None else ensure_platform_int(right_indexer)\n        )\n        return join_index, left_indexer, right_indexer\n    else:\n        return join_index",
                "def _join_monotonic(self, other, how=\"left\", return_indexers=False):\n    if self.equals(other):\n        ret_index = other if how == \"right\" else self\n        if return_indexers:\n            return ret_index, None, None\n        else:\n            return ret_index\n\n    sv = self._ndarray_values\n    ov = other._ndarray_values\n\n    if self.is_unique and other.is_unique:\n        # We can perform much better than the general case\n        if how == \"left\":\n            join_index = self\n            lidx = None\n            ridx = self._left_indexer_unique(sv, ov)\n        elif how == \"right\":\n            join_index = other\n            lidx = self._left_indexer_unique(ov, sv)\n            ridx = None\n        elif how == \"inner\":\n            join_index, lidx, ridx = self._inner_indexer(sv, ov)\n            join_index = self._wrap_joined_index(join_index, other)\n        elif how == \"outer\":\n            join_index, lidx, ridx = self._outer_indexer(sv, ov)\n            join_index = self._wrap_joined_index(join_index, other)\n    else:\n        if how == \"left\":\n            join_index, lidx, ridx = self._left_indexer(sv, ov)\n        elif how == \"right\":\n            join_index, ridx, lidx = self._left_indexer(ov, sv)\n        elif how == \"inner\":\n            join_index, lidx, ridx = self._inner_indexer(sv, ov)\n        elif how == \"outer\":\n            join_index, lidx, ridx = self._outer_indexer(sv, ov)\n        join_index = self._wrap_joined_index(join_index, other)\n\n    if return_indexers:\n        lidx = None if lidx is None else ensure_platform_int(lidx)\n        ridx = None if ridx is None else ensure_platform_int(ridx)\n        return join_index, lidx, ridx\n    else:\n        return join_index",
                "def _wrap_joined_index(self, joined, other):\n    name = get_op_result_name(self, other)\n    return Index(joined, name=name)",
                "@property\ndef values(self):\n    \"\"\"\n    Return an array representing the data in the Index.\n\n    .. warning::\n\n       We recommend using :attr:`Index.array` or\n       :meth:`Index.to_numpy`, depending on whether you need\n       a reference to the underlying data or a NumPy array.\n\n    Returns\n    -------\n    array: numpy.ndarray or ExtensionArray\n\n    See Also\n    --------\n    Index.array : Reference to the underlying data.\n    Index.to_numpy : A NumPy array representing the underlying data.\n    \"\"\"\n    return self._data.view(np.ndarray)",
                "@property\ndef _values(self) -> Union[ExtensionArray, ABCIndexClass, np.ndarray]:\n    # TODO(EA): remove index types as they become extension arrays\n    \"\"\"\n    The best array representation.\n\n    This is an ndarray, ExtensionArray, or Index subclass. This differs\n    from ``_ndarray_values``, which always returns an ndarray.\n\n    Both ``_values`` and ``_ndarray_values`` are consistent between\n    ``Series`` and ``Index``.\n\n    It may differ from the public '.values' method.\n\n    index             | values          | _values       | _ndarray_values |\n    ----------------- | --------------- | ------------- | --------------- |\n    Index             | ndarray         | ndarray       | ndarray         |\n    CategoricalIndex  | Categorical     | Categorical   | ndarray[int]    |\n    DatetimeIndex     | ndarray[M8ns]   | ndarray[M8ns] | ndarray[M8ns]   |\n    DatetimeIndex[tz] | ndarray[M8ns]   | DTI[tz]       | ndarray[M8ns]   |\n    PeriodIndex       | ndarray[object] | PeriodArray   | ndarray[int]    |\n    IntervalIndex     | IntervalArray   | IntervalArray | ndarray[object] |\n\n    See Also\n    --------\n    values\n    _ndarray_values\n    \"\"\"\n    return self._data",
                "def get_values(self):\n    \"\"\"\n    Return `Index` data as an `numpy.ndarray`.\n\n    .. deprecated:: 0.25.0\n        Use :meth:`Index.to_numpy` or :attr:`Index.array` instead.\n\n    Returns\n    -------\n    numpy.ndarray\n        A one-dimensional numpy array of the `Index` values.\n\n    See Also\n    --------\n    Index.values : The attribute that get_values wraps.\n\n    Examples\n    --------\n    Getting the `Index` values of a `DataFrame`:\n\n    >>> df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n    ...                    index=['a', 'b', 'c'], columns=['A', 'B', 'C'])\n    >>> df\n       A  B  C\n    a  1  2  3\n    b  4  5  6\n    c  7  8  9\n    >>> df.index.get_values()\n    array(['a', 'b', 'c'], dtype=object)\n\n    Standalone `Index` values:\n\n    >>> idx = pd.Index(['1', '2', '3'])\n    >>> idx.get_values()\n    array(['1', '2', '3'], dtype=object)\n\n    `MultiIndex` arrays also have only one dimension:\n\n    >>> midx = pd.MultiIndex.from_arrays([[1, 2, 3], ['a', 'b', 'c']],\n    ...                                  names=('number', 'letter'))\n    >>> midx.get_values()\n    array([(1, 'a'), (2, 'b'), (3, 'c')], dtype=object)\n    >>> midx.get_values().ndim\n    1\n    \"\"\"\n    warnings.warn(\n        \"The 'get_values' method is deprecated and will be removed in a \"\n        \"future version. Use '.to_numpy()' or '.array' instead.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n    return self._internal_get_values()",
                "def _internal_get_values(self):\n    return self.values",
                "@Appender(IndexOpsMixin.memory_usage.__doc__)\ndef memory_usage(self, deep=False):\n    result = super().memory_usage(deep=deep)\n\n    # include our engine hashtable\n    result += self._engine.sizeof(deep=deep)\n    return result",
                "@Appender(_index_shared_docs[\"where\"])\ndef where(self, cond, other=None):\n    if other is None:\n        other = self._na_value\n\n    dtype = self.dtype\n    values = self.values\n\n    if is_bool(other) or is_bool_dtype(other):\n\n        # bools force casting\n        values = values.astype(object)\n        dtype = None\n\n    values = np.where(cond, values, other)\n\n    if self._is_numeric_dtype and np.any(isna(values)):\n        # We can't coerce to the numeric dtype of \"self\" (unless\n        # it's float) if there are NaN values in our output.\n        dtype = None\n\n    return self._shallow_copy_with_infer(values, dtype=dtype)",
                "@classmethod\ndef _try_convert_to_int_index(cls, data, copy, name, dtype):\n    \"\"\"\n    Attempt to convert an array of data into an integer index.\n\n    Parameters\n    ----------\n    data : The data to convert.\n    copy : Whether to copy the data or not.\n    name : The name of the index returned.\n\n    Returns\n    -------\n    int_index : data converted to either an Int64Index or a\n                UInt64Index\n\n    Raises\n    ------\n    ValueError if the conversion was not successful.\n    \"\"\"\n\n    from .numeric import Int64Index, UInt64Index\n\n    if not is_unsigned_integer_dtype(dtype):\n        # skip int64 conversion attempt if uint-like dtype is passed, as\n        # this could return Int64Index when UInt64Index is what's desired\n        try:\n            res = data.astype(\"i8\", copy=False)\n            if (res == data).all():\n                return Int64Index(res, copy=copy, name=name)\n        except (OverflowError, TypeError, ValueError):\n            pass\n\n    # Conversion to int64 failed (possibly due to overflow) or was skipped,\n    # so let's try now with uint64.\n    try:\n        res = data.astype(\"u8\", copy=False)\n        if (res == data).all():\n            return UInt64Index(res, copy=copy, name=name)\n    except (OverflowError, TypeError, ValueError):\n        pass\n\n    raise ValueError",
                "@classmethod\ndef _scalar_data_error(cls, data):\n    # We return the TypeError so that we can raise it from the constructor\n    #  in order to keep mypy happy\n    return TypeError(\n        \"{0}(...) must be called with a collection of some \"\n        \"kind, {1} was passed\".format(cls.__name__, repr(data))\n    )",
                "@classmethod\ndef _string_data_error(cls, data):\n    raise TypeError(\n        \"String dtype not supported, you may need \"\n        \"to explicitly cast to a numeric type\"\n    )",
                "@classmethod\ndef _coerce_to_ndarray(cls, data):\n    \"\"\"\n    Coerces data to ndarray.\n\n    Converts other iterables to list first and then to array.\n    Does not touch ndarrays.\n\n    Raises\n    ------\n    TypeError\n        When the data passed in is a scalar.\n    \"\"\"\n\n    if not isinstance(data, (np.ndarray, Index)):\n        if data is None or is_scalar(data):\n            raise cls._scalar_data_error(data)\n\n        # other iterable of some kind\n        if not isinstance(data, (ABCSeries, list, tuple)):\n            data = list(data)\n        data = np.asarray(data)\n    return data",
                "def _coerce_scalar_to_index(self, item):\n    \"\"\"\n    We need to coerce a scalar to a compat for our index type.\n\n    Parameters\n    ----------\n    item : scalar item to coerce\n    \"\"\"\n    dtype = self.dtype\n\n    if self._is_numeric_dtype and isna(item):\n        # We can't coerce to the numeric dtype of \"self\" (unless\n        # it's float) if there are NaN values in our output.\n        dtype = None\n\n    return Index([item], dtype=dtype, **self._get_attributes_dict())",
                "def _to_safe_for_reshape(self):\n    \"\"\"\n    Convert to object if we are a categorical.\n    \"\"\"\n    return self",
                "def _convert_for_op(self, value):\n    \"\"\"\n    Convert value to be insertable to ndarray.\n    \"\"\"\n    return value",
                "def _assert_can_do_op(self, value):\n    \"\"\"\n    Check value is valid for scalar op.\n    \"\"\"\n    if not is_scalar(value):\n        msg = \"'value' must be a scalar, passed: {0}\"\n        raise TypeError(msg.format(type(value).__name__))",
                "@property\ndef _has_complex_internals(self):\n    # to disable groupby tricks in MultiIndex\n    return False",
                "def _is_memory_usage_qualified(self):\n    \"\"\"\n    Return a boolean if we need a qualified .info display.\n    \"\"\"\n    return self.is_object()",
                "def is_type_compatible(self, kind):\n    \"\"\"\n    Whether the index type is compatible with the provided type.\n    \"\"\"\n    return kind == self.inferred_type",
                "@Appender(_index_shared_docs[\"contains\"] % _index_doc_kwargs)\ndef __contains__(self, key):\n    hash(key)\n    try:\n        return key in self._engine\n    except (OverflowError, TypeError, ValueError):\n        return False",
                "def contains(self, key):\n    \"\"\"\n    Return a boolean indicating whether the provided key is in the index.\n\n    .. deprecated:: 0.25.0\n        Use ``key in index`` instead of ``index.contains(key)``.\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    warnings.warn(\n        \"The 'contains' method is deprecated and will be removed in a \"\n        \"future version. Use 'key in index' instead of \"\n        \"'index.contains(key)'\",\n        FutureWarning,\n        stacklevel=2,\n    )\n    return key in self",
                "def __hash__(self):\n    raise TypeError(\"unhashable type: %r\" % type(self).__name__)",
                "def __setitem__(self, key, value):\n    raise TypeError(\"Index does not support mutable operations\")",
                "def __getitem__(self, key):\n    \"\"\"\n    Override numpy.ndarray's __getitem__ method to work as desired.\n\n    This function adds lists and Series as valid boolean indexers\n    (ndarrays only supports ndarray with dtype=bool).\n\n    If resulting ndim != 1, plain ndarray is returned instead of\n    corresponding `Index` subclass.\n\n    \"\"\"\n    # There's no custom logic to be implemented in __getslice__, so it's\n    # not overloaded intentionally.\n    getitem = self._data.__getitem__\n    promote = self._shallow_copy\n\n    if is_scalar(key):\n        key = com.cast_scalar_indexer(key)\n        return getitem(key)\n\n    if isinstance(key, slice):\n        # This case is separated from the conditional above to avoid\n        # pessimization of basic indexing.\n        return promote(getitem(key))\n\n    if com.is_bool_indexer(key):\n        key = np.asarray(key, dtype=bool)\n\n    key = com.values_from_object(key)\n    result = getitem(key)\n    if not is_scalar(result):\n        return promote(result)\n    else:\n        return result",
                "def _can_hold_identifiers_and_holds_name(self, name):\n    \"\"\"\n    Faster check for ``name in self`` when we know `name` is a Python\n    identifier (e.g. in NDFrame.__getattr__, which hits this to support\n    . key lookup). For indexes that can't hold identifiers (everything\n    but object & categorical) we just return False.\n\n    https://github.com/pandas-dev/pandas/issues/19764\n    \"\"\"\n    if self.is_object() or self.is_categorical():\n        return name in self\n    return False",
                "def append(self, other):\n    \"\"\"\n    Append a collection of Index options together.\n\n    Parameters\n    ----------\n    other : Index or list/tuple of indices\n\n    Returns\n    -------\n    appended : Index\n    \"\"\"\n\n    to_concat = [self]\n\n    if isinstance(other, (list, tuple)):\n        to_concat = to_concat + list(other)\n    else:\n        to_concat.append(other)\n\n    for obj in to_concat:\n        if not isinstance(obj, Index):\n            raise TypeError(\"all inputs must be Index\")\n\n    names = {obj.name for obj in to_concat}\n    name = None if len(names) > 1 else self.name\n\n    return self._concat(to_concat, name)",
                "def _concat(self, to_concat, name):\n\n    typs = _concat.get_dtype_kinds(to_concat)\n\n    if len(typs) == 1:\n        return self._concat_same_dtype(to_concat, name=name)\n    return Index._concat_same_dtype(self, to_concat, name=name)",
                "def _concat_same_dtype(self, to_concat, name):\n    \"\"\"\n    Concatenate to_concat which has the same class.\n    \"\"\"\n    # must be overridden in specific classes\n    klasses = (ABCDatetimeIndex, ABCTimedeltaIndex, ABCPeriodIndex, ExtensionArray)\n    to_concat = [\n        x.astype(object) if isinstance(x, klasses) else x for x in to_concat\n    ]\n\n    self = to_concat[0]\n    attribs = self._get_attributes_dict()\n    attribs[\"name\"] = name\n\n    to_concat = [x._values if isinstance(x, Index) else x for x in to_concat]\n\n    return self._shallow_copy_with_infer(np.concatenate(to_concat), **attribs)",
                "def putmask(self, mask, value):\n    \"\"\"\n    Return a new Index of the values set with the mask.\n\n    Returns\n    -------\n    Index\n\n    See Also\n    --------\n    numpy.ndarray.putmask\n    \"\"\"\n    values = self.values.copy()\n    try:\n        np.putmask(values, mask, self._convert_for_op(value))\n        return self._shallow_copy(values)\n    except (ValueError, TypeError) as err:\n        if is_object_dtype(self):\n            raise err\n\n        # coerces to object\n        return self.astype(object).putmask(mask, value)",
                "def equals(self, other):\n    \"\"\"\n    Determine if two Index objects contain the same elements.\n\n    Returns\n    -------\n    bool\n        True if \"other\" is an Index and it has the same elements as calling\n        index; False otherwise.\n    \"\"\"\n    if self.is_(other):\n        return True\n\n    if not isinstance(other, Index):\n        return False\n\n    if is_object_dtype(self) and not is_object_dtype(other):\n        # if other is not object, use other's logic for coercion\n        return other.equals(self)\n\n    try:\n        return array_equivalent(\n            com.values_from_object(self), com.values_from_object(other)\n        )\n    except Exception:\n        return False",
                "def identical(self, other):\n    \"\"\"\n    Similar to equals, but check that other comparable attributes are\n    also equal.\n\n    Returns\n    -------\n    bool\n        If two Index objects have equal elements and same type True,\n        otherwise False.\n    \"\"\"\n    return (\n        self.equals(other)\n        and all(\n            (\n                getattr(self, c, None) == getattr(other, c, None)\n                for c in self._comparables\n            )\n        )\n        and type(self) == type(other)\n    )",
                "def asof(self, label):\n    \"\"\"\n    Return the label from the index, or, if not present, the previous one.\n\n    Assuming that the index is sorted, return the passed index label if it\n    is in the index, or return the previous index label if the passed one\n    is not in the index.\n\n    Parameters\n    ----------\n    label : object\n        The label up to which the method returns the latest index label.\n\n    Returns\n    -------\n    object\n        The passed label if it is in the index. The previous label if the\n        passed label is not in the sorted index or `NaN` if there is no\n        such label.\n\n    See Also\n    --------\n    Series.asof : Return the latest value in a Series up to the\n        passed index.\n    merge_asof : Perform an asof merge (similar to left join but it\n        matches on nearest key rather than equal key).\n    Index.get_loc : An `asof` is a thin wrapper around `get_loc`\n        with method='pad'.\n\n    Examples\n    --------\n    `Index.asof` returns the latest index label up to the passed label.\n\n    >>> idx = pd.Index(['2013-12-31', '2014-01-02', '2014-01-03'])\n    >>> idx.asof('2014-01-01')\n    '2013-12-31'\n\n    If the label is in the index, the method returns the passed label.\n\n    >>> idx.asof('2014-01-02')\n    '2014-01-02'\n\n    If all of the labels in the index are later than the passed label,\n    NaN is returned.\n\n    >>> idx.asof('1999-01-02')\n    nan\n\n    If the index is not sorted, an error is raised.\n\n    >>> idx_not_sorted = pd.Index(['2013-12-31', '2015-01-02',\n    ...                            '2014-01-03'])\n    >>> idx_not_sorted.asof('2013-12-31')\n    Traceback (most recent call last):\n    ValueError: index must be monotonic increasing or decreasing\n    \"\"\"\n    try:\n        loc = self.get_loc(label, method=\"pad\")\n    except KeyError:\n        return self._na_value\n    else:\n        if isinstance(loc, slice):\n            loc = loc.indices(len(self))[-1]\n        return self[loc]",
                "def asof_locs(self, where, mask):\n    \"\"\"\n    Find the locations (indices) of the labels from the index for\n    every entry in the `where` argument.\n\n    As in the `asof` function, if the label (a particular entry in\n    `where`) is not in the index, the latest index label upto the\n    passed label is chosen and its index returned.\n\n    If all of the labels in the index are later than a label in `where`,\n    -1 is returned.\n\n    `mask` is used to ignore NA values in the index during calculation.\n\n    Parameters\n    ----------\n    where : Index\n        An Index consisting of an array of timestamps.\n    mask : array-like\n        Array of booleans denoting where values in the original\n        data are not NA.\n\n    Returns\n    -------\n    numpy.ndarray\n        An array of locations (indices) of the labels from the Index\n        which correspond to the return values of the `asof` function\n        for every element in `where`.\n    \"\"\"\n    locs = self.values[mask].searchsorted(where.values, side=\"right\")\n    locs = np.where(locs > 0, locs - 1, 0)\n\n    result = np.arange(len(self))[mask].take(locs)\n\n    first = mask.argmax()\n    result[(locs == 0) & (where.values < self.values[first])] = -1\n\n    return result",
                "def sort_values(self, return_indexer=False, ascending=True):\n    \"\"\"\n    Return a sorted copy of the index.\n\n    Return a sorted copy of the index, and optionally return the indices\n    that sorted the index itself.\n\n    Parameters\n    ----------\n    return_indexer : bool, default False\n        Should the indices that would sort the index be returned.\n    ascending : bool, default True\n        Should the index values be sorted in an ascending order.\n\n    Returns\n    -------\n    sorted_index : pandas.Index\n        Sorted copy of the index.\n    indexer : numpy.ndarray, optional\n        The indices that the index itself was sorted by.\n\n    See Also\n    --------\n    Series.sort_values : Sort values of a Series.\n    DataFrame.sort_values : Sort values in a DataFrame.\n\n    Examples\n    --------\n    >>> idx = pd.Index([10, 100, 1, 1000])\n    >>> idx\n    Int64Index([10, 100, 1, 1000], dtype='int64')\n\n    Sort values in ascending order (default behavior).\n\n    >>> idx.sort_values()\n    Int64Index([1, 10, 100, 1000], dtype='int64')\n\n    Sort values in descending order, and also get the indices `idx` was\n    sorted by.\n\n    >>> idx.sort_values(ascending=False, return_indexer=True)\n    (Int64Index([1000, 100, 10, 1], dtype='int64'), array([3, 1, 0, 2]))\n    \"\"\"\n    _as = self.argsort()\n    if not ascending:\n        _as = _as[::-1]\n\n    sorted_index = self.take(_as)\n\n    if return_indexer:\n        return sorted_index, _as\n    else:\n        return sorted_index",
                "def sort(self, *args, **kwargs):\n    \"\"\"\n    Use sort_values instead.\n    \"\"\"\n    raise TypeError(\"cannot sort an Index object in-place, use sort_values instead\")",
                "def shift(self, periods=1, freq=None):\n    \"\"\"\n    Shift index by desired number of time frequency increments.\n\n    This method is for shifting the values of datetime-like indexes\n    by a specified time increment a given number of times.\n\n    Parameters\n    ----------\n    periods : int, default 1\n        Number of periods (or increments) to shift by,\n        can be positive or negative.\n    freq : pandas.DateOffset, pandas.Timedelta or string, optional\n        Frequency increment to shift by.\n        If None, the index is shifted by its own `freq` attribute.\n        Offset aliases are valid strings, e.g., 'D', 'W', 'M' etc.\n\n    Returns\n    -------\n    pandas.Index\n        Shifted index.\n\n    See Also\n    --------\n    Series.shift : Shift values of Series.\n\n    Notes\n    -----\n    This method is only implemented for datetime-like index classes,\n    i.e., DatetimeIndex, PeriodIndex and TimedeltaIndex.\n\n    Examples\n    --------\n    Put the first 5 month starts of 2011 into an index.\n\n    >>> month_starts = pd.date_range('1/1/2011', periods=5, freq='MS')\n    >>> month_starts\n    DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01', '2011-04-01',\n                   '2011-05-01'],\n                  dtype='datetime64[ns]', freq='MS')\n\n    Shift the index by 10 days.\n\n    >>> month_starts.shift(10, freq='D')\n    DatetimeIndex(['2011-01-11', '2011-02-11', '2011-03-11', '2011-04-11',\n                   '2011-05-11'],\n                  dtype='datetime64[ns]', freq=None)\n\n    The default value of `freq` is the `freq` attribute of the index,\n    which is 'MS' (month start) in this example.\n\n    >>> month_starts.shift(10)\n    DatetimeIndex(['2011-11-01', '2011-12-01', '2012-01-01', '2012-02-01',\n                   '2012-03-01'],\n                  dtype='datetime64[ns]', freq='MS')\n    \"\"\"\n    raise NotImplementedError(\"Not supported for type %s\" % type(self).__name__)",
                "def argsort(self, *args, **kwargs):\n    \"\"\"\n    Return the integer indices that would sort the index.\n\n    Parameters\n    ----------\n    *args\n        Passed to `numpy.ndarray.argsort`.\n    **kwargs\n        Passed to `numpy.ndarray.argsort`.\n\n    Returns\n    -------\n    numpy.ndarray\n        Integer indices that would sort the index if used as\n        an indexer.\n\n    See Also\n    --------\n    numpy.argsort : Similar method for NumPy arrays.\n    Index.sort_values : Return sorted copy of Index.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['b', 'a', 'd', 'c'])\n    >>> idx\n    Index(['b', 'a', 'd', 'c'], dtype='object')\n\n    >>> order = idx.argsort()\n    >>> order\n    array([1, 0, 3, 2])\n\n    >>> idx[order]\n    Index(['a', 'b', 'c', 'd'], dtype='object')\n    \"\"\"\n    result = self.asi8\n    if result is None:\n        result = np.array(self)\n    return result.argsort(*args, **kwargs)",
                "@Appender(_index_shared_docs[\"get_value\"] % _index_doc_kwargs)\ndef get_value(self, series, key):\n\n    # if we have something that is Index-like, then\n    # use this, e.g. DatetimeIndex\n    # Things like `Series._get_value` (via .at) pass the EA directly here.\n    s = getattr(series, \"_values\", series)\n    if isinstance(s, (ExtensionArray, Index)) and is_scalar(key):\n        # GH 20882, 21257\n        # Unify Index and ExtensionArray treatment\n        # First try to convert the key to a location\n        # If that fails, raise a KeyError if an integer\n        # index, otherwise, see if key is an integer, and\n        # try that\n        try:\n            iloc = self.get_loc(key)\n            return s[iloc]\n        except KeyError:\n            if len(self) > 0 and (self.holds_integer() or self.is_boolean()):\n                raise\n            elif is_integer(key):\n                return s[key]\n\n    s = com.values_from_object(series)\n    k = com.values_from_object(key)\n\n    k = self._convert_scalar_indexer(k, kind=\"getitem\")\n    try:\n        return self._engine.get_value(s, k, tz=getattr(series.dtype, \"tz\", None))\n    except KeyError as e1:\n        if len(self) > 0 and (self.holds_integer() or self.is_boolean()):\n            raise\n\n        try:\n            return libindex.get_value_at(s, key)\n        except IndexError:\n            raise\n        except TypeError:\n            # generator/iterator-like\n            if is_iterator(key):\n                raise InvalidIndexError(key)\n            else:\n                raise e1\n        except Exception:  # pragma: no cover\n            raise e1\n    except TypeError:\n        # python 3\n        if is_scalar(key):  # pragma: no cover\n            raise IndexError(key)\n        raise InvalidIndexError(key)",
                "def set_value(self, arr, key, value):\n    \"\"\"\n    Fast lookup of value from 1-dimensional ndarray.\n\n    Notes\n    -----\n    Only use this if you know what you're doing.\n    \"\"\"\n    self._engine.set_value(\n        com.values_from_object(arr), com.values_from_object(key), value\n    )",
                "@Appender(_index_shared_docs[\"get_indexer_non_unique\"] % _index_doc_kwargs)\ndef get_indexer_non_unique(self, target):\n    target = ensure_index(target)\n    pself, ptarget = self._maybe_promote(target)\n    if pself is not self or ptarget is not target:\n        return pself.get_indexer_non_unique(ptarget)\n\n    if is_categorical(target):\n        tgt_values = np.asarray(target)\n    elif self.is_all_dates:\n        tgt_values = target.asi8\n    else:\n        tgt_values = target._ndarray_values\n\n    indexer, missing = self._engine.get_indexer_non_unique(tgt_values)\n    return ensure_platform_int(indexer), missing",
                "def get_indexer_for(self, target, **kwargs):\n    \"\"\"\n    Guaranteed return of an indexer even when non-unique.\n\n    This dispatches to get_indexer or get_indexer_non_unique\n    as appropriate.\n\n    Returns\n    -------\n    numpy.ndarray\n        List of indices.\n    \"\"\"\n    if self.is_unique:\n        return self.get_indexer(target, **kwargs)\n    indexer, _ = self.get_indexer_non_unique(target, **kwargs)\n    return indexer",
                "def _maybe_promote(self, other):\n    # A hack, but it works\n    from pandas import DatetimeIndex\n\n    if self.inferred_type == \"date\" and isinstance(other, DatetimeIndex):\n        return DatetimeIndex(self), other\n    elif self.inferred_type == \"boolean\":\n        if not is_object_dtype(self.dtype):\n            return self.astype(\"object\"), other.astype(\"object\")\n    return self, other",
                "def groupby(self, values):\n    \"\"\"\n    Group the index labels by a given array of values.\n\n    Parameters\n    ----------\n    values : array\n        Values used to determine the groups.\n\n    Returns\n    -------\n    groups : dict\n        {group name -> group labels}\n    \"\"\"\n\n    # TODO: if we are a MultiIndex, we can do better\n    # that converting to tuples\n    if isinstance(values, ABCMultiIndex):\n        values = values.values\n    values = ensure_categorical(values)\n    result = values._reverse_indexer()\n\n    # map to the label\n    result = {k: self.take(v) for k, v in result.items()}\n\n    return result",
                "def map(self, mapper, na_action=None):\n    \"\"\"\n    Map values using input correspondence (a dict, Series, or function).\n\n    Parameters\n    ----------\n    mapper : function, dict, or Series\n        Mapping correspondence.\n    na_action : {None, 'ignore'}\n        If 'ignore', propagate NA values, without passing them to the\n        mapping correspondence.\n\n    Returns\n    -------\n    applied : Union[Index, MultiIndex], inferred\n        The output of the mapping function applied to the index.\n        If the function returns a tuple with more than one element\n        a MultiIndex will be returned.\n    \"\"\"\n\n    from .multi import MultiIndex\n\n    new_values = super()._map_values(mapper, na_action=na_action)\n\n    attributes = self._get_attributes_dict()\n\n    # we can return a MultiIndex\n    if new_values.size and isinstance(new_values[0], tuple):\n        if isinstance(self, MultiIndex):\n            names = self.names\n        elif attributes.get(\"name\"):\n            names = [attributes.get(\"name\")] * len(new_values[0])\n        else:\n            names = None\n        return MultiIndex.from_tuples(new_values, names=names)\n\n    attributes[\"copy\"] = False\n    if not new_values.size:\n        # empty\n        attributes[\"dtype\"] = self.dtype\n\n    return Index(new_values, **attributes)",
                "def isin(self, values, level=None):\n    \"\"\"\n    Return a boolean array where the index values are in `values`.\n\n    Compute boolean array of whether each index value is found in the\n    passed set of values. The length of the returned boolean array matches\n    the length of the index.\n\n    Parameters\n    ----------\n    values : set or list-like\n        Sought values.\n    level : str or int, optional\n        Name or position of the index level to use (if the index is a\n        `MultiIndex`).\n\n    Returns\n    -------\n    is_contained : ndarray\n        NumPy array of boolean values.\n\n    See Also\n    --------\n    Series.isin : Same for Series.\n    DataFrame.isin : Same method for DataFrames.\n\n    Notes\n    -----\n    In the case of `MultiIndex` you must either specify `values` as a\n    list-like object containing tuples that are the same length as the\n    number of levels, or specify `level`. Otherwise it will raise a\n    ``ValueError``.\n\n    If `level` is specified:\n\n    - if it is the name of one *and only one* index level, use that level;\n    - otherwise it should be a number indicating level position.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1,2,3])\n    >>> idx\n    Int64Index([1, 2, 3], dtype='int64')\n\n    Check whether each index value in a list of values.\n    >>> idx.isin([1, 4])\n    array([ True, False, False])\n\n    >>> midx = pd.MultiIndex.from_arrays([[1,2,3],\n    ...                                  ['red', 'blue', 'green']],\n    ...                                  names=('number', 'color'))\n    >>> midx\n    MultiIndex(levels=[[1, 2, 3], ['blue', 'green', 'red']],\n               codes=[[0, 1, 2], [2, 0, 1]],\n               names=['number', 'color'])\n\n    Check whether the strings in the 'color' level of the MultiIndex\n    are in a list of colors.\n\n    >>> midx.isin(['red', 'orange', 'yellow'], level='color')\n    array([ True, False, False])\n\n    To check across the levels of a MultiIndex, pass a list of tuples:\n\n    >>> midx.isin([(1, 'red'), (3, 'red')])\n    array([ True, False, False])\n\n    For a DatetimeIndex, string values in `values` are converted to\n    Timestamps.\n\n    >>> dates = ['2000-03-11', '2000-03-12', '2000-03-13']\n    >>> dti = pd.to_datetime(dates)\n    >>> dti\n    DatetimeIndex(['2000-03-11', '2000-03-12', '2000-03-13'],\n    dtype='datetime64[ns]', freq=None)\n\n    >>> dti.isin(['2000-03-11'])\n    array([ True, False, False])\n    \"\"\"\n    if level is not None:\n        self._validate_index_level(level)\n    return algos.isin(self, values)",
                "def _get_string_slice(self, key, use_lhs=True, use_rhs=True):\n    # this is for partial string indexing,\n    # overridden in DatetimeIndex, TimedeltaIndex and PeriodIndex\n    raise NotImplementedError",
                "def slice_indexer(self, start=None, end=None, step=None, kind=None):\n    \"\"\"\n    For an ordered or unique index, compute the slice indexer for input\n    labels and step.\n\n    Parameters\n    ----------\n    start : label, default None\n        If None, defaults to the beginning\n    end : label, default None\n        If None, defaults to the end\n    step : int, default None\n    kind : string, default None\n\n    Returns\n    -------\n    indexer : slice\n\n    Raises\n    ------\n    KeyError : If key does not exist, or key is not unique and index is\n        not ordered.\n\n    Notes\n    -----\n    This function assumes that the data is sorted, so use at your own peril\n\n    Examples\n    --------\n    This is a method on all index types. For example you can do:\n\n    >>> idx = pd.Index(list('abcd'))\n    >>> idx.slice_indexer(start='b', end='c')\n    slice(1, 3)\n\n    >>> idx = pd.MultiIndex.from_arrays([list('abcd'), list('efgh')])\n    >>> idx.slice_indexer(start='b', end=('c', 'g'))\n    slice(1, 3)\n    \"\"\"\n    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)\n\n    # return a slice\n    if not is_scalar(start_slice):\n        raise AssertionError(\"Start slice bound is non-scalar\")\n    if not is_scalar(end_slice):\n        raise AssertionError(\"End slice bound is non-scalar\")\n\n    return slice(start_slice, end_slice, step)",
                "def _maybe_cast_indexer(self, key):\n    \"\"\"\n    If we have a float key and are not a floating index, then try to cast\n    to an int if equivalent.\n    \"\"\"\n\n    if is_float(key) and not self.is_floating():\n        try:\n            ckey = int(key)\n            if ckey == key:\n                key = ckey\n        except (OverflowError, ValueError, TypeError):\n            pass\n    return key",
                "def _validate_indexer(self, form, key, kind):\n    \"\"\"\n    If we are positional indexer, validate that we have appropriate\n    typed bounds must be an integer.\n    \"\"\"\n    assert kind in [\"ix\", \"loc\", \"getitem\", \"iloc\"]\n\n    if key is None:\n        pass\n    elif is_integer(key):\n        pass\n    elif kind in [\"iloc\", \"getitem\"]:\n        self._invalid_indexer(form, key)\n    return key",
                "@Appender(_index_shared_docs[\"_maybe_cast_slice_bound\"])\ndef _maybe_cast_slice_bound(self, label, side, kind):\n    assert kind in [\"ix\", \"loc\", \"getitem\", None]\n\n    # We are a plain index here (sub-class override this method if they\n    # wish to have special treatment for floats/ints, e.g. Float64Index and\n    # datetimelike Indexes\n    # reject them\n    if is_float(label):\n        if not (kind in [\"ix\"] and (self.holds_integer() or self.is_floating())):\n            self._invalid_indexer(\"slice\", label)\n\n    # we are trying to find integer bounds on a non-integer based index\n    # this is rejected (generally .loc gets you here)\n    elif is_integer(label):\n        self._invalid_indexer(\"slice\", label)\n\n    return label",
                "def _searchsorted_monotonic(self, label, side=\"left\"):\n    if self.is_monotonic_increasing:\n        return self.searchsorted(label, side=side)\n    elif self.is_monotonic_decreasing:\n        # np.searchsorted expects ascending sort order, have to reverse\n        # everything for it to work (element ordering, search side and\n        # resulting value).\n        pos = self[::-1].searchsorted(\n            label, side=\"right\" if side == \"left\" else \"left\"\n        )\n        return len(self) - pos\n\n    raise ValueError(\"index must be monotonic increasing or decreasing\")",
                "def get_slice_bound(self, label, side, kind):\n    \"\"\"\n    Calculate slice bound that corresponds to given label.\n\n    Returns leftmost (one-past-the-rightmost if ``side=='right'``) position\n    of given label.\n\n    Parameters\n    ----------\n    label : object\n    side : {'left', 'right'}\n    kind : {'ix', 'loc', 'getitem'}\n\n    Returns\n    -------\n    int\n        Index of label.\n    \"\"\"\n    assert kind in [\"ix\", \"loc\", \"getitem\", None]\n\n    if side not in (\"left\", \"right\"):\n        raise ValueError(\n            \"Invalid value for side kwarg,\"\n            \" must be either 'left' or 'right': %s\" % (side,)\n        )\n\n    original_label = label\n\n    # For datetime indices label may be a string that has to be converted\n    # to datetime boundary according to its resolution.\n    label = self._maybe_cast_slice_bound(label, side, kind)\n\n    # we need to look up the label\n    try:\n        slc = self.get_loc(label)\n    except KeyError as err:\n        try:\n            return self._searchsorted_monotonic(label, side)\n        except ValueError:\n            # raise the original KeyError\n            raise err\n\n    if isinstance(slc, np.ndarray):\n        # get_loc may return a boolean array or an array of indices, which\n        # is OK as long as they are representable by a slice.\n        if is_bool_dtype(slc):\n            slc = lib.maybe_booleans_to_slice(slc.view(\"u1\"))\n        else:\n            slc = lib.maybe_indices_to_slice(slc.astype(\"i8\"), len(self))\n        if isinstance(slc, np.ndarray):\n            raise KeyError(\n                \"Cannot get %s slice bound for non-unique \"\n                \"label: %r\" % (side, original_label)\n            )\n\n    if isinstance(slc, slice):\n        if side == \"left\":\n            return slc.start\n        else:\n            return slc.stop\n    else:\n        if side == \"right\":\n            return slc + 1\n        else:\n            return slc",
                "def slice_locs(self, start=None, end=None, step=None, kind=None):\n    \"\"\"\n    Compute slice locations for input labels.\n\n    Parameters\n    ----------\n    start : label, default None\n        If None, defaults to the beginning\n    end : label, default None\n        If None, defaults to the end\n    step : int, defaults None\n        If None, defaults to 1\n    kind : {'ix', 'loc', 'getitem'} or None\n\n    Returns\n    -------\n    start, end : int\n\n    See Also\n    --------\n    Index.get_loc : Get location for a single label.\n\n    Notes\n    -----\n    This method only works if the index is monotonic or unique.\n\n    Examples\n    --------\n    >>> idx = pd.Index(list('abcd'))\n    >>> idx.slice_locs(start='b', end='c')\n    (1, 3)\n    \"\"\"\n    inc = step is None or step >= 0\n\n    if not inc:\n        # If it's a reverse slice, temporarily swap bounds.\n        start, end = end, start\n\n    # GH 16785: If start and end happen to be date strings with UTC offsets\n    # attempt to parse and check that the offsets are the same\n    if isinstance(start, (str, datetime)) and isinstance(end, (str, datetime)):\n        try:\n            ts_start = Timestamp(start)\n            ts_end = Timestamp(end)\n        except (ValueError, TypeError):\n            pass\n        else:\n            if not tz_compare(ts_start.tzinfo, ts_end.tzinfo):\n                raise ValueError(\"Both dates must have the same UTC offset\")\n\n    start_slice = None\n    if start is not None:\n        start_slice = self.get_slice_bound(start, \"left\", kind)\n    if start_slice is None:\n        start_slice = 0\n\n    end_slice = None\n    if end is not None:\n        end_slice = self.get_slice_bound(end, \"right\", kind)\n    if end_slice is None:\n        end_slice = len(self)\n\n    if not inc:\n        # Bounds at this moment are swapped, swap them back and shift by 1.\n        #\n        # slice_locs('B', 'A', step=-1): s='B', e='A'\n        #\n        #              s='A'                 e='B'\n        # AFTER SWAP:    |                     |\n        #                v ------------------> V\n        #           -----------------------------------\n        #           | | |A|A|A|A| | | | | |B|B| | | | |\n        #           -----------------------------------\n        #              ^ <------------------ ^\n        # SHOULD BE:   |                     |\n        #           end=s-1              start=e-1\n        #\n        end_slice, start_slice = start_slice - 1, end_slice - 1\n\n        # i == -1 triggers ``len(self) + i`` selection that points to the\n        # last element, not before-the-first one, subtracting len(self)\n        # compensates that.\n        if end_slice == -1:\n            end_slice -= len(self)\n        if start_slice == -1:\n            start_slice -= len(self)\n\n    return start_slice, end_slice",
                "def delete(self, loc):\n    \"\"\"\n    Make new Index with passed location(-s) deleted.\n\n    Returns\n    -------\n    new_index : Index\n    \"\"\"\n    return self._shallow_copy(np.delete(self._data, loc))",
                "def insert(self, loc, item):\n    \"\"\"\n    Make new Index inserting new item at location.\n\n    Follows Python list.append semantics for negative values.\n\n    Parameters\n    ----------\n    loc : int\n    item : object\n\n    Returns\n    -------\n    new_index : Index\n    \"\"\"\n    _self = np.asarray(self)\n    item = self._coerce_scalar_to_index(item)._ndarray_values\n    idx = np.concatenate((_self[:loc], item, _self[loc:]))\n    return self._shallow_copy_with_infer(idx)",
                "def drop(self, labels, errors=\"raise\"):\n    \"\"\"\n    Make new Index with passed list of labels deleted.\n\n    Parameters\n    ----------\n    labels : array-like\n    errors : {'ignore', 'raise'}, default 'raise'\n        If 'ignore', suppress error and existing labels are dropped.\n\n    Returns\n    -------\n    dropped : Index\n\n    Raises\n    ------\n    KeyError\n        If not all of the labels are found in the selected axis\n    \"\"\"\n    arr_dtype = \"object\" if self.dtype == \"object\" else None\n    labels = com.index_labels_to_array(labels, dtype=arr_dtype)\n    indexer = self.get_indexer(labels)\n    mask = indexer == -1\n    if mask.any():\n        if errors != \"ignore\":\n            raise KeyError(\"{} not found in axis\".format(labels[mask]))\n        indexer = indexer[~mask]\n    return self.delete(indexer)",
                "@classmethod\ndef _add_comparison_methods(cls):\n    \"\"\"\n    Add in comparison methods.\n    \"\"\"\n    cls.__eq__ = _make_comparison_op(operator.eq, cls)\n    cls.__ne__ = _make_comparison_op(operator.ne, cls)\n    cls.__lt__ = _make_comparison_op(operator.lt, cls)\n    cls.__gt__ = _make_comparison_op(operator.gt, cls)\n    cls.__le__ = _make_comparison_op(operator.le, cls)\n    cls.__ge__ = _make_comparison_op(operator.ge, cls)",
                "@classmethod\ndef _add_numeric_methods_add_sub_disabled(cls):\n    \"\"\"\n    Add in the numeric add/sub methods to disable.\n    \"\"\"\n    cls.__add__ = make_invalid_op(\"__add__\")\n    cls.__radd__ = make_invalid_op(\"__radd__\")\n    cls.__iadd__ = make_invalid_op(\"__iadd__\")\n    cls.__sub__ = make_invalid_op(\"__sub__\")\n    cls.__rsub__ = make_invalid_op(\"__rsub__\")\n    cls.__isub__ = make_invalid_op(\"__isub__\")",
                "@classmethod\ndef _add_numeric_methods_disabled(cls):\n    \"\"\"\n    Add in numeric methods to disable other than add/sub.\n    \"\"\"\n    cls.__pow__ = make_invalid_op(\"__pow__\")\n    cls.__rpow__ = make_invalid_op(\"__rpow__\")\n    cls.__mul__ = make_invalid_op(\"__mul__\")\n    cls.__rmul__ = make_invalid_op(\"__rmul__\")\n    cls.__floordiv__ = make_invalid_op(\"__floordiv__\")\n    cls.__rfloordiv__ = make_invalid_op(\"__rfloordiv__\")\n    cls.__truediv__ = make_invalid_op(\"__truediv__\")\n    cls.__rtruediv__ = make_invalid_op(\"__rtruediv__\")\n    cls.__mod__ = make_invalid_op(\"__mod__\")\n    cls.__divmod__ = make_invalid_op(\"__divmod__\")\n    cls.__neg__ = make_invalid_op(\"__neg__\")\n    cls.__pos__ = make_invalid_op(\"__pos__\")\n    cls.__abs__ = make_invalid_op(\"__abs__\")\n    cls.__inv__ = make_invalid_op(\"__inv__\")",
                "@classmethod\ndef _add_numeric_methods_binary(cls):\n    \"\"\"\n    Add in numeric methods.\n    \"\"\"\n    cls.__add__ = _make_arithmetic_op(operator.add, cls)\n    cls.__radd__ = _make_arithmetic_op(ops.radd, cls)\n    cls.__sub__ = _make_arithmetic_op(operator.sub, cls)\n    cls.__rsub__ = _make_arithmetic_op(ops.rsub, cls)\n    cls.__rpow__ = _make_arithmetic_op(ops.rpow, cls)\n    cls.__pow__ = _make_arithmetic_op(operator.pow, cls)\n\n    cls.__truediv__ = _make_arithmetic_op(operator.truediv, cls)\n    cls.__rtruediv__ = _make_arithmetic_op(ops.rtruediv, cls)\n\n    # TODO: rmod? rdivmod?\n    cls.__mod__ = _make_arithmetic_op(operator.mod, cls)\n    cls.__floordiv__ = _make_arithmetic_op(operator.floordiv, cls)\n    cls.__rfloordiv__ = _make_arithmetic_op(ops.rfloordiv, cls)\n    cls.__divmod__ = _make_arithmetic_op(divmod, cls)\n    cls.__mul__ = _make_arithmetic_op(operator.mul, cls)\n    cls.__rmul__ = _make_arithmetic_op(ops.rmul, cls)",
                "@classmethod\ndef _add_numeric_methods_unary(cls):\n    \"\"\"\n    Add in numeric unary methods.\n    \"\"\"\n\n    def _make_evaluate_unary(op, opstr):\n        def _evaluate_numeric_unary(self):\n\n            attrs = self._get_attributes_dict()\n            return Index(op(self.values), **attrs)\n\n        _evaluate_numeric_unary.__name__ = opstr\n        return _evaluate_numeric_unary\n\n    cls.__neg__ = _make_evaluate_unary(operator.neg, \"__neg__\")\n    cls.__pos__ = _make_evaluate_unary(operator.pos, \"__pos__\")\n    cls.__abs__ = _make_evaluate_unary(np.abs, \"__abs__\")\n    cls.__inv__ = _make_evaluate_unary(lambda x: -x, \"__inv__\")",
                "@classmethod\ndef _add_numeric_methods(cls):\n    cls._add_numeric_methods_unary()\n    cls._add_numeric_methods_binary()",
                "@classmethod\ndef _add_logical_methods(cls):\n    \"\"\"\n    Add in logical methods.\n    \"\"\"\n    _doc = \"\"\"\n    %(desc)s\n\n    Parameters\n    ----------\n    *args\n        These parameters will be passed to numpy.%(outname)s.\n    **kwargs\n        These parameters will be passed to numpy.%(outname)s.\n\n    Returns\n    -------\n    %(outname)s : bool or array_like (if axis is specified)\n        A single element array_like may be converted to bool.\"\"\"\n\n    _index_shared_docs[\"index_all\"] = dedent(\n        \"\"\"\n\n    See Also\n    --------\n    Index.any : Return whether any element in an Index is True.\n    Series.any : Return whether any element in a Series is True.\n    Series.all : Return whether all elements in a Series are True.\n\n    Notes\n    -----\n    Not a Number (NaN), positive infinity and negative infinity\n    evaluate to True because these are not equal to zero.\n\n    Examples\n    --------\n    **all**\n\n    True, because nonzero integers are considered True.\n\n    >>> pd.Index([1, 2, 3]).all()\n    True\n\n    False, because ``0`` is considered False.\n\n    >>> pd.Index([0, 1, 2]).all()\n    False\n\n    **any**\n\n    True, because ``1`` is considered True.\n\n    >>> pd.Index([0, 0, 1]).any()\n    True\n\n    False, because ``0`` is considered False.\n\n    >>> pd.Index([0, 0, 0]).any()\n    False\n    \"\"\"\n    )\n\n    _index_shared_docs[\"index_any\"] = dedent(\n        \"\"\"\n\n    See Also\n    --------\n    Index.all : Return whether all elements are True.\n    Series.all : Return whether all elements are True.\n\n    Notes\n    -----\n    Not a Number (NaN), positive infinity and negative infinity\n    evaluate to True because these are not equal to zero.\n\n    Examples\n    --------\n    >>> index = pd.Index([0, 1, 2])\n    >>> index.any()\n    True\n\n    >>> index = pd.Index([0, 0, 0])\n    >>> index.any()\n    False\n    \"\"\"\n    )\n\n    def _make_logical_function(name, desc, f):\n        @Substitution(outname=name, desc=desc)\n        @Appender(_index_shared_docs[\"index_\" + name])\n        @Appender(_doc)\n        def logical_func(self, *args, **kwargs):\n            result = f(self.values)\n            if (\n                isinstance(result, (np.ndarray, ABCSeries, Index))\n                and result.ndim == 0\n            ):\n                # return NumPy type\n                return result.dtype.type(result.item())\n            else:  # pragma: no cover\n                return result\n\n        logical_func.__name__ = name\n        return logical_func\n\n    cls.all = _make_logical_function(\n        \"all\", \"Return whether all elements are True.\", np.all\n    )\n    cls.any = _make_logical_function(\n        \"any\", \"Return whether any element is True.\", np.any\n    )",
                "@classmethod\ndef _add_logical_methods_disabled(cls):\n    \"\"\"\n    Add in logical methods to disable.\n    \"\"\"\n    cls.all = make_invalid_op(\"all\")\n    cls.any = make_invalid_op(\"any\")",
                "@property\ndef shape(self):\n    \"\"\"\n    Return a tuple of the shape of the underlying data.\n    \"\"\"\n    # not using \"(len(self), )\" to return \"correct\" shape if the values\n    # consists of a >1 D array (see GH-27775)\n    # overridden in MultiIndex.shape to avoid materializing the values\n    return self._values.shape",
                "def is_int(v):\n    return v is None or is_integer(v)",
                "def _get_leaf_sorter(labels):\n    \"\"\"\n    Returns sorter for the inner most level while preserving the\n    order of higher levels.\n    \"\"\"\n    if labels[0].size == 0:\n        return np.empty(0, dtype=\"int64\")\n\n    if len(labels) == 1:\n        lab = ensure_int64(labels[0])\n        sorter, _ = libalgos.groupsort_indexer(lab, 1 + lab.max())\n        return sorter\n\n    # find indexers of beginning of each set of\n    # same-key labels w.r.t all but last level\n    tic = labels[0][:-1] != labels[0][1:]\n    for lab in labels[1:-1]:\n        tic |= lab[:-1] != lab[1:]\n\n    starts = np.hstack(([True], tic, [True])).nonzero()[0]\n    lab = ensure_int64(labels[-1])\n    return lib.get_level_sorter(lab, ensure_int64(starts))",
                "def _make_evaluate_unary(op, opstr):\n    def _evaluate_numeric_unary(self):\n\n        attrs = self._get_attributes_dict()\n        return Index(op(self.values), **attrs)\n\n    _evaluate_numeric_unary.__name__ = opstr\n    return _evaluate_numeric_unary",
                "def _make_logical_function(name, desc, f):\n    @Substitution(outname=name, desc=desc)\n    @Appender(_index_shared_docs[\"index_\" + name])\n    @Appender(_doc)\n    def logical_func(self, *args, **kwargs):\n        result = f(self.values)\n        if (\n            isinstance(result, (np.ndarray, ABCSeries, Index))\n            and result.ndim == 0\n        ):\n            # return NumPy type\n            return result.dtype.type(result.item())\n        else:  # pragma: no cover\n            return result\n\n    logical_func.__name__ = name\n    return logical_func",
                "def _evaluate_numeric_unary(self):\n\n    attrs = self._get_attributes_dict()\n    return Index(op(self.values), **attrs)",
                "@Substitution(outname=name, desc=desc)\n@Appender(_index_shared_docs[\"index_\" + name])\n@Appender(_doc)\ndef logical_func(self, *args, **kwargs):\n    result = f(self.values)\n    if (\n        isinstance(result, (np.ndarray, ABCSeries, Index))\n        and result.ndim == 0\n    ):\n        # return NumPy type\n        return result.dtype.type(result.item())\n    else:  # pragma: no cover\n        return result"
            ],
            "inscope_function_signatures": [
                "_make_comparison_op(op, cls)",
                "_make_arithmetic_op(op, cls)",
                "_new_Index(cls, d)",
                "ensure_index_from_sequences(sequences, names=None)",
                "ensure_index(index_like, copy=False)",
                "_ensure_has_len(seq)",
                "_trim_front(strings)",
                "_validate_join_method(method)",
                "default_index(n)",
                "cmp_method(self, other)",
                "index_arithmetic_method(self, other)",
                "_left_indexer_unique(self, left, right)",
                "_left_indexer(self, left, right)",
                "_inner_indexer(self, left, right)",
                "_outer_indexer(self, left, right)",
                "__new__(cls, data=None, dtype=None, copy=False, name=None, fastpath=None, tupleize_cols=True, **kwargs) -> 'Index'",
                "asi8(self)",
                "_simple_new(cls, values, name=None, dtype=None, **kwargs)",
                "_constructor(self)",
                "_get_attributes_dict(self)",
                "_shallow_copy(self, values=None, **kwargs)",
                "_shallow_copy_with_infer(self, values, **kwargs)",
                "_update_inplace(self, result, **kwargs)",
                "is_(self, other)",
                "_reset_identity(self)",
                "_cleanup(self)",
                "_engine(self)",
                "__len__(self)",
                "__array__(self, dtype=None)",
                "__array_wrap__(self, result, context=None)",
                "dtype(self)",
                "dtype_str(self)",
                "ravel(self, order='C')",
                "view(self, cls=None)",
                "astype(self, dtype, copy=True)",
                "take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs)",
                "_assert_take_fillable(self, values, indices, allow_fill=True, fill_value=None, na_value=np.nan)",
                "repeat(self, repeats, axis=None)",
                "copy(self, name=None, deep=False, dtype=None, **kwargs)",
                "__copy__(self, **kwargs)",
                "__deepcopy__(self, memo=None)",
                "__repr__(self)",
                "_format_space(self)",
                "_formatter_func(self)",
                "_format_data(self, name=None)",
                "_format_attrs(self)",
                "_mpl_repr(self)",
                "format(self, name=False, formatter=None, **kwargs)",
                "_format_with_header(self, header, na_rep='NaN', **kwargs)",
                "to_native_types(self, slicer=None, **kwargs)",
                "_format_native_types(self, na_rep='', quoting=None, **kwargs)",
                "_summary(self, name=None)",
                "summary(self, name=None)",
                "to_flat_index(self)",
                "to_series(self, index=None, name=None)",
                "to_frame(self, index=True, name=None)",
                "_validate_names(self, name=None, names=None, deep=False)",
                "_get_names(self)",
                "_set_names(self, values, level=None)",
                "set_names(self, names, level=None, inplace=False)",
                "rename(self, name, inplace=False)",
                "nlevels(self)",
                "_sort_levels_monotonic(self)",
                "_validate_index_level(self, level)",
                "_get_level_number(self, level)",
                "sortlevel(self, level=None, ascending=True, sort_remaining=None)",
                "_get_level_values(self, level)",
                "droplevel(self, level=0)",
                "_get_grouper_for_level(self, mapper, level=None)",
                "is_monotonic(self)",
                "is_monotonic_increasing(self)",
                "is_monotonic_decreasing(self)",
                "_is_strictly_monotonic_increasing(self)",
                "_is_strictly_monotonic_decreasing(self)",
                "is_lexsorted_for_tuple(self, tup)",
                "is_unique(self)",
                "has_duplicates(self)",
                "is_boolean(self)",
                "is_integer(self)",
                "is_floating(self)",
                "is_numeric(self)",
                "is_object(self)",
                "is_categorical(self)",
                "is_interval(self)",
                "is_mixed(self)",
                "holds_integer(self)",
                "inferred_type(self)",
                "is_all_dates(self)",
                "__reduce__(self)",
                "__setstate__(self, state)",
                "_isnan(self)",
                "_nan_idxs(self)",
                "hasnans(self)",
                "isna(self)",
                "notna(self)",
                "fillna(self, value=None, downcast=None)",
                "dropna(self, how='any')",
                "unique(self, level=None)",
                "drop_duplicates(self, keep='first')",
                "duplicated(self, keep='first')",
                "get_duplicates(self)",
                "_get_unique_index(self, dropna=False)",
                "__add__(self, other)",
                "__radd__(self, other)",
                "__iadd__(self, other)",
                "__sub__(self, other)",
                "__rsub__(self, other)",
                "__and__(self, other)",
                "__or__(self, other)",
                "__xor__(self, other)",
                "__nonzero__(self)",
                "_get_reconciled_name_object(self, other)",
                "_union_incompatible_dtypes(self, other, sort)",
                "_is_compatible_with_other(self, other)",
                "_validate_sort_keyword(self, sort)",
                "union(self, other, sort=None)",
                "_union(self, other, sort)",
                "_wrap_setop_result(self, other, result)",
                "intersection(self, other, sort=False)",
                "difference(self, other, sort=None)",
                "symmetric_difference(self, other, result_name=None, sort=None)",
                "_assert_can_do_setop(self, other)",
                "_convert_can_do_setop(self, other)",
                "get_loc(self, key, method=None, tolerance=None)",
                "get_indexer(self, target, method=None, limit=None, tolerance=None)",
                "_convert_tolerance(self, tolerance, target)",
                "_get_fill_indexer(self, target, method, limit=None, tolerance=None)",
                "_get_fill_indexer_searchsorted(self, target, method, limit=None)",
                "_get_nearest_indexer(self, target, limit, tolerance)",
                "_filter_indexer_tolerance(self, target, indexer, tolerance)",
                "_convert_scalar_indexer(self, key, kind=None)",
                "_convert_slice_indexer(self, key: slice, kind=None)",
                "_convert_listlike_indexer(self, keyarr, kind=None)",
                "_convert_arr_indexer(self, keyarr)",
                "_convert_index_indexer(self, keyarr)",
                "_convert_list_indexer(self, keyarr, kind=None)",
                "_invalid_indexer(self, form, key)",
                "_can_reindex(self, indexer)",
                "reindex(self, target, method=None, level=None, limit=None, tolerance=None)",
                "_reindex_non_unique(self, target)",
                "join(self, other, how='left', level=None, return_indexers=False, sort=False)",
                "_join_multi(self, other, how, return_indexers=True)",
                "_join_non_unique(self, other, how='left', return_indexers=False)",
                "_join_level(self, other, level, how='left', return_indexers=False, keep_order=True)",
                "_join_monotonic(self, other, how='left', return_indexers=False)",
                "_wrap_joined_index(self, joined, other)",
                "values(self)",
                "_values(self) -> Union[ExtensionArray, ABCIndexClass, np.ndarray]",
                "get_values(self)",
                "_internal_get_values(self)",
                "memory_usage(self, deep=False)",
                "where(self, cond, other=None)",
                "_try_convert_to_int_index(cls, data, copy, name, dtype)",
                "_scalar_data_error(cls, data)",
                "_string_data_error(cls, data)",
                "_coerce_to_ndarray(cls, data)",
                "_coerce_scalar_to_index(self, item)",
                "_to_safe_for_reshape(self)",
                "_convert_for_op(self, value)",
                "_assert_can_do_op(self, value)",
                "_has_complex_internals(self)",
                "_is_memory_usage_qualified(self)",
                "is_type_compatible(self, kind)",
                "__contains__(self, key)",
                "contains(self, key)",
                "__hash__(self)",
                "__setitem__(self, key, value)",
                "__getitem__(self, key)",
                "_can_hold_identifiers_and_holds_name(self, name)",
                "append(self, other)",
                "_concat(self, to_concat, name)",
                "_concat_same_dtype(self, to_concat, name)",
                "putmask(self, mask, value)",
                "equals(self, other)",
                "identical(self, other)",
                "asof(self, label)",
                "asof_locs(self, where, mask)",
                "sort_values(self, return_indexer=False, ascending=True)",
                "sort(self, *args, **kwargs)",
                "shift(self, periods=1, freq=None)",
                "argsort(self, *args, **kwargs)",
                "get_value(self, series, key)",
                "set_value(self, arr, key, value)",
                "get_indexer_non_unique(self, target)",
                "get_indexer_for(self, target, **kwargs)",
                "_maybe_promote(self, other)",
                "groupby(self, values)",
                "map(self, mapper, na_action=None)",
                "isin(self, values, level=None)",
                "_get_string_slice(self, key, use_lhs=True, use_rhs=True)",
                "slice_indexer(self, start=None, end=None, step=None, kind=None)",
                "_maybe_cast_indexer(self, key)",
                "_validate_indexer(self, form, key, kind)",
                "_maybe_cast_slice_bound(self, label, side, kind)",
                "_searchsorted_monotonic(self, label, side='left')",
                "get_slice_bound(self, label, side, kind)",
                "slice_locs(self, start=None, end=None, step=None, kind=None)",
                "delete(self, loc)",
                "insert(self, loc, item)",
                "drop(self, labels, errors='raise')",
                "_add_comparison_methods(cls)",
                "_add_numeric_methods_add_sub_disabled(cls)",
                "_add_numeric_methods_disabled(cls)",
                "_add_numeric_methods_binary(cls)",
                "_add_numeric_methods_unary(cls)",
                "_add_numeric_methods(cls)",
                "_add_logical_methods(cls)",
                "_add_logical_methods_disabled(cls)",
                "shape(self)",
                "is_int(v)",
                "_get_leaf_sorter(labels)",
                "_make_evaluate_unary(op, opstr)",
                "_make_logical_function(name, desc, f)",
                "_evaluate_numeric_unary(self)",
                "logical_func(self, *args, **kwargs)"
            ],
            "variables_in_file": {
                "__all__": [
                    86
                ],
                "_unsortable_types": [
                    88
                ],
                "frozenset": [
                    88,
                    208
                ],
                "_index_doc_kwargs": [
                    2881,
                    2074,
                    808,
                    4715,
                    4147,
                    4630,
                    90,
                    890
                ],
                "dict": [
                    1824,
                    98,
                    1815,
                    90,
                    893
                ],
                "_index_shared_docs": [
                    899,
                    2051,
                    4997,
                    3206,
                    5382,
                    3081,
                    3210,
                    4618,
                    780,
                    2832,
                    4115,
                    4630,
                    921,
                    2074,
                    3226,
                    5020,
                    545,
                    808,
                    560,
                    5424,
                    4147,
                    3191,
                    2881,
                    1992,
                    3017,
                    5451,
                    1613,
                    3407,
                    721,
                    851,
                    2772,
                    3028,
                    4693,
                    2519,
                    2012,
                    3936,
                    98,
                    1635,
                    3171,
                    3430,
                    2023,
                    746,
                    4715,
                    3953,
                    3186,
                    2039,
                    890,
                    3067,
                    2812,
                    2557
                ],
                "isinstance": [
                    129,
                    513,
                    135,
                    4753,
                    3602,
                    4244,
                    4250,
                    4637,
                    287,
                    1824,
                    1569,
                    3232,
                    292,
                    1829,
                    294,
                    5159,
                    4777,
                    4273,
                    4280,
                    571,
                    1468,
                    4417,
                    5571,
                    2762,
                    717,
                    462,
                    4814,
                    3664,
                    4815,
                    5456,
                    4051,
                    5583,
                    3669,
                    4056,
                    1370,
                    3035,
                    3163,
                    1117,
                    3549,
                    3550,
                    352,
                    1120,
                    4320,
                    103,
                    3432,
                    2281,
                    3433,
                    107,
                    3308,
                    4201,
                    110,
                    5095,
                    5102,
                    5108
                ],
                "other": [
                    2560,
                    2561,
                    2563,
                    2564,
                    2566,
                    3591,
                    2568,
                    2569,
                    3596,
                    3598,
                    2576,
                    2577,
                    2579,
                    2581,
                    2584,
                    3610,
                    3618,
                    2596,
                    3620,
                    2600,
                    2606,
                    3664,
                    3667,
                    2652,
                    2654,
                    2658,
                    2662,
                    103,
                    104,
                    107,
                    108,
                    109,
                    624,
                    113,
                    117,
                    121,
                    129,
                    134,
                    4753,
                    4754,
                    4244,
                    4245,
                    4757,
                    4247,
                    4758,
                    2723,
                    2724,
                    2729,
                    2730,
                    2741,
                    3769,
                    3770,
                    3777,
                    3779,
                    2757,
                    2762,
                    2763,
                    3786,
                    2766,
                    2767,
                    3791,
                    3794,
                    3804,
                    4317,
                    4320,
                    4323,
                    4325,
                    3814,
                    2281,
                    4329,
                    2285,
                    2290,
                    2294,
                    2297,
                    4346,
                    4349,
                    2303,
                    4353,
                    2306,
                    2309,
                    2312,
                    2333,
                    2359,
                    2360,
                    2376,
                    3433,
                    3440,
                    3443,
                    3955,
                    3956,
                    3448,
                    3961,
                    3451,
                    3453,
                    3967,
                    2438,
                    3462,
                    2440,
                    2441,
                    2443,
                    3469,
                    3471,
                    3479,
                    3481,
                    3482,
                    3486,
                    3488,
                    2465,
                    2466,
                    3490,
                    3491,
                    2469,
                    3493,
                    3497,
                    3499,
                    2476,
                    2477,
                    3502,
                    2479,
                    2481,
                    3510,
                    3514,
                    2492,
                    3518,
                    3528,
                    3531,
                    2514,
                    2517,
                    3542,
                    3550,
                    3559,
                    3573
                ],
                "np.ndarray": [
                    352,
                    3840,
                    3843,
                    103,
                    5095,
                    1834,
                    5102,
                    1839,
                    5456,
                    4051
                ],
                "np": [
                    3456,
                    3840,
                    3969,
                    3843,
                    517,
                    4615,
                    3464,
                    393,
                    1039,
                    402,
                    659,
                    148,
                    1050,
                    3616,
                    3618,
                    2297,
                    1833,
                    1834,
                    3370,
                    1838,
                    1839,
                    2734,
                    2735,
                    3249,
                    2995,
                    3378,
                    3000,
                    3386,
                    1851,
                    3387,
                    829,
                    4282,
                    1599,
                    3647,
                    3011,
                    453,
                    3398,
                    1095,
                    1863,
                    1097,
                    4298,
                    2892,
                    3660,
                    5456,
                    1873,
                    4051,
                    341,
                    4058,
                    5468,
                    5471,
                    352,
                    5216,
                    4451,
                    4453,
                    103,
                    5095,
                    2665,
                    5354,
                    5102,
                    4207,
                    112,
                    5233,
                    4723,
                    116,
                    117,
                    2934,
                    5235,
                    761,
                    764,
                    3709,
                    3967
                ],
                "Index": [
                    773,
                    136,
                    137,
                    4250,
                    2589,
                    670,
                    4637,
                    5534,
                    2593,
                    420,
                    4264,
                    2359,
                    2360,
                    4280,
                    5571,
                    453,
                    5576,
                    2762,
                    2763,
                    717,
                    5456,
                    4051,
                    472,
                    601,
                    3163,
                    4828,
                    349,
                    352,
                    4320,
                    5347,
                    2020,
                    5603,
                    103,
                    3815,
                    3308,
                    2285,
                    4076,
                    2290,
                    5493,
                    5494,
                    5495,
                    2297,
                    764,
                    2303
                ],
                "ABCSeries": [
                    352,
                    129,
                    513,
                    103,
                    2281,
                    5456,
                    4056
                ],
                "ExtensionArray": [
                    4271,
                    3843,
                    4637,
                    103
                ],
                "other.ndim": [
                    104
                ],
                "len": [
                    3456,
                    643,
                    3461,
                    3464,
                    653,
                    1299,
                    1300,
                    5531,
                    4254,
                    2465,
                    2468,
                    1574,
                    1831,
                    1576,
                    2983,
                    3369,
                    3370,
                    1580,
                    3244,
                    3246,
                    4262,
                    4648,
                    3249,
                    3378,
                    4660,
                    566,
                    1593,
                    3386,
                    3387,
                    5049,
                    5179,
                    2495,
                    3649,
                    4418,
                    3398,
                    1863,
                    594,
                    3282,
                    4818,
                    5202,
                    5204,
                    5589,
                    1115,
                    3035,
                    3709,
                    4453,
                    3687,
                    104,
                    1128,
                    5611,
                    3308,
                    5101,
                    3696,
                    5623,
                    3453
                ],
                "self": [
                    4107,
                    4113,
                    2077,
                    2079,
                    4151,
                    4173,
                    4176,
                    4194,
                    4195,
                    104,
                    107,
                    108,
                    110,
                    113,
                    117,
                    121,
                    4225,
                    4226,
                    134,
                    4242,
                    4254,
                    4256,
                    4263,
                    4264,
                    4276,
                    4277,
                    4282,
                    2245,
                    4296,
                    4298,
                    4299,
                    4301,
                    4305,
                    2260,
                    2261,
                    2263,
                    2265,
                    2266,
                    4317,
                    2270,
                    2275,
                    4323,
                    4325,
                    4329,
                    2285,
                    2290,
                    2294,
                    2297,
                    4346,
                    4349,
                    4350,
                    2303,
                    4353,
                    2306,
                    2309,
                    2312,
                    2318,
                    2333,
                    2334,
                    2335,
                    2336,
                    2357,
                    4413,
                    4415,
                    4418,
                    4419,
                    2376,
                    4450,
                    4453,
                    4456,
                    2437,
                    2438,
                    2440,
                    2441,
                    2443,
                    4503,
                    4507,
                    2465,
                    2466,
                    2468,
                    2469,
                    2472,
                    2473,
                    2475,
                    2481,
                    2483,
                    2492,
                    2514,
                    2517,
                    4576,
                    2559,
                    2560,
                    2563,
                    2564,
                    4613,
                    2566,
                    2567,
                    4615,
                    2572,
                    2573,
                    2575,
                    2581,
                    534,
                    2583,
                    2584,
                    543,
                    4645,
                    2600,
                    4648,
                    2603,
                    2604,
                    2606,
                    4656,
                    4658,
                    563,
                    564,
                    4660,
                    567,
                    576,
                    591,
                    4689,
                    595,
                    596,
                    598,
                    2651,
                    2652,
                    2654,
                    2656,
                    2658,
                    2660,
                    4718,
                    4719,
                    624,
                    4724,
                    630,
                    631,
                    4729,
                    634,
                    642,
                    643,
                    4744,
                    4745,
                    4746,
                    653,
                    4753,
                    4754,
                    659,
                    4755,
                    4756,
                    4757,
                    4758,
                    669,
                    2722,
                    2723,
                    2724,
                    677,
                    2728,
                    4783,
                    692,
                    2750,
                    2754,
                    707,
                    714,
                    2763,
                    716,
                    2764,
                    718,
                    2766,
                    4811,
                    4815,
                    4816,
                    4826,
                    748,
                    749,
                    754,
                    761,
                    764,
                    771,
                    2821,
                    774,
                    2823,
                    2824,
                    778,
                    813,
                    814,
                    815,
                    4910,
                    4911,
                    819,
                    824,
                    825,
                    826,
                    2886,
                    2891,
                    2894,
                    2895,
                    2900,
                    2901,
                    2907,
                    4957,
                    2913,
                    2915,
                    4973,
                    2928,
                    2940,
                    894,
                    2942,
                    2944,
                    4994,
                    2948,
                    2950,
                    2969,
                    2971,
                    924,
                    926,
                    929,
                    5029,
                    5030,
                    2983,
                    937,
                    5035,
                    2992,
                    2993,
                    5040,
                    5041,
                    948,
                    2996,
                    2997,
                    2999,
                    5042,
                    5046,
                    5049,
                    957,
                    958,
                    959,
                    960,
                    3006,
                    3010,
                    3033,
                    3035,
                    5083,
                    5087,
                    5090,
                    3043,
                    996,
                    3044,
                    998,
                    1003,
                    3051,
                    5101,
                    1010,
                    3059,
                    1014,
                    3063,
                    3062,
                    1023,
                    1024,
                    1029,
                    1031,
                    1034,
                    3088,
                    3089,
                    3090,
                    3102,
                    3109,
                    3111,
                    3112,
                    3113,
                    3120,
                    3123,
                    5171,
                    3125,
                    3128,
                    5177,
                    5179,
                    1084,
                    3137,
                    3140,
                    1093,
                    1094,
                    1095,
                    1097,
                    5202,
                    5204,
                    1115,
                    1116,
                    3164,
                    3166,
                    1119,
                    3168,
                    5216,
                    1127,
                    1128,
                    5233,
                    5234,
                    5236,
                    1141,
                    5257,
                    5259,
                    1164,
                    5265,
                    3231,
                    1187,
                    3235,
                    1189,
                    3236,
                    1191,
                    3244,
                    3246,
                    3248,
                    3249,
                    3261,
                    3282,
                    1248,
                    1249,
                    5346,
                    5347,
                    1252,
                    3309,
                    3311,
                    3312,
                    1268,
                    3319,
                    3323,
                    1279,
                    3327,
                    3328,
                    3337,
                    3339,
                    3341,
                    1307,
                    1309,
                    3364,
                    3366,
                    3375,
                    3398,
                    3401,
                    5454,
                    1370,
                    1377,
                    3432,
                    1386,
                    1388,
                    3440,
                    5490,
                    3443,
                    3447,
                    3454,
                    3461,
                    3469,
                    3472,
                    3479,
                    3480,
                    3486,
                    3487,
                    1442,
                    3490,
                    3491,
                    3492,
                    3496,
                    3499,
                    3501,
                    1458,
                    3508,
                    3514,
                    3518,
                    3524,
                    1478,
                    3527,
                    1481,
                    1486,
                    3541,
                    3549,
                    1506,
                    3558,
                    3573,
                    3591,
                    1545,
                    1546,
                    3597,
                    3610,
                    3616,
                    1572,
                    3620,
                    1575,
                    1576,
                    1580,
                    1584,
                    1585,
                    1586,
                    3664,
                    3667,
                    3669,
                    1639,
                    1641,
                    1653,
                    1670,
                    1687,
                    1704,
                    1721,
                    3769,
                    3770,
                    3776,
                    1731,
                    3779,
                    3782,
                    1735,
                    3784,
                    1738,
                    3787,
                    1741,
                    3790,
                    3791,
                    1744,
                    3793,
                    3794,
                    1747,
                    3797,
                    1750,
                    3799,
                    3801,
                    3803,
                    3804,
                    3814,
                    1786,
                    1789,
                    1792,
                    3840,
                    1798,
                    1805,
                    1809,
                    1815,
                    1816,
                    1817,
                    3870,
                    1825,
                    1827,
                    1835,
                    1841,
                    1842,
                    1859,
                    1860,
                    1863,
                    1869,
                    1870,
                    3923,
                    3926,
                    1880,
                    1881,
                    3933,
                    3956,
                    3958,
                    3959,
                    3969,
                    3974,
                    1940,
                    1988,
                    2014,
                    2015,
                    2016,
                    2020,
                    2021,
                    4069,
                    4071,
                    4076,
                    4082,
                    2044,
                    2045,
                    2046
                ],
                "ValueError": [
                    2816,
                    3333,
                    776,
                    2315,
                    2961,
                    1298,
                    1300,
                    417,
                    4007,
                    1577,
                    427,
                    5163,
                    5167,
                    4016,
                    4019,
                    2936,
                    437,
                    824,
                    4152,
                    5051,
                    843,
                    2380,
                    4300,
                    5074,
                    3283,
                    599,
                    1371,
                    3547,
                    5091,
                    2918,
                    105,
                    2923,
                    365,
                    4978,
                    376,
                    2042,
                    5630
                ],
                "is_object_dtype": [
                    4323,
                    998,
                    107,
                    4301,
                    110,
                    304,
                    336,
                    1041,
                    1044,
                    4756,
                    342,
                    1750
                ],
                "ABCCategorical": [
                    107
                ],
                "left": [
                    3743,
                    3667,
                    3671,
                    3674,
                    218,
                    3675,
                    221,
                    224,
                    227,
                    3687,
                    3689,
                    3691,
                    108,
                    109,
                    3692,
                    3699,
                    3702,
                    3705,
                    3709
                ],
                "type": [
                    4096,
                    4353,
                    4576,
                    1127,
                    2376,
                    778,
                    108,
                    4176,
                    5584,
                    534,
                    3261
                ],
                "self._values": [
                    1249,
                    2475,
                    108,
                    2575,
                    5490,
                    894
                ],
                "other.dtype": [
                    2376,
                    108,
                    2566,
                    3479
                ],
                "op": [
                    5347,
                    134,
                    3001,
                    139,
                    109,
                    113,
                    117,
                    2999,
                    121,
                    123
                ],
                "ABCMultiIndex": [
                    3432,
                    3433,
                    4777,
                    110,
                    1370,
                    3035
                ],
                "np.errstate": [
                    112,
                    116
                ],
                "result": [
                    4613,
                    4614,
                    519,
                    520,
                    4615,
                    4616,
                    3597,
                    526,
                    527,
                    529,
                    530,
                    3602,
                    3603,
                    1045,
                    3604,
                    2583,
                    2584,
                    1050,
                    1051,
                    1052,
                    2078,
                    1055,
                    1056,
                    2079,
                    1597,
                    1599,
                    1601,
                    1602,
                    113,
                    4210,
                    4211,
                    4212,
                    117,
                    4214,
                    119,
                    120,
                    134,
                    135,
                    136,
                    137,
                    665,
                    666,
                    667,
                    670,
                    4780,
                    4783,
                    4785,
                    714,
                    716,
                    717,
                    718,
                    719,
                    1249,
                    1252,
                    1253,
                    320,
                    323,
                    331,
                    332,
                    5454,
                    5456,
                    5457,
                    5460,
                    5462,
                    3930,
                    3933,
                    3934,
                    4453,
                    4456,
                    4458,
                    3471,
                    3475,
                    3476,
                    3477,
                    2483,
                    2486,
                    2490,
                    2497,
                    2500,
                    2504,
                    2514,
                    2517,
                    2016,
                    2020
                ],
                "ops.comp_method_OBJECT_ARRAY": [
                    113
                ],
                "ops": [
                    5320,
                    5322,
                    5323,
                    5327,
                    113,
                    5332,
                    5335,
                    121
                ],
                "self.values": [
                    771,
                    774,
                    1034,
                    1809,
                    1191,
                    815,
                    563,
                    2996,
                    2997,
                    825,
                    3010,
                    4296,
                    5454,
                    3926,
                    2263,
                    4450,
                    5347,
                    4456,
                    113,
                    754,
                    117,
                    1014,
                    3959,
                    2045
                ],
                "np.asarray": [
                    3616,
                    453,
                    517,
                    1095,
                    4207,
                    5233,
                    659,
                    2995,
                    341,
                    117,
                    2934,
                    4723,
                    761,
                    4058,
                    764
                ],
                "is_bool_dtype": [
                    5098,
                    402,
                    119,
                    3961,
                    666
                ],
                "ops.invalid_comparison": [
                    121
                ],
                "name": [
                    4226,
                    139,
                    141,
                    397,
                    399,
                    527,
                    401,
                    274,
                    275,
                    1275,
                    1276,
                    1304,
                    1305,
                    4254,
                    285,
                    2333,
                    2334,
                    416,
                    929,
                    1442,
                    2335,
                    420,
                    293,
                    1188,
                    295,
                    423,
                    1189,
                    426,
                    299,
                    1191,
                    2601,
                    2603,
                    2604,
                    4015,
                    4264,
                    306,
                    436,
                    4278,
                    444,
                    4006,
                    447,
                    321,
                    450,
                    4256,
                    325,
                    453,
                    4263,
                    5450,
                    331,
                    5451,
                    334,
                    337,
                    468,
                    472,
                    5464,
                    349,
                    1247,
                    1248,
                    1249,
                    1126,
                    1127,
                    232,
                    1128,
                    3814,
                    1003,
                    3815,
                    1265,
                    1267,
                    1141,
                    374,
                    380,
                    1274,
                    123,
                    124,
                    1021
                ],
                "format": [
                    4026,
                    1480,
                    1578,
                    123,
                    139,
                    2316,
                    2381,
                    2507,
                    3259,
                    5263,
                    2042,
                    1307
                ],
                "op.__name__": [
                    123,
                    139
                ],
                "set_function_name": [
                    124,
                    141
                ],
                "cmp_method": [
                    124
                ],
                "cls": [
                    519,
                    141,
                    5275,
                    5276,
                    5277,
                    285,
                    5278,
                    416,
                    159,
                    162,
                    163,
                    5279,
                    5280,
                    5287,
                    5288,
                    5289,
                    5290,
                    5291,
                    5292,
                    5299,
                    5300,
                    5301,
                    5302,
                    5303,
                    5304,
                    5305,
                    5306,
                    4027,
                    5307,
                    5308,
                    5309,
                    5310,
                    5311,
                    5312,
                    450,
                    455,
                    5319,
                    713,
                    714,
                    5320,
                    5321,
                    5322,
                    5323,
                    5324,
                    5326,
                    5327,
                    5330,
                    5331,
                    5332,
                    4053,
                    5333,
                    5334,
                    5335,
                    5467,
                    5470,
                    5479,
                    5352,
                    5353,
                    5354,
                    5355,
                    5480,
                    5359,
                    5360,
                    373,
                    124
                ],
                "ABCDataFrame": [
                    129,
                    2281
                ],
                "ABCTimedeltaIndex": [
                    129,
                    4271
                ],
                "NotImplemented": [
                    130,
                    2282
                ],
                "Series": [
                    134,
                    1191,
                    2285,
                    2290,
                    2303
                ],
                "tuple": [
                    1569,
                    1829,
                    135,
                    811,
                    462,
                    4814,
                    3378,
                    3602,
                    4244,
                    4056,
                    893
                ],
                "index_arithmetic_method": [
                    141
                ],
                "Exception": [
                    4673,
                    3138,
                    4331,
                    144,
                    1844,
                    2591
                ],
                "_o_dtype": [
                    328,
                    313,
                    148
                ],
                "np.dtype": [
                    148
                ],
                "object": [
                    519,
                    148,
                    149,
                    405,
                    420,
                    4273,
                    3378,
                    2357,
                    2359,
                    2360,
                    323,
                    1097,
                    332,
                    4305,
                    2901,
                    2902,
                    471,
                    348,
                    349,
                    3964
                ],
                "_Identity": [
                    149,
                    630
                ],
                "issubclass": [
                    402,
                    159
                ],
                "ABCPeriodIndex": [
                    3232,
                    4271,
                    159
                ],
                "_new_PeriodIndex": [
                    162
                ],
                "d": [
                    162,
                    163,
                    1815,
                    1816,
                    1817
                ],
                "cls.__new__": [
                    163
                ],
                "IndexOpsMixin": [
                    3928,
                    166
                ],
                "PandasObject": [
                    166
                ],
                "_deprecations": [
                    208
                ],
                "DirNamesMixin._deprecations": [
                    208
                ],
                "DirNamesMixin": [
                    208
                ],
                "_join_precedence": [
                    211
                ],
                "libjoin.left_join_indexer_unique": [
                    218
                ],
                "libjoin": [
                    224,
                    218,
                    227,
                    221
                ],
                "right": [
                    224,
                    227,
                    3677,
                    3683,
                    3667,
                    3671,
                    218,
                    221
                ],
                "libjoin.left_join_indexer": [
                    221
                ],
                "libjoin.inner_join_indexer": [
                    224
                ],
                "libjoin.outer_join_indexer": [
                    227
                ],
                "_typ": [
                    229
                ],
                "_data": [
                    230
                ],
                "_id": [
                    231
                ],
                "_comparables": [
                    233
                ],
                "_attributes": [
                    234
                ],
                "_is_numeric_dtype": [
                    235
                ],
                "_can_hold_na": [
                    236
                ],
                "_defer_to_indexing": [
                    239
                ],
                "_infer_as_myclass": [
                    243
                ],
                "_engine_type": [
                    245
                ],
                "libindex.ObjectEngine": [
                    245
                ],
                "libindex": [
                    4664,
                    245
                ],
                "_supports_partial_string_indexing": [
                    248
                ],
                "_accessors": [
                    250
                ],
                "str": [
                    1120,
                    1095,
                    5159,
                    692,
                    252,
                    1117
                ],
                "CachedAccessor": [
                    252
                ],
                "StringMethods": [
                    252
                ],
                "hasattr": [
                    1120,
                    452,
                    3303,
                    5575,
                    713,
                    274,
                    1117
                ],
                "data": [
                    274,
                    275,
                    285,
                    287,
                    289,
                    292,
                    293,
                    294,
                    295,
                    1833,
                    298,
                    299,
                    1834,
                    1838,
                    303,
                    1839,
                    1841,
                    306,
                    309,
                    321,
                    325,
                    327,
                    331,
                    334,
                    336,
                    337,
                    340,
                    341,
                    345,
                    348,
                    349,
                    352,
                    360,
                    362,
                    364,
                    368,
                    374,
                    380,
                    385,
                    387,
                    391,
                    393,
                    396,
                    397,
                    398,
                    399,
                    400,
                    401,
                    402,
                    403,
                    405,
                    4004,
                    4005,
                    4013,
                    4014,
                    4027,
                    958,
                    452,
                    453,
                    454,
                    455,
                    968,
                    457,
                    965,
                    459,
                    460,
                    966,
                    462,
                    4051,
                    468,
                    4052,
                    4053,
                    471,
                    4056,
                    4057,
                    4058,
                    4059
                ],
                "data.name": [
                    275
                ],
                "fastpath": [
                    284,
                    277
                ],
                "warnings.warn": [
                    4166,
                    2506,
                    3917,
                    686,
                    1136,
                    278,
                    2237
                ],
                "warnings": [
                    4166,
                    2506,
                    3917,
                    686,
                    1136,
                    278,
                    2237
                ],
                "FutureWarning": [
                    2241,
                    4170,
                    3920,
                    689,
                    1138,
                    281
                ],
                "cls._simple_new": [
                    450,
                    285
                ],
                "ABCPandasArray": [
                    287
                ],
                "data.to_numpy": [
                    289
                ],
                "RangeIndex": [
                    5636,
                    292,
                    293,
                    295
                ],
                "copy": [
                    771,
                    764,
                    774,
                    393,
                    397,
                    399,
                    401,
                    409,
                    416,
                    420,
                    293,
                    4006,
                    423,
                    426,
                    299,
                    4015,
                    306,
                    436,
                    444,
                    5572,
                    325,
                    453,
                    5576,
                    334,
                    337,
                    472,
                    349,
                    5598,
                    5601,
                    362,
                    749,
                    754,
                    374,
                    380
                ],
                "dtype": [
                    385,
                    386,
                    771,
                    764,
                    3972,
                    774,
                    391,
                    3974,
                    393,
                    778,
                    397,
                    399,
                    401,
                    659,
                    412,
                    416,
                    4000,
                    932,
                    293,
                    933,
                    295,
                    298,
                    299,
                    303,
                    304,
                    306,
                    310,
                    313,
                    325,
                    453,
                    327,
                    328,
                    334,
                    336,
                    340,
                    342,
                    344,
                    345,
                    472,
                    353,
                    4069,
                    359,
                    362,
                    4074,
                    748,
                    4076,
                    751,
                    368,
                    754,
                    755,
                    374,
                    3958,
                    760,
                    763,
                    380,
                    3965,
                    767
                ],
                "range": [
                    294
                ],
                "RangeIndex.from_range": [
                    295
                ],
                "is_categorical_dtype": [
                    298,
                    1038,
                    751
                ],
                "CategoricalIndex": [
                    754,
                    299
                ],
                "kwargs": [
                    1031,
                    4616,
                    4745,
                    4746,
                    528,
                    928,
                    937,
                    810,
                    299,
                    811,
                    305,
                    436,
                    565,
                    566,
                    311,
                    444,
                    447,
                    1087,
                    321,
                    325,
                    453,
                    331,
                    334,
                    592,
                    337,
                    594,
                    468,
                    472,
                    349
                ],
                "is_interval_dtype": [
                    303
                ],
                "closed": [
                    305,
                    306
                ],
                "kwargs.get": [
                    928,
                    305,
                    468
                ],
                "IntervalIndex": [
                    426,
                    306
                ],
                "is_datetime64_any_dtype": [
                    309,
                    310
                ],
                "is_dtype_equal": [
                    2566,
                    328,
                    2376,
                    748,
                    2900,
                    3479,
                    313
                ],
                "DatetimeIndex": [
                    320,
                    770,
                    325,
                    4753,
                    4754,
                    436,
                    761
                ],
                "result.astype": [
                    323,
                    332
                ],
                "is_timedelta64_dtype": [
                    327
                ],
                "TimedeltaIndex": [
                    331,
                    444,
                    334
                ],
                "is_period_dtype": [
                    2472,
                    2476,
                    2572,
                    336,
                    2576
                ],
                "PeriodIndex": [
                    337,
                    447
                ],
                "is_extension_array_dtype": [
                    763,
                    340
                ],
                "ea_cls": [
                    344,
                    345
                ],
                "dtype.construct_array_type": [
                    344
                ],
                "ea_cls._from_sequence": [
                    345
                ],
                "data.astype": [
                    385,
                    4004,
                    391,
                    4013,
                    403,
                    348
                ],
                "is_integer_dtype": [
                    3230,
                    359
                ],
                "inferred": [
                    387,
                    388,
                    414,
                    421,
                    360,
                    361,
                    424,
                    363,
                    430,
                    367,
                    433,
                    434,
                    443,
                    413,
                    382,
                    445
                ],
                "lib.infer_dtype": [
                    360,
                    1805,
                    387,
                    413
                ],
                "lib": [
                    387,
                    360,
                    5099,
                    1805,
                    3662,
                    5101,
                    3696,
                    1042,
                    5587,
                    665,
                    666,
                    413
                ],
                "maybe_cast_to_integer_array": [
                    368,
                    362
                ],
                "any": [
                    364,
                    838
                ],
                "isna": [
                    3969,
                    1860,
                    1093,
                    4071,
                    364,
                    1942,
                    1048,
                    2271
                ],
                "cls._try_convert_to_int_index": [
                    416,
                    373
                ],
                "Float64Index": [
                    401,
                    380,
                    423
                ],
                "is_float_dtype": [
                    400,
                    386
                ],
                "np.array": [
                    4615,
                    1097,
                    393,
                    1039,
                    1873,
                    2297,
                    1050
                ],
                "is_signed_integer_dtype": [
                    396
                ],
                "data.dtype": [
                    400,
                    402,
                    396,
                    398
                ],
                "Int64Index": [
                    397,
                    4006
                ],
                "is_unsigned_integer_dtype": [
                    4000,
                    398
                ],
                "UInt64Index": [
                    4015,
                    399
                ],
                "data.dtype.type": [
                    402
                ],
                "np.bool": [
                    402
                ],
                "subarr": [
                    416,
                    450,
                    420,
                    423,
                    426,
                    403,
                    436,
                    405,
                    471,
                    472,
                    410,
                    444,
                    413,
                    447
                ],
                "com.asarray_tuplesafe": [
                    3188,
                    405,
                    471
                ],
                "com": [
                    471,
                    4198,
                    4329,
                    5258,
                    4653,
                    4206,
                    4654,
                    4209,
                    4690,
                    3188,
                    3541,
                    405,
                    3542
                ],
                "subarr.copy": [
                    410
                ],
                "inferred.startswith": [
                    434,
                    443
                ],
                "OutOfBoundsDatetime": [
                    437
                ],
                "IncompatibleFrequency": [
                    448
                ],
                "is_scalar": [
                    4960,
                    4962,
                    4197,
                    454,
                    4677,
                    4211,
                    4052,
                    4637,
                    4094
                ],
                "cls._scalar_data_error": [
                    4053,
                    455
                ],
                "tupleize_cols": [
                    457
                ],
                "is_list_like": [
                    1377,
                    1380,
                    2757,
                    1382,
                    457,
                    1297,
                    1270,
                    1274,
                    1373
                ],
                "is_iterator": [
                    5578,
                    459,
                    4669
                ],
                "list": [
                    3585,
                    1029,
                    4244,
                    4245,
                    1569,
                    1584,
                    1585,
                    1586,
                    2486,
                    5579,
                    460,
                    5583,
                    5584,
                    5585,
                    4056,
                    4057,
                    3555,
                    3556,
                    5613,
                    3702,
                    3705
                ],
                "all": [
                    3237,
                    4005,
                    4014,
                    462,
                    5623,
                    4347
                ],
                "e": [
                    2508,
                    462
                ],
                "MultiIndex.from_tuples": [
                    467,
                    4821
                ],
                "MultiIndex": [
                    5536,
                    1606,
                    4815,
                    3664,
                    467,
                    3669,
                    4821,
                    5592,
                    3577,
                    3740,
                    3549,
                    3550
                ],
                "property": [
                    3842,
                    4098,
                    1733,
                    1447,
                    679,
                    1672,
                    1706,
                    5482,
                    3820,
                    493,
                    1648,
                    982,
                    1655,
                    1689,
                    1311
                ],
                "values": [
                    513,
                    3969,
                    517,
                    3974,
                    520,
                    1034,
                    526,
                    1038,
                    1039,
                    1041,
                    1042,
                    1297,
                    1044,
                    1045,
                    1299,
                    1300,
                    1048,
                    1304,
                    1309,
                    1055,
                    4777,
                    4778,
                    4779,
                    4780,
                    3375,
                    4911,
                    562,
                    563,
                    566,
                    570,
                    571,
                    1084,
                    574,
                    1086,
                    576,
                    1087,
                    1095,
                    1863,
                    1097,
                    1864,
                    1099,
                    1100,
                    845,
                    1865,
                    4296,
                    848,
                    4298,
                    594,
                    4299,
                    598,
                    2263,
                    601,
                    2266,
                    2271,
                    2275,
                    3311,
                    3312,
                    3959,
                    3964,
                    3967
                ],
                "ABCIndexClass": [
                    513,
                    3843
                ],
                "values._values": [
                    517
                ],
                "object.__new__": [
                    519
                ],
                "result._data": [
                    520
                ],
                "result._index_data": [
                    526
                ],
                "result.name": [
                    1601,
                    527
                ],
                "k": [
                    962,
                    1826,
                    1827,
                    4654,
                    4783,
                    528,
                    529,
                    4656,
                    4658,
                    543
                ],
                "v": [
                    962,
                    1827,
                    1826,
                    4783,
                    528,
                    529,
                    3098
                ],
                "kwargs.items": [
                    528
                ],
                "setattr": [
                    529,
                    1827
                ],
                "result._reset_identity": [
                    530
                ],
                "classmethod": [
                    5282,
                    5314,
                    5337,
                    4037,
                    5474,
                    3977,
                    5357,
                    5294,
                    5362,
                    4021,
                    5270,
                    505,
                    4030
                ],
                "cache_readonly": [
                    672,
                    1800,
                    1867,
                    1807,
                    1854,
                    1875,
                    532,
                    636,
                    1726
                ],
                "getattr": [
                    543,
                    624,
                    4658,
                    570,
                    4636,
                    4349,
                    3327
                ],
                "self._attributes": [
                    543
                ],
                "attributes": [
                    576,
                    4823,
                    4811,
                    591,
                    592,
                    593,
                    4817,
                    595,
                    564,
                    565,
                    598,
                    567,
                    4818,
                    601,
                    4826,
                    4828
                ],
                "self._get_attributes_dict": [
                    5346,
                    4811,
                    4076,
                    3309,
                    591,
                    564,
                    4277,
                    1816,
                    669,
                    2750
                ],
                "attributes.update": [
                    592,
                    565
                ],
                "self.dtype": [
                    3479,
                    4069,
                    2566,
                    2376,
                    5257,
                    748,
                    3312,
                    595,
                    692,
                    2900,
                    1750,
                    567,
                    3958,
                    4756,
                    4826
                ],
                "ABCDatetimeArray": [
                    571
                ],
                "values.asi8": [
                    574
                ],
                "self._simple_new": [
                    576,
                    3312
                ],
                "Appender": [
                    3206,
                    3081,
                    4630,
                    921,
                    2074,
                    3226,
                    5020,
                    808,
                    560,
                    4147,
                    2881,
                    5451,
                    5452,
                    3028,
                    3928,
                    2012,
                    1635,
                    3430,
                    746,
                    4715,
                    3953,
                    3186,
                    2039,
                    890,
                    2812,
                    2557
                ],
                "self._infer_as_myclass": [
                    596
                ],
                "self._constructor": [
                    2517,
                    598
                ],
                "TypeError": [
                    4096,
                    776,
                    778,
                    2826,
                    2585,
                    1306,
                    4251,
                    4518,
                    4007,
                    5163,
                    3504,
                    4016,
                    2484,
                    4152,
                    4025,
                    3258,
                    2747,
                    4667,
                    4032,
                    4675,
                    2758,
                    2505,
                    4300,
                    4176,
                    3665,
                    4179,
                    599,
                    605,
                    1375,
                    1378,
                    5612,
                    2670,
                    1266,
                    4978,
                    3318,
                    1271
                ],
                "self._id": [
                    624,
                    718,
                    630
                ],
                "Ellipsis": [
                    624
                ],
                "self._engine.clear_mapping": [
                    634
                ],
                "self._engine": [
                    2944,
                    1731,
                    2821,
                    1670,
                    2823,
                    2928,
                    4689,
                    4658,
                    4151,
                    1687,
                    4729,
                    634,
                    3933,
                    2942
                ],
                "_ndarray_values": [
                    642,
                    643,
                    5234
                ],
                "self._ndarray_values": [
                    3616,
                    3776,
                    642,
                    707,
                    2473,
                    2573,
                    3610
                ],
                "self._engine_type": [
                    643
                ],
                "self._data": [
                    2656,
                    1825,
                    3840,
                    4194,
                    5216,
                    677,
                    714,
                    653,
                    3311,
                    1841,
                    659,
                    1815,
                    924,
                    3870
                ],
                "lib.item_from_zerodim": [
                    665
                ],
                "lib.is_scalar": [
                    666
                ],
                "attrs": [
                    962,
                    5346,
                    5347,
                    3309,
                    3310,
                    3312,
                    669,
                    670,
                    959
                ],
                "self._data.dtype": [
                    677
                ],
                "self._ndarray_values.ravel": [
                    707
                ],
                "order": [
                    707
                ],
                "self._data.view": [
                    3840,
                    714
                ],
                "self._shallow_copy": [
                    894,
                    924,
                    926,
                    2335,
                    2079,
                    1187,
                    2604,
                    2046,
                    826,
                    4299,
                    716,
                    2656,
                    5216,
                    2275,
                    4195,
                    2021,
                    1388,
                    2045,
                    3454
                ],
                "result._id": [
                    718
                ],
                "self.copy": [
                    937,
                    948,
                    749
                ],
                "self.name": [
                    1024,
                    771,
                    774,
                    3339,
                    3341,
                    1023,
                    1309,
                    2334,
                    4254,
                    1189,
                    2600,
                    1835,
                    2603,
                    2606,
                    1478,
                    1481,
                    2763,
                    2764,
                    1248,
                    2020,
                    754,
                    1279
                ],
                "is_datetime64tz_dtype": [
                    2472,
                    755,
                    2476,
                    767
                ],
                "tz": [
                    760,
                    761
                ],
                "pandas_dtype": [
                    760
                ],
                "tz_convert": [
                    761
                ],
                "tz_localize": [
                    761
                ],
                "self.values.astype": [
                    774
                ],
                "msg": [
                    4096,
                    839,
                    777,
                    778,
                    843,
                    823,
                    824,
                    4095,
                    1374,
                    1375
                ],
                "msg.format": [
                    824,
                    4096,
                    778
                ],
                "__name__": [
                    4096,
                    4576,
                    1127,
                    778,
                    4176
                ],
                "nv.validate_take": [
                    811
                ],
                "nv": [
                    811,
                    893
                ],
                "indices": [
                    834,
                    838,
                    812,
                    845,
                    816,
                    848,
                    825
                ],
                "ensure_platform_int": [
                    3808,
                    834,
                    812,
                    2892,
                    3372,
                    3759,
                    2930,
                    3762,
                    4730,
                    892,
                    3613,
                    3614,
                    3807
                ],
                "self._can_hold_na": [
                    1880,
                    1859,
                    1869,
                    813
                ],
                "taken": [
                    2596,
                    2599,
                    844,
                    2604,
                    814,
                    2607,
                    848,
                    849,
                    2609,
                    825,
                    826
                ],
                "self._assert_take_fillable": [
                    814
                ],
                "allow_fill": [
                    817,
                    845,
                    837,
                    822
                ],
                "fill_value": [
                    818,
                    837,
                    822
                ],
                "self._na_value": [
                    819,
                    3956,
                    4415
                ],
                "self.__class__.__name__": [
                    824,
                    1307,
                    957,
                    2318
                ],
                "self.__class__": [
                    2318,
                    824,
                    1817,
                    1307,
                    957
                ],
                "self.values.take": [
                    825
                ],
                "np.nan": [
                    1851,
                    829,
                    1599
                ],
                "algos.take": [
                    844
                ],
                "algos": [
                    2496,
                    2593,
                    3748,
                    844,
                    4911,
                    3698
                ],
                "na_value": [
                    845
                ],
                "values.take": [
                    848
                ],
                "repeats": [
                    892,
                    894
                ],
                "nv.validate_repeat": [
                    893
                ],
                "axis": [
                    893
                ],
                "self._values.repeat": [
                    894
                ],
                "deep": [
                    929,
                    1268,
                    3930,
                    923,
                    3933
                ],
                "new_index": [
                    930,
                    933,
                    934,
                    3401,
                    3402,
                    924,
                    926
                ],
                "self._data.copy": [
                    924
                ],
                "names": [
                    5532,
                    4253,
                    4254,
                    1311,
                    928,
                    929,
                    930,
                    5533,
                    5534,
                    5536,
                    4816,
                    4818,
                    4820,
                    4821,
                    1373,
                    1377,
                    1380,
                    1381,
                    1389,
                    1265,
                    1267,
                    3572,
                    1269,
                    1270,
                    1272,
                    3578
                ],
                "self._validate_names": [
                    929
                ],
                "new_index.set_names": [
                    930
                ],
                "new_index.astype": [
                    933
                ],
                "memo": [
                    946,
                    947
                ],
                "klass": [
                    968,
                    957
                ],
                "self._format_data": [
                    958
                ],
                "self._format_attrs": [
                    959
                ],
                "space": [
                    960,
                    962
                ],
                "self._format_space": [
                    960
                ],
                "prepr": [
                    968,
                    962
                ],
                "join": [
                    962
                ],
                "res": [
                    4004,
                    4005,
                    4006,
                    968,
                    970,
                    4013,
                    4014,
                    4015
                ],
                "default_pprint": [
                    987
                ],
                "is_justify": [
                    995,
                    1003
                ],
                "self.inferred_type": [
                    1792,
                    3235,
                    996,
                    998,
                    1798,
                    1738,
                    3051,
                    1741,
                    1744,
                    3248,
                    4113,
                    1747,
                    4753,
                    4755,
                    3128,
                    1786,
                    1789
                ],
                "self.categories": [
                    998
                ],
                "format_object_summary": [
                    1002
                ],
                "self._formatter_func": [
                    1003
                ],
                "format_object_attrs": [
                    1010
                ],
                "header": [
                    1056,
                    1029,
                    1031,
                    1020,
                    1022
                ],
                "header.append": [
                    1022
                ],
                "pprint_thing": [
                    1122,
                    1045,
                    1023
                ],
                "formatter": [
                    1028,
                    1029
                ],
                "self.map": [
                    1641,
                    1029
                ],
                "self._format_with_header": [
                    1031
                ],
                "values.dtype": [
                    1041,
                    1044,
                    1038
                ],
                "lib.maybe_convert_objects": [
                    1042
                ],
                "x": [
                    5624,
                    5355,
                    4273,
                    3475,
                    3476,
                    1045,
                    5623,
                    4280,
                    2490
                ],
                "mask": [
                    3712,
                    3713,
                    5260,
                    5261,
                    3727,
                    3728,
                    5263,
                    3730,
                    5264,
                    1048,
                    1049,
                    3738,
                    1051,
                    3617,
                    3618,
                    1596,
                    1598,
                    1599,
                    1093,
                    4298,
                    1099,
                    4305,
                    4450,
                    4453,
                    4455,
                    3710,
                    3711
                ],
                "mask.any": [
                    1049,
                    5261,
                    1598
                ],
                "na_rep": [
                    1099,
                    1051
                ],
                "result.tolist": [
                    1052
                ],
                "_trim_front": [
                    1055
                ],
                "format_array": [
                    1055
                ],
                "slicer": [
                    1085,
                    1086
                ],
                "values._format_native_types": [
                    1087
                ],
                "self.is_object": [
                    4225,
                    4107,
                    1094
                ],
                "quoting": [
                    1094
                ],
                "astype": [
                    2360,
                    2359,
                    1095
                ],
                "head": [
                    1122,
                    1116,
                    1117,
                    1118
                ],
                "head.format": [
                    1118
                ],
                "tail": [
                    1120,
                    1121,
                    1122,
                    1119
                ],
                "tail.format": [
                    1121
                ],
                "index_summary": [
                    1128,
                    1122,
                    1124
                ],
                "self._summary": [
                    1141
                ],
                "index": [
                    1186,
                    1187,
                    1251,
                    1191
                ],
                "self.values.copy": [
                    4296,
                    1191
                ],
                "DataFrame": [
                    1249
                ],
                "self._values.copy": [
                    1249
                ],
                "result.index": [
                    1252
                ],
                "deepcopy": [
                    1268
                ],
                "self.names": [
                    3440,
                    4816,
                    1586,
                    1268,
                    3541
                ],
                "FrozenList": [
                    1279
                ],
                "is_hashable": [
                    1305
                ],
                "_set_names": [
                    1311
                ],
                "_get_names": [
                    1311
                ],
                "level": [
                    3716,
                    1545,
                    3596,
                    3598,
                    3472,
                    3732,
                    2076,
                    2077,
                    1569,
                    1570,
                    1572,
                    3749,
                    1574,
                    1576,
                    3752,
                    1580,
                    4909,
                    4910,
                    1468,
                    1469,
                    1472,
                    1474,
                    1476,
                    3448,
                    1478,
                    1481,
                    1486,
                    1370,
                    3674,
                    3675,
                    1373,
                    1377,
                    1637,
                    1382,
                    1383,
                    3691,
                    1389,
                    3437,
                    3699,
                    3316,
                    3446,
                    3703,
                    3320,
                    3706
                ],
                "self.nlevels": [
                    1576,
                    1377,
                    1580
                ],
                "inplace": [
                    1385,
                    1442,
                    1390
                ],
                "idx": [
                    1386,
                    1388,
                    1389,
                    1391,
                    5235,
                    5236
                ],
                "idx._set_names": [
                    1389
                ],
                "self.set_names": [
                    1442
                ],
                "int": [
                    1468,
                    4975
                ],
                "IndexError": [
                    4665,
                    4678,
                    1475,
                    1470
                ],
                "KeyError": [
                    5088,
                    2822,
                    1479,
                    4647,
                    2829,
                    5103,
                    5263,
                    4659,
                    3127,
                    4414
                ],
                "self._validate_index_level": [
                    4910,
                    1545,
                    2077,
                    1486
                ],
                "self.sort_values": [
                    1506
                ],
                "ascending": [
                    4504,
                    1506
                ],
                "get_level_values": [
                    1548
                ],
                "_get_level_values": [
                    1548
                ],
                "levnums": [
                    1572,
                    1588
                ],
                "sorted": [
                    1572
                ],
                "self._get_level_number": [
                    1572
                ],
                "lev": [
                    1572
                ],
                "new_levels": [
                    3741,
                    1607,
                    1584,
                    3705,
                    1589,
                    1593,
                    3706,
                    1597
                ],
                "self.levels": [
                    1584
                ],
                "new_codes": [
                    3712,
                    3703,
                    1608,
                    3724,
                    1585,
                    3730,
                    3732,
                    3733,
                    1590,
                    3702,
                    1596,
                    1597,
                    3742
                ],
                "self.codes": [
                    1585
                ],
                "new_names": [
                    1609,
                    1601,
                    1586,
                    1591
                ],
                "i": [
                    1588,
                    1589,
                    1590,
                    1591
                ],
                "new_levels.pop": [
                    1589
                ],
                "new_codes.pop": [
                    1590
                ],
                "new_names.pop": [
                    1591
                ],
                "take": [
                    1597,
                    4453
                ],
                "result.putmask": [
                    1599
                ],
                "mapper": [
                    1641,
                    4809,
                    1638
                ],
                "grouper": [
                    1641,
                    1643,
                    1639
                ],
                "self.is_monotonic_increasing": [
                    1704,
                    5040,
                    1653,
                    2999,
                    2940
                ],
                "self._engine.is_monotonic_increasing": [
                    1670
                ],
                "self._engine.is_monotonic_decreasing": [
                    1687
                ],
                "self.is_unique": [
                    3490,
                    3779,
                    2265,
                    1735,
                    1704,
                    4744,
                    3282,
                    2260,
                    1721,
                    2907,
                    3486,
                    3327
                ],
                "self.is_monotonic_decreasing": [
                    1721,
                    5042
                ],
                "self._engine.is_unique": [
                    1731
                ],
                "is_datetime_array": [
                    1809
                ],
                "ensure_object": [
                    1809
                ],
                "d.update": [
                    1816
                ],
                "_new_Index": [
                    1817
                ],
                "state": [
                    1824,
                    1825,
                    1826,
                    1829,
                    1831,
                    1832,
                    1838,
                    1839
                ],
                "state.pop": [
                    1825
                ],
                "state.items": [
                    1826
                ],
                "nd_state": [
                    1832,
                    1833,
                    1834
                ],
                "own_state": [
                    1832,
                    1835
                ],
                "np.empty": [
                    1863,
                    1833,
                    1838,
                    3378,
                    3647
                ],
                "np.ndarray.__setstate__": [
                    1834,
                    1839
                ],
                "self._reset_identity": [
                    1842
                ],
                "_unpickle_compat": [
                    1846
                ],
                "__setstate__": [
                    1846
                ],
                "_na_value": [
                    1851
                ],
                "np.bool_": [
                    1863
                ],
                "values.fill": [
                    1864
                ],
                "w": [
                    1870,
                    1871
                ],
                "self._isnan.nonzero": [
                    1870
                ],
                "self._isnan": [
                    2016,
                    1870,
                    1940,
                    1881,
                    2045
                ],
                "np.int64": [
                    1873
                ],
                "bool": [
                    1881,
                    4207
                ],
                "self._isnan.any": [
                    1881
                ],
                "isnull": [
                    1942
                ],
                "self.isna": [
                    1988
                ],
                "notnull": [
                    1990
                ],
                "notna": [
                    1990
                ],
                "self._assert_can_do_op": [
                    2014
                ],
                "value": [
                    2016,
                    4096,
                    4298,
                    4305,
                    4690,
                    2014,
                    4088,
                    4094
                ],
                "self.hasnans": [
                    2044,
                    2270,
                    2015
                ],
                "self.putmask": [
                    2016
                ],
                "downcast": [
                    2017
                ],
                "how": [
                    3461,
                    3594,
                    3470,
                    3598,
                    3472,
                    3482,
                    3610,
                    3484,
                    3488,
                    3493,
                    3497,
                    3502,
                    3507,
                    3509,
                    3511,
                    3770,
                    3515,
                    3781,
                    3785,
                    3789,
                    3792,
                    3796,
                    3798,
                    3672,
                    3800,
                    3802,
                    3683,
                    3564,
                    3443,
                    3448,
                    2041,
                    2042,
                    3453
                ],
                "unique": [
                    2245,
                    2078
                ],
                "super": [
                    2183,
                    4809,
                    2127,
                    3930,
                    2078
                ],
                "drop_duplicates": [
                    2127
                ],
                "keep": [
                    2183,
                    2127
                ],
                "duplicated": [
                    2183
                ],
                "self.duplicated": [
                    2245
                ],
                "dropna": [
                    2268,
                    2260
                ],
                "self.unique": [
                    2266
                ],
                "NotImplementedError": [
                    2272,
                    4916,
                    4576,
                    3678
                ],
                "self.intersection": [
                    3514,
                    2306
                ],
                "self.union": [
                    2309,
                    3518
                ],
                "self.symmetric_difference": [
                    2312
                ],
                "__bool__": [
                    2322
                ],
                "__nonzero__": [
                    2322
                ],
                "get_op_result_name": [
                    2517,
                    3814,
                    2333,
                    2766
                ],
                "this": [
                    2660,
                    3480,
                    2662,
                    2567,
                    2728,
                    2569,
                    2665,
                    2666,
                    2730,
                    2735,
                    2673,
                    2737,
                    2357,
                    2901,
                    2903,
                    2360,
                    3482
                ],
                "self.astype": [
                    2567,
                    4305,
                    2901,
                    2357,
                    4757,
                    3480
                ],
                "Index.union": [
                    2360
                ],
                "sort": [
                    3520,
                    2722,
                    2437,
                    2502,
                    2598,
                    2441,
                    2569,
                    2379,
                    2443,
                    2667,
                    2382,
                    2744,
                    2481,
                    2360,
                    2651,
                    2559
                ],
                "self._validate_sort_keyword": [
                    2722,
                    2651,
                    2437,
                    2559
                ],
                "self._assert_can_do_setop": [
                    2560,
                    2723,
                    2652,
                    2438
                ],
                "self._is_compatible_with_other": [
                    2440
                ],
                "self._union_incompatible_dtypes": [
                    2441
                ],
                "self._union": [
                    2443
                ],
                "self.equals": [
                    2465,
                    2563,
                    3769,
                    4346,
                    3323,
                    2654
                ],
                "self._get_reconciled_name_object": [
                    2466,
                    2564
                ],
                "other._get_reconciled_name_object": [
                    2469
                ],
                "lvals": [
                    2497,
                    2593,
                    2500,
                    2473,
                    2475,
                    2573,
                    2575,
                    2483,
                    2486,
                    2583,
                    2489,
                    2589
                ],
                "rvals": [
                    2496,
                    2593,
                    2477,
                    2479,
                    2577,
                    2483,
                    2579,
                    2583,
                    2490,
                    2589
                ],
                "other._ndarray_values": [
                    3777,
                    3618,
                    2477,
                    2577,
                    3610
                ],
                "other._values": [
                    2579,
                    2479
                ],
                "self.is_monotonic": [
                    2481,
                    3499,
                    3491,
                    2581
                ],
                "other.is_monotonic": [
                    2481,
                    3499,
                    3491,
                    2581
                ],
                "self._outer_indexer": [
                    3793,
                    2483,
                    3803
                ],
                "value_set": [
                    2489,
                    2490
                ],
                "set": [
                    2489,
                    3541,
                    3542
                ],
                "result.extend": [
                    2490
                ],
                "indexer": [
                    3328,
                    2946,
                    2948,
                    2950,
                    2951,
                    2824,
                    2825,
                    2953,
                    2827,
                    3337,
                    4746,
                    4747,
                    3343,
                    5259,
                    5260,
                    5264,
                    5265,
                    2969,
                    2970,
                    2971,
                    2589,
                    2590,
                    2593,
                    2594,
                    2977,
                    2596,
                    3236,
                    3237,
                    2983,
                    2984,
                    3238,
                    2730,
                    3364,
                    3244,
                    2733,
                    3246,
                    3366,
                    3370,
                    3375,
                    3378,
                    3365,
                    2740,
                    3000,
                    3386,
                    2492,
                    2493,
                    3006,
                    2495,
                    2496,
                    3007,
                    3010,
                    3011,
                    3012,
                    3132,
                    3134,
                    3137,
                    3143,
                    3395,
                    3398,
                    3147,
                    3402,
                    3282,
                    3168,
                    2913,
                    3169,
                    2915,
                    2662,
                    2663,
                    2665,
                    2928,
                    2930,
                    3319,
                    4729,
                    4730,
                    3324
                ],
                "self.get_indexer": [
                    3328,
                    3236,
                    3527,
                    2824,
                    4745,
                    5259,
                    2992,
                    2993,
                    2969,
                    2492
                ],
                "nonzero": [
                    2663,
                    3660,
                    2733,
                    2740,
                    2493,
                    2590
                ],
                "other_diff": [
                    2496,
                    2497
                ],
                "algos.take_nd": [
                    2496,
                    3698,
                    3748
                ],
                "concat_compat": [
                    2497,
                    2743
                ],
                "sorting.safe_sort": [
                    2504,
                    2746,
                    2669,
                    2599
                ],
                "sorting": [
                    2504,
                    2746,
                    2669,
                    2599
                ],
                "RuntimeWarning": [
                    2509
                ],
                "self._wrap_setop_result": [
                    2584,
                    2514
                ],
                "ensure_index": [
                    2561,
                    3363,
                    2884,
                    4717,
                    3314,
                    3451
                ],
                "other.astype": [
                    2568,
                    3481,
                    4757
                ],
                "this.intersection": [
                    2569
                ],
                "self._inner_indexer": [
                    3801,
                    3790,
                    2583
                ],
                "get_indexer": [
                    2589
                ],
                "indexer.take": [
                    2733,
                    2590,
                    2663
                ],
                "algos.unique1d": [
                    2593
                ],
                "get_indexer_non_unique": [
                    2593
                ],
                "other.take": [
                    2596
                ],
                "taken.values": [
                    2599
                ],
                "other.name": [
                    2600,
                    2606
                ],
                "taken.name": [
                    2607
                ],
                "result_name": [
                    2658,
                    2725,
                    2726,
                    2764,
                    2766,
                    2767,
                    2673,
                    2751
                ],
                "self._convert_can_do_setop": [
                    2658,
                    2724
                ],
                "self._get_unique_index": [
                    2728,
                    2660
                ],
                "this.get_indexer": [
                    2730,
                    2662,
                    2903
                ],
                "label_diff": [
                    2665,
                    2666
                ],
                "np.setdiff1d": [
                    2665,
                    2734
                ],
                "np.arange": [
                    4453,
                    3398,
                    2665,
                    3370,
                    2735,
                    3386,
                    3387,
                    3709
                ],
                "this.size": [
                    2665,
                    2735
                ],
                "the_diff": [
                    2754,
                    2666,
                    2669,
                    2673,
                    2743,
                    2746
                ],
                "this.values.take": [
                    2737,
                    2666
                ],
                "this.values": [
                    2737,
                    2666
                ],
                "this._shallow_copy": [
                    2673
                ],
                "result_name_update": [
                    2724,
                    2726
                ],
                "other._get_unique_index": [
                    2729
                ],
                "common_indexer": [
                    2733,
                    2735
                ],
                "left_indexer": [
                    3713,
                    3718,
                    3723,
                    3724,
                    3732,
                    3733,
                    3738,
                    3755,
                    2734,
                    3758,
                    2992,
                    2737,
                    3759,
                    2996,
                    3764,
                    3002,
                    3688,
                    3691,
                    3692,
                    3709
                ],
                "left_diff": [
                    2737,
                    2743
                ],
                "right_indexer": [
                    3748,
                    3752,
                    3755,
                    2993,
                    3761,
                    3762,
                    2740,
                    2741,
                    2997,
                    3764,
                    3001,
                    3003
                ],
                "right_diff": [
                    2741,
                    2743
                ],
                "other.values.take": [
                    2741
                ],
                "other.values": [
                    2741
                ],
                "attribs": [
                    2752,
                    2753,
                    2754,
                    4277,
                    4278,
                    4282,
                    2750,
                    2751
                ],
                "self._shallow_copy_with_infer": [
                    2754,
                    3974,
                    3401,
                    5236,
                    4282
                ],
                "method": [
                    3329,
                    2946,
                    2948,
                    3332,
                    2824,
                    2963,
                    2966,
                    2883,
                    2941,
                    2814,
                    2897,
                    2904,
                    2912,
                    2913,
                    2914,
                    3317,
                    5629,
                    5630,
                    2943
                ],
                "tolerance": [
                    2913,
                    3329,
                    2915,
                    3011,
                    2885,
                    2886,
                    2917,
                    2824,
                    2949,
                    2951,
                    2897,
                    2934,
                    2935,
                    2904,
                    2937,
                    3005,
                    3006,
                    2815
                ],
                "self._engine.get_loc": [
                    2821,
                    2823
                ],
                "key": [
                    4994,
                    4995,
                    2821,
                    2823,
                    2824,
                    2829,
                    3088,
                    3089,
                    3090,
                    3094,
                    4637,
                    4645,
                    3111,
                    3112,
                    3113,
                    4650,
                    4651,
                    4654,
                    4149,
                    4151,
                    4664,
                    3132,
                    3261,
                    3134,
                    4669,
                    4670,
                    4677,
                    4678,
                    3143,
                    4679,
                    4173,
                    4690,
                    3033,
                    3042,
                    3044,
                    4197,
                    3046,
                    4198,
                    4199,
                    4201,
                    4204,
                    4973,
                    4206,
                    4207,
                    4975,
                    4209,
                    4210,
                    3059,
                    4976,
                    3061,
                    4977,
                    3063,
                    4980,
                    3065,
                    4989,
                    4991
                ],
                "self._maybe_cast_indexer": [
                    2823
                ],
                "indexer.ndim": [
                    2825
                ],
                "indexer.size": [
                    2825
                ],
                "loc": [
                    5216,
                    4417,
                    4418,
                    4419,
                    2827,
                    2828,
                    2830,
                    5235,
                    4413
                ],
                "indexer.item": [
                    2827
                ],
                "missing.clean_reindex_fill_method": [
                    2883
                ],
                "missing": [
                    2883,
                    3364,
                    3337,
                    3369,
                    3372,
                    3373,
                    4729,
                    4730
                ],
                "target": [
                    3329,
                    2946,
                    2948,
                    2951,
                    3337,
                    4745,
                    3339,
                    3340,
                    3341,
                    4746,
                    3343,
                    2969,
                    2971,
                    3363,
                    3364,
                    3373,
                    2992,
                    2993,
                    2995,
                    2996,
                    2997,
                    3383,
                    3006,
                    3010,
                    2884,
                    2886,
                    2891,
                    2892,
                    2894,
                    2895,
                    2900,
                    2902,
                    2904,
                    2913,
                    2915,
                    3303,
                    4727,
                    3306,
                    3308,
                    4717,
                    4718,
                    4719,
                    2928,
                    3312,
                    3314,
                    4722,
                    4723,
                    4725,
                    2935,
                    3320,
                    3323,
                    2940
                ],
                "self._convert_tolerance": [
                    2886
                ],
                "target.is_boolean": [
                    2891
                ],
                "self.is_numeric": [
                    2891
                ],
                "np.repeat": [
                    3456,
                    2892,
                    3464
                ],
                "target.size": [
                    2892,
                    2935
                ],
                "pself": [
                    4718,
                    4719,
                    2896,
                    2894,
                    2895,
                    4720
                ],
                "ptarget": [
                    4718,
                    4719,
                    2894,
                    2897,
                    2895,
                    4720
                ],
                "self._maybe_promote": [
                    4718,
                    2894
                ],
                "pself.get_indexer": [
                    2896
                ],
                "limit": [
                    2913,
                    2946,
                    2915,
                    2948,
                    3329,
                    3332,
                    2922,
                    2960,
                    2897,
                    2992,
                    2993,
                    2904
                ],
                "target.dtype": [
                    2900
                ],
                "target.astype": [
                    2902
                ],
                "InvalidIndexError": [
                    2908,
                    4670,
                    4679
                ],
                "self._get_fill_indexer": [
                    2913
                ],
                "self._get_nearest_indexer": [
                    2915
                ],
                "self._engine.get_indexer": [
                    2928
                ],
                "target._ndarray_values": [
                    2928,
                    4727,
                    2946,
                    2951
                ],
                "tolerance.size": [
                    2935
                ],
                "target.is_monotonic_increasing": [
                    2940
                ],
                "self._engine.get_pad_indexer": [
                    2942
                ],
                "self._engine.get_backfill_indexer": [
                    2944
                ],
                "self._get_fill_indexer_searchsorted": [
                    2948
                ],
                "self._filter_indexer_tolerance": [
                    3006,
                    2950
                ],
                "side": [
                    5090,
                    5083,
                    5041,
                    5073,
                    5105,
                    5076,
                    5109,
                    2966,
                    5047,
                    5114,
                    2971,
                    2972
                ],
                "nonexact": [
                    2977,
                    2970,
                    2971
                ],
                "self._searchsorted_monotonic": [
                    5090,
                    2971
                ],
                "left_distances": [
                    3001,
                    2996
                ],
                "abs": [
                    3010,
                    2996,
                    2997
                ],
                "right_distances": [
                    3001,
                    2997
                ],
                "operator.lt": [
                    5277,
                    2999
                ],
                "operator": [
                    5280,
                    5319,
                    5352,
                    5321,
                    5353,
                    5324,
                    5326,
                    5330,
                    5331,
                    5334,
                    2999,
                    5275,
                    5276,
                    5277,
                    5278,
                    5279
                ],
                "operator.le": [
                    5279,
                    2999
                ],
                "np.where": [
                    3011,
                    4451,
                    3249,
                    3000,
                    3967
                ],
                "distance": [
                    3010,
                    3011
                ],
                "kind": [
                    4993,
                    3083,
                    3086,
                    3088,
                    3089,
                    3090,
                    4113,
                    3229,
                    5022,
                    3104,
                    5029,
                    3111,
                    3112,
                    3113,
                    5171,
                    5177,
                    3137,
                    5071,
                    3030,
                    3032,
                    3033,
                    5083,
                    4957,
                    3168,
                    3042,
                    3046,
                    3061,
                    4987
                ],
                "self._validate_indexer": [
                    3111,
                    3112,
                    3113,
                    3088,
                    3089,
                    3090,
                    3033
                ],
                "is_float": [
                    3042,
                    5028,
                    4973,
                    3046
                ],
                "self.is_floating": [
                    5029,
                    3043,
                    4973,
                    3231
                ],
                "self._invalid_indexer": [
                    4994,
                    3044,
                    5030,
                    5035,
                    3059,
                    3063
                ],
                "is_integer": [
                    5034,
                    4650,
                    3061,
                    3098,
                    4991
                ],
                "self.holds_integer": [
                    4648,
                    4660,
                    5029,
                    3062
                ],
                "slice": [
                    4417,
                    4965,
                    3110,
                    4201,
                    3082,
                    3087,
                    5108
                ],
                "key.start": [
                    3088,
                    3094,
                    3111
                ],
                "key.stop": [
                    3112,
                    3089,
                    3094
                ],
                "key.step": [
                    3113,
                    3090,
                    3094
                ],
                "start": [
                    3137,
                    5155,
                    5159,
                    5161,
                    4957,
                    3122,
                    3123,
                    5170,
                    5171,
                    3094,
                    3100,
                    3101
                ],
                "stop": [
                    3137,
                    3124,
                    3125,
                    3094,
                    3100,
                    3101
                ],
                "step": [
                    3137,
                    4965,
                    3094,
                    4957,
                    5151
                ],
                "is_null_slicer": [
                    3131,
                    3100
                ],
                "is_index_slice": [
                    3139,
                    3109,
                    3101,
                    3102
                ],
                "is_int": [
                    3101
                ],
                "is_positional": [
                    3120,
                    3126,
                    3133,
                    3102
                ],
                "self.is_integer": [
                    3140,
                    3109,
                    3102
                ],
                "self.is_mixed": [
                    3120
                ],
                "self.get_loc": [
                    4645,
                    3123,
                    3125,
                    4413,
                    5087
                ],
                "self.slice_indexer": [
                    3137
                ],
                "keyarr": [
                    3168,
                    3169,
                    3232,
                    3236,
                    3208,
                    3230,
                    3249,
                    3250,
                    3188,
                    3189,
                    3163,
                    3164,
                    3166
                ],
                "self._convert_index_indexer": [
                    3164
                ],
                "self._convert_arr_indexer": [
                    3166
                ],
                "self._convert_list_indexer": [
                    3168
                ],
                "maybe_convert_indices": [
                    3246
                ],
                "form": [
                    4994,
                    3261
                ],
                "preserve_names": [
                    3339,
                    3303
                ],
                "_ensure_has_len": [
                    3306
                ],
                "attrs.pop": [
                    3310
                ],
                "_": [
                    4746,
                    3651,
                    3319
                ],
                "self._join_level": [
                    3447,
                    3597,
                    3319
                ],
                "self.get_indexer_non_unique": [
                    3337,
                    4746,
                    3364
                ],
                "target.nlevels": [
                    3339
                ],
                "target.name": [
                    3339,
                    3341
                ],
                "target.copy": [
                    3340
                ],
                "check": [
                    3395,
                    3365,
                    3366,
                    3399,
                    3374,
                    3375,
                    3376
                ],
                "new_labels": [
                    3366,
                    3401,
                    3378,
                    3379,
                    3380
                ],
                "self.take": [
                    3398,
                    3366,
                    4783,
                    3375,
                    4507
                ],
                "new_indexer": [
                    3398,
                    3367,
                    3399,
                    3402,
                    3386,
                    3387,
                    3388
                ],
                "length": [
                    3376,
                    3370,
                    3374
                ],
                "missing_labels": [
                    3380,
                    3373
                ],
                "target.take": [
                    3373
                ],
                "missing_indexer": [
                    3388,
                    3380,
                    3374
                ],
                "ensure_int64": [
                    3650,
                    3661,
                    3662,
                    3374,
                    3376,
                    3695
                ],
                "cur_labels": [
                    3387,
                    3379,
                    3375
                ],
                "cur_indexer": [
                    3376,
                    3387,
                    3379
                ],
                "target.is_unique": [
                    3383
                ],
                "self_is_mi": [
                    3552,
                    3590,
                    3432,
                    3437,
                    3446,
                    3549
                ],
                "other_is_mi": [
                    3552,
                    3433,
                    3437,
                    3446,
                    3550
                ],
                "other.names": [
                    3440,
                    3596,
                    3542
                ],
                "self._join_multi": [
                    3443
                ],
                "return_indexers": [
                    3488,
                    3523,
                    3493,
                    3622,
                    3463,
                    3497,
                    3757,
                    3502,
                    3598,
                    3472,
                    3474,
                    3443,
                    3448,
                    3482,
                    3771,
                    3806,
                    3455
                ],
                "join_index": [
                    3456,
                    3457,
                    3459,
                    3462,
                    3464,
                    3465,
                    3467,
                    3740,
                    3616,
                    3618,
                    3620,
                    3749,
                    3623,
                    3752,
                    3625,
                    3508,
                    3764,
                    3510,
                    3766,
                    3514,
                    3518,
                    3521,
                    3524,
                    3782,
                    3527,
                    3528,
                    3786,
                    3531,
                    3532,
                    3534,
                    3790,
                    3791,
                    3793,
                    3794,
                    3797,
                    3799,
                    3801,
                    3803,
                    3804,
                    3809,
                    3811,
                    3689,
                    3692,
                    3454
                ],
                "rindexer": [
                    3456,
                    3457,
                    3529,
                    3531,
                    3532
                ],
                "other._shallow_copy": [
                    3462
                ],
                "lindexer": [
                    3525,
                    3527,
                    3464,
                    3465,
                    3532
                ],
                "self._join_precedence": [
                    3469
                ],
                "other._join_precedence": [
                    3469
                ],
                "get": [
                    3672,
                    3594,
                    3470
                ],
                "other.join": [
                    3471
                ],
                "y": [
                    3475,
                    3476
                ],
                "z": [
                    3475,
                    3476
                ],
                "this.join": [
                    3482
                ],
                "_validate_join_method": [
                    3484
                ],
                "other.is_unique": [
                    3490,
                    3779,
                    3486
                ],
                "self._join_non_unique": [
                    3496,
                    3487
                ],
                "self._join_monotonic": [
                    3492,
                    3501
                ],
                "join_index.sort_values": [
                    3521
                ],
                "other.get_indexer": [
                    3531
                ],
                "self_names": [
                    3555,
                    3541,
                    3543
                ],
                "com.not_none": [
                    3541,
                    3542
                ],
                "other_names": [
                    3556,
                    3542,
                    3543
                ],
                "overlap": [
                    3585,
                    3555,
                    3556,
                    3543,
                    3546
                ],
                "ldrop_names": [
                    3570,
                    3555,
                    3558
                ],
                "rdrop_names": [
                    3570,
                    3556,
                    3559
                ],
                "self_jnlevels": [
                    3563,
                    3558
                ],
                "self.droplevel": [
                    3558
                ],
                "other_jnlevels": [
                    3564,
                    3559
                ],
                "other.droplevel": [
                    3559
                ],
                "join_idx": [
                    3563,
                    3573
                ],
                "lidx": [
                    3809,
                    3783,
                    3563,
                    3787,
                    3790,
                    3793,
                    3807,
                    3573,
                    3797,
                    3799,
                    3801,
                    3803,
                    3583
                ],
                "ridx": [
                    3808,
                    3809,
                    3784,
                    3563,
                    3788,
                    3790,
                    3793,
                    3573,
                    3797,
                    3799,
                    3801,
                    3803,
                    3583
                ],
                "self_jnlevels.join": [
                    3563
                ],
                "dropped_names": [
                    3570,
                    3573
                ],
                "levels": [
                    3578,
                    3572
                ],
                "codes": [
                    3578,
                    3572
                ],
                "_restore_dropped_levels_multijoin": [
                    3572
                ],
                "multi_join_idx": [
                    3577,
                    3581,
                    3583
                ],
                "multi_join_idx.remove_unused_levels": [
                    3581
                ],
                "jl": [
                    3585,
                    3596
                ],
                "flip_order": [
                    3589,
                    3592,
                    3754,
                    3601,
                    3669,
                    3670
                ],
                "other.names.index": [
                    3596
                ],
                "left_idx": [
                    3616,
                    3617,
                    3623,
                    3609,
                    3613
                ],
                "right_idx": [
                    3609,
                    3618,
                    3614,
                    3623
                ],
                "_get_join_indexers": [
                    3609
                ],
                "self._ndarray_values.take": [
                    3616
                ],
                "np.putmask": [
                    4298,
                    3618
                ],
                "other._ndarray_values.take": [
                    3618
                ],
                "self._wrap_joined_index": [
                    3794,
                    3804,
                    3620,
                    3791
                ],
                "size": [
                    3646
                ],
                "labels": [
                    3649,
                    3650,
                    3656,
                    3657,
                    5258,
                    5259,
                    3661,
                    5263,
                    3646
                ],
                "lab": [
                    3712,
                    3650,
                    3651,
                    3657,
                    3658,
                    3724,
                    3661,
                    3662,
                    3730,
                    3733
                ],
                "sorter": [
                    3651,
                    3652
                ],
                "libalgos.groupsort_indexer": [
                    3651,
                    3718
                ],
                "libalgos": [
                    3651,
                    3718
                ],
                "lab.max": [
                    3651
                ],
                "tic": [
                    3656,
                    3658,
                    3660
                ],
                "starts": [
                    3660,
                    3662
                ],
                "np.hstack": [
                    3660
                ],
                "lib.get_level_sorter": [
                    3662
                ],
                "left._get_level_number": [
                    3674
                ],
                "old_level": [
                    3696,
                    3682,
                    3675
                ],
                "left.levels": [
                    3705,
                    3675
                ],
                "right.is_unique": [
                    3677
                ],
                "new_level": [
                    3682,
                    3706
                ],
                "left_lev_indexer": [
                    3696,
                    3682,
                    3686,
                    3695
                ],
                "right_lev_indexer": [
                    3682,
                    3747,
                    3749
                ],
                "old_level.join": [
                    3682
                ],
                "keep_order": [
                    3708,
                    3687
                ],
                "_get_leaf_sorter": [
                    3691,
                    3732
                ],
                "left.codes": [
                    3699,
                    3691,
                    3702
                ],
                "rev_indexer": [
                    3696,
                    3699
                ],
                "lib.get_reverse_indexer": [
                    3696
                ],
                "new_lev_codes": [
                    3717,
                    3719,
                    3727,
                    3698,
                    3703,
                    3710
                ],
                "np.intp": [
                    3709
                ],
                "mask.all": [
                    3728,
                    3711
                ],
                "ngroups": [
                    3717,
                    3719
                ],
                "new_lev_codes.max": [
                    3717
                ],
                "counts": [
                    3723,
                    3718
                ],
                "mask_all": [
                    3728,
                    3729,
                    3737
                ],
                "mask.nonzero": [
                    3738
                ],
                "left.names": [
                    3743
                ],
                "join_index.codes": [
                    3752,
                    3749
                ],
                "ret_index": [
                    3770,
                    3772,
                    3774
                ],
                "sv": [
                    3776,
                    3784,
                    3787,
                    3790,
                    3793,
                    3797,
                    3799,
                    3801,
                    3803
                ],
                "ov": [
                    3777,
                    3784,
                    3787,
                    3790,
                    3793,
                    3797,
                    3799,
                    3801,
                    3803
                ],
                "self._left_indexer_unique": [
                    3784,
                    3787
                ],
                "self._left_indexer": [
                    3797,
                    3799
                ],
                "joined": [
                    3815
                ],
                "Union": [
                    3843
                ],
                "self._internal_get_values": [
                    3923
                ],
                "memory_usage": [
                    3930
                ],
                "self._engine.sizeof": [
                    3933
                ],
                "IndexOpsMixin.memory_usage.__doc__": [
                    3928
                ],
                "IndexOpsMixin.memory_usage": [
                    3928
                ],
                "is_bool": [
                    3961
                ],
                "values.astype": [
                    3964
                ],
                "cond": [
                    3967
                ],
                "self._is_numeric_dtype": [
                    3969,
                    4071
                ],
                "np.any": [
                    3969,
                    5471
                ],
                "OverflowError": [
                    4016,
                    4152,
                    4978,
                    4007
                ],
                "cls.__name__": [
                    4027
                ],
                "repr": [
                    4027
                ],
                "item": [
                    5234,
                    5235,
                    4076,
                    4071
                ],
                "hash": [
                    4149
                ],
                "getitem": [
                    4194,
                    4204,
                    4210,
                    4199
                ],
                "self._data.__getitem__": [
                    4194
                ],
                "promote": [
                    4212,
                    4195,
                    4204
                ],
                "com.cast_scalar_indexer": [
                    4198
                ],
                "com.is_bool_indexer": [
                    4206
                ],
                "com.values_from_object": [
                    4329,
                    4653,
                    4654,
                    4209,
                    4690
                ],
                "self.is_categorical": [
                    4225
                ],
                "to_concat": [
                    4256,
                    4260,
                    4263,
                    4264,
                    4272,
                    4273,
                    4242,
                    4276,
                    4245,
                    4247,
                    4280,
                    4249,
                    4282,
                    4253
                ],
                "to_concat.append": [
                    4247
                ],
                "obj": [
                    4249,
                    4250,
                    4253
                ],
                "obj.name": [
                    4253
                ],
                "self._concat": [
                    4256
                ],
                "typs": [
                    4260,
                    4262
                ],
                "_concat.get_dtype_kinds": [
                    4260
                ],
                "_concat": [
                    4260
                ],
                "self._concat_same_dtype": [
                    4263
                ],
                "Index._concat_same_dtype": [
                    4264
                ],
                "klasses": [
                    4273,
                    4271
                ],
                "ABCDatetimeIndex": [
                    4271
                ],
                "x.astype": [
                    4273
                ],
                "x._values": [
                    4280
                ],
                "np.concatenate": [
                    4282,
                    5235
                ],
                "self._convert_for_op": [
                    4298
                ],
                "err": [
                    5093,
                    4302
                ],
                "putmask": [
                    4305
                ],
                "self.is_": [
                    4317
                ],
                "other.equals": [
                    4325
                ],
                "array_equivalent": [
                    4328
                ],
                "c": [
                    4349,
                    4350
                ],
                "self._comparables": [
                    4350
                ],
                "label": [
                    5090,
                    5028,
                    5030,
                    5034,
                    5035,
                    5037,
                    5041,
                    5079,
                    5047,
                    5083,
                    4413,
                    5087
                ],
                "loc.indices": [
                    4418
                ],
                "locs": [
                    4456,
                    4450,
                    4451,
                    4453
                ],
                "searchsorted": [
                    4450,
                    5046
                ],
                "where.values": [
                    4456,
                    4450
                ],
                "where": [
                    4456,
                    4450
                ],
                "first": [
                    4456,
                    4455
                ],
                "mask.argmax": [
                    4455
                ],
                "_as": [
                    4505,
                    4507,
                    4510,
                    4503
                ],
                "self.argsort": [
                    4503
                ],
                "sorted_index": [
                    4512,
                    4507,
                    4510
                ],
                "return_indexer": [
                    4509
                ],
                "self.asi8": [
                    4613
                ],
                "result.argsort": [
                    4616
                ],
                "args": [
                    4616
                ],
                "s": [
                    4646,
                    4651,
                    4653,
                    4658,
                    4664,
                    4636,
                    4637
                ],
                "series": [
                    4658,
                    4636,
                    4653
                ],
                "iloc": [
                    4645,
                    4646
                ],
                "self.is_boolean": [
                    4648,
                    4660
                ],
                "self._convert_scalar_indexer": [
                    4656
                ],
                "self._engine.get_value": [
                    4658
                ],
                "series.dtype": [
                    4658
                ],
                "libindex.get_value_at": [
                    4664
                ],
                "e1": [
                    4672,
                    4674
                ],
                "self._engine.set_value": [
                    4689
                ],
                "arr": [
                    4690
                ],
                "pself.get_indexer_non_unique": [
                    4720
                ],
                "is_categorical": [
                    4722
                ],
                "tgt_values": [
                    4729,
                    4723,
                    4725,
                    4727
                ],
                "self.is_all_dates": [
                    4724
                ],
                "target.asi8": [
                    4725
                ],
                "self._engine.get_indexer_non_unique": [
                    4729
                ],
                "values.values": [
                    4778
                ],
                "ensure_categorical": [
                    4779
                ],
                "values._reverse_indexer": [
                    4780
                ],
                "result.items": [
                    4783
                ],
                "new_values": [
                    4809,
                    4814,
                    4818,
                    4821,
                    4824,
                    4828
                ],
                "_map_values": [
                    4809
                ],
                "na_action": [
                    4809
                ],
                "new_values.size": [
                    4824,
                    4814
                ],
                "attributes.get": [
                    4817,
                    4818
                ],
                "algos.isin": [
                    4911
                ],
                "start_slice": [
                    4960,
                    4965,
                    5196,
                    5169,
                    5171,
                    5172,
                    5173,
                    5203,
                    5204,
                    5206,
                    4957
                ],
                "end_slice": [
                    4962,
                    4965,
                    5196,
                    5201,
                    5202,
                    5206,
                    5175,
                    5177,
                    5178,
                    5179,
                    4957
                ],
                "self.slice_locs": [
                    4957
                ],
                "end": [
                    5155,
                    5159,
                    5162,
                    5176,
                    5177,
                    4957
                ],
                "AssertionError": [
                    4961,
                    4963
                ],
                "ckey": [
                    4976,
                    4977,
                    4975
                ],
                "self.searchsorted": [
                    5041
                ],
                "pos": [
                    5049,
                    5046
                ],
                "original_label": [
                    5105,
                    5079
                ],
                "self._maybe_cast_slice_bound": [
                    5083
                ],
                "slc": [
                    5095,
                    5098,
                    5099,
                    5101,
                    5102,
                    5108,
                    5110,
                    5112,
                    5115,
                    5117,
                    5087
                ],
                "lib.maybe_booleans_to_slice": [
                    5099
                ],
                "slc.view": [
                    5099
                ],
                "lib.maybe_indices_to_slice": [
                    5101
                ],
                "slc.astype": [
                    5101
                ],
                "slc.start": [
                    5110
                ],
                "slc.stop": [
                    5112
                ],
                "inc": [
                    5153,
                    5181,
                    5151
                ],
                "datetime": [
                    5159
                ],
                "ts_start": [
                    5161,
                    5166
                ],
                "Timestamp": [
                    5161,
                    5162
                ],
                "ts_end": [
                    5162,
                    5166
                ],
                "tz_compare": [
                    5166
                ],
                "ts_start.tzinfo": [
                    5166
                ],
                "ts_end.tzinfo": [
                    5166
                ],
                "self.get_slice_bound": [
                    5177,
                    5171
                ],
                "np.delete": [
                    5216
                ],
                "_self": [
                    5233,
                    5235
                ],
                "self._coerce_scalar_to_index": [
                    5234
                ],
                "arr_dtype": [
                    5257,
                    5258
                ],
                "com.index_labels_to_array": [
                    5258
                ],
                "errors": [
                    5262
                ],
                "self.delete": [
                    5265
                ],
                "cls.__eq__": [
                    5275
                ],
                "_make_comparison_op": [
                    5280,
                    5275,
                    5276,
                    5277,
                    5278,
                    5279
                ],
                "operator.eq": [
                    5275
                ],
                "cls.__ne__": [
                    5276
                ],
                "operator.ne": [
                    5276
                ],
                "cls.__lt__": [
                    5277
                ],
                "cls.__gt__": [
                    5278
                ],
                "operator.gt": [
                    5278
                ],
                "cls.__le__": [
                    5279
                ],
                "cls.__ge__": [
                    5280
                ],
                "operator.ge": [
                    5280
                ],
                "cls.__add__": [
                    5319,
                    5287
                ],
                "make_invalid_op": [
                    5287,
                    5288,
                    5289,
                    5290,
                    5291,
                    5292,
                    5299,
                    5300,
                    5301,
                    5302,
                    5303,
                    5304,
                    5305,
                    5306,
                    5307,
                    5308,
                    5309,
                    5310,
                    5311,
                    5312,
                    5479,
                    5480
                ],
                "cls.__radd__": [
                    5288,
                    5320
                ],
                "cls.__iadd__": [
                    5289
                ],
                "cls.__sub__": [
                    5321,
                    5290
                ],
                "cls.__rsub__": [
                    5322,
                    5291
                ],
                "cls.__isub__": [
                    5292
                ],
                "cls.__pow__": [
                    5299,
                    5324
                ],
                "cls.__rpow__": [
                    5323,
                    5300
                ],
                "cls.__mul__": [
                    5301,
                    5334
                ],
                "cls.__rmul__": [
                    5302,
                    5335
                ],
                "cls.__floordiv__": [
                    5331,
                    5303
                ],
                "cls.__rfloordiv__": [
                    5304,
                    5332
                ],
                "cls.__truediv__": [
                    5305,
                    5326
                ],
                "cls.__rtruediv__": [
                    5306,
                    5327
                ],
                "cls.__mod__": [
                    5330,
                    5307
                ],
                "cls.__divmod__": [
                    5308,
                    5333
                ],
                "cls.__neg__": [
                    5352,
                    5309
                ],
                "cls.__pos__": [
                    5353,
                    5310
                ],
                "cls.__abs__": [
                    5354,
                    5311
                ],
                "cls.__inv__": [
                    5312,
                    5355
                ],
                "_make_arithmetic_op": [
                    5319,
                    5320,
                    5321,
                    5322,
                    5323,
                    5324,
                    5326,
                    5327,
                    5330,
                    5331,
                    5332,
                    5333,
                    5334,
                    5335
                ],
                "operator.add": [
                    5319
                ],
                "ops.radd": [
                    5320
                ],
                "operator.sub": [
                    5321
                ],
                "ops.rsub": [
                    5322
                ],
                "ops.rpow": [
                    5323
                ],
                "operator.pow": [
                    5324
                ],
                "operator.truediv": [
                    5326
                ],
                "ops.rtruediv": [
                    5327
                ],
                "operator.mod": [
                    5330
                ],
                "operator.floordiv": [
                    5331
                ],
                "ops.rfloordiv": [
                    5332
                ],
                "divmod": [
                    5333
                ],
                "operator.mul": [
                    5334
                ],
                "ops.rmul": [
                    5335
                ],
                "_evaluate_numeric_unary.__name__": [
                    5349
                ],
                "_evaluate_numeric_unary": [
                    5349,
                    5350
                ],
                "opstr": [
                    5349
                ],
                "_make_evaluate_unary": [
                    5352,
                    5353,
                    5354,
                    5355
                ],
                "operator.neg": [
                    5352
                ],
                "operator.pos": [
                    5353
                ],
                "np.abs": [
                    5354
                ],
                "cls._add_numeric_methods_unary": [
                    5359
                ],
                "cls._add_numeric_methods_binary": [
                    5360
                ],
                "_doc": [
                    5452,
                    5367
                ],
                "dedent": [
                    5424,
                    5382
                ],
                "f": [
                    5454
                ],
                "result.ndim": [
                    5457
                ],
                "result.dtype.type": [
                    5460
                ],
                "result.dtype": [
                    5460
                ],
                "result.item": [
                    5460
                ],
                "Substitution": [
                    5450
                ],
                "desc": [
                    5450
                ],
                "logical_func.__name__": [
                    5464
                ],
                "logical_func": [
                    5464,
                    5465
                ],
                "cls.all": [
                    5467,
                    5479
                ],
                "_make_logical_function": [
                    5467,
                    5470
                ],
                "np.all": [
                    5468
                ],
                "cls.any": [
                    5480,
                    5470
                ],
                "self._values.shape": [
                    5490
                ],
                "Index._add_numeric_methods_disabled": [
                    5493
                ],
                "Index._add_logical_methods": [
                    5494
                ],
                "Index._add_comparison_methods": [
                    5495
                ],
                "sequences": [
                    5536,
                    5531,
                    5534
                ],
                "MultiIndex.from_arrays": [
                    5536,
                    5592
                ],
                "index_like": [
                    5601,
                    5571,
                    5603,
                    5573,
                    5574,
                    5575,
                    5576,
                    5578,
                    5579,
                    5583,
                    5584,
                    5585,
                    5587,
                    5594
                ],
                "index_like.copy": [
                    5573
                ],
                "index_like.name": [
                    5576
                ],
                "converted": [
                    5592,
                    5594,
                    5587,
                    5589
                ],
                "all_arrays": [
                    5587,
                    5589
                ],
                "lib.clean_index_list": [
                    5587
                ],
                "seq": [
                    5611,
                    5613,
                    5615
                ],
                "trimmed": [
                    5624,
                    5625,
                    5622,
                    5623
                ],
                "strings": [
                    5622,
                    5623
                ],
                "n": [
                    5636
                ]
            },
            "filtered_variables_in_file": {
                "__all__": [
                    86
                ],
                "_unsortable_types": [
                    88
                ],
                "_index_doc_kwargs": [
                    2881,
                    2074,
                    808,
                    4715,
                    4147,
                    4630,
                    90,
                    890
                ],
                "_index_shared_docs": [
                    899,
                    2051,
                    4997,
                    3206,
                    5382,
                    3081,
                    3210,
                    4618,
                    780,
                    2832,
                    4115,
                    4630,
                    921,
                    2074,
                    3226,
                    5020,
                    545,
                    808,
                    560,
                    5424,
                    4147,
                    3191,
                    2881,
                    1992,
                    3017,
                    5451,
                    1613,
                    3407,
                    721,
                    851,
                    2772,
                    3028,
                    4693,
                    2519,
                    2012,
                    3936,
                    98,
                    1635,
                    3171,
                    3430,
                    2023,
                    746,
                    4715,
                    3953,
                    3186,
                    2039,
                    890,
                    3067,
                    2812,
                    2557
                ],
                "other": [
                    2560,
                    2561,
                    2563,
                    2564,
                    2566,
                    3591,
                    2568,
                    2569,
                    3596,
                    3598,
                    2576,
                    2577,
                    2579,
                    2581,
                    2584,
                    3610,
                    3618,
                    2596,
                    3620,
                    2600,
                    2606,
                    3664,
                    3667,
                    2652,
                    2654,
                    2658,
                    2662,
                    103,
                    104,
                    107,
                    108,
                    109,
                    624,
                    113,
                    117,
                    121,
                    129,
                    134,
                    4753,
                    4754,
                    4244,
                    4245,
                    4757,
                    4247,
                    4758,
                    2723,
                    2724,
                    2729,
                    2730,
                    2741,
                    3769,
                    3770,
                    3777,
                    3779,
                    2757,
                    2762,
                    2763,
                    3786,
                    2766,
                    2767,
                    3791,
                    3794,
                    3804,
                    4317,
                    4320,
                    4323,
                    4325,
                    3814,
                    2281,
                    4329,
                    2285,
                    2290,
                    2294,
                    2297,
                    4346,
                    4349,
                    2303,
                    4353,
                    2306,
                    2309,
                    2312,
                    2333,
                    2359,
                    2360,
                    2376,
                    3433,
                    3440,
                    3443,
                    3955,
                    3956,
                    3448,
                    3961,
                    3451,
                    3453,
                    3967,
                    2438,
                    3462,
                    2440,
                    2441,
                    2443,
                    3469,
                    3471,
                    3479,
                    3481,
                    3482,
                    3486,
                    3488,
                    2465,
                    2466,
                    3490,
                    3491,
                    2469,
                    3493,
                    3497,
                    3499,
                    2476,
                    2477,
                    3502,
                    2479,
                    2481,
                    3510,
                    3514,
                    2492,
                    3518,
                    3528,
                    3531,
                    2514,
                    2517,
                    3542,
                    3550,
                    3559,
                    3573
                ],
                "np.ndarray": [
                    352,
                    3840,
                    3843,
                    103,
                    5095,
                    1834,
                    5102,
                    1839,
                    5456,
                    4051
                ],
                "np": [
                    3456,
                    3840,
                    3969,
                    3843,
                    517,
                    4615,
                    3464,
                    393,
                    1039,
                    402,
                    659,
                    148,
                    1050,
                    3616,
                    3618,
                    2297,
                    1833,
                    1834,
                    3370,
                    1838,
                    1839,
                    2734,
                    2735,
                    3249,
                    2995,
                    3378,
                    3000,
                    3386,
                    1851,
                    3387,
                    829,
                    4282,
                    1599,
                    3647,
                    3011,
                    453,
                    3398,
                    1095,
                    1863,
                    1097,
                    4298,
                    2892,
                    3660,
                    5456,
                    1873,
                    4051,
                    341,
                    4058,
                    5468,
                    5471,
                    352,
                    5216,
                    4451,
                    4453,
                    103,
                    5095,
                    2665,
                    5354,
                    5102,
                    4207,
                    112,
                    5233,
                    4723,
                    116,
                    117,
                    2934,
                    5235,
                    761,
                    764,
                    3709,
                    3967
                ],
                "Index": [
                    773,
                    136,
                    137,
                    4250,
                    2589,
                    670,
                    4637,
                    5534,
                    2593,
                    420,
                    4264,
                    2359,
                    2360,
                    4280,
                    5571,
                    453,
                    5576,
                    2762,
                    2763,
                    717,
                    5456,
                    4051,
                    472,
                    601,
                    3163,
                    4828,
                    349,
                    352,
                    4320,
                    5347,
                    2020,
                    5603,
                    103,
                    3815,
                    3308,
                    2285,
                    4076,
                    2290,
                    5493,
                    5494,
                    5495,
                    2297,
                    764,
                    2303
                ],
                "ABCSeries": [
                    352,
                    129,
                    513,
                    103,
                    2281,
                    5456,
                    4056
                ],
                "ExtensionArray": [
                    4271,
                    3843,
                    4637,
                    103
                ],
                "other.ndim": [
                    104
                ],
                "self": [
                    4107,
                    4113,
                    2077,
                    2079,
                    4151,
                    4173,
                    4176,
                    4194,
                    4195,
                    104,
                    107,
                    108,
                    110,
                    113,
                    117,
                    121,
                    4225,
                    4226,
                    134,
                    4242,
                    4254,
                    4256,
                    4263,
                    4264,
                    4276,
                    4277,
                    4282,
                    2245,
                    4296,
                    4298,
                    4299,
                    4301,
                    4305,
                    2260,
                    2261,
                    2263,
                    2265,
                    2266,
                    4317,
                    2270,
                    2275,
                    4323,
                    4325,
                    4329,
                    2285,
                    2290,
                    2294,
                    2297,
                    4346,
                    4349,
                    4350,
                    2303,
                    4353,
                    2306,
                    2309,
                    2312,
                    2318,
                    2333,
                    2334,
                    2335,
                    2336,
                    2357,
                    4413,
                    4415,
                    4418,
                    4419,
                    2376,
                    4450,
                    4453,
                    4456,
                    2437,
                    2438,
                    2440,
                    2441,
                    2443,
                    4503,
                    4507,
                    2465,
                    2466,
                    2468,
                    2469,
                    2472,
                    2473,
                    2475,
                    2481,
                    2483,
                    2492,
                    2514,
                    2517,
                    4576,
                    2559,
                    2560,
                    2563,
                    2564,
                    4613,
                    2566,
                    2567,
                    4615,
                    2572,
                    2573,
                    2575,
                    2581,
                    534,
                    2583,
                    2584,
                    543,
                    4645,
                    2600,
                    4648,
                    2603,
                    2604,
                    2606,
                    4656,
                    4658,
                    563,
                    564,
                    4660,
                    567,
                    576,
                    591,
                    4689,
                    595,
                    596,
                    598,
                    2651,
                    2652,
                    2654,
                    2656,
                    2658,
                    2660,
                    4718,
                    4719,
                    624,
                    4724,
                    630,
                    631,
                    4729,
                    634,
                    642,
                    643,
                    4744,
                    4745,
                    4746,
                    653,
                    4753,
                    4754,
                    659,
                    4755,
                    4756,
                    4757,
                    4758,
                    669,
                    2722,
                    2723,
                    2724,
                    677,
                    2728,
                    4783,
                    692,
                    2750,
                    2754,
                    707,
                    714,
                    2763,
                    716,
                    2764,
                    718,
                    2766,
                    4811,
                    4815,
                    4816,
                    4826,
                    748,
                    749,
                    754,
                    761,
                    764,
                    771,
                    2821,
                    774,
                    2823,
                    2824,
                    778,
                    813,
                    814,
                    815,
                    4910,
                    4911,
                    819,
                    824,
                    825,
                    826,
                    2886,
                    2891,
                    2894,
                    2895,
                    2900,
                    2901,
                    2907,
                    4957,
                    2913,
                    2915,
                    4973,
                    2928,
                    2940,
                    894,
                    2942,
                    2944,
                    4994,
                    2948,
                    2950,
                    2969,
                    2971,
                    924,
                    926,
                    929,
                    5029,
                    5030,
                    2983,
                    937,
                    5035,
                    2992,
                    2993,
                    5040,
                    5041,
                    948,
                    2996,
                    2997,
                    2999,
                    5042,
                    5046,
                    5049,
                    957,
                    958,
                    959,
                    960,
                    3006,
                    3010,
                    3033,
                    3035,
                    5083,
                    5087,
                    5090,
                    3043,
                    996,
                    3044,
                    998,
                    1003,
                    3051,
                    5101,
                    1010,
                    3059,
                    1014,
                    3063,
                    3062,
                    1023,
                    1024,
                    1029,
                    1031,
                    1034,
                    3088,
                    3089,
                    3090,
                    3102,
                    3109,
                    3111,
                    3112,
                    3113,
                    3120,
                    3123,
                    5171,
                    3125,
                    3128,
                    5177,
                    5179,
                    1084,
                    3137,
                    3140,
                    1093,
                    1094,
                    1095,
                    1097,
                    5202,
                    5204,
                    1115,
                    1116,
                    3164,
                    3166,
                    1119,
                    3168,
                    5216,
                    1127,
                    1128,
                    5233,
                    5234,
                    5236,
                    1141,
                    5257,
                    5259,
                    1164,
                    5265,
                    3231,
                    1187,
                    3235,
                    1189,
                    3236,
                    1191,
                    3244,
                    3246,
                    3248,
                    3249,
                    3261,
                    3282,
                    1248,
                    1249,
                    5346,
                    5347,
                    1252,
                    3309,
                    3311,
                    3312,
                    1268,
                    3319,
                    3323,
                    1279,
                    3327,
                    3328,
                    3337,
                    3339,
                    3341,
                    1307,
                    1309,
                    3364,
                    3366,
                    3375,
                    3398,
                    3401,
                    5454,
                    1370,
                    1377,
                    3432,
                    1386,
                    1388,
                    3440,
                    5490,
                    3443,
                    3447,
                    3454,
                    3461,
                    3469,
                    3472,
                    3479,
                    3480,
                    3486,
                    3487,
                    1442,
                    3490,
                    3491,
                    3492,
                    3496,
                    3499,
                    3501,
                    1458,
                    3508,
                    3514,
                    3518,
                    3524,
                    1478,
                    3527,
                    1481,
                    1486,
                    3541,
                    3549,
                    1506,
                    3558,
                    3573,
                    3591,
                    1545,
                    1546,
                    3597,
                    3610,
                    3616,
                    1572,
                    3620,
                    1575,
                    1576,
                    1580,
                    1584,
                    1585,
                    1586,
                    3664,
                    3667,
                    3669,
                    1639,
                    1641,
                    1653,
                    1670,
                    1687,
                    1704,
                    1721,
                    3769,
                    3770,
                    3776,
                    1731,
                    3779,
                    3782,
                    1735,
                    3784,
                    1738,
                    3787,
                    1741,
                    3790,
                    3791,
                    1744,
                    3793,
                    3794,
                    1747,
                    3797,
                    1750,
                    3799,
                    3801,
                    3803,
                    3804,
                    3814,
                    1786,
                    1789,
                    1792,
                    3840,
                    1798,
                    1805,
                    1809,
                    1815,
                    1816,
                    1817,
                    3870,
                    1825,
                    1827,
                    1835,
                    1841,
                    1842,
                    1859,
                    1860,
                    1863,
                    1869,
                    1870,
                    3923,
                    3926,
                    1880,
                    1881,
                    3933,
                    3956,
                    3958,
                    3959,
                    3969,
                    3974,
                    1940,
                    1988,
                    2014,
                    2015,
                    2016,
                    2020,
                    2021,
                    4069,
                    4071,
                    4076,
                    4082,
                    2044,
                    2045,
                    2046
                ],
                "is_object_dtype": [
                    4323,
                    998,
                    107,
                    4301,
                    110,
                    304,
                    336,
                    1041,
                    1044,
                    4756,
                    342,
                    1750
                ],
                "ABCCategorical": [
                    107
                ],
                "left": [
                    3743,
                    3667,
                    3671,
                    3674,
                    218,
                    3675,
                    221,
                    224,
                    227,
                    3687,
                    3689,
                    3691,
                    108,
                    109,
                    3692,
                    3699,
                    3702,
                    3705,
                    3709
                ],
                "self._values": [
                    1249,
                    2475,
                    108,
                    2575,
                    5490,
                    894
                ],
                "other.dtype": [
                    2376,
                    108,
                    2566,
                    3479
                ],
                "op": [
                    5347,
                    134,
                    3001,
                    139,
                    109,
                    113,
                    117,
                    2999,
                    121,
                    123
                ],
                "ABCMultiIndex": [
                    3432,
                    3433,
                    4777,
                    110,
                    1370,
                    3035
                ],
                "np.errstate": [
                    112,
                    116
                ],
                "result": [
                    4613,
                    4614,
                    519,
                    520,
                    4615,
                    4616,
                    3597,
                    526,
                    527,
                    529,
                    530,
                    3602,
                    3603,
                    1045,
                    3604,
                    2583,
                    2584,
                    1050,
                    1051,
                    1052,
                    2078,
                    1055,
                    1056,
                    2079,
                    1597,
                    1599,
                    1601,
                    1602,
                    113,
                    4210,
                    4211,
                    4212,
                    117,
                    4214,
                    119,
                    120,
                    134,
                    135,
                    136,
                    137,
                    665,
                    666,
                    667,
                    670,
                    4780,
                    4783,
                    4785,
                    714,
                    716,
                    717,
                    718,
                    719,
                    1249,
                    1252,
                    1253,
                    320,
                    323,
                    331,
                    332,
                    5454,
                    5456,
                    5457,
                    5460,
                    5462,
                    3930,
                    3933,
                    3934,
                    4453,
                    4456,
                    4458,
                    3471,
                    3475,
                    3476,
                    3477,
                    2483,
                    2486,
                    2490,
                    2497,
                    2500,
                    2504,
                    2514,
                    2517,
                    2016,
                    2020
                ],
                "ops.comp_method_OBJECT_ARRAY": [
                    113
                ],
                "ops": [
                    5320,
                    5322,
                    5323,
                    5327,
                    113,
                    5332,
                    5335,
                    121
                ],
                "self.values": [
                    771,
                    774,
                    1034,
                    1809,
                    1191,
                    815,
                    563,
                    2996,
                    2997,
                    825,
                    3010,
                    4296,
                    5454,
                    3926,
                    2263,
                    4450,
                    5347,
                    4456,
                    113,
                    754,
                    117,
                    1014,
                    3959,
                    2045
                ],
                "np.asarray": [
                    3616,
                    453,
                    517,
                    1095,
                    4207,
                    5233,
                    659,
                    2995,
                    341,
                    117,
                    2934,
                    4723,
                    761,
                    4058,
                    764
                ],
                "is_bool_dtype": [
                    5098,
                    402,
                    119,
                    3961,
                    666
                ],
                "ops.invalid_comparison": [
                    121
                ],
                "name": [
                    4226,
                    139,
                    141,
                    397,
                    399,
                    527,
                    401,
                    274,
                    275,
                    1275,
                    1276,
                    1304,
                    1305,
                    4254,
                    285,
                    2333,
                    2334,
                    416,
                    929,
                    1442,
                    2335,
                    420,
                    293,
                    1188,
                    295,
                    423,
                    1189,
                    426,
                    299,
                    1191,
                    2601,
                    2603,
                    2604,
                    4015,
                    4264,
                    306,
                    436,
                    4278,
                    444,
                    4006,
                    447,
                    321,
                    450,
                    4256,
                    325,
                    453,
                    4263,
                    5450,
                    331,
                    5451,
                    334,
                    337,
                    468,
                    472,
                    5464,
                    349,
                    1247,
                    1248,
                    1249,
                    1126,
                    1127,
                    232,
                    1128,
                    3814,
                    1003,
                    3815,
                    1265,
                    1267,
                    1141,
                    374,
                    380,
                    1274,
                    123,
                    124,
                    1021
                ],
                "op.__name__": [
                    123,
                    139
                ],
                "set_function_name": [
                    124,
                    141
                ],
                "cmp_method": [
                    124
                ],
                "cls": [
                    519,
                    141,
                    5275,
                    5276,
                    5277,
                    285,
                    5278,
                    416,
                    159,
                    162,
                    163,
                    5279,
                    5280,
                    5287,
                    5288,
                    5289,
                    5290,
                    5291,
                    5292,
                    5299,
                    5300,
                    5301,
                    5302,
                    5303,
                    5304,
                    5305,
                    5306,
                    4027,
                    5307,
                    5308,
                    5309,
                    5310,
                    5311,
                    5312,
                    450,
                    455,
                    5319,
                    713,
                    714,
                    5320,
                    5321,
                    5322,
                    5323,
                    5324,
                    5326,
                    5327,
                    5330,
                    5331,
                    5332,
                    4053,
                    5333,
                    5334,
                    5335,
                    5467,
                    5470,
                    5479,
                    5352,
                    5353,
                    5354,
                    5355,
                    5480,
                    5359,
                    5360,
                    373,
                    124
                ],
                "ABCDataFrame": [
                    129,
                    2281
                ],
                "ABCTimedeltaIndex": [
                    129,
                    4271
                ],
                "Series": [
                    134,
                    1191,
                    2285,
                    2290,
                    2303
                ],
                "index_arithmetic_method": [
                    141
                ],
                "_o_dtype": [
                    328,
                    313,
                    148
                ],
                "np.dtype": [
                    148
                ],
                "_Identity": [
                    149,
                    630
                ],
                "ABCPeriodIndex": [
                    3232,
                    4271,
                    159
                ],
                "_new_PeriodIndex": [
                    162
                ],
                "d": [
                    162,
                    163,
                    1815,
                    1816,
                    1817
                ],
                "cls.__new__": [
                    163
                ],
                "IndexOpsMixin": [
                    3928,
                    166
                ],
                "PandasObject": [
                    166
                ],
                "_deprecations": [
                    208
                ],
                "DirNamesMixin._deprecations": [
                    208
                ],
                "DirNamesMixin": [
                    208
                ],
                "_join_precedence": [
                    211
                ],
                "libjoin.left_join_indexer_unique": [
                    218
                ],
                "libjoin": [
                    224,
                    218,
                    227,
                    221
                ],
                "right": [
                    224,
                    227,
                    3677,
                    3683,
                    3667,
                    3671,
                    218,
                    221
                ],
                "libjoin.left_join_indexer": [
                    221
                ],
                "libjoin.inner_join_indexer": [
                    224
                ],
                "libjoin.outer_join_indexer": [
                    227
                ],
                "_typ": [
                    229
                ],
                "_data": [
                    230
                ],
                "_id": [
                    231
                ],
                "_comparables": [
                    233
                ],
                "_attributes": [
                    234
                ],
                "_is_numeric_dtype": [
                    235
                ],
                "_can_hold_na": [
                    236
                ],
                "_defer_to_indexing": [
                    239
                ],
                "_infer_as_myclass": [
                    243
                ],
                "_engine_type": [
                    245
                ],
                "libindex.ObjectEngine": [
                    245
                ],
                "libindex": [
                    4664,
                    245
                ],
                "_supports_partial_string_indexing": [
                    248
                ],
                "_accessors": [
                    250
                ],
                "CachedAccessor": [
                    252
                ],
                "StringMethods": [
                    252
                ],
                "data": [
                    274,
                    275,
                    285,
                    287,
                    289,
                    292,
                    293,
                    294,
                    295,
                    1833,
                    298,
                    299,
                    1834,
                    1838,
                    303,
                    1839,
                    1841,
                    306,
                    309,
                    321,
                    325,
                    327,
                    331,
                    334,
                    336,
                    337,
                    340,
                    341,
                    345,
                    348,
                    349,
                    352,
                    360,
                    362,
                    364,
                    368,
                    374,
                    380,
                    385,
                    387,
                    391,
                    393,
                    396,
                    397,
                    398,
                    399,
                    400,
                    401,
                    402,
                    403,
                    405,
                    4004,
                    4005,
                    4013,
                    4014,
                    4027,
                    958,
                    452,
                    453,
                    454,
                    455,
                    968,
                    457,
                    965,
                    459,
                    460,
                    966,
                    462,
                    4051,
                    468,
                    4052,
                    4053,
                    471,
                    4056,
                    4057,
                    4058,
                    4059
                ],
                "data.name": [
                    275
                ],
                "fastpath": [
                    284,
                    277
                ],
                "warnings.warn": [
                    4166,
                    2506,
                    3917,
                    686,
                    1136,
                    278,
                    2237
                ],
                "warnings": [
                    4166,
                    2506,
                    3917,
                    686,
                    1136,
                    278,
                    2237
                ],
                "cls._simple_new": [
                    450,
                    285
                ],
                "ABCPandasArray": [
                    287
                ],
                "data.to_numpy": [
                    289
                ],
                "RangeIndex": [
                    5636,
                    292,
                    293,
                    295
                ],
                "copy": [
                    771,
                    764,
                    774,
                    393,
                    397,
                    399,
                    401,
                    409,
                    416,
                    420,
                    293,
                    4006,
                    423,
                    426,
                    299,
                    4015,
                    306,
                    436,
                    444,
                    5572,
                    325,
                    453,
                    5576,
                    334,
                    337,
                    472,
                    349,
                    5598,
                    5601,
                    362,
                    749,
                    754,
                    374,
                    380
                ],
                "dtype": [
                    385,
                    386,
                    771,
                    764,
                    3972,
                    774,
                    391,
                    3974,
                    393,
                    778,
                    397,
                    399,
                    401,
                    659,
                    412,
                    416,
                    4000,
                    932,
                    293,
                    933,
                    295,
                    298,
                    299,
                    303,
                    304,
                    306,
                    310,
                    313,
                    325,
                    453,
                    327,
                    328,
                    334,
                    336,
                    340,
                    342,
                    344,
                    345,
                    472,
                    353,
                    4069,
                    359,
                    362,
                    4074,
                    748,
                    4076,
                    751,
                    368,
                    754,
                    755,
                    374,
                    3958,
                    760,
                    763,
                    380,
                    3965,
                    767
                ],
                "RangeIndex.from_range": [
                    295
                ],
                "is_categorical_dtype": [
                    298,
                    1038,
                    751
                ],
                "CategoricalIndex": [
                    754,
                    299
                ],
                "kwargs": [
                    1031,
                    4616,
                    4745,
                    4746,
                    528,
                    928,
                    937,
                    810,
                    299,
                    811,
                    305,
                    436,
                    565,
                    566,
                    311,
                    444,
                    447,
                    1087,
                    321,
                    325,
                    453,
                    331,
                    334,
                    592,
                    337,
                    594,
                    468,
                    472,
                    349
                ],
                "is_interval_dtype": [
                    303
                ],
                "closed": [
                    305,
                    306
                ],
                "kwargs.get": [
                    928,
                    305,
                    468
                ],
                "IntervalIndex": [
                    426,
                    306
                ],
                "is_datetime64_any_dtype": [
                    309,
                    310
                ],
                "is_dtype_equal": [
                    2566,
                    328,
                    2376,
                    748,
                    2900,
                    3479,
                    313
                ],
                "DatetimeIndex": [
                    320,
                    770,
                    325,
                    4753,
                    4754,
                    436,
                    761
                ],
                "result.astype": [
                    323,
                    332
                ],
                "is_timedelta64_dtype": [
                    327
                ],
                "TimedeltaIndex": [
                    331,
                    444,
                    334
                ],
                "is_period_dtype": [
                    2472,
                    2476,
                    2572,
                    336,
                    2576
                ],
                "PeriodIndex": [
                    337,
                    447
                ],
                "is_extension_array_dtype": [
                    763,
                    340
                ],
                "ea_cls": [
                    344,
                    345
                ],
                "dtype.construct_array_type": [
                    344
                ],
                "ea_cls._from_sequence": [
                    345
                ],
                "data.astype": [
                    385,
                    4004,
                    391,
                    4013,
                    403,
                    348
                ],
                "is_integer_dtype": [
                    3230,
                    359
                ],
                "inferred": [
                    387,
                    388,
                    414,
                    421,
                    360,
                    361,
                    424,
                    363,
                    430,
                    367,
                    433,
                    434,
                    443,
                    413,
                    382,
                    445
                ],
                "lib.infer_dtype": [
                    360,
                    1805,
                    387,
                    413
                ],
                "lib": [
                    387,
                    360,
                    5099,
                    1805,
                    3662,
                    5101,
                    3696,
                    1042,
                    5587,
                    665,
                    666,
                    413
                ],
                "maybe_cast_to_integer_array": [
                    368,
                    362
                ],
                "isna": [
                    3969,
                    1860,
                    1093,
                    4071,
                    364,
                    1942,
                    1048,
                    2271
                ],
                "cls._try_convert_to_int_index": [
                    416,
                    373
                ],
                "Float64Index": [
                    401,
                    380,
                    423
                ],
                "is_float_dtype": [
                    400,
                    386
                ],
                "np.array": [
                    4615,
                    1097,
                    393,
                    1039,
                    1873,
                    2297,
                    1050
                ],
                "is_signed_integer_dtype": [
                    396
                ],
                "data.dtype": [
                    400,
                    402,
                    396,
                    398
                ],
                "Int64Index": [
                    397,
                    4006
                ],
                "is_unsigned_integer_dtype": [
                    4000,
                    398
                ],
                "UInt64Index": [
                    4015,
                    399
                ],
                "data.dtype.type": [
                    402
                ],
                "np.bool": [
                    402
                ],
                "subarr": [
                    416,
                    450,
                    420,
                    423,
                    426,
                    403,
                    436,
                    405,
                    471,
                    472,
                    410,
                    444,
                    413,
                    447
                ],
                "com.asarray_tuplesafe": [
                    3188,
                    405,
                    471
                ],
                "com": [
                    471,
                    4198,
                    4329,
                    5258,
                    4653,
                    4206,
                    4654,
                    4209,
                    4690,
                    3188,
                    3541,
                    405,
                    3542
                ],
                "subarr.copy": [
                    410
                ],
                "inferred.startswith": [
                    434,
                    443
                ],
                "OutOfBoundsDatetime": [
                    437
                ],
                "IncompatibleFrequency": [
                    448
                ],
                "is_scalar": [
                    4960,
                    4962,
                    4197,
                    454,
                    4677,
                    4211,
                    4052,
                    4637,
                    4094
                ],
                "cls._scalar_data_error": [
                    4053,
                    455
                ],
                "tupleize_cols": [
                    457
                ],
                "is_list_like": [
                    1377,
                    1380,
                    2757,
                    1382,
                    457,
                    1297,
                    1270,
                    1274,
                    1373
                ],
                "is_iterator": [
                    5578,
                    459,
                    4669
                ],
                "e": [
                    2508,
                    462
                ],
                "MultiIndex.from_tuples": [
                    467,
                    4821
                ],
                "MultiIndex": [
                    5536,
                    1606,
                    4815,
                    3664,
                    467,
                    3669,
                    4821,
                    5592,
                    3577,
                    3740,
                    3549,
                    3550
                ],
                "values": [
                    513,
                    3969,
                    517,
                    3974,
                    520,
                    1034,
                    526,
                    1038,
                    1039,
                    1041,
                    1042,
                    1297,
                    1044,
                    1045,
                    1299,
                    1300,
                    1048,
                    1304,
                    1309,
                    1055,
                    4777,
                    4778,
                    4779,
                    4780,
                    3375,
                    4911,
                    562,
                    563,
                    566,
                    570,
                    571,
                    1084,
                    574,
                    1086,
                    576,
                    1087,
                    1095,
                    1863,
                    1097,
                    1864,
                    1099,
                    1100,
                    845,
                    1865,
                    4296,
                    848,
                    4298,
                    594,
                    4299,
                    598,
                    2263,
                    601,
                    2266,
                    2271,
                    2275,
                    3311,
                    3312,
                    3959,
                    3964,
                    3967
                ],
                "ABCIndexClass": [
                    513,
                    3843
                ],
                "values._values": [
                    517
                ],
                "object.__new__": [
                    519
                ],
                "result._data": [
                    520
                ],
                "result._index_data": [
                    526
                ],
                "result.name": [
                    1601,
                    527
                ],
                "k": [
                    962,
                    1826,
                    1827,
                    4654,
                    4783,
                    528,
                    529,
                    4656,
                    4658,
                    543
                ],
                "v": [
                    962,
                    1827,
                    1826,
                    4783,
                    528,
                    529,
                    3098
                ],
                "kwargs.items": [
                    528
                ],
                "result._reset_identity": [
                    530
                ],
                "cache_readonly": [
                    672,
                    1800,
                    1867,
                    1807,
                    1854,
                    1875,
                    532,
                    636,
                    1726
                ],
                "self._attributes": [
                    543
                ],
                "attributes": [
                    576,
                    4823,
                    4811,
                    591,
                    592,
                    593,
                    4817,
                    595,
                    564,
                    565,
                    598,
                    567,
                    4818,
                    601,
                    4826,
                    4828
                ],
                "self._get_attributes_dict": [
                    5346,
                    4811,
                    4076,
                    3309,
                    591,
                    564,
                    4277,
                    1816,
                    669,
                    2750
                ],
                "attributes.update": [
                    592,
                    565
                ],
                "self.dtype": [
                    3479,
                    4069,
                    2566,
                    2376,
                    5257,
                    748,
                    3312,
                    595,
                    692,
                    2900,
                    1750,
                    567,
                    3958,
                    4756,
                    4826
                ],
                "ABCDatetimeArray": [
                    571
                ],
                "values.asi8": [
                    574
                ],
                "self._simple_new": [
                    576,
                    3312
                ],
                "Appender": [
                    3206,
                    3081,
                    4630,
                    921,
                    2074,
                    3226,
                    5020,
                    808,
                    560,
                    4147,
                    2881,
                    5451,
                    5452,
                    3028,
                    3928,
                    2012,
                    1635,
                    3430,
                    746,
                    4715,
                    3953,
                    3186,
                    2039,
                    890,
                    2812,
                    2557
                ],
                "self._infer_as_myclass": [
                    596
                ],
                "self._constructor": [
                    2517,
                    598
                ],
                "self._id": [
                    624,
                    718,
                    630
                ],
                "self._engine.clear_mapping": [
                    634
                ],
                "self._engine": [
                    2944,
                    1731,
                    2821,
                    1670,
                    2823,
                    2928,
                    4689,
                    4658,
                    4151,
                    1687,
                    4729,
                    634,
                    3933,
                    2942
                ],
                "_ndarray_values": [
                    642,
                    643,
                    5234
                ],
                "self._ndarray_values": [
                    3616,
                    3776,
                    642,
                    707,
                    2473,
                    2573,
                    3610
                ],
                "self._engine_type": [
                    643
                ],
                "self._data": [
                    2656,
                    1825,
                    3840,
                    4194,
                    5216,
                    677,
                    714,
                    653,
                    3311,
                    1841,
                    659,
                    1815,
                    924,
                    3870
                ],
                "lib.item_from_zerodim": [
                    665
                ],
                "lib.is_scalar": [
                    666
                ],
                "attrs": [
                    962,
                    5346,
                    5347,
                    3309,
                    3310,
                    3312,
                    669,
                    670,
                    959
                ],
                "self._data.dtype": [
                    677
                ],
                "self._ndarray_values.ravel": [
                    707
                ],
                "order": [
                    707
                ],
                "self._data.view": [
                    3840,
                    714
                ],
                "self._shallow_copy": [
                    894,
                    924,
                    926,
                    2335,
                    2079,
                    1187,
                    2604,
                    2046,
                    826,
                    4299,
                    716,
                    2656,
                    5216,
                    2275,
                    4195,
                    2021,
                    1388,
                    2045,
                    3454
                ],
                "result._id": [
                    718
                ],
                "self.copy": [
                    937,
                    948,
                    749
                ],
                "self.name": [
                    1024,
                    771,
                    774,
                    3339,
                    3341,
                    1023,
                    1309,
                    2334,
                    4254,
                    1189,
                    2600,
                    1835,
                    2603,
                    2606,
                    1478,
                    1481,
                    2763,
                    2764,
                    1248,
                    2020,
                    754,
                    1279
                ],
                "is_datetime64tz_dtype": [
                    2472,
                    755,
                    2476,
                    767
                ],
                "tz": [
                    760,
                    761
                ],
                "pandas_dtype": [
                    760
                ],
                "tz_convert": [
                    761
                ],
                "tz_localize": [
                    761
                ],
                "self.values.astype": [
                    774
                ],
                "msg": [
                    4096,
                    839,
                    777,
                    778,
                    843,
                    823,
                    824,
                    4095,
                    1374,
                    1375
                ],
                "msg.format": [
                    824,
                    4096,
                    778
                ],
                "nv.validate_take": [
                    811
                ],
                "nv": [
                    811,
                    893
                ],
                "indices": [
                    834,
                    838,
                    812,
                    845,
                    816,
                    848,
                    825
                ],
                "ensure_platform_int": [
                    3808,
                    834,
                    812,
                    2892,
                    3372,
                    3759,
                    2930,
                    3762,
                    4730,
                    892,
                    3613,
                    3614,
                    3807
                ],
                "self._can_hold_na": [
                    1880,
                    1859,
                    1869,
                    813
                ],
                "taken": [
                    2596,
                    2599,
                    844,
                    2604,
                    814,
                    2607,
                    848,
                    849,
                    2609,
                    825,
                    826
                ],
                "self._assert_take_fillable": [
                    814
                ],
                "allow_fill": [
                    817,
                    845,
                    837,
                    822
                ],
                "fill_value": [
                    818,
                    837,
                    822
                ],
                "self._na_value": [
                    819,
                    3956,
                    4415
                ],
                "self.__class__.__name__": [
                    824,
                    1307,
                    957,
                    2318
                ],
                "self.__class__": [
                    2318,
                    824,
                    1817,
                    1307,
                    957
                ],
                "self.values.take": [
                    825
                ],
                "np.nan": [
                    1851,
                    829,
                    1599
                ],
                "algos.take": [
                    844
                ],
                "algos": [
                    2496,
                    2593,
                    3748,
                    844,
                    4911,
                    3698
                ],
                "na_value": [
                    845
                ],
                "values.take": [
                    848
                ],
                "repeats": [
                    892,
                    894
                ],
                "nv.validate_repeat": [
                    893
                ],
                "axis": [
                    893
                ],
                "self._values.repeat": [
                    894
                ],
                "deep": [
                    929,
                    1268,
                    3930,
                    923,
                    3933
                ],
                "new_index": [
                    930,
                    933,
                    934,
                    3401,
                    3402,
                    924,
                    926
                ],
                "self._data.copy": [
                    924
                ],
                "names": [
                    5532,
                    4253,
                    4254,
                    1311,
                    928,
                    929,
                    930,
                    5533,
                    5534,
                    5536,
                    4816,
                    4818,
                    4820,
                    4821,
                    1373,
                    1377,
                    1380,
                    1381,
                    1389,
                    1265,
                    1267,
                    3572,
                    1269,
                    1270,
                    1272,
                    3578
                ],
                "self._validate_names": [
                    929
                ],
                "new_index.set_names": [
                    930
                ],
                "new_index.astype": [
                    933
                ],
                "memo": [
                    946,
                    947
                ],
                "klass": [
                    968,
                    957
                ],
                "self._format_data": [
                    958
                ],
                "self._format_attrs": [
                    959
                ],
                "space": [
                    960,
                    962
                ],
                "self._format_space": [
                    960
                ],
                "prepr": [
                    968,
                    962
                ],
                "join": [
                    962
                ],
                "res": [
                    4004,
                    4005,
                    4006,
                    968,
                    970,
                    4013,
                    4014,
                    4015
                ],
                "default_pprint": [
                    987
                ],
                "is_justify": [
                    995,
                    1003
                ],
                "self.inferred_type": [
                    1792,
                    3235,
                    996,
                    998,
                    1798,
                    1738,
                    3051,
                    1741,
                    1744,
                    3248,
                    4113,
                    1747,
                    4753,
                    4755,
                    3128,
                    1786,
                    1789
                ],
                "self.categories": [
                    998
                ],
                "format_object_summary": [
                    1002
                ],
                "self._formatter_func": [
                    1003
                ],
                "format_object_attrs": [
                    1010
                ],
                "header": [
                    1056,
                    1029,
                    1031,
                    1020,
                    1022
                ],
                "header.append": [
                    1022
                ],
                "pprint_thing": [
                    1122,
                    1045,
                    1023
                ],
                "formatter": [
                    1028,
                    1029
                ],
                "self.map": [
                    1641,
                    1029
                ],
                "self._format_with_header": [
                    1031
                ],
                "values.dtype": [
                    1041,
                    1044,
                    1038
                ],
                "lib.maybe_convert_objects": [
                    1042
                ],
                "x": [
                    5624,
                    5355,
                    4273,
                    3475,
                    3476,
                    1045,
                    5623,
                    4280,
                    2490
                ],
                "mask": [
                    3712,
                    3713,
                    5260,
                    5261,
                    3727,
                    3728,
                    5263,
                    3730,
                    5264,
                    1048,
                    1049,
                    3738,
                    1051,
                    3617,
                    3618,
                    1596,
                    1598,
                    1599,
                    1093,
                    4298,
                    1099,
                    4305,
                    4450,
                    4453,
                    4455,
                    3710,
                    3711
                ],
                "mask.any": [
                    1049,
                    5261,
                    1598
                ],
                "na_rep": [
                    1099,
                    1051
                ],
                "result.tolist": [
                    1052
                ],
                "_trim_front": [
                    1055
                ],
                "format_array": [
                    1055
                ],
                "slicer": [
                    1085,
                    1086
                ],
                "values._format_native_types": [
                    1087
                ],
                "self.is_object": [
                    4225,
                    4107,
                    1094
                ],
                "quoting": [
                    1094
                ],
                "astype": [
                    2360,
                    2359,
                    1095
                ],
                "head": [
                    1122,
                    1116,
                    1117,
                    1118
                ],
                "head.format": [
                    1118
                ],
                "tail": [
                    1120,
                    1121,
                    1122,
                    1119
                ],
                "tail.format": [
                    1121
                ],
                "index_summary": [
                    1128,
                    1122,
                    1124
                ],
                "self._summary": [
                    1141
                ],
                "index": [
                    1186,
                    1187,
                    1251,
                    1191
                ],
                "self.values.copy": [
                    4296,
                    1191
                ],
                "DataFrame": [
                    1249
                ],
                "self._values.copy": [
                    1249
                ],
                "result.index": [
                    1252
                ],
                "deepcopy": [
                    1268
                ],
                "self.names": [
                    3440,
                    4816,
                    1586,
                    1268,
                    3541
                ],
                "FrozenList": [
                    1279
                ],
                "is_hashable": [
                    1305
                ],
                "_set_names": [
                    1311
                ],
                "_get_names": [
                    1311
                ],
                "level": [
                    3716,
                    1545,
                    3596,
                    3598,
                    3472,
                    3732,
                    2076,
                    2077,
                    1569,
                    1570,
                    1572,
                    3749,
                    1574,
                    1576,
                    3752,
                    1580,
                    4909,
                    4910,
                    1468,
                    1469,
                    1472,
                    1474,
                    1476,
                    3448,
                    1478,
                    1481,
                    1486,
                    1370,
                    3674,
                    3675,
                    1373,
                    1377,
                    1637,
                    1382,
                    1383,
                    3691,
                    1389,
                    3437,
                    3699,
                    3316,
                    3446,
                    3703,
                    3320,
                    3706
                ],
                "self.nlevels": [
                    1576,
                    1377,
                    1580
                ],
                "inplace": [
                    1385,
                    1442,
                    1390
                ],
                "idx": [
                    1386,
                    1388,
                    1389,
                    1391,
                    5235,
                    5236
                ],
                "idx._set_names": [
                    1389
                ],
                "self.set_names": [
                    1442
                ],
                "self._validate_index_level": [
                    4910,
                    1545,
                    2077,
                    1486
                ],
                "self.sort_values": [
                    1506
                ],
                "ascending": [
                    4504,
                    1506
                ],
                "get_level_values": [
                    1548
                ],
                "_get_level_values": [
                    1548
                ],
                "levnums": [
                    1572,
                    1588
                ],
                "self._get_level_number": [
                    1572
                ],
                "lev": [
                    1572
                ],
                "new_levels": [
                    3741,
                    1607,
                    1584,
                    3705,
                    1589,
                    1593,
                    3706,
                    1597
                ],
                "self.levels": [
                    1584
                ],
                "new_codes": [
                    3712,
                    3703,
                    1608,
                    3724,
                    1585,
                    3730,
                    3732,
                    3733,
                    1590,
                    3702,
                    1596,
                    1597,
                    3742
                ],
                "self.codes": [
                    1585
                ],
                "new_names": [
                    1609,
                    1601,
                    1586,
                    1591
                ],
                "i": [
                    1588,
                    1589,
                    1590,
                    1591
                ],
                "new_levels.pop": [
                    1589
                ],
                "new_codes.pop": [
                    1590
                ],
                "new_names.pop": [
                    1591
                ],
                "take": [
                    1597,
                    4453
                ],
                "result.putmask": [
                    1599
                ],
                "mapper": [
                    1641,
                    4809,
                    1638
                ],
                "grouper": [
                    1641,
                    1643,
                    1639
                ],
                "self.is_monotonic_increasing": [
                    1704,
                    5040,
                    1653,
                    2999,
                    2940
                ],
                "self._engine.is_monotonic_increasing": [
                    1670
                ],
                "self._engine.is_monotonic_decreasing": [
                    1687
                ],
                "self.is_unique": [
                    3490,
                    3779,
                    2265,
                    1735,
                    1704,
                    4744,
                    3282,
                    2260,
                    1721,
                    2907,
                    3486,
                    3327
                ],
                "self.is_monotonic_decreasing": [
                    1721,
                    5042
                ],
                "self._engine.is_unique": [
                    1731
                ],
                "is_datetime_array": [
                    1809
                ],
                "ensure_object": [
                    1809
                ],
                "d.update": [
                    1816
                ],
                "_new_Index": [
                    1817
                ],
                "state": [
                    1824,
                    1825,
                    1826,
                    1829,
                    1831,
                    1832,
                    1838,
                    1839
                ],
                "state.pop": [
                    1825
                ],
                "state.items": [
                    1826
                ],
                "nd_state": [
                    1832,
                    1833,
                    1834
                ],
                "own_state": [
                    1832,
                    1835
                ],
                "np.empty": [
                    1863,
                    1833,
                    1838,
                    3378,
                    3647
                ],
                "np.ndarray.__setstate__": [
                    1834,
                    1839
                ],
                "self._reset_identity": [
                    1842
                ],
                "_unpickle_compat": [
                    1846
                ],
                "__setstate__": [
                    1846
                ],
                "_na_value": [
                    1851
                ],
                "np.bool_": [
                    1863
                ],
                "values.fill": [
                    1864
                ],
                "w": [
                    1870,
                    1871
                ],
                "self._isnan.nonzero": [
                    1870
                ],
                "self._isnan": [
                    2016,
                    1870,
                    1940,
                    1881,
                    2045
                ],
                "np.int64": [
                    1873
                ],
                "self._isnan.any": [
                    1881
                ],
                "isnull": [
                    1942
                ],
                "self.isna": [
                    1988
                ],
                "notnull": [
                    1990
                ],
                "notna": [
                    1990
                ],
                "self._assert_can_do_op": [
                    2014
                ],
                "value": [
                    2016,
                    4096,
                    4298,
                    4305,
                    4690,
                    2014,
                    4088,
                    4094
                ],
                "self.hasnans": [
                    2044,
                    2270,
                    2015
                ],
                "self.putmask": [
                    2016
                ],
                "downcast": [
                    2017
                ],
                "how": [
                    3461,
                    3594,
                    3470,
                    3598,
                    3472,
                    3482,
                    3610,
                    3484,
                    3488,
                    3493,
                    3497,
                    3502,
                    3507,
                    3509,
                    3511,
                    3770,
                    3515,
                    3781,
                    3785,
                    3789,
                    3792,
                    3796,
                    3798,
                    3672,
                    3800,
                    3802,
                    3683,
                    3564,
                    3443,
                    3448,
                    2041,
                    2042,
                    3453
                ],
                "unique": [
                    2245,
                    2078
                ],
                "drop_duplicates": [
                    2127
                ],
                "keep": [
                    2183,
                    2127
                ],
                "duplicated": [
                    2183
                ],
                "self.duplicated": [
                    2245
                ],
                "dropna": [
                    2268,
                    2260
                ],
                "self.unique": [
                    2266
                ],
                "self.intersection": [
                    3514,
                    2306
                ],
                "self.union": [
                    2309,
                    3518
                ],
                "self.symmetric_difference": [
                    2312
                ],
                "__bool__": [
                    2322
                ],
                "__nonzero__": [
                    2322
                ],
                "get_op_result_name": [
                    2517,
                    3814,
                    2333,
                    2766
                ],
                "this": [
                    2660,
                    3480,
                    2662,
                    2567,
                    2728,
                    2569,
                    2665,
                    2666,
                    2730,
                    2735,
                    2673,
                    2737,
                    2357,
                    2901,
                    2903,
                    2360,
                    3482
                ],
                "self.astype": [
                    2567,
                    4305,
                    2901,
                    2357,
                    4757,
                    3480
                ],
                "Index.union": [
                    2360
                ],
                "sort": [
                    3520,
                    2722,
                    2437,
                    2502,
                    2598,
                    2441,
                    2569,
                    2379,
                    2443,
                    2667,
                    2382,
                    2744,
                    2481,
                    2360,
                    2651,
                    2559
                ],
                "self._validate_sort_keyword": [
                    2722,
                    2651,
                    2437,
                    2559
                ],
                "self._assert_can_do_setop": [
                    2560,
                    2723,
                    2652,
                    2438
                ],
                "self._is_compatible_with_other": [
                    2440
                ],
                "self._union_incompatible_dtypes": [
                    2441
                ],
                "self._union": [
                    2443
                ],
                "self.equals": [
                    2465,
                    2563,
                    3769,
                    4346,
                    3323,
                    2654
                ],
                "self._get_reconciled_name_object": [
                    2466,
                    2564
                ],
                "other._get_reconciled_name_object": [
                    2469
                ],
                "lvals": [
                    2497,
                    2593,
                    2500,
                    2473,
                    2475,
                    2573,
                    2575,
                    2483,
                    2486,
                    2583,
                    2489,
                    2589
                ],
                "rvals": [
                    2496,
                    2593,
                    2477,
                    2479,
                    2577,
                    2483,
                    2579,
                    2583,
                    2490,
                    2589
                ],
                "other._ndarray_values": [
                    3777,
                    3618,
                    2477,
                    2577,
                    3610
                ],
                "other._values": [
                    2579,
                    2479
                ],
                "self.is_monotonic": [
                    2481,
                    3499,
                    3491,
                    2581
                ],
                "other.is_monotonic": [
                    2481,
                    3499,
                    3491,
                    2581
                ],
                "self._outer_indexer": [
                    3793,
                    2483,
                    3803
                ],
                "value_set": [
                    2489,
                    2490
                ],
                "result.extend": [
                    2490
                ],
                "indexer": [
                    3328,
                    2946,
                    2948,
                    2950,
                    2951,
                    2824,
                    2825,
                    2953,
                    2827,
                    3337,
                    4746,
                    4747,
                    3343,
                    5259,
                    5260,
                    5264,
                    5265,
                    2969,
                    2970,
                    2971,
                    2589,
                    2590,
                    2593,
                    2594,
                    2977,
                    2596,
                    3236,
                    3237,
                    2983,
                    2984,
                    3238,
                    2730,
                    3364,
                    3244,
                    2733,
                    3246,
                    3366,
                    3370,
                    3375,
                    3378,
                    3365,
                    2740,
                    3000,
                    3386,
                    2492,
                    2493,
                    3006,
                    2495,
                    2496,
                    3007,
                    3010,
                    3011,
                    3012,
                    3132,
                    3134,
                    3137,
                    3143,
                    3395,
                    3398,
                    3147,
                    3402,
                    3282,
                    3168,
                    2913,
                    3169,
                    2915,
                    2662,
                    2663,
                    2665,
                    2928,
                    2930,
                    3319,
                    4729,
                    4730,
                    3324
                ],
                "self.get_indexer": [
                    3328,
                    3236,
                    3527,
                    2824,
                    4745,
                    5259,
                    2992,
                    2993,
                    2969,
                    2492
                ],
                "nonzero": [
                    2663,
                    3660,
                    2733,
                    2740,
                    2493,
                    2590
                ],
                "other_diff": [
                    2496,
                    2497
                ],
                "algos.take_nd": [
                    2496,
                    3698,
                    3748
                ],
                "concat_compat": [
                    2497,
                    2743
                ],
                "sorting.safe_sort": [
                    2504,
                    2746,
                    2669,
                    2599
                ],
                "sorting": [
                    2504,
                    2746,
                    2669,
                    2599
                ],
                "self._wrap_setop_result": [
                    2584,
                    2514
                ],
                "ensure_index": [
                    2561,
                    3363,
                    2884,
                    4717,
                    3314,
                    3451
                ],
                "other.astype": [
                    2568,
                    3481,
                    4757
                ],
                "this.intersection": [
                    2569
                ],
                "self._inner_indexer": [
                    3801,
                    3790,
                    2583
                ],
                "get_indexer": [
                    2589
                ],
                "indexer.take": [
                    2733,
                    2590,
                    2663
                ],
                "algos.unique1d": [
                    2593
                ],
                "get_indexer_non_unique": [
                    2593
                ],
                "other.take": [
                    2596
                ],
                "taken.values": [
                    2599
                ],
                "other.name": [
                    2600,
                    2606
                ],
                "taken.name": [
                    2607
                ],
                "result_name": [
                    2658,
                    2725,
                    2726,
                    2764,
                    2766,
                    2767,
                    2673,
                    2751
                ],
                "self._convert_can_do_setop": [
                    2658,
                    2724
                ],
                "self._get_unique_index": [
                    2728,
                    2660
                ],
                "this.get_indexer": [
                    2730,
                    2662,
                    2903
                ],
                "label_diff": [
                    2665,
                    2666
                ],
                "np.setdiff1d": [
                    2665,
                    2734
                ],
                "np.arange": [
                    4453,
                    3398,
                    2665,
                    3370,
                    2735,
                    3386,
                    3387,
                    3709
                ],
                "this.size": [
                    2665,
                    2735
                ],
                "the_diff": [
                    2754,
                    2666,
                    2669,
                    2673,
                    2743,
                    2746
                ],
                "this.values.take": [
                    2737,
                    2666
                ],
                "this.values": [
                    2737,
                    2666
                ],
                "this._shallow_copy": [
                    2673
                ],
                "result_name_update": [
                    2724,
                    2726
                ],
                "other._get_unique_index": [
                    2729
                ],
                "common_indexer": [
                    2733,
                    2735
                ],
                "left_indexer": [
                    3713,
                    3718,
                    3723,
                    3724,
                    3732,
                    3733,
                    3738,
                    3755,
                    2734,
                    3758,
                    2992,
                    2737,
                    3759,
                    2996,
                    3764,
                    3002,
                    3688,
                    3691,
                    3692,
                    3709
                ],
                "left_diff": [
                    2737,
                    2743
                ],
                "right_indexer": [
                    3748,
                    3752,
                    3755,
                    2993,
                    3761,
                    3762,
                    2740,
                    2741,
                    2997,
                    3764,
                    3001,
                    3003
                ],
                "right_diff": [
                    2741,
                    2743
                ],
                "other.values.take": [
                    2741
                ],
                "other.values": [
                    2741
                ],
                "attribs": [
                    2752,
                    2753,
                    2754,
                    4277,
                    4278,
                    4282,
                    2750,
                    2751
                ],
                "self._shallow_copy_with_infer": [
                    2754,
                    3974,
                    3401,
                    5236,
                    4282
                ],
                "method": [
                    3329,
                    2946,
                    2948,
                    3332,
                    2824,
                    2963,
                    2966,
                    2883,
                    2941,
                    2814,
                    2897,
                    2904,
                    2912,
                    2913,
                    2914,
                    3317,
                    5629,
                    5630,
                    2943
                ],
                "tolerance": [
                    2913,
                    3329,
                    2915,
                    3011,
                    2885,
                    2886,
                    2917,
                    2824,
                    2949,
                    2951,
                    2897,
                    2934,
                    2935,
                    2904,
                    2937,
                    3005,
                    3006,
                    2815
                ],
                "self._engine.get_loc": [
                    2821,
                    2823
                ],
                "key": [
                    4994,
                    4995,
                    2821,
                    2823,
                    2824,
                    2829,
                    3088,
                    3089,
                    3090,
                    3094,
                    4637,
                    4645,
                    3111,
                    3112,
                    3113,
                    4650,
                    4651,
                    4654,
                    4149,
                    4151,
                    4664,
                    3132,
                    3261,
                    3134,
                    4669,
                    4670,
                    4677,
                    4678,
                    3143,
                    4679,
                    4173,
                    4690,
                    3033,
                    3042,
                    3044,
                    4197,
                    3046,
                    4198,
                    4199,
                    4201,
                    4204,
                    4973,
                    4206,
                    4207,
                    4975,
                    4209,
                    4210,
                    3059,
                    4976,
                    3061,
                    4977,
                    3063,
                    4980,
                    3065,
                    4989,
                    4991
                ],
                "self._maybe_cast_indexer": [
                    2823
                ],
                "indexer.ndim": [
                    2825
                ],
                "indexer.size": [
                    2825
                ],
                "loc": [
                    5216,
                    4417,
                    4418,
                    4419,
                    2827,
                    2828,
                    2830,
                    5235,
                    4413
                ],
                "indexer.item": [
                    2827
                ],
                "missing.clean_reindex_fill_method": [
                    2883
                ],
                "missing": [
                    2883,
                    3364,
                    3337,
                    3369,
                    3372,
                    3373,
                    4729,
                    4730
                ],
                "target": [
                    3329,
                    2946,
                    2948,
                    2951,
                    3337,
                    4745,
                    3339,
                    3340,
                    3341,
                    4746,
                    3343,
                    2969,
                    2971,
                    3363,
                    3364,
                    3373,
                    2992,
                    2993,
                    2995,
                    2996,
                    2997,
                    3383,
                    3006,
                    3010,
                    2884,
                    2886,
                    2891,
                    2892,
                    2894,
                    2895,
                    2900,
                    2902,
                    2904,
                    2913,
                    2915,
                    3303,
                    4727,
                    3306,
                    3308,
                    4717,
                    4718,
                    4719,
                    2928,
                    3312,
                    3314,
                    4722,
                    4723,
                    4725,
                    2935,
                    3320,
                    3323,
                    2940
                ],
                "self._convert_tolerance": [
                    2886
                ],
                "target.is_boolean": [
                    2891
                ],
                "self.is_numeric": [
                    2891
                ],
                "np.repeat": [
                    3456,
                    2892,
                    3464
                ],
                "target.size": [
                    2892,
                    2935
                ],
                "pself": [
                    4718,
                    4719,
                    2896,
                    2894,
                    2895,
                    4720
                ],
                "ptarget": [
                    4718,
                    4719,
                    2894,
                    2897,
                    2895,
                    4720
                ],
                "self._maybe_promote": [
                    4718,
                    2894
                ],
                "pself.get_indexer": [
                    2896
                ],
                "limit": [
                    2913,
                    2946,
                    2915,
                    2948,
                    3329,
                    3332,
                    2922,
                    2960,
                    2897,
                    2992,
                    2993,
                    2904
                ],
                "target.dtype": [
                    2900
                ],
                "target.astype": [
                    2902
                ],
                "InvalidIndexError": [
                    2908,
                    4670,
                    4679
                ],
                "self._get_fill_indexer": [
                    2913
                ],
                "self._get_nearest_indexer": [
                    2915
                ],
                "self._engine.get_indexer": [
                    2928
                ],
                "target._ndarray_values": [
                    2928,
                    4727,
                    2946,
                    2951
                ],
                "tolerance.size": [
                    2935
                ],
                "target.is_monotonic_increasing": [
                    2940
                ],
                "self._engine.get_pad_indexer": [
                    2942
                ],
                "self._engine.get_backfill_indexer": [
                    2944
                ],
                "self._get_fill_indexer_searchsorted": [
                    2948
                ],
                "self._filter_indexer_tolerance": [
                    3006,
                    2950
                ],
                "side": [
                    5090,
                    5083,
                    5041,
                    5073,
                    5105,
                    5076,
                    5109,
                    2966,
                    5047,
                    5114,
                    2971,
                    2972
                ],
                "nonexact": [
                    2977,
                    2970,
                    2971
                ],
                "self._searchsorted_monotonic": [
                    5090,
                    2971
                ],
                "left_distances": [
                    3001,
                    2996
                ],
                "right_distances": [
                    3001,
                    2997
                ],
                "operator.lt": [
                    5277,
                    2999
                ],
                "operator": [
                    5280,
                    5319,
                    5352,
                    5321,
                    5353,
                    5324,
                    5326,
                    5330,
                    5331,
                    5334,
                    2999,
                    5275,
                    5276,
                    5277,
                    5278,
                    5279
                ],
                "operator.le": [
                    5279,
                    2999
                ],
                "np.where": [
                    3011,
                    4451,
                    3249,
                    3000,
                    3967
                ],
                "distance": [
                    3010,
                    3011
                ],
                "kind": [
                    4993,
                    3083,
                    3086,
                    3088,
                    3089,
                    3090,
                    4113,
                    3229,
                    5022,
                    3104,
                    5029,
                    3111,
                    3112,
                    3113,
                    5171,
                    5177,
                    3137,
                    5071,
                    3030,
                    3032,
                    3033,
                    5083,
                    4957,
                    3168,
                    3042,
                    3046,
                    3061,
                    4987
                ],
                "self._validate_indexer": [
                    3111,
                    3112,
                    3113,
                    3088,
                    3089,
                    3090,
                    3033
                ],
                "is_float": [
                    3042,
                    5028,
                    4973,
                    3046
                ],
                "self.is_floating": [
                    5029,
                    3043,
                    4973,
                    3231
                ],
                "self._invalid_indexer": [
                    4994,
                    3044,
                    5030,
                    5035,
                    3059,
                    3063
                ],
                "is_integer": [
                    5034,
                    4650,
                    3061,
                    3098,
                    4991
                ],
                "self.holds_integer": [
                    4648,
                    4660,
                    5029,
                    3062
                ],
                "key.start": [
                    3088,
                    3094,
                    3111
                ],
                "key.stop": [
                    3112,
                    3089,
                    3094
                ],
                "key.step": [
                    3113,
                    3090,
                    3094
                ],
                "start": [
                    3137,
                    5155,
                    5159,
                    5161,
                    4957,
                    3122,
                    3123,
                    5170,
                    5171,
                    3094,
                    3100,
                    3101
                ],
                "stop": [
                    3137,
                    3124,
                    3125,
                    3094,
                    3100,
                    3101
                ],
                "step": [
                    3137,
                    4965,
                    3094,
                    4957,
                    5151
                ],
                "is_null_slicer": [
                    3131,
                    3100
                ],
                "is_index_slice": [
                    3139,
                    3109,
                    3101,
                    3102
                ],
                "is_int": [
                    3101
                ],
                "is_positional": [
                    3120,
                    3126,
                    3133,
                    3102
                ],
                "self.is_integer": [
                    3140,
                    3109,
                    3102
                ],
                "self.is_mixed": [
                    3120
                ],
                "self.get_loc": [
                    4645,
                    3123,
                    3125,
                    4413,
                    5087
                ],
                "self.slice_indexer": [
                    3137
                ],
                "keyarr": [
                    3168,
                    3169,
                    3232,
                    3236,
                    3208,
                    3230,
                    3249,
                    3250,
                    3188,
                    3189,
                    3163,
                    3164,
                    3166
                ],
                "self._convert_index_indexer": [
                    3164
                ],
                "self._convert_arr_indexer": [
                    3166
                ],
                "self._convert_list_indexer": [
                    3168
                ],
                "maybe_convert_indices": [
                    3246
                ],
                "form": [
                    4994,
                    3261
                ],
                "preserve_names": [
                    3339,
                    3303
                ],
                "_ensure_has_len": [
                    3306
                ],
                "attrs.pop": [
                    3310
                ],
                "_": [
                    4746,
                    3651,
                    3319
                ],
                "self._join_level": [
                    3447,
                    3597,
                    3319
                ],
                "self.get_indexer_non_unique": [
                    3337,
                    4746,
                    3364
                ],
                "target.nlevels": [
                    3339
                ],
                "target.name": [
                    3339,
                    3341
                ],
                "target.copy": [
                    3340
                ],
                "check": [
                    3395,
                    3365,
                    3366,
                    3399,
                    3374,
                    3375,
                    3376
                ],
                "new_labels": [
                    3366,
                    3401,
                    3378,
                    3379,
                    3380
                ],
                "self.take": [
                    3398,
                    3366,
                    4783,
                    3375,
                    4507
                ],
                "new_indexer": [
                    3398,
                    3367,
                    3399,
                    3402,
                    3386,
                    3387,
                    3388
                ],
                "length": [
                    3376,
                    3370,
                    3374
                ],
                "missing_labels": [
                    3380,
                    3373
                ],
                "target.take": [
                    3373
                ],
                "missing_indexer": [
                    3388,
                    3380,
                    3374
                ],
                "ensure_int64": [
                    3650,
                    3661,
                    3662,
                    3374,
                    3376,
                    3695
                ],
                "cur_labels": [
                    3387,
                    3379,
                    3375
                ],
                "cur_indexer": [
                    3376,
                    3387,
                    3379
                ],
                "target.is_unique": [
                    3383
                ],
                "self_is_mi": [
                    3552,
                    3590,
                    3432,
                    3437,
                    3446,
                    3549
                ],
                "other_is_mi": [
                    3552,
                    3433,
                    3437,
                    3446,
                    3550
                ],
                "other.names": [
                    3440,
                    3596,
                    3542
                ],
                "self._join_multi": [
                    3443
                ],
                "return_indexers": [
                    3488,
                    3523,
                    3493,
                    3622,
                    3463,
                    3497,
                    3757,
                    3502,
                    3598,
                    3472,
                    3474,
                    3443,
                    3448,
                    3482,
                    3771,
                    3806,
                    3455
                ],
                "join_index": [
                    3456,
                    3457,
                    3459,
                    3462,
                    3464,
                    3465,
                    3467,
                    3740,
                    3616,
                    3618,
                    3620,
                    3749,
                    3623,
                    3752,
                    3625,
                    3508,
                    3764,
                    3510,
                    3766,
                    3514,
                    3518,
                    3521,
                    3524,
                    3782,
                    3527,
                    3528,
                    3786,
                    3531,
                    3532,
                    3534,
                    3790,
                    3791,
                    3793,
                    3794,
                    3797,
                    3799,
                    3801,
                    3803,
                    3804,
                    3809,
                    3811,
                    3689,
                    3692,
                    3454
                ],
                "rindexer": [
                    3456,
                    3457,
                    3529,
                    3531,
                    3532
                ],
                "other._shallow_copy": [
                    3462
                ],
                "lindexer": [
                    3525,
                    3527,
                    3464,
                    3465,
                    3532
                ],
                "self._join_precedence": [
                    3469
                ],
                "other._join_precedence": [
                    3469
                ],
                "get": [
                    3672,
                    3594,
                    3470
                ],
                "other.join": [
                    3471
                ],
                "y": [
                    3475,
                    3476
                ],
                "z": [
                    3475,
                    3476
                ],
                "this.join": [
                    3482
                ],
                "_validate_join_method": [
                    3484
                ],
                "other.is_unique": [
                    3490,
                    3779,
                    3486
                ],
                "self._join_non_unique": [
                    3496,
                    3487
                ],
                "self._join_monotonic": [
                    3492,
                    3501
                ],
                "join_index.sort_values": [
                    3521
                ],
                "other.get_indexer": [
                    3531
                ],
                "self_names": [
                    3555,
                    3541,
                    3543
                ],
                "com.not_none": [
                    3541,
                    3542
                ],
                "other_names": [
                    3556,
                    3542,
                    3543
                ],
                "overlap": [
                    3585,
                    3555,
                    3556,
                    3543,
                    3546
                ],
                "ldrop_names": [
                    3570,
                    3555,
                    3558
                ],
                "rdrop_names": [
                    3570,
                    3556,
                    3559
                ],
                "self_jnlevels": [
                    3563,
                    3558
                ],
                "self.droplevel": [
                    3558
                ],
                "other_jnlevels": [
                    3564,
                    3559
                ],
                "other.droplevel": [
                    3559
                ],
                "join_idx": [
                    3563,
                    3573
                ],
                "lidx": [
                    3809,
                    3783,
                    3563,
                    3787,
                    3790,
                    3793,
                    3807,
                    3573,
                    3797,
                    3799,
                    3801,
                    3803,
                    3583
                ],
                "ridx": [
                    3808,
                    3809,
                    3784,
                    3563,
                    3788,
                    3790,
                    3793,
                    3573,
                    3797,
                    3799,
                    3801,
                    3803,
                    3583
                ],
                "self_jnlevels.join": [
                    3563
                ],
                "dropped_names": [
                    3570,
                    3573
                ],
                "levels": [
                    3578,
                    3572
                ],
                "codes": [
                    3578,
                    3572
                ],
                "_restore_dropped_levels_multijoin": [
                    3572
                ],
                "multi_join_idx": [
                    3577,
                    3581,
                    3583
                ],
                "multi_join_idx.remove_unused_levels": [
                    3581
                ],
                "jl": [
                    3585,
                    3596
                ],
                "flip_order": [
                    3589,
                    3592,
                    3754,
                    3601,
                    3669,
                    3670
                ],
                "other.names.index": [
                    3596
                ],
                "left_idx": [
                    3616,
                    3617,
                    3623,
                    3609,
                    3613
                ],
                "right_idx": [
                    3609,
                    3618,
                    3614,
                    3623
                ],
                "_get_join_indexers": [
                    3609
                ],
                "self._ndarray_values.take": [
                    3616
                ],
                "np.putmask": [
                    4298,
                    3618
                ],
                "other._ndarray_values.take": [
                    3618
                ],
                "self._wrap_joined_index": [
                    3794,
                    3804,
                    3620,
                    3791
                ],
                "size": [
                    3646
                ],
                "labels": [
                    3649,
                    3650,
                    3656,
                    3657,
                    5258,
                    5259,
                    3661,
                    5263,
                    3646
                ],
                "lab": [
                    3712,
                    3650,
                    3651,
                    3657,
                    3658,
                    3724,
                    3661,
                    3662,
                    3730,
                    3733
                ],
                "sorter": [
                    3651,
                    3652
                ],
                "libalgos.groupsort_indexer": [
                    3651,
                    3718
                ],
                "libalgos": [
                    3651,
                    3718
                ],
                "lab.max": [
                    3651
                ],
                "tic": [
                    3656,
                    3658,
                    3660
                ],
                "starts": [
                    3660,
                    3662
                ],
                "np.hstack": [
                    3660
                ],
                "lib.get_level_sorter": [
                    3662
                ],
                "left._get_level_number": [
                    3674
                ],
                "old_level": [
                    3696,
                    3682,
                    3675
                ],
                "left.levels": [
                    3705,
                    3675
                ],
                "right.is_unique": [
                    3677
                ],
                "new_level": [
                    3682,
                    3706
                ],
                "left_lev_indexer": [
                    3696,
                    3682,
                    3686,
                    3695
                ],
                "right_lev_indexer": [
                    3682,
                    3747,
                    3749
                ],
                "old_level.join": [
                    3682
                ],
                "keep_order": [
                    3708,
                    3687
                ],
                "_get_leaf_sorter": [
                    3691,
                    3732
                ],
                "left.codes": [
                    3699,
                    3691,
                    3702
                ],
                "rev_indexer": [
                    3696,
                    3699
                ],
                "lib.get_reverse_indexer": [
                    3696
                ],
                "new_lev_codes": [
                    3717,
                    3719,
                    3727,
                    3698,
                    3703,
                    3710
                ],
                "np.intp": [
                    3709
                ],
                "mask.all": [
                    3728,
                    3711
                ],
                "ngroups": [
                    3717,
                    3719
                ],
                "new_lev_codes.max": [
                    3717
                ],
                "counts": [
                    3723,
                    3718
                ],
                "mask_all": [
                    3728,
                    3729,
                    3737
                ],
                "mask.nonzero": [
                    3738
                ],
                "left.names": [
                    3743
                ],
                "join_index.codes": [
                    3752,
                    3749
                ],
                "ret_index": [
                    3770,
                    3772,
                    3774
                ],
                "sv": [
                    3776,
                    3784,
                    3787,
                    3790,
                    3793,
                    3797,
                    3799,
                    3801,
                    3803
                ],
                "ov": [
                    3777,
                    3784,
                    3787,
                    3790,
                    3793,
                    3797,
                    3799,
                    3801,
                    3803
                ],
                "self._left_indexer_unique": [
                    3784,
                    3787
                ],
                "self._left_indexer": [
                    3797,
                    3799
                ],
                "joined": [
                    3815
                ],
                "Union": [
                    3843
                ],
                "self._internal_get_values": [
                    3923
                ],
                "memory_usage": [
                    3930
                ],
                "self._engine.sizeof": [
                    3933
                ],
                "IndexOpsMixin.memory_usage.__doc__": [
                    3928
                ],
                "IndexOpsMixin.memory_usage": [
                    3928
                ],
                "is_bool": [
                    3961
                ],
                "values.astype": [
                    3964
                ],
                "cond": [
                    3967
                ],
                "self._is_numeric_dtype": [
                    3969,
                    4071
                ],
                "np.any": [
                    3969,
                    5471
                ],
                "cls.__name__": [
                    4027
                ],
                "item": [
                    5234,
                    5235,
                    4076,
                    4071
                ],
                "getitem": [
                    4194,
                    4204,
                    4210,
                    4199
                ],
                "self._data.__getitem__": [
                    4194
                ],
                "promote": [
                    4212,
                    4195,
                    4204
                ],
                "com.cast_scalar_indexer": [
                    4198
                ],
                "com.is_bool_indexer": [
                    4206
                ],
                "com.values_from_object": [
                    4329,
                    4653,
                    4654,
                    4209,
                    4690
                ],
                "self.is_categorical": [
                    4225
                ],
                "to_concat": [
                    4256,
                    4260,
                    4263,
                    4264,
                    4272,
                    4273,
                    4242,
                    4276,
                    4245,
                    4247,
                    4280,
                    4249,
                    4282,
                    4253
                ],
                "to_concat.append": [
                    4247
                ],
                "obj": [
                    4249,
                    4250,
                    4253
                ],
                "obj.name": [
                    4253
                ],
                "self._concat": [
                    4256
                ],
                "typs": [
                    4260,
                    4262
                ],
                "_concat.get_dtype_kinds": [
                    4260
                ],
                "_concat": [
                    4260
                ],
                "self._concat_same_dtype": [
                    4263
                ],
                "Index._concat_same_dtype": [
                    4264
                ],
                "klasses": [
                    4273,
                    4271
                ],
                "ABCDatetimeIndex": [
                    4271
                ],
                "x.astype": [
                    4273
                ],
                "x._values": [
                    4280
                ],
                "np.concatenate": [
                    4282,
                    5235
                ],
                "self._convert_for_op": [
                    4298
                ],
                "err": [
                    5093,
                    4302
                ],
                "putmask": [
                    4305
                ],
                "self.is_": [
                    4317
                ],
                "other.equals": [
                    4325
                ],
                "array_equivalent": [
                    4328
                ],
                "c": [
                    4349,
                    4350
                ],
                "self._comparables": [
                    4350
                ],
                "label": [
                    5090,
                    5028,
                    5030,
                    5034,
                    5035,
                    5037,
                    5041,
                    5079,
                    5047,
                    5083,
                    4413,
                    5087
                ],
                "loc.indices": [
                    4418
                ],
                "locs": [
                    4456,
                    4450,
                    4451,
                    4453
                ],
                "searchsorted": [
                    4450,
                    5046
                ],
                "where.values": [
                    4456,
                    4450
                ],
                "where": [
                    4456,
                    4450
                ],
                "first": [
                    4456,
                    4455
                ],
                "mask.argmax": [
                    4455
                ],
                "_as": [
                    4505,
                    4507,
                    4510,
                    4503
                ],
                "self.argsort": [
                    4503
                ],
                "sorted_index": [
                    4512,
                    4507,
                    4510
                ],
                "return_indexer": [
                    4509
                ],
                "self.asi8": [
                    4613
                ],
                "result.argsort": [
                    4616
                ],
                "args": [
                    4616
                ],
                "s": [
                    4646,
                    4651,
                    4653,
                    4658,
                    4664,
                    4636,
                    4637
                ],
                "series": [
                    4658,
                    4636,
                    4653
                ],
                "iloc": [
                    4645,
                    4646
                ],
                "self.is_boolean": [
                    4648,
                    4660
                ],
                "self._convert_scalar_indexer": [
                    4656
                ],
                "self._engine.get_value": [
                    4658
                ],
                "series.dtype": [
                    4658
                ],
                "libindex.get_value_at": [
                    4664
                ],
                "e1": [
                    4672,
                    4674
                ],
                "self._engine.set_value": [
                    4689
                ],
                "arr": [
                    4690
                ],
                "pself.get_indexer_non_unique": [
                    4720
                ],
                "is_categorical": [
                    4722
                ],
                "tgt_values": [
                    4729,
                    4723,
                    4725,
                    4727
                ],
                "self.is_all_dates": [
                    4724
                ],
                "target.asi8": [
                    4725
                ],
                "self._engine.get_indexer_non_unique": [
                    4729
                ],
                "values.values": [
                    4778
                ],
                "ensure_categorical": [
                    4779
                ],
                "values._reverse_indexer": [
                    4780
                ],
                "result.items": [
                    4783
                ],
                "new_values": [
                    4809,
                    4814,
                    4818,
                    4821,
                    4824,
                    4828
                ],
                "_map_values": [
                    4809
                ],
                "na_action": [
                    4809
                ],
                "new_values.size": [
                    4824,
                    4814
                ],
                "attributes.get": [
                    4817,
                    4818
                ],
                "algos.isin": [
                    4911
                ],
                "start_slice": [
                    4960,
                    4965,
                    5196,
                    5169,
                    5171,
                    5172,
                    5173,
                    5203,
                    5204,
                    5206,
                    4957
                ],
                "end_slice": [
                    4962,
                    4965,
                    5196,
                    5201,
                    5202,
                    5206,
                    5175,
                    5177,
                    5178,
                    5179,
                    4957
                ],
                "self.slice_locs": [
                    4957
                ],
                "end": [
                    5155,
                    5159,
                    5162,
                    5176,
                    5177,
                    4957
                ],
                "ckey": [
                    4976,
                    4977,
                    4975
                ],
                "self.searchsorted": [
                    5041
                ],
                "pos": [
                    5049,
                    5046
                ],
                "original_label": [
                    5105,
                    5079
                ],
                "self._maybe_cast_slice_bound": [
                    5083
                ],
                "slc": [
                    5095,
                    5098,
                    5099,
                    5101,
                    5102,
                    5108,
                    5110,
                    5112,
                    5115,
                    5117,
                    5087
                ],
                "lib.maybe_booleans_to_slice": [
                    5099
                ],
                "slc.view": [
                    5099
                ],
                "lib.maybe_indices_to_slice": [
                    5101
                ],
                "slc.astype": [
                    5101
                ],
                "slc.start": [
                    5110
                ],
                "slc.stop": [
                    5112
                ],
                "inc": [
                    5153,
                    5181,
                    5151
                ],
                "datetime": [
                    5159
                ],
                "ts_start": [
                    5161,
                    5166
                ],
                "Timestamp": [
                    5161,
                    5162
                ],
                "ts_end": [
                    5162,
                    5166
                ],
                "tz_compare": [
                    5166
                ],
                "ts_start.tzinfo": [
                    5166
                ],
                "ts_end.tzinfo": [
                    5166
                ],
                "self.get_slice_bound": [
                    5177,
                    5171
                ],
                "np.delete": [
                    5216
                ],
                "_self": [
                    5233,
                    5235
                ],
                "self._coerce_scalar_to_index": [
                    5234
                ],
                "arr_dtype": [
                    5257,
                    5258
                ],
                "com.index_labels_to_array": [
                    5258
                ],
                "errors": [
                    5262
                ],
                "self.delete": [
                    5265
                ],
                "cls.__eq__": [
                    5275
                ],
                "_make_comparison_op": [
                    5280,
                    5275,
                    5276,
                    5277,
                    5278,
                    5279
                ],
                "operator.eq": [
                    5275
                ],
                "cls.__ne__": [
                    5276
                ],
                "operator.ne": [
                    5276
                ],
                "cls.__lt__": [
                    5277
                ],
                "cls.__gt__": [
                    5278
                ],
                "operator.gt": [
                    5278
                ],
                "cls.__le__": [
                    5279
                ],
                "cls.__ge__": [
                    5280
                ],
                "operator.ge": [
                    5280
                ],
                "cls.__add__": [
                    5319,
                    5287
                ],
                "make_invalid_op": [
                    5287,
                    5288,
                    5289,
                    5290,
                    5291,
                    5292,
                    5299,
                    5300,
                    5301,
                    5302,
                    5303,
                    5304,
                    5305,
                    5306,
                    5307,
                    5308,
                    5309,
                    5310,
                    5311,
                    5312,
                    5479,
                    5480
                ],
                "cls.__radd__": [
                    5288,
                    5320
                ],
                "cls.__iadd__": [
                    5289
                ],
                "cls.__sub__": [
                    5321,
                    5290
                ],
                "cls.__rsub__": [
                    5322,
                    5291
                ],
                "cls.__isub__": [
                    5292
                ],
                "cls.__pow__": [
                    5299,
                    5324
                ],
                "cls.__rpow__": [
                    5323,
                    5300
                ],
                "cls.__mul__": [
                    5301,
                    5334
                ],
                "cls.__rmul__": [
                    5302,
                    5335
                ],
                "cls.__floordiv__": [
                    5331,
                    5303
                ],
                "cls.__rfloordiv__": [
                    5304,
                    5332
                ],
                "cls.__truediv__": [
                    5305,
                    5326
                ],
                "cls.__rtruediv__": [
                    5306,
                    5327
                ],
                "cls.__mod__": [
                    5330,
                    5307
                ],
                "cls.__divmod__": [
                    5308,
                    5333
                ],
                "cls.__neg__": [
                    5352,
                    5309
                ],
                "cls.__pos__": [
                    5353,
                    5310
                ],
                "cls.__abs__": [
                    5354,
                    5311
                ],
                "cls.__inv__": [
                    5312,
                    5355
                ],
                "_make_arithmetic_op": [
                    5319,
                    5320,
                    5321,
                    5322,
                    5323,
                    5324,
                    5326,
                    5327,
                    5330,
                    5331,
                    5332,
                    5333,
                    5334,
                    5335
                ],
                "operator.add": [
                    5319
                ],
                "ops.radd": [
                    5320
                ],
                "operator.sub": [
                    5321
                ],
                "ops.rsub": [
                    5322
                ],
                "ops.rpow": [
                    5323
                ],
                "operator.pow": [
                    5324
                ],
                "operator.truediv": [
                    5326
                ],
                "ops.rtruediv": [
                    5327
                ],
                "operator.mod": [
                    5330
                ],
                "operator.floordiv": [
                    5331
                ],
                "ops.rfloordiv": [
                    5332
                ],
                "operator.mul": [
                    5334
                ],
                "ops.rmul": [
                    5335
                ],
                "_evaluate_numeric_unary.__name__": [
                    5349
                ],
                "_evaluate_numeric_unary": [
                    5349,
                    5350
                ],
                "opstr": [
                    5349
                ],
                "_make_evaluate_unary": [
                    5352,
                    5353,
                    5354,
                    5355
                ],
                "operator.neg": [
                    5352
                ],
                "operator.pos": [
                    5353
                ],
                "np.abs": [
                    5354
                ],
                "cls._add_numeric_methods_unary": [
                    5359
                ],
                "cls._add_numeric_methods_binary": [
                    5360
                ],
                "_doc": [
                    5452,
                    5367
                ],
                "dedent": [
                    5424,
                    5382
                ],
                "f": [
                    5454
                ],
                "result.ndim": [
                    5457
                ],
                "result.dtype.type": [
                    5460
                ],
                "result.dtype": [
                    5460
                ],
                "result.item": [
                    5460
                ],
                "Substitution": [
                    5450
                ],
                "desc": [
                    5450
                ],
                "logical_func.__name__": [
                    5464
                ],
                "logical_func": [
                    5464,
                    5465
                ],
                "cls.all": [
                    5467,
                    5479
                ],
                "_make_logical_function": [
                    5467,
                    5470
                ],
                "np.all": [
                    5468
                ],
                "cls.any": [
                    5480,
                    5470
                ],
                "self._values.shape": [
                    5490
                ],
                "Index._add_numeric_methods_disabled": [
                    5493
                ],
                "Index._add_logical_methods": [
                    5494
                ],
                "Index._add_comparison_methods": [
                    5495
                ],
                "sequences": [
                    5536,
                    5531,
                    5534
                ],
                "MultiIndex.from_arrays": [
                    5536,
                    5592
                ],
                "index_like": [
                    5601,
                    5571,
                    5603,
                    5573,
                    5574,
                    5575,
                    5576,
                    5578,
                    5579,
                    5583,
                    5584,
                    5585,
                    5587,
                    5594
                ],
                "index_like.copy": [
                    5573
                ],
                "index_like.name": [
                    5576
                ],
                "converted": [
                    5592,
                    5594,
                    5587,
                    5589
                ],
                "all_arrays": [
                    5587,
                    5589
                ],
                "lib.clean_index_list": [
                    5587
                ],
                "seq": [
                    5611,
                    5613,
                    5615
                ],
                "trimmed": [
                    5624,
                    5625,
                    5622,
                    5623
                ],
                "strings": [
                    5622,
                    5623
                ],
                "n": [
                    5636
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_146/pandas/tests/dtypes/test_missing.py",
                "test_function": "test_array_equivalent_tzawareness",
                "test_function_code": "@pytest.mark.parametrize(\n    \"lvalue, rvalue\",\n    [\n        # There are 3 variants for each of lvalue and rvalue. We include all\n        #  three for the tz-naive `now` and exclude the datetim64 variant\n        #  for utcnow because it drops tzinfo.\n        (now, utcnow),\n        (now.to_datetime64(), utcnow),\n        (now.to_pydatetime(), utcnow),\n        (now, utcnow),\n        (now.to_datetime64(), utcnow.to_pydatetime()),\n        (now.to_pydatetime(), utcnow.to_pydatetime()),\n    ],\n)\ndef test_array_equivalent_tzawareness(lvalue, rvalue):\n    # we shouldn't raise if comparing tzaware and tznaive datetimes\n    left = np.array([lvalue], dtype=object)\n    right = np.array([rvalue], dtype=object)\n\n    assert not array_equivalent(left, right, strict_nan=True)\n    assert not array_equivalent(left, right, strict_nan=False)",
                "test_error": "TypeError: Cannot compare tz-naive and tz-aware timestamps",
                "full_test_error": "lvalue = Timestamp('2023-12-11 19:48:37.250741')\nrvalue = Timestamp('2023-12-11 19:48:37.250861+0000', tz='UTC')\n\n    @pytest.mark.parametrize(\n        \"lvalue, rvalue\",\n        [\n            # There are 3 variants for each of lvalue and rvalue. We include all\n            #  three for the tz-naive `now` and exclude the datetim64 variant\n            #  for utcnow because it drops tzinfo.\n            (now, utcnow),\n            (now.to_datetime64(), utcnow),\n            (now.to_pydatetime(), utcnow),\n            (now, utcnow),\n            (now.to_datetime64(), utcnow.to_pydatetime()),\n            (now.to_pydatetime(), utcnow.to_pydatetime()),\n        ],\n    )\n    def test_array_equivalent_tzawareness(lvalue, rvalue):\n        # we shouldn't raise if comparing tzaware and tznaive datetimes\n        left = np.array([lvalue], dtype=object)\n        right = np.array([rvalue], dtype=object)\n    \n>       assert not array_equivalent(left, right, strict_nan=True)\n\npandas/tests/dtypes/test_missing.py:357: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/dtypes/missing.py:448: in array_equivalent\n    if np.any(left_value != right_value):\npandas/_libs/tslibs/c_timestamp.pyx:118: in pandas._libs.tslibs.c_timestamp._Timestamp.__richcmp__\n    self._assert_tzawareness_compat(other)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>   raise TypeError('Cannot compare tz-naive and tz-aware '\nE   TypeError: Cannot compare tz-naive and tz-aware timestamps\n\npandas/_libs/tslibs/c_timestamp.pyx:179: TypeError",
                "traceback": "pandas/core/dtypes/missing.py:448: in array_equivalent\n    if np.any(left_value != right_value):\npandas/_libs/tslibs/c_timestamp.pyx:118: in pandas._libs.tslibs.c_timestamp._Timestamp.__richcmp__\n    self._assert_tzawareness_compat(other)",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>   raise TypeError('Cannot compare tz-naive and tz-aware '\nE   TypeError: Cannot compare tz-naive and tz-aware timestamps\n\npandas/_libs/tslibs/c_timestamp.pyx:179: TypeError",
                "test_function_decorators": [
                    "pytest.mark.parametrize('lvalue, rvalue', [(now, utcnow), (now.to_datetime64(), utcnow), (now.to_pydatetime(), utcnow), (now, utcnow), (now.to_datetime64(), utcnow.to_pydatetime()), (now.to_pydatetime(), utcnow.to_pydatetime())])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_146/pandas/tests/dtypes/test_missing.py",
                "test_function": "test_array_equivalent_tzawareness",
                "test_function_code": "@pytest.mark.parametrize(\n    \"lvalue, rvalue\",\n    [\n        # There are 3 variants for each of lvalue and rvalue. We include all\n        #  three for the tz-naive `now` and exclude the datetim64 variant\n        #  for utcnow because it drops tzinfo.\n        (now, utcnow),\n        (now.to_datetime64(), utcnow),\n        (now.to_pydatetime(), utcnow),\n        (now, utcnow),\n        (now.to_datetime64(), utcnow.to_pydatetime()),\n        (now.to_pydatetime(), utcnow.to_pydatetime()),\n    ],\n)\ndef test_array_equivalent_tzawareness(lvalue, rvalue):\n    # we shouldn't raise if comparing tzaware and tznaive datetimes\n    left = np.array([lvalue], dtype=object)\n    right = np.array([rvalue], dtype=object)\n\n    assert not array_equivalent(left, right, strict_nan=True)\n    assert not array_equivalent(left, right, strict_nan=False)",
                "test_error": "TypeError: Cannot compare tz-naive and tz-aware timestamps",
                "full_test_error": "lvalue = numpy.datetime64('2023-12-11T19:48:37.250741000')\nrvalue = Timestamp('2023-12-11 19:48:37.250861+0000', tz='UTC')\n\n    @pytest.mark.parametrize(\n        \"lvalue, rvalue\",\n        [\n            # There are 3 variants for each of lvalue and rvalue. We include all\n            #  three for the tz-naive `now` and exclude the datetim64 variant\n            #  for utcnow because it drops tzinfo.\n            (now, utcnow),\n            (now.to_datetime64(), utcnow),\n            (now.to_pydatetime(), utcnow),\n            (now, utcnow),\n            (now.to_datetime64(), utcnow.to_pydatetime()),\n            (now.to_pydatetime(), utcnow.to_pydatetime()),\n        ],\n    )\n    def test_array_equivalent_tzawareness(lvalue, rvalue):\n        # we shouldn't raise if comparing tzaware and tznaive datetimes\n        left = np.array([lvalue], dtype=object)\n        right = np.array([rvalue], dtype=object)\n    \n>       assert not array_equivalent(left, right, strict_nan=True)\n\npandas/tests/dtypes/test_missing.py:357: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/dtypes/missing.py:448: in array_equivalent\n    if np.any(left_value != right_value):\npandas/_libs/tslibs/c_timestamp.pyx:114: in pandas._libs.tslibs.c_timestamp._Timestamp.__richcmp__\n    return PyObject_RichCompare(other, self, reverse_ops[op])\npandas/_libs/tslibs/c_timestamp.pyx:118: in pandas._libs.tslibs.c_timestamp._Timestamp.__richcmp__\n    self._assert_tzawareness_compat(other)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>   raise TypeError('Cannot compare tz-naive and tz-aware '\nE   TypeError: Cannot compare tz-naive and tz-aware timestamps\n\npandas/_libs/tslibs/c_timestamp.pyx:179: TypeError",
                "traceback": "pandas/core/dtypes/missing.py:448: in array_equivalent\n    if np.any(left_value != right_value):\npandas/_libs/tslibs/c_timestamp.pyx:114: in pandas._libs.tslibs.c_timestamp._Timestamp.__richcmp__\n    return PyObject_RichCompare(other, self, reverse_ops[op])\npandas/_libs/tslibs/c_timestamp.pyx:118: in pandas._libs.tslibs.c_timestamp._Timestamp.__richcmp__\n    self._assert_tzawareness_compat(other)",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>   raise TypeError('Cannot compare tz-naive and tz-aware '\nE   TypeError: Cannot compare tz-naive and tz-aware timestamps\n\npandas/_libs/tslibs/c_timestamp.pyx:179: TypeError",
                "test_function_decorators": [
                    "pytest.mark.parametrize('lvalue, rvalue', [(now, utcnow), (now.to_datetime64(), utcnow), (now.to_pydatetime(), utcnow), (now, utcnow), (now.to_datetime64(), utcnow.to_pydatetime()), (now.to_pydatetime(), utcnow.to_pydatetime())])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_146/pandas/tests/dtypes/test_missing.py",
                "test_function": "test_array_equivalent_tzawareness",
                "test_function_code": "@pytest.mark.parametrize(\n    \"lvalue, rvalue\",\n    [\n        # There are 3 variants for each of lvalue and rvalue. We include all\n        #  three for the tz-naive `now` and exclude the datetim64 variant\n        #  for utcnow because it drops tzinfo.\n        (now, utcnow),\n        (now.to_datetime64(), utcnow),\n        (now.to_pydatetime(), utcnow),\n        (now, utcnow),\n        (now.to_datetime64(), utcnow.to_pydatetime()),\n        (now.to_pydatetime(), utcnow.to_pydatetime()),\n    ],\n)\ndef test_array_equivalent_tzawareness(lvalue, rvalue):\n    # we shouldn't raise if comparing tzaware and tznaive datetimes\n    left = np.array([lvalue], dtype=object)\n    right = np.array([rvalue], dtype=object)\n\n    assert not array_equivalent(left, right, strict_nan=True)\n    assert not array_equivalent(left, right, strict_nan=False)",
                "test_error": "TypeError: Cannot compare tz-naive and tz-aware timestamps",
                "full_test_error": "lvalue = Timestamp('2023-12-11 19:48:37.250741')\nrvalue = Timestamp('2023-12-11 19:48:37.250861+0000', tz='UTC')\n\n    @pytest.mark.parametrize(\n        \"lvalue, rvalue\",\n        [\n            # There are 3 variants for each of lvalue and rvalue. We include all\n            #  three for the tz-naive `now` and exclude the datetim64 variant\n            #  for utcnow because it drops tzinfo.\n            (now, utcnow),\n            (now.to_datetime64(), utcnow),\n            (now.to_pydatetime(), utcnow),\n            (now, utcnow),\n            (now.to_datetime64(), utcnow.to_pydatetime()),\n            (now.to_pydatetime(), utcnow.to_pydatetime()),\n        ],\n    )\n    def test_array_equivalent_tzawareness(lvalue, rvalue):\n        # we shouldn't raise if comparing tzaware and tznaive datetimes\n        left = np.array([lvalue], dtype=object)\n        right = np.array([rvalue], dtype=object)\n    \n>       assert not array_equivalent(left, right, strict_nan=True)\n\npandas/tests/dtypes/test_missing.py:357: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/dtypes/missing.py:448: in array_equivalent\n    if np.any(left_value != right_value):\npandas/_libs/tslibs/c_timestamp.pyx:118: in pandas._libs.tslibs.c_timestamp._Timestamp.__richcmp__\n    self._assert_tzawareness_compat(other)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>   raise TypeError('Cannot compare tz-naive and tz-aware '\nE   TypeError: Cannot compare tz-naive and tz-aware timestamps\n\npandas/_libs/tslibs/c_timestamp.pyx:179: TypeError",
                "traceback": "pandas/core/dtypes/missing.py:448: in array_equivalent\n    if np.any(left_value != right_value):\npandas/_libs/tslibs/c_timestamp.pyx:118: in pandas._libs.tslibs.c_timestamp._Timestamp.__richcmp__\n    self._assert_tzawareness_compat(other)",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>   raise TypeError('Cannot compare tz-naive and tz-aware '\nE   TypeError: Cannot compare tz-naive and tz-aware timestamps\n\npandas/_libs/tslibs/c_timestamp.pyx:179: TypeError",
                "test_function_decorators": [
                    "pytest.mark.parametrize('lvalue, rvalue', [(now, utcnow), (now.to_datetime64(), utcnow), (now.to_pydatetime(), utcnow), (now, utcnow), (now.to_datetime64(), utcnow.to_pydatetime()), (now.to_pydatetime(), utcnow.to_pydatetime())])"
                ]
            }
        ]
    }
}