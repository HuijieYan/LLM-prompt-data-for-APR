{
    "pandas:156": {
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_156/pandas/core/sparse/frame.py": {
            "buggy_functions": [
                {
                    "function_name": "_combine_match_index",
                    "function_code": "def _combine_match_index(self, other, func, level=None):\n\n    if level is not None:\n        raise NotImplementedError(\"'level' argument is not supported\")\n\n    this, other = self.align(other, join=\"outer\", axis=0, level=level, copy=False)\n\n    new_data = {}\n    for col, series in this.items():\n        new_data[col] = func(series.values, other.values)\n\n    fill_value = self._get_op_result_fill_value(other, func)\n\n    return self._constructor(\n        new_data,\n        index=this.index,\n        columns=self.columns,\n        default_fill_value=fill_value,\n    ).__finalize__(self)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 571,
                    "end_line": 589,
                    "variables": {
                        "level": [
                            576,
                            573
                        ],
                        "NotImplementedError": [
                            574
                        ],
                        "this": [
                            576,
                            586,
                            579
                        ],
                        "other": [
                            576,
                            580,
                            582
                        ],
                        "self.align": [
                            576
                        ],
                        "self": [
                            576,
                            582,
                            584,
                            587,
                            589
                        ],
                        "new_data": [
                            585,
                            578,
                            580
                        ],
                        "col": [
                            579,
                            580
                        ],
                        "series": [
                            579,
                            580
                        ],
                        "this.items": [
                            579
                        ],
                        "func": [
                            580,
                            582
                        ],
                        "series.values": [
                            580
                        ],
                        "other.values": [
                            580
                        ],
                        "fill_value": [
                            588,
                            582
                        ],
                        "self._get_op_result_fill_value": [
                            582
                        ],
                        "__finalize__": [
                            584
                        ],
                        "self._constructor": [
                            584
                        ],
                        "this.index": [
                            586
                        ],
                        "self.columns": [
                            587
                        ]
                    },
                    "filtered_variables": {
                        "level": [
                            576,
                            573
                        ],
                        "this": [
                            576,
                            586,
                            579
                        ],
                        "other": [
                            576,
                            580,
                            582
                        ],
                        "self.align": [
                            576
                        ],
                        "self": [
                            576,
                            582,
                            584,
                            587,
                            589
                        ],
                        "new_data": [
                            585,
                            578,
                            580
                        ],
                        "col": [
                            579,
                            580
                        ],
                        "series": [
                            579,
                            580
                        ],
                        "this.items": [
                            579
                        ],
                        "func": [
                            580,
                            582
                        ],
                        "series.values": [
                            580
                        ],
                        "other.values": [
                            580
                        ],
                        "fill_value": [
                            588,
                            582
                        ],
                        "self._get_op_result_fill_value": [
                            582
                        ],
                        "__finalize__": [
                            584
                        ],
                        "self._constructor": [
                            584
                        ],
                        "this.index": [
                            586
                        ],
                        "self.columns": [
                            587
                        ]
                    },
                    "diff_line_number": 579,
                    "class_data": {
                        "signature": "class SparseDataFrame(DataFrame)",
                        "docstring": "DataFrame containing sparse floating point data in the form of SparseSeries\nobjects\n\n.. deprecated:: 0.25.0\n\n   Use a DataFrame with sparse values instead.\n\nParameters\n----------\ndata : same types as can be passed to DataFrame or scipy.sparse.spmatrix\n    .. versionchanged:: 0.23.0\n       If data is a dict, argument order is maintained for Python 3.6\n       and later.\n\nindex : array-like, optional\ncolumn : array-like, optional\ndefault_kind : {'block', 'integer'}, default 'block'\n    Default sparse kind for converting Series to SparseSeries. Will not\n    override SparseSeries passed into constructor\ndefault_fill_value : float\n    Default fill_value for converting Series to SparseSeries\n    (default: nan). Will not override SparseSeries passed in.",
                        "constructor_docstring": null,
                        "functions": [
                            "def __init__(self, data=None, index=None, columns=None, default_kind=None, default_fill_value=None, dtype=None, copy=False):\n    if not is_scalar(default_fill_value):\n        raise ValueError(\"'default_fill_value' must be a scalar\")\n    warnings.warn(depr_msg, FutureWarning, stacklevel=2)\n    if isinstance(data, SparseDataFrame):\n        if index is None:\n            index = data.index\n        if columns is None:\n            columns = data.columns\n        if default_fill_value is None:\n            default_fill_value = data.default_fill_value\n        if default_kind is None:\n            default_kind = data.default_kind\n    elif isinstance(data, (SparseSeries, SparseArray)):\n        if index is None:\n            index = data.index\n        if default_fill_value is None:\n            default_fill_value = data.fill_value\n        if columns is None and hasattr(data, 'name'):\n            columns = [data.name]\n        if columns is None:\n            raise Exception('cannot pass a series w/o a name or columns')\n        data = {columns[0]: data}\n    if default_fill_value is None:\n        default_fill_value = np.nan\n    if default_kind is None:\n        default_kind = 'block'\n    self._default_kind = default_kind\n    self._default_fill_value = default_fill_value\n    if is_scipy_sparse(data):\n        mgr = self._init_spmatrix(data, index, columns, dtype=dtype, fill_value=default_fill_value)\n    elif isinstance(data, dict):\n        mgr = self._init_dict(data, index, columns, dtype=dtype)\n    elif isinstance(data, (np.ndarray, list)):\n        mgr = self._init_matrix(data, index, columns, dtype=dtype)\n    elif isinstance(data, SparseDataFrame):\n        mgr = self._init_mgr(data._data, dict(index=index, columns=columns), dtype=dtype, copy=copy)\n    elif isinstance(data, DataFrame):\n        mgr = self._init_dict(data, data.index, data.columns, dtype=dtype)\n    elif isinstance(data, Series):\n        mgr = self._init_dict(data.to_frame(), data.index, columns=None, dtype=dtype)\n    elif isinstance(data, BlockManager):\n        mgr = self._init_mgr(data, axes=dict(index=index, columns=columns), dtype=dtype, copy=copy)\n    elif data is None:\n        data = DataFrame()\n        if index is None:\n            index = Index([])\n        else:\n            index = ensure_index(index)\n        if columns is None:\n            columns = Index([])\n        else:\n            for c in columns:\n                data[c] = SparseArray(self._default_fill_value, index=index, kind=self._default_kind, fill_value=self._default_fill_value)\n        mgr = to_manager(data, columns, index)\n        if dtype is not None:\n            mgr = mgr.astype(dtype)\n    else:\n        msg = 'SparseDataFrame called with unknown type \"{data_type}\" for data argument'\n        raise TypeError(msg.format(data_type=type(data).__name__))\n    generic.NDFrame.__init__(self, mgr)",
                            "@property\ndef _constructor(self):\n    return SparseDataFrame",
                            "def _init_dict(self, data, index, columns, dtype=None):\n    if columns is not None:\n        columns = ensure_index(columns)\n        data = {k: v for k, v in data.items() if k in columns}\n    else:\n        keys = com.dict_keys_to_ordered_list(data)\n        columns = Index(keys)\n    if index is None:\n        index = extract_index(list(data.values()))\n\n    def sp_maker(x):\n        return SparseArray(x, kind=self._default_kind, fill_value=self._default_fill_value, copy=True, dtype=dtype)\n    sdict = {}\n    for k, v in data.items():\n        if isinstance(v, Series):\n            if not v.index.equals(index):\n                v = v.reindex(index)\n            if not isinstance(v, SparseSeries):\n                v = sp_maker(v.values)\n        elif isinstance(v, SparseArray):\n            v = v.copy()\n        else:\n            if isinstance(v, dict):\n                v = [v.get(i, np.nan) for i in index]\n            v = sp_maker(v)\n        if index is not None and len(v) != len(index):\n            msg = 'Length of passed values is {}, index implies {}'\n            raise ValueError(msg.format(len(v), len(index)))\n        sdict[k] = v\n    if len(columns.difference(sdict)):\n        nan_arr = np.empty(len(index), dtype='float64')\n        nan_arr.fill(np.nan)\n        nan_arr = SparseArray(nan_arr, kind=self._default_kind, fill_value=self._default_fill_value, copy=False)\n        sdict.update(((c, nan_arr) for c in columns if c not in sdict))\n    return to_manager(sdict, columns, index)",
                            "def _init_matrix(self, data, index, columns, dtype=None):\n    \"\"\"\n    Init self from ndarray or list of lists.\n    \"\"\"\n    data = prep_ndarray(data, copy=False)\n    index, columns = SparseFrameAccessor._prep_index(data, index, columns)\n    data = {idx: data[:, i] for i, idx in enumerate(columns)}\n    return self._init_dict(data, index, columns, dtype)",
                            "def _init_spmatrix(self, data, index, columns, dtype=None, fill_value=None):\n    \"\"\"\n    Init self from scipy.sparse matrix.\n    \"\"\"\n    index, columns = SparseFrameAccessor._prep_index(data, index, columns)\n    data = data.tocoo()\n    N = len(index)\n    sdict = {}\n    values = Series(data.data, index=data.row, copy=False)\n    for col, rowvals in values.groupby(data.col):\n        rowvals = rowvals.sort_index()\n        rows = rowvals.index.values.astype(np.int32)\n        blocs, blens = get_blocks(rows)\n        sdict[columns[col]] = SparseSeries(rowvals.values, index=index, fill_value=fill_value, sparse_index=BlockIndex(N, blocs, blens))\n    sdict.update({column: SparseSeries(index=index, fill_value=fill_value, sparse_index=BlockIndex(N, [], [])) for column in columns if column not in sdict})\n    return self._init_dict(sdict, index, columns, dtype)",
                            "@Appender(SparseFrameAccessor.to_coo.__doc__)\ndef to_coo(self):\n    return SparseFrameAccessor(self).to_coo()",
                            "def __repr__(self):\n    with warnings.catch_warnings():\n        warnings.filterwarnings('ignore', 'Sparse')\n        return super().__repr__()",
                            "def __getstate__(self):\n    return dict(_typ=self._typ, _subtyp=self._subtyp, _data=self._data, _default_fill_value=self._default_fill_value, _default_kind=self._default_kind)",
                            "def _unpickle_sparse_frame_compat(self, state):\n    \"\"\"\n    Original pickle format\n    \"\"\"\n    series, cols, idx, fv, kind = state\n    if not isinstance(cols, Index):\n        from pandas.io.pickle import _unpickle_array\n        columns = _unpickle_array(cols)\n    else:\n        columns = cols\n    if not isinstance(idx, Index):\n        from pandas.io.pickle import _unpickle_array\n        index = _unpickle_array(idx)\n    else:\n        index = idx\n    series_dict = DataFrame()\n    for col, (sp_index, sp_values) in series.items():\n        series_dict[col] = SparseSeries(sp_values, sparse_index=sp_index, fill_value=fv)\n    self._data = to_manager(series_dict, columns, index)\n    self._default_fill_value = fv\n    self._default_kind = kind",
                            "@Appender(SparseFrameAccessor.to_dense.__doc__)\ndef to_dense(self):\n    return SparseFrameAccessor(self).to_dense()",
                            "def _apply_columns(self, func):\n    \"\"\"\n    Get new SparseDataFrame applying func to each columns\n    \"\"\"\n    new_data = {col: func(series) for col, series in self.items()}\n    return self._constructor(data=new_data, index=self.index, columns=self.columns, default_fill_value=self.default_fill_value).__finalize__(self)",
                            "def astype(self, dtype):\n    return self._apply_columns(lambda x: x.astype(dtype))",
                            "def copy(self, deep=True):\n    \"\"\"\n    Make a copy of this SparseDataFrame\n    \"\"\"\n    result = super().copy(deep=deep)\n    result._default_fill_value = self._default_fill_value\n    result._default_kind = self._default_kind\n    return result",
                            "@property\ndef default_fill_value(self):\n    return self._default_fill_value",
                            "@property\ndef default_kind(self):\n    return self._default_kind",
                            "@property\ndef density(self):\n    \"\"\"\n    Ratio of non-sparse points to total (dense) data points\n    represented in the frame\n    \"\"\"\n    tot_nonsparse = sum((ser.sp_index.npoints for _, ser in self.items()))\n    tot = len(self.index) * len(self.columns)\n    return tot_nonsparse / float(tot)",
                            "def fillna(self, value=None, method=None, axis=0, inplace=False, limit=None, downcast=None):\n    new_self = super().fillna(value=value, method=method, axis=axis, inplace=inplace, limit=limit, downcast=downcast)\n    if not inplace:\n        self = new_self\n    if value is not None and value == value and (method is None) and (limit is None):\n        self._default_fill_value = value\n    if not inplace:\n        return self",
                            "def _sanitize_column(self, key, value, **kwargs):\n    \"\"\"\n    Creates a new SparseArray from the input value.\n\n    Parameters\n    ----------\n    key : object\n    value : scalar, Series, or array-like\n    kwargs : dict\n\n    Returns\n    -------\n    sanitized_column : SparseArray\n\n    \"\"\"\n\n    def sp_maker(x, index=None):\n        return SparseArray(x, index=index, fill_value=self._default_fill_value, kind=self._default_kind)\n    if isinstance(value, SparseSeries):\n        clean = value.reindex(self.index).as_sparse_array(fill_value=self._default_fill_value, kind=self._default_kind)\n    elif isinstance(value, SparseArray):\n        if len(value) != len(self.index):\n            raise ValueError('Length of values does not match length of index')\n        clean = value\n    elif hasattr(value, '__iter__'):\n        if isinstance(value, Series):\n            clean = value.reindex(self.index)\n            if not isinstance(value, SparseSeries):\n                clean = sp_maker(clean)\n        else:\n            if len(value) != len(self.index):\n                raise ValueError('Length of values does not match length of index')\n            clean = sp_maker(value)\n    else:\n        clean = sp_maker(value, self.index)\n    return clean",
                            "def _get_value(self, index, col, takeable=False):\n    \"\"\"\n    Quickly retrieve single value at passed column and index\n\n    Please use .at[] or .iat[] accessors.\n\n    Parameters\n    ----------\n    index : row label\n    col : column label\n    takeable : interpret the index/col as indexers, default False\n\n    Returns\n    -------\n    value : scalar value\n    \"\"\"\n    if takeable is True:\n        series = self._iget_item_cache(col)\n    else:\n        series = self._get_item_cache(col)\n    return series._get_value(index, takeable=takeable)",
                            "def _slice(self, slobj, axis=0, kind=None):\n    if axis == 0:\n        new_index = self.index[slobj]\n        new_columns = self.columns\n    else:\n        new_index = self.index\n        new_columns = self.columns[slobj]\n    return self.reindex(index=new_index, columns=new_columns)",
                            "def xs(self, key, axis=0, copy=False):\n    \"\"\"\n    Returns a row (cross-section) from the SparseDataFrame as a Series\n    object.\n\n    Parameters\n    ----------\n    key : some index contained in the index\n\n    Returns\n    -------\n    xs : Series\n    \"\"\"\n    if axis == 1:\n        data = self[key]\n        return data\n    i = self.index.get_loc(key)\n    data = self.take([i])._internal_get_values()[0]\n    return Series(data, index=self.columns)",
                            "def _set_value(self, index, col, value, takeable=False):\n    \"\"\"\n    Put single value at passed column and index\n\n    Please use .at[] or .iat[] accessors.\n\n    Parameters\n    ----------\n    index : row label\n    col : column label\n    value : scalar value\n    takeable : interpret the index/col as indexers, default False\n\n    Notes\n    -----\n    This method *always* returns a new object. It is currently not\n    particularly efficient (and potentially very expensive) but is provided\n    for API compatibility with DataFrame\n\n    Returns\n    -------\n    frame : DataFrame\n    \"\"\"\n    dense = self.to_dense()._set_value(index, col, value, takeable=takeable)\n    return dense.to_sparse(kind=self._default_kind, fill_value=self._default_fill_value)",
                            "def _combine_frame(self, other, func, fill_value=None, level=None):\n    if level is not None:\n        raise NotImplementedError(\"'level' argument is not supported\")\n    this, other = self.align(other, join='outer', level=level, copy=False)\n    new_index, new_columns = (this.index, this.columns)\n    if self.empty and other.empty:\n        return self._constructor(index=new_index).__finalize__(self)\n    new_data = {}\n    if fill_value is not None:\n        for col in new_columns:\n            if col in this and col in other:\n                dleft = this[col].to_dense()\n                dright = other[col].to_dense()\n                result = dleft._binop(dright, func, fill_value=fill_value)\n                result = result.to_sparse(fill_value=this[col].fill_value)\n                new_data[col] = result\n    else:\n        for col in new_columns:\n            if col in this and col in other:\n                new_data[col] = func(this[col], other[col])\n    new_fill_value = self._get_op_result_fill_value(other, func)\n    return self._constructor(data=new_data, index=new_index, columns=new_columns, default_fill_value=new_fill_value).__finalize__(self)",
                            "def _combine_match_index(self, other, func, level=None):\n    if level is not None:\n        raise NotImplementedError(\"'level' argument is not supported\")\n    this, other = self.align(other, join='outer', axis=0, level=level, copy=False)\n    new_data = {}\n    for col, series in this.items():\n        new_data[col] = func(series.values, other.values)\n    fill_value = self._get_op_result_fill_value(other, func)\n    return self._constructor(new_data, index=this.index, columns=self.columns, default_fill_value=fill_value).__finalize__(self)",
                            "def _combine_match_columns(self, other, func, level=None):\n    if level is not None:\n        raise NotImplementedError(\"'level' argument is not supported\")\n    left, right = self.align(other, join='outer', axis=1, level=level, copy=False)\n    assert left.columns.equals(right.index)\n    new_data = {}\n    for col in left.columns:\n        new_data[col] = func(left[col], float(right[col]))\n    return self._constructor(new_data, index=left.index, columns=left.columns, default_fill_value=self.default_fill_value).__finalize__(self)",
                            "def _combine_const(self, other, func):\n    return self._apply_columns(lambda x: func(x, other))",
                            "def _get_op_result_fill_value(self, other, func):\n    own_default = self.default_fill_value\n    if isinstance(other, DataFrame):\n        other_default = getattr(other, 'default_fill_value', np.nan)\n        if own_default == other_default:\n            fill_value = own_default\n        elif np.isnan(own_default) and (not np.isnan(other_default)):\n            fill_value = other_default\n        elif not np.isnan(own_default) and np.isnan(other_default):\n            fill_value = own_default\n        else:\n            fill_value = None\n    elif isinstance(other, SparseSeries):\n        if isna(other.fill_value) or isna(own_default):\n            fill_value = np.nan\n        else:\n            fill_value = func(np.float64(own_default), np.float64(other.fill_value))\n            fill_value = item_from_zerodim(fill_value)\n    else:\n        raise NotImplementedError(type(other))\n    return fill_value",
                            "def _reindex_index(self, index, method, copy, level, fill_value=np.nan, limit=None, takeable=False):\n    if level is not None:\n        raise TypeError('Reindex by level not supported for sparse')\n    if self.index.equals(index):\n        if copy:\n            return self.copy()\n        else:\n            return self\n    if len(self.index) == 0:\n        return self._constructor(index=index, columns=self.columns).__finalize__(self)\n    indexer = self.index.get_indexer(index, method, limit=limit)\n    indexer = ensure_platform_int(indexer)\n    mask = indexer == -1\n    need_mask = mask.any()\n    new_series = {}\n    for col, series in self.items():\n        if mask.all():\n            continue\n        values = series.values\n        new = values.take(indexer)\n        if need_mask:\n            new = new.to_dense()\n            new, fill_value = maybe_upcast(new, fill_value=fill_value)\n            np.putmask(new, mask, fill_value)\n        new_series[col] = new\n    return self._constructor(new_series, index=index, columns=self.columns, default_fill_value=self._default_fill_value).__finalize__(self)",
                            "def _reindex_columns(self, columns, method, copy, level, fill_value=None, limit=None, takeable=False):\n    if level is not None:\n        raise TypeError('Reindex by level not supported for sparse')\n    if notna(fill_value):\n        raise NotImplementedError(\"'fill_value' argument is not supported\")\n    if limit:\n        raise NotImplementedError(\"'limit' argument is not supported\")\n    if method is not None:\n        raise NotImplementedError(\"'method' argument is not supported\")\n    sdict = {k: v for k, v in self.items() if k in columns}\n    return self._constructor(sdict, index=self.index, columns=columns, default_fill_value=self._default_fill_value).__finalize__(self)",
                            "def _reindex_with_indexers(self, reindexers, method=None, fill_value=None, limit=None, copy=False, allow_dups=False):\n    if method is not None or limit is not None:\n        raise NotImplementedError('cannot reindex with a method or limit with sparse')\n    if fill_value is None:\n        fill_value = np.nan\n    reindexers = {self._get_axis_number(a): val for a, val in reindexers.items()}\n    index, row_indexer = reindexers.get(0, (None, None))\n    columns, col_indexer = reindexers.get(1, (None, None))\n    if columns is None:\n        columns = self.columns\n    new_arrays = {}\n    for col in columns:\n        if col not in self:\n            continue\n        if row_indexer is not None:\n            new_arrays[col] = algos.take_1d(self[col]._internal_get_values(), row_indexer, fill_value=fill_value)\n        else:\n            new_arrays[col] = self[col]\n    return self._constructor(new_arrays, index=index, columns=columns).__finalize__(self)",
                            "def _join_compat(self, other, on=None, how='left', lsuffix='', rsuffix='', sort=False):\n    if on is not None:\n        raise NotImplementedError(\"'on' keyword parameter is not yet implemented\")\n    return self._join_index(other, how, lsuffix, rsuffix)",
                            "def _join_index(self, other, how, lsuffix, rsuffix):\n    if isinstance(other, Series):\n        if other.name is None:\n            raise ValueError('Other Series must have a name')\n        other = SparseDataFrame({other.name: other}, default_fill_value=self._default_fill_value)\n    join_index = self.index.join(other.index, how=how)\n    this = self.reindex(join_index)\n    other = other.reindex(join_index)\n    this, other = this._maybe_rename_join(other, lsuffix, rsuffix)\n    from pandas import concat\n    return concat([this, other], axis=1, verify_integrity=True)",
                            "def _maybe_rename_join(self, other, lsuffix, rsuffix):\n    to_rename = self.columns.intersection(other.columns)\n    if len(to_rename) > 0:\n        if not lsuffix and (not rsuffix):\n            raise ValueError('columns overlap but no suffix specified: {to_rename}'.format(to_rename=to_rename))\n\n        def lrenamer(x):\n            if x in to_rename:\n                return '{x}{lsuffix}'.format(x=x, lsuffix=lsuffix)\n            return x\n\n        def rrenamer(x):\n            if x in to_rename:\n                return '{x}{rsuffix}'.format(x=x, rsuffix=rsuffix)\n            return x\n        this = self.rename(columns=lrenamer)\n        other = other.rename(columns=rrenamer)\n    else:\n        this = self\n    return (this, other)",
                            "def transpose(self, *args, **kwargs):\n    \"\"\"\n    Returns a DataFrame with the rows/columns switched.\n    \"\"\"\n    nv.validate_transpose(args, kwargs)\n    return self._constructor(self.values.T, index=self.columns, columns=self.index, default_fill_value=self._default_fill_value, default_kind=self._default_kind).__finalize__(self)",
                            "@Appender(DataFrame.count.__doc__)\ndef count(self, axis=0, **kwds):\n    if axis is None:\n        axis = self._stat_axis_number\n    return self.apply(lambda x: x.count(), axis=axis)",
                            "def cumsum(self, axis=0, *args, **kwargs):\n    \"\"\"\n    Return SparseDataFrame of cumulative sums over requested axis.\n\n    Parameters\n    ----------\n    axis : {0, 1}\n        0 for row-wise, 1 for column-wise\n\n    Returns\n    -------\n    y : SparseDataFrame\n    \"\"\"\n    nv.validate_cumsum(args, kwargs)\n    if axis is None:\n        axis = self._stat_axis_number\n    return self.apply(lambda x: x.cumsum(), axis=axis)",
                            "@Appender(generic._shared_docs['isna'] % _shared_doc_kwargs)\ndef isna(self):\n    return self._apply_columns(lambda x: x.isna())",
                            "@Appender(generic._shared_docs['notna'] % _shared_doc_kwargs)\ndef notna(self):\n    return self._apply_columns(lambda x: x.notna())",
                            "def apply(self, func, axis=0, broadcast=None, reduce=None, result_type=None):\n    \"\"\"\n    Analogous to DataFrame.apply, for SparseDataFrame\n\n    Parameters\n    ----------\n    func : function\n        Function to apply to each column\n    axis : {0, 1, 'index', 'columns'}\n    broadcast : bool, default False\n        For aggregation functions, return object of same size with values\n        propagated\n\n        .. deprecated:: 0.23.0\n           This argument will be removed in a future version, replaced\n           by result_type='broadcast'.\n\n    reduce : boolean or None, default None\n        Try to apply reduction procedures. If the DataFrame is empty,\n        apply will use reduce to determine whether the result should be a\n        Series or a DataFrame. If reduce is None (the default), apply's\n        return value will be guessed by calling func an empty Series (note:\n        while guessing, exceptions raised by func will be ignored). If\n        reduce is True a Series will always be returned, and if False a\n        DataFrame will always be returned.\n\n        .. deprecated:: 0.23.0\n           This argument will be removed in a future version, replaced\n           by result_type='reduce'.\n\n    result_type : {'expand', 'reduce', 'broadcast, None}\n        These only act when axis=1 {columns}:\n\n        * 'expand' : list-like results will be turned into columns.\n        * 'reduce' : return a Series if possible rather than expanding\n          list-like results. This is the opposite to 'expand'.\n        * 'broadcast' : results will be broadcast to the original shape\n          of the frame, the original index & columns will be retained.\n\n        The default behaviour (None) depends on the return value of the\n        applied function: list-like results will be returned as a Series\n        of those. However if the apply function returns a Series these\n        are expanded to columns.\n\n        .. versionadded:: 0.23.0\n\n    Returns\n    -------\n    applied : Series or SparseDataFrame\n    \"\"\"\n    if not len(self.columns):\n        return self\n    axis = self._get_axis_number(axis)\n    if isinstance(func, np.ufunc):\n        new_series = {}\n        for k, v in self.items():\n            applied = func(v)\n            applied.fill_value = func(v.fill_value)\n            new_series[k] = applied\n        return self._constructor(new_series, index=self.index, columns=self.columns, default_fill_value=self._default_fill_value, default_kind=self._default_kind).__finalize__(self)\n    from pandas.core.apply import frame_apply\n    op = frame_apply(self, func=func, axis=axis, reduce=reduce, broadcast=broadcast, result_type=result_type)\n    return op.get_result()",
                            "def applymap(self, func):\n    \"\"\"\n    Apply a function to a DataFrame that is intended to operate\n    elementwise, i.e. like doing map(func, series) for each series in the\n    DataFrame\n\n    Parameters\n    ----------\n    func : function\n        Python function, returns a single value from a single value\n\n    Returns\n    -------\n    applied : DataFrame\n    \"\"\"\n    return self.apply(lambda x: [func(y) for y in x])",
                            "def sp_maker(x):\n    return SparseArray(x, kind=self._default_kind, fill_value=self._default_fill_value, copy=True, dtype=dtype)",
                            "def sp_maker(x, index=None):\n    return SparseArray(x, index=index, fill_value=self._default_fill_value, kind=self._default_kind)",
                            "def lrenamer(x):\n    if x in to_rename:\n        return '{x}{lsuffix}'.format(x=x, lsuffix=lsuffix)\n    return x",
                            "def rrenamer(x):\n    if x in to_rename:\n        return '{x}{rsuffix}'.format(x=x, rsuffix=rsuffix)\n    return x"
                        ],
                        "constructor_variables": [
                            "_default_fill_value",
                            "data",
                            "index",
                            "msg",
                            "default_fill_value",
                            "columns",
                            "mgr",
                            "default_kind",
                            "_default_kind"
                        ],
                        "class_level_variables": [
                            "_subtyp",
                            "_constructor_sliced",
                            "T",
                            "isnull",
                            "notnull"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "__init__(self, data=None, index=None, columns=None, default_kind=None, default_fill_value=None, dtype=None, copy=False)",
                            "_constructor(self)",
                            "_init_dict(self, data, index, columns, dtype=None)",
                            "_init_matrix(self, data, index, columns, dtype=None)",
                            "_init_spmatrix(self, data, index, columns, dtype=None, fill_value=None)",
                            "to_coo(self)",
                            "__repr__(self)",
                            "__getstate__(self)",
                            "_unpickle_sparse_frame_compat(self, state)",
                            "to_dense(self)",
                            "_apply_columns(self, func)",
                            "astype(self, dtype)",
                            "copy(self, deep=True)",
                            "default_fill_value(self)",
                            "default_kind(self)",
                            "density(self)",
                            "fillna(self, value=None, method=None, axis=0, inplace=False, limit=None, downcast=None)",
                            "_sanitize_column(self, key, value, **kwargs)",
                            "_get_value(self, index, col, takeable=False)",
                            "_slice(self, slobj, axis=0, kind=None)",
                            "xs(self, key, axis=0, copy=False)",
                            "_set_value(self, index, col, value, takeable=False)",
                            "_combine_frame(self, other, func, fill_value=None, level=None)",
                            "_combine_match_index(self, other, func, level=None)",
                            "_combine_match_columns(self, other, func, level=None)",
                            "_combine_const(self, other, func)",
                            "_get_op_result_fill_value(self, other, func)",
                            "_reindex_index(self, index, method, copy, level, fill_value=np.nan, limit=None, takeable=False)",
                            "_reindex_columns(self, columns, method, copy, level, fill_value=None, limit=None, takeable=False)",
                            "_reindex_with_indexers(self, reindexers, method=None, fill_value=None, limit=None, copy=False, allow_dups=False)",
                            "_join_compat(self, other, on=None, how='left', lsuffix='', rsuffix='', sort=False)",
                            "_join_index(self, other, how, lsuffix, rsuffix)",
                            "_maybe_rename_join(self, other, lsuffix, rsuffix)",
                            "transpose(self, *args, **kwargs)",
                            "count(self, axis=0, **kwds)",
                            "cumsum(self, axis=0, *args, **kwargs)",
                            "isna(self)",
                            "notna(self)",
                            "apply(self, func, axis=0, broadcast=None, reduce=None, result_type=None)",
                            "applymap(self, func)",
                            "sp_maker(x)",
                            "sp_maker(x, index=None)",
                            "lrenamer(x)",
                            "rrenamer(x)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_combine_match_columns",
                    "function_code": "def _combine_match_columns(self, other, func, level=None):\n    # patched version of DataFrame._combine_match_columns to account for\n    # NumPy circumventing __rsub__ with float64 types, e.g.: 3.0 - series,\n    # where 3.0 is numpy.float64 and series is a SparseSeries. Still\n    # possible for this to happen, which is bothersome\n\n    if level is not None:\n        raise NotImplementedError(\"'level' argument is not supported\")\n\n    left, right = self.align(other, join=\"outer\", axis=1, level=level, copy=False)\n    assert left.columns.equals(right.index)\n\n    new_data = {}\n\n    for col in left.columns:\n        new_data[col] = func(left[col], float(right[col]))\n\n    return self._constructor(\n        new_data,\n        index=left.index,\n        columns=left.columns,\n        default_fill_value=self.default_fill_value,\n    ).__finalize__(self)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 591,
                    "end_line": 613,
                    "variables": {
                        "level": [
                            600,
                            597
                        ],
                        "NotImplementedError": [
                            598
                        ],
                        "left": [
                            610,
                            611,
                            600,
                            601,
                            605,
                            606
                        ],
                        "right": [
                            600,
                            601,
                            606
                        ],
                        "self.align": [
                            600
                        ],
                        "self": [
                            600,
                            612,
                            608,
                            613
                        ],
                        "other": [
                            600
                        ],
                        "left.columns.equals": [
                            601
                        ],
                        "left.columns": [
                            601,
                            611,
                            605
                        ],
                        "right.index": [
                            601
                        ],
                        "new_data": [
                            609,
                            603,
                            606
                        ],
                        "col": [
                            605,
                            606
                        ],
                        "func": [
                            606
                        ],
                        "float": [
                            606
                        ],
                        "__finalize__": [
                            608
                        ],
                        "self._constructor": [
                            608
                        ],
                        "left.index": [
                            610
                        ],
                        "self.default_fill_value": [
                            612
                        ]
                    },
                    "filtered_variables": {
                        "level": [
                            600,
                            597
                        ],
                        "left": [
                            610,
                            611,
                            600,
                            601,
                            605,
                            606
                        ],
                        "right": [
                            600,
                            601,
                            606
                        ],
                        "self.align": [
                            600
                        ],
                        "self": [
                            600,
                            612,
                            608,
                            613
                        ],
                        "other": [
                            600
                        ],
                        "left.columns.equals": [
                            601
                        ],
                        "left.columns": [
                            601,
                            611,
                            605
                        ],
                        "right.index": [
                            601
                        ],
                        "new_data": [
                            609,
                            603,
                            606
                        ],
                        "col": [
                            605,
                            606
                        ],
                        "func": [
                            606
                        ],
                        "__finalize__": [
                            608
                        ],
                        "self._constructor": [
                            608
                        ],
                        "left.index": [
                            610
                        ],
                        "self.default_fill_value": [
                            612
                        ]
                    },
                    "diff_line_number": 606,
                    "class_data": {
                        "signature": "class SparseDataFrame(DataFrame)",
                        "docstring": "DataFrame containing sparse floating point data in the form of SparseSeries\nobjects\n\n.. deprecated:: 0.25.0\n\n   Use a DataFrame with sparse values instead.\n\nParameters\n----------\ndata : same types as can be passed to DataFrame or scipy.sparse.spmatrix\n    .. versionchanged:: 0.23.0\n       If data is a dict, argument order is maintained for Python 3.6\n       and later.\n\nindex : array-like, optional\ncolumn : array-like, optional\ndefault_kind : {'block', 'integer'}, default 'block'\n    Default sparse kind for converting Series to SparseSeries. Will not\n    override SparseSeries passed into constructor\ndefault_fill_value : float\n    Default fill_value for converting Series to SparseSeries\n    (default: nan). Will not override SparseSeries passed in.",
                        "constructor_docstring": null,
                        "functions": [
                            "def __init__(self, data=None, index=None, columns=None, default_kind=None, default_fill_value=None, dtype=None, copy=False):\n    if not is_scalar(default_fill_value):\n        raise ValueError(\"'default_fill_value' must be a scalar\")\n    warnings.warn(depr_msg, FutureWarning, stacklevel=2)\n    if isinstance(data, SparseDataFrame):\n        if index is None:\n            index = data.index\n        if columns is None:\n            columns = data.columns\n        if default_fill_value is None:\n            default_fill_value = data.default_fill_value\n        if default_kind is None:\n            default_kind = data.default_kind\n    elif isinstance(data, (SparseSeries, SparseArray)):\n        if index is None:\n            index = data.index\n        if default_fill_value is None:\n            default_fill_value = data.fill_value\n        if columns is None and hasattr(data, 'name'):\n            columns = [data.name]\n        if columns is None:\n            raise Exception('cannot pass a series w/o a name or columns')\n        data = {columns[0]: data}\n    if default_fill_value is None:\n        default_fill_value = np.nan\n    if default_kind is None:\n        default_kind = 'block'\n    self._default_kind = default_kind\n    self._default_fill_value = default_fill_value\n    if is_scipy_sparse(data):\n        mgr = self._init_spmatrix(data, index, columns, dtype=dtype, fill_value=default_fill_value)\n    elif isinstance(data, dict):\n        mgr = self._init_dict(data, index, columns, dtype=dtype)\n    elif isinstance(data, (np.ndarray, list)):\n        mgr = self._init_matrix(data, index, columns, dtype=dtype)\n    elif isinstance(data, SparseDataFrame):\n        mgr = self._init_mgr(data._data, dict(index=index, columns=columns), dtype=dtype, copy=copy)\n    elif isinstance(data, DataFrame):\n        mgr = self._init_dict(data, data.index, data.columns, dtype=dtype)\n    elif isinstance(data, Series):\n        mgr = self._init_dict(data.to_frame(), data.index, columns=None, dtype=dtype)\n    elif isinstance(data, BlockManager):\n        mgr = self._init_mgr(data, axes=dict(index=index, columns=columns), dtype=dtype, copy=copy)\n    elif data is None:\n        data = DataFrame()\n        if index is None:\n            index = Index([])\n        else:\n            index = ensure_index(index)\n        if columns is None:\n            columns = Index([])\n        else:\n            for c in columns:\n                data[c] = SparseArray(self._default_fill_value, index=index, kind=self._default_kind, fill_value=self._default_fill_value)\n        mgr = to_manager(data, columns, index)\n        if dtype is not None:\n            mgr = mgr.astype(dtype)\n    else:\n        msg = 'SparseDataFrame called with unknown type \"{data_type}\" for data argument'\n        raise TypeError(msg.format(data_type=type(data).__name__))\n    generic.NDFrame.__init__(self, mgr)",
                            "@property\ndef _constructor(self):\n    return SparseDataFrame",
                            "def _init_dict(self, data, index, columns, dtype=None):\n    if columns is not None:\n        columns = ensure_index(columns)\n        data = {k: v for k, v in data.items() if k in columns}\n    else:\n        keys = com.dict_keys_to_ordered_list(data)\n        columns = Index(keys)\n    if index is None:\n        index = extract_index(list(data.values()))\n\n    def sp_maker(x):\n        return SparseArray(x, kind=self._default_kind, fill_value=self._default_fill_value, copy=True, dtype=dtype)\n    sdict = {}\n    for k, v in data.items():\n        if isinstance(v, Series):\n            if not v.index.equals(index):\n                v = v.reindex(index)\n            if not isinstance(v, SparseSeries):\n                v = sp_maker(v.values)\n        elif isinstance(v, SparseArray):\n            v = v.copy()\n        else:\n            if isinstance(v, dict):\n                v = [v.get(i, np.nan) for i in index]\n            v = sp_maker(v)\n        if index is not None and len(v) != len(index):\n            msg = 'Length of passed values is {}, index implies {}'\n            raise ValueError(msg.format(len(v), len(index)))\n        sdict[k] = v\n    if len(columns.difference(sdict)):\n        nan_arr = np.empty(len(index), dtype='float64')\n        nan_arr.fill(np.nan)\n        nan_arr = SparseArray(nan_arr, kind=self._default_kind, fill_value=self._default_fill_value, copy=False)\n        sdict.update(((c, nan_arr) for c in columns if c not in sdict))\n    return to_manager(sdict, columns, index)",
                            "def _init_matrix(self, data, index, columns, dtype=None):\n    \"\"\"\n    Init self from ndarray or list of lists.\n    \"\"\"\n    data = prep_ndarray(data, copy=False)\n    index, columns = SparseFrameAccessor._prep_index(data, index, columns)\n    data = {idx: data[:, i] for i, idx in enumerate(columns)}\n    return self._init_dict(data, index, columns, dtype)",
                            "def _init_spmatrix(self, data, index, columns, dtype=None, fill_value=None):\n    \"\"\"\n    Init self from scipy.sparse matrix.\n    \"\"\"\n    index, columns = SparseFrameAccessor._prep_index(data, index, columns)\n    data = data.tocoo()\n    N = len(index)\n    sdict = {}\n    values = Series(data.data, index=data.row, copy=False)\n    for col, rowvals in values.groupby(data.col):\n        rowvals = rowvals.sort_index()\n        rows = rowvals.index.values.astype(np.int32)\n        blocs, blens = get_blocks(rows)\n        sdict[columns[col]] = SparseSeries(rowvals.values, index=index, fill_value=fill_value, sparse_index=BlockIndex(N, blocs, blens))\n    sdict.update({column: SparseSeries(index=index, fill_value=fill_value, sparse_index=BlockIndex(N, [], [])) for column in columns if column not in sdict})\n    return self._init_dict(sdict, index, columns, dtype)",
                            "@Appender(SparseFrameAccessor.to_coo.__doc__)\ndef to_coo(self):\n    return SparseFrameAccessor(self).to_coo()",
                            "def __repr__(self):\n    with warnings.catch_warnings():\n        warnings.filterwarnings('ignore', 'Sparse')\n        return super().__repr__()",
                            "def __getstate__(self):\n    return dict(_typ=self._typ, _subtyp=self._subtyp, _data=self._data, _default_fill_value=self._default_fill_value, _default_kind=self._default_kind)",
                            "def _unpickle_sparse_frame_compat(self, state):\n    \"\"\"\n    Original pickle format\n    \"\"\"\n    series, cols, idx, fv, kind = state\n    if not isinstance(cols, Index):\n        from pandas.io.pickle import _unpickle_array\n        columns = _unpickle_array(cols)\n    else:\n        columns = cols\n    if not isinstance(idx, Index):\n        from pandas.io.pickle import _unpickle_array\n        index = _unpickle_array(idx)\n    else:\n        index = idx\n    series_dict = DataFrame()\n    for col, (sp_index, sp_values) in series.items():\n        series_dict[col] = SparseSeries(sp_values, sparse_index=sp_index, fill_value=fv)\n    self._data = to_manager(series_dict, columns, index)\n    self._default_fill_value = fv\n    self._default_kind = kind",
                            "@Appender(SparseFrameAccessor.to_dense.__doc__)\ndef to_dense(self):\n    return SparseFrameAccessor(self).to_dense()",
                            "def _apply_columns(self, func):\n    \"\"\"\n    Get new SparseDataFrame applying func to each columns\n    \"\"\"\n    new_data = {col: func(series) for col, series in self.items()}\n    return self._constructor(data=new_data, index=self.index, columns=self.columns, default_fill_value=self.default_fill_value).__finalize__(self)",
                            "def astype(self, dtype):\n    return self._apply_columns(lambda x: x.astype(dtype))",
                            "def copy(self, deep=True):\n    \"\"\"\n    Make a copy of this SparseDataFrame\n    \"\"\"\n    result = super().copy(deep=deep)\n    result._default_fill_value = self._default_fill_value\n    result._default_kind = self._default_kind\n    return result",
                            "@property\ndef default_fill_value(self):\n    return self._default_fill_value",
                            "@property\ndef default_kind(self):\n    return self._default_kind",
                            "@property\ndef density(self):\n    \"\"\"\n    Ratio of non-sparse points to total (dense) data points\n    represented in the frame\n    \"\"\"\n    tot_nonsparse = sum((ser.sp_index.npoints for _, ser in self.items()))\n    tot = len(self.index) * len(self.columns)\n    return tot_nonsparse / float(tot)",
                            "def fillna(self, value=None, method=None, axis=0, inplace=False, limit=None, downcast=None):\n    new_self = super().fillna(value=value, method=method, axis=axis, inplace=inplace, limit=limit, downcast=downcast)\n    if not inplace:\n        self = new_self\n    if value is not None and value == value and (method is None) and (limit is None):\n        self._default_fill_value = value\n    if not inplace:\n        return self",
                            "def _sanitize_column(self, key, value, **kwargs):\n    \"\"\"\n    Creates a new SparseArray from the input value.\n\n    Parameters\n    ----------\n    key : object\n    value : scalar, Series, or array-like\n    kwargs : dict\n\n    Returns\n    -------\n    sanitized_column : SparseArray\n\n    \"\"\"\n\n    def sp_maker(x, index=None):\n        return SparseArray(x, index=index, fill_value=self._default_fill_value, kind=self._default_kind)\n    if isinstance(value, SparseSeries):\n        clean = value.reindex(self.index).as_sparse_array(fill_value=self._default_fill_value, kind=self._default_kind)\n    elif isinstance(value, SparseArray):\n        if len(value) != len(self.index):\n            raise ValueError('Length of values does not match length of index')\n        clean = value\n    elif hasattr(value, '__iter__'):\n        if isinstance(value, Series):\n            clean = value.reindex(self.index)\n            if not isinstance(value, SparseSeries):\n                clean = sp_maker(clean)\n        else:\n            if len(value) != len(self.index):\n                raise ValueError('Length of values does not match length of index')\n            clean = sp_maker(value)\n    else:\n        clean = sp_maker(value, self.index)\n    return clean",
                            "def _get_value(self, index, col, takeable=False):\n    \"\"\"\n    Quickly retrieve single value at passed column and index\n\n    Please use .at[] or .iat[] accessors.\n\n    Parameters\n    ----------\n    index : row label\n    col : column label\n    takeable : interpret the index/col as indexers, default False\n\n    Returns\n    -------\n    value : scalar value\n    \"\"\"\n    if takeable is True:\n        series = self._iget_item_cache(col)\n    else:\n        series = self._get_item_cache(col)\n    return series._get_value(index, takeable=takeable)",
                            "def _slice(self, slobj, axis=0, kind=None):\n    if axis == 0:\n        new_index = self.index[slobj]\n        new_columns = self.columns\n    else:\n        new_index = self.index\n        new_columns = self.columns[slobj]\n    return self.reindex(index=new_index, columns=new_columns)",
                            "def xs(self, key, axis=0, copy=False):\n    \"\"\"\n    Returns a row (cross-section) from the SparseDataFrame as a Series\n    object.\n\n    Parameters\n    ----------\n    key : some index contained in the index\n\n    Returns\n    -------\n    xs : Series\n    \"\"\"\n    if axis == 1:\n        data = self[key]\n        return data\n    i = self.index.get_loc(key)\n    data = self.take([i])._internal_get_values()[0]\n    return Series(data, index=self.columns)",
                            "def _set_value(self, index, col, value, takeable=False):\n    \"\"\"\n    Put single value at passed column and index\n\n    Please use .at[] or .iat[] accessors.\n\n    Parameters\n    ----------\n    index : row label\n    col : column label\n    value : scalar value\n    takeable : interpret the index/col as indexers, default False\n\n    Notes\n    -----\n    This method *always* returns a new object. It is currently not\n    particularly efficient (and potentially very expensive) but is provided\n    for API compatibility with DataFrame\n\n    Returns\n    -------\n    frame : DataFrame\n    \"\"\"\n    dense = self.to_dense()._set_value(index, col, value, takeable=takeable)\n    return dense.to_sparse(kind=self._default_kind, fill_value=self._default_fill_value)",
                            "def _combine_frame(self, other, func, fill_value=None, level=None):\n    if level is not None:\n        raise NotImplementedError(\"'level' argument is not supported\")\n    this, other = self.align(other, join='outer', level=level, copy=False)\n    new_index, new_columns = (this.index, this.columns)\n    if self.empty and other.empty:\n        return self._constructor(index=new_index).__finalize__(self)\n    new_data = {}\n    if fill_value is not None:\n        for col in new_columns:\n            if col in this and col in other:\n                dleft = this[col].to_dense()\n                dright = other[col].to_dense()\n                result = dleft._binop(dright, func, fill_value=fill_value)\n                result = result.to_sparse(fill_value=this[col].fill_value)\n                new_data[col] = result\n    else:\n        for col in new_columns:\n            if col in this and col in other:\n                new_data[col] = func(this[col], other[col])\n    new_fill_value = self._get_op_result_fill_value(other, func)\n    return self._constructor(data=new_data, index=new_index, columns=new_columns, default_fill_value=new_fill_value).__finalize__(self)",
                            "def _combine_match_index(self, other, func, level=None):\n    if level is not None:\n        raise NotImplementedError(\"'level' argument is not supported\")\n    this, other = self.align(other, join='outer', axis=0, level=level, copy=False)\n    new_data = {}\n    for col, series in this.items():\n        new_data[col] = func(series.values, other.values)\n    fill_value = self._get_op_result_fill_value(other, func)\n    return self._constructor(new_data, index=this.index, columns=self.columns, default_fill_value=fill_value).__finalize__(self)",
                            "def _combine_match_columns(self, other, func, level=None):\n    if level is not None:\n        raise NotImplementedError(\"'level' argument is not supported\")\n    left, right = self.align(other, join='outer', axis=1, level=level, copy=False)\n    assert left.columns.equals(right.index)\n    new_data = {}\n    for col in left.columns:\n        new_data[col] = func(left[col], float(right[col]))\n    return self._constructor(new_data, index=left.index, columns=left.columns, default_fill_value=self.default_fill_value).__finalize__(self)",
                            "def _combine_const(self, other, func):\n    return self._apply_columns(lambda x: func(x, other))",
                            "def _get_op_result_fill_value(self, other, func):\n    own_default = self.default_fill_value\n    if isinstance(other, DataFrame):\n        other_default = getattr(other, 'default_fill_value', np.nan)\n        if own_default == other_default:\n            fill_value = own_default\n        elif np.isnan(own_default) and (not np.isnan(other_default)):\n            fill_value = other_default\n        elif not np.isnan(own_default) and np.isnan(other_default):\n            fill_value = own_default\n        else:\n            fill_value = None\n    elif isinstance(other, SparseSeries):\n        if isna(other.fill_value) or isna(own_default):\n            fill_value = np.nan\n        else:\n            fill_value = func(np.float64(own_default), np.float64(other.fill_value))\n            fill_value = item_from_zerodim(fill_value)\n    else:\n        raise NotImplementedError(type(other))\n    return fill_value",
                            "def _reindex_index(self, index, method, copy, level, fill_value=np.nan, limit=None, takeable=False):\n    if level is not None:\n        raise TypeError('Reindex by level not supported for sparse')\n    if self.index.equals(index):\n        if copy:\n            return self.copy()\n        else:\n            return self\n    if len(self.index) == 0:\n        return self._constructor(index=index, columns=self.columns).__finalize__(self)\n    indexer = self.index.get_indexer(index, method, limit=limit)\n    indexer = ensure_platform_int(indexer)\n    mask = indexer == -1\n    need_mask = mask.any()\n    new_series = {}\n    for col, series in self.items():\n        if mask.all():\n            continue\n        values = series.values\n        new = values.take(indexer)\n        if need_mask:\n            new = new.to_dense()\n            new, fill_value = maybe_upcast(new, fill_value=fill_value)\n            np.putmask(new, mask, fill_value)\n        new_series[col] = new\n    return self._constructor(new_series, index=index, columns=self.columns, default_fill_value=self._default_fill_value).__finalize__(self)",
                            "def _reindex_columns(self, columns, method, copy, level, fill_value=None, limit=None, takeable=False):\n    if level is not None:\n        raise TypeError('Reindex by level not supported for sparse')\n    if notna(fill_value):\n        raise NotImplementedError(\"'fill_value' argument is not supported\")\n    if limit:\n        raise NotImplementedError(\"'limit' argument is not supported\")\n    if method is not None:\n        raise NotImplementedError(\"'method' argument is not supported\")\n    sdict = {k: v for k, v in self.items() if k in columns}\n    return self._constructor(sdict, index=self.index, columns=columns, default_fill_value=self._default_fill_value).__finalize__(self)",
                            "def _reindex_with_indexers(self, reindexers, method=None, fill_value=None, limit=None, copy=False, allow_dups=False):\n    if method is not None or limit is not None:\n        raise NotImplementedError('cannot reindex with a method or limit with sparse')\n    if fill_value is None:\n        fill_value = np.nan\n    reindexers = {self._get_axis_number(a): val for a, val in reindexers.items()}\n    index, row_indexer = reindexers.get(0, (None, None))\n    columns, col_indexer = reindexers.get(1, (None, None))\n    if columns is None:\n        columns = self.columns\n    new_arrays = {}\n    for col in columns:\n        if col not in self:\n            continue\n        if row_indexer is not None:\n            new_arrays[col] = algos.take_1d(self[col]._internal_get_values(), row_indexer, fill_value=fill_value)\n        else:\n            new_arrays[col] = self[col]\n    return self._constructor(new_arrays, index=index, columns=columns).__finalize__(self)",
                            "def _join_compat(self, other, on=None, how='left', lsuffix='', rsuffix='', sort=False):\n    if on is not None:\n        raise NotImplementedError(\"'on' keyword parameter is not yet implemented\")\n    return self._join_index(other, how, lsuffix, rsuffix)",
                            "def _join_index(self, other, how, lsuffix, rsuffix):\n    if isinstance(other, Series):\n        if other.name is None:\n            raise ValueError('Other Series must have a name')\n        other = SparseDataFrame({other.name: other}, default_fill_value=self._default_fill_value)\n    join_index = self.index.join(other.index, how=how)\n    this = self.reindex(join_index)\n    other = other.reindex(join_index)\n    this, other = this._maybe_rename_join(other, lsuffix, rsuffix)\n    from pandas import concat\n    return concat([this, other], axis=1, verify_integrity=True)",
                            "def _maybe_rename_join(self, other, lsuffix, rsuffix):\n    to_rename = self.columns.intersection(other.columns)\n    if len(to_rename) > 0:\n        if not lsuffix and (not rsuffix):\n            raise ValueError('columns overlap but no suffix specified: {to_rename}'.format(to_rename=to_rename))\n\n        def lrenamer(x):\n            if x in to_rename:\n                return '{x}{lsuffix}'.format(x=x, lsuffix=lsuffix)\n            return x\n\n        def rrenamer(x):\n            if x in to_rename:\n                return '{x}{rsuffix}'.format(x=x, rsuffix=rsuffix)\n            return x\n        this = self.rename(columns=lrenamer)\n        other = other.rename(columns=rrenamer)\n    else:\n        this = self\n    return (this, other)",
                            "def transpose(self, *args, **kwargs):\n    \"\"\"\n    Returns a DataFrame with the rows/columns switched.\n    \"\"\"\n    nv.validate_transpose(args, kwargs)\n    return self._constructor(self.values.T, index=self.columns, columns=self.index, default_fill_value=self._default_fill_value, default_kind=self._default_kind).__finalize__(self)",
                            "@Appender(DataFrame.count.__doc__)\ndef count(self, axis=0, **kwds):\n    if axis is None:\n        axis = self._stat_axis_number\n    return self.apply(lambda x: x.count(), axis=axis)",
                            "def cumsum(self, axis=0, *args, **kwargs):\n    \"\"\"\n    Return SparseDataFrame of cumulative sums over requested axis.\n\n    Parameters\n    ----------\n    axis : {0, 1}\n        0 for row-wise, 1 for column-wise\n\n    Returns\n    -------\n    y : SparseDataFrame\n    \"\"\"\n    nv.validate_cumsum(args, kwargs)\n    if axis is None:\n        axis = self._stat_axis_number\n    return self.apply(lambda x: x.cumsum(), axis=axis)",
                            "@Appender(generic._shared_docs['isna'] % _shared_doc_kwargs)\ndef isna(self):\n    return self._apply_columns(lambda x: x.isna())",
                            "@Appender(generic._shared_docs['notna'] % _shared_doc_kwargs)\ndef notna(self):\n    return self._apply_columns(lambda x: x.notna())",
                            "def apply(self, func, axis=0, broadcast=None, reduce=None, result_type=None):\n    \"\"\"\n    Analogous to DataFrame.apply, for SparseDataFrame\n\n    Parameters\n    ----------\n    func : function\n        Function to apply to each column\n    axis : {0, 1, 'index', 'columns'}\n    broadcast : bool, default False\n        For aggregation functions, return object of same size with values\n        propagated\n\n        .. deprecated:: 0.23.0\n           This argument will be removed in a future version, replaced\n           by result_type='broadcast'.\n\n    reduce : boolean or None, default None\n        Try to apply reduction procedures. If the DataFrame is empty,\n        apply will use reduce to determine whether the result should be a\n        Series or a DataFrame. If reduce is None (the default), apply's\n        return value will be guessed by calling func an empty Series (note:\n        while guessing, exceptions raised by func will be ignored). If\n        reduce is True a Series will always be returned, and if False a\n        DataFrame will always be returned.\n\n        .. deprecated:: 0.23.0\n           This argument will be removed in a future version, replaced\n           by result_type='reduce'.\n\n    result_type : {'expand', 'reduce', 'broadcast, None}\n        These only act when axis=1 {columns}:\n\n        * 'expand' : list-like results will be turned into columns.\n        * 'reduce' : return a Series if possible rather than expanding\n          list-like results. This is the opposite to 'expand'.\n        * 'broadcast' : results will be broadcast to the original shape\n          of the frame, the original index & columns will be retained.\n\n        The default behaviour (None) depends on the return value of the\n        applied function: list-like results will be returned as a Series\n        of those. However if the apply function returns a Series these\n        are expanded to columns.\n\n        .. versionadded:: 0.23.0\n\n    Returns\n    -------\n    applied : Series or SparseDataFrame\n    \"\"\"\n    if not len(self.columns):\n        return self\n    axis = self._get_axis_number(axis)\n    if isinstance(func, np.ufunc):\n        new_series = {}\n        for k, v in self.items():\n            applied = func(v)\n            applied.fill_value = func(v.fill_value)\n            new_series[k] = applied\n        return self._constructor(new_series, index=self.index, columns=self.columns, default_fill_value=self._default_fill_value, default_kind=self._default_kind).__finalize__(self)\n    from pandas.core.apply import frame_apply\n    op = frame_apply(self, func=func, axis=axis, reduce=reduce, broadcast=broadcast, result_type=result_type)\n    return op.get_result()",
                            "def applymap(self, func):\n    \"\"\"\n    Apply a function to a DataFrame that is intended to operate\n    elementwise, i.e. like doing map(func, series) for each series in the\n    DataFrame\n\n    Parameters\n    ----------\n    func : function\n        Python function, returns a single value from a single value\n\n    Returns\n    -------\n    applied : DataFrame\n    \"\"\"\n    return self.apply(lambda x: [func(y) for y in x])",
                            "def sp_maker(x):\n    return SparseArray(x, kind=self._default_kind, fill_value=self._default_fill_value, copy=True, dtype=dtype)",
                            "def sp_maker(x, index=None):\n    return SparseArray(x, index=index, fill_value=self._default_fill_value, kind=self._default_kind)",
                            "def lrenamer(x):\n    if x in to_rename:\n        return '{x}{lsuffix}'.format(x=x, lsuffix=lsuffix)\n    return x",
                            "def rrenamer(x):\n    if x in to_rename:\n        return '{x}{rsuffix}'.format(x=x, rsuffix=rsuffix)\n    return x"
                        ],
                        "constructor_variables": [
                            "_default_fill_value",
                            "data",
                            "index",
                            "msg",
                            "default_fill_value",
                            "columns",
                            "mgr",
                            "default_kind",
                            "_default_kind"
                        ],
                        "class_level_variables": [
                            "_subtyp",
                            "_constructor_sliced",
                            "T",
                            "isnull",
                            "notnull"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "__init__(self, data=None, index=None, columns=None, default_kind=None, default_fill_value=None, dtype=None, copy=False)",
                            "_constructor(self)",
                            "_init_dict(self, data, index, columns, dtype=None)",
                            "_init_matrix(self, data, index, columns, dtype=None)",
                            "_init_spmatrix(self, data, index, columns, dtype=None, fill_value=None)",
                            "to_coo(self)",
                            "__repr__(self)",
                            "__getstate__(self)",
                            "_unpickle_sparse_frame_compat(self, state)",
                            "to_dense(self)",
                            "_apply_columns(self, func)",
                            "astype(self, dtype)",
                            "copy(self, deep=True)",
                            "default_fill_value(self)",
                            "default_kind(self)",
                            "density(self)",
                            "fillna(self, value=None, method=None, axis=0, inplace=False, limit=None, downcast=None)",
                            "_sanitize_column(self, key, value, **kwargs)",
                            "_get_value(self, index, col, takeable=False)",
                            "_slice(self, slobj, axis=0, kind=None)",
                            "xs(self, key, axis=0, copy=False)",
                            "_set_value(self, index, col, value, takeable=False)",
                            "_combine_frame(self, other, func, fill_value=None, level=None)",
                            "_combine_match_index(self, other, func, level=None)",
                            "_combine_match_columns(self, other, func, level=None)",
                            "_combine_const(self, other, func)",
                            "_get_op_result_fill_value(self, other, func)",
                            "_reindex_index(self, index, method, copy, level, fill_value=np.nan, limit=None, takeable=False)",
                            "_reindex_columns(self, columns, method, copy, level, fill_value=None, limit=None, takeable=False)",
                            "_reindex_with_indexers(self, reindexers, method=None, fill_value=None, limit=None, copy=False, allow_dups=False)",
                            "_join_compat(self, other, on=None, how='left', lsuffix='', rsuffix='', sort=False)",
                            "_join_index(self, other, how, lsuffix, rsuffix)",
                            "_maybe_rename_join(self, other, lsuffix, rsuffix)",
                            "transpose(self, *args, **kwargs)",
                            "count(self, axis=0, **kwds)",
                            "cumsum(self, axis=0, *args, **kwargs)",
                            "isna(self)",
                            "notna(self)",
                            "apply(self, func, axis=0, broadcast=None, reduce=None, result_type=None)",
                            "applymap(self, func)",
                            "sp_maker(x)",
                            "sp_maker(x, index=None)",
                            "lrenamer(x)",
                            "rrenamer(x)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def to_manager(sdf, columns, index):\n    \"\"\" create and return the block manager from a dataframe of series,\n    columns, index\n    \"\"\"\n\n    # from BlockManager perspective\n    axes = [ensure_index(columns), ensure_index(index)]\n\n    return create_block_manager_from_arrays([sdf[c] for c in columns], columns, axes)",
                "def stack_sparse_frame(frame):\n    \"\"\"\n    Only makes sense when fill_value is NaN\n    \"\"\"\n    lengths = [s.sp_index.npoints for _, s in frame.items()]\n    nobs = sum(lengths)\n\n    # this is pretty fast\n    minor_codes = np.repeat(np.arange(len(frame.columns)), lengths)\n\n    inds_to_concat = []\n    vals_to_concat = []\n    # TODO: Figure out whether this can be reached.\n    # I think this currently can't be reached because you can't build a\n    # SparseDataFrame with a non-np.NaN fill value (fails earlier).\n    for _, series in frame.items():\n        if not np.isnan(series.fill_value):\n            raise TypeError(\"This routine assumes NaN fill value\")\n\n        int_index = series.sp_index.to_int_index()\n        inds_to_concat.append(int_index.indices)\n        vals_to_concat.append(series.sp_values)\n\n    major_codes = np.concatenate(inds_to_concat)\n    stacked_values = np.concatenate(vals_to_concat)\n    index = MultiIndex(\n        levels=[frame.index, frame.columns],\n        codes=[major_codes, minor_codes],\n        verify_integrity=False,\n    )\n\n    lp = DataFrame(stacked_values.reshape((nobs, 1)), index=index, columns=[\"foo\"])\n    return lp.sort_index(level=0)",
                "def homogenize(series_dict):\n    \"\"\"\n    Conform a set of SparseSeries (with NaN fill_value) to a common SparseIndex\n    corresponding to the locations where they all have data\n\n    Parameters\n    ----------\n    series_dict : dict or DataFrame\n\n    Notes\n    -----\n    Using the dumbest algorithm I could think of. Should put some more thought\n    into this\n\n    Returns\n    -------\n    homogenized : dict of SparseSeries\n    \"\"\"\n    index = None\n\n    need_reindex = False\n\n    for _, series in series_dict.items():\n        if not np.isnan(series.fill_value):\n            raise TypeError(\"this method is only valid with NaN fill values\")\n\n        if index is None:\n            index = series.sp_index\n        elif not series.sp_index.equals(index):\n            need_reindex = True\n            index = index.intersect(series.sp_index)\n\n    if need_reindex:\n        output = {}\n        for name, series in series_dict.items():\n            if not series.sp_index.equals(index):\n                series = series.sparse_reindex(index)\n\n            output[name] = series\n    else:\n        output = series_dict\n\n    return output",
                "def __init__(\n    self,\n    data=None,\n    index=None,\n    columns=None,\n    default_kind=None,\n    default_fill_value=None,\n    dtype=None,\n    copy=False,\n):\n    if not is_scalar(default_fill_value):\n        raise ValueError(\"'default_fill_value' must be a scalar\")\n\n    warnings.warn(depr_msg, FutureWarning, stacklevel=2)\n    # pick up the defaults from the Sparse structures\n    if isinstance(data, SparseDataFrame):\n        if index is None:\n            index = data.index\n        if columns is None:\n            columns = data.columns\n        if default_fill_value is None:\n            default_fill_value = data.default_fill_value\n        if default_kind is None:\n            default_kind = data.default_kind\n    elif isinstance(data, (SparseSeries, SparseArray)):\n        if index is None:\n            index = data.index\n        if default_fill_value is None:\n            default_fill_value = data.fill_value\n        if columns is None and hasattr(data, \"name\"):\n            columns = [data.name]\n        if columns is None:\n            raise Exception(\"cannot pass a series w/o a name or columns\")\n        data = {columns[0]: data}\n\n    if default_fill_value is None:\n        default_fill_value = np.nan\n    if default_kind is None:\n        default_kind = \"block\"\n\n    self._default_kind = default_kind\n    self._default_fill_value = default_fill_value\n\n    if is_scipy_sparse(data):\n        mgr = self._init_spmatrix(\n            data, index, columns, dtype=dtype, fill_value=default_fill_value\n        )\n    elif isinstance(data, dict):\n        mgr = self._init_dict(data, index, columns, dtype=dtype)\n    elif isinstance(data, (np.ndarray, list)):\n        mgr = self._init_matrix(data, index, columns, dtype=dtype)\n    elif isinstance(data, SparseDataFrame):\n        mgr = self._init_mgr(\n            data._data, dict(index=index, columns=columns), dtype=dtype, copy=copy\n        )\n    elif isinstance(data, DataFrame):\n        mgr = self._init_dict(data, data.index, data.columns, dtype=dtype)\n    elif isinstance(data, Series):\n        mgr = self._init_dict(\n            data.to_frame(), data.index, columns=None, dtype=dtype\n        )\n    elif isinstance(data, BlockManager):\n        mgr = self._init_mgr(\n            data, axes=dict(index=index, columns=columns), dtype=dtype, copy=copy\n        )\n    elif data is None:\n        data = DataFrame()\n\n        if index is None:\n            index = Index([])\n        else:\n            index = ensure_index(index)\n\n        if columns is None:\n            columns = Index([])\n        else:\n            for c in columns:\n                data[c] = SparseArray(\n                    self._default_fill_value,\n                    index=index,\n                    kind=self._default_kind,\n                    fill_value=self._default_fill_value,\n                )\n        mgr = to_manager(data, columns, index)\n        if dtype is not None:\n            mgr = mgr.astype(dtype)\n    else:\n        msg = (\n            'SparseDataFrame called with unknown type \"{data_type}\" '\n            \"for data argument\"\n        )\n        raise TypeError(msg.format(data_type=type(data).__name__))\n\n    generic.NDFrame.__init__(self, mgr)",
                "@property\ndef _constructor(self):\n    return SparseDataFrame",
                "def _init_dict(self, data, index, columns, dtype=None):\n    # pre-filter out columns if we passed it\n    if columns is not None:\n        columns = ensure_index(columns)\n        data = {k: v for k, v in data.items() if k in columns}\n    else:\n        keys = com.dict_keys_to_ordered_list(data)\n        columns = Index(keys)\n\n    if index is None:\n        index = extract_index(list(data.values()))\n\n    def sp_maker(x):\n        return SparseArray(\n            x,\n            kind=self._default_kind,\n            fill_value=self._default_fill_value,\n            copy=True,\n            dtype=dtype,\n        )\n\n    sdict = {}\n    for k, v in data.items():\n        if isinstance(v, Series):\n            # Force alignment, no copy necessary\n            if not v.index.equals(index):\n                v = v.reindex(index)\n\n            if not isinstance(v, SparseSeries):\n                v = sp_maker(v.values)\n        elif isinstance(v, SparseArray):\n            v = v.copy()\n        else:\n            if isinstance(v, dict):\n                v = [v.get(i, np.nan) for i in index]\n\n            v = sp_maker(v)\n\n        if index is not None and len(v) != len(index):\n            msg = \"Length of passed values is {}, index implies {}\"\n            raise ValueError(msg.format(len(v), len(index)))\n        sdict[k] = v\n\n    if len(columns.difference(sdict)):\n        # TODO: figure out how to handle this case, all nan's?\n        # add in any other columns we want to have (completeness)\n        nan_arr = np.empty(len(index), dtype=\"float64\")\n        nan_arr.fill(np.nan)\n        nan_arr = SparseArray(\n            nan_arr,\n            kind=self._default_kind,\n            fill_value=self._default_fill_value,\n            copy=False,\n        )\n        sdict.update((c, nan_arr) for c in columns if c not in sdict)\n\n    return to_manager(sdict, columns, index)",
                "def _init_matrix(self, data, index, columns, dtype=None):\n    \"\"\"\n    Init self from ndarray or list of lists.\n    \"\"\"\n    data = prep_ndarray(data, copy=False)\n    index, columns = SparseFrameAccessor._prep_index(data, index, columns)\n    data = {idx: data[:, i] for i, idx in enumerate(columns)}\n    return self._init_dict(data, index, columns, dtype)",
                "def _init_spmatrix(self, data, index, columns, dtype=None, fill_value=None):\n    \"\"\"\n    Init self from scipy.sparse matrix.\n    \"\"\"\n    index, columns = SparseFrameAccessor._prep_index(data, index, columns)\n    data = data.tocoo()\n    N = len(index)\n\n    # Construct a dict of SparseSeries\n    sdict = {}\n    values = Series(data.data, index=data.row, copy=False)\n    for col, rowvals in values.groupby(data.col):\n        # get_blocks expects int32 row indices in sorted order\n        rowvals = rowvals.sort_index()\n        rows = rowvals.index.values.astype(np.int32)\n        blocs, blens = get_blocks(rows)\n\n        sdict[columns[col]] = SparseSeries(\n            rowvals.values,\n            index=index,\n            fill_value=fill_value,\n            sparse_index=BlockIndex(N, blocs, blens),\n        )\n\n    # Add any columns that were empty and thus not grouped on above\n    sdict.update(\n        {\n            column: SparseSeries(\n                index=index,\n                fill_value=fill_value,\n                sparse_index=BlockIndex(N, [], []),\n            )\n            for column in columns\n            if column not in sdict\n        }\n    )\n\n    return self._init_dict(sdict, index, columns, dtype)",
                "@Appender(SparseFrameAccessor.to_coo.__doc__)\ndef to_coo(self):\n    return SparseFrameAccessor(self).to_coo()",
                "def __repr__(self):\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", \"Sparse\")\n        return super().__repr__()",
                "def __getstate__(self):\n    # pickling\n    return dict(\n        _typ=self._typ,\n        _subtyp=self._subtyp,\n        _data=self._data,\n        _default_fill_value=self._default_fill_value,\n        _default_kind=self._default_kind,\n    )",
                "def _unpickle_sparse_frame_compat(self, state):\n    \"\"\"\n    Original pickle format\n    \"\"\"\n    series, cols, idx, fv, kind = state\n\n    if not isinstance(cols, Index):  # pragma: no cover\n        from pandas.io.pickle import _unpickle_array\n\n        columns = _unpickle_array(cols)\n    else:\n        columns = cols\n\n    if not isinstance(idx, Index):  # pragma: no cover\n        from pandas.io.pickle import _unpickle_array\n\n        index = _unpickle_array(idx)\n    else:\n        index = idx\n\n    series_dict = DataFrame()\n    for col, (sp_index, sp_values) in series.items():\n        series_dict[col] = SparseSeries(\n            sp_values, sparse_index=sp_index, fill_value=fv\n        )\n\n    self._data = to_manager(series_dict, columns, index)\n    self._default_fill_value = fv\n    self._default_kind = kind",
                "@Appender(SparseFrameAccessor.to_dense.__doc__)\ndef to_dense(self):\n    return SparseFrameAccessor(self).to_dense()",
                "def _apply_columns(self, func):\n    \"\"\"\n    Get new SparseDataFrame applying func to each columns\n    \"\"\"\n\n    new_data = {col: func(series) for col, series in self.items()}\n\n    return self._constructor(\n        data=new_data,\n        index=self.index,\n        columns=self.columns,\n        default_fill_value=self.default_fill_value,\n    ).__finalize__(self)",
                "def astype(self, dtype):\n    return self._apply_columns(lambda x: x.astype(dtype))",
                "def copy(self, deep=True):\n    \"\"\"\n    Make a copy of this SparseDataFrame\n    \"\"\"\n    result = super().copy(deep=deep)\n    result._default_fill_value = self._default_fill_value\n    result._default_kind = self._default_kind\n    return result",
                "@property\ndef default_fill_value(self):\n    return self._default_fill_value",
                "@property\ndef default_kind(self):\n    return self._default_kind",
                "@property\ndef density(self):\n    \"\"\"\n    Ratio of non-sparse points to total (dense) data points\n    represented in the frame\n    \"\"\"\n    tot_nonsparse = sum(ser.sp_index.npoints for _, ser in self.items())\n    tot = len(self.index) * len(self.columns)\n    return tot_nonsparse / float(tot)",
                "def fillna(\n    self, value=None, method=None, axis=0, inplace=False, limit=None, downcast=None\n):\n    new_self = super().fillna(\n        value=value,\n        method=method,\n        axis=axis,\n        inplace=inplace,\n        limit=limit,\n        downcast=downcast,\n    )\n    if not inplace:\n        self = new_self\n\n    # set the fill value if we are filling as a scalar with nothing special\n    # going on\n    if value is not None and value == value and method is None and limit is None:\n        self._default_fill_value = value\n\n    if not inplace:\n        return self",
                "def _sanitize_column(self, key, value, **kwargs):\n    \"\"\"\n    Creates a new SparseArray from the input value.\n\n    Parameters\n    ----------\n    key : object\n    value : scalar, Series, or array-like\n    kwargs : dict\n\n    Returns\n    -------\n    sanitized_column : SparseArray\n\n    \"\"\"\n\n    def sp_maker(x, index=None):\n        return SparseArray(\n            x,\n            index=index,\n            fill_value=self._default_fill_value,\n            kind=self._default_kind,\n        )\n\n    if isinstance(value, SparseSeries):\n        clean = value.reindex(self.index).as_sparse_array(\n            fill_value=self._default_fill_value, kind=self._default_kind\n        )\n\n    elif isinstance(value, SparseArray):\n        if len(value) != len(self.index):\n            raise ValueError(\"Length of values does not match length of index\")\n        clean = value\n\n    elif hasattr(value, \"__iter__\"):\n        if isinstance(value, Series):\n            clean = value.reindex(self.index)\n            if not isinstance(value, SparseSeries):\n                clean = sp_maker(clean)\n        else:\n            if len(value) != len(self.index):\n                raise ValueError(\"Length of values does not match length of index\")\n            clean = sp_maker(value)\n\n    # Scalar\n    else:\n        clean = sp_maker(value, self.index)\n\n    # always return a SparseArray!\n    return clean",
                "def _get_value(self, index, col, takeable=False):\n    \"\"\"\n    Quickly retrieve single value at passed column and index\n\n    Please use .at[] or .iat[] accessors.\n\n    Parameters\n    ----------\n    index : row label\n    col : column label\n    takeable : interpret the index/col as indexers, default False\n\n    Returns\n    -------\n    value : scalar value\n    \"\"\"\n    if takeable is True:\n        series = self._iget_item_cache(col)\n    else:\n        series = self._get_item_cache(col)\n\n    return series._get_value(index, takeable=takeable)",
                "def _slice(self, slobj, axis=0, kind=None):\n    if axis == 0:\n        new_index = self.index[slobj]\n        new_columns = self.columns\n    else:\n        new_index = self.index\n        new_columns = self.columns[slobj]\n\n    return self.reindex(index=new_index, columns=new_columns)",
                "def xs(self, key, axis=0, copy=False):\n    \"\"\"\n    Returns a row (cross-section) from the SparseDataFrame as a Series\n    object.\n\n    Parameters\n    ----------\n    key : some index contained in the index\n\n    Returns\n    -------\n    xs : Series\n    \"\"\"\n    if axis == 1:\n        data = self[key]\n        return data\n\n    i = self.index.get_loc(key)\n    data = self.take([i])._internal_get_values()[0]\n    return Series(data, index=self.columns)",
                "def _set_value(self, index, col, value, takeable=False):\n    \"\"\"\n    Put single value at passed column and index\n\n    Please use .at[] or .iat[] accessors.\n\n    Parameters\n    ----------\n    index : row label\n    col : column label\n    value : scalar value\n    takeable : interpret the index/col as indexers, default False\n\n    Notes\n    -----\n    This method *always* returns a new object. It is currently not\n    particularly efficient (and potentially very expensive) but is provided\n    for API compatibility with DataFrame\n\n    Returns\n    -------\n    frame : DataFrame\n    \"\"\"\n    dense = self.to_dense()._set_value(index, col, value, takeable=takeable)\n    return dense.to_sparse(\n        kind=self._default_kind, fill_value=self._default_fill_value\n    )",
                "def _combine_frame(self, other, func, fill_value=None, level=None):\n    if level is not None:\n        raise NotImplementedError(\"'level' argument is not supported\")\n\n    this, other = self.align(other, join=\"outer\", level=level, copy=False)\n    new_index, new_columns = this.index, this.columns\n\n    if self.empty and other.empty:\n        return self._constructor(index=new_index).__finalize__(self)\n\n    new_data = {}\n    if fill_value is not None:\n        # TODO: be a bit more intelligent here\n        for col in new_columns:\n            if col in this and col in other:\n                dleft = this[col].to_dense()\n                dright = other[col].to_dense()\n                result = dleft._binop(dright, func, fill_value=fill_value)\n                result = result.to_sparse(fill_value=this[col].fill_value)\n                new_data[col] = result\n    else:\n\n        for col in new_columns:\n            if col in this and col in other:\n                new_data[col] = func(this[col], other[col])\n\n    new_fill_value = self._get_op_result_fill_value(other, func)\n\n    return self._constructor(\n        data=new_data,\n        index=new_index,\n        columns=new_columns,\n        default_fill_value=new_fill_value,\n    ).__finalize__(self)",
                "def _combine_match_index(self, other, func, level=None):\n\n    if level is not None:\n        raise NotImplementedError(\"'level' argument is not supported\")\n\n    this, other = self.align(other, join=\"outer\", axis=0, level=level, copy=False)\n\n    new_data = {}\n    for col, series in this.items():\n        new_data[col] = func(series.values, other.values)\n\n    fill_value = self._get_op_result_fill_value(other, func)\n\n    return self._constructor(\n        new_data,\n        index=this.index,\n        columns=self.columns,\n        default_fill_value=fill_value,\n    ).__finalize__(self)",
                "def _combine_match_columns(self, other, func, level=None):\n    # patched version of DataFrame._combine_match_columns to account for\n    # NumPy circumventing __rsub__ with float64 types, e.g.: 3.0 - series,\n    # where 3.0 is numpy.float64 and series is a SparseSeries. Still\n    # possible for this to happen, which is bothersome\n\n    if level is not None:\n        raise NotImplementedError(\"'level' argument is not supported\")\n\n    left, right = self.align(other, join=\"outer\", axis=1, level=level, copy=False)\n    assert left.columns.equals(right.index)\n\n    new_data = {}\n\n    for col in left.columns:\n        new_data[col] = func(left[col], float(right[col]))\n\n    return self._constructor(\n        new_data,\n        index=left.index,\n        columns=left.columns,\n        default_fill_value=self.default_fill_value,\n    ).__finalize__(self)",
                "def _combine_const(self, other, func):\n    return self._apply_columns(lambda x: func(x, other))",
                "def _get_op_result_fill_value(self, other, func):\n    own_default = self.default_fill_value\n\n    if isinstance(other, DataFrame):\n        # i.e. called from _combine_frame\n\n        other_default = getattr(other, \"default_fill_value\", np.nan)\n\n        # if the fill values are the same use them? or use a valid one\n        if own_default == other_default:\n            # TOOD: won't this evaluate as False if both are np.nan?\n            fill_value = own_default\n        elif np.isnan(own_default) and not np.isnan(other_default):\n            fill_value = other_default\n        elif not np.isnan(own_default) and np.isnan(other_default):\n            fill_value = own_default\n        else:\n            fill_value = None\n\n    elif isinstance(other, SparseSeries):\n        # i.e. called from _combine_match_index\n\n        # fill_value is a function of our operator\n        if isna(other.fill_value) or isna(own_default):\n            fill_value = np.nan\n        else:\n            fill_value = func(np.float64(own_default), np.float64(other.fill_value))\n            fill_value = item_from_zerodim(fill_value)\n    else:\n        raise NotImplementedError(type(other))\n\n    return fill_value",
                "def _reindex_index(\n    self, index, method, copy, level, fill_value=np.nan, limit=None, takeable=False\n):\n    if level is not None:\n        raise TypeError(\"Reindex by level not supported for sparse\")\n\n    if self.index.equals(index):\n        if copy:\n            return self.copy()\n        else:\n            return self\n\n    if len(self.index) == 0:\n        return self._constructor(index=index, columns=self.columns).__finalize__(\n            self\n        )\n\n    indexer = self.index.get_indexer(index, method, limit=limit)\n    indexer = ensure_platform_int(indexer)\n    mask = indexer == -1\n    need_mask = mask.any()\n\n    new_series = {}\n    for col, series in self.items():\n        if mask.all():\n            continue\n\n        values = series.values\n        # .take returns SparseArray\n        new = values.take(indexer)\n        if need_mask:\n            new = new.to_dense()\n            # convert integer to float if necessary. need to do a lot\n            # more than that, handle boolean etc also\n            new, fill_value = maybe_upcast(new, fill_value=fill_value)\n            np.putmask(new, mask, fill_value)\n\n        new_series[col] = new\n\n    return self._constructor(\n        new_series,\n        index=index,\n        columns=self.columns,\n        default_fill_value=self._default_fill_value,\n    ).__finalize__(self)",
                "def _reindex_columns(\n    self, columns, method, copy, level, fill_value=None, limit=None, takeable=False\n):\n    if level is not None:\n        raise TypeError(\"Reindex by level not supported for sparse\")\n\n    if notna(fill_value):\n        raise NotImplementedError(\"'fill_value' argument is not supported\")\n\n    if limit:\n        raise NotImplementedError(\"'limit' argument is not supported\")\n\n    if method is not None:\n        raise NotImplementedError(\"'method' argument is not supported\")\n\n    # TODO: fill value handling\n    sdict = {k: v for k, v in self.items() if k in columns}\n    return self._constructor(\n        sdict,\n        index=self.index,\n        columns=columns,\n        default_fill_value=self._default_fill_value,\n    ).__finalize__(self)",
                "def _reindex_with_indexers(\n    self,\n    reindexers,\n    method=None,\n    fill_value=None,\n    limit=None,\n    copy=False,\n    allow_dups=False,\n):\n\n    if method is not None or limit is not None:\n        raise NotImplementedError(\n            \"cannot reindex with a method or limit with sparse\"\n        )\n\n    if fill_value is None:\n        fill_value = np.nan\n\n    reindexers = {self._get_axis_number(a): val for (a, val) in reindexers.items()}\n\n    index, row_indexer = reindexers.get(0, (None, None))\n    columns, col_indexer = reindexers.get(1, (None, None))\n\n    if columns is None:\n        columns = self.columns\n\n    new_arrays = {}\n    for col in columns:\n        if col not in self:\n            continue\n        if row_indexer is not None:\n            new_arrays[col] = algos.take_1d(\n                self[col]._internal_get_values(), row_indexer, fill_value=fill_value\n            )\n        else:\n            new_arrays[col] = self[col]\n\n    return self._constructor(new_arrays, index=index, columns=columns).__finalize__(\n        self\n    )",
                "def _join_compat(\n    self, other, on=None, how=\"left\", lsuffix=\"\", rsuffix=\"\", sort=False\n):\n    if on is not None:\n        raise NotImplementedError(\"'on' keyword parameter is not yet implemented\")\n    return self._join_index(other, how, lsuffix, rsuffix)",
                "def _join_index(self, other, how, lsuffix, rsuffix):\n    if isinstance(other, Series):\n        if other.name is None:\n            raise ValueError(\"Other Series must have a name\")\n\n        other = SparseDataFrame(\n            {other.name: other}, default_fill_value=self._default_fill_value\n        )\n\n    join_index = self.index.join(other.index, how=how)\n\n    this = self.reindex(join_index)\n    other = other.reindex(join_index)\n\n    this, other = this._maybe_rename_join(other, lsuffix, rsuffix)\n\n    from pandas import concat\n\n    return concat([this, other], axis=1, verify_integrity=True)",
                "def _maybe_rename_join(self, other, lsuffix, rsuffix):\n    to_rename = self.columns.intersection(other.columns)\n    if len(to_rename) > 0:\n        if not lsuffix and not rsuffix:\n            raise ValueError(\n                \"columns overlap but no suffix specified: \"\n                \"{to_rename}\".format(to_rename=to_rename)\n            )\n\n        def lrenamer(x):\n            if x in to_rename:\n                return \"{x}{lsuffix}\".format(x=x, lsuffix=lsuffix)\n            return x\n\n        def rrenamer(x):\n            if x in to_rename:\n                return \"{x}{rsuffix}\".format(x=x, rsuffix=rsuffix)\n            return x\n\n        this = self.rename(columns=lrenamer)\n        other = other.rename(columns=rrenamer)\n    else:\n        this = self\n\n    return this, other",
                "def transpose(self, *args, **kwargs):\n    \"\"\"\n    Returns a DataFrame with the rows/columns switched.\n    \"\"\"\n    nv.validate_transpose(args, kwargs)\n    return self._constructor(\n        self.values.T,\n        index=self.columns,\n        columns=self.index,\n        default_fill_value=self._default_fill_value,\n        default_kind=self._default_kind,\n    ).__finalize__(self)",
                "@Appender(DataFrame.count.__doc__)\ndef count(self, axis=0, **kwds):\n    if axis is None:\n        axis = self._stat_axis_number\n\n    return self.apply(lambda x: x.count(), axis=axis)",
                "def cumsum(self, axis=0, *args, **kwargs):\n    \"\"\"\n    Return SparseDataFrame of cumulative sums over requested axis.\n\n    Parameters\n    ----------\n    axis : {0, 1}\n        0 for row-wise, 1 for column-wise\n\n    Returns\n    -------\n    y : SparseDataFrame\n    \"\"\"\n    nv.validate_cumsum(args, kwargs)\n\n    if axis is None:\n        axis = self._stat_axis_number\n\n    return self.apply(lambda x: x.cumsum(), axis=axis)",
                "@Appender(generic._shared_docs[\"isna\"] % _shared_doc_kwargs)\ndef isna(self):\n    return self._apply_columns(lambda x: x.isna())",
                "@Appender(generic._shared_docs[\"notna\"] % _shared_doc_kwargs)\ndef notna(self):\n    return self._apply_columns(lambda x: x.notna())",
                "def apply(self, func, axis=0, broadcast=None, reduce=None, result_type=None):\n    \"\"\"\n    Analogous to DataFrame.apply, for SparseDataFrame\n\n    Parameters\n    ----------\n    func : function\n        Function to apply to each column\n    axis : {0, 1, 'index', 'columns'}\n    broadcast : bool, default False\n        For aggregation functions, return object of same size with values\n        propagated\n\n        .. deprecated:: 0.23.0\n           This argument will be removed in a future version, replaced\n           by result_type='broadcast'.\n\n    reduce : boolean or None, default None\n        Try to apply reduction procedures. If the DataFrame is empty,\n        apply will use reduce to determine whether the result should be a\n        Series or a DataFrame. If reduce is None (the default), apply's\n        return value will be guessed by calling func an empty Series (note:\n        while guessing, exceptions raised by func will be ignored). If\n        reduce is True a Series will always be returned, and if False a\n        DataFrame will always be returned.\n\n        .. deprecated:: 0.23.0\n           This argument will be removed in a future version, replaced\n           by result_type='reduce'.\n\n    result_type : {'expand', 'reduce', 'broadcast, None}\n        These only act when axis=1 {columns}:\n\n        * 'expand' : list-like results will be turned into columns.\n        * 'reduce' : return a Series if possible rather than expanding\n          list-like results. This is the opposite to 'expand'.\n        * 'broadcast' : results will be broadcast to the original shape\n          of the frame, the original index & columns will be retained.\n\n        The default behaviour (None) depends on the return value of the\n        applied function: list-like results will be returned as a Series\n        of those. However if the apply function returns a Series these\n        are expanded to columns.\n\n        .. versionadded:: 0.23.0\n\n    Returns\n    -------\n    applied : Series or SparseDataFrame\n    \"\"\"\n    if not len(self.columns):\n        return self\n    axis = self._get_axis_number(axis)\n\n    if isinstance(func, np.ufunc):\n        new_series = {}\n        for k, v in self.items():\n            applied = func(v)\n            applied.fill_value = func(v.fill_value)\n            new_series[k] = applied\n        return self._constructor(\n            new_series,\n            index=self.index,\n            columns=self.columns,\n            default_fill_value=self._default_fill_value,\n            default_kind=self._default_kind,\n        ).__finalize__(self)\n\n    from pandas.core.apply import frame_apply\n\n    op = frame_apply(\n        self,\n        func=func,\n        axis=axis,\n        reduce=reduce,\n        broadcast=broadcast,\n        result_type=result_type,\n    )\n    return op.get_result()",
                "def applymap(self, func):\n    \"\"\"\n    Apply a function to a DataFrame that is intended to operate\n    elementwise, i.e. like doing map(func, series) for each series in the\n    DataFrame\n\n    Parameters\n    ----------\n    func : function\n        Python function, returns a single value from a single value\n\n    Returns\n    -------\n    applied : DataFrame\n    \"\"\"\n    return self.apply(lambda x: [func(y) for y in x])",
                "def sp_maker(x):\n    return SparseArray(\n        x,\n        kind=self._default_kind,\n        fill_value=self._default_fill_value,\n        copy=True,\n        dtype=dtype,\n    )",
                "def sp_maker(x, index=None):\n    return SparseArray(\n        x,\n        index=index,\n        fill_value=self._default_fill_value,\n        kind=self._default_kind,\n    )",
                "def lrenamer(x):\n    if x in to_rename:\n        return \"{x}{lsuffix}\".format(x=x, lsuffix=lsuffix)\n    return x",
                "def rrenamer(x):\n    if x in to_rename:\n        return \"{x}{rsuffix}\".format(x=x, rsuffix=rsuffix)\n    return x"
            ],
            "inscope_function_signatures": [
                "to_manager(sdf, columns, index)",
                "stack_sparse_frame(frame)",
                "homogenize(series_dict)",
                "__init__(self, data=None, index=None, columns=None, default_kind=None, default_fill_value=None, dtype=None, copy=False)",
                "_constructor(self)",
                "_init_dict(self, data, index, columns, dtype=None)",
                "_init_matrix(self, data, index, columns, dtype=None)",
                "_init_spmatrix(self, data, index, columns, dtype=None, fill_value=None)",
                "to_coo(self)",
                "__repr__(self)",
                "__getstate__(self)",
                "_unpickle_sparse_frame_compat(self, state)",
                "to_dense(self)",
                "_apply_columns(self, func)",
                "astype(self, dtype)",
                "copy(self, deep=True)",
                "default_fill_value(self)",
                "default_kind(self)",
                "density(self)",
                "fillna(self, value=None, method=None, axis=0, inplace=False, limit=None, downcast=None)",
                "_sanitize_column(self, key, value, **kwargs)",
                "_get_value(self, index, col, takeable=False)",
                "_slice(self, slobj, axis=0, kind=None)",
                "xs(self, key, axis=0, copy=False)",
                "_set_value(self, index, col, value, takeable=False)",
                "_combine_frame(self, other, func, fill_value=None, level=None)",
                "_combine_match_index(self, other, func, level=None)",
                "_combine_match_columns(self, other, func, level=None)",
                "_combine_const(self, other, func)",
                "_get_op_result_fill_value(self, other, func)",
                "_reindex_index(self, index, method, copy, level, fill_value=np.nan, limit=None, takeable=False)",
                "_reindex_columns(self, columns, method, copy, level, fill_value=None, limit=None, takeable=False)",
                "_reindex_with_indexers(self, reindexers, method=None, fill_value=None, limit=None, copy=False, allow_dups=False)",
                "_join_compat(self, other, on=None, how='left', lsuffix='', rsuffix='', sort=False)",
                "_join_index(self, other, how, lsuffix, rsuffix)",
                "_maybe_rename_join(self, other, lsuffix, rsuffix)",
                "transpose(self, *args, **kwargs)",
                "count(self, axis=0, **kwds)",
                "cumsum(self, axis=0, *args, **kwargs)",
                "isna(self)",
                "notna(self)",
                "apply(self, func, axis=0, broadcast=None, reduce=None, result_type=None)",
                "applymap(self, func)",
                "sp_maker(x)",
                "sp_maker(x, index=None)",
                "lrenamer(x)",
                "rrenamer(x)"
            ],
            "variables_in_file": {
                "_shared_doc_kwargs": [
                    857,
                    30,
                    863
                ],
                "dict": [
                    131,
                    202,
                    115,
                    121,
                    30,
                    286
                ],
                "depr_msg": [
                    81,
                    31
                ],
                "DataFrame": [
                    134,
                    40,
                    621,
                    1009,
                    314,
                    123,
                    830
                ],
                "_subtyp": [
                    66
                ],
                "is_scalar": [
                    78
                ],
                "default_fill_value": [
                    96,
                    103,
                    104,
                    109,
                    78,
                    113,
                    88,
                    89,
                    95
                ],
                "ValueError": [
                    772,
                    428,
                    79,
                    209,
                    438,
                    793
                ],
                "warnings.warn": [
                    81
                ],
                "warnings": [
                    280,
                    81,
                    281
                ],
                "FutureWarning": [
                    81
                ],
                "isinstance": [
                    129,
                    770,
                    637,
                    923,
                    421,
                    426,
                    300,
                    432,
                    434,
                    307,
                    192,
                    197,
                    199,
                    202,
                    83,
                    92,
                    621,
                    115,
                    117,
                    119,
                    123,
                    125
                ],
                "data": [
                    129,
                    131,
                    133,
                    134,
                    145,
                    151,
                    159,
                    173,
                    175,
                    179,
                    191,
                    499,
                    83,
                    85,
                    87,
                    89,
                    91,
                    92,
                    247,
                    94,
                    96,
                    97,
                    98,
                    503,
                    101,
                    231,
                    232,
                    233,
                    234,
                    111,
                    240,
                    113,
                    241,
                    115,
                    116,
                    117,
                    118,
                    119,
                    246,
                    121,
                    498,
                    123,
                    124,
                    125,
                    502,
                    127
                ],
                "SparseDataFrame": [
                    1059,
                    1060,
                    165,
                    774,
                    83,
                    119
                ],
                "index": [
                    131,
                    1031,
                    136,
                    137,
                    264,
                    139,
                    1039,
                    528,
                    273,
                    657,
                    147,
                    1040,
                    1041,
                    1043,
                    151,
                    664,
                    1048,
                    1049,
                    668,
                    416,
                    178,
                    179,
                    692,
                    310,
                    312,
                    320,
                    194,
                    195,
                    203,
                    973,
                    207,
                    209,
                    84,
                    85,
                    215,
                    472,
                    93,
                    94,
                    225,
                    741,
                    232,
                    234,
                    1003,
                    240,
                    113,
                    242,
                    1009,
                    116,
                    118,
                    758,
                    121,
                    255
                ],
                "data.index": [
                    124,
                    85,
                    94,
                    127
                ],
                "columns": [
                    131,
                    268,
                    141,
                    142,
                    144,
                    273,
                    151,
                    171,
                    172,
                    173,
                    303,
                    176,
                    305,
                    320,
                    713,
                    717,
                    973,
                    975,
                    212,
                    86,
                    87,
                    223,
                    97,
                    98,
                    99,
                    225,
                    101,
                    742,
                    232,
                    233,
                    234,
                    744,
                    745,
                    748,
                    240,
                    113,
                    116,
                    118,
                    758,
                    121,
                    253
                ],
                "data.columns": [
                    124,
                    87
                ],
                "data.default_fill_value": [
                    89
                ],
                "default_kind": [
                    105,
                    106,
                    108,
                    90,
                    91
                ],
                "data.default_kind": [
                    91
                ],
                "SparseSeries": [
                    197,
                    421,
                    263,
                    167,
                    637,
                    434,
                    316,
                    92,
                    253
                ],
                "SparseArray": [
                    199,
                    426,
                    145,
                    182,
                    217,
                    92,
                    414
                ],
                "data.fill_value": [
                    96
                ],
                "hasattr": [
                    97,
                    431
                ],
                "data.name": [
                    98
                ],
                "Exception": [
                    100
                ],
                "np.nan": [
                    737,
                    642,
                    104,
                    203,
                    652,
                    624,
                    216
                ],
                "np": [
                    642,
                    644,
                    652,
                    1036,
                    923,
                    686,
                    203,
                    215,
                    216,
                    986,
                    737,
                    994,
                    104,
                    1001,
                    1002,
                    624,
                    117,
                    630,
                    632,
                    250
                ],
                "self._default_kind": [
                    322,
                    291,
                    418,
                    934,
                    423,
                    360,
                    108,
                    530,
                    148,
                    184,
                    825,
                    219,
                    351
                ],
                "self": [
                    528,
                    530,
                    540,
                    543,
                    544,
                    562,
                    564,
                    569,
                    576,
                    582,
                    584,
                    587,
                    589,
                    600,
                    608,
                    612,
                    613,
                    616,
                    619,
                    108,
                    109,
                    112,
                    116,
                    118,
                    120,
                    124,
                    126,
                    130,
                    657,
                    146,
                    659,
                    148,
                    149,
                    661,
                    663,
                    664,
                    665,
                    668,
                    161,
                    674,
                    690,
                    693,
                    694,
                    695,
                    184,
                    185,
                    713,
                    714,
                    716,
                    718,
                    719,
                    219,
                    220,
                    739,
                    745,
                    234,
                    749,
                    753,
                    756,
                    758,
                    759,
                    767,
                    775,
                    778,
                    780,
                    273,
                    277,
                    790,
                    287,
                    288,
                    289,
                    290,
                    291,
                    808,
                    811,
                    820,
                    821,
                    822,
                    823,
                    824,
                    825,
                    826,
                    320,
                    321,
                    322,
                    833,
                    835,
                    326,
                    333,
                    335,
                    337,
                    338,
                    339,
                    340,
                    853,
                    343,
                    855,
                    859,
                    350,
                    351,
                    865,
                    356,
                    360,
                    368,
                    369,
                    384,
                    389,
                    392,
                    919,
                    920,
                    921,
                    925,
                    417,
                    418,
                    929,
                    931,
                    932,
                    422,
                    423,
                    933,
                    934,
                    935,
                    427,
                    940,
                    433,
                    437,
                    443,
                    964,
                    468,
                    470,
                    476,
                    477,
                    479,
                    480,
                    482,
                    498,
                    501,
                    502,
                    503
                ],
                "self._default_fill_value": [
                    321,
                    290,
                    417,
                    356,
                    389,
                    933,
                    423,
                    775,
                    109,
                    718,
                    146,
                    530,
                    149,
                    694,
                    824,
                    185,
                    220,
                    350
                ],
                "is_scipy_sparse": [
                    111
                ],
                "mgr": [
                    161,
                    130,
                    112,
                    116,
                    118,
                    151,
                    120,
                    153,
                    124,
                    126
                ],
                "self._init_spmatrix": [
                    112
                ],
                "dtype": [
                    153,
                    131,
                    234,
                    113,
                    273,
                    116,
                    118,
                    343,
                    152,
                    121,
                    187,
                    124,
                    127
                ],
                "self._init_dict": [
                    234,
                    273,
                    116,
                    124,
                    126
                ],
                "np.ndarray": [
                    117
                ],
                "list": [
                    179,
                    117
                ],
                "self._init_matrix": [
                    118
                ],
                "self._init_mgr": [
                    120,
                    130
                ],
                "data._data": [
                    121
                ],
                "copy": [
                    121,
                    658,
                    131,
                    349
                ],
                "Series": [
                    192,
                    770,
                    432,
                    246,
                    503,
                    125
                ],
                "data.to_frame": [
                    127
                ],
                "BlockManager": [
                    129
                ],
                "Index": [
                    137,
                    300,
                    142,
                    176,
                    307
                ],
                "ensure_index": [
                    139,
                    172,
                    973
                ],
                "c": [
                    144,
                    145,
                    975,
                    223
                ],
                "to_manager": [
                    320,
                    225,
                    151
                ],
                "mgr.astype": [
                    153
                ],
                "msg": [
                    208,
                    209,
                    155,
                    159
                ],
                "TypeError": [
                    995,
                    1037,
                    655,
                    701,
                    159
                ],
                "msg.format": [
                    209,
                    159
                ],
                "__name__": [
                    159
                ],
                "type": [
                    647,
                    159
                ],
                "generic.NDFrame.__init__": [
                    161
                ],
                "generic.NDFrame": [
                    161
                ],
                "generic": [
                    857,
                    161,
                    863
                ],
                "property": [
                    354,
                    163,
                    358,
                    362,
                    828
                ],
                "_constructor_sliced": [
                    167
                ],
                "k": [
                    928,
                    713,
                    173,
                    210,
                    925,
                    191
                ],
                "v": [
                    925,
                    926,
                    927,
                    173,
                    191,
                    192,
                    194,
                    195,
                    197,
                    198,
                    199,
                    200,
                    713,
                    202,
                    203,
                    205,
                    207,
                    209,
                    210
                ],
                "data.items": [
                    173,
                    191
                ],
                "keys": [
                    176,
                    175
                ],
                "com.dict_keys_to_ordered_list": [
                    175
                ],
                "com": [
                    175
                ],
                "extract_index": [
                    179
                ],
                "data.values": [
                    179
                ],
                "x": [
                    800,
                    801,
                    865,
                    835,
                    804,
                    805,
                    806,
                    964,
                    616,
                    855,
                    799,
                    343,
                    183,
                    859,
                    415
                ],
                "sdict": [
                    225,
                    261,
                    713,
                    715,
                    269,
                    273,
                    210,
                    212,
                    245,
                    253,
                    190,
                    223
                ],
                "v.index.equals": [
                    194
                ],
                "v.index": [
                    194
                ],
                "v.reindex": [
                    195
                ],
                "sp_maker": [
                    198,
                    205,
                    435,
                    439,
                    443
                ],
                "v.values": [
                    198
                ],
                "v.copy": [
                    200
                ],
                "v.get": [
                    203
                ],
                "i": [
                    233,
                    203,
                    501,
                    502
                ],
                "len": [
                    663,
                    427,
                    791,
                    207,
                    919,
                    209,
                    242,
                    369,
                    212,
                    437,
                    215,
                    986
                ],
                "columns.difference": [
                    212
                ],
                "nan_arr": [
                    215,
                    216,
                    217,
                    218,
                    223
                ],
                "np.empty": [
                    215
                ],
                "nan_arr.fill": [
                    216
                ],
                "sdict.update": [
                    261,
                    223
                ],
                "prep_ndarray": [
                    231
                ],
                "SparseFrameAccessor._prep_index": [
                    232,
                    240
                ],
                "SparseFrameAccessor": [
                    324,
                    326,
                    232,
                    240,
                    275,
                    277
                ],
                "idx": [
                    233,
                    298,
                    307,
                    310,
                    312
                ],
                "enumerate": [
                    233
                ],
                "data.tocoo": [
                    241
                ],
                "N": [
                    257,
                    242,
                    266
                ],
                "values": [
                    680,
                    678,
                    246,
                    247
                ],
                "data.data": [
                    246
                ],
                "data.row": [
                    246
                ],
                "col": [
                    528,
                    674,
                    549,
                    550,
                    551,
                    552,
                    554,
                    555,
                    558,
                    559,
                    560,
                    688,
                    315,
                    316,
                    579,
                    580,
                    333,
                    468,
                    470,
                    605,
                    606,
                    748,
                    749,
                    752,
                    753,
                    756,
                    247,
                    253
                ],
                "rowvals": [
                    249,
                    250,
                    254,
                    247
                ],
                "values.groupby": [
                    247
                ],
                "data.col": [
                    247
                ],
                "rowvals.sort_index": [
                    249
                ],
                "rows": [
                    250,
                    251
                ],
                "rowvals.index.values.astype": [
                    250
                ],
                "rowvals.index.values": [
                    250
                ],
                "rowvals.index": [
                    250
                ],
                "np.int32": [
                    250
                ],
                "blocs": [
                    257,
                    251
                ],
                "blens": [
                    257,
                    251
                ],
                "get_blocks": [
                    251
                ],
                "rowvals.values": [
                    254
                ],
                "fill_value": [
                    256,
                    642,
                    644,
                    645,
                    265,
                    649,
                    547,
                    553,
                    554,
                    685,
                    686,
                    703,
                    582,
                    588,
                    736,
                    737,
                    753,
                    629,
                    631,
                    633,
                    635
                ],
                "BlockIndex": [
                    257,
                    266
                ],
                "column": [
                    268,
                    269,
                    263
                ],
                "to_coo": [
                    277
                ],
                "Appender": [
                    324,
                    275,
                    857,
                    830,
                    863
                ],
                "SparseFrameAccessor.to_coo.__doc__": [
                    275
                ],
                "SparseFrameAccessor.to_coo": [
                    275
                ],
                "warnings.catch_warnings": [
                    280
                ],
                "warnings.filterwarnings": [
                    281
                ],
                "__repr__": [
                    282
                ],
                "super": [
                    282,
                    349,
                    375
                ],
                "self._typ": [
                    287
                ],
                "self._subtyp": [
                    288
                ],
                "self._data": [
                    320,
                    289
                ],
                "series": [
                    1035,
                    1036,
                    1040,
                    1041,
                    1043,
                    1047,
                    1048,
                    1049,
                    1051,
                    674,
                    678,
                    298,
                    315,
                    579,
                    580,
                    333,
                    468,
                    470,
                    472,
                    993,
                    994,
                    997,
                    999
                ],
                "cols": [
                    305,
                    298,
                    300,
                    303
                ],
                "fv": [
                    321,
                    298,
                    317
                ],
                "kind": [
                    298,
                    322
                ],
                "state": [
                    298
                ],
                "_unpickle_array": [
                    310,
                    303
                ],
                "series_dict": [
                    320,
                    1035,
                    1047,
                    314,
                    316,
                    1053
                ],
                "sp_index": [
                    315,
                    317
                ],
                "sp_values": [
                    315,
                    317
                ],
                "series.items": [
                    315
                ],
                "to_dense": [
                    552,
                    326,
                    551
                ],
                "SparseFrameAccessor.to_dense.__doc__": [
                    324
                ],
                "SparseFrameAccessor.to_dense": [
                    324
                ],
                "new_data": [
                    609,
                    546,
                    578,
                    580,
                    585,
                    555,
                    333,
                    336,
                    560,
                    565,
                    603,
                    606
                ],
                "func": [
                    580,
                    644,
                    582,
                    964,
                    616,
                    553,
                    333,
                    941,
                    560,
                    562,
                    926,
                    923,
                    606,
                    927
                ],
                "self.items": [
                    674,
                    713,
                    333,
                    368,
                    925
                ],
                "__finalize__": [
                    544,
                    608,
                    929,
                    584,
                    714,
                    335,
                    690,
                    564,
                    820,
                    758,
                    664
                ],
                "self._constructor": [
                    544,
                    608,
                    929,
                    584,
                    714,
                    335,
                    690,
                    564,
                    820,
                    758,
                    664
                ],
                "self.index": [
                    668,
                    931,
                    422,
                    778,
                    427,
                    716,
                    823,
                    433,
                    337,
                    369,
                    657,
                    437,
                    501,
                    663,
                    443,
                    476,
                    479
                ],
                "self.columns": [
                    480,
                    932,
                    745,
                    587,
                    919,
                    369,
                    338,
                    693,
                    790,
                    503,
                    664,
                    822,
                    477
                ],
                "self.default_fill_value": [
                    619,
                    339,
                    612
                ],
                "self._apply_columns": [
                    616,
                    865,
                    859,
                    343
                ],
                "x.astype": [
                    343
                ],
                "result": [
                    352,
                    553,
                    554,
                    555,
                    349,
                    350,
                    351
                ],
                "deep": [
                    349
                ],
                "result._default_fill_value": [
                    350
                ],
                "result._default_kind": [
                    351
                ],
                "tot_nonsparse": [
                    368,
                    370
                ],
                "sum": [
                    368,
                    983
                ],
                "ser.sp_index.npoints": [
                    368
                ],
                "ser.sp_index": [
                    368
                ],
                "ser": [
                    368
                ],
                "_": [
                    368,
                    993,
                    1035,
                    982
                ],
                "tot": [
                    369,
                    370
                ],
                "float": [
                    370,
                    606
                ],
                "new_self": [
                    384,
                    375
                ],
                "fillna": [
                    375
                ],
                "value": [
                    388,
                    389,
                    422,
                    421,
                    426,
                    427,
                    429,
                    431,
                    432,
                    433,
                    434,
                    528,
                    437,
                    439,
                    376,
                    443
                ],
                "method": [
                    388,
                    709,
                    377,
                    731,
                    668
                ],
                "axis": [
                    832,
                    833,
                    835,
                    942,
                    497,
                    852,
                    853,
                    855,
                    921,
                    378,
                    475
                ],
                "inplace": [
                    391,
                    379,
                    383
                ],
                "limit": [
                    668,
                    706,
                    388,
                    731,
                    380
                ],
                "downcast": [
                    381
                ],
                "clean": [
                    422,
                    429,
                    433,
                    435,
                    439,
                    443,
                    446
                ],
                "as_sparse_array": [
                    422
                ],
                "value.reindex": [
                    433,
                    422
                ],
                "takeable": [
                    472,
                    528,
                    467
                ],
                "self._iget_item_cache": [
                    468
                ],
                "self._get_item_cache": [
                    470
                ],
                "series._get_value": [
                    472
                ],
                "new_index": [
                    544,
                    482,
                    566,
                    476,
                    541,
                    479
                ],
                "slobj": [
                    480,
                    476
                ],
                "new_columns": [
                    480,
                    477,
                    482,
                    549,
                    558,
                    567,
                    541
                ],
                "self.reindex": [
                    482,
                    780
                ],
                "key": [
                    498,
                    501
                ],
                "self.index.get_loc": [
                    501
                ],
                "_internal_get_values": [
                    753,
                    502
                ],
                "self.take": [
                    502
                ],
                "dense": [
                    528,
                    529
                ],
                "_set_value": [
                    528
                ],
                "self.to_dense": [
                    528
                ],
                "dense.to_sparse": [
                    529
                ],
                "level": [
                    576,
                    700,
                    654,
                    597,
                    600,
                    537,
                    540,
                    573
                ],
                "NotImplementedError": [
                    704,
                    707,
                    710,
                    647,
                    766,
                    598,
                    538,
                    732,
                    574
                ],
                "this": [
                    576,
                    579,
                    550,
                    551,
                    808,
                    554,
                    586,
                    780,
                    811,
                    813,
                    559,
                    560,
                    783,
                    787,
                    540,
                    541
                ],
                "other": [
                    641,
                    770,
                    771,
                    644,
                    774,
                    647,
                    775,
                    778,
                    781,
                    783,
                    787,
                    790,
                    540,
                    543,
                    550,
                    552,
                    809,
                    813,
                    559,
                    560,
                    562,
                    576,
                    580,
                    582,
                    600,
                    616,
                    621,
                    624,
                    637,
                    767
                ],
                "self.align": [
                    576,
                    600,
                    540
                ],
                "this.index": [
                    586,
                    541
                ],
                "this.columns": [
                    541
                ],
                "self.empty": [
                    543
                ],
                "other.empty": [
                    543
                ],
                "dleft": [
                    553,
                    551
                ],
                "dright": [
                    552,
                    553
                ],
                "dleft._binop": [
                    553
                ],
                "result.to_sparse": [
                    554
                ],
                "new_fill_value": [
                    568,
                    562
                ],
                "self._get_op_result_fill_value": [
                    562,
                    582
                ],
                "this.items": [
                    579
                ],
                "series.values": [
                    580,
                    678
                ],
                "other.values": [
                    580
                ],
                "left": [
                    610,
                    611,
                    600,
                    601,
                    605,
                    606
                ],
                "right": [
                    600,
                    601,
                    606
                ],
                "left.columns.equals": [
                    601
                ],
                "left.columns": [
                    601,
                    611,
                    605
                ],
                "right.index": [
                    601
                ],
                "left.index": [
                    610
                ],
                "own_default": [
                    641,
                    644,
                    619,
                    627,
                    629,
                    630,
                    632,
                    633
                ],
                "other_default": [
                    624,
                    627,
                    630,
                    631,
                    632
                ],
                "getattr": [
                    624
                ],
                "np.isnan": [
                    632,
                    994,
                    1036,
                    630
                ],
                "isna": [
                    641,
                    861
                ],
                "other.fill_value": [
                    641,
                    644
                ],
                "np.float64": [
                    644
                ],
                "item_from_zerodim": [
                    645
                ],
                "self.index.equals": [
                    657
                ],
                "self.copy": [
                    659
                ],
                "indexer": [
                    680,
                    668,
                    669,
                    670
                ],
                "self.index.get_indexer": [
                    668
                ],
                "ensure_platform_int": [
                    669
                ],
                "mask": [
                    675,
                    686,
                    670,
                    671
                ],
                "need_mask": [
                    681,
                    671
                ],
                "mask.any": [
                    671
                ],
                "new_series": [
                    928,
                    673,
                    930,
                    688,
                    691,
                    924
                ],
                "mask.all": [
                    675
                ],
                "new": [
                    680,
                    682,
                    685,
                    686,
                    688
                ],
                "values.take": [
                    680
                ],
                "new.to_dense": [
                    682
                ],
                "maybe_upcast": [
                    685
                ],
                "np.putmask": [
                    686
                ],
                "notna": [
                    867,
                    703
                ],
                "reindexers": [
                    739,
                    741,
                    742
                ],
                "self._get_axis_number": [
                    921,
                    739
                ],
                "a": [
                    739
                ],
                "val": [
                    739
                ],
                "reindexers.items": [
                    739
                ],
                "row_indexer": [
                    753,
                    741,
                    751
                ],
                "reindexers.get": [
                    741,
                    742
                ],
                "col_indexer": [
                    742
                ],
                "new_arrays": [
                    752,
                    747,
                    756,
                    758
                ],
                "algos.take_1d": [
                    752
                ],
                "algos": [
                    752
                ],
                "on": [
                    765
                ],
                "self._join_index": [
                    767
                ],
                "how": [
                    778,
                    767
                ],
                "lsuffix": [
                    792,
                    800,
                    783,
                    767
                ],
                "rsuffix": [
                    792,
                    783,
                    805,
                    767
                ],
                "other.name": [
                    771,
                    775
                ],
                "join_index": [
                    778,
                    780,
                    781
                ],
                "self.index.join": [
                    778
                ],
                "other.index": [
                    778
                ],
                "other.reindex": [
                    781
                ],
                "this._maybe_rename_join": [
                    783
                ],
                "concat": [
                    787
                ],
                "to_rename": [
                    804,
                    790,
                    791,
                    795,
                    799
                ],
                "self.columns.intersection": [
                    790
                ],
                "other.columns": [
                    790
                ],
                "format": [
                    800,
                    794,
                    805
                ],
                "self.rename": [
                    808
                ],
                "lrenamer": [
                    808
                ],
                "other.rename": [
                    809
                ],
                "rrenamer": [
                    809
                ],
                "nv.validate_transpose": [
                    819
                ],
                "nv": [
                    850,
                    819
                ],
                "args": [
                    850,
                    819
                ],
                "kwargs": [
                    850,
                    819
                ],
                "self.values.T": [
                    821
                ],
                "self.values": [
                    821
                ],
                "T": [
                    828
                ],
                "transpose": [
                    828
                ],
                "self._stat_axis_number": [
                    833,
                    853
                ],
                "self.apply": [
                    835,
                    964,
                    855
                ],
                "x.count": [
                    835
                ],
                "DataFrame.count.__doc__": [
                    830
                ],
                "DataFrame.count": [
                    830
                ],
                "nv.validate_cumsum": [
                    850
                ],
                "x.cumsum": [
                    855
                ],
                "x.isna": [
                    859
                ],
                "generic._shared_docs": [
                    857,
                    863
                ],
                "isnull": [
                    861
                ],
                "x.notna": [
                    865
                ],
                "notnull": [
                    867
                ],
                "np.ufunc": [
                    923
                ],
                "applied": [
                    928,
                    926,
                    927
                ],
                "applied.fill_value": [
                    927
                ],
                "v.fill_value": [
                    927
                ],
                "op": [
                    939,
                    947
                ],
                "frame_apply": [
                    939
                ],
                "reduce": [
                    943
                ],
                "broadcast": [
                    944
                ],
                "result_type": [
                    945
                ],
                "op.get_result": [
                    947
                ],
                "y": [
                    964
                ],
                "axes": [
                    973,
                    975
                ],
                "create_block_manager_from_arrays": [
                    975
                ],
                "sdf": [
                    975
                ],
                "lengths": [
                    986,
                    982,
                    983
                ],
                "s.sp_index.npoints": [
                    982
                ],
                "s.sp_index": [
                    982
                ],
                "s": [
                    982
                ],
                "frame.items": [
                    993,
                    982
                ],
                "frame": [
                    993,
                    986,
                    1004,
                    982
                ],
                "nobs": [
                    1009,
                    983
                ],
                "minor_codes": [
                    986,
                    1005
                ],
                "np.repeat": [
                    986
                ],
                "np.arange": [
                    986
                ],
                "frame.columns": [
                    986,
                    1004
                ],
                "inds_to_concat": [
                    1001,
                    988,
                    998
                ],
                "vals_to_concat": [
                    1002,
                    989,
                    999
                ],
                "series.fill_value": [
                    994,
                    1036
                ],
                "int_index": [
                    997,
                    998
                ],
                "series.sp_index.to_int_index": [
                    997
                ],
                "series.sp_index": [
                    997,
                    1040,
                    1041,
                    1043,
                    1048
                ],
                "inds_to_concat.append": [
                    998
                ],
                "int_index.indices": [
                    998
                ],
                "vals_to_concat.append": [
                    999
                ],
                "series.sp_values": [
                    999
                ],
                "major_codes": [
                    1001,
                    1005
                ],
                "np.concatenate": [
                    1001,
                    1002
                ],
                "stacked_values": [
                    1009,
                    1002
                ],
                "MultiIndex": [
                    1003
                ],
                "frame.index": [
                    1004
                ],
                "lp": [
                    1009,
                    1010
                ],
                "stacked_values.reshape": [
                    1009
                ],
                "lp.sort_index": [
                    1010
                ],
                "need_reindex": [
                    1033,
                    1042,
                    1045
                ],
                "series_dict.items": [
                    1035,
                    1047
                ],
                "series.sp_index.equals": [
                    1048,
                    1041
                ],
                "index.intersect": [
                    1043
                ],
                "output": [
                    1051,
                    1053,
                    1046,
                    1055
                ],
                "name": [
                    1051,
                    1047
                ],
                "series.sparse_reindex": [
                    1049
                ],
                "ops.add_flex_arithmetic_methods": [
                    1059
                ],
                "ops": [
                    1059,
                    1060
                ],
                "ops.add_special_arithmetic_methods": [
                    1060
                ]
            },
            "filtered_variables_in_file": {
                "_shared_doc_kwargs": [
                    857,
                    30,
                    863
                ],
                "depr_msg": [
                    81,
                    31
                ],
                "DataFrame": [
                    134,
                    40,
                    621,
                    1009,
                    314,
                    123,
                    830
                ],
                "_subtyp": [
                    66
                ],
                "is_scalar": [
                    78
                ],
                "default_fill_value": [
                    96,
                    103,
                    104,
                    109,
                    78,
                    113,
                    88,
                    89,
                    95
                ],
                "warnings.warn": [
                    81
                ],
                "warnings": [
                    280,
                    81,
                    281
                ],
                "data": [
                    129,
                    131,
                    133,
                    134,
                    145,
                    151,
                    159,
                    173,
                    175,
                    179,
                    191,
                    499,
                    83,
                    85,
                    87,
                    89,
                    91,
                    92,
                    247,
                    94,
                    96,
                    97,
                    98,
                    503,
                    101,
                    231,
                    232,
                    233,
                    234,
                    111,
                    240,
                    113,
                    241,
                    115,
                    116,
                    117,
                    118,
                    119,
                    246,
                    121,
                    498,
                    123,
                    124,
                    125,
                    502,
                    127
                ],
                "SparseDataFrame": [
                    1059,
                    1060,
                    165,
                    774,
                    83,
                    119
                ],
                "index": [
                    131,
                    1031,
                    136,
                    137,
                    264,
                    139,
                    1039,
                    528,
                    273,
                    657,
                    147,
                    1040,
                    1041,
                    1043,
                    151,
                    664,
                    1048,
                    1049,
                    668,
                    416,
                    178,
                    179,
                    692,
                    310,
                    312,
                    320,
                    194,
                    195,
                    203,
                    973,
                    207,
                    209,
                    84,
                    85,
                    215,
                    472,
                    93,
                    94,
                    225,
                    741,
                    232,
                    234,
                    1003,
                    240,
                    113,
                    242,
                    1009,
                    116,
                    118,
                    758,
                    121,
                    255
                ],
                "data.index": [
                    124,
                    85,
                    94,
                    127
                ],
                "columns": [
                    131,
                    268,
                    141,
                    142,
                    144,
                    273,
                    151,
                    171,
                    172,
                    173,
                    303,
                    176,
                    305,
                    320,
                    713,
                    717,
                    973,
                    975,
                    212,
                    86,
                    87,
                    223,
                    97,
                    98,
                    99,
                    225,
                    101,
                    742,
                    232,
                    233,
                    234,
                    744,
                    745,
                    748,
                    240,
                    113,
                    116,
                    118,
                    758,
                    121,
                    253
                ],
                "data.columns": [
                    124,
                    87
                ],
                "data.default_fill_value": [
                    89
                ],
                "default_kind": [
                    105,
                    106,
                    108,
                    90,
                    91
                ],
                "data.default_kind": [
                    91
                ],
                "SparseSeries": [
                    197,
                    421,
                    263,
                    167,
                    637,
                    434,
                    316,
                    92,
                    253
                ],
                "SparseArray": [
                    199,
                    426,
                    145,
                    182,
                    217,
                    92,
                    414
                ],
                "data.fill_value": [
                    96
                ],
                "data.name": [
                    98
                ],
                "np.nan": [
                    737,
                    642,
                    104,
                    203,
                    652,
                    624,
                    216
                ],
                "np": [
                    642,
                    644,
                    652,
                    1036,
                    923,
                    686,
                    203,
                    215,
                    216,
                    986,
                    737,
                    994,
                    104,
                    1001,
                    1002,
                    624,
                    117,
                    630,
                    632,
                    250
                ],
                "self._default_kind": [
                    322,
                    291,
                    418,
                    934,
                    423,
                    360,
                    108,
                    530,
                    148,
                    184,
                    825,
                    219,
                    351
                ],
                "self": [
                    528,
                    530,
                    540,
                    543,
                    544,
                    562,
                    564,
                    569,
                    576,
                    582,
                    584,
                    587,
                    589,
                    600,
                    608,
                    612,
                    613,
                    616,
                    619,
                    108,
                    109,
                    112,
                    116,
                    118,
                    120,
                    124,
                    126,
                    130,
                    657,
                    146,
                    659,
                    148,
                    149,
                    661,
                    663,
                    664,
                    665,
                    668,
                    161,
                    674,
                    690,
                    693,
                    694,
                    695,
                    184,
                    185,
                    713,
                    714,
                    716,
                    718,
                    719,
                    219,
                    220,
                    739,
                    745,
                    234,
                    749,
                    753,
                    756,
                    758,
                    759,
                    767,
                    775,
                    778,
                    780,
                    273,
                    277,
                    790,
                    287,
                    288,
                    289,
                    290,
                    291,
                    808,
                    811,
                    820,
                    821,
                    822,
                    823,
                    824,
                    825,
                    826,
                    320,
                    321,
                    322,
                    833,
                    835,
                    326,
                    333,
                    335,
                    337,
                    338,
                    339,
                    340,
                    853,
                    343,
                    855,
                    859,
                    350,
                    351,
                    865,
                    356,
                    360,
                    368,
                    369,
                    384,
                    389,
                    392,
                    919,
                    920,
                    921,
                    925,
                    417,
                    418,
                    929,
                    931,
                    932,
                    422,
                    423,
                    933,
                    934,
                    935,
                    427,
                    940,
                    433,
                    437,
                    443,
                    964,
                    468,
                    470,
                    476,
                    477,
                    479,
                    480,
                    482,
                    498,
                    501,
                    502,
                    503
                ],
                "self._default_fill_value": [
                    321,
                    290,
                    417,
                    356,
                    389,
                    933,
                    423,
                    775,
                    109,
                    718,
                    146,
                    530,
                    149,
                    694,
                    824,
                    185,
                    220,
                    350
                ],
                "is_scipy_sparse": [
                    111
                ],
                "mgr": [
                    161,
                    130,
                    112,
                    116,
                    118,
                    151,
                    120,
                    153,
                    124,
                    126
                ],
                "self._init_spmatrix": [
                    112
                ],
                "dtype": [
                    153,
                    131,
                    234,
                    113,
                    273,
                    116,
                    118,
                    343,
                    152,
                    121,
                    187,
                    124,
                    127
                ],
                "self._init_dict": [
                    234,
                    273,
                    116,
                    124,
                    126
                ],
                "np.ndarray": [
                    117
                ],
                "self._init_matrix": [
                    118
                ],
                "self._init_mgr": [
                    120,
                    130
                ],
                "data._data": [
                    121
                ],
                "copy": [
                    121,
                    658,
                    131,
                    349
                ],
                "Series": [
                    192,
                    770,
                    432,
                    246,
                    503,
                    125
                ],
                "data.to_frame": [
                    127
                ],
                "BlockManager": [
                    129
                ],
                "Index": [
                    137,
                    300,
                    142,
                    176,
                    307
                ],
                "ensure_index": [
                    139,
                    172,
                    973
                ],
                "c": [
                    144,
                    145,
                    975,
                    223
                ],
                "to_manager": [
                    320,
                    225,
                    151
                ],
                "mgr.astype": [
                    153
                ],
                "msg": [
                    208,
                    209,
                    155,
                    159
                ],
                "msg.format": [
                    209,
                    159
                ],
                "generic.NDFrame.__init__": [
                    161
                ],
                "generic.NDFrame": [
                    161
                ],
                "generic": [
                    857,
                    161,
                    863
                ],
                "_constructor_sliced": [
                    167
                ],
                "k": [
                    928,
                    713,
                    173,
                    210,
                    925,
                    191
                ],
                "v": [
                    925,
                    926,
                    927,
                    173,
                    191,
                    192,
                    194,
                    195,
                    197,
                    198,
                    199,
                    200,
                    713,
                    202,
                    203,
                    205,
                    207,
                    209,
                    210
                ],
                "data.items": [
                    173,
                    191
                ],
                "keys": [
                    176,
                    175
                ],
                "com.dict_keys_to_ordered_list": [
                    175
                ],
                "com": [
                    175
                ],
                "extract_index": [
                    179
                ],
                "data.values": [
                    179
                ],
                "x": [
                    800,
                    801,
                    865,
                    835,
                    804,
                    805,
                    806,
                    964,
                    616,
                    855,
                    799,
                    343,
                    183,
                    859,
                    415
                ],
                "sdict": [
                    225,
                    261,
                    713,
                    715,
                    269,
                    273,
                    210,
                    212,
                    245,
                    253,
                    190,
                    223
                ],
                "v.index.equals": [
                    194
                ],
                "v.index": [
                    194
                ],
                "v.reindex": [
                    195
                ],
                "sp_maker": [
                    198,
                    205,
                    435,
                    439,
                    443
                ],
                "v.values": [
                    198
                ],
                "v.copy": [
                    200
                ],
                "v.get": [
                    203
                ],
                "i": [
                    233,
                    203,
                    501,
                    502
                ],
                "columns.difference": [
                    212
                ],
                "nan_arr": [
                    215,
                    216,
                    217,
                    218,
                    223
                ],
                "np.empty": [
                    215
                ],
                "nan_arr.fill": [
                    216
                ],
                "sdict.update": [
                    261,
                    223
                ],
                "prep_ndarray": [
                    231
                ],
                "SparseFrameAccessor._prep_index": [
                    232,
                    240
                ],
                "SparseFrameAccessor": [
                    324,
                    326,
                    232,
                    240,
                    275,
                    277
                ],
                "idx": [
                    233,
                    298,
                    307,
                    310,
                    312
                ],
                "data.tocoo": [
                    241
                ],
                "N": [
                    257,
                    242,
                    266
                ],
                "values": [
                    680,
                    678,
                    246,
                    247
                ],
                "data.data": [
                    246
                ],
                "data.row": [
                    246
                ],
                "col": [
                    528,
                    674,
                    549,
                    550,
                    551,
                    552,
                    554,
                    555,
                    558,
                    559,
                    560,
                    688,
                    315,
                    316,
                    579,
                    580,
                    333,
                    468,
                    470,
                    605,
                    606,
                    748,
                    749,
                    752,
                    753,
                    756,
                    247,
                    253
                ],
                "rowvals": [
                    249,
                    250,
                    254,
                    247
                ],
                "values.groupby": [
                    247
                ],
                "data.col": [
                    247
                ],
                "rowvals.sort_index": [
                    249
                ],
                "rows": [
                    250,
                    251
                ],
                "rowvals.index.values.astype": [
                    250
                ],
                "rowvals.index.values": [
                    250
                ],
                "rowvals.index": [
                    250
                ],
                "np.int32": [
                    250
                ],
                "blocs": [
                    257,
                    251
                ],
                "blens": [
                    257,
                    251
                ],
                "get_blocks": [
                    251
                ],
                "rowvals.values": [
                    254
                ],
                "fill_value": [
                    256,
                    642,
                    644,
                    645,
                    265,
                    649,
                    547,
                    553,
                    554,
                    685,
                    686,
                    703,
                    582,
                    588,
                    736,
                    737,
                    753,
                    629,
                    631,
                    633,
                    635
                ],
                "BlockIndex": [
                    257,
                    266
                ],
                "column": [
                    268,
                    269,
                    263
                ],
                "to_coo": [
                    277
                ],
                "Appender": [
                    324,
                    275,
                    857,
                    830,
                    863
                ],
                "SparseFrameAccessor.to_coo.__doc__": [
                    275
                ],
                "SparseFrameAccessor.to_coo": [
                    275
                ],
                "warnings.catch_warnings": [
                    280
                ],
                "warnings.filterwarnings": [
                    281
                ],
                "__repr__": [
                    282
                ],
                "self._typ": [
                    287
                ],
                "self._subtyp": [
                    288
                ],
                "self._data": [
                    320,
                    289
                ],
                "series": [
                    1035,
                    1036,
                    1040,
                    1041,
                    1043,
                    1047,
                    1048,
                    1049,
                    1051,
                    674,
                    678,
                    298,
                    315,
                    579,
                    580,
                    333,
                    468,
                    470,
                    472,
                    993,
                    994,
                    997,
                    999
                ],
                "cols": [
                    305,
                    298,
                    300,
                    303
                ],
                "fv": [
                    321,
                    298,
                    317
                ],
                "kind": [
                    298,
                    322
                ],
                "state": [
                    298
                ],
                "_unpickle_array": [
                    310,
                    303
                ],
                "series_dict": [
                    320,
                    1035,
                    1047,
                    314,
                    316,
                    1053
                ],
                "sp_index": [
                    315,
                    317
                ],
                "sp_values": [
                    315,
                    317
                ],
                "series.items": [
                    315
                ],
                "to_dense": [
                    552,
                    326,
                    551
                ],
                "SparseFrameAccessor.to_dense.__doc__": [
                    324
                ],
                "SparseFrameAccessor.to_dense": [
                    324
                ],
                "new_data": [
                    609,
                    546,
                    578,
                    580,
                    585,
                    555,
                    333,
                    336,
                    560,
                    565,
                    603,
                    606
                ],
                "func": [
                    580,
                    644,
                    582,
                    964,
                    616,
                    553,
                    333,
                    941,
                    560,
                    562,
                    926,
                    923,
                    606,
                    927
                ],
                "self.items": [
                    674,
                    713,
                    333,
                    368,
                    925
                ],
                "__finalize__": [
                    544,
                    608,
                    929,
                    584,
                    714,
                    335,
                    690,
                    564,
                    820,
                    758,
                    664
                ],
                "self._constructor": [
                    544,
                    608,
                    929,
                    584,
                    714,
                    335,
                    690,
                    564,
                    820,
                    758,
                    664
                ],
                "self.index": [
                    668,
                    931,
                    422,
                    778,
                    427,
                    716,
                    823,
                    433,
                    337,
                    369,
                    657,
                    437,
                    501,
                    663,
                    443,
                    476,
                    479
                ],
                "self.columns": [
                    480,
                    932,
                    745,
                    587,
                    919,
                    369,
                    338,
                    693,
                    790,
                    503,
                    664,
                    822,
                    477
                ],
                "self.default_fill_value": [
                    619,
                    339,
                    612
                ],
                "self._apply_columns": [
                    616,
                    865,
                    859,
                    343
                ],
                "x.astype": [
                    343
                ],
                "result": [
                    352,
                    553,
                    554,
                    555,
                    349,
                    350,
                    351
                ],
                "deep": [
                    349
                ],
                "result._default_fill_value": [
                    350
                ],
                "result._default_kind": [
                    351
                ],
                "tot_nonsparse": [
                    368,
                    370
                ],
                "ser.sp_index.npoints": [
                    368
                ],
                "ser.sp_index": [
                    368
                ],
                "ser": [
                    368
                ],
                "_": [
                    368,
                    993,
                    1035,
                    982
                ],
                "tot": [
                    369,
                    370
                ],
                "new_self": [
                    384,
                    375
                ],
                "fillna": [
                    375
                ],
                "value": [
                    388,
                    389,
                    422,
                    421,
                    426,
                    427,
                    429,
                    431,
                    432,
                    433,
                    434,
                    528,
                    437,
                    439,
                    376,
                    443
                ],
                "method": [
                    388,
                    709,
                    377,
                    731,
                    668
                ],
                "axis": [
                    832,
                    833,
                    835,
                    942,
                    497,
                    852,
                    853,
                    855,
                    921,
                    378,
                    475
                ],
                "inplace": [
                    391,
                    379,
                    383
                ],
                "limit": [
                    668,
                    706,
                    388,
                    731,
                    380
                ],
                "downcast": [
                    381
                ],
                "clean": [
                    422,
                    429,
                    433,
                    435,
                    439,
                    443,
                    446
                ],
                "as_sparse_array": [
                    422
                ],
                "value.reindex": [
                    433,
                    422
                ],
                "takeable": [
                    472,
                    528,
                    467
                ],
                "self._iget_item_cache": [
                    468
                ],
                "self._get_item_cache": [
                    470
                ],
                "series._get_value": [
                    472
                ],
                "new_index": [
                    544,
                    482,
                    566,
                    476,
                    541,
                    479
                ],
                "slobj": [
                    480,
                    476
                ],
                "new_columns": [
                    480,
                    477,
                    482,
                    549,
                    558,
                    567,
                    541
                ],
                "self.reindex": [
                    482,
                    780
                ],
                "key": [
                    498,
                    501
                ],
                "self.index.get_loc": [
                    501
                ],
                "_internal_get_values": [
                    753,
                    502
                ],
                "self.take": [
                    502
                ],
                "dense": [
                    528,
                    529
                ],
                "_set_value": [
                    528
                ],
                "self.to_dense": [
                    528
                ],
                "dense.to_sparse": [
                    529
                ],
                "level": [
                    576,
                    700,
                    654,
                    597,
                    600,
                    537,
                    540,
                    573
                ],
                "this": [
                    576,
                    579,
                    550,
                    551,
                    808,
                    554,
                    586,
                    780,
                    811,
                    813,
                    559,
                    560,
                    783,
                    787,
                    540,
                    541
                ],
                "other": [
                    641,
                    770,
                    771,
                    644,
                    774,
                    647,
                    775,
                    778,
                    781,
                    783,
                    787,
                    790,
                    540,
                    543,
                    550,
                    552,
                    809,
                    813,
                    559,
                    560,
                    562,
                    576,
                    580,
                    582,
                    600,
                    616,
                    621,
                    624,
                    637,
                    767
                ],
                "self.align": [
                    576,
                    600,
                    540
                ],
                "this.index": [
                    586,
                    541
                ],
                "this.columns": [
                    541
                ],
                "self.empty": [
                    543
                ],
                "other.empty": [
                    543
                ],
                "dleft": [
                    553,
                    551
                ],
                "dright": [
                    552,
                    553
                ],
                "dleft._binop": [
                    553
                ],
                "result.to_sparse": [
                    554
                ],
                "new_fill_value": [
                    568,
                    562
                ],
                "self._get_op_result_fill_value": [
                    562,
                    582
                ],
                "this.items": [
                    579
                ],
                "series.values": [
                    580,
                    678
                ],
                "other.values": [
                    580
                ],
                "left": [
                    610,
                    611,
                    600,
                    601,
                    605,
                    606
                ],
                "right": [
                    600,
                    601,
                    606
                ],
                "left.columns.equals": [
                    601
                ],
                "left.columns": [
                    601,
                    611,
                    605
                ],
                "right.index": [
                    601
                ],
                "left.index": [
                    610
                ],
                "own_default": [
                    641,
                    644,
                    619,
                    627,
                    629,
                    630,
                    632,
                    633
                ],
                "other_default": [
                    624,
                    627,
                    630,
                    631,
                    632
                ],
                "np.isnan": [
                    632,
                    994,
                    1036,
                    630
                ],
                "isna": [
                    641,
                    861
                ],
                "other.fill_value": [
                    641,
                    644
                ],
                "np.float64": [
                    644
                ],
                "item_from_zerodim": [
                    645
                ],
                "self.index.equals": [
                    657
                ],
                "self.copy": [
                    659
                ],
                "indexer": [
                    680,
                    668,
                    669,
                    670
                ],
                "self.index.get_indexer": [
                    668
                ],
                "ensure_platform_int": [
                    669
                ],
                "mask": [
                    675,
                    686,
                    670,
                    671
                ],
                "need_mask": [
                    681,
                    671
                ],
                "mask.any": [
                    671
                ],
                "new_series": [
                    928,
                    673,
                    930,
                    688,
                    691,
                    924
                ],
                "mask.all": [
                    675
                ],
                "new": [
                    680,
                    682,
                    685,
                    686,
                    688
                ],
                "values.take": [
                    680
                ],
                "new.to_dense": [
                    682
                ],
                "maybe_upcast": [
                    685
                ],
                "np.putmask": [
                    686
                ],
                "notna": [
                    867,
                    703
                ],
                "reindexers": [
                    739,
                    741,
                    742
                ],
                "self._get_axis_number": [
                    921,
                    739
                ],
                "a": [
                    739
                ],
                "val": [
                    739
                ],
                "reindexers.items": [
                    739
                ],
                "row_indexer": [
                    753,
                    741,
                    751
                ],
                "reindexers.get": [
                    741,
                    742
                ],
                "col_indexer": [
                    742
                ],
                "new_arrays": [
                    752,
                    747,
                    756,
                    758
                ],
                "algos.take_1d": [
                    752
                ],
                "algos": [
                    752
                ],
                "on": [
                    765
                ],
                "self._join_index": [
                    767
                ],
                "how": [
                    778,
                    767
                ],
                "lsuffix": [
                    792,
                    800,
                    783,
                    767
                ],
                "rsuffix": [
                    792,
                    783,
                    805,
                    767
                ],
                "other.name": [
                    771,
                    775
                ],
                "join_index": [
                    778,
                    780,
                    781
                ],
                "self.index.join": [
                    778
                ],
                "other.index": [
                    778
                ],
                "other.reindex": [
                    781
                ],
                "this._maybe_rename_join": [
                    783
                ],
                "concat": [
                    787
                ],
                "to_rename": [
                    804,
                    790,
                    791,
                    795,
                    799
                ],
                "self.columns.intersection": [
                    790
                ],
                "other.columns": [
                    790
                ],
                "self.rename": [
                    808
                ],
                "lrenamer": [
                    808
                ],
                "other.rename": [
                    809
                ],
                "rrenamer": [
                    809
                ],
                "nv.validate_transpose": [
                    819
                ],
                "nv": [
                    850,
                    819
                ],
                "args": [
                    850,
                    819
                ],
                "kwargs": [
                    850,
                    819
                ],
                "self.values.T": [
                    821
                ],
                "self.values": [
                    821
                ],
                "T": [
                    828
                ],
                "transpose": [
                    828
                ],
                "self._stat_axis_number": [
                    833,
                    853
                ],
                "self.apply": [
                    835,
                    964,
                    855
                ],
                "x.count": [
                    835
                ],
                "DataFrame.count.__doc__": [
                    830
                ],
                "DataFrame.count": [
                    830
                ],
                "nv.validate_cumsum": [
                    850
                ],
                "x.cumsum": [
                    855
                ],
                "x.isna": [
                    859
                ],
                "generic._shared_docs": [
                    857,
                    863
                ],
                "isnull": [
                    861
                ],
                "x.notna": [
                    865
                ],
                "notnull": [
                    867
                ],
                "np.ufunc": [
                    923
                ],
                "applied": [
                    928,
                    926,
                    927
                ],
                "applied.fill_value": [
                    927
                ],
                "v.fill_value": [
                    927
                ],
                "op": [
                    939,
                    947
                ],
                "frame_apply": [
                    939
                ],
                "reduce": [
                    943
                ],
                "broadcast": [
                    944
                ],
                "result_type": [
                    945
                ],
                "op.get_result": [
                    947
                ],
                "y": [
                    964
                ],
                "axes": [
                    973,
                    975
                ],
                "create_block_manager_from_arrays": [
                    975
                ],
                "sdf": [
                    975
                ],
                "lengths": [
                    986,
                    982,
                    983
                ],
                "s.sp_index.npoints": [
                    982
                ],
                "s.sp_index": [
                    982
                ],
                "s": [
                    982
                ],
                "frame.items": [
                    993,
                    982
                ],
                "frame": [
                    993,
                    986,
                    1004,
                    982
                ],
                "nobs": [
                    1009,
                    983
                ],
                "minor_codes": [
                    986,
                    1005
                ],
                "np.repeat": [
                    986
                ],
                "np.arange": [
                    986
                ],
                "frame.columns": [
                    986,
                    1004
                ],
                "inds_to_concat": [
                    1001,
                    988,
                    998
                ],
                "vals_to_concat": [
                    1002,
                    989,
                    999
                ],
                "series.fill_value": [
                    994,
                    1036
                ],
                "int_index": [
                    997,
                    998
                ],
                "series.sp_index.to_int_index": [
                    997
                ],
                "series.sp_index": [
                    997,
                    1040,
                    1041,
                    1043,
                    1048
                ],
                "inds_to_concat.append": [
                    998
                ],
                "int_index.indices": [
                    998
                ],
                "vals_to_concat.append": [
                    999
                ],
                "series.sp_values": [
                    999
                ],
                "major_codes": [
                    1001,
                    1005
                ],
                "np.concatenate": [
                    1001,
                    1002
                ],
                "stacked_values": [
                    1009,
                    1002
                ],
                "MultiIndex": [
                    1003
                ],
                "frame.index": [
                    1004
                ],
                "lp": [
                    1009,
                    1010
                ],
                "stacked_values.reshape": [
                    1009
                ],
                "lp.sort_index": [
                    1010
                ],
                "need_reindex": [
                    1033,
                    1042,
                    1045
                ],
                "series_dict.items": [
                    1035,
                    1047
                ],
                "series.sp_index.equals": [
                    1048,
                    1041
                ],
                "index.intersect": [
                    1043
                ],
                "output": [
                    1051,
                    1053,
                    1046,
                    1055
                ],
                "name": [
                    1051,
                    1047
                ],
                "series.sparse_reindex": [
                    1049
                ],
                "ops.add_flex_arithmetic_methods": [
                    1059
                ],
                "ops": [
                    1059,
                    1060
                ],
                "ops.add_special_arithmetic_methods": [
                    1060
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_156/pandas/tests/sparse/frame/test_frame.py",
                "test_function": "test_add_series_retains_dtype",
                "test_function_code": "    def test_add_series_retains_dtype(self):\n        # SparseDataFrame._combine_match_columns used to incorrectly cast\n        #  to float\n        d = {0: [2j, 3j], 1: [0, 1]}\n        sdf = SparseDataFrame(data=d, default_fill_value=1)\n        result = sdf + sdf[0]\n\n        df = sdf.to_dense()\n        expected = df + df[0]\n        tm.assert_frame_equal(result.to_dense(), expected)\n\n        # Make it explicit to be on the safe side\n        edata = {0: [4j, 5j], 1: [3j, 1 + 3j]}\n        expected = DataFrame(edata)\n        tm.assert_frame_equal(result.to_dense(), expected)",
                "test_error": "AssertionError: DataFrame.iloc[:, 0] are different  DataFrame.iloc[:, 0] values are different (100.0 %) [left]:  [2j, 3j] [right]: [4j, 5j]",
                "full_test_error": "self = <pandas.tests.sparse.frame.test_frame.TestSparseDataFrameArithmetic object at 0x114475730>\n\n    def test_add_series_retains_dtype(self):\n        # SparseDataFrame._combine_match_columns used to incorrectly cast\n        #  to float\n        d = {0: [2j, 3j], 1: [0, 1]}\n        sdf = SparseDataFrame(data=d, default_fill_value=1)\n        result = sdf + sdf[0]\n    \n        df = sdf.to_dense()\n        expected = df + df[0]\n>       tm.assert_frame_equal(result.to_dense(), expected)\n\npandas/tests/sparse/frame/test_frame.py:1499: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/_libs/testing.pyx:65: in pandas._libs.testing.assert_almost_equal\n    cpdef assert_almost_equal(a, b,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>   raise_assert_detail(obj, msg, lobj, robj)\nE   AssertionError: DataFrame.iloc[:, 0] are different\nE   \nE   DataFrame.iloc[:, 0] values are different (100.0 %)\nE   [left]:  [2j, 3j]\nE   [right]: [4j, 5j]\n\npandas/_libs/testing.pyx:178: AssertionError",
                "traceback": "pandas/_libs/testing.pyx:65: in pandas._libs.testing.assert_almost_equal\n    cpdef assert_almost_equal(a, b,",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>   raise_assert_detail(obj, msg, lobj, robj)\nE   AssertionError: DataFrame.iloc[:, 0] are different\nE   \nE   DataFrame.iloc[:, 0] values are different (100.0 %)\nE   [left]:  [2j, 3j]\nE   [right]: [4j, 5j]\n\npandas/_libs/testing.pyx:178: AssertionError",
                "test_function_decorators": []
            }
        ]
    }
}