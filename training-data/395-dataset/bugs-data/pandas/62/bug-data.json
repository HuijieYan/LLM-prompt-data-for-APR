{
    "pandas:62": {
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/core/internals/blocks.py": {
            "buggy_functions": [
                {
                    "function_name": "setitem",
                    "function_code": "def setitem(self, indexer, value):\n    \"\"\"\n    Set the value inplace, returning a a maybe different typed block.\n\n    Parameters\n    ----------\n    indexer : tuple, list-like, array-like, slice\n        The subset of self.values to set\n    value : object\n        The value being set\n\n    Returns\n    -------\n    Block\n\n    Notes\n    -----\n    `indexer` is a direct slice/positional indexer. `value` must\n    be a compatible shape.\n    \"\"\"\n    transpose = self.ndim == 2\n\n    # coerce None values, if appropriate\n    if value is None:\n        if self.is_numeric:\n            value = np.nan\n\n    # coerce if block dtype can store value\n    values = self.values\n    if self._can_hold_element(value):\n        # We only get here for non-Extension Blocks, so _try_coerce_args\n        #  is only relevant for DatetimeBlock and TimedeltaBlock\n        if lib.is_scalar(value):\n            value = convert_scalar_for_putitemlike(value, values.dtype)\n\n    else:\n        # current dtype cannot store value, coerce to common dtype\n        find_dtype = False\n\n        if hasattr(value, \"dtype\"):\n            dtype = value.dtype\n            find_dtype = True\n\n        elif lib.is_scalar(value) and not isna(value):\n            dtype, _ = infer_dtype_from_scalar(value, pandas_dtype=True)\n            find_dtype = True\n\n        if find_dtype:\n            dtype = find_common_type([values.dtype, dtype])\n            if not is_dtype_equal(self.dtype, dtype):\n                b = self.astype(dtype)\n                return b.setitem(indexer, value)\n\n    # value must be storeable at this moment\n    if is_extension_array_dtype(getattr(value, \"dtype\", None)):\n        # We need to be careful not to allow through strings that\n        #  can be parsed to EADtypes\n        arr_value = value\n    else:\n        arr_value = np.array(value)\n\n    # cast the values to a type that can hold nan (if necessary)\n    if not self._can_hold_element(value):\n        dtype, _ = maybe_promote(arr_value.dtype)\n        values = values.astype(dtype)\n\n    if transpose:\n        values = values.T\n\n    # length checking\n    check_setitem_lengths(indexer, value, values)\n    exact_match = (\n        len(arr_value.shape)\n        and arr_value.shape[0] == values.shape[0]\n        and arr_value.size == values.size\n    )\n    if is_empty_indexer(indexer, arr_value):\n        # GH#8669 empty indexers\n        pass\n\n    elif is_scalar_indexer(indexer, arr_value):\n        # setting a single element for each dim and with a rhs that could\n        #  be e.g. a list; see GH#6043\n        values[indexer] = value\n\n    elif (\n        exact_match\n        and is_categorical_dtype(arr_value.dtype)\n        and not is_categorical_dtype(values)\n    ):\n        # GH25495 - If the current dtype is not categorical,\n        # we need to create a new categorical block\n        values[indexer] = value\n        return self.make_block(Categorical(self.values, dtype=arr_value.dtype))\n\n    # if we are an exact match (ex-broadcasting),\n    # then use the resultant dtype\n    elif exact_match:\n        values[indexer] = value\n\n        try:\n            values = values.astype(arr_value.dtype)\n        except ValueError:\n            pass\n\n    # set\n    else:\n        values[indexer] = value\n\n    if transpose:\n        values = values.T\n    block = self.make_block(values)\n    return block\n",
                    "decorators": [],
                    "docstring": "Set the value inplace, returning a a maybe different typed block.\n\nParameters\n----------\nindexer : tuple, list-like, array-like, slice\n    The subset of self.values to set\nvalue : object\n    The value being set\n\nReturns\n-------\nBlock\n\nNotes\n-----\n`indexer` is a direct slice/positional indexer. `value` must\nbe a compatible shape.",
                    "start_line": 811,
                    "variables": {
                        "transpose": [
                            920,
                            877,
                            831
                        ],
                        "self.ndim": [
                            831
                        ],
                        "self": [
                            835,
                            839,
                            840,
                            873,
                            904,
                            922,
                            860,
                            861,
                            831
                        ],
                        "value": [
                            903,
                            909,
                            918,
                            834,
                            836,
                            840,
                            843,
                            844,
                            850,
                            851,
                            854,
                            855,
                            862,
                            865,
                            868,
                            870,
                            873,
                            881,
                            894
                        ],
                        "self.is_numeric": [
                            835
                        ],
                        "np.nan": [
                            836
                        ],
                        "np": [
                            836,
                            870
                        ],
                        "values": [
                            899,
                            839,
                            903,
                            875,
                            844,
                            909,
                            878,
                            912,
                            881,
                            884,
                            885,
                            918,
                            921,
                            922,
                            859,
                            894
                        ],
                        "self.values": [
                            904,
                            839
                        ],
                        "self._can_hold_element": [
                            840,
                            873
                        ],
                        "lib.is_scalar": [
                            843,
                            854
                        ],
                        "lib": [
                            843,
                            854
                        ],
                        "convert_scalar_for_putitemlike": [
                            844
                        ],
                        "values.dtype": [
                            859,
                            844
                        ],
                        "find_dtype": [
                            848,
                            858,
                            856,
                            852
                        ],
                        "hasattr": [
                            850
                        ],
                        "dtype": [
                            874,
                            875,
                            851,
                            855,
                            859,
                            860,
                            861
                        ],
                        "value.dtype": [
                            851
                        ],
                        "isna": [
                            854
                        ],
                        "_": [
                            874,
                            855
                        ],
                        "infer_dtype_from_scalar": [
                            855
                        ],
                        "find_common_type": [
                            859
                        ],
                        "is_dtype_equal": [
                            860
                        ],
                        "self.dtype": [
                            860
                        ],
                        "b": [
                            861,
                            862
                        ],
                        "self.astype": [
                            861
                        ],
                        "b.setitem": [
                            862
                        ],
                        "indexer": [
                            903,
                            909,
                            881,
                            862,
                            918,
                            887,
                            891,
                            894
                        ],
                        "is_extension_array_dtype": [
                            865
                        ],
                        "getattr": [
                            865
                        ],
                        "arr_value": [
                            898,
                            868,
                            870,
                            904,
                            874,
                            912,
                            883,
                            884,
                            885,
                            887,
                            891
                        ],
                        "np.array": [
                            870
                        ],
                        "maybe_promote": [
                            874
                        ],
                        "arr_value.dtype": [
                            904,
                            874,
                            912,
                            898
                        ],
                        "values.astype": [
                            912,
                            875
                        ],
                        "values.T": [
                            921,
                            878
                        ],
                        "check_setitem_lengths": [
                            881
                        ],
                        "exact_match": [
                            897,
                            882,
                            908
                        ],
                        "len": [
                            883
                        ],
                        "arr_value.shape": [
                            883,
                            884
                        ],
                        "values.shape": [
                            884
                        ],
                        "arr_value.size": [
                            885
                        ],
                        "values.size": [
                            885
                        ],
                        "is_empty_indexer": [
                            887
                        ],
                        "is_scalar_indexer": [
                            891
                        ],
                        "is_categorical_dtype": [
                            898,
                            899
                        ],
                        "self.make_block": [
                            904,
                            922
                        ],
                        "Categorical": [
                            904
                        ],
                        "ValueError": [
                            913
                        ],
                        "block": [
                            922,
                            923
                        ]
                    },
                    "filtered_variables": {
                        "transpose": [
                            920,
                            877,
                            831
                        ],
                        "self.ndim": [
                            831
                        ],
                        "self": [
                            835,
                            839,
                            840,
                            873,
                            904,
                            922,
                            860,
                            861,
                            831
                        ],
                        "value": [
                            903,
                            909,
                            918,
                            834,
                            836,
                            840,
                            843,
                            844,
                            850,
                            851,
                            854,
                            855,
                            862,
                            865,
                            868,
                            870,
                            873,
                            881,
                            894
                        ],
                        "self.is_numeric": [
                            835
                        ],
                        "np.nan": [
                            836
                        ],
                        "np": [
                            836,
                            870
                        ],
                        "values": [
                            899,
                            839,
                            903,
                            875,
                            844,
                            909,
                            878,
                            912,
                            881,
                            884,
                            885,
                            918,
                            921,
                            922,
                            859,
                            894
                        ],
                        "self.values": [
                            904,
                            839
                        ],
                        "self._can_hold_element": [
                            840,
                            873
                        ],
                        "lib.is_scalar": [
                            843,
                            854
                        ],
                        "lib": [
                            843,
                            854
                        ],
                        "convert_scalar_for_putitemlike": [
                            844
                        ],
                        "values.dtype": [
                            859,
                            844
                        ],
                        "find_dtype": [
                            848,
                            858,
                            856,
                            852
                        ],
                        "dtype": [
                            874,
                            875,
                            851,
                            855,
                            859,
                            860,
                            861
                        ],
                        "value.dtype": [
                            851
                        ],
                        "isna": [
                            854
                        ],
                        "_": [
                            874,
                            855
                        ],
                        "infer_dtype_from_scalar": [
                            855
                        ],
                        "find_common_type": [
                            859
                        ],
                        "is_dtype_equal": [
                            860
                        ],
                        "self.dtype": [
                            860
                        ],
                        "b": [
                            861,
                            862
                        ],
                        "self.astype": [
                            861
                        ],
                        "b.setitem": [
                            862
                        ],
                        "indexer": [
                            903,
                            909,
                            881,
                            862,
                            918,
                            887,
                            891,
                            894
                        ],
                        "is_extension_array_dtype": [
                            865
                        ],
                        "arr_value": [
                            898,
                            868,
                            870,
                            904,
                            874,
                            912,
                            883,
                            884,
                            885,
                            887,
                            891
                        ],
                        "np.array": [
                            870
                        ],
                        "maybe_promote": [
                            874
                        ],
                        "arr_value.dtype": [
                            904,
                            874,
                            912,
                            898
                        ],
                        "values.astype": [
                            912,
                            875
                        ],
                        "values.T": [
                            921,
                            878
                        ],
                        "check_setitem_lengths": [
                            881
                        ],
                        "exact_match": [
                            897,
                            882,
                            908
                        ],
                        "arr_value.shape": [
                            883,
                            884
                        ],
                        "values.shape": [
                            884
                        ],
                        "arr_value.size": [
                            885
                        ],
                        "values.size": [
                            885
                        ],
                        "is_empty_indexer": [
                            887
                        ],
                        "is_scalar_indexer": [
                            891
                        ],
                        "is_categorical_dtype": [
                            898,
                            899
                        ],
                        "self.make_block": [
                            904,
                            922
                        ],
                        "Categorical": [
                            904
                        ],
                        "block": [
                            922,
                            923
                        ]
                    },
                    "diff_line_number": 832,
                    "class_data": {
                        "signature": "class Block(PandasObject)",
                        "docstring": "Canonical n-dimensional unit of homogeneous dtype contained in a pandas\ndata structure\n\nIndex-ignorant; let the container take care of that",
                        "constructor_docstring": null,
                        "functions": [
                            "def __init__(self, values, placement, ndim=None):\n    self.ndim = self._check_ndim(values, ndim)\n    self.mgr_locs = placement\n    self.values = values\n    if self._validate_ndim and self.ndim and (len(self.mgr_locs) != len(self.values)):\n        raise ValueError(f'Wrong number of items passed {len(self.values)}, placement implies {len(self.mgr_locs)}')",
                            "def _check_ndim(self, values, ndim):\n    \"\"\"\n    ndim inference and validation.\n\n    Infers ndim from 'values' if not provided to __init__.\n    Validates that values.ndim and ndim are consistent if and only if\n    the class variable '_validate_ndim' is True.\n\n    Parameters\n    ----------\n    values : array-like\n    ndim : int or None\n\n    Returns\n    -------\n    ndim : int\n\n    Raises\n    ------\n    ValueError : the number of dimensions do not match\n    \"\"\"\n    if ndim is None:\n        ndim = values.ndim\n    if self._validate_ndim and values.ndim != ndim:\n        raise ValueError(f'Wrong number of dimensions. values.ndim != ndim [{values.ndim} != {ndim}]')\n    return ndim",
                            "@property\ndef _holder(self):\n    \"\"\"The array-like that can hold the underlying values.\n\n    None for 'Block', overridden by subclasses that don't\n    use an ndarray.\n    \"\"\"\n    return None",
                            "@property\ndef _consolidate_key(self):\n    return (self._can_consolidate, self.dtype.name)",
                            "@property\ndef _is_single_block(self):\n    return self.ndim == 1",
                            "@property\ndef is_view(self):\n    \"\"\" return a boolean if I am possibly a view \"\"\"\n    return self.values.base is not None",
                            "@property\ndef is_datelike(self):\n    \"\"\" return True if I am a non-datelike \"\"\"\n    return self.is_datetime or self.is_timedelta",
                            "def is_categorical_astype(self, dtype):\n    \"\"\"\n    validate that we have a astypeable to categorical,\n    returns a boolean if we are a categorical\n    \"\"\"\n    if dtype is Categorical or dtype is CategoricalDtype:\n        raise TypeError(f'invalid type {dtype} for astype')\n    elif is_categorical_dtype(dtype):\n        return True\n    return False",
                            "def external_values(self):\n    \"\"\"\n    The array that Series.values returns (public attribute).\n\n    This has some historical constraints, and is overridden in block\n    subclasses to return the correct array (e.g. period returns\n    object ndarray and datetimetz a datetime64[ns] ndarray instead of\n    proper extension array).\n    \"\"\"\n    return self.values",
                            "def internal_values(self):\n    \"\"\"\n    The array that Series._values returns (internal values).\n    \"\"\"\n    return self.values",
                            "def array_values(self) -> ExtensionArray:\n    \"\"\"\n    The array that Series.array returns. Always an ExtensionArray.\n    \"\"\"\n    return PandasArray(self.values)",
                            "def get_values(self, dtype=None):\n    \"\"\"\n    return an internal format, currently just the ndarray\n    this is often overridden to handle to_dense like operations\n    \"\"\"\n    if is_object_dtype(dtype):\n        return self.values.astype(object)\n    return self.values",
                            "def get_block_values(self, dtype=None):\n    \"\"\"\n    This is used in the JSON C code\n    \"\"\"\n    return self.get_values(dtype=dtype)",
                            "def to_dense(self):\n    return self.values.view()",
                            "@property\ndef fill_value(self):\n    return np.nan",
                            "@property\ndef mgr_locs(self):\n    return self._mgr_locs",
                            "@mgr_locs.setter\ndef mgr_locs(self, new_mgr_locs):\n    if not isinstance(new_mgr_locs, libinternals.BlockPlacement):\n        new_mgr_locs = libinternals.BlockPlacement(new_mgr_locs)\n    self._mgr_locs = new_mgr_locs",
                            "@property\ndef array_dtype(self):\n    \"\"\" the dtype to return if I want to construct this block as an\n    array\n    \"\"\"\n    return self.dtype",
                            "def make_block(self, values, placement=None) -> 'Block':\n    \"\"\"\n    Create a new block, with type inference propagate any values that are\n    not specified\n    \"\"\"\n    if placement is None:\n        placement = self.mgr_locs\n    return make_block(values, placement=placement, ndim=self.ndim)",
                            "def make_block_same_class(self, values, placement=None, ndim=None):\n    \"\"\" Wrap given values in a block of same type as self. \"\"\"\n    if placement is None:\n        placement = self.mgr_locs\n    if ndim is None:\n        ndim = self.ndim\n    return make_block(values, placement=placement, ndim=ndim, klass=type(self))",
                            "def __repr__(self) -> str:\n    name = type(self).__name__\n    if self._is_single_block:\n        result = f'{name}: {len(self)} dtype: {self.dtype}'\n    else:\n        shape = ' x '.join((pprint_thing(s) for s in self.shape))\n        result = f'{name}: {pprint_thing(self.mgr_locs.indexer)}, {shape}, dtype: {self.dtype}'\n    return result",
                            "def __len__(self) -> int:\n    return len(self.values)",
                            "def __getstate__(self):\n    return (self.mgr_locs.indexer, self.values)",
                            "def __setstate__(self, state):\n    self.mgr_locs = libinternals.BlockPlacement(state[0])\n    self.values = state[1]\n    self.ndim = self.values.ndim",
                            "def _slice(self, slicer):\n    \"\"\" return a slice of my values \"\"\"\n    return self.values[slicer]",
                            "def getitem_block(self, slicer, new_mgr_locs=None):\n    \"\"\"\n    Perform __getitem__-like, return result as block.\n\n    As of now, only supports slices that preserve dimensionality.\n    \"\"\"\n    if new_mgr_locs is None:\n        if isinstance(slicer, tuple):\n            axis0_slicer = slicer[0]\n        else:\n            axis0_slicer = slicer\n        new_mgr_locs = self.mgr_locs[axis0_slicer]\n    new_values = self._slice(slicer)\n    if self._validate_ndim and new_values.ndim != self.ndim:\n        raise ValueError('Only same dim slicing is allowed')\n    return self.make_block_same_class(new_values, new_mgr_locs)",
                            "@property\ndef shape(self):\n    return self.values.shape",
                            "@property\ndef dtype(self):\n    return self.values.dtype",
                            "@property\ndef ftype(self):\n    if getattr(self.values, '_pandas_ftype', False):\n        dtype = self.dtype.subtype\n    else:\n        dtype = self.dtype\n    return f'{dtype}:{self._ftype}'",
                            "def merge(self, other):\n    return _merge_blocks([self, other])",
                            "def concat_same_type(self, to_concat, placement=None):\n    \"\"\"\n    Concatenate list of single blocks of the same type.\n    \"\"\"\n    values = self._concatenator([blk.values for blk in to_concat], axis=self.ndim - 1)\n    return self.make_block_same_class(values, placement=placement or slice(0, len(values), 1))",
                            "def iget(self, i):\n    return self.values[i]",
                            "def set(self, locs, values):\n    \"\"\"\n    Modify Block in-place with new item value\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.values[locs] = values",
                            "def delete(self, loc):\n    \"\"\"\n    Delete given loc(-s) from block in-place.\n    \"\"\"\n    self.values = np.delete(self.values, loc, 0)\n    self.mgr_locs = self.mgr_locs.delete(loc)",
                            "def apply(self, func, **kwargs) -> List['Block']:\n    \"\"\" apply the function to my values; return a block if we are not\n    one\n    \"\"\"\n    with np.errstate(all='ignore'):\n        result = func(self.values, **kwargs)\n    return self._split_op_result(result)",
                            "def _split_op_result(self, result) -> List['Block']:\n    if is_extension_array_dtype(result) and result.ndim > 1:\n        nbs = []\n        for i, loc in enumerate(self.mgr_locs):\n            vals = result[i]\n            nv = _block_shape(vals, ndim=self.ndim)\n            block = self.make_block(values=nv, placement=[loc])\n            nbs.append(block)\n        return nbs\n    if not isinstance(result, Block):\n        result = self.make_block(values=_block_shape(result, ndim=self.ndim))\n    return [result]",
                            "def fillna(self, value, limit=None, inplace=False, downcast=None):\n    \"\"\" fillna on the block with the value. If we fail, then convert to\n    ObjectBlock and try again\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    mask = isna(self.values)\n    if limit is not None:\n        limit = libalgos._validate_limit(None, limit=limit)\n        mask[mask.cumsum(self.ndim - 1) > limit] = False\n    if not self._can_hold_na:\n        if inplace:\n            return self\n        else:\n            return self.copy()\n    if self._can_hold_element(value):\n        blocks = self.putmask(mask, value, inplace=inplace)\n        return self._maybe_downcast(blocks, downcast)\n    if not mask.any():\n        return self if inplace else self.copy()\n\n    def f(mask, val, idx):\n        block = self.coerce_to_target_dtype(value)\n        if idx is not None:\n            block = block.getitem_block(slice(idx, idx + 1))\n        return block.fillna(value, limit=limit, inplace=inplace, downcast=None)\n    return self.split_and_operate(None, f, inplace)",
                            "def split_and_operate(self, mask, f, inplace: bool):\n    \"\"\"\n    split the block per-column, and apply the callable f\n    per-column, return a new block for each. Handle\n    masking which will not change a block unless needed.\n\n    Parameters\n    ----------\n    mask : 2-d boolean mask\n    f : callable accepting (1d-mask, 1d values, indexer)\n    inplace : boolean\n\n    Returns\n    -------\n    list of blocks\n    \"\"\"\n    if mask is None:\n        mask = np.broadcast_to(True, shape=self.shape)\n    new_values = self.values\n\n    def make_a_block(nv, ref_loc):\n        if isinstance(nv, list):\n            assert len(nv) == 1, nv\n            assert isinstance(nv[0], Block)\n            block = nv[0]\n        else:\n            nv = _block_shape(nv, ndim=self.ndim)\n            block = self.make_block(values=nv, placement=ref_loc)\n        return block\n    if self.ndim == 1:\n        if mask.any():\n            nv = f(mask, new_values, None)\n        else:\n            nv = new_values if inplace else new_values.copy()\n        block = make_a_block(nv, self.mgr_locs)\n        return [block]\n    new_blocks = []\n    for i, ref_loc in enumerate(self.mgr_locs):\n        m = mask[i]\n        v = new_values[i]\n        if m.any():\n            nv = f(m, v, i)\n        else:\n            nv = v if inplace else v.copy()\n        block = make_a_block(nv, [ref_loc])\n        new_blocks.append(block)\n    return new_blocks",
                            "def _maybe_downcast(self, blocks: List['Block'], downcast=None) -> List['Block']:\n    if downcast is None and (self.is_float or self.is_timedelta or self.is_datetime):\n        return blocks\n    return _extend_blocks([b.downcast(downcast) for b in blocks])",
                            "def downcast(self, dtypes=None):\n    \"\"\" try to downcast each item to the dict of dtypes if present \"\"\"\n    if dtypes is False:\n        return self\n    values = self.values\n    if self._is_single_block:\n        if dtypes is None:\n            dtypes = 'infer'\n        nv = maybe_downcast_to_dtype(values, dtypes)\n        return self.make_block(nv)\n    if dtypes is None:\n        return self\n    if not (dtypes == 'infer' or isinstance(dtypes, dict)):\n        raise ValueError(\"downcast must have a dictionary or 'infer' as its argument\")\n    elif dtypes != 'infer':\n        raise AssertionError('dtypes as dict is not supported yet')\n\n    def f(mask, val, idx):\n        val = maybe_downcast_to_dtype(val, dtype='infer')\n        return val\n    return self.split_and_operate(None, f, False)",
                            "def astype(self, dtype, copy: bool=False, errors: str='raise'):\n    \"\"\"\n    Coerce to the new dtype.\n\n    Parameters\n    ----------\n    dtype : str, dtype convertible\n    copy : bool, default False\n        copy if indicated\n    errors : str, {'raise', 'ignore'}, default 'ignore'\n        - ``raise`` : allow exceptions to be raised\n        - ``ignore`` : suppress exceptions. On error return original object\n\n    Returns\n    -------\n    Block\n    \"\"\"\n    errors_legal_values = ('raise', 'ignore')\n    if errors not in errors_legal_values:\n        invalid_arg = f\"Expected value of kwarg 'errors' to be one of {list(errors_legal_values)}. Supplied value is '{errors}'\"\n        raise ValueError(invalid_arg)\n    if inspect.isclass(dtype) and issubclass(dtype, ExtensionDtype):\n        msg = f\"Expected an instance of {dtype.__name__}, but got the class instead. Try instantiating 'dtype'.\"\n        raise TypeError(msg)\n    if self.is_categorical_astype(dtype):\n        if is_categorical_dtype(self.values):\n            return self.make_block(self.values.astype(dtype, copy=copy))\n        return self.make_block(Categorical(self.values, dtype=dtype))\n    dtype = pandas_dtype(dtype)\n    if is_dtype_equal(self.dtype, dtype):\n        if copy:\n            return self.copy()\n        return self\n    if self.is_extension:\n        values = self.values.astype(dtype)\n    else:\n        if issubclass(dtype.type, str):\n            if self.is_datelike:\n                values = self.to_native_types()\n            else:\n                values = self.get_values()\n        else:\n            values = self.get_values(dtype=dtype)\n        vals1d = values.ravel()\n        try:\n            values = astype_nansafe(vals1d, dtype, copy=True)\n        except (ValueError, TypeError):\n            if errors == 'raise':\n                raise\n            newb = self.copy() if copy else self\n            return newb\n    if isinstance(values, np.ndarray):\n        values = values.reshape(self.shape)\n    newb = make_block(values, placement=self.mgr_locs, ndim=self.ndim)\n    if newb.is_numeric and self.is_numeric:\n        if newb.shape != self.shape:\n            raise TypeError(f'cannot set astype for copy = [{copy}] for dtype ({self.dtype.name} [{self.shape}]) to different shape ({newb.dtype.name} [{newb.shape}])')\n    return newb",
                            "def convert(self, copy: bool=True, datetime: bool=True, numeric: bool=True, timedelta: bool=True, coerce: bool=False):\n    \"\"\" attempt to coerce any object types to better types return a copy\n    of the block (if copy = True) by definition we are not an ObjectBlock\n    here!\n    \"\"\"\n    return self.copy() if copy else self",
                            "def _can_hold_element(self, element: Any) -> bool:\n    \"\"\" require the same dtype as ourselves \"\"\"\n    dtype = self.values.dtype.type\n    tipo = maybe_infer_dtype_type(element)\n    if tipo is not None:\n        return issubclass(tipo.type, dtype)\n    return isinstance(element, dtype)",
                            "def to_native_types(self, slicer=None, na_rep='nan', quoting=None, **kwargs):\n    \"\"\" convert to our native types format, slicing if desired \"\"\"\n    values = self.get_values()\n    if slicer is not None:\n        values = values[:, slicer]\n    mask = isna(values)\n    itemsize = writers.word_len(na_rep)\n    if not self.is_object and (not quoting) and itemsize:\n        values = values.astype(str)\n        if values.dtype.itemsize / np.dtype('U1').itemsize < itemsize:\n            values = values.astype(f'<U{itemsize}')\n    else:\n        values = np.array(values, dtype='object')\n    values[mask] = na_rep\n    return values",
                            "def copy(self, deep=True):\n    \"\"\" copy constructor \"\"\"\n    values = self.values\n    if deep:\n        values = values.copy()\n    return self.make_block_same_class(values, ndim=self.ndim)",
                            "def replace(self, to_replace, value, inplace=False, filter=None, regex=False, convert=True):\n    \"\"\"replace the to_replace value with value, possible to create new\n    blocks here this is just a call to putmask. regex is not used here.\n    It is used in ObjectBlocks.  It is here for API compatibility.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    original_to_replace = to_replace\n    if not self._can_hold_element(to_replace):\n        if not isinstance(to_replace, list):\n            if inplace:\n                return [self]\n            return [self.copy()]\n        to_replace = [x for x in to_replace if self._can_hold_element(x)]\n        if not len(to_replace):\n            if inplace:\n                return [self]\n            return [self.copy()]\n        if len(to_replace) == 1:\n            return self.replace(to_replace[0], value, inplace=inplace, filter=filter, regex=regex, convert=convert)\n        if is_object_dtype(self):\n            raise AssertionError\n        block = self.astype(object)\n        return block.replace(to_replace=to_replace, value=value, inplace=inplace, filter=filter, regex=regex, convert=convert)\n    values = self.values\n    if lib.is_scalar(to_replace) and isinstance(values, np.ndarray):\n        to_replace = convert_scalar_for_putitemlike(to_replace, values.dtype)\n    mask = missing.mask_missing(values, to_replace)\n    if filter is not None:\n        filtered_out = ~self.mgr_locs.isin(filter)\n        mask[filtered_out.nonzero()[0]] = False\n    if not mask.any():\n        if inplace:\n            return [self]\n        return [self.copy()]\n    try:\n        blocks = self.putmask(mask, value, inplace=inplace)\n    except (TypeError, ValueError):\n        if is_object_dtype(self):\n            raise\n        assert not self._can_hold_element(value), value\n        block = self.astype(object)\n        return block.replace(to_replace=original_to_replace, value=value, inplace=inplace, filter=filter, regex=regex, convert=convert)\n    if convert:\n        blocks = [b.convert(numeric=False, copy=not inplace) for b in blocks]\n    return blocks",
                            "def _replace_single(self, *args, **kwargs):\n    \"\"\" no-op on a non-ObjectBlock \"\"\"\n    return self if kwargs['inplace'] else self.copy()",
                            "def setitem(self, indexer, value):\n    \"\"\"\n    Set the value inplace, returning a a maybe different typed block.\n\n    Parameters\n    ----------\n    indexer : tuple, list-like, array-like, slice\n        The subset of self.values to set\n    value : object\n        The value being set\n\n    Returns\n    -------\n    Block\n\n    Notes\n    -----\n    `indexer` is a direct slice/positional indexer. `value` must\n    be a compatible shape.\n    \"\"\"\n    transpose = self.ndim == 2\n    if value is None:\n        if self.is_numeric:\n            value = np.nan\n    values = self.values\n    if self._can_hold_element(value):\n        if lib.is_scalar(value):\n            value = convert_scalar_for_putitemlike(value, values.dtype)\n    else:\n        find_dtype = False\n        if hasattr(value, 'dtype'):\n            dtype = value.dtype\n            find_dtype = True\n        elif lib.is_scalar(value) and (not isna(value)):\n            dtype, _ = infer_dtype_from_scalar(value, pandas_dtype=True)\n            find_dtype = True\n        if find_dtype:\n            dtype = find_common_type([values.dtype, dtype])\n            if not is_dtype_equal(self.dtype, dtype):\n                b = self.astype(dtype)\n                return b.setitem(indexer, value)\n    if is_extension_array_dtype(getattr(value, 'dtype', None)):\n        arr_value = value\n    else:\n        arr_value = np.array(value)\n    if not self._can_hold_element(value):\n        dtype, _ = maybe_promote(arr_value.dtype)\n        values = values.astype(dtype)\n    if transpose:\n        values = values.T\n    check_setitem_lengths(indexer, value, values)\n    exact_match = len(arr_value.shape) and arr_value.shape[0] == values.shape[0] and (arr_value.size == values.size)\n    if is_empty_indexer(indexer, arr_value):\n        pass\n    elif is_scalar_indexer(indexer, arr_value):\n        values[indexer] = value\n    elif exact_match and is_categorical_dtype(arr_value.dtype) and (not is_categorical_dtype(values)):\n        values[indexer] = value\n        return self.make_block(Categorical(self.values, dtype=arr_value.dtype))\n    elif exact_match:\n        values[indexer] = value\n        try:\n            values = values.astype(arr_value.dtype)\n        except ValueError:\n            pass\n    else:\n        values[indexer] = value\n    if transpose:\n        values = values.T\n    block = self.make_block(values)\n    return block",
                            "def putmask(self, mask, new, align=True, inplace=False, axis=0, transpose=False):\n    \"\"\" putmask the data to the block; it is possible that we may create a\n    new dtype of block\n\n    return the resulting block(s)\n\n    Parameters\n    ----------\n    mask  : the condition to respect\n    new : a ndarray/object\n    align : boolean, perform alignment on other/cond, default is True\n    inplace : perform inplace modification, default is False\n    axis : int\n    transpose : boolean\n        Set to True if self is stored with axes reversed\n\n    Returns\n    -------\n    a list of new blocks, the result of the putmask\n    \"\"\"\n    new_values = self.values if inplace else self.values.copy()\n    new = getattr(new, 'values', new)\n    mask = getattr(mask, 'values', mask)\n    if not is_list_like(new) and isna(new) and (not self.is_object):\n        new = self.fill_value\n    if self._can_hold_element(new):\n        if lib.is_scalar(new):\n            new = convert_scalar_for_putitemlike(new, new_values.dtype)\n        if transpose:\n            new_values = new_values.T\n        if getattr(new, 'ndim', 0) >= 1:\n            if self.ndim - 1 == new.ndim and axis == 1:\n                new = np.repeat(new, new_values.shape[-1]).reshape(self.shape)\n            new = new.astype(new_values.dtype)\n        if is_list_like(new) and np.any(mask[mask]) and (getattr(new, 'ndim', 1) == 1):\n            if mask[mask].shape[-1] == len(new):\n                np.place(new_values, mask, new)\n            elif mask.shape[-1] == len(new) or len(new) == 1:\n                np.putmask(new_values, mask, new)\n            else:\n                raise ValueError('cannot assign mismatch length to masked array')\n        else:\n            np.putmask(new_values, mask, new)\n    elif mask.any():\n        if transpose:\n            mask = mask.T\n            if isinstance(new, np.ndarray):\n                new = new.T\n            axis = new_values.ndim - axis - 1\n        if getattr(new, 'ndim', 0) >= 1:\n            if self.ndim - 1 == new.ndim:\n                new_shape = list(new.shape)\n                new_shape.insert(axis, 1)\n                new = new.reshape(tuple(new_shape))\n\n        def f(mask, val, idx):\n            if idx is None:\n                n = new\n            else:\n                if isinstance(new, np.ndarray):\n                    n = np.squeeze(new[idx % new.shape[0]])\n                else:\n                    n = np.array(new)\n                dtype, _ = maybe_promote(n.dtype)\n                n = n.astype(dtype)\n            nv = _putmask_smart(val, mask, n)\n            return nv\n        new_blocks = self.split_and_operate(mask, f, inplace)\n        return new_blocks\n    if inplace:\n        return [self]\n    if transpose:\n        new_values = new_values.T\n    return [self.make_block(new_values)]",
                            "def coerce_to_target_dtype(self, other):\n    \"\"\"\n    coerce the current block to a dtype compat for other\n    we will return a block, possibly object, and not raise\n\n    we can also safely try to coerce to the same dtype\n    and will receive the same block\n    \"\"\"\n    dtype, _ = infer_dtype_from(other, pandas_dtype=True)\n    if is_dtype_equal(self.dtype, dtype):\n        return self\n    if self.is_bool or is_object_dtype(dtype) or is_bool_dtype(dtype):\n        return self.astype(object)\n    elif (self.is_float or self.is_complex) and (is_integer_dtype(dtype) or is_float_dtype(dtype)):\n        return self\n    elif self.is_datetime or is_datetime64_dtype(dtype) or is_datetime64tz_dtype(dtype):\n        if not ((is_datetime64_dtype(dtype) or is_datetime64tz_dtype(dtype)) and self.is_datetime):\n            return self.astype(object)\n        mytz = getattr(self.dtype, 'tz', None)\n        othertz = getattr(dtype, 'tz', None)\n        if not tz_compare(mytz, othertz):\n            return self.astype(object)\n        raise AssertionError(f'possible recursion in coerce_to_target_dtype: {self} {other}')\n    elif self.is_timedelta or is_timedelta64_dtype(dtype):\n        if not (is_timedelta64_dtype(dtype) and self.is_timedelta):\n            return self.astype(object)\n        raise AssertionError(f'possible recursion in coerce_to_target_dtype: {self} {other}')\n    try:\n        return self.astype(dtype)\n    except (ValueError, TypeError, OverflowError):\n        return self.astype(object)",
                            "def interpolate(self, method='pad', axis=0, index=None, values=None, inplace=False, limit=None, limit_direction='forward', limit_area=None, fill_value=None, coerce=False, downcast=None, **kwargs):\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n\n    def check_int_bool(self, inplace):\n        if (self.is_bool or self.is_integer) and (not self.is_timedelta):\n            if inplace:\n                return self\n            else:\n                return self.copy()\n    try:\n        m = missing.clean_fill_method(method)\n    except ValueError:\n        m = None\n    if m is not None:\n        r = check_int_bool(self, inplace)\n        if r is not None:\n            return r\n        return self._interpolate_with_fill(method=m, axis=axis, inplace=inplace, limit=limit, fill_value=fill_value, coerce=coerce, downcast=downcast)\n    m = missing.clean_interp_method(method, **kwargs)\n    r = check_int_bool(self, inplace)\n    if r is not None:\n        return r\n    return self._interpolate(method=m, index=index, values=values, axis=axis, limit=limit, limit_direction=limit_direction, limit_area=limit_area, fill_value=fill_value, inplace=inplace, downcast=downcast, **kwargs)",
                            "def _interpolate_with_fill(self, method='pad', axis=0, inplace=False, limit=None, fill_value=None, coerce=False, downcast=None):\n    \"\"\" fillna but using the interpolate machinery \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    if coerce:\n        if not self._can_hold_na:\n            if inplace:\n                return [self]\n            else:\n                return [self.copy()]\n    values = self.values if inplace else self.values.copy()\n    fill_value = convert_scalar_for_putitemlike(fill_value, self.values.dtype)\n    values = missing.interpolate_2d(values, method=method, axis=axis, limit=limit, fill_value=fill_value, dtype=self.dtype)\n    blocks = [self.make_block_same_class(values, ndim=self.ndim)]\n    return self._maybe_downcast(blocks, downcast)",
                            "def _interpolate(self, method=None, index=None, values=None, fill_value=None, axis=0, limit=None, limit_direction='forward', limit_area=None, inplace=False, downcast=None, **kwargs):\n    \"\"\" interpolate using scipy wrappers \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    data = self.values if inplace else self.values.copy()\n    if not self.is_float:\n        if not self.is_integer:\n            return self\n        data = data.astype(np.float64)\n    if fill_value is None:\n        fill_value = self.fill_value\n    if method in ('krogh', 'piecewise_polynomial', 'pchip'):\n        if not index.is_monotonic:\n            raise ValueError(f'{method} interpolation requires that the index be monotonic.')\n\n    def func(x):\n        return missing.interpolate_1d(index, x, method=method, limit=limit, limit_direction=limit_direction, limit_area=limit_area, fill_value=fill_value, bounds_error=False, **kwargs)\n    interp_values = np.apply_along_axis(func, axis, data)\n    blocks = [self.make_block_same_class(interp_values)]\n    return self._maybe_downcast(blocks, downcast)",
                            "def take_nd(self, indexer, axis, new_mgr_locs=None, fill_tuple=None):\n    \"\"\"\n    Take values according to indexer and return them as a block.bb\n\n    \"\"\"\n    values = self.values\n    if fill_tuple is None:\n        fill_value = self.fill_value\n        allow_fill = False\n    else:\n        fill_value = fill_tuple[0]\n        allow_fill = True\n    new_values = algos.take_nd(values, indexer, axis=axis, allow_fill=allow_fill, fill_value=fill_value)\n    assert not (axis == 0 and new_mgr_locs is None)\n    if new_mgr_locs is None:\n        new_mgr_locs = self.mgr_locs\n    if not is_dtype_equal(new_values.dtype, self.dtype):\n        return self.make_block(new_values, new_mgr_locs)\n    else:\n        return self.make_block_same_class(new_values, new_mgr_locs)",
                            "def diff(self, n: int, axis: int=1) -> List['Block']:\n    \"\"\" return block for the diff of the values \"\"\"\n    new_values = algos.diff(self.values, n, axis=axis, stacklevel=7)\n    new_values = _block_shape(new_values, ndim=self.ndim)\n    return [self.make_block(values=new_values)]",
                            "def shift(self, periods, axis=0, fill_value=None):\n    \"\"\" shift the block by periods, possibly upcast \"\"\"\n    new_values, fill_value = maybe_upcast(self.values, fill_value)\n    f_ordered = new_values.flags.f_contiguous\n    if f_ordered:\n        new_values = new_values.T\n        axis = new_values.ndim - axis - 1\n    if np.prod(new_values.shape):\n        new_values = np.roll(new_values, ensure_platform_int(periods), axis=axis)\n    axis_indexer = [slice(None)] * self.ndim\n    if periods > 0:\n        axis_indexer[axis] = slice(None, periods)\n    else:\n        axis_indexer[axis] = slice(periods, None)\n    new_values[tuple(axis_indexer)] = fill_value\n    if f_ordered:\n        new_values = new_values.T\n    return [self.make_block(new_values)]",
                            "def where(self, other, cond, align=True, errors='raise', try_cast: bool=False, axis: int=0) -> List['Block']:\n    \"\"\"\n    evaluate the block; return result block(s) from the result\n\n    Parameters\n    ----------\n    other : a ndarray/object\n    cond  : the condition to respect\n    align : boolean, perform alignment on other/cond\n    errors : str, {'raise', 'ignore'}, default 'raise'\n        - ``raise`` : allow exceptions to be raised\n        - ``ignore`` : suppress exceptions. On error return original object\n    axis : int\n\n    Returns\n    -------\n    a new block(s), the result of the func\n    \"\"\"\n    import pandas.core.computation.expressions as expressions\n    assert errors in ['raise', 'ignore']\n    transpose = self.ndim == 2\n    values = self.values\n    orig_other = other\n    if transpose:\n        values = values.T\n    other = getattr(other, '_values', getattr(other, 'values', other))\n    cond = getattr(cond, 'values', cond)\n    if getattr(other, 'ndim', 0) >= 1:\n        if values.ndim - 1 == other.ndim and axis == 1:\n            other = other.reshape(tuple(other.shape + (1,)))\n        elif transpose and values.ndim == self.ndim - 1:\n            cond = cond.T\n    if not hasattr(cond, 'shape'):\n        raise ValueError('where must have a condition that is ndarray like')\n\n    def where_func(cond, values, other):\n        if not ((self.is_integer or self.is_bool) and lib.is_float(other) and np.isnan(other)):\n            if not self._can_hold_element(other):\n                raise TypeError\n            if lib.is_scalar(other) and isinstance(values, np.ndarray):\n                other = convert_scalar_for_putitemlike(other, values.dtype)\n        fastres = expressions.where(cond, values, other)\n        return fastres\n    if cond.ravel().all():\n        result = values\n    else:\n        try:\n            result = where_func(cond, values, other)\n        except TypeError:\n            block = self.coerce_to_target_dtype(other)\n            blocks = block.where(orig_other, cond, align=align, errors=errors, try_cast=try_cast, axis=axis)\n            return self._maybe_downcast(blocks, 'infer')\n    if self._can_hold_na or self.ndim == 1:\n        if transpose:\n            result = result.T\n        return [self.make_block(result)]\n    axis = cond.ndim - 1\n    cond = cond.swapaxes(axis, 0)\n    mask = np.array([cond[i].all() for i in range(cond.shape[0])], dtype=bool)\n    result_blocks = []\n    for m in [mask, ~mask]:\n        if m.any():\n            taken = result.take(m.nonzero()[0], axis=axis)\n            r = maybe_downcast_numeric(taken, self.dtype)\n            nb = self.make_block(r.T, placement=self.mgr_locs[m])\n            result_blocks.append(nb)\n    return result_blocks",
                            "def equals(self, other) -> bool:\n    if self.dtype != other.dtype or self.shape != other.shape:\n        return False\n    return array_equivalent(self.values, other.values)",
                            "def _unstack(self, unstacker_func, new_columns, n_rows, fill_value):\n    \"\"\"Return a list of unstacked blocks of self\n\n    Parameters\n    ----------\n    unstacker_func : callable\n        Partially applied unstacker.\n    new_columns : Index\n        All columns of the unstacked BlockManager.\n    n_rows : int\n        Only used in ExtensionBlock._unstack\n    fill_value : int\n        Only used in ExtensionBlock._unstack\n\n    Returns\n    -------\n    blocks : list of Block\n        New blocks of unstacked values.\n    mask : array_like of bool\n        The mask of columns of `blocks` we should keep.\n    \"\"\"\n    unstacker = unstacker_func(self.values.T)\n    new_items = unstacker.get_new_columns()\n    new_placement = new_columns.get_indexer(new_items)\n    new_values, mask = unstacker.get_new_values()\n    mask = mask.any(0)\n    new_values = new_values.T[mask]\n    new_placement = new_placement[mask]\n    blocks = [make_block(new_values, placement=new_placement)]\n    return (blocks, mask)",
                            "def quantile(self, qs, interpolation='linear', axis=0):\n    \"\"\"\n    compute the quantiles of the\n\n    Parameters\n    ----------\n    qs: a scalar or list of the quantiles to be computed\n    interpolation: type of interpolation, default 'linear'\n    axis: axis to compute, default 0\n\n    Returns\n    -------\n    Block\n    \"\"\"\n    assert self.ndim == 2\n    values = self.get_values()\n    is_empty = values.shape[axis] == 0\n    orig_scalar = not is_list_like(qs)\n    if orig_scalar:\n        qs = [qs]\n    if is_empty:\n        result = np.repeat(np.array([self.fill_value] * len(qs)), len(values)).reshape(len(values), len(qs))\n    else:\n        mask = np.asarray(isna(values))\n        result = nanpercentile(values, np.array(qs) * 100, axis=axis, na_value=self.fill_value, mask=mask, ndim=values.ndim, interpolation=interpolation)\n        result = np.array(result, copy=False)\n        result = result.T\n    if orig_scalar and (not lib.is_scalar(result)):\n        assert result.shape[-1] == 1, result.shape\n        result = result[..., 0]\n        result = lib.item_from_zerodim(result)\n    ndim = np.ndim(result)\n    return make_block(result, placement=np.arange(len(result)), ndim=ndim)",
                            "def _replace_coerce(self, to_replace, value, inplace=True, regex=False, convert=False, mask=None):\n    \"\"\"\n    Replace value corresponding to the given boolean array with another\n    value.\n\n    Parameters\n    ----------\n    to_replace : object or pattern\n        Scalar to replace or regular expression to match.\n    value : object\n        Replacement object.\n    inplace : bool, default False\n        Perform inplace modification.\n    regex : bool, default False\n        If true, perform regular expression substitution.\n    convert : bool, default True\n        If true, try to coerce any object types to better types.\n    mask : array-like of bool, optional\n        True indicate corresponding element is ignored.\n\n    Returns\n    -------\n    A new block if there is anything to replace or the original block.\n    \"\"\"\n    if mask.any():\n        if not regex:\n            self = self.coerce_to_target_dtype(value)\n            return self.putmask(mask, value, inplace=inplace)\n        else:\n            return self._replace_single(to_replace, value, inplace=inplace, regex=regex, convert=convert, mask=mask)\n    return self",
                            "def f(mask, val, idx):\n    block = self.coerce_to_target_dtype(value)\n    if idx is not None:\n        block = block.getitem_block(slice(idx, idx + 1))\n    return block.fillna(value, limit=limit, inplace=inplace, downcast=None)",
                            "def make_a_block(nv, ref_loc):\n    if isinstance(nv, list):\n        assert len(nv) == 1, nv\n        assert isinstance(nv[0], Block)\n        block = nv[0]\n    else:\n        nv = _block_shape(nv, ndim=self.ndim)\n        block = self.make_block(values=nv, placement=ref_loc)\n    return block",
                            "def f(mask, val, idx):\n    val = maybe_downcast_to_dtype(val, dtype='infer')\n    return val",
                            "def check_int_bool(self, inplace):\n    if (self.is_bool or self.is_integer) and (not self.is_timedelta):\n        if inplace:\n            return self\n        else:\n            return self.copy()",
                            "def func(x):\n    return missing.interpolate_1d(index, x, method=method, limit=limit, limit_direction=limit_direction, limit_area=limit_area, fill_value=fill_value, bounds_error=False, **kwargs)",
                            "def where_func(cond, values, other):\n    if not ((self.is_integer or self.is_bool) and lib.is_float(other) and np.isnan(other)):\n        if not self._can_hold_element(other):\n            raise TypeError\n        if lib.is_scalar(other) and isinstance(values, np.ndarray):\n            other = convert_scalar_for_putitemlike(other, values.dtype)\n    fastres = expressions.where(cond, values, other)\n    return fastres",
                            "def f(mask, val, idx):\n    if idx is None:\n        n = new\n    else:\n        if isinstance(new, np.ndarray):\n            n = np.squeeze(new[idx % new.shape[0]])\n        else:\n            n = np.array(new)\n        dtype, _ = maybe_promote(n.dtype)\n        n = n.astype(dtype)\n    nv = _putmask_smart(val, mask, n)\n    return nv"
                        ],
                        "constructor_variables": [
                            "mgr_locs",
                            "ndim",
                            "values"
                        ],
                        "class_level_variables": [
                            "__slots__",
                            "is_numeric",
                            "is_float",
                            "is_integer",
                            "is_complex",
                            "is_datetime",
                            "is_datetimetz",
                            "is_timedelta",
                            "is_bool",
                            "is_object",
                            "is_categorical",
                            "is_extension",
                            "_can_hold_na",
                            "_can_consolidate",
                            "_verify_integrity",
                            "_validate_ndim",
                            "_ftype",
                            "_concatenator"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "__init__(self, values, placement, ndim=None)",
                            "_check_ndim(self, values, ndim)",
                            "_holder(self)",
                            "_consolidate_key(self)",
                            "_is_single_block(self)",
                            "is_view(self)",
                            "is_datelike(self)",
                            "is_categorical_astype(self, dtype)",
                            "external_values(self)",
                            "internal_values(self)",
                            "array_values(self) -> ExtensionArray",
                            "get_values(self, dtype=None)",
                            "get_block_values(self, dtype=None)",
                            "to_dense(self)",
                            "fill_value(self)",
                            "mgr_locs(self)",
                            "mgr_locs(self, new_mgr_locs)",
                            "array_dtype(self)",
                            "make_block(self, values, placement=None) -> 'Block'",
                            "make_block_same_class(self, values, placement=None, ndim=None)",
                            "__repr__(self) -> str",
                            "__len__(self) -> int",
                            "__getstate__(self)",
                            "__setstate__(self, state)",
                            "_slice(self, slicer)",
                            "getitem_block(self, slicer, new_mgr_locs=None)",
                            "shape(self)",
                            "dtype(self)",
                            "ftype(self)",
                            "merge(self, other)",
                            "concat_same_type(self, to_concat, placement=None)",
                            "iget(self, i)",
                            "set(self, locs, values)",
                            "delete(self, loc)",
                            "apply(self, func, **kwargs) -> List['Block']",
                            "_split_op_result(self, result) -> List['Block']",
                            "fillna(self, value, limit=None, inplace=False, downcast=None)",
                            "split_and_operate(self, mask, f, inplace: bool)",
                            "_maybe_downcast(self, blocks: List['Block'], downcast=None) -> List['Block']",
                            "downcast(self, dtypes=None)",
                            "astype(self, dtype, copy: bool=False, errors: str='raise')",
                            "convert(self, copy: bool=True, datetime: bool=True, numeric: bool=True, timedelta: bool=True, coerce: bool=False)",
                            "_can_hold_element(self, element: Any) -> bool",
                            "to_native_types(self, slicer=None, na_rep='nan', quoting=None, **kwargs)",
                            "copy(self, deep=True)",
                            "replace(self, to_replace, value, inplace=False, filter=None, regex=False, convert=True)",
                            "_replace_single(self, *args, **kwargs)",
                            "setitem(self, indexer, value)",
                            "putmask(self, mask, new, align=True, inplace=False, axis=0, transpose=False)",
                            "coerce_to_target_dtype(self, other)",
                            "interpolate(self, method='pad', axis=0, index=None, values=None, inplace=False, limit=None, limit_direction='forward', limit_area=None, fill_value=None, coerce=False, downcast=None, **kwargs)",
                            "_interpolate_with_fill(self, method='pad', axis=0, inplace=False, limit=None, fill_value=None, coerce=False, downcast=None)",
                            "_interpolate(self, method=None, index=None, values=None, fill_value=None, axis=0, limit=None, limit_direction='forward', limit_area=None, inplace=False, downcast=None, **kwargs)",
                            "take_nd(self, indexer, axis, new_mgr_locs=None, fill_tuple=None)",
                            "diff(self, n: int, axis: int=1) -> List['Block']",
                            "shift(self, periods, axis=0, fill_value=None)",
                            "where(self, other, cond, align=True, errors='raise', try_cast: bool=False, axis: int=0) -> List['Block']",
                            "equals(self, other) -> bool",
                            "_unstack(self, unstacker_func, new_columns, n_rows, fill_value)",
                            "quantile(self, qs, interpolation='linear', axis=0)",
                            "_replace_coerce(self, to_replace, value, inplace=True, regex=False, convert=False, mask=None)",
                            "f(mask, val, idx)",
                            "make_a_block(nv, ref_loc)",
                            "f(mask, val, idx)",
                            "check_int_bool(self, inplace)",
                            "func(x)",
                            "where_func(cond, values, other)",
                            "f(mask, val, idx)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "transpose": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.ndim": {
                                    "variable_value": "2",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "FloatBlock: slice(0, 5, 1), 5 x 5, dtype: float64",
                                    "variable_type": "FloatBlock",
                                    "variable_shape": "5"
                                },
                                "value": {
                                    "variable_value": "0",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self.is_numeric": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "np.nan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.values": {
                                    "variable_value": "array([[ 0.3254095 ,  1.13537071,  0.41596485, -2.38692762, -0.81208499],\n       [ 0.40564894,  2.32744218, -1.60344725, -0.40459818, -1.52215049],\n       [ 2.0293561 ,  2.31396406,  0.64057006,  1.79947236,  1.6430445 ],\n       [-0.17452001,  2.5454803 ,  1.73012858, -2.17683834,  0.88815101],\n       [ 0.1508324 ,  1.27522634, -0.56470797, -0.19516334,  0.10775487]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self._can_hold_element": {
                                    "variable_value": "<bound method FloatBlock._can_hold_element of FloatBlock: slice(0, 5, 1), 5 x 5, dtype: float64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "lib.is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "convert_scalar_for_putitemlike": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "find_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "value.dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "infer_dtype_from_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "find_common_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('float64')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "b": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": "<bound method Block.astype of FloatBlock: slice(0, 5, 1), 5 x 5, dtype: float64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "b.setitem": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": "array([[[1, 2],\n        [1, 0]],\n\n       [[0, 1],\n        [1, 4]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "2"
                                },
                                "is_extension_array_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "arr_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "maybe_promote": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "arr_value.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values.T": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_setitem_lengths": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "exact_match": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "arr_value.shape": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values.shape": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "arr_value.size": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values.size": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_empty_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_scalar_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.make_block": {
                                    "variable_value": "<bound method Block.make_block of FloatBlock: slice(0, 5, 1), 5 x 5, dtype: float64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "Categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "block": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "transpose": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.ndim": {
                                    "variable_value": "2",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "FloatBlock: slice(0, 5, 1), 5 x 5, dtype: float64",
                                    "variable_type": "FloatBlock",
                                    "variable_shape": "5"
                                },
                                "indexer": {
                                    "variable_value": "array([[[3, 0],\n        [2, 1]],\n\n       [[3, 4],\n        [1, 2]]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "2"
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "indexer.ndim": {
                                    "variable_value": "3",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "value": {
                                    "variable_value": "0",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self.is_numeric": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "np.nan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.values": {
                                    "variable_value": "array([[-0.96316138, -0.25324197, -0.56214806, -0.42852087,  0.26633828],\n       [ 0.51424004,  0.07438232,  1.26303524,  1.22172992,  0.112109  ],\n       [ 3.48309486, -0.25680754,  1.24356758, -0.2019222 , -1.87463799],\n       [ 0.28925441,  1.54993669,  0.34833028, -0.41053969,  0.19238042],\n       [ 0.51079584,  0.78516134,  0.24337125,  1.02305151,  0.02736425]])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self._can_hold_element": {
                                    "variable_value": "<bound method FloatBlock._can_hold_element of FloatBlock: slice(0, 5, 1), 5 x 5, dtype: float64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "lib.is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "convert_scalar_for_putitemlike": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "find_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "value.dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "infer_dtype_from_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "find_common_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('float64')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "b": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": "<bound method Block.astype of FloatBlock: slice(0, 5, 1), 5 x 5, dtype: float64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "b.setitem": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_extension_array_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "arr_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "maybe_promote": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "arr_value.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values.T": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_setitem_lengths": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "exact_match": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "arr_value.shape": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values.shape": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "arr_value.size": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values.size": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_empty_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_scalar_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.make_block": {
                                    "variable_value": "<bound method Block.make_block of FloatBlock: slice(0, 5, 1), 5 x 5, dtype: float64>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "Categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "block": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {}
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def get_block_type(values, dtype=None):\n    \"\"\"\n    Find the appropriate Block subclass to use for the given values and dtype.\n\n    Parameters\n    ----------\n    values : ndarray-like\n    dtype : numpy or pandas dtype\n\n    Returns\n    -------\n    cls : class, subclass of Block\n    \"\"\"\n    dtype = dtype or values.dtype\n    vtype = dtype.type\n\n    if is_sparse(dtype):\n        # Need this first(ish) so that Sparse[datetime] is sparse\n        cls = ExtensionBlock\n    elif is_categorical(values):\n        cls = CategoricalBlock\n    elif issubclass(vtype, np.datetime64):\n        assert not is_datetime64tz_dtype(values)\n        cls = DatetimeBlock\n    elif is_datetime64tz_dtype(values):\n        cls = DatetimeTZBlock\n    elif is_interval_dtype(dtype) or is_period_dtype(dtype):\n        cls = ObjectValuesExtensionBlock\n    elif is_extension_array_dtype(values):\n        cls = ExtensionBlock\n    elif issubclass(vtype, np.floating):\n        cls = FloatBlock\n    elif issubclass(vtype, np.timedelta64):\n        assert issubclass(vtype, np.integer)\n        cls = TimeDeltaBlock\n    elif issubclass(vtype, np.complexfloating):\n        cls = ComplexBlock\n    elif issubclass(vtype, np.integer):\n        cls = IntBlock\n    elif dtype == np.bool_:\n        cls = BoolBlock\n    else:\n        cls = ObjectBlock\n    return cls",
                "def make_block(values, placement, klass=None, ndim=None, dtype=None):\n    # Ensure that we don't allow PandasArray / PandasDtype in internals.\n    # For now, blocks should be backed by ndarrays when possible.\n    if isinstance(values, ABCPandasArray):\n        values = values.to_numpy()\n        if ndim and ndim > 1:\n            values = np.atleast_2d(values)\n\n    if isinstance(dtype, PandasDtype):\n        dtype = dtype.numpy_dtype\n\n    if klass is None:\n        dtype = dtype or values.dtype\n        klass = get_block_type(values, dtype)\n\n    elif klass is DatetimeTZBlock and not is_datetime64tz_dtype(values):\n        # TODO: This is no longer hit internally; does it need to be retained\n        #  for e.g. pyarrow?\n        values = DatetimeArray._simple_new(values, dtype=dtype)\n\n    return klass(values, ndim=ndim, placement=placement)",
                "def _extend_blocks(result, blocks=None):\n    \"\"\" return a new extended blocks, given the result \"\"\"\n\n    if blocks is None:\n        blocks = []\n    if isinstance(result, list):\n        for r in result:\n            if isinstance(r, list):\n                blocks.extend(r)\n            else:\n                blocks.append(r)\n    else:\n        assert isinstance(result, Block), type(result)\n        blocks.append(result)\n    return blocks",
                "def _block_shape(values, ndim=1, shape=None):\n    \"\"\" guarantee the shape of the values to be at least 1 d \"\"\"\n    if values.ndim < ndim:\n        if shape is None:\n            shape = values.shape\n        if not is_extension_array_dtype(values):\n            # TODO: https://github.com/pandas-dev/pandas/issues/23023\n            # block.shape is incorrect for \"2D\" ExtensionArrays\n            # We can't, and don't need to, reshape.\n            values = values.reshape(tuple((1,) + shape))\n    return values",
                "def _merge_blocks(blocks, dtype=None, _can_consolidate=True):\n\n    if len(blocks) == 1:\n        return blocks[0]\n\n    if _can_consolidate:\n\n        if dtype is None:\n            if len({b.dtype for b in blocks}) != 1:\n                raise AssertionError(\"_merge_blocks are invalid!\")\n\n        # FIXME: optimization potential in case all mgrs contain slices and\n        # combination of those slices is a slice, too.\n        new_mgr_locs = np.concatenate([b.mgr_locs.as_array for b in blocks])\n        new_values = np.vstack([b.values for b in blocks])\n\n        argsort = np.argsort(new_mgr_locs)\n        new_values = new_values[argsort]\n        new_mgr_locs = new_mgr_locs[argsort]\n\n        return make_block(new_values, placement=new_mgr_locs)\n\n    # no merge\n    return blocks",
                "def _safe_reshape(arr, new_shape):\n    \"\"\"\n    If possible, reshape `arr` to have shape `new_shape`,\n    with a couple of exceptions (see gh-13012):\n\n    1) If `arr` is a ExtensionArray or Index, `arr` will be\n       returned as is.\n    2) If `arr` is a Series, the `_values` attribute will\n       be reshaped and returned.\n\n    Parameters\n    ----------\n    arr : array-like, object to be reshaped\n    new_shape : int or tuple of ints, the new shape\n    \"\"\"\n    if isinstance(arr, ABCSeries):\n        arr = arr._values\n    if not isinstance(arr, ABCExtensionArray):\n        arr = arr.reshape(new_shape)\n    return arr",
                "def _putmask_smart(v, mask, n):\n    \"\"\"\n    Return a new ndarray, try to preserve dtype if possible.\n\n    Parameters\n    ----------\n    v : `values`, updated in-place (array like)\n    mask : np.ndarray\n        Applies to both sides (array like).\n    n : `new values` either scalar or an array like aligned with `values`\n\n    Returns\n    -------\n    values : ndarray with updated values\n        this *may* be a copy of the original\n\n    See Also\n    --------\n    ndarray.putmask\n    \"\"\"\n\n    # we cannot use np.asarray() here as we cannot have conversions\n    # that numpy does when numeric are mixed with strings\n\n    # n should be the length of the mask or a scalar here\n    if not is_list_like(n):\n        n = np.repeat(n, len(mask))\n\n    # see if we are only masking values that if putted\n    # will work in the current dtype\n    try:\n        nn = n[mask]\n    except TypeError:\n        # TypeError: only integer scalar arrays can be converted to a scalar index\n        pass\n    else:\n        # make sure that we have a nullable type\n        # if we have nulls\n        if not _isna_compat(v, nn[0]):\n            pass\n        elif not (is_float_dtype(nn.dtype) or is_integer_dtype(nn.dtype)):\n            # only compare integers/floats\n            pass\n        elif not (is_float_dtype(v.dtype) or is_integer_dtype(v.dtype)):\n            # only compare integers/floats\n            pass\n        else:\n\n            # we ignore ComplexWarning here\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"ignore\", np.ComplexWarning)\n                nn_at = nn.astype(v.dtype)\n\n            comp = nn == nn_at\n            if is_list_like(comp) and comp.all():\n                nv = v.copy()\n                nv[mask] = nn_at\n                return nv\n\n    n = np.asarray(n)\n\n    def _putmask_preserve(nv, n):\n        try:\n            nv[mask] = n[mask]\n        except (IndexError, ValueError):\n            nv[mask] = n\n        return nv\n\n    # preserves dtype if possible\n    if v.dtype.kind == n.dtype.kind:\n        return _putmask_preserve(v, n)\n\n    # change the dtype if needed\n    dtype, _ = maybe_promote(n.dtype)\n\n    if is_extension_array_dtype(v.dtype) and is_object_dtype(dtype):\n        v = v._internal_get_values(dtype)\n    else:\n        v = v.astype(dtype)\n\n    return _putmask_preserve(v, n)",
                "def __init__(self, values, placement, ndim=None):\n    self.ndim = self._check_ndim(values, ndim)\n    self.mgr_locs = placement\n    self.values = values\n\n    if self._validate_ndim and self.ndim and len(self.mgr_locs) != len(self.values):\n        raise ValueError(\n            f\"Wrong number of items passed {len(self.values)}, \"\n            f\"placement implies {len(self.mgr_locs)}\"\n        )",
                "def _check_ndim(self, values, ndim):\n    \"\"\"\n    ndim inference and validation.\n\n    Infers ndim from 'values' if not provided to __init__.\n    Validates that values.ndim and ndim are consistent if and only if\n    the class variable '_validate_ndim' is True.\n\n    Parameters\n    ----------\n    values : array-like\n    ndim : int or None\n\n    Returns\n    -------\n    ndim : int\n\n    Raises\n    ------\n    ValueError : the number of dimensions do not match\n    \"\"\"\n    if ndim is None:\n        ndim = values.ndim\n\n    if self._validate_ndim and values.ndim != ndim:\n        raise ValueError(\n            \"Wrong number of dimensions. \"\n            f\"values.ndim != ndim [{values.ndim} != {ndim}]\"\n        )\n    return ndim",
                "@property\ndef _holder(self):\n    \"\"\"The array-like that can hold the underlying values.\n\n    None for 'Block', overridden by subclasses that don't\n    use an ndarray.\n    \"\"\"\n    return None",
                "@property\ndef _consolidate_key(self):\n    return (self._can_consolidate, self.dtype.name)",
                "@property\ndef _is_single_block(self):\n    return self.ndim == 1",
                "@property\ndef is_view(self):\n    \"\"\" return a boolean if I am possibly a view \"\"\"\n    return self.values.base is not None",
                "@property\ndef is_datelike(self):\n    \"\"\" return True if I am a non-datelike \"\"\"\n    return self.is_datetime or self.is_timedelta",
                "def is_categorical_astype(self, dtype):\n    \"\"\"\n    validate that we have a astypeable to categorical,\n    returns a boolean if we are a categorical\n    \"\"\"\n    if dtype is Categorical or dtype is CategoricalDtype:\n        # this is a pd.Categorical, but is not\n        # a valid type for astypeing\n        raise TypeError(f\"invalid type {dtype} for astype\")\n\n    elif is_categorical_dtype(dtype):\n        return True\n\n    return False",
                "def external_values(self):\n    \"\"\"\n    The array that Series.values returns (public attribute).\n\n    This has some historical constraints, and is overridden in block\n    subclasses to return the correct array (e.g. period returns\n    object ndarray and datetimetz a datetime64[ns] ndarray instead of\n    proper extension array).\n    \"\"\"\n    return self.values",
                "def internal_values(self):\n    \"\"\"\n    The array that Series._values returns (internal values).\n    \"\"\"\n    return self.values",
                "def array_values(self) -> ExtensionArray:\n    \"\"\"\n    The array that Series.array returns. Always an ExtensionArray.\n    \"\"\"\n    return PandasArray(self.values)",
                "def get_values(self, dtype=None):\n    \"\"\"\n    return an internal format, currently just the ndarray\n    this is often overridden to handle to_dense like operations\n    \"\"\"\n    if is_object_dtype(dtype):\n        return self.values.astype(object)\n    return self.values",
                "def get_block_values(self, dtype=None):\n    \"\"\"\n    This is used in the JSON C code\n    \"\"\"\n    return self.get_values(dtype=dtype)",
                "def to_dense(self):\n    return self.values.view()",
                "@property\ndef fill_value(self):\n    return np.nan",
                "@property\ndef mgr_locs(self):\n    return self._mgr_locs",
                "@mgr_locs.setter\ndef mgr_locs(self, new_mgr_locs):\n    if not isinstance(new_mgr_locs, libinternals.BlockPlacement):\n        new_mgr_locs = libinternals.BlockPlacement(new_mgr_locs)\n\n    self._mgr_locs = new_mgr_locs",
                "@property\ndef array_dtype(self):\n    \"\"\" the dtype to return if I want to construct this block as an\n    array\n    \"\"\"\n    return self.dtype",
                "def make_block(self, values, placement=None) -> \"Block\":\n    \"\"\"\n    Create a new block, with type inference propagate any values that are\n    not specified\n    \"\"\"\n    if placement is None:\n        placement = self.mgr_locs\n\n    return make_block(values, placement=placement, ndim=self.ndim)",
                "def make_block_same_class(self, values, placement=None, ndim=None):\n    \"\"\" Wrap given values in a block of same type as self. \"\"\"\n    if placement is None:\n        placement = self.mgr_locs\n    if ndim is None:\n        ndim = self.ndim\n    return make_block(values, placement=placement, ndim=ndim, klass=type(self))",
                "def __repr__(self) -> str:\n    # don't want to print out all of the items here\n    name = type(self).__name__\n    if self._is_single_block:\n\n        result = f\"{name}: {len(self)} dtype: {self.dtype}\"\n\n    else:\n\n        shape = \" x \".join(pprint_thing(s) for s in self.shape)\n        result = (\n            f\"{name}: {pprint_thing(self.mgr_locs.indexer)}, \"\n            f\"{shape}, dtype: {self.dtype}\"\n        )\n\n    return result",
                "def __len__(self) -> int:\n    return len(self.values)",
                "def __getstate__(self):\n    return self.mgr_locs.indexer, self.values",
                "def __setstate__(self, state):\n    self.mgr_locs = libinternals.BlockPlacement(state[0])\n    self.values = state[1]\n    self.ndim = self.values.ndim",
                "def _slice(self, slicer):\n    \"\"\" return a slice of my values \"\"\"\n    return self.values[slicer]",
                "def getitem_block(self, slicer, new_mgr_locs=None):\n    \"\"\"\n    Perform __getitem__-like, return result as block.\n\n    As of now, only supports slices that preserve dimensionality.\n    \"\"\"\n    if new_mgr_locs is None:\n        if isinstance(slicer, tuple):\n            axis0_slicer = slicer[0]\n        else:\n            axis0_slicer = slicer\n        new_mgr_locs = self.mgr_locs[axis0_slicer]\n\n    new_values = self._slice(slicer)\n\n    if self._validate_ndim and new_values.ndim != self.ndim:\n        raise ValueError(\"Only same dim slicing is allowed\")\n\n    return self.make_block_same_class(new_values, new_mgr_locs)",
                "@property\ndef shape(self):\n    return self.values.shape",
                "@property\ndef dtype(self):\n    return self.values.dtype",
                "@property\ndef ftype(self):\n    if getattr(self.values, \"_pandas_ftype\", False):\n        dtype = self.dtype.subtype\n    else:\n        dtype = self.dtype\n    return f\"{dtype}:{self._ftype}\"",
                "def merge(self, other):\n    return _merge_blocks([self, other])",
                "def concat_same_type(self, to_concat, placement=None):\n    \"\"\"\n    Concatenate list of single blocks of the same type.\n    \"\"\"\n    values = self._concatenator(\n        [blk.values for blk in to_concat], axis=self.ndim - 1\n    )\n    return self.make_block_same_class(\n        values, placement=placement or slice(0, len(values), 1)\n    )",
                "def iget(self, i):\n    return self.values[i]",
                "def set(self, locs, values):\n    \"\"\"\n    Modify Block in-place with new item value\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.values[locs] = values",
                "def delete(self, loc):\n    \"\"\"\n    Delete given loc(-s) from block in-place.\n    \"\"\"\n    self.values = np.delete(self.values, loc, 0)\n    self.mgr_locs = self.mgr_locs.delete(loc)",
                "def apply(self, func, **kwargs) -> List[\"Block\"]:\n    \"\"\" apply the function to my values; return a block if we are not\n    one\n    \"\"\"\n    with np.errstate(all=\"ignore\"):\n        result = func(self.values, **kwargs)\n\n    return self._split_op_result(result)",
                "def _split_op_result(self, result) -> List[\"Block\"]:\n    # See also: split_and_operate\n    if is_extension_array_dtype(result) and result.ndim > 1:\n        # if we get a 2D ExtensionArray, we need to split it into 1D pieces\n        nbs = []\n        for i, loc in enumerate(self.mgr_locs):\n            vals = result[i]\n            nv = _block_shape(vals, ndim=self.ndim)\n            block = self.make_block(values=nv, placement=[loc])\n            nbs.append(block)\n        return nbs\n\n    if not isinstance(result, Block):\n        result = self.make_block(values=_block_shape(result, ndim=self.ndim))\n\n    return [result]",
                "def fillna(self, value, limit=None, inplace=False, downcast=None):\n    \"\"\" fillna on the block with the value. If we fail, then convert to\n    ObjectBlock and try again\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n\n    mask = isna(self.values)\n    if limit is not None:\n        limit = libalgos._validate_limit(None, limit=limit)\n        mask[mask.cumsum(self.ndim - 1) > limit] = False\n\n    if not self._can_hold_na:\n        if inplace:\n            return self\n        else:\n            return self.copy()\n\n    if self._can_hold_element(value):\n        # equivalent: _try_coerce_args(value) would not raise\n        blocks = self.putmask(mask, value, inplace=inplace)\n        return self._maybe_downcast(blocks, downcast)\n\n    # we can't process the value, but nothing to do\n    if not mask.any():\n        return self if inplace else self.copy()\n\n    # operate column-by-column\n    def f(mask, val, idx):\n        block = self.coerce_to_target_dtype(value)\n\n        # slice out our block\n        if idx is not None:\n            # i.e. self.ndim == 2\n            block = block.getitem_block(slice(idx, idx + 1))\n        return block.fillna(value, limit=limit, inplace=inplace, downcast=None)\n\n    return self.split_and_operate(None, f, inplace)",
                "def split_and_operate(self, mask, f, inplace: bool):\n    \"\"\"\n    split the block per-column, and apply the callable f\n    per-column, return a new block for each. Handle\n    masking which will not change a block unless needed.\n\n    Parameters\n    ----------\n    mask : 2-d boolean mask\n    f : callable accepting (1d-mask, 1d values, indexer)\n    inplace : boolean\n\n    Returns\n    -------\n    list of blocks\n    \"\"\"\n\n    if mask is None:\n        mask = np.broadcast_to(True, shape=self.shape)\n\n    new_values = self.values\n\n    def make_a_block(nv, ref_loc):\n        if isinstance(nv, list):\n            assert len(nv) == 1, nv\n            assert isinstance(nv[0], Block)\n            block = nv[0]\n        else:\n            # Put back the dimension that was taken from it and make\n            # a block out of the result.\n            nv = _block_shape(nv, ndim=self.ndim)\n            block = self.make_block(values=nv, placement=ref_loc)\n        return block\n\n    # ndim == 1\n    if self.ndim == 1:\n        if mask.any():\n            nv = f(mask, new_values, None)\n        else:\n            nv = new_values if inplace else new_values.copy()\n        block = make_a_block(nv, self.mgr_locs)\n        return [block]\n\n    # ndim > 1\n    new_blocks = []\n    for i, ref_loc in enumerate(self.mgr_locs):\n        m = mask[i]\n        v = new_values[i]\n\n        # need a new block\n        if m.any():\n            nv = f(m, v, i)\n        else:\n            nv = v if inplace else v.copy()\n\n        block = make_a_block(nv, [ref_loc])\n        new_blocks.append(block)\n\n    return new_blocks",
                "def _maybe_downcast(self, blocks: List[\"Block\"], downcast=None) -> List[\"Block\"]:\n\n    # no need to downcast our float\n    # unless indicated\n    if downcast is None and (\n        self.is_float or self.is_timedelta or self.is_datetime\n    ):\n        return blocks\n\n    return _extend_blocks([b.downcast(downcast) for b in blocks])",
                "def downcast(self, dtypes=None):\n    \"\"\" try to downcast each item to the dict of dtypes if present \"\"\"\n\n    # turn it off completely\n    if dtypes is False:\n        return self\n\n    values = self.values\n\n    # single block handling\n    if self._is_single_block:\n\n        # try to cast all non-floats here\n        if dtypes is None:\n            dtypes = \"infer\"\n\n        nv = maybe_downcast_to_dtype(values, dtypes)\n        return self.make_block(nv)\n\n    # ndim > 1\n    if dtypes is None:\n        return self\n\n    if not (dtypes == \"infer\" or isinstance(dtypes, dict)):\n        raise ValueError(\n            \"downcast must have a dictionary or 'infer' as its argument\"\n        )\n    elif dtypes != \"infer\":\n        raise AssertionError(\"dtypes as dict is not supported yet\")\n\n    # operate column-by-column\n    # this is expensive as it splits the blocks items-by-item\n    def f(mask, val, idx):\n        val = maybe_downcast_to_dtype(val, dtype=\"infer\")\n        return val\n\n    return self.split_and_operate(None, f, False)",
                "def astype(self, dtype, copy: bool = False, errors: str = \"raise\"):\n    \"\"\"\n    Coerce to the new dtype.\n\n    Parameters\n    ----------\n    dtype : str, dtype convertible\n    copy : bool, default False\n        copy if indicated\n    errors : str, {'raise', 'ignore'}, default 'ignore'\n        - ``raise`` : allow exceptions to be raised\n        - ``ignore`` : suppress exceptions. On error return original object\n\n    Returns\n    -------\n    Block\n    \"\"\"\n    errors_legal_values = (\"raise\", \"ignore\")\n\n    if errors not in errors_legal_values:\n        invalid_arg = (\n            \"Expected value of kwarg 'errors' to be one of \"\n            f\"{list(errors_legal_values)}. Supplied value is '{errors}'\"\n        )\n        raise ValueError(invalid_arg)\n\n    if inspect.isclass(dtype) and issubclass(dtype, ExtensionDtype):\n        msg = (\n            f\"Expected an instance of {dtype.__name__}, \"\n            \"but got the class instead. Try instantiating 'dtype'.\"\n        )\n        raise TypeError(msg)\n\n    # may need to convert to categorical\n    if self.is_categorical_astype(dtype):\n\n        if is_categorical_dtype(self.values):\n            # GH 10696/18593: update an existing categorical efficiently\n            return self.make_block(self.values.astype(dtype, copy=copy))\n\n        return self.make_block(Categorical(self.values, dtype=dtype))\n\n    dtype = pandas_dtype(dtype)\n\n    # astype processing\n    if is_dtype_equal(self.dtype, dtype):\n        if copy:\n            return self.copy()\n        return self\n\n    # force the copy here\n    if self.is_extension:\n        # TODO: Should we try/except this astype?\n        values = self.values.astype(dtype)\n    else:\n        if issubclass(dtype.type, str):\n\n            # use native type formatting for datetime/tz/timedelta\n            if self.is_datelike:\n                values = self.to_native_types()\n\n            # astype formatting\n            else:\n                values = self.get_values()\n\n        else:\n            values = self.get_values(dtype=dtype)\n\n        # _astype_nansafe works fine with 1-d only\n        vals1d = values.ravel()\n        try:\n            values = astype_nansafe(vals1d, dtype, copy=True)\n        except (ValueError, TypeError):\n            # e.g. astype_nansafe can fail on object-dtype of strings\n            #  trying to convert to float\n            if errors == \"raise\":\n                raise\n            newb = self.copy() if copy else self\n            return newb\n\n    # TODO(extension)\n    # should we make this attribute?\n    if isinstance(values, np.ndarray):\n        values = values.reshape(self.shape)\n\n    newb = make_block(values, placement=self.mgr_locs, ndim=self.ndim)\n\n    if newb.is_numeric and self.is_numeric:\n        if newb.shape != self.shape:\n            raise TypeError(\n                f\"cannot set astype for copy = [{copy}] for dtype \"\n                f\"({self.dtype.name} [{self.shape}]) to different shape \"\n                f\"({newb.dtype.name} [{newb.shape}])\"\n            )\n    return newb",
                "def convert(\n    self,\n    copy: bool = True,\n    datetime: bool = True,\n    numeric: bool = True,\n    timedelta: bool = True,\n    coerce: bool = False,\n):\n    \"\"\" attempt to coerce any object types to better types return a copy\n    of the block (if copy = True) by definition we are not an ObjectBlock\n    here!\n    \"\"\"\n\n    return self.copy() if copy else self",
                "def _can_hold_element(self, element: Any) -> bool:\n    \"\"\" require the same dtype as ourselves \"\"\"\n    dtype = self.values.dtype.type\n    tipo = maybe_infer_dtype_type(element)\n    if tipo is not None:\n        return issubclass(tipo.type, dtype)\n    return isinstance(element, dtype)",
                "def to_native_types(self, slicer=None, na_rep=\"nan\", quoting=None, **kwargs):\n    \"\"\" convert to our native types format, slicing if desired \"\"\"\n    values = self.get_values()\n\n    if slicer is not None:\n        values = values[:, slicer]\n    mask = isna(values)\n    itemsize = writers.word_len(na_rep)\n\n    if not self.is_object and not quoting and itemsize:\n        values = values.astype(str)\n        if values.dtype.itemsize / np.dtype(\"U1\").itemsize < itemsize:\n            # enlarge for the na_rep\n            values = values.astype(f\"<U{itemsize}\")\n    else:\n        values = np.array(values, dtype=\"object\")\n\n    values[mask] = na_rep\n    return values",
                "def copy(self, deep=True):\n    \"\"\" copy constructor \"\"\"\n    values = self.values\n    if deep:\n        values = values.copy()\n    return self.make_block_same_class(values, ndim=self.ndim)",
                "def replace(\n    self, to_replace, value, inplace=False, filter=None, regex=False, convert=True\n):\n    \"\"\"replace the to_replace value with value, possible to create new\n    blocks here this is just a call to putmask. regex is not used here.\n    It is used in ObjectBlocks.  It is here for API compatibility.\n    \"\"\"\n\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    original_to_replace = to_replace\n\n    # If we cannot replace with own dtype, convert to ObjectBlock and\n    # retry\n    if not self._can_hold_element(to_replace):\n        if not isinstance(to_replace, list):\n            if inplace:\n                return [self]\n            return [self.copy()]\n\n        to_replace = [x for x in to_replace if self._can_hold_element(x)]\n        if not len(to_replace):\n            # GH#28084 avoid costly checks since we can infer\n            #  that there is nothing to replace in this block\n            if inplace:\n                return [self]\n            return [self.copy()]\n\n        if len(to_replace) == 1:\n            # _can_hold_element checks have reduced this back to the\n            #  scalar case and we can avoid a costly object cast\n            return self.replace(\n                to_replace[0],\n                value,\n                inplace=inplace,\n                filter=filter,\n                regex=regex,\n                convert=convert,\n            )\n\n        # GH 22083, TypeError or ValueError occurred within error handling\n        # causes infinite loop. Cast and retry only if not objectblock.\n        if is_object_dtype(self):\n            raise AssertionError\n\n        # try again with a compatible block\n        block = self.astype(object)\n        return block.replace(\n            to_replace=to_replace,\n            value=value,\n            inplace=inplace,\n            filter=filter,\n            regex=regex,\n            convert=convert,\n        )\n\n    values = self.values\n    if lib.is_scalar(to_replace) and isinstance(values, np.ndarray):\n        # The only non-DatetimeLike class that also has a non-trivial\n        #  try_coerce_args is ObjectBlock, but that overrides replace,\n        #  so does not get here.\n        to_replace = convert_scalar_for_putitemlike(to_replace, values.dtype)\n\n    mask = missing.mask_missing(values, to_replace)\n    if filter is not None:\n        filtered_out = ~self.mgr_locs.isin(filter)\n        mask[filtered_out.nonzero()[0]] = False\n\n    if not mask.any():\n        if inplace:\n            return [self]\n        return [self.copy()]\n\n    try:\n        blocks = self.putmask(mask, value, inplace=inplace)\n        # Note: it is _not_ the case that self._can_hold_element(value)\n        #  is always true at this point.  In particular, that can fail\n        #  for:\n        #   \"2u\" with bool-dtype, float-dtype\n        #   0.5 with int64-dtype\n        #   np.nan with int64-dtype\n    except (TypeError, ValueError):\n        # GH 22083, TypeError or ValueError occurred within error handling\n        # causes infinite loop. Cast and retry only if not objectblock.\n        if is_object_dtype(self):\n            raise\n\n        assert not self._can_hold_element(value), value\n\n        # try again with a compatible block\n        block = self.astype(object)\n        return block.replace(\n            to_replace=original_to_replace,\n            value=value,\n            inplace=inplace,\n            filter=filter,\n            regex=regex,\n            convert=convert,\n        )\n    if convert:\n        blocks = [b.convert(numeric=False, copy=not inplace) for b in blocks]\n    return blocks",
                "def _replace_single(self, *args, **kwargs):\n    \"\"\" no-op on a non-ObjectBlock \"\"\"\n    return self if kwargs[\"inplace\"] else self.copy()",
                "def setitem(self, indexer, value):\n    \"\"\"\n    Set the value inplace, returning a a maybe different typed block.\n\n    Parameters\n    ----------\n    indexer : tuple, list-like, array-like, slice\n        The subset of self.values to set\n    value : object\n        The value being set\n\n    Returns\n    -------\n    Block\n\n    Notes\n    -----\n    `indexer` is a direct slice/positional indexer. `value` must\n    be a compatible shape.\n    \"\"\"\n    transpose = self.ndim == 2\n\n    # coerce None values, if appropriate\n    if value is None:\n        if self.is_numeric:\n            value = np.nan\n\n    # coerce if block dtype can store value\n    values = self.values\n    if self._can_hold_element(value):\n        # We only get here for non-Extension Blocks, so _try_coerce_args\n        #  is only relevant for DatetimeBlock and TimedeltaBlock\n        if lib.is_scalar(value):\n            value = convert_scalar_for_putitemlike(value, values.dtype)\n\n    else:\n        # current dtype cannot store value, coerce to common dtype\n        find_dtype = False\n\n        if hasattr(value, \"dtype\"):\n            dtype = value.dtype\n            find_dtype = True\n\n        elif lib.is_scalar(value) and not isna(value):\n            dtype, _ = infer_dtype_from_scalar(value, pandas_dtype=True)\n            find_dtype = True\n\n        if find_dtype:\n            dtype = find_common_type([values.dtype, dtype])\n            if not is_dtype_equal(self.dtype, dtype):\n                b = self.astype(dtype)\n                return b.setitem(indexer, value)\n\n    # value must be storeable at this moment\n    if is_extension_array_dtype(getattr(value, \"dtype\", None)):\n        # We need to be careful not to allow through strings that\n        #  can be parsed to EADtypes\n        arr_value = value\n    else:\n        arr_value = np.array(value)\n\n    # cast the values to a type that can hold nan (if necessary)\n    if not self._can_hold_element(value):\n        dtype, _ = maybe_promote(arr_value.dtype)\n        values = values.astype(dtype)\n\n    if transpose:\n        values = values.T\n\n    # length checking\n    check_setitem_lengths(indexer, value, values)\n    exact_match = (\n        len(arr_value.shape)\n        and arr_value.shape[0] == values.shape[0]\n        and arr_value.size == values.size\n    )\n    if is_empty_indexer(indexer, arr_value):\n        # GH#8669 empty indexers\n        pass\n\n    elif is_scalar_indexer(indexer, arr_value):\n        # setting a single element for each dim and with a rhs that could\n        #  be e.g. a list; see GH#6043\n        values[indexer] = value\n\n    elif (\n        exact_match\n        and is_categorical_dtype(arr_value.dtype)\n        and not is_categorical_dtype(values)\n    ):\n        # GH25495 - If the current dtype is not categorical,\n        # we need to create a new categorical block\n        values[indexer] = value\n        return self.make_block(Categorical(self.values, dtype=arr_value.dtype))\n\n    # if we are an exact match (ex-broadcasting),\n    # then use the resultant dtype\n    elif exact_match:\n        values[indexer] = value\n\n        try:\n            values = values.astype(arr_value.dtype)\n        except ValueError:\n            pass\n\n    # set\n    else:\n        values[indexer] = value\n\n    if transpose:\n        values = values.T\n    block = self.make_block(values)\n    return block",
                "def putmask(self, mask, new, align=True, inplace=False, axis=0, transpose=False):\n    \"\"\" putmask the data to the block; it is possible that we may create a\n    new dtype of block\n\n    return the resulting block(s)\n\n    Parameters\n    ----------\n    mask  : the condition to respect\n    new : a ndarray/object\n    align : boolean, perform alignment on other/cond, default is True\n    inplace : perform inplace modification, default is False\n    axis : int\n    transpose : boolean\n        Set to True if self is stored with axes reversed\n\n    Returns\n    -------\n    a list of new blocks, the result of the putmask\n    \"\"\"\n\n    new_values = self.values if inplace else self.values.copy()\n\n    new = getattr(new, \"values\", new)\n    mask = getattr(mask, \"values\", mask)\n\n    # if we are passed a scalar None, convert it here\n    if not is_list_like(new) and isna(new) and not self.is_object:\n        # FIXME: make sure we have compatible NA\n        new = self.fill_value\n\n    if self._can_hold_element(new):\n        # We only get here for non-Extension Blocks, so _try_coerce_args\n        #  is only relevant for DatetimeBlock and TimedeltaBlock\n        if lib.is_scalar(new):\n            new = convert_scalar_for_putitemlike(new, new_values.dtype)\n\n        if transpose:\n            new_values = new_values.T\n\n        # If the default repeat behavior in np.putmask would go in the\n        # wrong direction, then explicitly repeat and reshape new instead\n        if getattr(new, \"ndim\", 0) >= 1:\n            if self.ndim - 1 == new.ndim and axis == 1:\n                new = np.repeat(new, new_values.shape[-1]).reshape(self.shape)\n            new = new.astype(new_values.dtype)\n\n        # we require exact matches between the len of the\n        # values we are setting (or is compat). np.putmask\n        # doesn't check this and will simply truncate / pad\n        # the output, but we want sane error messages\n        #\n        # TODO: this prob needs some better checking\n        # for 2D cases\n        if (\n            is_list_like(new)\n            and np.any(mask[mask])\n            and getattr(new, \"ndim\", 1) == 1\n        ):\n            if mask[mask].shape[-1] == len(new):\n                # GH 30567\n                # If length of ``new`` is less than the length of ``new_values``,\n                # `np.putmask` would first repeat the ``new`` array and then\n                # assign the masked values hence produces incorrect result.\n                # `np.place` on the other hand uses the ``new`` values at it is\n                # to place in the masked locations of ``new_values``\n                np.place(new_values, mask, new)\n            elif mask.shape[-1] == len(new) or len(new) == 1:\n                np.putmask(new_values, mask, new)\n            else:\n                raise ValueError(\"cannot assign mismatch length to masked array\")\n        else:\n            np.putmask(new_values, mask, new)\n\n    # maybe upcast me\n    elif mask.any():\n        if transpose:\n            mask = mask.T\n            if isinstance(new, np.ndarray):\n                new = new.T\n            axis = new_values.ndim - axis - 1\n\n        # Pseudo-broadcast\n        if getattr(new, \"ndim\", 0) >= 1:\n            if self.ndim - 1 == new.ndim:\n                new_shape = list(new.shape)\n                new_shape.insert(axis, 1)\n                new = new.reshape(tuple(new_shape))\n\n        # operate column-by-column\n        def f(mask, val, idx):\n\n            if idx is None:\n                # ndim==1 case.\n                n = new\n            else:\n\n                if isinstance(new, np.ndarray):\n                    n = np.squeeze(new[idx % new.shape[0]])\n                else:\n                    n = np.array(new)\n\n                # type of the new block\n                dtype, _ = maybe_promote(n.dtype)\n\n                # we need to explicitly astype here to make a copy\n                n = n.astype(dtype)\n\n            nv = _putmask_smart(val, mask, n)\n            return nv\n\n        new_blocks = self.split_and_operate(mask, f, inplace)\n        return new_blocks\n\n    if inplace:\n        return [self]\n\n    if transpose:\n        new_values = new_values.T\n\n    return [self.make_block(new_values)]",
                "def coerce_to_target_dtype(self, other):\n    \"\"\"\n    coerce the current block to a dtype compat for other\n    we will return a block, possibly object, and not raise\n\n    we can also safely try to coerce to the same dtype\n    and will receive the same block\n    \"\"\"\n\n    # if we cannot then coerce to object\n    dtype, _ = infer_dtype_from(other, pandas_dtype=True)\n\n    if is_dtype_equal(self.dtype, dtype):\n        return self\n\n    if self.is_bool or is_object_dtype(dtype) or is_bool_dtype(dtype):\n        # we don't upcast to bool\n        return self.astype(object)\n\n    elif (self.is_float or self.is_complex) and (\n        is_integer_dtype(dtype) or is_float_dtype(dtype)\n    ):\n        # don't coerce float/complex to int\n        return self\n\n    elif (\n        self.is_datetime\n        or is_datetime64_dtype(dtype)\n        or is_datetime64tz_dtype(dtype)\n    ):\n\n        # not a datetime\n        if not (\n            (is_datetime64_dtype(dtype) or is_datetime64tz_dtype(dtype))\n            and self.is_datetime\n        ):\n            return self.astype(object)\n\n        # don't upcast timezone with different timezone or no timezone\n        mytz = getattr(self.dtype, \"tz\", None)\n        othertz = getattr(dtype, \"tz\", None)\n\n        if not tz_compare(mytz, othertz):\n            return self.astype(object)\n\n        raise AssertionError(\n            f\"possible recursion in coerce_to_target_dtype: {self} {other}\"\n        )\n\n    elif self.is_timedelta or is_timedelta64_dtype(dtype):\n\n        # not a timedelta\n        if not (is_timedelta64_dtype(dtype) and self.is_timedelta):\n            return self.astype(object)\n\n        raise AssertionError(\n            f\"possible recursion in coerce_to_target_dtype: {self} {other}\"\n        )\n\n    try:\n        return self.astype(dtype)\n    except (ValueError, TypeError, OverflowError):\n        return self.astype(object)",
                "def interpolate(\n    self,\n    method=\"pad\",\n    axis=0,\n    index=None,\n    values=None,\n    inplace=False,\n    limit=None,\n    limit_direction=\"forward\",\n    limit_area=None,\n    fill_value=None,\n    coerce=False,\n    downcast=None,\n    **kwargs,\n):\n\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n\n    def check_int_bool(self, inplace):\n        # Only FloatBlocks will contain NaNs.\n        # timedelta subclasses IntBlock\n        if (self.is_bool or self.is_integer) and not self.is_timedelta:\n            if inplace:\n                return self\n            else:\n                return self.copy()\n\n    # a fill na type method\n    try:\n        m = missing.clean_fill_method(method)\n    except ValueError:\n        m = None\n\n    if m is not None:\n        r = check_int_bool(self, inplace)\n        if r is not None:\n            return r\n        return self._interpolate_with_fill(\n            method=m,\n            axis=axis,\n            inplace=inplace,\n            limit=limit,\n            fill_value=fill_value,\n            coerce=coerce,\n            downcast=downcast,\n        )\n    # validate the interp method\n    m = missing.clean_interp_method(method, **kwargs)\n\n    r = check_int_bool(self, inplace)\n    if r is not None:\n        return r\n    return self._interpolate(\n        method=m,\n        index=index,\n        values=values,\n        axis=axis,\n        limit=limit,\n        limit_direction=limit_direction,\n        limit_area=limit_area,\n        fill_value=fill_value,\n        inplace=inplace,\n        downcast=downcast,\n        **kwargs,\n    )",
                "def _interpolate_with_fill(\n    self,\n    method=\"pad\",\n    axis=0,\n    inplace=False,\n    limit=None,\n    fill_value=None,\n    coerce=False,\n    downcast=None,\n):\n    \"\"\" fillna but using the interpolate machinery \"\"\"\n\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n\n    # if we are coercing, then don't force the conversion\n    # if the block can't hold the type\n    if coerce:\n        if not self._can_hold_na:\n            if inplace:\n                return [self]\n            else:\n                return [self.copy()]\n\n    values = self.values if inplace else self.values.copy()\n\n    # We only get here for non-ExtensionBlock\n    fill_value = convert_scalar_for_putitemlike(fill_value, self.values.dtype)\n\n    values = missing.interpolate_2d(\n        values,\n        method=method,\n        axis=axis,\n        limit=limit,\n        fill_value=fill_value,\n        dtype=self.dtype,\n    )\n\n    blocks = [self.make_block_same_class(values, ndim=self.ndim)]\n    return self._maybe_downcast(blocks, downcast)",
                "def _interpolate(\n    self,\n    method=None,\n    index=None,\n    values=None,\n    fill_value=None,\n    axis=0,\n    limit=None,\n    limit_direction=\"forward\",\n    limit_area=None,\n    inplace=False,\n    downcast=None,\n    **kwargs,\n):\n    \"\"\" interpolate using scipy wrappers \"\"\"\n\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    data = self.values if inplace else self.values.copy()\n\n    # only deal with floats\n    if not self.is_float:\n        if not self.is_integer:\n            return self\n        data = data.astype(np.float64)\n\n    if fill_value is None:\n        fill_value = self.fill_value\n\n    if method in (\"krogh\", \"piecewise_polynomial\", \"pchip\"):\n        if not index.is_monotonic:\n            raise ValueError(\n                f\"{method} interpolation requires that the index be monotonic.\"\n            )\n    # process 1-d slices in the axis direction\n\n    def func(x):\n\n        # process a 1-d slice, returning it\n        # should the axis argument be handled below in apply_along_axis?\n        # i.e. not an arg to missing.interpolate_1d\n        return missing.interpolate_1d(\n            index,\n            x,\n            method=method,\n            limit=limit,\n            limit_direction=limit_direction,\n            limit_area=limit_area,\n            fill_value=fill_value,\n            bounds_error=False,\n            **kwargs,\n        )\n\n    # interp each column independently\n    interp_values = np.apply_along_axis(func, axis, data)\n\n    blocks = [self.make_block_same_class(interp_values)]\n    return self._maybe_downcast(blocks, downcast)",
                "def take_nd(self, indexer, axis, new_mgr_locs=None, fill_tuple=None):\n    \"\"\"\n    Take values according to indexer and return them as a block.bb\n\n    \"\"\"\n\n    # algos.take_nd dispatches for DatetimeTZBlock, CategoricalBlock\n    # so need to preserve types\n    # sparse is treated like an ndarray, but needs .get_values() shaping\n\n    values = self.values\n\n    if fill_tuple is None:\n        fill_value = self.fill_value\n        allow_fill = False\n    else:\n        fill_value = fill_tuple[0]\n        allow_fill = True\n\n    new_values = algos.take_nd(\n        values, indexer, axis=axis, allow_fill=allow_fill, fill_value=fill_value\n    )\n\n    # Called from three places in managers, all of which satisfy\n    #  this assertion\n    assert not (axis == 0 and new_mgr_locs is None)\n    if new_mgr_locs is None:\n        new_mgr_locs = self.mgr_locs\n\n    if not is_dtype_equal(new_values.dtype, self.dtype):\n        return self.make_block(new_values, new_mgr_locs)\n    else:\n        return self.make_block_same_class(new_values, new_mgr_locs)",
                "def diff(self, n: int, axis: int = 1) -> List[\"Block\"]:\n    \"\"\" return block for the diff of the values \"\"\"\n    new_values = algos.diff(self.values, n, axis=axis, stacklevel=7)\n    # We use block_shape for ExtensionBlock subclasses, which may call here\n    # via a super.\n    new_values = _block_shape(new_values, ndim=self.ndim)\n    return [self.make_block(values=new_values)]",
                "def shift(self, periods, axis=0, fill_value=None):\n    \"\"\" shift the block by periods, possibly upcast \"\"\"\n\n    # convert integer to float if necessary. need to do a lot more than\n    # that, handle boolean etc also\n    new_values, fill_value = maybe_upcast(self.values, fill_value)\n\n    # make sure array sent to np.roll is c_contiguous\n    f_ordered = new_values.flags.f_contiguous\n    if f_ordered:\n        new_values = new_values.T\n        axis = new_values.ndim - axis - 1\n\n    if np.prod(new_values.shape):\n        new_values = np.roll(new_values, ensure_platform_int(periods), axis=axis)\n\n    axis_indexer = [slice(None)] * self.ndim\n    if periods > 0:\n        axis_indexer[axis] = slice(None, periods)\n    else:\n        axis_indexer[axis] = slice(periods, None)\n    new_values[tuple(axis_indexer)] = fill_value\n\n    # restore original order\n    if f_ordered:\n        new_values = new_values.T\n\n    return [self.make_block(new_values)]",
                "def where(\n    self,\n    other,\n    cond,\n    align=True,\n    errors=\"raise\",\n    try_cast: bool = False,\n    axis: int = 0,\n) -> List[\"Block\"]:\n    \"\"\"\n    evaluate the block; return result block(s) from the result\n\n    Parameters\n    ----------\n    other : a ndarray/object\n    cond  : the condition to respect\n    align : boolean, perform alignment on other/cond\n    errors : str, {'raise', 'ignore'}, default 'raise'\n        - ``raise`` : allow exceptions to be raised\n        - ``ignore`` : suppress exceptions. On error return original object\n    axis : int\n\n    Returns\n    -------\n    a new block(s), the result of the func\n    \"\"\"\n    import pandas.core.computation.expressions as expressions\n\n    assert errors in [\"raise\", \"ignore\"]\n    transpose = self.ndim == 2\n\n    values = self.values\n    orig_other = other\n    if transpose:\n        values = values.T\n\n    other = getattr(other, \"_values\", getattr(other, \"values\", other))\n    cond = getattr(cond, \"values\", cond)\n\n    # If the default broadcasting would go in the wrong direction, then\n    # explicitly reshape other instead\n    if getattr(other, \"ndim\", 0) >= 1:\n        if values.ndim - 1 == other.ndim and axis == 1:\n            other = other.reshape(tuple(other.shape + (1,)))\n        elif transpose and values.ndim == self.ndim - 1:\n            cond = cond.T\n\n    if not hasattr(cond, \"shape\"):\n        raise ValueError(\"where must have a condition that is ndarray like\")\n\n    def where_func(cond, values, other):\n\n        if not (\n            (self.is_integer or self.is_bool)\n            and lib.is_float(other)\n            and np.isnan(other)\n        ):\n            # np.where will cast integer array to floats in this case\n            if not self._can_hold_element(other):\n                raise TypeError\n            if lib.is_scalar(other) and isinstance(values, np.ndarray):\n                # convert datetime to datetime64, timedelta to timedelta64\n                other = convert_scalar_for_putitemlike(other, values.dtype)\n\n        # By the time we get here, we should have all Series/Index\n        #  args extracted to  ndarray\n        fastres = expressions.where(cond, values, other)\n        return fastres\n\n    if cond.ravel().all():\n        result = values\n    else:\n        # see if we can operate on the entire block, or need item-by-item\n        # or if we are a single block (ndim == 1)\n        try:\n            result = where_func(cond, values, other)\n        except TypeError:\n\n            # we cannot coerce, return a compat dtype\n            # we are explicitly ignoring errors\n            block = self.coerce_to_target_dtype(other)\n            blocks = block.where(\n                orig_other,\n                cond,\n                align=align,\n                errors=errors,\n                try_cast=try_cast,\n                axis=axis,\n            )\n            return self._maybe_downcast(blocks, \"infer\")\n\n    if self._can_hold_na or self.ndim == 1:\n\n        if transpose:\n            result = result.T\n\n        return [self.make_block(result)]\n\n    # might need to separate out blocks\n    axis = cond.ndim - 1\n    cond = cond.swapaxes(axis, 0)\n    mask = np.array([cond[i].all() for i in range(cond.shape[0])], dtype=bool)\n\n    result_blocks = []\n    for m in [mask, ~mask]:\n        if m.any():\n            taken = result.take(m.nonzero()[0], axis=axis)\n            r = maybe_downcast_numeric(taken, self.dtype)\n            nb = self.make_block(r.T, placement=self.mgr_locs[m])\n            result_blocks.append(nb)\n\n    return result_blocks",
                "def equals(self, other) -> bool:\n    if self.dtype != other.dtype or self.shape != other.shape:\n        return False\n    return array_equivalent(self.values, other.values)",
                "def _unstack(self, unstacker_func, new_columns, n_rows, fill_value):\n    \"\"\"Return a list of unstacked blocks of self\n\n    Parameters\n    ----------\n    unstacker_func : callable\n        Partially applied unstacker.\n    new_columns : Index\n        All columns of the unstacked BlockManager.\n    n_rows : int\n        Only used in ExtensionBlock._unstack\n    fill_value : int\n        Only used in ExtensionBlock._unstack\n\n    Returns\n    -------\n    blocks : list of Block\n        New blocks of unstacked values.\n    mask : array_like of bool\n        The mask of columns of `blocks` we should keep.\n    \"\"\"\n    unstacker = unstacker_func(self.values.T)\n    new_items = unstacker.get_new_columns()\n    new_placement = new_columns.get_indexer(new_items)\n    new_values, mask = unstacker.get_new_values()\n\n    mask = mask.any(0)\n    new_values = new_values.T[mask]\n    new_placement = new_placement[mask]\n\n    blocks = [make_block(new_values, placement=new_placement)]\n    return blocks, mask",
                "def quantile(self, qs, interpolation=\"linear\", axis=0):\n    \"\"\"\n    compute the quantiles of the\n\n    Parameters\n    ----------\n    qs: a scalar or list of the quantiles to be computed\n    interpolation: type of interpolation, default 'linear'\n    axis: axis to compute, default 0\n\n    Returns\n    -------\n    Block\n    \"\"\"\n    # We should always have ndim == 2 because Series dispatches to DataFrame\n    assert self.ndim == 2\n\n    values = self.get_values()\n\n    is_empty = values.shape[axis] == 0\n    orig_scalar = not is_list_like(qs)\n    if orig_scalar:\n        # make list-like, unpack later\n        qs = [qs]\n\n    if is_empty:\n        # create the array of na_values\n        # 2d len(values) * len(qs)\n        result = np.repeat(\n            np.array([self.fill_value] * len(qs)), len(values)\n        ).reshape(len(values), len(qs))\n    else:\n        # asarray needed for Sparse, see GH#24600\n        mask = np.asarray(isna(values))\n        result = nanpercentile(\n            values,\n            np.array(qs) * 100,\n            axis=axis,\n            na_value=self.fill_value,\n            mask=mask,\n            ndim=values.ndim,\n            interpolation=interpolation,\n        )\n\n        result = np.array(result, copy=False)\n        result = result.T\n\n    if orig_scalar and not lib.is_scalar(result):\n        # result could be scalar in case with is_empty and self.ndim == 1\n        assert result.shape[-1] == 1, result.shape\n        result = result[..., 0]\n        result = lib.item_from_zerodim(result)\n\n    ndim = np.ndim(result)\n    return make_block(result, placement=np.arange(len(result)), ndim=ndim)",
                "def _replace_coerce(\n    self, to_replace, value, inplace=True, regex=False, convert=False, mask=None\n):\n    \"\"\"\n    Replace value corresponding to the given boolean array with another\n    value.\n\n    Parameters\n    ----------\n    to_replace : object or pattern\n        Scalar to replace or regular expression to match.\n    value : object\n        Replacement object.\n    inplace : bool, default False\n        Perform inplace modification.\n    regex : bool, default False\n        If true, perform regular expression substitution.\n    convert : bool, default True\n        If true, try to coerce any object types to better types.\n    mask : array-like of bool, optional\n        True indicate corresponding element is ignored.\n\n    Returns\n    -------\n    A new block if there is anything to replace or the original block.\n    \"\"\"\n\n    if mask.any():\n        if not regex:\n            self = self.coerce_to_target_dtype(value)\n            return self.putmask(mask, value, inplace=inplace)\n        else:\n            return self._replace_single(\n                to_replace,\n                value,\n                inplace=inplace,\n                regex=regex,\n                convert=convert,\n                mask=mask,\n            )\n    return self",
                "def __init__(self, values, placement, ndim=None):\n    \"\"\"Initialize a non-consolidatable block.\n\n    'ndim' may be inferred from 'placement'.\n\n    This will call continue to call __init__ for the other base\n    classes mixed in with this Mixin.\n    \"\"\"\n    # Placement must be converted to BlockPlacement so that we can check\n    # its length\n    if not isinstance(placement, libinternals.BlockPlacement):\n        placement = libinternals.BlockPlacement(placement)\n\n    # Maybe infer ndim from placement\n    if ndim is None:\n        if len(placement) != 1:\n            ndim = 1\n        else:\n            ndim = 2\n    super().__init__(values, placement, ndim=ndim)",
                "@property\ndef shape(self):\n    if self.ndim == 1:\n        return ((len(self.values)),)\n    return (len(self.mgr_locs), len(self.values))",
                "def iget(self, col):\n\n    if self.ndim == 2 and isinstance(col, tuple):\n        col, loc = col\n        if not com.is_null_slice(col) and col != 0:\n            raise IndexError(f\"{self} only contains one item\")\n        elif isinstance(col, slice):\n            if col != slice(None):\n                raise NotImplementedError(col)\n            return self.values[[loc]]\n        return self.values[loc]\n    else:\n        if col != 0:\n            raise IndexError(f\"{self} only contains one item\")\n        return self.values",
                "def should_store(self, value):\n    return isinstance(value, self._holder)",
                "def set(self, locs, values, check=False):\n    assert locs.tolist() == [0]\n    self.values = values",
                "def putmask(self, mask, new, align=True, inplace=False, axis=0, transpose=False):\n    \"\"\"\n    putmask the data to the block; we must be a single block and not\n    generate other blocks\n\n    return the resulting block\n\n    Parameters\n    ----------\n    mask  : the condition to respect\n    new : a ndarray/object\n    align : boolean, perform alignment on other/cond, default is True\n    inplace : perform inplace modification, default is False\n\n    Returns\n    -------\n    a new block, the result of the putmask\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n\n    # use block's copy logic.\n    # .values may be an Index which does shallow copy by default\n    new_values = self.values if inplace else self.copy().values\n\n    if isinstance(new, np.ndarray) and len(new) == len(mask):\n        new = new[mask]\n\n    mask = _safe_reshape(mask, new_values.shape)\n\n    new_values[mask] = new\n    return [self.make_block(values=new_values)]",
                "def _get_unstack_items(self, unstacker, new_columns):\n    \"\"\"\n    Get the placement, values, and mask for a Block unstack.\n\n    This is shared between ObjectBlock and ExtensionBlock. They\n    differ in that ObjectBlock passes the values, while ExtensionBlock\n    passes the dummy ndarray of positions to be used by a take\n    later.\n\n    Parameters\n    ----------\n    unstacker : pandas.core.reshape.reshape._Unstacker\n    new_columns : Index\n        All columns of the unstacked BlockManager.\n\n    Returns\n    -------\n    new_placement : ndarray[int]\n        The placement of the new columns in `new_columns`.\n    new_values : Union[ndarray, ExtensionArray]\n        The first return value from _Unstacker.get_new_values.\n    mask : ndarray[bool]\n        The second return value from _Unstacker.get_new_values.\n    \"\"\"\n    # shared with ExtensionBlock\n    new_items = unstacker.get_new_columns()\n    new_placement = new_columns.get_indexer(new_items)\n    new_values, mask = unstacker.get_new_values()\n\n    mask = mask.any(0)\n    return new_placement, new_values, mask",
                "def __init__(self, values, placement, ndim=None):\n    values = self._maybe_coerce_values(values)\n    super().__init__(values, placement, ndim)",
                "def _maybe_coerce_values(self, values):\n    \"\"\"\n    Unbox to an extension array.\n\n    This will unbox an ExtensionArray stored in an Index or Series.\n    ExtensionArrays pass through. No dtype coercion is done.\n\n    Parameters\n    ----------\n    values : Index, Series, ExtensionArray\n\n    Returns\n    -------\n    ExtensionArray\n    \"\"\"\n    return extract_array(values)",
                "@property\ndef _holder(self):\n    # For extension blocks, the holder is values-dependent.\n    return type(self.values)",
                "@property\ndef fill_value(self):\n    # Used in reindex_indexer\n    return self.values.dtype.na_value",
                "@property\ndef _can_hold_na(self):\n    # The default ExtensionArray._can_hold_na is True\n    return self._holder._can_hold_na",
                "@property\ndef is_view(self):\n    \"\"\"Extension arrays are never treated as views.\"\"\"\n    return False",
                "@property\ndef is_numeric(self):\n    return self.values.dtype._is_numeric",
                "def setitem(self, indexer, value):\n    \"\"\"Set the value inplace, returning a same-typed block.\n\n    This differs from Block.setitem by not allowing setitem to change\n    the dtype of the Block.\n\n    Parameters\n    ----------\n    indexer : tuple, list-like, array-like, slice\n        The subset of self.values to set\n    value : object\n        The value being set\n\n    Returns\n    -------\n    Block\n\n    Notes\n    -----\n    `indexer` is a direct slice/positional indexer. `value` must\n    be a compatible shape.\n    \"\"\"\n    if isinstance(indexer, tuple):\n        # we are always 1-D\n        indexer = indexer[0]\n\n    check_setitem_lengths(indexer, value, self.values)\n    self.values[indexer] = value\n    return self",
                "def get_values(self, dtype=None):\n    # ExtensionArrays must be iterable, so this works.\n    values = np.asarray(self.values)\n    if values.ndim == self.ndim - 1:\n        values = values.reshape((1,) + values.shape)\n    return values",
                "def array_values(self) -> ExtensionArray:\n    return self.values",
                "def to_dense(self):\n    return np.asarray(self.values)",
                "def to_native_types(self, slicer=None, na_rep=\"nan\", quoting=None, **kwargs):\n    \"\"\"override to use ExtensionArray astype for the conversion\"\"\"\n    values = self.values\n    if slicer is not None:\n        values = values[slicer]\n    mask = isna(values)\n\n    values = np.asarray(values.astype(object))\n    values[mask] = na_rep\n\n    # we are expected to return a 2-d ndarray\n    return values.reshape(1, len(values))",
                "def take_nd(self, indexer, axis=0, new_mgr_locs=None, fill_tuple=None):\n    \"\"\"\n    Take values according to indexer and return them as a block.\n    \"\"\"\n    if fill_tuple is None:\n        fill_value = None\n    else:\n        fill_value = fill_tuple[0]\n\n    # axis doesn't matter; we are really a single-dim object\n    # but are passed the axis depending on the calling routing\n    # if its REALLY axis 0, then this will be a reindex and not a take\n    new_values = self.values.take(indexer, fill_value=fill_value, allow_fill=True)\n\n    # Called from three places in managers, all of which satisfy\n    #  this assertion\n    assert not (self.ndim == 1 and new_mgr_locs is None)\n    if new_mgr_locs is None:\n        new_mgr_locs = self.mgr_locs\n\n    return self.make_block_same_class(new_values, new_mgr_locs)",
                "def _can_hold_element(self, element: Any) -> bool:\n    # XXX: We may need to think about pushing this onto the array.\n    # We're doing the same as CategoricalBlock here.\n    return True",
                "def _slice(self, slicer):\n    \"\"\" return a slice of my values \"\"\"\n\n    # slice the category\n    # return same dims as we currently have\n\n    if isinstance(slicer, tuple) and len(slicer) == 2:\n        if not com.is_null_slice(slicer[0]):\n            raise AssertionError(\"invalid slicing for a 1-ndim categorical\")\n        slicer = slicer[1]\n\n    return self.values[slicer]",
                "def concat_same_type(self, to_concat, placement=None):\n    \"\"\"\n    Concatenate list of single blocks of the same type.\n    \"\"\"\n    values = self._holder._concat_same_type([blk.values for blk in to_concat])\n    placement = placement or slice(0, len(values), 1)\n    return self.make_block_same_class(values, ndim=self.ndim, placement=placement)",
                "def fillna(self, value, limit=None, inplace=False, downcast=None):\n    values = self.values if inplace else self.values.copy()\n    values = values.fillna(value=value, limit=limit)\n    return [\n        self.make_block_same_class(\n            values=values, placement=self.mgr_locs, ndim=self.ndim\n        )\n    ]",
                "def interpolate(\n    self, method=\"pad\", axis=0, inplace=False, limit=None, fill_value=None, **kwargs\n):\n\n    values = self.values if inplace else self.values.copy()\n    return self.make_block_same_class(\n        values=values.fillna(value=fill_value, method=method, limit=limit),\n        placement=self.mgr_locs,\n    )",
                "def diff(self, n: int, axis: int = 1) -> List[\"Block\"]:\n    if axis == 1:\n        # we are by definition 1D.\n        axis = 0\n    return super().diff(n, axis)",
                "def shift(\n    self,\n    periods: int,\n    axis: libinternals.BlockPlacement = 0,\n    fill_value: Any = None,\n) -> List[\"ExtensionBlock\"]:\n    \"\"\"\n    Shift the block by `periods`.\n\n    Dispatches to underlying ExtensionArray and re-boxes in an\n    ExtensionBlock.\n    \"\"\"\n    return [\n        self.make_block_same_class(\n            self.values.shift(periods=periods, fill_value=fill_value),\n            placement=self.mgr_locs,\n            ndim=self.ndim,\n        )\n    ]",
                "def where(\n    self,\n    other,\n    cond,\n    align=True,\n    errors=\"raise\",\n    try_cast: bool = False,\n    axis: int = 0,\n) -> List[\"Block\"]:\n    if isinstance(other, ABCDataFrame):\n        # ExtensionArrays are 1-D, so if we get here then\n        # `other` should be a DataFrame with a single column.\n        assert other.shape[1] == 1\n        other = other.iloc[:, 0]\n\n    other = extract_array(other, extract_numpy=True)\n\n    if isinstance(cond, ABCDataFrame):\n        assert cond.shape[1] == 1\n        cond = cond.iloc[:, 0]\n\n    cond = extract_array(cond, extract_numpy=True)\n\n    if lib.is_scalar(other) and isna(other):\n        # The default `other` for Series / Frame is np.nan\n        # we want to replace that with the correct NA value\n        # for the type\n        other = self.dtype.na_value\n\n    if is_sparse(self.values):\n        # TODO(SparseArray.__setitem__): remove this if condition\n        # We need to re-infer the type of the data after doing the\n        # where, for cases where the subtypes don't match\n        dtype = None\n    else:\n        dtype = self.dtype\n\n    result = self.values.copy()\n    icond = ~cond\n    if lib.is_scalar(other):\n        set_other = other\n    else:\n        set_other = other[icond]\n    try:\n        result[icond] = set_other\n    except (NotImplementedError, TypeError):\n        # NotImplementedError for class not implementing `__setitem__`\n        # TypeError for SparseArray, which implements just to raise\n        # a TypeError\n        result = self._holder._from_sequence(\n            np.where(cond, self.values, other), dtype=dtype\n        )\n\n    return [self.make_block_same_class(result, placement=self.mgr_locs)]",
                "@property\ndef _ftype(self):\n    return getattr(self.values, \"_pandas_ftype\", Block._ftype)",
                "def _unstack(self, unstacker_func, new_columns, n_rows, fill_value):\n    # ExtensionArray-safe unstack.\n    # We override ObjectBlock._unstack, which unstacks directly on the\n    # values of the array. For EA-backed blocks, this would require\n    # converting to a 2-D ndarray of objects.\n    # Instead, we unstack an ndarray of integer positions, followed by\n    # a `take` on the actual values.\n    dummy_arr = np.arange(n_rows)\n    dummy_unstacker = functools.partial(unstacker_func, fill_value=-1)\n    unstacker = dummy_unstacker(dummy_arr)\n\n    new_placement, new_values, mask = self._get_unstack_items(\n        unstacker, new_columns\n    )\n\n    blocks = [\n        self.make_block_same_class(\n            self.values.take(indices, allow_fill=True, fill_value=fill_value),\n            [place],\n        )\n        for indices, place in zip(new_values.T, new_placement)\n    ]\n    return blocks, mask",
                "def external_values(self):\n    return self.values.astype(object)",
                "def equals(self, other) -> bool:\n    if self.dtype != other.dtype or self.shape != other.shape:\n        return False\n    left, right = self.values, other.values\n    return ((left == right) | (np.isnan(left) & np.isnan(right))).all()",
                "def _can_hold_element(self, element: Any) -> bool:\n    tipo = maybe_infer_dtype_type(element)\n    if tipo is not None:\n        return issubclass(tipo.type, (np.floating, np.integer)) and not issubclass(\n            tipo.type, (np.datetime64, np.timedelta64)\n        )\n    return isinstance(\n        element, (float, int, np.floating, np.int_)\n    ) and not isinstance(\n        element,\n        (bool, np.bool_, datetime, timedelta, np.datetime64, np.timedelta64),\n    )",
                "def to_native_types(\n    self,\n    slicer=None,\n    na_rep=\"\",\n    float_format=None,\n    decimal=\".\",\n    quoting=None,\n    **kwargs,\n):\n    \"\"\" convert to our native types format, slicing if desired \"\"\"\n\n    values = self.values\n    if slicer is not None:\n        values = values[:, slicer]\n\n    # see gh-13418: no special formatting is desired at the\n    # output (important for appropriate 'quoting' behaviour),\n    # so do not pass it through the FloatArrayFormatter\n    if float_format is None and decimal == \".\":\n        mask = isna(values)\n\n        if not quoting:\n            values = values.astype(str)\n        else:\n            values = np.array(values, dtype=\"object\")\n\n        values[mask] = na_rep\n        return values\n\n    from pandas.io.formats.format import FloatArrayFormatter\n\n    formatter = FloatArrayFormatter(\n        values,\n        na_rep=na_rep,\n        float_format=float_format,\n        decimal=decimal,\n        quoting=quoting,\n        fixed_width=False,\n    )\n    return formatter.get_result_as_array()",
                "def should_store(self, value):\n    # when inserting a column should not coerce integers to floats\n    # unnecessarily\n    return issubclass(value.dtype.type, np.floating) and value.dtype == self.dtype",
                "def _can_hold_element(self, element: Any) -> bool:\n    tipo = maybe_infer_dtype_type(element)\n    if tipo is not None:\n        return issubclass(tipo.type, (np.floating, np.integer, np.complexfloating))\n    return isinstance(\n        element, (float, int, complex, np.float_, np.int_)\n    ) and not isinstance(element, (bool, np.bool_))",
                "def should_store(self, value):\n    return issubclass(value.dtype.type, np.complexfloating)",
                "def _can_hold_element(self, element: Any) -> bool:\n    tipo = maybe_infer_dtype_type(element)\n    if tipo is not None:\n        return (\n            issubclass(tipo.type, np.integer)\n            and not issubclass(tipo.type, (np.datetime64, np.timedelta64))\n            and self.dtype.itemsize >= tipo.itemsize\n        )\n    return is_integer(element)",
                "def should_store(self, value):\n    return is_integer_dtype(value) and value.dtype == self.dtype",
                "@property\ndef _holder(self):\n    return DatetimeArray",
                "@property\ndef fill_value(self):\n    return np.datetime64(\"NaT\", \"ns\")",
                "def get_values(self, dtype=None):\n    \"\"\"\n    return object dtype as boxed values, such as Timestamps/Timedelta\n    \"\"\"\n    if is_object_dtype(dtype):\n        values = self.values.ravel()\n        result = self._holder(values).astype(object)\n        return result.reshape(self.values.shape)\n    return self.values",
                "def internal_values(self):\n    # Override to return DatetimeArray and TimedeltaArray\n    return self.array_values()",
                "def iget(self, key):\n    # GH#31649 we need to wrap scalars in Timestamp/Timedelta\n    # TODO: this can be removed if we ever have 2D EA\n    result = super().iget(key)\n    if isinstance(result, np.datetime64):\n        result = Timestamp(result)\n    elif isinstance(result, np.timedelta64):\n        result = Timedelta(result)\n    return result",
                "def __init__(self, values, placement, ndim=None):\n    values = self._maybe_coerce_values(values)\n    super().__init__(values, placement=placement, ndim=ndim)",
                "@property\ndef _can_hold_na(self):\n    return True",
                "def _maybe_coerce_values(self, values):\n    \"\"\"\n    Input validation for values passed to __init__. Ensure that\n    we have datetime64ns, coercing if necessary.\n\n    Parameters\n    ----------\n    values : array-like\n        Must be convertible to datetime64\n\n    Returns\n    -------\n    values : ndarray[datetime64ns]\n\n    Overridden by DatetimeTZBlock.\n    \"\"\"\n    if values.dtype != _NS_DTYPE:\n        values = conversion.ensure_datetime64ns(values)\n\n    if isinstance(values, DatetimeArray):\n        values = values._data\n\n    assert isinstance(values, np.ndarray), type(values)\n    return values",
                "def astype(self, dtype, copy: bool = False, errors: str = \"raise\"):\n    \"\"\"\n    these automatically copy, so copy=True has no effect\n    raise on an except if raise == True\n    \"\"\"\n    dtype = pandas_dtype(dtype)\n\n    # if we are passed a datetime64[ns, tz]\n    if is_datetime64tz_dtype(dtype):\n        values = self.values\n        if getattr(values, \"tz\", None) is None:\n            values = DatetimeArray(values).tz_localize(\"UTC\")\n        values = values.tz_convert(dtype.tz)\n        return self.make_block(values)\n\n    # delegate\n    return super().astype(dtype=dtype, copy=copy, errors=errors)",
                "def _can_hold_element(self, element: Any) -> bool:\n    tipo = maybe_infer_dtype_type(element)\n    if tipo is not None:\n        if self.is_datetimetz:\n            # require exact match, since non-nano does not exist\n            return is_dtype_equal(tipo, self.dtype) or is_valid_nat_for_dtype(\n                element, self.dtype\n            )\n\n        # GH#27419 if we get a non-nano datetime64 object\n        return is_datetime64_dtype(tipo)\n    elif element is NaT:\n        return True\n    elif isinstance(element, datetime):\n        if self.is_datetimetz:\n            return tz_compare(element.tzinfo, self.dtype.tz)\n        return element.tzinfo is None\n\n    return is_valid_nat_for_dtype(element, self.dtype)",
                "def to_native_types(\n    self, slicer=None, na_rep=None, date_format=None, quoting=None, **kwargs\n):\n    \"\"\" convert to our native types format, slicing if desired \"\"\"\n\n    values = self.values\n    i8values = self.values.view(\"i8\")\n\n    if slicer is not None:\n        values = values[..., slicer]\n        i8values = i8values[..., slicer]\n\n    from pandas.io.formats.format import _get_format_datetime64_from_values\n\n    fmt = _get_format_datetime64_from_values(values, date_format)\n\n    result = tslib.format_array_from_datetime(\n        i8values.ravel(),\n        tz=getattr(self.values, \"tz\", None),\n        format=fmt,\n        na_rep=na_rep,\n    ).reshape(i8values.shape)\n    return np.atleast_2d(result)",
                "def should_store(self, value):\n    return (\n        issubclass(value.dtype.type, np.datetime64)\n        and not is_datetime64tz_dtype(value)\n        and not is_extension_array_dtype(value)\n    )",
                "def set(self, locs, values):\n    \"\"\"\n    Modify Block in-place with new item value\n\n    Returns\n    -------\n    None\n    \"\"\"\n    values = conversion.ensure_datetime64ns(values, copy=False)\n\n    self.values[locs] = values",
                "def external_values(self):\n    return np.asarray(self.values.astype(\"datetime64[ns]\", copy=False))",
                "def array_values(self) -> ExtensionArray:\n    return DatetimeArray._simple_new(self.values)",
                "@property\ndef _holder(self):\n    return DatetimeArray",
                "def _maybe_coerce_values(self, values):\n    \"\"\"Input validation for values passed to __init__. Ensure that\n    we have datetime64TZ, coercing if necessary.\n\n    Parameters\n    ----------\n    values : array-like\n        Must be convertible to datetime64\n\n    Returns\n    -------\n    values : DatetimeArray\n    \"\"\"\n    if not isinstance(values, self._holder):\n        values = self._holder(values)\n\n    if values.tz is None:\n        raise ValueError(\"cannot create a DatetimeTZBlock without a tz\")\n\n    return values",
                "@property\ndef is_view(self):\n    \"\"\" return a boolean if I am possibly a view \"\"\"\n    # check the ndarray values of the DatetimeIndex values\n    return self.values._data.base is not None",
                "def get_values(self, dtype=None):\n    \"\"\"\n    Returns an ndarray of values.\n\n    Parameters\n    ----------\n    dtype : np.dtype\n        Only `object`-like dtypes are respected here (not sure\n        why).\n\n    Returns\n    -------\n    values : ndarray\n        When ``dtype=object``, then and object-dtype ndarray of\n        boxed values is returned. Otherwise, an M8[ns] ndarray\n        is returned.\n\n        DatetimeArray is always 1-d. ``get_values`` will reshape\n        the return value to be the same dimensionality as the\n        block.\n    \"\"\"\n    values = self.values\n    if is_object_dtype(dtype):\n        values = values.astype(object)\n\n    values = np.asarray(values)\n\n    if self.ndim == 2:\n        # Ensure that our shape is correct for DataFrame.\n        # ExtensionArrays are always 1-D, even in a DataFrame when\n        # the analogous NumPy-backed column would be a 2-D ndarray.\n        values = values.reshape(1, -1)\n    return values",
                "def to_dense(self):\n    # we request M8[ns] dtype here, even though it discards tzinfo,\n    # as lots of code (e.g. anything using values_from_object)\n    # expects that behavior.\n    return np.asarray(self.values, dtype=_NS_DTYPE)",
                "def _slice(self, slicer):\n    \"\"\" return a slice of my values \"\"\"\n    if isinstance(slicer, tuple):\n        col, loc = slicer\n        if not com.is_null_slice(col) and col != 0:\n            raise IndexError(f\"{self} only contains one item\")\n        return self.values[loc]\n    return self.values[slicer]",
                "def diff(self, n: int, axis: int = 0) -> List[\"Block\"]:\n    \"\"\"\n    1st discrete difference.\n\n    Parameters\n    ----------\n    n : int\n        Number of periods to diff.\n    axis : int, default 0\n        Axis to diff upon.\n\n    Returns\n    -------\n    A list with a new TimeDeltaBlock.\n\n    Notes\n    -----\n    The arguments here are mimicking shift so they are called correctly\n    by apply.\n    \"\"\"\n    if axis == 0:\n        # Cannot currently calculate diff across multiple blocks since this\n        # function is invoked via apply\n        raise NotImplementedError\n    new_values = (self.values - self.shift(n, axis=axis)[0].values).asi8\n\n    # Reshape the new_values like how algos.diff does for timedelta data\n    new_values = new_values.reshape(1, len(new_values))\n    new_values = new_values.astype(\"timedelta64[ns]\")\n    return [TimeDeltaBlock(new_values, placement=self.mgr_locs.indexer)]",
                "def concat_same_type(self, to_concat, placement=None):\n    # need to handle concat([tz1, tz2]) here, since DatetimeArray\n    # only handles cases where all the tzs are the same.\n    # Instead of placing the condition here, it could also go into the\n    # is_uniform_join_units check, but I'm not sure what is better.\n    if len({x.dtype for x in to_concat}) > 1:\n        values = concat_datetime([x.values for x in to_concat])\n        placement = placement or slice(0, len(values), 1)\n\n        if self.ndim > 1:\n            values = np.atleast_2d(values)\n        return ObjectBlock(values, ndim=self.ndim, placement=placement)\n    return super().concat_same_type(to_concat, placement)",
                "def fillna(self, value, limit=None, inplace=False, downcast=None):\n    # We support filling a DatetimeTZ with a `value` whose timezone\n    # is different by coercing to object.\n    if self._can_hold_element(value):\n        return super().fillna(value, limit, inplace, downcast)\n\n    # different timezones, or a non-tz\n    return self.astype(object).fillna(\n        value, limit=limit, inplace=inplace, downcast=downcast\n    )",
                "def setitem(self, indexer, value):\n    # https://github.com/pandas-dev/pandas/issues/24020\n    # Need a dedicated setitem until #24020 (type promotion in setitem\n    # for extension arrays) is designed and implemented.\n    if self._can_hold_element(value) or (\n        isinstance(indexer, np.ndarray) and indexer.size == 0\n    ):\n        return super().setitem(indexer, value)\n\n    obj_vals = self.values.astype(object)\n    newb = make_block(\n        obj_vals, placement=self.mgr_locs, klass=ObjectBlock, ndim=self.ndim\n    )\n    return newb.setitem(indexer, value)",
                "def equals(self, other) -> bool:\n    # override for significant performance improvement\n    if self.dtype != other.dtype or self.shape != other.shape:\n        return False\n    return (self.values.view(\"i8\") == other.values.view(\"i8\")).all()",
                "def quantile(self, qs, interpolation=\"linear\", axis=0):\n    naive = self.values.view(\"M8[ns]\")\n\n    # kludge for 2D block with 1D values\n    naive = naive.reshape(self.shape)\n\n    blk = self.make_block(naive)\n    res_blk = blk.quantile(qs, interpolation=interpolation, axis=axis)\n\n    # ravel is kludge for 2D block with 1D values, assumes column-like\n    aware = self._holder(res_blk.values.ravel(), dtype=self.dtype)\n    return self.make_block_same_class(aware, ndim=res_blk.ndim)",
                "def __init__(self, values, placement, ndim=None):\n    if values.dtype != _TD_DTYPE:\n        values = conversion.ensure_timedelta64ns(values)\n    if isinstance(values, TimedeltaArray):\n        values = values._data\n    assert isinstance(values, np.ndarray), type(values)\n    super().__init__(values, placement=placement, ndim=ndim)",
                "@property\ndef _holder(self):\n    return TimedeltaArray",
                "def _can_hold_element(self, element: Any) -> bool:\n    tipo = maybe_infer_dtype_type(element)\n    if tipo is not None:\n        return issubclass(tipo.type, np.timedelta64)\n    elif element is NaT:\n        return True\n    elif isinstance(element, (timedelta, np.timedelta64)):\n        return True\n    return is_valid_nat_for_dtype(element, self.dtype)",
                "def fillna(self, value, **kwargs):\n\n    # allow filling with integers to be\n    # interpreted as nanoseconds\n    if is_integer(value):\n        # Deprecation GH#24694, GH#19233\n        raise TypeError(\n            \"Passing integers to fillna for timedelta64[ns] dtype is no \"\n            \"longer supported.  To obtain the old behavior, pass \"\n            \"`pd.Timedelta(seconds=n)` instead.\"\n        )\n    return super().fillna(value, **kwargs)",
                "def should_store(self, value):\n    return issubclass(\n        value.dtype.type, np.timedelta64\n    ) and not is_extension_array_dtype(value)",
                "def to_native_types(self, slicer=None, na_rep=None, quoting=None, **kwargs):\n    \"\"\" convert to our native types format, slicing if desired \"\"\"\n\n    values = self.values\n    if slicer is not None:\n        values = values[:, slicer]\n    mask = isna(values)\n\n    rvalues = np.empty(values.shape, dtype=object)\n    if na_rep is None:\n        na_rep = \"NaT\"\n    rvalues[mask] = na_rep\n    imask = (~mask).ravel()\n\n    # FIXME:\n    # should use the formats.format.Timedelta64Formatter here\n    # to figure what format to pass to the Timedelta\n    # e.g. to not show the decimals say\n    rvalues.flat[imask] = np.array(\n        [Timedelta(val)._repr_base(format=\"all\") for val in values.ravel()[imask]],\n        dtype=object,\n    )\n    return rvalues",
                "def external_values(self):\n    return np.asarray(self.values.astype(\"timedelta64[ns]\", copy=False))",
                "def array_values(self) -> ExtensionArray:\n    return TimedeltaArray._simple_new(self.values)",
                "def _can_hold_element(self, element: Any) -> bool:\n    tipo = maybe_infer_dtype_type(element)\n    if tipo is not None:\n        return issubclass(tipo.type, np.bool_)\n    return isinstance(element, (bool, np.bool_))",
                "def should_store(self, value):\n    return issubclass(value.dtype.type, np.bool_) and not is_extension_array_dtype(\n        value\n    )",
                "def replace(\n    self, to_replace, value, inplace=False, filter=None, regex=False, convert=True\n):\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    to_replace_values = np.atleast_1d(to_replace)\n    if not np.can_cast(to_replace_values, bool):\n        return self\n    return super().replace(\n        to_replace,\n        value,\n        inplace=inplace,\n        filter=filter,\n        regex=regex,\n        convert=convert,\n    )",
                "def __init__(self, values, placement=None, ndim=2):\n    if issubclass(values.dtype.type, str):\n        values = np.array(values, dtype=object)\n\n    super().__init__(values, ndim=ndim, placement=placement)",
                "@property\ndef is_bool(self):\n    \"\"\" we can be a bool if we have only bool values but are of type\n    object\n    \"\"\"\n    return lib.is_bool_array(self.values.ravel())",
                "def convert(\n    self,\n    copy: bool = True,\n    datetime: bool = True,\n    numeric: bool = True,\n    timedelta: bool = True,\n    coerce: bool = False,\n):\n    \"\"\" attempt to coerce any object types to better types return a copy of\n    the block (if copy = True) by definition we ARE an ObjectBlock!!!!!\n\n    can return multiple blocks!\n    \"\"\"\n\n    # operate column-by-column\n    def f(mask, val, idx):\n        shape = val.shape\n        values = soft_convert_objects(\n            val.ravel(),\n            datetime=datetime,\n            numeric=numeric,\n            timedelta=timedelta,\n            coerce=coerce,\n            copy=copy,\n        )\n        if isinstance(values, np.ndarray):\n            # TODO: allow EA once reshape is supported\n            values = values.reshape(shape)\n\n        values = _block_shape(values, ndim=self.ndim)\n        return values\n\n    if self.ndim == 2:\n        blocks = self.split_and_operate(None, f, False)\n    else:\n        values = f(None, self.values.ravel(), None)\n        blocks = [make_block(values, ndim=self.ndim, placement=self.mgr_locs)]\n\n    return blocks",
                "def _maybe_downcast(self, blocks: List[\"Block\"], downcast=None) -> List[\"Block\"]:\n\n    if downcast is not None:\n        return blocks\n\n    # split and convert the blocks\n    return _extend_blocks([b.convert(datetime=True, numeric=False) for b in blocks])",
                "def _can_hold_element(self, element: Any) -> bool:\n    return True",
                "def should_store(self, value):\n    return not (\n        issubclass(\n            value.dtype.type,\n            (np.integer, np.floating, np.complexfloating, np.datetime64, np.bool_),\n        )\n        or is_extension_array_dtype(value)\n    )",
                "def replace(\n    self, to_replace, value, inplace=False, filter=None, regex=False, convert=True\n):\n    to_rep_is_list = is_list_like(to_replace)\n    value_is_list = is_list_like(value)\n    both_lists = to_rep_is_list and value_is_list\n    either_list = to_rep_is_list or value_is_list\n\n    result_blocks = []\n    blocks = [self]\n\n    if not either_list and is_re(to_replace):\n        return self._replace_single(\n            to_replace,\n            value,\n            inplace=inplace,\n            filter=filter,\n            regex=True,\n            convert=convert,\n        )\n    elif not (either_list or regex):\n        return super().replace(\n            to_replace,\n            value,\n            inplace=inplace,\n            filter=filter,\n            regex=regex,\n            convert=convert,\n        )\n    elif both_lists:\n        for to_rep, v in zip(to_replace, value):\n            result_blocks = []\n            for b in blocks:\n                result = b._replace_single(\n                    to_rep,\n                    v,\n                    inplace=inplace,\n                    filter=filter,\n                    regex=regex,\n                    convert=convert,\n                )\n                result_blocks = _extend_blocks(result, result_blocks)\n            blocks = result_blocks\n        return result_blocks\n\n    elif to_rep_is_list and regex:\n        for to_rep in to_replace:\n            result_blocks = []\n            for b in blocks:\n                result = b._replace_single(\n                    to_rep,\n                    value,\n                    inplace=inplace,\n                    filter=filter,\n                    regex=regex,\n                    convert=convert,\n                )\n                result_blocks = _extend_blocks(result, result_blocks)\n            blocks = result_blocks\n        return result_blocks\n\n    return self._replace_single(\n        to_replace,\n        value,\n        inplace=inplace,\n        filter=filter,\n        convert=convert,\n        regex=regex,\n    )",
                "def _replace_single(\n    self,\n    to_replace,\n    value,\n    inplace=False,\n    filter=None,\n    regex=False,\n    convert=True,\n    mask=None,\n):\n    \"\"\"\n    Replace elements by the given value.\n\n    Parameters\n    ----------\n    to_replace : object or pattern\n        Scalar to replace or regular expression to match.\n    value : object\n        Replacement object.\n    inplace : bool, default False\n        Perform inplace modification.\n    filter : list, optional\n    regex : bool, default False\n        If true, perform regular expression substitution.\n    convert : bool, default True\n        If true, try to coerce any object types to better types.\n    mask : array-like of bool, optional\n        True indicate corresponding element is ignored.\n\n    Returns\n    -------\n    a new block, the result after replacing\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n\n    # to_replace is regex compilable\n    to_rep_re = regex and is_re_compilable(to_replace)\n\n    # regex is regex compilable\n    regex_re = is_re_compilable(regex)\n\n    # only one will survive\n    if to_rep_re and regex_re:\n        raise AssertionError(\n            \"only one of to_replace and regex can be regex compilable\"\n        )\n\n    # if regex was passed as something that can be a regex (rather than a\n    # boolean)\n    if regex_re:\n        to_replace = regex\n\n    regex = regex_re or to_rep_re\n\n    # try to get the pattern attribute (compiled re) or it's a string\n    if is_re(to_replace):\n        pattern = to_replace.pattern\n    else:\n        pattern = to_replace\n\n    # if the pattern is not empty and to_replace is either a string or a\n    # regex\n    if regex and pattern:\n        rx = re.compile(to_replace)\n    else:\n        # if the thing to replace is not a string or compiled regex call\n        # the superclass method -> to_replace is some kind of object\n        return super().replace(\n            to_replace, value, inplace=inplace, filter=filter, regex=regex\n        )\n\n    new_values = self.values if inplace else self.values.copy()\n\n    # deal with replacing values with objects (strings) that match but\n    # whose replacement is not a string (numeric, nan, object)\n    if isna(value) or not isinstance(value, str):\n\n        def re_replacer(s):\n            if is_re(rx) and isinstance(s, str):\n                return value if rx.search(s) is not None else s\n            else:\n                return s\n\n    else:\n        # value is guaranteed to be a string here, s can be either a string\n        # or null if it's null it gets returned\n        def re_replacer(s):\n            if is_re(rx) and isinstance(s, str):\n                return rx.sub(value, s)\n            else:\n                return s\n\n    f = np.vectorize(re_replacer, otypes=[self.dtype])\n\n    if filter is None:\n        filt = slice(None)\n    else:\n        filt = self.mgr_locs.isin(filter).nonzero()[0]\n\n    if mask is None:\n        new_values[filt] = f(new_values[filt])\n    else:\n        new_values[filt][mask] = f(new_values[filt][mask])\n\n    # convert\n    block = self.make_block(new_values)\n    if convert:\n        block = block.convert(numeric=False)\n    return block",
                "def _replace_coerce(\n    self, to_replace, value, inplace=True, regex=False, convert=False, mask=None\n):\n    \"\"\"\n    Replace value corresponding to the given boolean array with another\n    value.\n\n    Parameters\n    ----------\n    to_replace : object or pattern\n        Scalar to replace or regular expression to match.\n    value : object\n        Replacement object.\n    inplace : bool, default False\n        Perform inplace modification.\n    regex : bool, default False\n        If true, perform regular expression substitution.\n    convert : bool, default True\n        If true, try to coerce any object types to better types.\n    mask : array-like of bool, optional\n        True indicate corresponding element is ignored.\n\n    Returns\n    -------\n    A new block if there is anything to replace or the original block.\n    \"\"\"\n    if mask.any():\n        block = super()._replace_coerce(\n            to_replace=to_replace,\n            value=value,\n            inplace=inplace,\n            regex=regex,\n            convert=convert,\n            mask=mask,\n        )\n        if convert:\n            block = [b.convert(numeric=False, copy=True) for b in block]\n        return block\n    if convert:\n        return [self.convert(numeric=False, copy=True)]\n    return self",
                "def __init__(self, values, placement, ndim=None):\n    # coerce to categorical if we can\n    values = extract_array(values)\n    assert isinstance(values, Categorical), type(values)\n    super().__init__(values, placement=placement, ndim=ndim)",
                "@property\ndef _holder(self):\n    return Categorical",
                "@property\ndef array_dtype(self):\n    \"\"\" the dtype to return if I want to construct this block as an\n    array\n    \"\"\"\n    return np.object_",
                "def to_dense(self):\n    # Categorical.get_values returns a DatetimeIndex for datetime\n    # categories, so we can't simply use `np.asarray(self.values)` like\n    # other types.\n    return self.values._internal_get_values()",
                "def to_native_types(self, slicer=None, na_rep=\"\", quoting=None, **kwargs):\n    \"\"\" convert to our native types format, slicing if desired \"\"\"\n\n    values = self.values\n    if slicer is not None:\n        # Categorical is always one dimension\n        values = values[slicer]\n    mask = isna(values)\n    values = np.array(values, dtype=\"object\")\n    values[mask] = na_rep\n\n    # we are expected to return a 2-d ndarray\n    return values.reshape(1, len(values))",
                "def concat_same_type(self, to_concat, placement=None):\n    \"\"\"\n    Concatenate list of single blocks of the same type.\n\n    Note that this CategoricalBlock._concat_same_type *may* not\n    return a CategoricalBlock. When the categories in `to_concat`\n    differ, this will return an object ndarray.\n\n    If / when we decide we don't like that behavior:\n\n    1. Change Categorical._concat_same_type to use union_categoricals\n    2. Delete this method.\n    \"\"\"\n    values = self._concatenator(\n        [blk.values for blk in to_concat], axis=self.ndim - 1\n    )\n    # not using self.make_block_same_class as values can be object dtype\n    return make_block(\n        values, placement=placement or slice(0, len(values), 1), ndim=self.ndim\n    )",
                "def replace(\n    self,\n    to_replace,\n    value,\n    inplace: bool = False,\n    filter=None,\n    regex: bool = False,\n    convert: bool = True,\n):\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    result = self if inplace else self.copy()\n    if filter is None:  # replace was called on a series\n        result.values.replace(to_replace, value, inplace=True)\n        if convert:\n            return result.convert(numeric=False, copy=not inplace)\n        else:\n            return result\n    else:  # replace was called on a DataFrame\n        if not isna(value):\n            result.values.add_categories(value, inplace=True)\n        return super(CategoricalBlock, result).replace(\n            to_replace, value, inplace, filter, regex, convert\n        )",
                "def _putmask_preserve(nv, n):\n    try:\n        nv[mask] = n[mask]\n    except (IndexError, ValueError):\n        nv[mask] = n\n    return nv",
                "def f(mask, val, idx):\n    block = self.coerce_to_target_dtype(value)\n\n    # slice out our block\n    if idx is not None:\n        # i.e. self.ndim == 2\n        block = block.getitem_block(slice(idx, idx + 1))\n    return block.fillna(value, limit=limit, inplace=inplace, downcast=None)",
                "def make_a_block(nv, ref_loc):\n    if isinstance(nv, list):\n        assert len(nv) == 1, nv\n        assert isinstance(nv[0], Block)\n        block = nv[0]\n    else:\n        # Put back the dimension that was taken from it and make\n        # a block out of the result.\n        nv = _block_shape(nv, ndim=self.ndim)\n        block = self.make_block(values=nv, placement=ref_loc)\n    return block",
                "def f(mask, val, idx):\n    val = maybe_downcast_to_dtype(val, dtype=\"infer\")\n    return val",
                "def check_int_bool(self, inplace):\n    # Only FloatBlocks will contain NaNs.\n    # timedelta subclasses IntBlock\n    if (self.is_bool or self.is_integer) and not self.is_timedelta:\n        if inplace:\n            return self\n        else:\n            return self.copy()",
                "def func(x):\n\n    # process a 1-d slice, returning it\n    # should the axis argument be handled below in apply_along_axis?\n    # i.e. not an arg to missing.interpolate_1d\n    return missing.interpolate_1d(\n        index,\n        x,\n        method=method,\n        limit=limit,\n        limit_direction=limit_direction,\n        limit_area=limit_area,\n        fill_value=fill_value,\n        bounds_error=False,\n        **kwargs,\n    )",
                "def where_func(cond, values, other):\n\n    if not (\n        (self.is_integer or self.is_bool)\n        and lib.is_float(other)\n        and np.isnan(other)\n    ):\n        # np.where will cast integer array to floats in this case\n        if not self._can_hold_element(other):\n            raise TypeError\n        if lib.is_scalar(other) and isinstance(values, np.ndarray):\n            # convert datetime to datetime64, timedelta to timedelta64\n            other = convert_scalar_for_putitemlike(other, values.dtype)\n\n    # By the time we get here, we should have all Series/Index\n    #  args extracted to  ndarray\n    fastres = expressions.where(cond, values, other)\n    return fastres",
                "def f(mask, val, idx):\n    shape = val.shape\n    values = soft_convert_objects(\n        val.ravel(),\n        datetime=datetime,\n        numeric=numeric,\n        timedelta=timedelta,\n        coerce=coerce,\n        copy=copy,\n    )\n    if isinstance(values, np.ndarray):\n        # TODO: allow EA once reshape is supported\n        values = values.reshape(shape)\n\n    values = _block_shape(values, ndim=self.ndim)\n    return values",
                "def re_replacer(s):\n    if is_re(rx) and isinstance(s, str):\n        return value if rx.search(s) is not None else s\n    else:\n        return s",
                "def re_replacer(s):\n    if is_re(rx) and isinstance(s, str):\n        return rx.sub(value, s)\n    else:\n        return s",
                "def f(mask, val, idx):\n\n    if idx is None:\n        # ndim==1 case.\n        n = new\n    else:\n\n        if isinstance(new, np.ndarray):\n            n = np.squeeze(new[idx % new.shape[0]])\n        else:\n            n = np.array(new)\n\n        # type of the new block\n        dtype, _ = maybe_promote(n.dtype)\n\n        # we need to explicitly astype here to make a copy\n        n = n.astype(dtype)\n\n    nv = _putmask_smart(val, mask, n)\n    return nv"
            ],
            "inscope_function_signatures": [
                "get_block_type(values, dtype=None)",
                "make_block(values, placement, klass=None, ndim=None, dtype=None)",
                "_extend_blocks(result, blocks=None)",
                "_block_shape(values, ndim=1, shape=None)",
                "_merge_blocks(blocks, dtype=None, _can_consolidate=True)",
                "_safe_reshape(arr, new_shape)",
                "_putmask_smart(v, mask, n)",
                "__init__(self, values, placement, ndim=None)",
                "_check_ndim(self, values, ndim)",
                "_holder(self)",
                "_consolidate_key(self)",
                "_is_single_block(self)",
                "is_view(self)",
                "is_datelike(self)",
                "is_categorical_astype(self, dtype)",
                "external_values(self)",
                "internal_values(self)",
                "array_values(self) -> ExtensionArray",
                "get_values(self, dtype=None)",
                "get_block_values(self, dtype=None)",
                "to_dense(self)",
                "fill_value(self)",
                "mgr_locs(self)",
                "mgr_locs(self, new_mgr_locs)",
                "array_dtype(self)",
                "make_block(self, values, placement=None) -> 'Block'",
                "make_block_same_class(self, values, placement=None, ndim=None)",
                "__repr__(self) -> str",
                "__len__(self) -> int",
                "__getstate__(self)",
                "__setstate__(self, state)",
                "_slice(self, slicer)",
                "getitem_block(self, slicer, new_mgr_locs=None)",
                "shape(self)",
                "dtype(self)",
                "ftype(self)",
                "merge(self, other)",
                "concat_same_type(self, to_concat, placement=None)",
                "iget(self, i)",
                "set(self, locs, values)",
                "delete(self, loc)",
                "apply(self, func, **kwargs) -> List['Block']",
                "_split_op_result(self, result) -> List['Block']",
                "fillna(self, value, limit=None, inplace=False, downcast=None)",
                "split_and_operate(self, mask, f, inplace: bool)",
                "_maybe_downcast(self, blocks: List['Block'], downcast=None) -> List['Block']",
                "downcast(self, dtypes=None)",
                "astype(self, dtype, copy: bool=False, errors: str='raise')",
                "convert(self, copy: bool=True, datetime: bool=True, numeric: bool=True, timedelta: bool=True, coerce: bool=False)",
                "_can_hold_element(self, element: Any) -> bool",
                "to_native_types(self, slicer=None, na_rep='nan', quoting=None, **kwargs)",
                "copy(self, deep=True)",
                "replace(self, to_replace, value, inplace=False, filter=None, regex=False, convert=True)",
                "_replace_single(self, *args, **kwargs)",
                "setitem(self, indexer, value)",
                "putmask(self, mask, new, align=True, inplace=False, axis=0, transpose=False)",
                "coerce_to_target_dtype(self, other)",
                "interpolate(self, method='pad', axis=0, index=None, values=None, inplace=False, limit=None, limit_direction='forward', limit_area=None, fill_value=None, coerce=False, downcast=None, **kwargs)",
                "_interpolate_with_fill(self, method='pad', axis=0, inplace=False, limit=None, fill_value=None, coerce=False, downcast=None)",
                "_interpolate(self, method=None, index=None, values=None, fill_value=None, axis=0, limit=None, limit_direction='forward', limit_area=None, inplace=False, downcast=None, **kwargs)",
                "take_nd(self, indexer, axis, new_mgr_locs=None, fill_tuple=None)",
                "diff(self, n: int, axis: int=1) -> List['Block']",
                "shift(self, periods, axis=0, fill_value=None)",
                "where(self, other, cond, align=True, errors='raise', try_cast: bool=False, axis: int=0) -> List['Block']",
                "equals(self, other) -> bool",
                "_unstack(self, unstacker_func, new_columns, n_rows, fill_value)",
                "quantile(self, qs, interpolation='linear', axis=0)",
                "_replace_coerce(self, to_replace, value, inplace=True, regex=False, convert=False, mask=None)",
                "__init__(self, values, placement, ndim=None)",
                "shape(self)",
                "iget(self, col)",
                "should_store(self, value)",
                "set(self, locs, values, check=False)",
                "putmask(self, mask, new, align=True, inplace=False, axis=0, transpose=False)",
                "_get_unstack_items(self, unstacker, new_columns)",
                "__init__(self, values, placement, ndim=None)",
                "_maybe_coerce_values(self, values)",
                "_holder(self)",
                "fill_value(self)",
                "_can_hold_na(self)",
                "is_view(self)",
                "is_numeric(self)",
                "setitem(self, indexer, value)",
                "get_values(self, dtype=None)",
                "array_values(self) -> ExtensionArray",
                "to_dense(self)",
                "to_native_types(self, slicer=None, na_rep='nan', quoting=None, **kwargs)",
                "take_nd(self, indexer, axis=0, new_mgr_locs=None, fill_tuple=None)",
                "_can_hold_element(self, element: Any) -> bool",
                "_slice(self, slicer)",
                "concat_same_type(self, to_concat, placement=None)",
                "fillna(self, value, limit=None, inplace=False, downcast=None)",
                "interpolate(self, method='pad', axis=0, inplace=False, limit=None, fill_value=None, **kwargs)",
                "diff(self, n: int, axis: int=1) -> List['Block']",
                "shift(self, periods: int, axis: libinternals.BlockPlacement=0, fill_value: Any=None) -> List['ExtensionBlock']",
                "where(self, other, cond, align=True, errors='raise', try_cast: bool=False, axis: int=0) -> List['Block']",
                "_ftype(self)",
                "_unstack(self, unstacker_func, new_columns, n_rows, fill_value)",
                "external_values(self)",
                "equals(self, other) -> bool",
                "_can_hold_element(self, element: Any) -> bool",
                "to_native_types(self, slicer=None, na_rep='', float_format=None, decimal='.', quoting=None, **kwargs)",
                "should_store(self, value)",
                "_can_hold_element(self, element: Any) -> bool",
                "should_store(self, value)",
                "_can_hold_element(self, element: Any) -> bool",
                "should_store(self, value)",
                "_holder(self)",
                "fill_value(self)",
                "get_values(self, dtype=None)",
                "internal_values(self)",
                "iget(self, key)",
                "__init__(self, values, placement, ndim=None)",
                "_can_hold_na(self)",
                "_maybe_coerce_values(self, values)",
                "astype(self, dtype, copy: bool=False, errors: str='raise')",
                "_can_hold_element(self, element: Any) -> bool",
                "to_native_types(self, slicer=None, na_rep=None, date_format=None, quoting=None, **kwargs)",
                "should_store(self, value)",
                "set(self, locs, values)",
                "external_values(self)",
                "array_values(self) -> ExtensionArray",
                "_holder(self)",
                "_maybe_coerce_values(self, values)",
                "is_view(self)",
                "get_values(self, dtype=None)",
                "to_dense(self)",
                "_slice(self, slicer)",
                "diff(self, n: int, axis: int=0) -> List['Block']",
                "concat_same_type(self, to_concat, placement=None)",
                "fillna(self, value, limit=None, inplace=False, downcast=None)",
                "setitem(self, indexer, value)",
                "equals(self, other) -> bool",
                "quantile(self, qs, interpolation='linear', axis=0)",
                "__init__(self, values, placement, ndim=None)",
                "_holder(self)",
                "_can_hold_element(self, element: Any) -> bool",
                "fillna(self, value, **kwargs)",
                "should_store(self, value)",
                "to_native_types(self, slicer=None, na_rep=None, quoting=None, **kwargs)",
                "external_values(self)",
                "array_values(self) -> ExtensionArray",
                "_can_hold_element(self, element: Any) -> bool",
                "should_store(self, value)",
                "replace(self, to_replace, value, inplace=False, filter=None, regex=False, convert=True)",
                "__init__(self, values, placement=None, ndim=2)",
                "is_bool(self)",
                "convert(self, copy: bool=True, datetime: bool=True, numeric: bool=True, timedelta: bool=True, coerce: bool=False)",
                "_maybe_downcast(self, blocks: List['Block'], downcast=None) -> List['Block']",
                "_can_hold_element(self, element: Any) -> bool",
                "should_store(self, value)",
                "replace(self, to_replace, value, inplace=False, filter=None, regex=False, convert=True)",
                "_replace_single(self, to_replace, value, inplace=False, filter=None, regex=False, convert=True, mask=None)",
                "_replace_coerce(self, to_replace, value, inplace=True, regex=False, convert=False, mask=None)",
                "__init__(self, values, placement, ndim=None)",
                "_holder(self)",
                "array_dtype(self)",
                "to_dense(self)",
                "to_native_types(self, slicer=None, na_rep='', quoting=None, **kwargs)",
                "concat_same_type(self, to_concat, placement=None)",
                "replace(self, to_replace, value, inplace: bool=False, filter=None, regex: bool=False, convert: bool=True)",
                "_putmask_preserve(nv, n)",
                "f(mask, val, idx)",
                "make_a_block(nv, ref_loc)",
                "f(mask, val, idx)",
                "check_int_bool(self, inplace)",
                "func(x)",
                "where_func(cond, values, other)",
                "f(mask, val, idx)",
                "re_replacer(s)",
                "re_replacer(s)",
                "f(mask, val, idx)"
            ],
            "variables_in_file": {
                "PandasObject": [
                    91
                ],
                "__slots__": [
                    2592,
                    99,
                    2022,
                    2118,
                    2028,
                    2893,
                    2481,
                    2038,
                    2102,
                    2300,
                    2173,
                    2559
                ],
                "is_numeric": [
                    2484,
                    100,
                    2023
                ],
                "is_float": [
                    101,
                    2039
                ],
                "is_integer": [
                    2513,
                    2130,
                    102,
                    2119
                ],
                "is_complex": [
                    2103,
                    103
                ],
                "is_datetime": [
                    104,
                    2174
                ],
                "is_datetimetz": [
                    105,
                    2301
                ],
                "is_timedelta": [
                    2482,
                    106
                ],
                "is_bool": [
                    2560,
                    107
                ],
                "is_object": [
                    2593,
                    108
                ],
                "is_categorical": [
                    109,
                    2894,
                    3005
                ],
                "is_extension": [
                    1729,
                    110,
                    2302
                ],
                "_can_hold_na": [
                    2561,
                    2594,
                    2024,
                    2120,
                    111,
                    2896,
                    2483
                ],
                "_can_consolidate": [
                    112,
                    3093,
                    1599
                ],
                "_verify_integrity": [
                    1600,
                    113,
                    2895
                ],
                "_validate_ndim": [
                    1601,
                    114
                ],
                "_ftype": [
                    115
                ],
                "_concatenator": [
                    2897,
                    116
                ],
                "staticmethod": [
                    2897,
                    116
                ],
                "np.concatenate": [
                    116,
                    3101
                ],
                "np": [
                    2048,
                    1025,
                    2051,
                    1541,
                    2566,
                    2567,
                    2570,
                    1550,
                    1551,
                    2578,
                    2579,
                    3101,
                    2078,
                    3102,
                    3104,
                    1533,
                    2598,
                    2098,
                    2108,
                    2110,
                    2111,
                    2114,
                    2634,
                    2126,
                    2127,
                    3162,
                    2145,
                    2664,
                    3186,
                    116,
                    2165,
                    2167,
                    3195,
                    640,
                    1677,
                    2206,
                    688,
                    692,
                    1240,
                    2269,
                    2273,
                    2291,
                    245,
                    1270,
                    761,
                    2307,
                    2831,
                    1808,
                    1817,
                    1826,
                    1330,
                    1331,
                    2365,
                    836,
                    2378,
                    2914,
                    870,
                    2930,
                    1401,
                    382,
                    1406,
                    2430,
                    389,
                    2450,
                    1447,
                    2485,
                    1975,
                    2492,
                    3007,
                    2502,
                    1991,
                    3016,
                    969,
                    2505,
                    3018,
                    3019,
                    3021,
                    3023,
                    3025,
                    467,
                    981,
                    2524,
                    3038,
                    991,
                    993,
                    997,
                    2535,
                    1003,
                    2545,
                    2034,
                    1525,
                    1526,
                    2552,
                    1530,
                    2044,
                    2045,
                    1022,
                    1023
                ],
                "self.ndim": [
                    1921,
                    643,
                    2950,
                    2954,
                    273,
                    401,
                    1809,
                    407,
                    280,
                    2456,
                    1437,
                    1314,
                    420,
                    175,
                    309,
                    1333,
                    1848,
                    1214,
                    703,
                    831,
                    2367,
                    968,
                    330,
                    2638,
                    2641,
                    2645,
                    1878,
                    1626,
                    1885,
                    479,
                    1375,
                    1632,
                    484,
                    359,
                    1512,
                    1390,
                    1009,
                    119,
                    123,
                    2429,
                    2431
                ],
                "self": [
                    2065,
                    2098,
                    2128,
                    2133,
                    2152,
                    2153,
                    2154,
                    2155,
                    2159,
                    119,
                    120,
                    121,
                    123,
                    125,
                    126,
                    2177,
                    153,
                    2218,
                    171,
                    2222,
                    175,
                    180,
                    2230,
                    2232,
                    185,
                    2233,
                    2241,
                    2242,
                    2245,
                    2252,
                    2253,
                    211,
                    217,
                    2265,
                    223,
                    231,
                    232,
                    238,
                    2288,
                    241,
                    2291,
                    2294,
                    249,
                    256,
                    263,
                    271,
                    273,
                    2326,
                    278,
                    280,
                    281,
                    2327,
                    285,
                    286,
                    288,
                    2338,
                    292,
                    294,
                    295,
                    301,
                    304,
                    307,
                    308,
                    309,
                    313,
                    2361,
                    2367,
                    326,
                    328,
                    330,
                    2378,
                    333,
                    337,
                    2385,
                    2386,
                    2387,
                    341,
                    345,
                    346,
                    348,
                    349,
                    352,
                    358,
                    359,
                    361,
                    2413,
                    366,
                    2418,
                    376,
                    2429,
                    382,
                    383,
                    2431,
                    2437,
                    390,
                    392,
                    2441,
                    399,
                    401,
                    402,
                    2449,
                    2454,
                    407,
                    2456,
                    2462,
                    2464,
                    417,
                    2467,
                    420,
                    422,
                    2470,
                    424,
                    2472,
                    426,
                    428,
                    2476,
                    430,
                    431,
                    2477,
                    435,
                    439,
                    447,
                    2507,
                    467,
                    469,
                    479,
                    480,
                    2530,
                    484,
                    489,
                    494,
                    2552,
                    2555,
                    514,
                    525,
                    527,
                    530,
                    2580,
                    537,
                    541,
                    556,
                    2607,
                    2638,
                    592,
                    2641,
                    594,
                    2642,
                    596,
                    2644,
                    598,
                    2645,
                    603,
                    605,
                    606,
                    609,
                    611,
                    616,
                    617,
                    621,
                    624,
                    2678,
                    2681,
                    635,
                    641,
                    643,
                    645,
                    646,
                    649,
                    667,
                    671,
                    679,
                    2730,
                    686,
                    700,
                    703,
                    718,
                    721,
                    722,
                    724,
                    729,
                    730,
                    735,
                    746,
                    750,
                    760,
                    2810,
                    769,
                    774,
                    775,
                    778,
                    2831,
                    788,
                    2836,
                    791,
                    794,
                    2844,
                    809,
                    831,
                    835,
                    839,
                    840,
                    2888,
                    2889,
                    860,
                    861,
                    2920,
                    873,
                    2925,
                    2949,
                    2950,
                    904,
                    2954,
                    2967,
                    922,
                    946,
                    952,
                    954,
                    956,
                    968,
                    969,
                    1009,
                    1036,
                    1040,
                    1045,
                    1059,
                    1060,
                    1062,
                    1064,
                    1066,
                    1070,
                    1073,
                    1081,
                    1083,
                    1086,
                    1090,
                    1093,
                    1096,
                    1099,
                    1100,
                    1103,
                    1107,
                    1109,
                    1132,
                    1134,
                    1136,
                    1145,
                    1148,
                    1160,
                    1163,
                    1194,
                    1196,
                    1198,
                    1200,
                    1203,
                    1211,
                    1214,
                    1215,
                    1234,
                    1237,
                    1238,
                    1239,
                    1243,
                    1272,
                    1273,
                    1285,
                    1288,
                    1302,
                    1304,
                    1305,
                    1307,
                    1311,
                    1314,
                    1315,
                    1322,
                    1333,
                    1344,
                    1375,
                    1377,
                    1390,
                    1399,
                    1404,
                    1426,
                    1435,
                    1437,
                    1442,
                    1453,
                    1454,
                    1460,
                    1462,
                    1485,
                    1512,
                    1514,
                    1526,
                    1535,
                    1582,
                    1583,
                    1585,
                    1593,
                    1626,
                    1627,
                    1628,
                    1632,
                    1635,
                    1639,
                    1640,
                    1643,
                    1644,
                    1647,
                    1651,
                    1675,
                    1683,
                    1732,
                    1755,
                    1760,
                    1765,
                    1774,
                    1802,
                    1803,
                    1804,
                    1808,
                    1809,
                    1814,
                    1817,
                    1821,
                    1844,
                    1848,
                    1850,
                    1852,
                    1870,
                    1876,
                    1878,
                    1881,
                    1884,
                    1885,
                    1893,
                    1894,
                    1896,
                    1918,
                    1919,
                    1920,
                    1921,
                    1952,
                    1954,
                    1960,
                    1962,
                    1974,
                    1975,
                    1978,
                    1982,
                    1995,
                    2000,
                    2001,
                    2018,
                    2031,
                    2033
                ],
                "self._check_ndim": [
                    119
                ],
                "values": [
                    1537,
                    3077,
                    3079,
                    3080,
                    3084,
                    3085,
                    527,
                    2065,
                    2067,
                    536,
                    2073,
                    2076,
                    2078,
                    2080,
                    2081,
                    2597,
                    2086,
                    2598,
                    2600,
                    2626,
                    2634,
                    2636,
                    2638,
                    2639,
                    2644,
                    2645,
                    1622,
                    611,
                    2152,
                    617,
                    2153,
                    621,
                    624,
                    627,
                    1651,
                    629,
                    119,
                    121,
                    640,
                    641,
                    2177,
                    643,
                    2178,
                    1675,
                    1166,
                    151,
                    2200,
                    153,
                    2201,
                    2203,
                    156,
                    2204,
                    2206,
                    2207,
                    679,
                    682,
                    683,
                    2218,
                    2219,
                    2220,
                    687,
                    688,
                    1200,
                    690,
                    2221,
                    692,
                    1205,
                    694,
                    695,
                    1206,
                    700,
                    702,
                    703,
                    1214,
                    1732,
                    1733,
                    2252,
                    2256,
                    2261,
                    1750,
                    2286,
                    2288,
                    760,
                    761,
                    765,
                    767,
                    1285,
                    1295,
                    1808,
                    273,
                    1809,
                    1810,
                    1811,
                    2326,
                    2327,
                    281,
                    2329,
                    2332,
                    1821,
                    1823,
                    1824,
                    1826,
                    1827,
                    1830,
                    2361,
                    2363,
                    2365,
                    2371,
                    2372,
                    839,
                    844,
                    1876,
                    1877,
                    1878,
                    2901,
                    2902,
                    1881,
                    1882,
                    859,
                    2903,
                    1885,
                    1377,
                    1380,
                    1893,
                    358,
                    1895,
                    362,
                    875,
                    1388,
                    2413,
                    878,
                    1390,
                    2925,
                    881,
                    2928,
                    2929,
                    884,
                    885,
                    2930,
                    2931,
                    376,
                    2934,
                    2426,
                    2427,
                    1406,
                    894,
                    1408,
                    2430,
                    2431,
                    899,
                    1412,
                    2949,
                    903,
                    1416,
                    2954,
                    909,
                    1421,
                    912,
                    918,
                    921,
                    922,
                    2222,
                    2999,
                    2488,
                    2489,
                    2490,
                    2491,
                    2492,
                    2493,
                    3005,
                    3008,
                    3010,
                    3014,
                    3035,
                    3036,
                    3038,
                    2530,
                    2532,
                    2533,
                    3044,
                    2535,
                    3045,
                    3047,
                    1514,
                    3050,
                    1516,
                    3052,
                    2546,
                    1526,
                    1527,
                    1530,
                    1532
                ],
                "ndim": [
                    2178,
                    3077,
                    1550,
                    1551,
                    150,
                    279,
                    151,
                    281,
                    280,
                    153,
                    156,
                    158,
                    2600,
                    2493,
                    1733,
                    1617,
                    1619,
                    1621,
                    1622,
                    2903,
                    3037,
                    3052,
                    119
                ],
                "self.mgr_locs": [
                    1920,
                    769,
                    643,
                    271,
                    399,
                    2836,
                    278,
                    1302,
                    2456,
                    294,
                    1454,
                    304,
                    307,
                    1850,
                    1978,
                    326,
                    2645,
                    1628,
                    1885,
                    1896,
                    489,
                    494,
                    2418,
                    120,
                    123,
                    126,
                    383
                ],
                "placement": [
                    2432,
                    2178,
                    2954,
                    270,
                    271,
                    273,
                    277,
                    278,
                    281,
                    2600,
                    2493,
                    1733,
                    1613,
                    1614,
                    1618,
                    1877,
                    1622,
                    1878,
                    2903,
                    362,
                    3052,
                    120,
                    2427,
                    2431
                ],
                "self.values": [
                    527,
                    2065,
                    2607,
                    594,
                    596,
                    2644,
                    598,
                    1627,
                    1628,
                    611,
                    1639,
                    1640,
                    2152,
                    2154,
                    2155,
                    1644,
                    1651,
                    121,
                    123,
                    125,
                    1675,
                    671,
                    2218,
                    1200,
                    1203,
                    180,
                    700,
                    2252,
                    2253,
                    1234,
                    211,
                    217,
                    2265,
                    1755,
                    223,
                    1760,
                    231,
                    232,
                    1774,
                    2288,
                    241,
                    2291,
                    2294,
                    760,
                    2810,
                    1285,
                    1802,
                    1803,
                    1808,
                    1814,
                    1817,
                    1821,
                    1311,
                    2338,
                    1322,
                    301,
                    304,
                    308,
                    309,
                    1844,
                    313,
                    2361,
                    839,
                    2378,
                    1870,
                    337,
                    2386,
                    2387,
                    341,
                    345,
                    1881,
                    1377,
                    1893,
                    2920,
                    2413,
                    366,
                    2925,
                    376,
                    382,
                    1919,
                    390,
                    904,
                    2454,
                    2464,
                    417,
                    1954,
                    2467,
                    1962,
                    946,
                    1462,
                    1975,
                    1982,
                    1485,
                    2001,
                    469,
                    2018,
                    2530,
                    2033,
                    2552,
                    2555
                ],
                "self._validate_ndim": [
                    153,
                    330,
                    123
                ],
                "len": [
                    2954,
                    1677,
                    1551,
                    3090,
                    3096,
                    288,
                    1830,
                    301,
                    2427,
                    1865,
                    1618,
                    725,
                    1877,
                    984,
                    473,
                    3162,
                    1627,
                    732,
                    1628,
                    992,
                    362,
                    2416,
                    883,
                    1526,
                    1527,
                    2934,
                    2425,
                    123,
                    125,
                    126
                ],
                "ValueError": [
                    544,
                    3200,
                    995,
                    582,
                    331,
                    2330,
                    785,
                    913,
                    1394,
                    1108,
                    1141,
                    630,
                    154,
                    124,
                    1247
                ],
                "values.ndim": [
                    1537,
                    3077,
                    1388,
                    1390,
                    1809,
                    151,
                    153,
                    156
                ],
                "property": [
                    258,
                    2180,
                    2309,
                    2334,
                    160,
                    169,
                    2602,
                    173,
                    177,
                    182,
                    1980,
                    2495,
                    335,
                    339,
                    343,
                    1752,
                    1624,
                    2905,
                    2139,
                    1757,
                    2909,
                    2143,
                    1762,
                    1767,
                    1772,
                    243,
                    247
                ],
                "self._can_consolidate": [
                    171
                ],
                "self.dtype.name": [
                    649,
                    171
                ],
                "self.dtype": [
                    263,
                    649,
                    2831,
                    1304,
                    2462,
                    288,
                    1952,
                    1059,
                    295,
                    1960,
                    171,
                    2476,
                    1453,
                    2098,
                    1460,
                    2232,
                    2233,
                    1211,
                    1086,
                    2242,
                    2245,
                    2507,
                    2128,
                    2133,
                    346,
                    603,
                    860,
                    348,
                    2031
                ],
                "self.values.base": [
                    180
                ],
                "self.is_datetime": [
                    185,
                    514,
                    1081,
                    1073
                ],
                "self.is_timedelta": [
                    514,
                    1096,
                    1099,
                    1132,
                    185
                ],
                "dtype": [
                    1028,
                    1031,
                    3209,
                    3211,
                    3212,
                    3214,
                    3095,
                    671,
                    1057,
                    674,
                    675,
                    1059,
                    1062,
                    1958,
                    1960,
                    2214,
                    2217,
                    1067,
                    2221,
                    2225,
                    1074,
                    1075,
                    1975,
                    1080,
                    2999,
                    2362,
                    3000,
                    3002,
                    1087,
                    192,
                    195,
                    3012,
                    197,
                    584,
                    1096,
                    586,
                    1099,
                    592,
                    3025,
                    851,
                    596,
                    1107,
                    598,
                    855,
                    600,
                    346,
                    603,
                    348,
                    349,
                    859,
                    860,
                    861,
                    3040,
                    3041,
                    611,
                    3044,
                    613,
                    230,
                    2151,
                    3045,
                    874,
                    875,
                    3050,
                    238,
                    624,
                    629
                ],
                "Categorical": [
                    192,
                    904,
                    2902,
                    598,
                    2907
                ],
                "CategoricalDtype": [
                    192
                ],
                "TypeError": [
                    3168,
                    195,
                    647,
                    589,
                    1422,
                    785,
                    1970,
                    2515,
                    1108,
                    630,
                    1405
                ],
                "is_categorical_dtype": [
                    594,
                    899,
                    197,
                    898
                ],
                "PandasArray": [
                    223
                ],
                "ExtensionArray": [
                    2293,
                    2554,
                    219,
                    1813
                ],
                "is_object_dtype": [
                    1062,
                    230,
                    2151,
                    746,
                    3211,
                    788,
                    2362
                ],
                "self.values.astype": [
                    2018,
                    611,
                    231,
                    2291,
                    596,
                    2454,
                    2552
                ],
                "object": [
                    1090,
                    1826,
                    2018,
                    2598,
                    231,
                    1064,
                    2153,
                    2441,
                    2535,
                    1100,
                    750,
                    2363,
                    2547,
                    1109,
                    2454,
                    794,
                    1083
                ],
                "self.get_values": [
                    679,
                    1514,
                    621,
                    238,
                    624
                ],
                "self.values.view": [
                    2464,
                    241,
                    2467,
                    2253
                ],
                "np.nan": [
                    836,
                    245
                ],
                "self._mgr_locs": [
                    256,
                    249
                ],
                "isinstance": [
                    640,
                    2049,
                    2817,
                    1798,
                    2567,
                    2826,
                    1677,
                    1934,
                    2450,
                    406,
                    1022,
                    1942,
                    2326,
                    2203,
                    2206,
                    543,
                    675,
                    3063,
                    3129,
                    2490,
                    3131,
                    2492,
                    2109,
                    3065,
                    2111,
                    2240,
                    322,
                    1865,
                    2505,
                    2634,
                    1613,
                    2382,
                    719,
                    2814,
                    2902,
                    3070,
                    472,
                    474,
                    3035,
                    1632,
                    3040,
                    1636,
                    1003,
                    1647,
                    2165,
                    2167,
                    761,
                    253,
                    1406,
                    2047
                ],
                "new_mgr_locs": [
                    256,
                    1300,
                    1301,
                    1302,
                    1305,
                    1307,
                    3101,
                    3104,
                    3106,
                    3108,
                    1848,
                    1849,
                    1850,
                    1852,
                    321,
                    326,
                    333,
                    253,
                    254
                ],
                "libinternals.BlockPlacement": [
                    1613,
                    1614,
                    307,
                    1908,
                    253,
                    254
                ],
                "libinternals": [
                    1613,
                    1614,
                    307,
                    1908,
                    253,
                    254
                ],
                "mgr_locs.setter": [
                    251
                ],
                "mgr_locs": [
                    251
                ],
                "make_block": [
                    643,
                    3108,
                    2953,
                    1551,
                    273,
                    2645,
                    1494,
                    2455,
                    281
                ],
                "type": [
                    2902,
                    3070,
                    281,
                    1755,
                    2492,
                    285,
                    2206
                ],
                "name": [
                    288,
                    285,
                    294
                ],
                "__name__": [
                    285
                ],
                "self._is_single_block": [
                    530,
                    286
                ],
                "result": [
                    1541,
                    390,
                    1542,
                    392,
                    1416,
                    1544,
                    1546,
                    396,
                    1421,
                    1547,
                    1548,
                    400,
                    1550,
                    1551,
                    2702,
                    406,
                    407,
                    2167,
                    409,
                    2710,
                    2967,
                    2969,
                    2971,
                    2718,
                    2973,
                    288,
                    1440,
                    1442,
                    2976,
                    2977,
                    293,
                    2726,
                    298,
                    1962,
                    1452,
                    1969,
                    3063,
                    1974,
                    3064,
                    1978,
                    2263,
                    2269,
                    2153,
                    2154,
                    2164,
                    1525,
                    2165,
                    2166,
                    2168,
                    2169,
                    1531,
                    3070,
                    3071
                ],
                "shape": [
                    2625,
                    292,
                    3078,
                    295,
                    3079,
                    2636,
                    3084,
                    984
                ],
                "join": [
                    292
                ],
                "pprint_thing": [
                    292,
                    294
                ],
                "s": [
                    2817,
                    2818,
                    292,
                    2820,
                    2826,
                    2827,
                    2829
                ],
                "self.shape": [
                    641,
                    292,
                    646,
                    2470,
                    649,
                    969,
                    2031,
                    467,
                    1460,
                    2462
                ],
                "self.mgr_locs.indexer": [
                    304,
                    2418,
                    294
                ],
                "str": [
                    2209,
                    2817,
                    613,
                    2597,
                    2826,
                    558,
                    687,
                    283,
                    2076,
                    2814
                ],
                "int": [
                    2048,
                    1353,
                    1899,
                    300,
                    1932,
                    1907,
                    2389,
                    1309,
                    2110
                ],
                "state": [
                    307,
                    308
                ],
                "self.values.ndim": [
                    309
                ],
                "slicer": [
                    2066,
                    2067,
                    1822,
                    1823,
                    681,
                    682,
                    313,
                    322,
                    323,
                    325,
                    328,
                    1865,
                    1866,
                    1868,
                    1870,
                    2255,
                    2256,
                    2257,
                    2382,
                    2383,
                    2387,
                    2531,
                    2532,
                    2926,
                    2928
                ],
                "tuple": [
                    1632,
                    322,
                    1798,
                    1865,
                    3084,
                    1389,
                    2382,
                    1012,
                    1338
                ],
                "axis0_slicer": [
                    323,
                    325,
                    326
                ],
                "new_values": [
                    1675,
                    1294,
                    1680,
                    1682,
                    1043,
                    1683,
                    1045,
                    2839,
                    1304,
                    1305,
                    2841,
                    1307,
                    2844,
                    3102,
                    1311,
                    3105,
                    1314,
                    1315,
                    3108,
                    1322,
                    1325,
                    1327,
                    1328,
                    1712,
                    946,
                    1330,
                    1331,
                    1715,
                    1844,
                    1338,
                    1852,
                    1342,
                    960,
                    1344,
                    963,
                    328,
                    969,
                    330,
                    970,
                    1995,
                    333,
                    1488,
                    1491,
                    2004,
                    469,
                    1494,
                    991,
                    993,
                    997,
                    486,
                    488,
                    1005,
                    2413,
                    496,
                    2416,
                    2417,
                    2418,
                    2810
                ],
                "self._slice": [
                    328
                ],
                "new_values.ndim": [
                    1328,
                    330,
                    1005
                ],
                "self.make_block_same_class": [
                    1894,
                    1884,
                    361,
                    333,
                    2477,
                    2000,
                    1918,
                    1878,
                    1272,
                    1978,
                    1307,
                    1852,
                    1214,
                    703
                ],
                "self.values.shape": [
                    337,
                    2154
                ],
                "self.values.dtype": [
                    1760,
                    1774,
                    1203,
                    341,
                    671
                ],
                "getattr": [
                    865,
                    2265,
                    1382,
                    967,
                    1383,
                    1387,
                    2219,
                    1008,
                    948,
                    949,
                    982,
                    1982,
                    345,
                    1086,
                    1087
                ],
                "self.dtype.subtype": [
                    346
                ],
                "self._ftype": [
                    349
                ],
                "_merge_blocks": [
                    352
                ],
                "other": [
                    1408,
                    1412,
                    1421,
                    1934,
                    1937,
                    1426,
                    1938,
                    1940,
                    1948,
                    2462,
                    1952,
                    1057,
                    2464,
                    1964,
                    1965,
                    1967,
                    1460,
                    1462,
                    1975,
                    1093,
                    1103,
                    352,
                    1378,
                    1382,
                    1387,
                    1388,
                    1389,
                    2031,
                    2033,
                    1400,
                    1401,
                    1404,
                    1406
                ],
                "self._concatenator": [
                    2949,
                    358
                ],
                "blk.values": [
                    1876,
                    2950,
                    359
                ],
                "blk": [
                    2950,
                    359,
                    2472,
                    2473,
                    1876
                ],
                "to_concat": [
                    2432,
                    2950,
                    359,
                    1876,
                    2425,
                    2426
                ],
                "slice": [
                    1636,
                    1637,
                    362,
                    2954,
                    2834,
                    1333,
                    1877,
                    1335,
                    1337,
                    2427,
                    444
                ],
                "i": [
                    1447,
                    494,
                    495,
                    400,
                    366,
                    399,
                    496,
                    500
                ],
                "locs": [
                    376,
                    1650,
                    2288
                ],
                "np.delete": [
                    382
                ],
                "loc": [
                    1633,
                    1639,
                    1640,
                    399,
                    2383,
                    402,
                    2386,
                    382,
                    383
                ],
                "self.mgr_locs.delete": [
                    383
                ],
                "np.errstate": [
                    389
                ],
                "func": [
                    1270,
                    390
                ],
                "kwargs": [
                    1158,
                    390,
                    809,
                    1266,
                    1174,
                    2520
                ],
                "self._split_op_result": [
                    392
                ],
                "List": [
                    385,
                    509,
                    394,
                    1354,
                    1899,
                    1933,
                    2389,
                    1910,
                    2649,
                    1309
                ],
                "is_extension_array_dtype": [
                    865,
                    2275,
                    3014,
                    3080,
                    2570,
                    2666,
                    396,
                    3211,
                    2525
                ],
                "result.ndim": [
                    396
                ],
                "nbs": [
                    403,
                    404,
                    398
                ],
                "enumerate": [
                    494,
                    399
                ],
                "vals": [
                    400,
                    401
                ],
                "nv": [
                    3201,
                    3202,
                    1033,
                    1034,
                    401,
                    402,
                    536,
                    537,
                    3192,
                    472,
                    473,
                    474,
                    475,
                    479,
                    480,
                    486,
                    488,
                    489,
                    500,
                    502,
                    3191,
                    504,
                    3193,
                    3199
                ],
                "_block_shape": [
                    1314,
                    2638,
                    401,
                    407,
                    479
                ],
                "block": [
                    402,
                    403,
                    1426,
                    1427,
                    794,
                    795,
                    923,
                    922,
                    2844,
                    2846,
                    2847,
                    439,
                    444,
                    445,
                    2876,
                    2885,
                    2886,
                    475,
                    480,
                    481,
                    489,
                    490,
                    750,
                    751,
                    504,
                    505
                ],
                "self.make_block": [
                    480,
                    1344,
                    1442,
                    1315,
                    1305,
                    904,
                    2472,
                    1454,
                    2222,
                    402,
                    1683,
                    596,
                    1045,
                    598,
                    407,
                    537,
                    922,
                    2844
                ],
                "nbs.append": [
                    403
                ],
                "Block": [
                    2304,
                    2021,
                    1718,
                    406,
                    3070,
                    474,
                    2172,
                    1982,
                    2591
                ],
                "inplace": [
                    773,
                    2438,
                    1671,
                    1160,
                    2693,
                    778,
                    1675,
                    1036,
                    2442,
                    1039,
                    2577,
                    2705,
                    1172,
                    2966,
                    2967,
                    2584,
                    2971,
                    798,
                    415,
                    2721,
                    2978,
                    804,
                    1189,
                    423,
                    1195,
                    2733,
                    430,
                    1583,
                    1200,
                    946,
                    435,
                    1588,
                    445,
                    447,
                    2879,
                    713,
                    720,
                    1233,
                    1234,
                    2772,
                    728,
                    1881,
                    738,
                    1893,
                    1127,
                    488,
                    1133,
                    754,
                    502,
                    2807,
                    1145,
                    2810,
                    2684,
                    1151
                ],
                "validate_bool_kwarg": [
                    1189,
                    1127,
                    1671,
                    713,
                    1233,
                    2577,
                    2772,
                    2966,
                    415
                ],
                "mask": [
                    1536,
                    3201,
                    770,
                    772,
                    1033,
                    778,
                    1036,
                    1677,
                    1678,
                    1680,
                    1682,
                    2838,
                    2073,
                    2841,
                    1824,
                    417,
                    2080,
                    1827,
                    420,
                    1447,
                    1450,
                    683,
                    1580,
                    430,
                    1583,
                    1712,
                    434,
                    1714,
                    1715,
                    949,
                    694,
                    1591,
                    2875,
                    2882,
                    1995,
                    1488,
                    466,
                    467,
                    1490,
                    981,
                    1491,
                    1492,
                    984,
                    1495,
                    2006,
                    3162,
                    991,
                    992,
                    993,
                    3167,
                    3199,
                    485,
                    486,
                    997,
                    1000,
                    2533,
                    1002,
                    2538,
                    2539,
                    495,
                    2929,
                    2931,
                    3192,
                    1530,
                    767
                ],
                "isna": [
                    1824,
                    417,
                    2533,
                    683,
                    2929,
                    854,
                    952,
                    2073,
                    1530,
                    1948,
                    2814,
                    2975
                ],
                "limit": [
                    1152,
                    418,
                    419,
                    420,
                    2438,
                    1895,
                    2442,
                    1261,
                    1168,
                    1209,
                    1882,
                    445
                ],
                "libalgos._validate_limit": [
                    419
                ],
                "libalgos": [
                    419
                ],
                "mask.cumsum": [
                    420
                ],
                "self._can_hold_na": [
                    1194,
                    1437,
                    422
                ],
                "self.copy": [
                    775,
                    809,
                    426,
                    1675,
                    1198,
                    1136,
                    722,
                    435,
                    2967,
                    730,
                    635,
                    667,
                    605
                ],
                "self._can_hold_element": [
                    2437,
                    840,
                    873,
                    428,
                    718,
                    2449,
                    724,
                    791,
                    1404,
                    956
                ],
                "value": [
                    2818,
                    2692,
                    2437,
                    2438,
                    903,
                    778,
                    1802,
                    1803,
                    909,
                    2442,
                    2570,
                    2571,
                    2449,
                    2699,
                    2827,
                    2452,
                    918,
                    791,
                    2583,
                    2969,
                    2458,
                    797,
                    2975,
                    2720,
                    2976,
                    2978,
                    428,
                    2732,
                    430,
                    1582,
                    1583,
                    2098,
                    1587,
                    439,
                    445,
                    2878,
                    834,
                    2114,
                    836,
                    840,
                    843,
                    844,
                    2814,
                    2513,
                    850,
                    851,
                    2133,
                    854,
                    855,
                    2520,
                    1882,
                    2524,
                    2525,
                    862,
                    737,
                    865,
                    2273,
                    868,
                    2274,
                    870,
                    2275,
                    2663,
                    873,
                    2666,
                    1647,
                    753,
                    881,
                    2673,
                    2807,
                    2683,
                    894
                ],
                "blocks": [
                    3072,
                    516,
                    518,
                    778,
                    2701,
                    3090,
                    1427,
                    3091,
                    2711,
                    3096,
                    1435,
                    2717,
                    3101,
                    3102,
                    804,
                    805,
                    2727,
                    3111,
                    430,
                    431,
                    1214,
                    1215,
                    1999,
                    2642,
                    2645,
                    1494,
                    1495,
                    2006,
                    2647,
                    2652,
                    2655,
                    3061,
                    2678,
                    3062,
                    1272,
                    1273,
                    3066,
                    3068,
                    3071
                ],
                "self.putmask": [
                    778,
                    430,
                    1583
                ],
                "self._maybe_downcast": [
                    1215,
                    1435,
                    1273,
                    431
                ],
                "downcast": [
                    513,
                    1155,
                    518,
                    2438,
                    2442,
                    431,
                    1173,
                    1273,
                    2651,
                    1215
                ],
                "mask.any": [
                    772,
                    485,
                    1000,
                    1580,
                    1490,
                    434,
                    1714,
                    2875
                ],
                "self.coerce_to_target_dtype": [
                    1426,
                    1582,
                    439
                ],
                "idx": [
                    1017,
                    442,
                    444,
                    1023
                ],
                "block.getitem_block": [
                    444
                ],
                "block.fillna": [
                    445
                ],
                "self.split_and_operate": [
                    2642,
                    556,
                    1036,
                    447
                ],
                "f": [
                    486,
                    1036,
                    556,
                    2831,
                    2642,
                    500,
                    2644,
                    2839,
                    2841,
                    447
                ],
                "bool": [
                    2051,
                    2563,
                    2567,
                    1931,
                    656,
                    657,
                    658,
                    659,
                    660,
                    2579,
                    2961,
                    2963,
                    2964,
                    2460,
                    669,
                    2209,
                    1447,
                    558,
                    1459,
                    2227,
                    2611,
                    2612,
                    2613,
                    2614,
                    2105,
                    2615,
                    1854,
                    2111,
                    449,
                    2499,
                    1352,
                    2122,
                    2657,
                    2030,
                    2041
                ],
                "np.broadcast_to": [
                    467
                ],
                "list": [
                    580,
                    719,
                    1010,
                    3063,
                    472,
                    3065
                ],
                "ref_loc": [
                    480,
                    504,
                    494
                ],
                "new_values.copy": [
                    488
                ],
                "make_a_block": [
                    504,
                    489
                ],
                "new_blocks": [
                    1036,
                    1037,
                    493,
                    505,
                    507
                ],
                "m": [
                    1158,
                    1450,
                    1451,
                    1164,
                    1452,
                    1454,
                    495,
                    499,
                    1140,
                    500,
                    1142,
                    1144,
                    1149
                ],
                "v": [
                    3205,
                    3174,
                    3206,
                    2699,
                    3179,
                    3211,
                    3212,
                    3214,
                    496,
                    2704,
                    3216,
                    3187,
                    500,
                    502,
                    3191
                ],
                "m.any": [
                    499,
                    1451
                ],
                "v.copy": [
                    502,
                    3191
                ],
                "new_blocks.append": [
                    505
                ],
                "self.is_float": [
                    514,
                    1066,
                    1237
                ],
                "_extend_blocks": [
                    2710,
                    2726,
                    518,
                    2655
                ],
                "b.downcast": [
                    518
                ],
                "b": [
                    804,
                    2885,
                    518,
                    2717,
                    2718,
                    2701,
                    2702,
                    3101,
                    3102,
                    3096,
                    861,
                    862,
                    2655
                ],
                "dtypes": [
                    547,
                    524,
                    533,
                    534,
                    536,
                    540,
                    543
                ],
                "maybe_downcast_to_dtype": [
                    536,
                    553
                ],
                "dict": [
                    543
                ],
                "AssertionError": [
                    548,
                    1092,
                    1867,
                    747,
                    1102,
                    3097,
                    2782
                ],
                "val": [
                    2625,
                    2627,
                    553,
                    554,
                    1033,
                    2546
                ],
                "errors_legal_values": [
                    577,
                    580,
                    575
                ],
                "errors": [
                    577,
                    580,
                    2225,
                    1431,
                    633,
                    1374
                ],
                "invalid_arg": [
                    578,
                    582
                ],
                "inspect.isclass": [
                    584
                ],
                "inspect": [
                    584
                ],
                "issubclass": [
                    2566,
                    2570,
                    674,
                    2597,
                    2098,
                    2108,
                    3007,
                    2114,
                    2502,
                    584,
                    3016,
                    3018,
                    3019,
                    3021,
                    2126,
                    2127,
                    3023,
                    2523,
                    2273,
                    613,
                    2662,
                    2044
                ],
                "ExtensionDtype": [
                    584
                ],
                "msg": [
                    585,
                    589
                ],
                "dtype.__name__": [
                    586
                ],
                "self.is_categorical_astype": [
                    592
                ],
                "copy": [
                    648,
                    2632,
                    2225,
                    596,
                    635,
                    667,
                    604
                ],
                "pandas_dtype": [
                    600,
                    2214
                ],
                "is_dtype_equal": [
                    1059,
                    1304,
                    603,
                    860,
                    2232
                ],
                "self.is_extension": [
                    609
                ],
                "dtype.type": [
                    3000,
                    613
                ],
                "self.is_datelike": [
                    616
                ],
                "self.to_native_types": [
                    617
                ],
                "vals1d": [
                    627,
                    629
                ],
                "values.ravel": [
                    2546,
                    627
                ],
                "astype_nansafe": [
                    629
                ],
                "newb": [
                    643,
                    645,
                    646,
                    650,
                    652,
                    2455,
                    2458,
                    635,
                    636
                ],
                "np.ndarray": [
                    640,
                    2634,
                    1003,
                    1677,
                    2450,
                    1022,
                    761,
                    2206,
                    2492,
                    1406
                ],
                "values.reshape": [
                    641,
                    2371,
                    1830,
                    2636,
                    3084,
                    1810,
                    2934
                ],
                "newb.is_numeric": [
                    645
                ],
                "self.is_numeric": [
                    835,
                    645
                ],
                "newb.shape": [
                    650,
                    646
                ],
                "newb.dtype.name": [
                    650
                ],
                "newb.dtype": [
                    650
                ],
                "Any": [
                    2657,
                    2499,
                    2563,
                    2122,
                    2227,
                    1909,
                    2041,
                    669,
                    1854,
                    2105
                ],
                "self.values.dtype.type": [
                    671
                ],
                "tipo": [
                    2564,
                    2565,
                    2566,
                    672,
                    673,
                    674,
                    2228,
                    2229,
                    2232,
                    2106,
                    2107,
                    2108,
                    2237,
                    2500,
                    2501,
                    2502,
                    2123,
                    2124,
                    2126,
                    2127,
                    2128,
                    2042,
                    2043,
                    2044,
                    2045
                ],
                "maybe_infer_dtype_type": [
                    672,
                    2106,
                    2500,
                    2564,
                    2123,
                    2228,
                    2042
                ],
                "element": [
                    2048,
                    2050,
                    2564,
                    2567,
                    672,
                    675,
                    2228,
                    2233,
                    2106,
                    2238,
                    2110,
                    2240,
                    2111,
                    2242,
                    2243,
                    2500,
                    2245,
                    2503,
                    2505,
                    2123,
                    2507,
                    2130,
                    2042
                ],
                "tipo.type": [
                    674,
                    2502,
                    2566,
                    2126,
                    2108,
                    2127,
                    2044,
                    2045
                ],
                "itemsize": [
                    688,
                    690,
                    684,
                    686
                ],
                "writers.word_len": [
                    684
                ],
                "writers": [
                    684
                ],
                "na_rep": [
                    2080,
                    1827,
                    2087,
                    2536,
                    2537,
                    2538,
                    684,
                    2931,
                    694,
                    2267
                ],
                "self.is_object": [
                    952,
                    686
                ],
                "quoting": [
                    2090,
                    2075,
                    686
                ],
                "values.astype": [
                    1826,
                    875,
                    687,
                    912,
                    690,
                    2363,
                    2076
                ],
                "values.dtype.itemsize": [
                    688
                ],
                "values.dtype": [
                    1408,
                    3044,
                    2597,
                    2488,
                    844,
                    688,
                    2999,
                    2200,
                    859,
                    765
                ],
                "np.dtype": [
                    688
                ],
                "np.array": [
                    1025,
                    1541,
                    870,
                    1447,
                    2598,
                    2545,
                    2930,
                    692,
                    1526,
                    1533,
                    2078
                ],
                "deep": [
                    701
                ],
                "values.copy": [
                    702
                ],
                "original_to_replace": [
                    714,
                    796
                ],
                "to_replace": [
                    2691,
                    2699,
                    2578,
                    2582,
                    2969,
                    2715,
                    2978,
                    2731,
                    1586,
                    2877,
                    714,
                    718,
                    719,
                    724,
                    725,
                    2775,
                    732,
                    736,
                    2789,
                    2794,
                    2795,
                    2797,
                    752,
                    2672,
                    2802,
                    2807,
                    2680,
                    761,
                    2682,
                    765,
                    767
                ],
                "x": [
                    2425,
                    2426,
                    1259,
                    724
                ],
                "self.replace": [
                    735
                ],
                "filter": [
                    768,
                    769,
                    2722,
                    739,
                    2978,
                    2694,
                    2734,
                    2833,
                    2706,
                    755,
                    2836,
                    2807,
                    2968,
                    2585,
                    2685,
                    799
                ],
                "regex": [
                    2689,
                    2695,
                    2707,
                    2714,
                    2586,
                    800,
                    2978,
                    2723,
                    1581,
                    2736,
                    1589,
                    2880,
                    2775,
                    2778,
                    740,
                    2789,
                    2791,
                    2801,
                    756,
                    2807
                ],
                "convert": [
                    801,
                    2881,
                    803,
                    2724,
                    741,
                    2884,
                    2887,
                    2696,
                    2978,
                    2735,
                    2708,
                    757,
                    1590,
                    2970,
                    2587,
                    2845,
                    2687
                ],
                "self.astype": [
                    1090,
                    1064,
                    2441,
                    1100,
                    750,
                    1107,
                    1109,
                    794,
                    1083,
                    861
                ],
                "block.replace": [
                    795,
                    751
                ],
                "lib.is_scalar": [
                    1544,
                    843,
                    1964,
                    854,
                    761,
                    1948,
                    1406,
                    959
                ],
                "lib": [
                    1544,
                    843,
                    1548,
                    1964,
                    2607,
                    854,
                    1400,
                    761,
                    1948,
                    1406,
                    959
                ],
                "convert_scalar_for_putitemlike": [
                    960,
                    1408,
                    844,
                    1203,
                    765
                ],
                "missing.mask_missing": [
                    767
                ],
                "missing": [
                    1158,
                    1257,
                    1140,
                    1205,
                    767
                ],
                "filtered_out": [
                    769,
                    770
                ],
                "self.mgr_locs.isin": [
                    769,
                    2836
                ],
                "filtered_out.nonzero": [
                    770
                ],
                "b.convert": [
                    804,
                    2885,
                    2655
                ],
                "transpose": [
                    962,
                    1379,
                    1375,
                    1439,
                    1001,
                    877,
                    1390,
                    1042,
                    920,
                    831
                ],
                "find_dtype": [
                    848,
                    858,
                    856,
                    852
                ],
                "hasattr": [
                    1393,
                    850
                ],
                "value.dtype": [
                    2273,
                    2114,
                    2663,
                    2570,
                    2098,
                    851,
                    2133,
                    2524
                ],
                "_": [
                    1057,
                    1028,
                    3209,
                    874,
                    855
                ],
                "infer_dtype_from_scalar": [
                    855
                ],
                "find_common_type": [
                    859
                ],
                "b.setitem": [
                    862
                ],
                "indexer": [
                    1798,
                    903,
                    1800,
                    1802,
                    1803,
                    909,
                    1295,
                    881,
                    862,
                    2450,
                    1844,
                    2452,
                    918,
                    887,
                    2458,
                    891,
                    894
                ],
                "arr_value": [
                    898,
                    868,
                    870,
                    904,
                    874,
                    912,
                    883,
                    884,
                    885,
                    887,
                    891
                ],
                "maybe_promote": [
                    3209,
                    874,
                    1028
                ],
                "arr_value.dtype": [
                    904,
                    874,
                    912,
                    898
                ],
                "values.T": [
                    921,
                    1380,
                    878
                ],
                "check_setitem_lengths": [
                    881,
                    1802
                ],
                "exact_match": [
                    897,
                    882,
                    908
                ],
                "arr_value.shape": [
                    883,
                    884
                ],
                "values.shape": [
                    3079,
                    2535,
                    1516,
                    1810,
                    884
                ],
                "arr_value.size": [
                    885
                ],
                "values.size": [
                    885
                ],
                "is_empty_indexer": [
                    887
                ],
                "is_scalar_indexer": [
                    891
                ],
                "self.values.copy": [
                    1893,
                    1962,
                    1200,
                    1234,
                    946,
                    1881,
                    2810
                ],
                "new": [
                    1025,
                    1677,
                    1678,
                    1682,
                    948,
                    952,
                    954,
                    956,
                    959,
                    960,
                    967,
                    968,
                    969,
                    970,
                    980,
                    982,
                    984,
                    991,
                    992,
                    993,
                    997,
                    1003,
                    1004,
                    1008,
                    1009,
                    1010,
                    1012,
                    1019,
                    1022,
                    1023
                ],
                "is_list_like": [
                    1517,
                    2672,
                    2673,
                    980,
                    3190,
                    952,
                    3161
                ],
                "self.fill_value": [
                    1288,
                    1526,
                    954,
                    1243,
                    1535
                ],
                "new_values.dtype": [
                    960,
                    1304,
                    970
                ],
                "new_values.T": [
                    963,
                    1327,
                    1043,
                    1491,
                    2004,
                    1342
                ],
                "new.ndim": [
                    968,
                    1009
                ],
                "axis": [
                    1167,
                    1295,
                    1300,
                    1433,
                    1311,
                    1445,
                    1446,
                    1534,
                    2473,
                    1452,
                    1328,
                    1331,
                    1335,
                    1208,
                    1337,
                    968,
                    2409,
                    1388,
                    1005,
                    1516,
                    1900,
                    1902,
                    1903,
                    2413,
                    1011,
                    1270,
                    1150
                ],
                "reshape": [
                    969,
                    1525,
                    2263
                ],
                "np.repeat": [
                    969,
                    3162,
                    1525
                ],
                "new_values.shape": [
                    1680,
                    969,
                    1330
                ],
                "new.astype": [
                    970
                ],
                "np.any": [
                    981
                ],
                "np.place": [
                    991
                ],
                "mask.shape": [
                    992
                ],
                "np.putmask": [
                    993,
                    997
                ],
                "mask.T": [
                    1002
                ],
                "new.T": [
                    1004
                ],
                "new_shape": [
                    1010,
                    1011,
                    1012,
                    3132
                ],
                "new.shape": [
                    1010,
                    1023
                ],
                "new_shape.insert": [
                    1011
                ],
                "new.reshape": [
                    1012
                ],
                "n": [
                    1025,
                    3201,
                    1028,
                    3205,
                    3206,
                    1031,
                    1019,
                    1033,
                    3209,
                    3216,
                    1023,
                    1311,
                    3161,
                    3162,
                    3167,
                    2413,
                    1903,
                    3195,
                    3199
                ],
                "np.squeeze": [
                    1023
                ],
                "n.dtype": [
                    3209,
                    1028,
                    3205
                ],
                "n.astype": [
                    1031
                ],
                "_putmask_smart": [
                    1033
                ],
                "infer_dtype_from": [
                    1057
                ],
                "self.is_bool": [
                    1132,
                    1062,
                    1399
                ],
                "is_bool_dtype": [
                    1062
                ],
                "self.is_complex": [
                    1066
                ],
                "is_integer_dtype": [
                    3176,
                    3179,
                    1067,
                    2133
                ],
                "is_float_dtype": [
                    3176,
                    3179,
                    1067
                ],
                "is_datetime64_dtype": [
                    1080,
                    1074,
                    2237
                ],
                "is_datetime64tz_dtype": [
                    3008,
                    2274,
                    3010,
                    3047,
                    2217,
                    1075,
                    1080
                ],
                "mytz": [
                    1089,
                    1086
                ],
                "othertz": [
                    1089,
                    1087
                ],
                "tz_compare": [
                    1089,
                    2242
                ],
                "is_timedelta64_dtype": [
                    1096,
                    1099
                ],
                "OverflowError": [
                    1108
                ],
                "self.is_integer": [
                    1132,
                    1238,
                    1399
                ],
                "missing.clean_fill_method": [
                    1140
                ],
                "method": [
                    1248,
                    1158,
                    1895,
                    1260,
                    1140,
                    1207,
                    1245
                ],
                "r": [
                    3066,
                    1160,
                    1161,
                    1162,
                    1453,
                    1454,
                    3064,
                    1145,
                    1146,
                    1147,
                    3068,
                    3065
                ],
                "check_int_bool": [
                    1160,
                    1145
                ],
                "self._interpolate_with_fill": [
                    1148
                ],
                "fill_value": [
                    1153,
                    2307,
                    1288,
                    1291,
                    1295,
                    1171,
                    1322,
                    1837,
                    1839,
                    1203,
                    1844,
                    2485,
                    1338,
                    1210,
                    2001,
                    1242,
                    1243,
                    1895,
                    1264,
                    1919
                ],
                "coerce": [
                    1193,
                    1154,
                    2631
                ],
                "missing.clean_interp_method": [
                    1158
                ],
                "self._interpolate": [
                    1163
                ],
                "index": [
                    1258,
                    1165,
                    1246
                ],
                "limit_direction": [
                    1169,
                    1262
                ],
                "limit_area": [
                    1170,
                    1263
                ],
                "missing.interpolate_2d": [
                    1205
                ],
                "data": [
                    1240,
                    1234,
                    1270
                ],
                "data.astype": [
                    1240
                ],
                "np.float64": [
                    1240
                ],
                "index.is_monotonic": [
                    1246
                ],
                "missing.interpolate_1d": [
                    1257
                ],
                "interp_values": [
                    1272,
                    1270
                ],
                "np.apply_along_axis": [
                    1270
                ],
                "fill_tuple": [
                    1291,
                    1836,
                    1839,
                    1287
                ],
                "allow_fill": [
                    1289,
                    1292,
                    1295
                ],
                "algos.take_nd": [
                    1294
                ],
                "algos": [
                    1294,
                    1311
                ],
                "algos.diff": [
                    1311
                ],
                "maybe_upcast": [
                    1322
                ],
                "f_ordered": [
                    1341,
                    1325,
                    1326
                ],
                "new_values.flags.f_contiguous": [
                    1325
                ],
                "new_values.flags": [
                    1325
                ],
                "np.prod": [
                    1330
                ],
                "np.roll": [
                    1331
                ],
                "ensure_platform_int": [
                    1331
                ],
                "periods": [
                    1331,
                    1334,
                    1335,
                    1337,
                    1919
                ],
                "axis_indexer": [
                    1337,
                    1338,
                    1333,
                    1335
                ],
                "orig_other": [
                    1378,
                    1428
                ],
                "cond": [
                    1412,
                    1445,
                    1446,
                    1415,
                    1383,
                    1447,
                    1963,
                    1421,
                    1391,
                    1393,
                    1975,
                    1429,
                    1942,
                    1943,
                    1944,
                    1946
                ],
                "other.ndim": [
                    1388
                ],
                "other.reshape": [
                    1389
                ],
                "other.shape": [
                    1389,
                    2031,
                    1937,
                    1460,
                    2462
                ],
                "cond.T": [
                    1391
                ],
                "lib.is_float": [
                    1400
                ],
                "np.isnan": [
                    1401,
                    2034
                ],
                "fastres": [
                    1412,
                    1413
                ],
                "expressions.where": [
                    1412
                ],
                "expressions": [
                    1412
                ],
                "all": [
                    2464,
                    1447,
                    2034,
                    1415
                ],
                "cond.ravel": [
                    1415
                ],
                "where_func": [
                    1421
                ],
                "block.where": [
                    1427
                ],
                "align": [
                    1430
                ],
                "try_cast": [
                    1432
                ],
                "result.T": [
                    1440,
                    1542
                ],
                "cond.ndim": [
                    1445
                ],
                "cond.swapaxes": [
                    1446
                ],
                "range": [
                    1447
                ],
                "cond.shape": [
                    1943,
                    1447
                ],
                "result_blocks": [
                    2726,
                    2727,
                    2728,
                    1449,
                    2700,
                    1455,
                    1457,
                    2677,
                    2710,
                    2711,
                    2712,
                    2716
                ],
                "taken": [
                    1452,
                    1453
                ],
                "result.take": [
                    1452
                ],
                "m.nonzero": [
                    1452
                ],
                "maybe_downcast_numeric": [
                    1453
                ],
                "nb": [
                    1454,
                    1455
                ],
                "r.T": [
                    1454
                ],
                "result_blocks.append": [
                    1455
                ],
                "other.dtype": [
                    1460,
                    2462,
                    2031
                ],
                "array_equivalent": [
                    1462
                ],
                "other.values": [
                    2464,
                    2033,
                    1462
                ],
                "unstacker": [
                    1993,
                    1996,
                    1485,
                    1710,
                    1486,
                    1488,
                    1712
                ],
                "unstacker_func": [
                    1992,
                    1485
                ],
                "self.values.T": [
                    1485
                ],
                "new_items": [
                    1711,
                    1710,
                    1486,
                    1487
                ],
                "unstacker.get_new_columns": [
                    1710,
                    1486
                ],
                "new_placement": [
                    1995,
                    1711,
                    1487,
                    1715,
                    1492,
                    2004,
                    1494
                ],
                "new_columns.get_indexer": [
                    1711,
                    1487
                ],
                "new_columns": [
                    1711,
                    1996,
                    1487
                ],
                "unstacker.get_new_values": [
                    1488,
                    1712
                ],
                "is_empty": [
                    1522,
                    1516
                ],
                "orig_scalar": [
                    1544,
                    1517,
                    1518
                ],
                "qs": [
                    2473,
                    1517,
                    1520,
                    1526,
                    1527,
                    1533
                ],
                "np.asarray": [
                    1826,
                    2378,
                    1808,
                    2291,
                    2552,
                    1817,
                    1530,
                    3195,
                    2365
                ],
                "nanpercentile": [
                    1531
                ],
                "interpolation": [
                    2473,
                    1538
                ],
                "result.shape": [
                    1546
                ],
                "lib.item_from_zerodim": [
                    1548
                ],
                "np.ndim": [
                    1550
                ],
                "np.arange": [
                    1991,
                    1551
                ],
                "self._replace_single": [
                    2681,
                    1585,
                    2730
                ],
                "__init__": [
                    2178,
                    1733,
                    2600,
                    1622,
                    2903,
                    2493
                ],
                "super": [
                    2432,
                    2977,
                    2178,
                    2690,
                    1733,
                    2438,
                    2600,
                    2903,
                    1903,
                    2225,
                    2164,
                    2452,
                    1622,
                    2581,
                    2520,
                    2806,
                    2876,
                    2493
                ],
                "col": [
                    1632,
                    1633,
                    1634,
                    1636,
                    1637,
                    1638,
                    1642,
                    2383,
                    2384
                ],
                "com.is_null_slice": [
                    2384,
                    1634,
                    1866
                ],
                "com": [
                    2384,
                    1634,
                    1866
                ],
                "IndexError": [
                    2385,
                    1643,
                    1635,
                    3200
                ],
                "NotImplementedError": [
                    1970,
                    2412,
                    1638
                ],
                "self._holder": [
                    1765,
                    2153,
                    2476,
                    1647,
                    1876,
                    1974,
                    2326,
                    2327
                ],
                "locs.tolist": [
                    1650
                ],
                "_safe_reshape": [
                    1680
                ],
                "NonConsolidatableMixIn": [
                    1718
                ],
                "self._maybe_coerce_values": [
                    2177,
                    1732
                ],
                "extract_array": [
                    1946,
                    1940,
                    2901,
                    1750
                ],
                "self.values.dtype.na_value": [
                    1760
                ],
                "self._holder._can_hold_na": [
                    1765
                ],
                "self.values.dtype._is_numeric": [
                    1774
                ],
                "self.values.take": [
                    2001,
                    1844
                ],
                "self._holder._concat_same_type": [
                    1876
                ],
                "values.fillna": [
                    1882,
                    1895
                ],
                "diff": [
                    1903
                ],
                "self.values.shift": [
                    1919
                ],
                "ABCDataFrame": [
                    1942,
                    1934
                ],
                "other.iloc": [
                    1938
                ],
                "cond.iloc": [
                    1944
                ],
                "self.dtype.na_value": [
                    1952
                ],
                "is_sparse": [
                    3002,
                    1954
                ],
                "icond": [
                    1969,
                    1963,
                    1967
                ],
                "set_other": [
                    1969,
                    1965,
                    1967
                ],
                "self._holder._from_sequence": [
                    1974
                ],
                "np.where": [
                    1975
                ],
                "Block._ftype": [
                    1982
                ],
                "dummy_arr": [
                    1993,
                    1991
                ],
                "n_rows": [
                    1991
                ],
                "dummy_unstacker": [
                    1992,
                    1993
                ],
                "functools.partial": [
                    1992
                ],
                "functools": [
                    1992
                ],
                "self._get_unstack_items": [
                    1995
                ],
                "indices": [
                    2001,
                    2004
                ],
                "place": [
                    2002,
                    2004
                ],
                "zip": [
                    2699,
                    2004
                ],
                "ExtensionBlock": [
                    2297,
                    3015,
                    2892,
                    2009,
                    3004
                ],
                "NumericBlock": [
                    2027,
                    2117,
                    2558
                ],
                "left": [
                    2033,
                    2034
                ],
                "right": [
                    2033,
                    2034
                ],
                "FloatOrComplexBlock": [
                    2101,
                    2037
                ],
                "np.floating": [
                    2048,
                    2664,
                    3016,
                    2108,
                    2098,
                    2044
                ],
                "np.integer": [
                    2664,
                    3019,
                    2126,
                    2108,
                    3023,
                    2044
                ],
                "np.datetime64": [
                    2145,
                    2273,
                    2051,
                    2307,
                    2664,
                    2127,
                    2165,
                    2045,
                    3007
                ],
                "np.timedelta64": [
                    2051,
                    2502,
                    2505,
                    3018,
                    2127,
                    2485,
                    2167,
                    2524,
                    2045
                ],
                "float": [
                    2048,
                    2110
                ],
                "np.int_": [
                    2048,
                    2110
                ],
                "np.bool_": [
                    2051,
                    2566,
                    2567,
                    2664,
                    2570,
                    3025,
                    2111
                ],
                "datetime": [
                    2240,
                    2051,
                    2628
                ],
                "timedelta": [
                    2505,
                    2051,
                    2630
                ],
                "float_format": [
                    2072,
                    2088
                ],
                "decimal": [
                    2072,
                    2089
                ],
                "formatter": [
                    2093,
                    2085
                ],
                "FloatArrayFormatter": [
                    2085
                ],
                "formatter.get_result_as_array": [
                    2093
                ],
                "value.dtype.type": [
                    2273,
                    2114,
                    2663,
                    2570,
                    2098,
                    2524
                ],
                "np.complexfloating": [
                    2664,
                    2114,
                    2108,
                    3021
                ],
                "complex": [
                    2110
                ],
                "np.float_": [
                    2110
                ],
                "self.dtype.itemsize": [
                    2128
                ],
                "tipo.itemsize": [
                    2128
                ],
                "DatetimeArray": [
                    2311,
                    3050,
                    2220,
                    2294,
                    2203,
                    2141
                ],
                "self.values.ravel": [
                    2152,
                    2644,
                    2607
                ],
                "astype": [
                    2153,
                    2225
                ],
                "result.reshape": [
                    2154
                ],
                "self.array_values": [
                    2159
                ],
                "iget": [
                    2164
                ],
                "key": [
                    2164
                ],
                "Timestamp": [
                    2166
                ],
                "Timedelta": [
                    2168,
                    2546
                ],
                "DatetimeLikeBlockMixin": [
                    2480,
                    2172
                ],
                "_NS_DTYPE": [
                    2200,
                    2378
                ],
                "conversion.ensure_datetime64ns": [
                    2201,
                    2286
                ],
                "conversion": [
                    2201,
                    2489,
                    2286
                ],
                "values._data": [
                    2491,
                    2204
                ],
                "tz_localize": [
                    2220
                ],
                "values.tz_convert": [
                    2221
                ],
                "dtype.tz": [
                    2221
                ],
                "self.is_datetimetz": [
                    2241,
                    2230
                ],
                "is_valid_nat_for_dtype": [
                    2232,
                    2507,
                    2245
                ],
                "NaT": [
                    2238,
                    2503
                ],
                "element.tzinfo": [
                    2242,
                    2243
                ],
                "self.dtype.tz": [
                    2242
                ],
                "i8values": [
                    2264,
                    2257,
                    2268,
                    2253
                ],
                "fmt": [
                    2266,
                    2261
                ],
                "_get_format_datetime64_from_values": [
                    2261
                ],
                "date_format": [
                    2261
                ],
                "tslib.format_array_from_datetime": [
                    2263
                ],
                "tslib": [
                    2263
                ],
                "i8values.ravel": [
                    2264
                ],
                "i8values.shape": [
                    2268
                ],
                "np.atleast_2d": [
                    3038,
                    2269,
                    2430
                ],
                "DatetimeArray._simple_new": [
                    3050,
                    2294
                ],
                "DatetimeBlock": [
                    2297,
                    2306,
                    3009,
                    2305
                ],
                "internal_values": [
                    2304
                ],
                "Block.internal_values": [
                    2304
                ],
                "_can_hold_element": [
                    2305
                ],
                "DatetimeBlock._can_hold_element": [
                    2305
                ],
                "to_native_types": [
                    2306
                ],
                "DatetimeBlock.to_native_types": [
                    2306
                ],
                "values.tz": [
                    2329
                ],
                "self.values._data.base": [
                    2338
                ],
                "self.values._data": [
                    2338
                ],
                "asi8": [
                    2413
                ],
                "self.shift": [
                    2413
                ],
                "new_values.reshape": [
                    2416
                ],
                "new_values.astype": [
                    2417
                ],
                "TimeDeltaBlock": [
                    2418,
                    3020
                ],
                "x.dtype": [
                    2425
                ],
                "concat_datetime": [
                    2426
                ],
                "x.values": [
                    2426
                ],
                "ObjectBlock": [
                    2456,
                    3028,
                    2431
                ],
                "concat_same_type": [
                    2432
                ],
                "fillna": [
                    2520,
                    2441,
                    2438
                ],
                "indexer.size": [
                    2450
                ],
                "setitem": [
                    2452
                ],
                "obj_vals": [
                    2456,
                    2454
                ],
                "newb.setitem": [
                    2458
                ],
                "other.values.view": [
                    2464
                ],
                "naive": [
                    2472,
                    2467,
                    2470
                ],
                "naive.reshape": [
                    2470
                ],
                "res_blk": [
                    2473,
                    2476,
                    2477
                ],
                "blk.quantile": [
                    2473
                ],
                "aware": [
                    2476,
                    2477
                ],
                "res_blk.values.ravel": [
                    2476
                ],
                "res_blk.values": [
                    2476
                ],
                "res_blk.ndim": [
                    2477
                ],
                "IntBlock": [
                    2480,
                    3024
                ],
                "_TD_DTYPE": [
                    2488
                ],
                "conversion.ensure_timedelta64ns": [
                    2489
                ],
                "TimedeltaArray": [
                    2497,
                    2490,
                    2555
                ],
                "rvalues": [
                    2545,
                    2538,
                    2549,
                    2535
                ],
                "np.empty": [
                    2535
                ],
                "imask": [
                    2545,
                    2546,
                    2539
                ],
                "ravel": [
                    2539
                ],
                "rvalues.flat": [
                    2545
                ],
                "_repr_base": [
                    2546
                ],
                "TimedeltaArray._simple_new": [
                    2555
                ],
                "to_replace_values": [
                    2578,
                    2579
                ],
                "np.atleast_1d": [
                    2578
                ],
                "np.can_cast": [
                    2579
                ],
                "replace": [
                    2977,
                    2690,
                    2581,
                    2806
                ],
                "values.dtype.type": [
                    2597
                ],
                "lib.is_bool_array": [
                    2607
                ],
                "val.shape": [
                    2625
                ],
                "soft_convert_objects": [
                    2626
                ],
                "val.ravel": [
                    2627
                ],
                "numeric": [
                    2629
                ],
                "to_rep_is_list": [
                    2672,
                    2674,
                    2675,
                    2714
                ],
                "value_is_list": [
                    2673,
                    2674,
                    2675
                ],
                "both_lists": [
                    2674,
                    2698
                ],
                "either_list": [
                    2680,
                    2689,
                    2675
                ],
                "is_re": [
                    2680,
                    2817,
                    2794,
                    2826
                ],
                "to_rep": [
                    2719,
                    2699,
                    2715,
                    2703
                ],
                "b._replace_single": [
                    2718,
                    2702
                ],
                "to_rep_re": [
                    2791,
                    2781,
                    2775
                ],
                "is_re_compilable": [
                    2778,
                    2775
                ],
                "regex_re": [
                    2778,
                    2788,
                    2781,
                    2791
                ],
                "pattern": [
                    2801,
                    2795,
                    2797
                ],
                "to_replace.pattern": [
                    2795
                ],
                "rx": [
                    2817,
                    2818,
                    2826,
                    2827,
                    2802
                ],
                "re.compile": [
                    2802
                ],
                "re": [
                    2802
                ],
                "rx.search": [
                    2818
                ],
                "rx.sub": [
                    2827
                ],
                "np.vectorize": [
                    2831
                ],
                "re_replacer": [
                    2831
                ],
                "filt": [
                    2841,
                    2834,
                    2836,
                    2839
                ],
                "nonzero": [
                    2836
                ],
                "block.convert": [
                    2846
                ],
                "_replace_coerce": [
                    2876
                ],
                "self.convert": [
                    2888
                ],
                "concat_categorical": [
                    2897
                ],
                "np.object_": [
                    2914
                ],
                "self.values._internal_get_values": [
                    2920
                ],
                "result.values.replace": [
                    2969
                ],
                "result.values": [
                    2976,
                    2969
                ],
                "result.convert": [
                    2971
                ],
                "result.values.add_categories": [
                    2976
                ],
                "CategoricalBlock": [
                    2977,
                    3006
                ],
                "vtype": [
                    3016,
                    3018,
                    3019,
                    3021,
                    3023,
                    3000,
                    3007
                ],
                "cls": [
                    3009,
                    3011,
                    3013,
                    3015,
                    3017,
                    3020,
                    3022,
                    3024,
                    3026,
                    3028,
                    3029,
                    3004,
                    3006
                ],
                "DatetimeTZBlock": [
                    3011,
                    3047
                ],
                "is_interval_dtype": [
                    3012
                ],
                "is_period_dtype": [
                    3012
                ],
                "ObjectValuesExtensionBlock": [
                    3013
                ],
                "FloatBlock": [
                    3017
                ],
                "ComplexBlock": [
                    3022
                ],
                "BoolBlock": [
                    3026
                ],
                "ABCPandasArray": [
                    3035
                ],
                "values.to_numpy": [
                    3036
                ],
                "PandasDtype": [
                    3040
                ],
                "dtype.numpy_dtype": [
                    3041
                ],
                "klass": [
                    3043,
                    3052,
                    3045,
                    3047
                ],
                "get_block_type": [
                    3045
                ],
                "blocks.extend": [
                    3066
                ],
                "blocks.append": [
                    3068,
                    3071
                ],
                "b.dtype": [
                    3096
                ],
                "b.mgr_locs.as_array": [
                    3101
                ],
                "b.mgr_locs": [
                    3101
                ],
                "np.vstack": [
                    3102
                ],
                "b.values": [
                    3102
                ],
                "argsort": [
                    3104,
                    3105,
                    3106
                ],
                "np.argsort": [
                    3104
                ],
                "arr": [
                    3129,
                    3130,
                    3131,
                    3132,
                    3133
                ],
                "ABCSeries": [
                    3129
                ],
                "arr._values": [
                    3130
                ],
                "ABCExtensionArray": [
                    3131
                ],
                "arr.reshape": [
                    3132
                ],
                "nn": [
                    3174,
                    3176,
                    3187,
                    3189,
                    3167
                ],
                "_isna_compat": [
                    3174
                ],
                "nn.dtype": [
                    3176
                ],
                "v.dtype": [
                    3187,
                    3179,
                    3211,
                    3205
                ],
                "warnings.catch_warnings": [
                    3185
                ],
                "warnings": [
                    3185,
                    3186
                ],
                "warnings.simplefilter": [
                    3186
                ],
                "np.ComplexWarning": [
                    3186
                ],
                "nn_at": [
                    3192,
                    3187,
                    3189
                ],
                "nn.astype": [
                    3187
                ],
                "comp": [
                    3189,
                    3190
                ],
                "comp.all": [
                    3190
                ],
                "v.dtype.kind": [
                    3205
                ],
                "n.dtype.kind": [
                    3205
                ],
                "_putmask_preserve": [
                    3216,
                    3206
                ],
                "v._internal_get_values": [
                    3212
                ],
                "v.astype": [
                    3214
                ]
            },
            "filtered_variables_in_file": {
                "PandasObject": [
                    91
                ],
                "__slots__": [
                    2592,
                    99,
                    2022,
                    2118,
                    2028,
                    2893,
                    2481,
                    2038,
                    2102,
                    2300,
                    2173,
                    2559
                ],
                "is_numeric": [
                    2484,
                    100,
                    2023
                ],
                "is_float": [
                    101,
                    2039
                ],
                "is_integer": [
                    2513,
                    2130,
                    102,
                    2119
                ],
                "is_complex": [
                    2103,
                    103
                ],
                "is_datetime": [
                    104,
                    2174
                ],
                "is_datetimetz": [
                    105,
                    2301
                ],
                "is_timedelta": [
                    2482,
                    106
                ],
                "is_bool": [
                    2560,
                    107
                ],
                "is_object": [
                    2593,
                    108
                ],
                "is_categorical": [
                    109,
                    2894,
                    3005
                ],
                "is_extension": [
                    1729,
                    110,
                    2302
                ],
                "_can_hold_na": [
                    2561,
                    2594,
                    2024,
                    2120,
                    111,
                    2896,
                    2483
                ],
                "_can_consolidate": [
                    112,
                    3093,
                    1599
                ],
                "_verify_integrity": [
                    1600,
                    113,
                    2895
                ],
                "_validate_ndim": [
                    1601,
                    114
                ],
                "_ftype": [
                    115
                ],
                "_concatenator": [
                    2897,
                    116
                ],
                "np.concatenate": [
                    116,
                    3101
                ],
                "np": [
                    2048,
                    1025,
                    2051,
                    1541,
                    2566,
                    2567,
                    2570,
                    1550,
                    1551,
                    2578,
                    2579,
                    3101,
                    2078,
                    3102,
                    3104,
                    1533,
                    2598,
                    2098,
                    2108,
                    2110,
                    2111,
                    2114,
                    2634,
                    2126,
                    2127,
                    3162,
                    2145,
                    2664,
                    3186,
                    116,
                    2165,
                    2167,
                    3195,
                    640,
                    1677,
                    2206,
                    688,
                    692,
                    1240,
                    2269,
                    2273,
                    2291,
                    245,
                    1270,
                    761,
                    2307,
                    2831,
                    1808,
                    1817,
                    1826,
                    1330,
                    1331,
                    2365,
                    836,
                    2378,
                    2914,
                    870,
                    2930,
                    1401,
                    382,
                    1406,
                    2430,
                    389,
                    2450,
                    1447,
                    2485,
                    1975,
                    2492,
                    3007,
                    2502,
                    1991,
                    3016,
                    969,
                    2505,
                    3018,
                    3019,
                    3021,
                    3023,
                    3025,
                    467,
                    981,
                    2524,
                    3038,
                    991,
                    993,
                    997,
                    2535,
                    1003,
                    2545,
                    2034,
                    1525,
                    1526,
                    2552,
                    1530,
                    2044,
                    2045,
                    1022,
                    1023
                ],
                "self.ndim": [
                    1921,
                    643,
                    2950,
                    2954,
                    273,
                    401,
                    1809,
                    407,
                    280,
                    2456,
                    1437,
                    1314,
                    420,
                    175,
                    309,
                    1333,
                    1848,
                    1214,
                    703,
                    831,
                    2367,
                    968,
                    330,
                    2638,
                    2641,
                    2645,
                    1878,
                    1626,
                    1885,
                    479,
                    1375,
                    1632,
                    484,
                    359,
                    1512,
                    1390,
                    1009,
                    119,
                    123,
                    2429,
                    2431
                ],
                "self": [
                    2065,
                    2098,
                    2128,
                    2133,
                    2152,
                    2153,
                    2154,
                    2155,
                    2159,
                    119,
                    120,
                    121,
                    123,
                    125,
                    126,
                    2177,
                    153,
                    2218,
                    171,
                    2222,
                    175,
                    180,
                    2230,
                    2232,
                    185,
                    2233,
                    2241,
                    2242,
                    2245,
                    2252,
                    2253,
                    211,
                    217,
                    2265,
                    223,
                    231,
                    232,
                    238,
                    2288,
                    241,
                    2291,
                    2294,
                    249,
                    256,
                    263,
                    271,
                    273,
                    2326,
                    278,
                    280,
                    281,
                    2327,
                    285,
                    286,
                    288,
                    2338,
                    292,
                    294,
                    295,
                    301,
                    304,
                    307,
                    308,
                    309,
                    313,
                    2361,
                    2367,
                    326,
                    328,
                    330,
                    2378,
                    333,
                    337,
                    2385,
                    2386,
                    2387,
                    341,
                    345,
                    346,
                    348,
                    349,
                    352,
                    358,
                    359,
                    361,
                    2413,
                    366,
                    2418,
                    376,
                    2429,
                    382,
                    383,
                    2431,
                    2437,
                    390,
                    392,
                    2441,
                    399,
                    401,
                    402,
                    2449,
                    2454,
                    407,
                    2456,
                    2462,
                    2464,
                    417,
                    2467,
                    420,
                    422,
                    2470,
                    424,
                    2472,
                    426,
                    428,
                    2476,
                    430,
                    431,
                    2477,
                    435,
                    439,
                    447,
                    2507,
                    467,
                    469,
                    479,
                    480,
                    2530,
                    484,
                    489,
                    494,
                    2552,
                    2555,
                    514,
                    525,
                    527,
                    530,
                    2580,
                    537,
                    541,
                    556,
                    2607,
                    2638,
                    592,
                    2641,
                    594,
                    2642,
                    596,
                    2644,
                    598,
                    2645,
                    603,
                    605,
                    606,
                    609,
                    611,
                    616,
                    617,
                    621,
                    624,
                    2678,
                    2681,
                    635,
                    641,
                    643,
                    645,
                    646,
                    649,
                    667,
                    671,
                    679,
                    2730,
                    686,
                    700,
                    703,
                    718,
                    721,
                    722,
                    724,
                    729,
                    730,
                    735,
                    746,
                    750,
                    760,
                    2810,
                    769,
                    774,
                    775,
                    778,
                    2831,
                    788,
                    2836,
                    791,
                    794,
                    2844,
                    809,
                    831,
                    835,
                    839,
                    840,
                    2888,
                    2889,
                    860,
                    861,
                    2920,
                    873,
                    2925,
                    2949,
                    2950,
                    904,
                    2954,
                    2967,
                    922,
                    946,
                    952,
                    954,
                    956,
                    968,
                    969,
                    1009,
                    1036,
                    1040,
                    1045,
                    1059,
                    1060,
                    1062,
                    1064,
                    1066,
                    1070,
                    1073,
                    1081,
                    1083,
                    1086,
                    1090,
                    1093,
                    1096,
                    1099,
                    1100,
                    1103,
                    1107,
                    1109,
                    1132,
                    1134,
                    1136,
                    1145,
                    1148,
                    1160,
                    1163,
                    1194,
                    1196,
                    1198,
                    1200,
                    1203,
                    1211,
                    1214,
                    1215,
                    1234,
                    1237,
                    1238,
                    1239,
                    1243,
                    1272,
                    1273,
                    1285,
                    1288,
                    1302,
                    1304,
                    1305,
                    1307,
                    1311,
                    1314,
                    1315,
                    1322,
                    1333,
                    1344,
                    1375,
                    1377,
                    1390,
                    1399,
                    1404,
                    1426,
                    1435,
                    1437,
                    1442,
                    1453,
                    1454,
                    1460,
                    1462,
                    1485,
                    1512,
                    1514,
                    1526,
                    1535,
                    1582,
                    1583,
                    1585,
                    1593,
                    1626,
                    1627,
                    1628,
                    1632,
                    1635,
                    1639,
                    1640,
                    1643,
                    1644,
                    1647,
                    1651,
                    1675,
                    1683,
                    1732,
                    1755,
                    1760,
                    1765,
                    1774,
                    1802,
                    1803,
                    1804,
                    1808,
                    1809,
                    1814,
                    1817,
                    1821,
                    1844,
                    1848,
                    1850,
                    1852,
                    1870,
                    1876,
                    1878,
                    1881,
                    1884,
                    1885,
                    1893,
                    1894,
                    1896,
                    1918,
                    1919,
                    1920,
                    1921,
                    1952,
                    1954,
                    1960,
                    1962,
                    1974,
                    1975,
                    1978,
                    1982,
                    1995,
                    2000,
                    2001,
                    2018,
                    2031,
                    2033
                ],
                "self._check_ndim": [
                    119
                ],
                "values": [
                    1537,
                    3077,
                    3079,
                    3080,
                    3084,
                    3085,
                    527,
                    2065,
                    2067,
                    536,
                    2073,
                    2076,
                    2078,
                    2080,
                    2081,
                    2597,
                    2086,
                    2598,
                    2600,
                    2626,
                    2634,
                    2636,
                    2638,
                    2639,
                    2644,
                    2645,
                    1622,
                    611,
                    2152,
                    617,
                    2153,
                    621,
                    624,
                    627,
                    1651,
                    629,
                    119,
                    121,
                    640,
                    641,
                    2177,
                    643,
                    2178,
                    1675,
                    1166,
                    151,
                    2200,
                    153,
                    2201,
                    2203,
                    156,
                    2204,
                    2206,
                    2207,
                    679,
                    682,
                    683,
                    2218,
                    2219,
                    2220,
                    687,
                    688,
                    1200,
                    690,
                    2221,
                    692,
                    1205,
                    694,
                    695,
                    1206,
                    700,
                    702,
                    703,
                    1214,
                    1732,
                    1733,
                    2252,
                    2256,
                    2261,
                    1750,
                    2286,
                    2288,
                    760,
                    761,
                    765,
                    767,
                    1285,
                    1295,
                    1808,
                    273,
                    1809,
                    1810,
                    1811,
                    2326,
                    2327,
                    281,
                    2329,
                    2332,
                    1821,
                    1823,
                    1824,
                    1826,
                    1827,
                    1830,
                    2361,
                    2363,
                    2365,
                    2371,
                    2372,
                    839,
                    844,
                    1876,
                    1877,
                    1878,
                    2901,
                    2902,
                    1881,
                    1882,
                    859,
                    2903,
                    1885,
                    1377,
                    1380,
                    1893,
                    358,
                    1895,
                    362,
                    875,
                    1388,
                    2413,
                    878,
                    1390,
                    2925,
                    881,
                    2928,
                    2929,
                    884,
                    885,
                    2930,
                    2931,
                    376,
                    2934,
                    2426,
                    2427,
                    1406,
                    894,
                    1408,
                    2430,
                    2431,
                    899,
                    1412,
                    2949,
                    903,
                    1416,
                    2954,
                    909,
                    1421,
                    912,
                    918,
                    921,
                    922,
                    2222,
                    2999,
                    2488,
                    2489,
                    2490,
                    2491,
                    2492,
                    2493,
                    3005,
                    3008,
                    3010,
                    3014,
                    3035,
                    3036,
                    3038,
                    2530,
                    2532,
                    2533,
                    3044,
                    2535,
                    3045,
                    3047,
                    1514,
                    3050,
                    1516,
                    3052,
                    2546,
                    1526,
                    1527,
                    1530,
                    1532
                ],
                "ndim": [
                    2178,
                    3077,
                    1550,
                    1551,
                    150,
                    279,
                    151,
                    281,
                    280,
                    153,
                    156,
                    158,
                    2600,
                    2493,
                    1733,
                    1617,
                    1619,
                    1621,
                    1622,
                    2903,
                    3037,
                    3052,
                    119
                ],
                "self.mgr_locs": [
                    1920,
                    769,
                    643,
                    271,
                    399,
                    2836,
                    278,
                    1302,
                    2456,
                    294,
                    1454,
                    304,
                    307,
                    1850,
                    1978,
                    326,
                    2645,
                    1628,
                    1885,
                    1896,
                    489,
                    494,
                    2418,
                    120,
                    123,
                    126,
                    383
                ],
                "placement": [
                    2432,
                    2178,
                    2954,
                    270,
                    271,
                    273,
                    277,
                    278,
                    281,
                    2600,
                    2493,
                    1733,
                    1613,
                    1614,
                    1618,
                    1877,
                    1622,
                    1878,
                    2903,
                    362,
                    3052,
                    120,
                    2427,
                    2431
                ],
                "self.values": [
                    527,
                    2065,
                    2607,
                    594,
                    596,
                    2644,
                    598,
                    1627,
                    1628,
                    611,
                    1639,
                    1640,
                    2152,
                    2154,
                    2155,
                    1644,
                    1651,
                    121,
                    123,
                    125,
                    1675,
                    671,
                    2218,
                    1200,
                    1203,
                    180,
                    700,
                    2252,
                    2253,
                    1234,
                    211,
                    217,
                    2265,
                    1755,
                    223,
                    1760,
                    231,
                    232,
                    1774,
                    2288,
                    241,
                    2291,
                    2294,
                    760,
                    2810,
                    1285,
                    1802,
                    1803,
                    1808,
                    1814,
                    1817,
                    1821,
                    1311,
                    2338,
                    1322,
                    301,
                    304,
                    308,
                    309,
                    1844,
                    313,
                    2361,
                    839,
                    2378,
                    1870,
                    337,
                    2386,
                    2387,
                    341,
                    345,
                    1881,
                    1377,
                    1893,
                    2920,
                    2413,
                    366,
                    2925,
                    376,
                    382,
                    1919,
                    390,
                    904,
                    2454,
                    2464,
                    417,
                    1954,
                    2467,
                    1962,
                    946,
                    1462,
                    1975,
                    1982,
                    1485,
                    2001,
                    469,
                    2018,
                    2530,
                    2033,
                    2552,
                    2555
                ],
                "self._validate_ndim": [
                    153,
                    330,
                    123
                ],
                "values.ndim": [
                    1537,
                    3077,
                    1388,
                    1390,
                    1809,
                    151,
                    153,
                    156
                ],
                "self._can_consolidate": [
                    171
                ],
                "self.dtype.name": [
                    649,
                    171
                ],
                "self.dtype": [
                    263,
                    649,
                    2831,
                    1304,
                    2462,
                    288,
                    1952,
                    1059,
                    295,
                    1960,
                    171,
                    2476,
                    1453,
                    2098,
                    1460,
                    2232,
                    2233,
                    1211,
                    1086,
                    2242,
                    2245,
                    2507,
                    2128,
                    2133,
                    346,
                    603,
                    860,
                    348,
                    2031
                ],
                "self.values.base": [
                    180
                ],
                "self.is_datetime": [
                    185,
                    514,
                    1081,
                    1073
                ],
                "self.is_timedelta": [
                    514,
                    1096,
                    1099,
                    1132,
                    185
                ],
                "dtype": [
                    1028,
                    1031,
                    3209,
                    3211,
                    3212,
                    3214,
                    3095,
                    671,
                    1057,
                    674,
                    675,
                    1059,
                    1062,
                    1958,
                    1960,
                    2214,
                    2217,
                    1067,
                    2221,
                    2225,
                    1074,
                    1075,
                    1975,
                    1080,
                    2999,
                    2362,
                    3000,
                    3002,
                    1087,
                    192,
                    195,
                    3012,
                    197,
                    584,
                    1096,
                    586,
                    1099,
                    592,
                    3025,
                    851,
                    596,
                    1107,
                    598,
                    855,
                    600,
                    346,
                    603,
                    348,
                    349,
                    859,
                    860,
                    861,
                    3040,
                    3041,
                    611,
                    3044,
                    613,
                    230,
                    2151,
                    3045,
                    874,
                    875,
                    3050,
                    238,
                    624,
                    629
                ],
                "Categorical": [
                    192,
                    904,
                    2902,
                    598,
                    2907
                ],
                "CategoricalDtype": [
                    192
                ],
                "is_categorical_dtype": [
                    594,
                    899,
                    197,
                    898
                ],
                "PandasArray": [
                    223
                ],
                "ExtensionArray": [
                    2293,
                    2554,
                    219,
                    1813
                ],
                "is_object_dtype": [
                    1062,
                    230,
                    2151,
                    746,
                    3211,
                    788,
                    2362
                ],
                "self.values.astype": [
                    2018,
                    611,
                    231,
                    2291,
                    596,
                    2454,
                    2552
                ],
                "self.get_values": [
                    679,
                    1514,
                    621,
                    238,
                    624
                ],
                "self.values.view": [
                    2464,
                    241,
                    2467,
                    2253
                ],
                "np.nan": [
                    836,
                    245
                ],
                "self._mgr_locs": [
                    256,
                    249
                ],
                "new_mgr_locs": [
                    256,
                    1300,
                    1301,
                    1302,
                    1305,
                    1307,
                    3101,
                    3104,
                    3106,
                    3108,
                    1848,
                    1849,
                    1850,
                    1852,
                    321,
                    326,
                    333,
                    253,
                    254
                ],
                "libinternals.BlockPlacement": [
                    1613,
                    1614,
                    307,
                    1908,
                    253,
                    254
                ],
                "libinternals": [
                    1613,
                    1614,
                    307,
                    1908,
                    253,
                    254
                ],
                "mgr_locs.setter": [
                    251
                ],
                "mgr_locs": [
                    251
                ],
                "make_block": [
                    643,
                    3108,
                    2953,
                    1551,
                    273,
                    2645,
                    1494,
                    2455,
                    281
                ],
                "name": [
                    288,
                    285,
                    294
                ],
                "self._is_single_block": [
                    530,
                    286
                ],
                "result": [
                    1541,
                    390,
                    1542,
                    392,
                    1416,
                    1544,
                    1546,
                    396,
                    1421,
                    1547,
                    1548,
                    400,
                    1550,
                    1551,
                    2702,
                    406,
                    407,
                    2167,
                    409,
                    2710,
                    2967,
                    2969,
                    2971,
                    2718,
                    2973,
                    288,
                    1440,
                    1442,
                    2976,
                    2977,
                    293,
                    2726,
                    298,
                    1962,
                    1452,
                    1969,
                    3063,
                    1974,
                    3064,
                    1978,
                    2263,
                    2269,
                    2153,
                    2154,
                    2164,
                    1525,
                    2165,
                    2166,
                    2168,
                    2169,
                    1531,
                    3070,
                    3071
                ],
                "shape": [
                    2625,
                    292,
                    3078,
                    295,
                    3079,
                    2636,
                    3084,
                    984
                ],
                "join": [
                    292
                ],
                "pprint_thing": [
                    292,
                    294
                ],
                "s": [
                    2817,
                    2818,
                    292,
                    2820,
                    2826,
                    2827,
                    2829
                ],
                "self.shape": [
                    641,
                    292,
                    646,
                    2470,
                    649,
                    969,
                    2031,
                    467,
                    1460,
                    2462
                ],
                "self.mgr_locs.indexer": [
                    304,
                    2418,
                    294
                ],
                "state": [
                    307,
                    308
                ],
                "self.values.ndim": [
                    309
                ],
                "slicer": [
                    2066,
                    2067,
                    1822,
                    1823,
                    681,
                    682,
                    313,
                    322,
                    323,
                    325,
                    328,
                    1865,
                    1866,
                    1868,
                    1870,
                    2255,
                    2256,
                    2257,
                    2382,
                    2383,
                    2387,
                    2531,
                    2532,
                    2926,
                    2928
                ],
                "axis0_slicer": [
                    323,
                    325,
                    326
                ],
                "new_values": [
                    1675,
                    1294,
                    1680,
                    1682,
                    1043,
                    1683,
                    1045,
                    2839,
                    1304,
                    1305,
                    2841,
                    1307,
                    2844,
                    3102,
                    1311,
                    3105,
                    1314,
                    1315,
                    3108,
                    1322,
                    1325,
                    1327,
                    1328,
                    1712,
                    946,
                    1330,
                    1331,
                    1715,
                    1844,
                    1338,
                    1852,
                    1342,
                    960,
                    1344,
                    963,
                    328,
                    969,
                    330,
                    970,
                    1995,
                    333,
                    1488,
                    1491,
                    2004,
                    469,
                    1494,
                    991,
                    993,
                    997,
                    486,
                    488,
                    1005,
                    2413,
                    496,
                    2416,
                    2417,
                    2418,
                    2810
                ],
                "self._slice": [
                    328
                ],
                "new_values.ndim": [
                    1328,
                    330,
                    1005
                ],
                "self.make_block_same_class": [
                    1894,
                    1884,
                    361,
                    333,
                    2477,
                    2000,
                    1918,
                    1878,
                    1272,
                    1978,
                    1307,
                    1852,
                    1214,
                    703
                ],
                "self.values.shape": [
                    337,
                    2154
                ],
                "self.values.dtype": [
                    1760,
                    1774,
                    1203,
                    341,
                    671
                ],
                "self.dtype.subtype": [
                    346
                ],
                "self._ftype": [
                    349
                ],
                "_merge_blocks": [
                    352
                ],
                "other": [
                    1408,
                    1412,
                    1421,
                    1934,
                    1937,
                    1426,
                    1938,
                    1940,
                    1948,
                    2462,
                    1952,
                    1057,
                    2464,
                    1964,
                    1965,
                    1967,
                    1460,
                    1462,
                    1975,
                    1093,
                    1103,
                    352,
                    1378,
                    1382,
                    1387,
                    1388,
                    1389,
                    2031,
                    2033,
                    1400,
                    1401,
                    1404,
                    1406
                ],
                "self._concatenator": [
                    2949,
                    358
                ],
                "blk.values": [
                    1876,
                    2950,
                    359
                ],
                "blk": [
                    2950,
                    359,
                    2472,
                    2473,
                    1876
                ],
                "to_concat": [
                    2432,
                    2950,
                    359,
                    1876,
                    2425,
                    2426
                ],
                "i": [
                    1447,
                    494,
                    495,
                    400,
                    366,
                    399,
                    496,
                    500
                ],
                "locs": [
                    376,
                    1650,
                    2288
                ],
                "np.delete": [
                    382
                ],
                "loc": [
                    1633,
                    1639,
                    1640,
                    399,
                    2383,
                    402,
                    2386,
                    382,
                    383
                ],
                "self.mgr_locs.delete": [
                    383
                ],
                "np.errstate": [
                    389
                ],
                "func": [
                    1270,
                    390
                ],
                "kwargs": [
                    1158,
                    390,
                    809,
                    1266,
                    1174,
                    2520
                ],
                "self._split_op_result": [
                    392
                ],
                "List": [
                    385,
                    509,
                    394,
                    1354,
                    1899,
                    1933,
                    2389,
                    1910,
                    2649,
                    1309
                ],
                "is_extension_array_dtype": [
                    865,
                    2275,
                    3014,
                    3080,
                    2570,
                    2666,
                    396,
                    3211,
                    2525
                ],
                "result.ndim": [
                    396
                ],
                "nbs": [
                    403,
                    404,
                    398
                ],
                "vals": [
                    400,
                    401
                ],
                "nv": [
                    3201,
                    3202,
                    1033,
                    1034,
                    401,
                    402,
                    536,
                    537,
                    3192,
                    472,
                    473,
                    474,
                    475,
                    479,
                    480,
                    486,
                    488,
                    489,
                    500,
                    502,
                    3191,
                    504,
                    3193,
                    3199
                ],
                "_block_shape": [
                    1314,
                    2638,
                    401,
                    407,
                    479
                ],
                "block": [
                    402,
                    403,
                    1426,
                    1427,
                    794,
                    795,
                    923,
                    922,
                    2844,
                    2846,
                    2847,
                    439,
                    444,
                    445,
                    2876,
                    2885,
                    2886,
                    475,
                    480,
                    481,
                    489,
                    490,
                    750,
                    751,
                    504,
                    505
                ],
                "self.make_block": [
                    480,
                    1344,
                    1442,
                    1315,
                    1305,
                    904,
                    2472,
                    1454,
                    2222,
                    402,
                    1683,
                    596,
                    1045,
                    598,
                    407,
                    537,
                    922,
                    2844
                ],
                "nbs.append": [
                    403
                ],
                "Block": [
                    2304,
                    2021,
                    1718,
                    406,
                    3070,
                    474,
                    2172,
                    1982,
                    2591
                ],
                "inplace": [
                    773,
                    2438,
                    1671,
                    1160,
                    2693,
                    778,
                    1675,
                    1036,
                    2442,
                    1039,
                    2577,
                    2705,
                    1172,
                    2966,
                    2967,
                    2584,
                    2971,
                    798,
                    415,
                    2721,
                    2978,
                    804,
                    1189,
                    423,
                    1195,
                    2733,
                    430,
                    1583,
                    1200,
                    946,
                    435,
                    1588,
                    445,
                    447,
                    2879,
                    713,
                    720,
                    1233,
                    1234,
                    2772,
                    728,
                    1881,
                    738,
                    1893,
                    1127,
                    488,
                    1133,
                    754,
                    502,
                    2807,
                    1145,
                    2810,
                    2684,
                    1151
                ],
                "validate_bool_kwarg": [
                    1189,
                    1127,
                    1671,
                    713,
                    1233,
                    2577,
                    2772,
                    2966,
                    415
                ],
                "mask": [
                    1536,
                    3201,
                    770,
                    772,
                    1033,
                    778,
                    1036,
                    1677,
                    1678,
                    1680,
                    1682,
                    2838,
                    2073,
                    2841,
                    1824,
                    417,
                    2080,
                    1827,
                    420,
                    1447,
                    1450,
                    683,
                    1580,
                    430,
                    1583,
                    1712,
                    434,
                    1714,
                    1715,
                    949,
                    694,
                    1591,
                    2875,
                    2882,
                    1995,
                    1488,
                    466,
                    467,
                    1490,
                    981,
                    1491,
                    1492,
                    984,
                    1495,
                    2006,
                    3162,
                    991,
                    992,
                    993,
                    3167,
                    3199,
                    485,
                    486,
                    997,
                    1000,
                    2533,
                    1002,
                    2538,
                    2539,
                    495,
                    2929,
                    2931,
                    3192,
                    1530,
                    767
                ],
                "isna": [
                    1824,
                    417,
                    2533,
                    683,
                    2929,
                    854,
                    952,
                    2073,
                    1530,
                    1948,
                    2814,
                    2975
                ],
                "limit": [
                    1152,
                    418,
                    419,
                    420,
                    2438,
                    1895,
                    2442,
                    1261,
                    1168,
                    1209,
                    1882,
                    445
                ],
                "libalgos._validate_limit": [
                    419
                ],
                "libalgos": [
                    419
                ],
                "mask.cumsum": [
                    420
                ],
                "self._can_hold_na": [
                    1194,
                    1437,
                    422
                ],
                "self.copy": [
                    775,
                    809,
                    426,
                    1675,
                    1198,
                    1136,
                    722,
                    435,
                    2967,
                    730,
                    635,
                    667,
                    605
                ],
                "self._can_hold_element": [
                    2437,
                    840,
                    873,
                    428,
                    718,
                    2449,
                    724,
                    791,
                    1404,
                    956
                ],
                "value": [
                    2818,
                    2692,
                    2437,
                    2438,
                    903,
                    778,
                    1802,
                    1803,
                    909,
                    2442,
                    2570,
                    2571,
                    2449,
                    2699,
                    2827,
                    2452,
                    918,
                    791,
                    2583,
                    2969,
                    2458,
                    797,
                    2975,
                    2720,
                    2976,
                    2978,
                    428,
                    2732,
                    430,
                    1582,
                    1583,
                    2098,
                    1587,
                    439,
                    445,
                    2878,
                    834,
                    2114,
                    836,
                    840,
                    843,
                    844,
                    2814,
                    2513,
                    850,
                    851,
                    2133,
                    854,
                    855,
                    2520,
                    1882,
                    2524,
                    2525,
                    862,
                    737,
                    865,
                    2273,
                    868,
                    2274,
                    870,
                    2275,
                    2663,
                    873,
                    2666,
                    1647,
                    753,
                    881,
                    2673,
                    2807,
                    2683,
                    894
                ],
                "blocks": [
                    3072,
                    516,
                    518,
                    778,
                    2701,
                    3090,
                    1427,
                    3091,
                    2711,
                    3096,
                    1435,
                    2717,
                    3101,
                    3102,
                    804,
                    805,
                    2727,
                    3111,
                    430,
                    431,
                    1214,
                    1215,
                    1999,
                    2642,
                    2645,
                    1494,
                    1495,
                    2006,
                    2647,
                    2652,
                    2655,
                    3061,
                    2678,
                    3062,
                    1272,
                    1273,
                    3066,
                    3068,
                    3071
                ],
                "self.putmask": [
                    778,
                    430,
                    1583
                ],
                "self._maybe_downcast": [
                    1215,
                    1435,
                    1273,
                    431
                ],
                "downcast": [
                    513,
                    1155,
                    518,
                    2438,
                    2442,
                    431,
                    1173,
                    1273,
                    2651,
                    1215
                ],
                "mask.any": [
                    772,
                    485,
                    1000,
                    1580,
                    1490,
                    434,
                    1714,
                    2875
                ],
                "self.coerce_to_target_dtype": [
                    1426,
                    1582,
                    439
                ],
                "idx": [
                    1017,
                    442,
                    444,
                    1023
                ],
                "block.getitem_block": [
                    444
                ],
                "block.fillna": [
                    445
                ],
                "self.split_and_operate": [
                    2642,
                    556,
                    1036,
                    447
                ],
                "f": [
                    486,
                    1036,
                    556,
                    2831,
                    2642,
                    500,
                    2644,
                    2839,
                    2841,
                    447
                ],
                "np.broadcast_to": [
                    467
                ],
                "ref_loc": [
                    480,
                    504,
                    494
                ],
                "new_values.copy": [
                    488
                ],
                "make_a_block": [
                    504,
                    489
                ],
                "new_blocks": [
                    1036,
                    1037,
                    493,
                    505,
                    507
                ],
                "m": [
                    1158,
                    1450,
                    1451,
                    1164,
                    1452,
                    1454,
                    495,
                    499,
                    1140,
                    500,
                    1142,
                    1144,
                    1149
                ],
                "v": [
                    3205,
                    3174,
                    3206,
                    2699,
                    3179,
                    3211,
                    3212,
                    3214,
                    496,
                    2704,
                    3216,
                    3187,
                    500,
                    502,
                    3191
                ],
                "m.any": [
                    499,
                    1451
                ],
                "v.copy": [
                    502,
                    3191
                ],
                "new_blocks.append": [
                    505
                ],
                "self.is_float": [
                    514,
                    1066,
                    1237
                ],
                "_extend_blocks": [
                    2710,
                    2726,
                    518,
                    2655
                ],
                "b.downcast": [
                    518
                ],
                "b": [
                    804,
                    2885,
                    518,
                    2717,
                    2718,
                    2701,
                    2702,
                    3101,
                    3102,
                    3096,
                    861,
                    862,
                    2655
                ],
                "dtypes": [
                    547,
                    524,
                    533,
                    534,
                    536,
                    540,
                    543
                ],
                "maybe_downcast_to_dtype": [
                    536,
                    553
                ],
                "val": [
                    2625,
                    2627,
                    553,
                    554,
                    1033,
                    2546
                ],
                "errors_legal_values": [
                    577,
                    580,
                    575
                ],
                "errors": [
                    577,
                    580,
                    2225,
                    1431,
                    633,
                    1374
                ],
                "invalid_arg": [
                    578,
                    582
                ],
                "inspect.isclass": [
                    584
                ],
                "inspect": [
                    584
                ],
                "ExtensionDtype": [
                    584
                ],
                "msg": [
                    585,
                    589
                ],
                "dtype.__name__": [
                    586
                ],
                "self.is_categorical_astype": [
                    592
                ],
                "copy": [
                    648,
                    2632,
                    2225,
                    596,
                    635,
                    667,
                    604
                ],
                "pandas_dtype": [
                    600,
                    2214
                ],
                "is_dtype_equal": [
                    1059,
                    1304,
                    603,
                    860,
                    2232
                ],
                "self.is_extension": [
                    609
                ],
                "dtype.type": [
                    3000,
                    613
                ],
                "self.is_datelike": [
                    616
                ],
                "self.to_native_types": [
                    617
                ],
                "vals1d": [
                    627,
                    629
                ],
                "values.ravel": [
                    2546,
                    627
                ],
                "astype_nansafe": [
                    629
                ],
                "newb": [
                    643,
                    645,
                    646,
                    650,
                    652,
                    2455,
                    2458,
                    635,
                    636
                ],
                "np.ndarray": [
                    640,
                    2634,
                    1003,
                    1677,
                    2450,
                    1022,
                    761,
                    2206,
                    2492,
                    1406
                ],
                "values.reshape": [
                    641,
                    2371,
                    1830,
                    2636,
                    3084,
                    1810,
                    2934
                ],
                "newb.is_numeric": [
                    645
                ],
                "self.is_numeric": [
                    835,
                    645
                ],
                "newb.shape": [
                    650,
                    646
                ],
                "newb.dtype.name": [
                    650
                ],
                "newb.dtype": [
                    650
                ],
                "Any": [
                    2657,
                    2499,
                    2563,
                    2122,
                    2227,
                    1909,
                    2041,
                    669,
                    1854,
                    2105
                ],
                "self.values.dtype.type": [
                    671
                ],
                "tipo": [
                    2564,
                    2565,
                    2566,
                    672,
                    673,
                    674,
                    2228,
                    2229,
                    2232,
                    2106,
                    2107,
                    2108,
                    2237,
                    2500,
                    2501,
                    2502,
                    2123,
                    2124,
                    2126,
                    2127,
                    2128,
                    2042,
                    2043,
                    2044,
                    2045
                ],
                "maybe_infer_dtype_type": [
                    672,
                    2106,
                    2500,
                    2564,
                    2123,
                    2228,
                    2042
                ],
                "element": [
                    2048,
                    2050,
                    2564,
                    2567,
                    672,
                    675,
                    2228,
                    2233,
                    2106,
                    2238,
                    2110,
                    2240,
                    2111,
                    2242,
                    2243,
                    2500,
                    2245,
                    2503,
                    2505,
                    2123,
                    2507,
                    2130,
                    2042
                ],
                "tipo.type": [
                    674,
                    2502,
                    2566,
                    2126,
                    2108,
                    2127,
                    2044,
                    2045
                ],
                "itemsize": [
                    688,
                    690,
                    684,
                    686
                ],
                "writers.word_len": [
                    684
                ],
                "writers": [
                    684
                ],
                "na_rep": [
                    2080,
                    1827,
                    2087,
                    2536,
                    2537,
                    2538,
                    684,
                    2931,
                    694,
                    2267
                ],
                "self.is_object": [
                    952,
                    686
                ],
                "quoting": [
                    2090,
                    2075,
                    686
                ],
                "values.astype": [
                    1826,
                    875,
                    687,
                    912,
                    690,
                    2363,
                    2076
                ],
                "values.dtype.itemsize": [
                    688
                ],
                "values.dtype": [
                    1408,
                    3044,
                    2597,
                    2488,
                    844,
                    688,
                    2999,
                    2200,
                    859,
                    765
                ],
                "np.dtype": [
                    688
                ],
                "np.array": [
                    1025,
                    1541,
                    870,
                    1447,
                    2598,
                    2545,
                    2930,
                    692,
                    1526,
                    1533,
                    2078
                ],
                "deep": [
                    701
                ],
                "values.copy": [
                    702
                ],
                "original_to_replace": [
                    714,
                    796
                ],
                "to_replace": [
                    2691,
                    2699,
                    2578,
                    2582,
                    2969,
                    2715,
                    2978,
                    2731,
                    1586,
                    2877,
                    714,
                    718,
                    719,
                    724,
                    725,
                    2775,
                    732,
                    736,
                    2789,
                    2794,
                    2795,
                    2797,
                    752,
                    2672,
                    2802,
                    2807,
                    2680,
                    761,
                    2682,
                    765,
                    767
                ],
                "x": [
                    2425,
                    2426,
                    1259,
                    724
                ],
                "self.replace": [
                    735
                ],
                "regex": [
                    2689,
                    2695,
                    2707,
                    2714,
                    2586,
                    800,
                    2978,
                    2723,
                    1581,
                    2736,
                    1589,
                    2880,
                    2775,
                    2778,
                    740,
                    2789,
                    2791,
                    2801,
                    756,
                    2807
                ],
                "convert": [
                    801,
                    2881,
                    803,
                    2724,
                    741,
                    2884,
                    2887,
                    2696,
                    2978,
                    2735,
                    2708,
                    757,
                    1590,
                    2970,
                    2587,
                    2845,
                    2687
                ],
                "self.astype": [
                    1090,
                    1064,
                    2441,
                    1100,
                    750,
                    1107,
                    1109,
                    794,
                    1083,
                    861
                ],
                "block.replace": [
                    795,
                    751
                ],
                "lib.is_scalar": [
                    1544,
                    843,
                    1964,
                    854,
                    761,
                    1948,
                    1406,
                    959
                ],
                "lib": [
                    1544,
                    843,
                    1548,
                    1964,
                    2607,
                    854,
                    1400,
                    761,
                    1948,
                    1406,
                    959
                ],
                "convert_scalar_for_putitemlike": [
                    960,
                    1408,
                    844,
                    1203,
                    765
                ],
                "missing.mask_missing": [
                    767
                ],
                "missing": [
                    1158,
                    1257,
                    1140,
                    1205,
                    767
                ],
                "filtered_out": [
                    769,
                    770
                ],
                "self.mgr_locs.isin": [
                    769,
                    2836
                ],
                "filtered_out.nonzero": [
                    770
                ],
                "b.convert": [
                    804,
                    2885,
                    2655
                ],
                "transpose": [
                    962,
                    1379,
                    1375,
                    1439,
                    1001,
                    877,
                    1390,
                    1042,
                    920,
                    831
                ],
                "find_dtype": [
                    848,
                    858,
                    856,
                    852
                ],
                "value.dtype": [
                    2273,
                    2114,
                    2663,
                    2570,
                    2098,
                    851,
                    2133,
                    2524
                ],
                "_": [
                    1057,
                    1028,
                    3209,
                    874,
                    855
                ],
                "infer_dtype_from_scalar": [
                    855
                ],
                "find_common_type": [
                    859
                ],
                "b.setitem": [
                    862
                ],
                "indexer": [
                    1798,
                    903,
                    1800,
                    1802,
                    1803,
                    909,
                    1295,
                    881,
                    862,
                    2450,
                    1844,
                    2452,
                    918,
                    887,
                    2458,
                    891,
                    894
                ],
                "arr_value": [
                    898,
                    868,
                    870,
                    904,
                    874,
                    912,
                    883,
                    884,
                    885,
                    887,
                    891
                ],
                "maybe_promote": [
                    3209,
                    874,
                    1028
                ],
                "arr_value.dtype": [
                    904,
                    874,
                    912,
                    898
                ],
                "values.T": [
                    921,
                    1380,
                    878
                ],
                "check_setitem_lengths": [
                    881,
                    1802
                ],
                "exact_match": [
                    897,
                    882,
                    908
                ],
                "arr_value.shape": [
                    883,
                    884
                ],
                "values.shape": [
                    3079,
                    2535,
                    1516,
                    1810,
                    884
                ],
                "arr_value.size": [
                    885
                ],
                "values.size": [
                    885
                ],
                "is_empty_indexer": [
                    887
                ],
                "is_scalar_indexer": [
                    891
                ],
                "self.values.copy": [
                    1893,
                    1962,
                    1200,
                    1234,
                    946,
                    1881,
                    2810
                ],
                "new": [
                    1025,
                    1677,
                    1678,
                    1682,
                    948,
                    952,
                    954,
                    956,
                    959,
                    960,
                    967,
                    968,
                    969,
                    970,
                    980,
                    982,
                    984,
                    991,
                    992,
                    993,
                    997,
                    1003,
                    1004,
                    1008,
                    1009,
                    1010,
                    1012,
                    1019,
                    1022,
                    1023
                ],
                "is_list_like": [
                    1517,
                    2672,
                    2673,
                    980,
                    3190,
                    952,
                    3161
                ],
                "self.fill_value": [
                    1288,
                    1526,
                    954,
                    1243,
                    1535
                ],
                "new_values.dtype": [
                    960,
                    1304,
                    970
                ],
                "new_values.T": [
                    963,
                    1327,
                    1043,
                    1491,
                    2004,
                    1342
                ],
                "new.ndim": [
                    968,
                    1009
                ],
                "axis": [
                    1167,
                    1295,
                    1300,
                    1433,
                    1311,
                    1445,
                    1446,
                    1534,
                    2473,
                    1452,
                    1328,
                    1331,
                    1335,
                    1208,
                    1337,
                    968,
                    2409,
                    1388,
                    1005,
                    1516,
                    1900,
                    1902,
                    1903,
                    2413,
                    1011,
                    1270,
                    1150
                ],
                "reshape": [
                    969,
                    1525,
                    2263
                ],
                "np.repeat": [
                    969,
                    3162,
                    1525
                ],
                "new_values.shape": [
                    1680,
                    969,
                    1330
                ],
                "new.astype": [
                    970
                ],
                "np.any": [
                    981
                ],
                "np.place": [
                    991
                ],
                "mask.shape": [
                    992
                ],
                "np.putmask": [
                    993,
                    997
                ],
                "mask.T": [
                    1002
                ],
                "new.T": [
                    1004
                ],
                "new_shape": [
                    1010,
                    1011,
                    1012,
                    3132
                ],
                "new.shape": [
                    1010,
                    1023
                ],
                "new_shape.insert": [
                    1011
                ],
                "new.reshape": [
                    1012
                ],
                "n": [
                    1025,
                    3201,
                    1028,
                    3205,
                    3206,
                    1031,
                    1019,
                    1033,
                    3209,
                    3216,
                    1023,
                    1311,
                    3161,
                    3162,
                    3167,
                    2413,
                    1903,
                    3195,
                    3199
                ],
                "np.squeeze": [
                    1023
                ],
                "n.dtype": [
                    3209,
                    1028,
                    3205
                ],
                "n.astype": [
                    1031
                ],
                "_putmask_smart": [
                    1033
                ],
                "infer_dtype_from": [
                    1057
                ],
                "self.is_bool": [
                    1132,
                    1062,
                    1399
                ],
                "is_bool_dtype": [
                    1062
                ],
                "self.is_complex": [
                    1066
                ],
                "is_integer_dtype": [
                    3176,
                    3179,
                    1067,
                    2133
                ],
                "is_float_dtype": [
                    3176,
                    3179,
                    1067
                ],
                "is_datetime64_dtype": [
                    1080,
                    1074,
                    2237
                ],
                "is_datetime64tz_dtype": [
                    3008,
                    2274,
                    3010,
                    3047,
                    2217,
                    1075,
                    1080
                ],
                "mytz": [
                    1089,
                    1086
                ],
                "othertz": [
                    1089,
                    1087
                ],
                "tz_compare": [
                    1089,
                    2242
                ],
                "is_timedelta64_dtype": [
                    1096,
                    1099
                ],
                "self.is_integer": [
                    1132,
                    1238,
                    1399
                ],
                "missing.clean_fill_method": [
                    1140
                ],
                "method": [
                    1248,
                    1158,
                    1895,
                    1260,
                    1140,
                    1207,
                    1245
                ],
                "r": [
                    3066,
                    1160,
                    1161,
                    1162,
                    1453,
                    1454,
                    3064,
                    1145,
                    1146,
                    1147,
                    3068,
                    3065
                ],
                "check_int_bool": [
                    1160,
                    1145
                ],
                "self._interpolate_with_fill": [
                    1148
                ],
                "fill_value": [
                    1153,
                    2307,
                    1288,
                    1291,
                    1295,
                    1171,
                    1322,
                    1837,
                    1839,
                    1203,
                    1844,
                    2485,
                    1338,
                    1210,
                    2001,
                    1242,
                    1243,
                    1895,
                    1264,
                    1919
                ],
                "coerce": [
                    1193,
                    1154,
                    2631
                ],
                "missing.clean_interp_method": [
                    1158
                ],
                "self._interpolate": [
                    1163
                ],
                "index": [
                    1258,
                    1165,
                    1246
                ],
                "limit_direction": [
                    1169,
                    1262
                ],
                "limit_area": [
                    1170,
                    1263
                ],
                "missing.interpolate_2d": [
                    1205
                ],
                "data": [
                    1240,
                    1234,
                    1270
                ],
                "data.astype": [
                    1240
                ],
                "np.float64": [
                    1240
                ],
                "index.is_monotonic": [
                    1246
                ],
                "missing.interpolate_1d": [
                    1257
                ],
                "interp_values": [
                    1272,
                    1270
                ],
                "np.apply_along_axis": [
                    1270
                ],
                "fill_tuple": [
                    1291,
                    1836,
                    1839,
                    1287
                ],
                "allow_fill": [
                    1289,
                    1292,
                    1295
                ],
                "algos.take_nd": [
                    1294
                ],
                "algos": [
                    1294,
                    1311
                ],
                "algos.diff": [
                    1311
                ],
                "maybe_upcast": [
                    1322
                ],
                "f_ordered": [
                    1341,
                    1325,
                    1326
                ],
                "new_values.flags.f_contiguous": [
                    1325
                ],
                "new_values.flags": [
                    1325
                ],
                "np.prod": [
                    1330
                ],
                "np.roll": [
                    1331
                ],
                "ensure_platform_int": [
                    1331
                ],
                "periods": [
                    1331,
                    1334,
                    1335,
                    1337,
                    1919
                ],
                "axis_indexer": [
                    1337,
                    1338,
                    1333,
                    1335
                ],
                "orig_other": [
                    1378,
                    1428
                ],
                "cond": [
                    1412,
                    1445,
                    1446,
                    1415,
                    1383,
                    1447,
                    1963,
                    1421,
                    1391,
                    1393,
                    1975,
                    1429,
                    1942,
                    1943,
                    1944,
                    1946
                ],
                "other.ndim": [
                    1388
                ],
                "other.reshape": [
                    1389
                ],
                "other.shape": [
                    1389,
                    2031,
                    1937,
                    1460,
                    2462
                ],
                "cond.T": [
                    1391
                ],
                "lib.is_float": [
                    1400
                ],
                "np.isnan": [
                    1401,
                    2034
                ],
                "fastres": [
                    1412,
                    1413
                ],
                "expressions.where": [
                    1412
                ],
                "expressions": [
                    1412
                ],
                "cond.ravel": [
                    1415
                ],
                "where_func": [
                    1421
                ],
                "block.where": [
                    1427
                ],
                "align": [
                    1430
                ],
                "try_cast": [
                    1432
                ],
                "result.T": [
                    1440,
                    1542
                ],
                "cond.ndim": [
                    1445
                ],
                "cond.swapaxes": [
                    1446
                ],
                "cond.shape": [
                    1943,
                    1447
                ],
                "result_blocks": [
                    2726,
                    2727,
                    2728,
                    1449,
                    2700,
                    1455,
                    1457,
                    2677,
                    2710,
                    2711,
                    2712,
                    2716
                ],
                "taken": [
                    1452,
                    1453
                ],
                "result.take": [
                    1452
                ],
                "m.nonzero": [
                    1452
                ],
                "maybe_downcast_numeric": [
                    1453
                ],
                "nb": [
                    1454,
                    1455
                ],
                "r.T": [
                    1454
                ],
                "result_blocks.append": [
                    1455
                ],
                "other.dtype": [
                    1460,
                    2462,
                    2031
                ],
                "array_equivalent": [
                    1462
                ],
                "other.values": [
                    2464,
                    2033,
                    1462
                ],
                "unstacker": [
                    1993,
                    1996,
                    1485,
                    1710,
                    1486,
                    1488,
                    1712
                ],
                "unstacker_func": [
                    1992,
                    1485
                ],
                "self.values.T": [
                    1485
                ],
                "new_items": [
                    1711,
                    1710,
                    1486,
                    1487
                ],
                "unstacker.get_new_columns": [
                    1710,
                    1486
                ],
                "new_placement": [
                    1995,
                    1711,
                    1487,
                    1715,
                    1492,
                    2004,
                    1494
                ],
                "new_columns.get_indexer": [
                    1711,
                    1487
                ],
                "new_columns": [
                    1711,
                    1996,
                    1487
                ],
                "unstacker.get_new_values": [
                    1488,
                    1712
                ],
                "is_empty": [
                    1522,
                    1516
                ],
                "orig_scalar": [
                    1544,
                    1517,
                    1518
                ],
                "qs": [
                    2473,
                    1517,
                    1520,
                    1526,
                    1527,
                    1533
                ],
                "np.asarray": [
                    1826,
                    2378,
                    1808,
                    2291,
                    2552,
                    1817,
                    1530,
                    3195,
                    2365
                ],
                "nanpercentile": [
                    1531
                ],
                "interpolation": [
                    2473,
                    1538
                ],
                "result.shape": [
                    1546
                ],
                "lib.item_from_zerodim": [
                    1548
                ],
                "np.ndim": [
                    1550
                ],
                "np.arange": [
                    1991,
                    1551
                ],
                "self._replace_single": [
                    2681,
                    1585,
                    2730
                ],
                "__init__": [
                    2178,
                    1733,
                    2600,
                    1622,
                    2903,
                    2493
                ],
                "col": [
                    1632,
                    1633,
                    1634,
                    1636,
                    1637,
                    1638,
                    1642,
                    2383,
                    2384
                ],
                "com.is_null_slice": [
                    2384,
                    1634,
                    1866
                ],
                "com": [
                    2384,
                    1634,
                    1866
                ],
                "self._holder": [
                    1765,
                    2153,
                    2476,
                    1647,
                    1876,
                    1974,
                    2326,
                    2327
                ],
                "locs.tolist": [
                    1650
                ],
                "_safe_reshape": [
                    1680
                ],
                "NonConsolidatableMixIn": [
                    1718
                ],
                "self._maybe_coerce_values": [
                    2177,
                    1732
                ],
                "extract_array": [
                    1946,
                    1940,
                    2901,
                    1750
                ],
                "self.values.dtype.na_value": [
                    1760
                ],
                "self._holder._can_hold_na": [
                    1765
                ],
                "self.values.dtype._is_numeric": [
                    1774
                ],
                "self.values.take": [
                    2001,
                    1844
                ],
                "self._holder._concat_same_type": [
                    1876
                ],
                "values.fillna": [
                    1882,
                    1895
                ],
                "diff": [
                    1903
                ],
                "self.values.shift": [
                    1919
                ],
                "ABCDataFrame": [
                    1942,
                    1934
                ],
                "other.iloc": [
                    1938
                ],
                "cond.iloc": [
                    1944
                ],
                "self.dtype.na_value": [
                    1952
                ],
                "is_sparse": [
                    3002,
                    1954
                ],
                "icond": [
                    1969,
                    1963,
                    1967
                ],
                "set_other": [
                    1969,
                    1965,
                    1967
                ],
                "self._holder._from_sequence": [
                    1974
                ],
                "np.where": [
                    1975
                ],
                "Block._ftype": [
                    1982
                ],
                "dummy_arr": [
                    1993,
                    1991
                ],
                "n_rows": [
                    1991
                ],
                "dummy_unstacker": [
                    1992,
                    1993
                ],
                "functools.partial": [
                    1992
                ],
                "functools": [
                    1992
                ],
                "self._get_unstack_items": [
                    1995
                ],
                "indices": [
                    2001,
                    2004
                ],
                "place": [
                    2002,
                    2004
                ],
                "ExtensionBlock": [
                    2297,
                    3015,
                    2892,
                    2009,
                    3004
                ],
                "NumericBlock": [
                    2027,
                    2117,
                    2558
                ],
                "left": [
                    2033,
                    2034
                ],
                "right": [
                    2033,
                    2034
                ],
                "FloatOrComplexBlock": [
                    2101,
                    2037
                ],
                "np.floating": [
                    2048,
                    2664,
                    3016,
                    2108,
                    2098,
                    2044
                ],
                "np.integer": [
                    2664,
                    3019,
                    2126,
                    2108,
                    3023,
                    2044
                ],
                "np.datetime64": [
                    2145,
                    2273,
                    2051,
                    2307,
                    2664,
                    2127,
                    2165,
                    2045,
                    3007
                ],
                "np.timedelta64": [
                    2051,
                    2502,
                    2505,
                    3018,
                    2127,
                    2485,
                    2167,
                    2524,
                    2045
                ],
                "np.int_": [
                    2048,
                    2110
                ],
                "np.bool_": [
                    2051,
                    2566,
                    2567,
                    2664,
                    2570,
                    3025,
                    2111
                ],
                "datetime": [
                    2240,
                    2051,
                    2628
                ],
                "timedelta": [
                    2505,
                    2051,
                    2630
                ],
                "float_format": [
                    2072,
                    2088
                ],
                "decimal": [
                    2072,
                    2089
                ],
                "formatter": [
                    2093,
                    2085
                ],
                "FloatArrayFormatter": [
                    2085
                ],
                "formatter.get_result_as_array": [
                    2093
                ],
                "value.dtype.type": [
                    2273,
                    2114,
                    2663,
                    2570,
                    2098,
                    2524
                ],
                "np.complexfloating": [
                    2664,
                    2114,
                    2108,
                    3021
                ],
                "np.float_": [
                    2110
                ],
                "self.dtype.itemsize": [
                    2128
                ],
                "tipo.itemsize": [
                    2128
                ],
                "DatetimeArray": [
                    2311,
                    3050,
                    2220,
                    2294,
                    2203,
                    2141
                ],
                "self.values.ravel": [
                    2152,
                    2644,
                    2607
                ],
                "astype": [
                    2153,
                    2225
                ],
                "result.reshape": [
                    2154
                ],
                "self.array_values": [
                    2159
                ],
                "iget": [
                    2164
                ],
                "key": [
                    2164
                ],
                "Timestamp": [
                    2166
                ],
                "Timedelta": [
                    2168,
                    2546
                ],
                "DatetimeLikeBlockMixin": [
                    2480,
                    2172
                ],
                "_NS_DTYPE": [
                    2200,
                    2378
                ],
                "conversion.ensure_datetime64ns": [
                    2201,
                    2286
                ],
                "conversion": [
                    2201,
                    2489,
                    2286
                ],
                "values._data": [
                    2491,
                    2204
                ],
                "tz_localize": [
                    2220
                ],
                "values.tz_convert": [
                    2221
                ],
                "dtype.tz": [
                    2221
                ],
                "self.is_datetimetz": [
                    2241,
                    2230
                ],
                "is_valid_nat_for_dtype": [
                    2232,
                    2507,
                    2245
                ],
                "NaT": [
                    2238,
                    2503
                ],
                "element.tzinfo": [
                    2242,
                    2243
                ],
                "self.dtype.tz": [
                    2242
                ],
                "i8values": [
                    2264,
                    2257,
                    2268,
                    2253
                ],
                "fmt": [
                    2266,
                    2261
                ],
                "_get_format_datetime64_from_values": [
                    2261
                ],
                "date_format": [
                    2261
                ],
                "tslib.format_array_from_datetime": [
                    2263
                ],
                "tslib": [
                    2263
                ],
                "i8values.ravel": [
                    2264
                ],
                "i8values.shape": [
                    2268
                ],
                "np.atleast_2d": [
                    3038,
                    2269,
                    2430
                ],
                "DatetimeArray._simple_new": [
                    3050,
                    2294
                ],
                "DatetimeBlock": [
                    2297,
                    2306,
                    3009,
                    2305
                ],
                "internal_values": [
                    2304
                ],
                "Block.internal_values": [
                    2304
                ],
                "_can_hold_element": [
                    2305
                ],
                "DatetimeBlock._can_hold_element": [
                    2305
                ],
                "to_native_types": [
                    2306
                ],
                "DatetimeBlock.to_native_types": [
                    2306
                ],
                "values.tz": [
                    2329
                ],
                "self.values._data.base": [
                    2338
                ],
                "self.values._data": [
                    2338
                ],
                "asi8": [
                    2413
                ],
                "self.shift": [
                    2413
                ],
                "new_values.reshape": [
                    2416
                ],
                "new_values.astype": [
                    2417
                ],
                "TimeDeltaBlock": [
                    2418,
                    3020
                ],
                "x.dtype": [
                    2425
                ],
                "concat_datetime": [
                    2426
                ],
                "x.values": [
                    2426
                ],
                "ObjectBlock": [
                    2456,
                    3028,
                    2431
                ],
                "concat_same_type": [
                    2432
                ],
                "fillna": [
                    2520,
                    2441,
                    2438
                ],
                "indexer.size": [
                    2450
                ],
                "setitem": [
                    2452
                ],
                "obj_vals": [
                    2456,
                    2454
                ],
                "newb.setitem": [
                    2458
                ],
                "other.values.view": [
                    2464
                ],
                "naive": [
                    2472,
                    2467,
                    2470
                ],
                "naive.reshape": [
                    2470
                ],
                "res_blk": [
                    2473,
                    2476,
                    2477
                ],
                "blk.quantile": [
                    2473
                ],
                "aware": [
                    2476,
                    2477
                ],
                "res_blk.values.ravel": [
                    2476
                ],
                "res_blk.values": [
                    2476
                ],
                "res_blk.ndim": [
                    2477
                ],
                "IntBlock": [
                    2480,
                    3024
                ],
                "_TD_DTYPE": [
                    2488
                ],
                "conversion.ensure_timedelta64ns": [
                    2489
                ],
                "TimedeltaArray": [
                    2497,
                    2490,
                    2555
                ],
                "rvalues": [
                    2545,
                    2538,
                    2549,
                    2535
                ],
                "np.empty": [
                    2535
                ],
                "imask": [
                    2545,
                    2546,
                    2539
                ],
                "ravel": [
                    2539
                ],
                "rvalues.flat": [
                    2545
                ],
                "_repr_base": [
                    2546
                ],
                "TimedeltaArray._simple_new": [
                    2555
                ],
                "to_replace_values": [
                    2578,
                    2579
                ],
                "np.atleast_1d": [
                    2578
                ],
                "np.can_cast": [
                    2579
                ],
                "replace": [
                    2977,
                    2690,
                    2581,
                    2806
                ],
                "values.dtype.type": [
                    2597
                ],
                "lib.is_bool_array": [
                    2607
                ],
                "val.shape": [
                    2625
                ],
                "soft_convert_objects": [
                    2626
                ],
                "val.ravel": [
                    2627
                ],
                "numeric": [
                    2629
                ],
                "to_rep_is_list": [
                    2672,
                    2674,
                    2675,
                    2714
                ],
                "value_is_list": [
                    2673,
                    2674,
                    2675
                ],
                "both_lists": [
                    2674,
                    2698
                ],
                "either_list": [
                    2680,
                    2689,
                    2675
                ],
                "is_re": [
                    2680,
                    2817,
                    2794,
                    2826
                ],
                "to_rep": [
                    2719,
                    2699,
                    2715,
                    2703
                ],
                "b._replace_single": [
                    2718,
                    2702
                ],
                "to_rep_re": [
                    2791,
                    2781,
                    2775
                ],
                "is_re_compilable": [
                    2778,
                    2775
                ],
                "regex_re": [
                    2778,
                    2788,
                    2781,
                    2791
                ],
                "pattern": [
                    2801,
                    2795,
                    2797
                ],
                "to_replace.pattern": [
                    2795
                ],
                "rx": [
                    2817,
                    2818,
                    2826,
                    2827,
                    2802
                ],
                "re.compile": [
                    2802
                ],
                "re": [
                    2802
                ],
                "rx.search": [
                    2818
                ],
                "rx.sub": [
                    2827
                ],
                "np.vectorize": [
                    2831
                ],
                "re_replacer": [
                    2831
                ],
                "filt": [
                    2841,
                    2834,
                    2836,
                    2839
                ],
                "nonzero": [
                    2836
                ],
                "block.convert": [
                    2846
                ],
                "_replace_coerce": [
                    2876
                ],
                "self.convert": [
                    2888
                ],
                "concat_categorical": [
                    2897
                ],
                "np.object_": [
                    2914
                ],
                "self.values._internal_get_values": [
                    2920
                ],
                "result.values.replace": [
                    2969
                ],
                "result.values": [
                    2976,
                    2969
                ],
                "result.convert": [
                    2971
                ],
                "result.values.add_categories": [
                    2976
                ],
                "CategoricalBlock": [
                    2977,
                    3006
                ],
                "vtype": [
                    3016,
                    3018,
                    3019,
                    3021,
                    3023,
                    3000,
                    3007
                ],
                "cls": [
                    3009,
                    3011,
                    3013,
                    3015,
                    3017,
                    3020,
                    3022,
                    3024,
                    3026,
                    3028,
                    3029,
                    3004,
                    3006
                ],
                "DatetimeTZBlock": [
                    3011,
                    3047
                ],
                "is_interval_dtype": [
                    3012
                ],
                "is_period_dtype": [
                    3012
                ],
                "ObjectValuesExtensionBlock": [
                    3013
                ],
                "FloatBlock": [
                    3017
                ],
                "ComplexBlock": [
                    3022
                ],
                "BoolBlock": [
                    3026
                ],
                "ABCPandasArray": [
                    3035
                ],
                "values.to_numpy": [
                    3036
                ],
                "PandasDtype": [
                    3040
                ],
                "dtype.numpy_dtype": [
                    3041
                ],
                "klass": [
                    3043,
                    3052,
                    3045,
                    3047
                ],
                "get_block_type": [
                    3045
                ],
                "blocks.extend": [
                    3066
                ],
                "blocks.append": [
                    3068,
                    3071
                ],
                "b.dtype": [
                    3096
                ],
                "b.mgr_locs.as_array": [
                    3101
                ],
                "b.mgr_locs": [
                    3101
                ],
                "np.vstack": [
                    3102
                ],
                "b.values": [
                    3102
                ],
                "argsort": [
                    3104,
                    3105,
                    3106
                ],
                "np.argsort": [
                    3104
                ],
                "arr": [
                    3129,
                    3130,
                    3131,
                    3132,
                    3133
                ],
                "ABCSeries": [
                    3129
                ],
                "arr._values": [
                    3130
                ],
                "ABCExtensionArray": [
                    3131
                ],
                "arr.reshape": [
                    3132
                ],
                "nn": [
                    3174,
                    3176,
                    3187,
                    3189,
                    3167
                ],
                "_isna_compat": [
                    3174
                ],
                "nn.dtype": [
                    3176
                ],
                "v.dtype": [
                    3187,
                    3179,
                    3211,
                    3205
                ],
                "warnings.catch_warnings": [
                    3185
                ],
                "warnings": [
                    3185,
                    3186
                ],
                "warnings.simplefilter": [
                    3186
                ],
                "np.ComplexWarning": [
                    3186
                ],
                "nn_at": [
                    3192,
                    3187,
                    3189
                ],
                "nn.astype": [
                    3187
                ],
                "comp": [
                    3189,
                    3190
                ],
                "comp.all": [
                    3190
                ],
                "v.dtype.kind": [
                    3205
                ],
                "n.dtype.kind": [
                    3205
                ],
                "_putmask_preserve": [
                    3216,
                    3206
                ],
                "v._internal_get_values": [
                    3212
                ],
                "v.astype": [
                    3214
                ]
            }
        },
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/io/stata.py": {
            "buggy_functions": [
                {
                    "function_name": "_do_convert_missing",
                    "function_code": "def _do_convert_missing(self, data: DataFrame, convert_missing: bool) -> DataFrame:\n    # Check for missing values, and replace if found\n    replacements = {}\n    for i, colname in enumerate(data):\n        fmt = self.typlist[i]\n        if fmt not in self.VALID_RANGE:\n            continue\n\n        nmin, nmax = self.VALID_RANGE[fmt]\n        series = data[colname]\n        missing = np.logical_or(series < nmin, series > nmax)\n\n        if not missing.any():\n            continue\n\n        if convert_missing:  # Replacement follows Stata notation\n            missing_loc = np.argwhere(missing._ndarray_values)\n            umissing, umissing_loc = np.unique(series[missing], return_inverse=True)\n            replacement = Series(series, dtype=np.object)\n            for j, um in enumerate(umissing):\n                missing_value = StataMissingValue(um)\n\n                loc = missing_loc[umissing_loc == j]\n                replacement.iloc[loc] = missing_value\n        else:  # All replacements are identical\n            dtype = series.dtype\n            if dtype not in (np.float32, np.float64):\n                dtype = np.float64\n            replacement = Series(series, dtype=dtype)\n            replacement[missing] = np.nan\n        replacements[colname] = replacement\n    if replacements:\n        columns = data.columns\n        replacement_df = DataFrame(replacements)\n        replaced = concat([data.drop(replacement_df.columns, 1), replacement_df], 1)\n        data = replaced[columns]\n    return data\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 1658,
                    "variables": {
                        "DataFrame": [
                            1658,
                            1691
                        ],
                        "bool": [
                            1658
                        ],
                        "replacements": [
                            1688,
                            1689,
                            1691,
                            1660
                        ],
                        "i": [
                            1661,
                            1662
                        ],
                        "colname": [
                            1688,
                            1667,
                            1661
                        ],
                        "enumerate": [
                            1661,
                            1677
                        ],
                        "data": [
                            1667,
                            1693,
                            1690,
                            1692,
                            1661,
                            1694
                        ],
                        "fmt": [
                            1666,
                            1662,
                            1663
                        ],
                        "self.typlist": [
                            1662
                        ],
                        "self": [
                            1666,
                            1662,
                            1663
                        ],
                        "self.VALID_RANGE": [
                            1666,
                            1663
                        ],
                        "nmin": [
                            1666,
                            1668
                        ],
                        "nmax": [
                            1666,
                            1668
                        ],
                        "series": [
                            1667,
                            1668,
                            1675,
                            1676,
                            1683,
                            1686
                        ],
                        "missing": [
                            1668,
                            1670,
                            1674,
                            1675,
                            1687
                        ],
                        "np.logical_or": [
                            1668
                        ],
                        "np": [
                            1668,
                            1674,
                            1675,
                            1676,
                            1684,
                            1685,
                            1687
                        ],
                        "missing.any": [
                            1670
                        ],
                        "convert_missing": [
                            1673
                        ],
                        "missing_loc": [
                            1680,
                            1674
                        ],
                        "np.argwhere": [
                            1674
                        ],
                        "missing._ndarray_values": [
                            1674
                        ],
                        "umissing": [
                            1675,
                            1677
                        ],
                        "umissing_loc": [
                            1680,
                            1675
                        ],
                        "np.unique": [
                            1675
                        ],
                        "replacement": [
                            1676,
                            1681,
                            1686,
                            1687,
                            1688
                        ],
                        "Series": [
                            1676,
                            1686
                        ],
                        "np.object": [
                            1676
                        ],
                        "j": [
                            1680,
                            1677
                        ],
                        "um": [
                            1677,
                            1678
                        ],
                        "missing_value": [
                            1681,
                            1678
                        ],
                        "StataMissingValue": [
                            1678
                        ],
                        "loc": [
                            1680,
                            1681
                        ],
                        "replacement.iloc": [
                            1681
                        ],
                        "dtype": [
                            1683,
                            1684,
                            1685,
                            1686
                        ],
                        "series.dtype": [
                            1683
                        ],
                        "np.float32": [
                            1684
                        ],
                        "np.float64": [
                            1684,
                            1685
                        ],
                        "np.nan": [
                            1687
                        ],
                        "columns": [
                            1690,
                            1693
                        ],
                        "data.columns": [
                            1690
                        ],
                        "replacement_df": [
                            1691,
                            1692
                        ],
                        "replaced": [
                            1692,
                            1693
                        ],
                        "concat": [
                            1692
                        ],
                        "data.drop": [
                            1692
                        ],
                        "replacement_df.columns": [
                            1692
                        ]
                    },
                    "filtered_variables": {
                        "DataFrame": [
                            1658,
                            1691
                        ],
                        "replacements": [
                            1688,
                            1689,
                            1691,
                            1660
                        ],
                        "i": [
                            1661,
                            1662
                        ],
                        "colname": [
                            1688,
                            1667,
                            1661
                        ],
                        "data": [
                            1667,
                            1693,
                            1690,
                            1692,
                            1661,
                            1694
                        ],
                        "fmt": [
                            1666,
                            1662,
                            1663
                        ],
                        "self.typlist": [
                            1662
                        ],
                        "self": [
                            1666,
                            1662,
                            1663
                        ],
                        "self.VALID_RANGE": [
                            1666,
                            1663
                        ],
                        "nmin": [
                            1666,
                            1668
                        ],
                        "nmax": [
                            1666,
                            1668
                        ],
                        "series": [
                            1667,
                            1668,
                            1675,
                            1676,
                            1683,
                            1686
                        ],
                        "missing": [
                            1668,
                            1670,
                            1674,
                            1675,
                            1687
                        ],
                        "np.logical_or": [
                            1668
                        ],
                        "np": [
                            1668,
                            1674,
                            1675,
                            1676,
                            1684,
                            1685,
                            1687
                        ],
                        "missing.any": [
                            1670
                        ],
                        "convert_missing": [
                            1673
                        ],
                        "missing_loc": [
                            1680,
                            1674
                        ],
                        "np.argwhere": [
                            1674
                        ],
                        "missing._ndarray_values": [
                            1674
                        ],
                        "umissing": [
                            1675,
                            1677
                        ],
                        "umissing_loc": [
                            1680,
                            1675
                        ],
                        "np.unique": [
                            1675
                        ],
                        "replacement": [
                            1676,
                            1681,
                            1686,
                            1687,
                            1688
                        ],
                        "Series": [
                            1676,
                            1686
                        ],
                        "np.object": [
                            1676
                        ],
                        "j": [
                            1680,
                            1677
                        ],
                        "um": [
                            1677,
                            1678
                        ],
                        "missing_value": [
                            1681,
                            1678
                        ],
                        "StataMissingValue": [
                            1678
                        ],
                        "loc": [
                            1680,
                            1681
                        ],
                        "replacement.iloc": [
                            1681
                        ],
                        "dtype": [
                            1683,
                            1684,
                            1685,
                            1686
                        ],
                        "series.dtype": [
                            1683
                        ],
                        "np.float32": [
                            1684
                        ],
                        "np.float64": [
                            1684,
                            1685
                        ],
                        "np.nan": [
                            1687
                        ],
                        "columns": [
                            1690,
                            1693
                        ],
                        "data.columns": [
                            1690
                        ],
                        "replacement_df": [
                            1691,
                            1692
                        ],
                        "replaced": [
                            1692,
                            1693
                        ],
                        "concat": [
                            1692
                        ],
                        "data.drop": [
                            1692
                        ],
                        "replacement_df.columns": [
                            1692
                        ]
                    },
                    "diff_line_number": 1680,
                    "class_data": {
                        "signature": "class StataReader(StataParser, abc.Iterator)",
                        "docstring": null,
                        "constructor_docstring": null,
                        "functions": [
                            "def __init__(self, path_or_buf: FilePathOrBuffer, convert_dates: bool=True, convert_categoricals: bool=True, index_col: Optional[str]=None, convert_missing: bool=False, preserve_dtypes: bool=True, columns: Optional[Sequence[str]]=None, order_categoricals: bool=True, chunksize: Optional[int]=None):\n    super().__init__()\n    self.col_sizes: List[int] = []\n    self._convert_dates = convert_dates\n    self._convert_categoricals = convert_categoricals\n    self._index_col = index_col\n    self._convert_missing = convert_missing\n    self._preserve_dtypes = preserve_dtypes\n    self._columns = columns\n    self._order_categoricals = order_categoricals\n    self._encoding = ''\n    self._chunksize = chunksize\n    self._has_string_data = False\n    self._missing_values = False\n    self._can_read_value_labels = False\n    self._column_selector_set = False\n    self._value_labels_read = False\n    self._data_read = False\n    self._dtype = None\n    self._lines_read = 0\n    self._native_byteorder = _set_endianness(sys.byteorder)\n    path_or_buf = stringify_path(path_or_buf)\n    if isinstance(path_or_buf, str):\n        path_or_buf, encoding, _, should_close = get_filepath_or_buffer(path_or_buf)\n    if isinstance(path_or_buf, (str, bytes)):\n        self.path_or_buf = open(path_or_buf, 'rb')\n    elif isinstance(path_or_buf, IOBase):\n        contents = path_or_buf.read()\n        self.path_or_buf = BytesIO(contents)\n    self._read_header()\n    self._setup_dtype()",
                            "def __enter__(self) -> 'StataReader':\n    \"\"\" enter context manager \"\"\"\n    return self",
                            "def __exit__(self, exc_type, exc_value, traceback) -> None:\n    \"\"\" exit context manager \"\"\"\n    self.close()",
                            "def close(self) -> None:\n    \"\"\" close the handle if its open \"\"\"\n    try:\n        self.path_or_buf.close()\n    except IOError:\n        pass",
                            "def _set_encoding(self) -> None:\n    \"\"\"\n    Set string encoding which depends on file version\n    \"\"\"\n    if self.format_version < 118:\n        self._encoding = 'latin-1'\n    else:\n        self._encoding = 'utf-8'",
                            "def _read_header(self) -> None:\n    first_char = self.path_or_buf.read(1)\n    if struct.unpack('c', first_char)[0] == b'<':\n        self._read_new_header()\n    else:\n        self._read_old_header(first_char)\n    self.has_string_data = len([x for x in self.typlist if type(x) is int]) > 0\n    self.col_sizes = [self._calcsize(typ) for typ in self.typlist]",
                            "def _read_new_header(self) -> None:\n    self.path_or_buf.read(27)\n    self.format_version = int(self.path_or_buf.read(3))\n    if self.format_version not in [117, 118, 119]:\n        raise ValueError(_version_error.format(version=self.format_version))\n    self._set_encoding()\n    self.path_or_buf.read(21)\n    self.byteorder = self.path_or_buf.read(3) == b'MSF' and '>' or '<'\n    self.path_or_buf.read(15)\n    nvar_type = 'H' if self.format_version <= 118 else 'I'\n    nvar_size = 2 if self.format_version <= 118 else 4\n    self.nvar = struct.unpack(self.byteorder + nvar_type, self.path_or_buf.read(nvar_size))[0]\n    self.path_or_buf.read(7)\n    self.nobs = self._get_nobs()\n    self.path_or_buf.read(11)\n    self._data_label = self._get_data_label()\n    self.path_or_buf.read(19)\n    self.time_stamp = self._get_time_stamp()\n    self.path_or_buf.read(26)\n    self.path_or_buf.read(8)\n    self.path_or_buf.read(8)\n    self._seek_vartypes = struct.unpack(self.byteorder + 'q', self.path_or_buf.read(8))[0] + 16\n    self._seek_varnames = struct.unpack(self.byteorder + 'q', self.path_or_buf.read(8))[0] + 10\n    self._seek_sortlist = struct.unpack(self.byteorder + 'q', self.path_or_buf.read(8))[0] + 10\n    self._seek_formats = struct.unpack(self.byteorder + 'q', self.path_or_buf.read(8))[0] + 9\n    self._seek_value_label_names = struct.unpack(self.byteorder + 'q', self.path_or_buf.read(8))[0] + 19\n    self._seek_variable_labels = self._get_seek_variable_labels()\n    self.path_or_buf.read(8)\n    self.data_location = struct.unpack(self.byteorder + 'q', self.path_or_buf.read(8))[0] + 6\n    self.seek_strls = struct.unpack(self.byteorder + 'q', self.path_or_buf.read(8))[0] + 7\n    self.seek_value_labels = struct.unpack(self.byteorder + 'q', self.path_or_buf.read(8))[0] + 14\n    self.typlist, self.dtyplist = self._get_dtypes(self._seek_vartypes)\n    self.path_or_buf.seek(self._seek_varnames)\n    self.varlist = self._get_varlist()\n    self.path_or_buf.seek(self._seek_sortlist)\n    self.srtlist = struct.unpack(self.byteorder + 'h' * (self.nvar + 1), self.path_or_buf.read(2 * (self.nvar + 1)))[:-1]\n    self.path_or_buf.seek(self._seek_formats)\n    self.fmtlist = self._get_fmtlist()\n    self.path_or_buf.seek(self._seek_value_label_names)\n    self.lbllist = self._get_lbllist()\n    self.path_or_buf.seek(self._seek_variable_labels)\n    self._variable_labels = self._get_variable_labels()",
                            "def _get_dtypes(self, seek_vartypes: int) -> Tuple[List[Union[int, str]], List[Union[int, np.dtype]]]:\n    self.path_or_buf.seek(seek_vartypes)\n    raw_typlist = [struct.unpack(self.byteorder + 'H', self.path_or_buf.read(2))[0] for _ in range(self.nvar)]\n\n    def f(typ: int) -> Union[int, str]:\n        if typ <= 2045:\n            return typ\n        try:\n            return self.TYPE_MAP_XML[typ]\n        except KeyError:\n            raise ValueError(f'cannot convert stata types [{typ}]')\n    typlist = [f(x) for x in raw_typlist]\n\n    def g(typ: int) -> Union[str, np.dtype]:\n        if typ <= 2045:\n            return str(typ)\n        try:\n            return self.DTYPE_MAP_XML[typ]\n        except KeyError:\n            raise ValueError(f'cannot convert stata dtype [{typ}]')\n    dtyplist = [g(x) for x in raw_typlist]\n    return (typlist, dtyplist)",
                            "def _get_varlist(self) -> List[str]:\n    b = 33 if self.format_version < 118 else 129\n    return [self._decode(self.path_or_buf.read(b)) for _ in range(self.nvar)]",
                            "def _get_fmtlist(self) -> List[str]:\n    if self.format_version >= 118:\n        b = 57\n    elif self.format_version > 113:\n        b = 49\n    elif self.format_version > 104:\n        b = 12\n    else:\n        b = 7\n    return [self._decode(self.path_or_buf.read(b)) for _ in range(self.nvar)]",
                            "def _get_lbllist(self) -> List[str]:\n    if self.format_version >= 118:\n        b = 129\n    elif self.format_version > 108:\n        b = 33\n    else:\n        b = 9\n    return [self._decode(self.path_or_buf.read(b)) for _ in range(self.nvar)]",
                            "def _get_variable_labels(self) -> List[str]:\n    if self.format_version >= 118:\n        vlblist = [self._decode(self.path_or_buf.read(321)) for _ in range(self.nvar)]\n    elif self.format_version > 105:\n        vlblist = [self._decode(self.path_or_buf.read(81)) for _ in range(self.nvar)]\n    else:\n        vlblist = [self._decode(self.path_or_buf.read(32)) for _ in range(self.nvar)]\n    return vlblist",
                            "def _get_nobs(self) -> int:\n    if self.format_version >= 118:\n        return struct.unpack(self.byteorder + 'Q', self.path_or_buf.read(8))[0]\n    else:\n        return struct.unpack(self.byteorder + 'I', self.path_or_buf.read(4))[0]",
                            "def _get_data_label(self) -> str:\n    if self.format_version >= 118:\n        strlen = struct.unpack(self.byteorder + 'H', self.path_or_buf.read(2))[0]\n        return self._decode(self.path_or_buf.read(strlen))\n    elif self.format_version == 117:\n        strlen = struct.unpack('b', self.path_or_buf.read(1))[0]\n        return self._decode(self.path_or_buf.read(strlen))\n    elif self.format_version > 105:\n        return self._decode(self.path_or_buf.read(81))\n    else:\n        return self._decode(self.path_or_buf.read(32))",
                            "def _get_time_stamp(self) -> str:\n    if self.format_version >= 118:\n        strlen = struct.unpack('b', self.path_or_buf.read(1))[0]\n        return self.path_or_buf.read(strlen).decode('utf-8')\n    elif self.format_version == 117:\n        strlen = struct.unpack('b', self.path_or_buf.read(1))[0]\n        return self._decode(self.path_or_buf.read(strlen))\n    elif self.format_version > 104:\n        return self._decode(self.path_or_buf.read(18))\n    else:\n        raise ValueError()",
                            "def _get_seek_variable_labels(self) -> int:\n    if self.format_version == 117:\n        self.path_or_buf.read(8)\n        return self._seek_value_label_names + 33 * self.nvar + 20 + 17\n    elif self.format_version >= 118:\n        return struct.unpack(self.byteorder + 'q', self.path_or_buf.read(8))[0] + 17\n    else:\n        raise ValueError()",
                            "def _read_old_header(self, first_char: bytes) -> None:\n    self.format_version = struct.unpack('b', first_char)[0]\n    if self.format_version not in [104, 105, 108, 111, 113, 114, 115]:\n        raise ValueError(_version_error.format(version=self.format_version))\n    self._set_encoding()\n    self.byteorder = struct.unpack('b', self.path_or_buf.read(1))[0] == 1 and '>' or '<'\n    self.filetype = struct.unpack('b', self.path_or_buf.read(1))[0]\n    self.path_or_buf.read(1)\n    self.nvar = struct.unpack(self.byteorder + 'H', self.path_or_buf.read(2))[0]\n    self.nobs = self._get_nobs()\n    self._data_label = self._get_data_label()\n    self.time_stamp = self._get_time_stamp()\n    if self.format_version > 108:\n        typlist = [ord(self.path_or_buf.read(1)) for _ in range(self.nvar)]\n    else:\n        buf = self.path_or_buf.read(self.nvar)\n        typlistb = np.frombuffer(buf, dtype=np.uint8)\n        typlist = []\n        for tp in typlistb:\n            if tp in self.OLD_TYPE_MAPPING:\n                typlist.append(self.OLD_TYPE_MAPPING[tp])\n            else:\n                typlist.append(tp - 127)\n    try:\n        self.typlist = [self.TYPE_MAP[typ] for typ in typlist]\n    except ValueError:\n        invalid_types = ','.join((str(x) for x in typlist))\n        raise ValueError(f'cannot convert stata types [{invalid_types}]')\n    try:\n        self.dtyplist = [self.DTYPE_MAP[typ] for typ in typlist]\n    except ValueError:\n        invalid_dtypes = ','.join((str(x) for x in typlist))\n        raise ValueError(f'cannot convert stata dtypes [{invalid_dtypes}]')\n    if self.format_version > 108:\n        self.varlist = [self._decode(self.path_or_buf.read(33)) for _ in range(self.nvar)]\n    else:\n        self.varlist = [self._decode(self.path_or_buf.read(9)) for _ in range(self.nvar)]\n    self.srtlist = struct.unpack(self.byteorder + 'h' * (self.nvar + 1), self.path_or_buf.read(2 * (self.nvar + 1)))[:-1]\n    self.fmtlist = self._get_fmtlist()\n    self.lbllist = self._get_lbllist()\n    self._variable_labels = self._get_variable_labels()\n    if self.format_version > 104:\n        while True:\n            data_type = struct.unpack(self.byteorder + 'b', self.path_or_buf.read(1))[0]\n            if self.format_version > 108:\n                data_len = struct.unpack(self.byteorder + 'i', self.path_or_buf.read(4))[0]\n            else:\n                data_len = struct.unpack(self.byteorder + 'h', self.path_or_buf.read(2))[0]\n            if data_type == 0:\n                break\n            self.path_or_buf.read(data_len)\n    self.data_location = self.path_or_buf.tell()",
                            "def _setup_dtype(self) -> np.dtype:\n    \"\"\"Map between numpy and state dtypes\"\"\"\n    if self._dtype is not None:\n        return self._dtype\n    dtypes = []\n    for i, typ in enumerate(self.typlist):\n        if typ in self.NUMPY_TYPE_MAP:\n            dtypes.append(('s' + str(i), self.byteorder + self.NUMPY_TYPE_MAP[typ]))\n        else:\n            dtypes.append(('s' + str(i), 'S' + str(typ)))\n    self._dtype = np.dtype(dtypes)\n    return self._dtype",
                            "def _calcsize(self, fmt: Union[int, str]) -> int:\n    if isinstance(fmt, int):\n        return fmt\n    return struct.calcsize(self.byteorder + fmt)",
                            "def _decode(self, s: bytes) -> str:\n    s = s.partition(b'\\x00')[0]\n    try:\n        return s.decode(self._encoding)\n    except UnicodeDecodeError:\n        encoding = self._encoding\n        msg = f'\\nOne or more strings in the dta file could not be decoded using {encoding}, and\\nso the fallback encoding of latin-1 is being used.  This can happen when a file\\nhas been incorrectly encoded by Stata or some other software. You should verify\\nthe string values returned are correct.'\n        warnings.warn(msg, UnicodeWarning)\n        return s.decode('latin-1')",
                            "def _read_value_labels(self) -> None:\n    if self._value_labels_read:\n        return\n    if self.format_version <= 108:\n        self._value_labels_read = True\n        self.value_label_dict: Dict[str, Dict[Union[float, int], str]] = {}\n        return\n    if self.format_version >= 117:\n        self.path_or_buf.seek(self.seek_value_labels)\n    else:\n        assert self._dtype is not None\n        offset = self.nobs * self._dtype.itemsize\n        self.path_or_buf.seek(self.data_location + offset)\n    self._value_labels_read = True\n    self.value_label_dict = {}\n    while True:\n        if self.format_version >= 117:\n            if self.path_or_buf.read(5) == b'</val':\n                break\n        slength = self.path_or_buf.read(4)\n        if not slength:\n            break\n        if self.format_version <= 117:\n            labname = self._decode(self.path_or_buf.read(33))\n        else:\n            labname = self._decode(self.path_or_buf.read(129))\n        self.path_or_buf.read(3)\n        n = struct.unpack(self.byteorder + 'I', self.path_or_buf.read(4))[0]\n        txtlen = struct.unpack(self.byteorder + 'I', self.path_or_buf.read(4))[0]\n        off = np.frombuffer(self.path_or_buf.read(4 * n), dtype=self.byteorder + 'i4', count=n)\n        val = np.frombuffer(self.path_or_buf.read(4 * n), dtype=self.byteorder + 'i4', count=n)\n        ii = np.argsort(off)\n        off = off[ii]\n        val = val[ii]\n        txt = self.path_or_buf.read(txtlen)\n        self.value_label_dict[labname] = dict()\n        for i in range(n):\n            end = off[i + 1] if i < n - 1 else txtlen\n            self.value_label_dict[labname][val[i]] = self._decode(txt[off[i]:end])\n        if self.format_version >= 117:\n            self.path_or_buf.read(6)\n    self._value_labels_read = True",
                            "def _read_strls(self) -> None:\n    self.path_or_buf.seek(self.seek_strls)\n    self.GSO = {'0': ''}\n    while True:\n        if self.path_or_buf.read(3) != b'GSO':\n            break\n        if self.format_version == 117:\n            v_o = struct.unpack(self.byteorder + 'Q', self.path_or_buf.read(8))[0]\n        else:\n            buf = self.path_or_buf.read(12)\n            v_size = 2 if self.format_version == 118 else 3\n            if self.byteorder == '<':\n                buf = buf[0:v_size] + buf[4:12 - v_size]\n            else:\n                buf = buf[0:v_size] + buf[4 + v_size:]\n            v_o = struct.unpack('Q', buf)[0]\n        typ = struct.unpack('B', self.path_or_buf.read(1))[0]\n        length = struct.unpack(self.byteorder + 'I', self.path_or_buf.read(4))[0]\n        va = self.path_or_buf.read(length)\n        if typ == 130:\n            decoded_va = va[0:-1].decode(self._encoding)\n        else:\n            decoded_va = str(va)\n        self.GSO[str(v_o)] = decoded_va",
                            "def __next__(self) -> DataFrame:\n    return self.read(nrows=self._chunksize or 1)",
                            "def get_chunk(self, size: Optional[int]=None) -> DataFrame:\n    \"\"\"\n    Reads lines from Stata file and returns as dataframe\n\n    Parameters\n    ----------\n    size : int, defaults to None\n        Number of lines to read.  If None, reads whole file.\n\n    Returns\n    -------\n    DataFrame\n    \"\"\"\n    if size is None:\n        size = self._chunksize\n    return self.read(nrows=size)",
                            "@Appender(_read_method_doc)\ndef read(self, nrows: Optional[int]=None, convert_dates: Optional[bool]=None, convert_categoricals: Optional[bool]=None, index_col: Optional[str]=None, convert_missing: Optional[bool]=None, preserve_dtypes: Optional[bool]=None, columns: Optional[Sequence[str]]=None, order_categoricals: Optional[bool]=None) -> DataFrame:\n    if self.nobs == 0 and nrows is None:\n        self._can_read_value_labels = True\n        self._data_read = True\n        self.close()\n        return DataFrame(columns=self.varlist)\n    if convert_dates is None:\n        convert_dates = self._convert_dates\n    if convert_categoricals is None:\n        convert_categoricals = self._convert_categoricals\n    if convert_missing is None:\n        convert_missing = self._convert_missing\n    if preserve_dtypes is None:\n        preserve_dtypes = self._preserve_dtypes\n    if columns is None:\n        columns = self._columns\n    if order_categoricals is None:\n        order_categoricals = self._order_categoricals\n    if index_col is None:\n        index_col = self._index_col\n    if nrows is None:\n        nrows = self.nobs\n    if self.format_version >= 117 and (not self._value_labels_read):\n        self._can_read_value_labels = True\n        self._read_strls()\n    assert self._dtype is not None\n    dtype = self._dtype\n    max_read_len = (self.nobs - self._lines_read) * dtype.itemsize\n    read_len = nrows * dtype.itemsize\n    read_len = min(read_len, max_read_len)\n    if read_len <= 0:\n        if convert_categoricals:\n            self._read_value_labels()\n        self.close()\n        raise StopIteration\n    offset = self._lines_read * dtype.itemsize\n    self.path_or_buf.seek(self.data_location + offset)\n    read_lines = min(nrows, self.nobs - self._lines_read)\n    data = np.frombuffer(self.path_or_buf.read(read_len), dtype=dtype, count=read_lines)\n    self._lines_read += read_lines\n    if self._lines_read == self.nobs:\n        self._can_read_value_labels = True\n        self._data_read = True\n    if self.byteorder != self._native_byteorder:\n        data = data.byteswap().newbyteorder()\n    if convert_categoricals:\n        self._read_value_labels()\n    if len(data) == 0:\n        data = DataFrame(columns=self.varlist)\n    else:\n        data = DataFrame.from_records(data)\n        data.columns = self.varlist\n    if index_col is None:\n        ix = np.arange(self._lines_read - read_lines, self._lines_read)\n        data = data.set_index(ix)\n    if columns is not None:\n        try:\n            data = self._do_select_columns(data, columns)\n        except ValueError:\n            self.close()\n            raise\n    for col, typ in zip(data, self.typlist):\n        if type(typ) is int:\n            data[col] = data[col].apply(self._decode, convert_dtype=True)\n    data = self._insert_strls(data)\n    cols_ = np.where(self.dtyplist)[0]\n    ix = data.index\n    requires_type_conversion = False\n    data_formatted = []\n    for i in cols_:\n        if self.dtyplist[i] is not None:\n            col = data.columns[i]\n            dtype = data[col].dtype\n            if dtype != np.dtype(object) and dtype != self.dtyplist[i]:\n                requires_type_conversion = True\n                data_formatted.append((col, Series(data[col], ix, self.dtyplist[i])))\n            else:\n                data_formatted.append((col, data[col]))\n    if requires_type_conversion:\n        data = DataFrame.from_dict(dict(data_formatted))\n    del data_formatted\n    data = self._do_convert_missing(data, convert_missing)\n    if convert_dates:\n\n        def any_startswith(x: str) -> bool:\n            return any((x.startswith(fmt) for fmt in _date_formats))\n        cols = np.where([any_startswith(x) for x in self.fmtlist])[0]\n        for i in cols:\n            col = data.columns[i]\n            try:\n                data[col] = _stata_elapsed_date_to_datetime_vec(data[col], self.fmtlist[i])\n            except ValueError:\n                self.close()\n                raise\n    if convert_categoricals and self.format_version > 108:\n        data = self._do_convert_categoricals(data, self.value_label_dict, self.lbllist, order_categoricals)\n    if not preserve_dtypes:\n        retyped_data = []\n        convert = False\n        for col in data:\n            dtype = data[col].dtype\n            if dtype in (np.float16, np.float32):\n                dtype = np.float64\n                convert = True\n            elif dtype in (np.int8, np.int16, np.int32):\n                dtype = np.int64\n                convert = True\n            retyped_data.append((col, data[col].astype(dtype)))\n        if convert:\n            data = DataFrame.from_dict(dict(retyped_data))\n    if index_col is not None:\n        data = data.set_index(data.pop(index_col))\n    return data",
                            "def _do_convert_missing(self, data: DataFrame, convert_missing: bool) -> DataFrame:\n    replacements = {}\n    for i, colname in enumerate(data):\n        fmt = self.typlist[i]\n        if fmt not in self.VALID_RANGE:\n            continue\n        nmin, nmax = self.VALID_RANGE[fmt]\n        series = data[colname]\n        missing = np.logical_or(series < nmin, series > nmax)\n        if not missing.any():\n            continue\n        if convert_missing:\n            missing_loc = np.argwhere(missing._ndarray_values)\n            umissing, umissing_loc = np.unique(series[missing], return_inverse=True)\n            replacement = Series(series, dtype=np.object)\n            for j, um in enumerate(umissing):\n                missing_value = StataMissingValue(um)\n                loc = missing_loc[umissing_loc == j]\n                replacement.iloc[loc] = missing_value\n        else:\n            dtype = series.dtype\n            if dtype not in (np.float32, np.float64):\n                dtype = np.float64\n            replacement = Series(series, dtype=dtype)\n            replacement[missing] = np.nan\n        replacements[colname] = replacement\n    if replacements:\n        columns = data.columns\n        replacement_df = DataFrame(replacements)\n        replaced = concat([data.drop(replacement_df.columns, 1), replacement_df], 1)\n        data = replaced[columns]\n    return data",
                            "def _insert_strls(self, data: DataFrame) -> DataFrame:\n    if not hasattr(self, 'GSO') or len(self.GSO) == 0:\n        return data\n    for i, typ in enumerate(self.typlist):\n        if typ != 'Q':\n            continue\n        data.iloc[:, i] = [self.GSO[str(k)] for k in data.iloc[:, i]]\n    return data",
                            "def _do_select_columns(self, data: DataFrame, columns: Sequence[str]) -> DataFrame:\n    if not self._column_selector_set:\n        column_set = set(columns)\n        if len(column_set) != len(columns):\n            raise ValueError('columns contains duplicate entries')\n        unmatched = column_set.difference(data.columns)\n        if unmatched:\n            joined = ', '.join(list(unmatched))\n            raise ValueError(f'The following columns were not found in the Stata data set: {joined}')\n        dtyplist = []\n        typlist = []\n        fmtlist = []\n        lbllist = []\n        for col in columns:\n            i = data.columns.get_loc(col)\n            dtyplist.append(self.dtyplist[i])\n            typlist.append(self.typlist[i])\n            fmtlist.append(self.fmtlist[i])\n            lbllist.append(self.lbllist[i])\n        self.dtyplist = dtyplist\n        self.typlist = typlist\n        self.fmtlist = fmtlist\n        self.lbllist = lbllist\n        self._column_selector_set = True\n    return data[columns]",
                            "@staticmethod\ndef _do_convert_categoricals(data: DataFrame, value_label_dict: Dict[str, Dict[Union[float, int], str]], lbllist: Sequence[str], order_categoricals: bool) -> DataFrame:\n    \"\"\"\n    Converts categorical columns to Categorical type.\n    \"\"\"\n    value_labels = list(value_label_dict.keys())\n    cat_converted_data = []\n    for col, label in zip(data, lbllist):\n        if label in value_labels:\n            cat_data = Categorical(data[col], ordered=order_categoricals)\n            categories = []\n            for category in cat_data.categories:\n                if category in value_label_dict[label]:\n                    categories.append(value_label_dict[label][category])\n                else:\n                    categories.append(category)\n            try:\n                cat_data.categories = categories\n            except ValueError:\n                vc = Series(categories).value_counts()\n                repeated_cats = list(vc.index[vc > 1])\n                repeats = '-' * 80 + '\\n' + '\\n'.join(repeated_cats)\n                msg = f'\\nValue labels for column {col} are not unique. These cannot be converted to\\npandas categoricals.\\n\\nEither read the file with `convert_categoricals` set to False or use the\\nlow level interface in `StataReader` to separately read the values and the\\nvalue_labels.\\n\\nThe repeated labels are:\\n{repeats}\\n'\n                raise ValueError(msg)\n            cat_series = Series(cat_data, index=data.index)\n            cat_converted_data.append((col, cat_series))\n        else:\n            cat_converted_data.append((col, data[col]))\n    data = DataFrame.from_dict(dict(cat_converted_data))\n    return data",
                            "@property\ndef data_label(self) -> str:\n    \"\"\"\n    Return data label of Stata file.\n    \"\"\"\n    return self._data_label",
                            "def variable_labels(self) -> Dict[str, str]:\n    \"\"\"\n    Return variable labels as a dict, associating each variable name\n    with corresponding label.\n\n    Returns\n    -------\n    dict\n    \"\"\"\n    return dict(zip(self.varlist, self._variable_labels))",
                            "def value_labels(self) -> Dict[str, Dict[Union[float, int], str]]:\n    \"\"\"\n    Return a dict, associating each variable name a dict, associating\n    each value its corresponding label.\n\n    Returns\n    -------\n    dict\n    \"\"\"\n    if not self._value_labels_read:\n        self._read_value_labels()\n    return self.value_label_dict",
                            "def f(typ: int) -> Union[int, str]:\n    if typ <= 2045:\n        return typ\n    try:\n        return self.TYPE_MAP_XML[typ]\n    except KeyError:\n        raise ValueError(f'cannot convert stata types [{typ}]')",
                            "def g(typ: int) -> Union[str, np.dtype]:\n    if typ <= 2045:\n        return str(typ)\n    try:\n        return self.DTYPE_MAP_XML[typ]\n    except KeyError:\n        raise ValueError(f'cannot convert stata dtype [{typ}]')",
                            "def any_startswith(x: str) -> bool:\n    return any((x.startswith(fmt) for fmt in _date_formats))"
                        ],
                        "constructor_variables": [
                            "_convert_dates",
                            "_order_categoricals",
                            "_data_read",
                            "_can_read_value_labels",
                            "_value_labels_read",
                            "_preserve_dtypes",
                            "_chunksize",
                            "_columns",
                            "path_or_buf",
                            "_convert_missing",
                            "contents",
                            "_lines_read",
                            "_encoding",
                            "_dtype",
                            "_column_selector_set",
                            "_convert_categoricals",
                            "_index_col",
                            "_has_string_data",
                            "_native_byteorder",
                            "_missing_values"
                        ],
                        "class_level_variables": [
                            "__doc__"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "__init__(self, path_or_buf: FilePathOrBuffer, convert_dates: bool=True, convert_categoricals: bool=True, index_col: Optional[str]=None, convert_missing: bool=False, preserve_dtypes: bool=True, columns: Optional[Sequence[str]]=None, order_categoricals: bool=True, chunksize: Optional[int]=None)",
                            "__enter__(self) -> 'StataReader'",
                            "__exit__(self, exc_type, exc_value, traceback) -> None",
                            "close(self) -> None",
                            "_set_encoding(self) -> None",
                            "_read_header(self) -> None",
                            "_read_new_header(self) -> None",
                            "_get_dtypes(self, seek_vartypes: int) -> Tuple[List[Union[int, str]], List[Union[int, np.dtype]]]",
                            "_get_varlist(self) -> List[str]",
                            "_get_fmtlist(self) -> List[str]",
                            "_get_lbllist(self) -> List[str]",
                            "_get_variable_labels(self) -> List[str]",
                            "_get_nobs(self) -> int",
                            "_get_data_label(self) -> str",
                            "_get_time_stamp(self) -> str",
                            "_get_seek_variable_labels(self) -> int",
                            "_read_old_header(self, first_char: bytes) -> None",
                            "_setup_dtype(self) -> np.dtype",
                            "_calcsize(self, fmt: Union[int, str]) -> int",
                            "_decode(self, s: bytes) -> str",
                            "_read_value_labels(self) -> None",
                            "_read_strls(self) -> None",
                            "__next__(self) -> DataFrame",
                            "get_chunk(self, size: Optional[int]=None) -> DataFrame",
                            "read(self, nrows: Optional[int]=None, convert_dates: Optional[bool]=None, convert_categoricals: Optional[bool]=None, index_col: Optional[str]=None, convert_missing: Optional[bool]=None, preserve_dtypes: Optional[bool]=None, columns: Optional[Sequence[str]]=None, order_categoricals: Optional[bool]=None) -> DataFrame",
                            "_do_convert_missing(self, data: DataFrame, convert_missing: bool) -> DataFrame",
                            "_insert_strls(self, data: DataFrame) -> DataFrame",
                            "_do_select_columns(self, data: DataFrame, columns: Sequence[str]) -> DataFrame",
                            "_do_convert_categoricals(data: DataFrame, value_label_dict: Dict[str, Dict[Union[float, int], str]], lbllist: Sequence[str], order_categoricals: bool) -> DataFrame",
                            "data_label(self) -> str",
                            "variable_labels(self) -> Dict[str, str]",
                            "value_labels(self) -> Dict[str, Dict[Union[float, int], str]]",
                            "f(typ: int) -> Union[int, str]",
                            "g(typ: int) -> Union[str, np.dtype]",
                            "any_startswith(x: str) -> bool"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def _stata_elapsed_date_to_datetime_vec(dates, fmt) -> Series:\n    \"\"\"\n    Convert from SIF to datetime. https://www.stata.com/help.cgi?datetime\n\n    Parameters\n    ----------\n    dates : Series\n        The Stata Internal Format date to convert to datetime according to fmt\n    fmt : str\n        The format to convert to. Can be, tc, td, tw, tm, tq, th, ty\n        Returns\n\n    Returns\n    -------\n    converted : Series\n        The converted dates\n\n    Examples\n    --------\n    >>> dates = pd.Series([52])\n    >>> _stata_elapsed_date_to_datetime_vec(dates , \"%tw\")\n    0   1961-01-01\n    dtype: datetime64[ns]\n\n    Notes\n    -----\n    datetime/c - tc\n        milliseconds since 01jan1960 00:00:00.000, assuming 86,400 s/day\n    datetime/C - tC - NOT IMPLEMENTED\n        milliseconds since 01jan1960 00:00:00.000, adjusted for leap seconds\n    date - td\n        days since 01jan1960 (01jan1960 = 0)\n    weekly date - tw\n        weeks since 1960w1\n        This assumes 52 weeks in a year, then adds 7 * remainder of the weeks.\n        The datetime value is the start of the week in terms of days in the\n        year, not ISO calendar weeks.\n    monthly date - tm\n        months since 1960m1\n    quarterly date - tq\n        quarters since 1960q1\n    half-yearly date - th\n        half-years since 1960h1 yearly\n    date - ty\n        years since 0000\n    \"\"\"\n    MIN_YEAR, MAX_YEAR = Timestamp.min.year, Timestamp.max.year\n    MAX_DAY_DELTA = (Timestamp.max - datetime.datetime(1960, 1, 1)).days\n    MIN_DAY_DELTA = (Timestamp.min - datetime.datetime(1960, 1, 1)).days\n    MIN_MS_DELTA = MIN_DAY_DELTA * 24 * 3600 * 1000\n    MAX_MS_DELTA = MAX_DAY_DELTA * 24 * 3600 * 1000\n\n    def convert_year_month_safe(year, month) -> Series:\n        \"\"\"\n        Convert year and month to datetimes, using pandas vectorized versions\n        when the date range falls within the range supported by pandas.\n        Otherwise it falls back to a slower but more robust method\n        using datetime.\n        \"\"\"\n        if year.max() < MAX_YEAR and year.min() > MIN_YEAR:\n            return to_datetime(100 * year + month, format=\"%Y%m\")\n        else:\n            index = getattr(year, \"index\", None)\n            return Series(\n                [datetime.datetime(y, m, 1) for y, m in zip(year, month)], index=index\n            )\n\n    def convert_year_days_safe(year, days) -> Series:\n        \"\"\"\n        Converts year (e.g. 1999) and days since the start of the year to a\n        datetime or datetime64 Series\n        \"\"\"\n        if year.max() < (MAX_YEAR - 1) and year.min() > MIN_YEAR:\n            return to_datetime(year, format=\"%Y\") + to_timedelta(days, unit=\"d\")\n        else:\n            index = getattr(year, \"index\", None)\n            value = [\n                datetime.datetime(y, 1, 1) + relativedelta(days=int(d))\n                for y, d in zip(year, days)\n            ]\n            return Series(value, index=index)\n\n    def convert_delta_safe(base, deltas, unit) -> Series:\n        \"\"\"\n        Convert base dates and deltas to datetimes, using pandas vectorized\n        versions if the deltas satisfy restrictions required to be expressed\n        as dates in pandas.\n        \"\"\"\n        index = getattr(deltas, \"index\", None)\n        if unit == \"d\":\n            if deltas.max() > MAX_DAY_DELTA or deltas.min() < MIN_DAY_DELTA:\n                values = [base + relativedelta(days=int(d)) for d in deltas]\n                return Series(values, index=index)\n        elif unit == \"ms\":\n            if deltas.max() > MAX_MS_DELTA or deltas.min() < MIN_MS_DELTA:\n                values = [\n                    base + relativedelta(microseconds=(int(d) * 1000)) for d in deltas\n                ]\n                return Series(values, index=index)\n        else:\n            raise ValueError(\"format not understood\")\n        base = to_datetime(base)\n        deltas = to_timedelta(deltas, unit=unit)\n        return base + deltas\n\n    # TODO: If/when pandas supports more than datetime64[ns], this should be\n    # improved to use correct range, e.g. datetime[Y] for yearly\n    bad_locs = np.isnan(dates)\n    has_bad_values = False\n    if bad_locs.any():\n        has_bad_values = True\n        data_col = Series(dates)\n        data_col[bad_locs] = 1.0  # Replace with NaT\n    dates = dates.astype(np.int64)\n\n    if fmt.startswith((\"%tc\", \"tc\")):  # Delta ms relative to base\n        base = stata_epoch\n        ms = dates\n        conv_dates = convert_delta_safe(base, ms, \"ms\")\n    elif fmt.startswith((\"%tC\", \"tC\")):\n\n        warnings.warn(\"Encountered %tC format. Leaving in Stata Internal Format.\")\n        conv_dates = Series(dates, dtype=np.object)\n        if has_bad_values:\n            conv_dates[bad_locs] = NaT\n        return conv_dates\n    # Delta days relative to base\n    elif fmt.startswith((\"%td\", \"td\", \"%d\", \"d\")):\n        base = stata_epoch\n        days = dates\n        conv_dates = convert_delta_safe(base, days, \"d\")\n    # does not count leap days - 7 days is a week.\n    # 52nd week may have more than 7 days\n    elif fmt.startswith((\"%tw\", \"tw\")):\n        year = stata_epoch.year + dates // 52\n        days = (dates % 52) * 7\n        conv_dates = convert_year_days_safe(year, days)\n    elif fmt.startswith((\"%tm\", \"tm\")):  # Delta months relative to base\n        year = stata_epoch.year + dates // 12\n        month = (dates % 12) + 1\n        conv_dates = convert_year_month_safe(year, month)\n    elif fmt.startswith((\"%tq\", \"tq\")):  # Delta quarters relative to base\n        year = stata_epoch.year + dates // 4\n        quarter_month = (dates % 4) * 3 + 1\n        conv_dates = convert_year_month_safe(year, quarter_month)\n    elif fmt.startswith((\"%th\", \"th\")):  # Delta half-years relative to base\n        year = stata_epoch.year + dates // 2\n        month = (dates % 2) * 6 + 1\n        conv_dates = convert_year_month_safe(year, month)\n    elif fmt.startswith((\"%ty\", \"ty\")):  # Years -- not delta\n        year = dates\n        first_month = np.ones_like(dates)\n        conv_dates = convert_year_month_safe(year, first_month)\n    else:\n        raise ValueError(f\"Date fmt {fmt} not understood\")\n\n    if has_bad_values:  # Restore NaT for bad values\n        conv_dates[bad_locs] = NaT\n\n    return conv_dates",
                "def _datetime_to_stata_elapsed_vec(dates: Series, fmt: str) -> Series:\n    \"\"\"\n    Convert from datetime to SIF. https://www.stata.com/help.cgi?datetime\n\n    Parameters\n    ----------\n    dates : Series\n        Series or array containing datetime.datetime or datetime64[ns] to\n        convert to the Stata Internal Format given by fmt\n    fmt : str\n        The format to convert to. Can be, tc, td, tw, tm, tq, th, ty\n    \"\"\"\n    index = dates.index\n    NS_PER_DAY = 24 * 3600 * 1000 * 1000 * 1000\n    US_PER_DAY = NS_PER_DAY / 1000\n\n    def parse_dates_safe(dates, delta=False, year=False, days=False):\n        d = {}\n        if is_datetime64_dtype(dates.values):\n            if delta:\n                time_delta = dates - stata_epoch\n                d[\"delta\"] = time_delta.values.astype(np.int64) // 1000  # microseconds\n            if days or year:\n                # ignore since mypy reports that DatetimeIndex has no year/month\n                date_index = DatetimeIndex(dates)\n                d[\"year\"] = date_index.year  # type: ignore\n                d[\"month\"] = date_index.month  # type: ignore\n            if days:\n                days_in_ns = dates.astype(np.int64) - to_datetime(\n                    d[\"year\"], format=\"%Y\"\n                ).astype(np.int64)\n                d[\"days\"] = days_in_ns // NS_PER_DAY\n\n        elif infer_dtype(dates, skipna=False) == \"datetime\":\n            if delta:\n                delta = dates.values - stata_epoch\n\n                def f(x: datetime.timedelta) -> float:\n                    return US_PER_DAY * x.days + 1000000 * x.seconds + x.microseconds\n\n                v = np.vectorize(f)\n                d[\"delta\"] = v(delta)\n            if year:\n                year_month = dates.apply(lambda x: 100 * x.year + x.month)\n                d[\"year\"] = year_month.values // 100\n                d[\"month\"] = year_month.values - d[\"year\"] * 100\n            if days:\n\n                def g(x: datetime.datetime) -> int:\n                    return (x - datetime.datetime(x.year, 1, 1)).days\n\n                v = np.vectorize(g)\n                d[\"days\"] = v(dates)\n        else:\n            raise ValueError(\n                \"Columns containing dates must contain either \"\n                \"datetime64, datetime.datetime or null values.\"\n            )\n\n        return DataFrame(d, index=index)\n\n    bad_loc = isna(dates)\n    index = dates.index\n    if bad_loc.any():\n        dates = Series(dates)\n        if is_datetime64_dtype(dates):\n            dates[bad_loc] = to_datetime(stata_epoch)\n        else:\n            dates[bad_loc] = stata_epoch\n\n    if fmt in [\"%tc\", \"tc\"]:\n        d = parse_dates_safe(dates, delta=True)\n        conv_dates = d.delta / 1000\n    elif fmt in [\"%tC\", \"tC\"]:\n        warnings.warn(\"Stata Internal Format tC not supported.\")\n        conv_dates = dates\n    elif fmt in [\"%td\", \"td\"]:\n        d = parse_dates_safe(dates, delta=True)\n        conv_dates = d.delta // US_PER_DAY\n    elif fmt in [\"%tw\", \"tw\"]:\n        d = parse_dates_safe(dates, year=True, days=True)\n        conv_dates = 52 * (d.year - stata_epoch.year) + d.days // 7\n    elif fmt in [\"%tm\", \"tm\"]:\n        d = parse_dates_safe(dates, year=True)\n        conv_dates = 12 * (d.year - stata_epoch.year) + d.month - 1\n    elif fmt in [\"%tq\", \"tq\"]:\n        d = parse_dates_safe(dates, year=True)\n        conv_dates = 4 * (d.year - stata_epoch.year) + (d.month - 1) // 3\n    elif fmt in [\"%th\", \"th\"]:\n        d = parse_dates_safe(dates, year=True)\n        conv_dates = 2 * (d.year - stata_epoch.year) + (d.month > 6).astype(np.int)\n    elif fmt in [\"%ty\", \"ty\"]:\n        d = parse_dates_safe(dates, year=True)\n        conv_dates = d.year\n    else:\n        raise ValueError(f\"Format {fmt} is not a known Stata date format\")\n\n    conv_dates = Series(conv_dates, dtype=np.float64)\n    missing_value = struct.unpack(\"<d\", b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xe0\\x7f\")[0]\n    conv_dates[bad_loc] = missing_value\n\n    return Series(conv_dates, index=index)",
                "def _cast_to_stata_types(data: DataFrame) -> DataFrame:\n    \"\"\"Checks the dtypes of the columns of a pandas DataFrame for\n    compatibility with the data types and ranges supported by Stata, and\n    converts if necessary.\n\n    Parameters\n    ----------\n    data : DataFrame\n        The DataFrame to check and convert\n\n    Notes\n    -----\n    Numeric columns in Stata must be one of int8, int16, int32, float32 or\n    float64, with some additional value restrictions.  int8 and int16 columns\n    are checked for violations of the value restrictions and upcast if needed.\n    int64 data is not usable in Stata, and so it is downcast to int32 whenever\n    the value are in the int32 range, and sidecast to float64 when larger than\n    this range.  If the int64 values are outside of the range of those\n    perfectly representable as float64 values, a warning is raised.\n\n    bool columns are cast to int8.  uint columns are converted to int of the\n    same size if there is no loss in precision, otherwise are upcast to a\n    larger type.  uint64 is currently not supported since it is concerted to\n    object in a DataFrame.\n    \"\"\"\n    ws = \"\"\n    #                  original, if small, if large\n    conversion_data = (\n        (np.bool, np.int8, np.int8),\n        (np.uint8, np.int8, np.int16),\n        (np.uint16, np.int16, np.int32),\n        (np.uint32, np.int32, np.int64),\n    )\n\n    float32_max = struct.unpack(\"<f\", b\"\\xff\\xff\\xff\\x7e\")[0]\n    float64_max = struct.unpack(\"<d\", b\"\\xff\\xff\\xff\\xff\\xff\\xff\\xdf\\x7f\")[0]\n\n    for col in data:\n        dtype = data[col].dtype\n        # Cast from unsupported types to supported types\n        for c_data in conversion_data:\n            if dtype == c_data[0]:\n                if data[col].max() <= np.iinfo(c_data[1]).max:\n                    dtype = c_data[1]\n                else:\n                    dtype = c_data[2]\n                if c_data[2] == np.float64:  # Warn if necessary\n                    if data[col].max() >= 2 ** 53:\n                        ws = precision_loss_doc.format(\"uint64\", \"float64\")\n\n                data[col] = data[col].astype(dtype)\n\n        # Check values and upcast if necessary\n        if dtype == np.int8:\n            if data[col].max() > 100 or data[col].min() < -127:\n                data[col] = data[col].astype(np.int16)\n        elif dtype == np.int16:\n            if data[col].max() > 32740 or data[col].min() < -32767:\n                data[col] = data[col].astype(np.int32)\n        elif dtype == np.int64:\n            if data[col].max() <= 2147483620 and data[col].min() >= -2147483647:\n                data[col] = data[col].astype(np.int32)\n            else:\n                data[col] = data[col].astype(np.float64)\n                if data[col].max() >= 2 ** 53 or data[col].min() <= -(2 ** 53):\n                    ws = precision_loss_doc.format(\"int64\", \"float64\")\n        elif dtype in (np.float32, np.float64):\n            value = data[col].max()\n            if np.isinf(value):\n                raise ValueError(\n                    f\"Column {col} has a maximum value of infinity which is outside \"\n                    \"the range supported by Stata.\"\n                )\n            if dtype == np.float32 and value > float32_max:\n                data[col] = data[col].astype(np.float64)\n            elif dtype == np.float64:\n                if value > float64_max:\n                    raise ValueError(\n                        f\"Column {col} has a maximum value ({value}) outside the range \"\n                        f\"supported by Stata ({float64_max})\"\n                    )\n\n    if ws:\n        warnings.warn(ws, PossiblePrecisionLoss)\n\n    return data",
                "@Appender(_read_stata_doc)\ndef read_stata(\n    filepath_or_buffer: FilePathOrBuffer,\n    convert_dates: bool = True,\n    convert_categoricals: bool = True,\n    index_col: Optional[str] = None,\n    convert_missing: bool = False,\n    preserve_dtypes: bool = True,\n    columns: Optional[Sequence[str]] = None,\n    order_categoricals: bool = True,\n    chunksize: Optional[int] = None,\n    iterator: bool = False,\n) -> Union[DataFrame, StataReader]:\n\n    reader = StataReader(\n        filepath_or_buffer,\n        convert_dates=convert_dates,\n        convert_categoricals=convert_categoricals,\n        index_col=index_col,\n        convert_missing=convert_missing,\n        preserve_dtypes=preserve_dtypes,\n        columns=columns,\n        order_categoricals=order_categoricals,\n        chunksize=chunksize,\n    )\n\n    if iterator or chunksize:\n        return reader\n\n    try:\n        data = reader.read()\n    finally:\n        reader.close()\n    return data",
                "def _open_file_binary_write(fname: FilePathOrBuffer) -> Tuple[BinaryIO, bool]:\n    \"\"\"\n    Open a binary file or no-op if file-like.\n\n    Parameters\n    ----------\n    fname : string path, path object or buffer\n\n    Returns\n    -------\n    file : file-like object\n        File object supporting write\n    own : bool\n        True if the file was created, otherwise False\n    \"\"\"\n    if hasattr(fname, \"write\"):\n        # See https://github.com/python/mypy/issues/1424 for hasattr challenges\n        return fname, False  # type: ignore\n    elif isinstance(fname, (str, Path)):\n        return open(fname, \"wb\"), True\n    else:\n        raise TypeError(\"fname must be a binary file, buffer or path-like.\")",
                "def _set_endianness(endianness: str) -> str:\n    if endianness.lower() in [\"<\", \"little\"]:\n        return \"<\"\n    elif endianness.lower() in [\">\", \"big\"]:\n        return \">\"\n    else:  # pragma : no cover\n        raise ValueError(f\"Endianness {endianness} not understood\")",
                "def _pad_bytes(name: AnyStr, length: int) -> AnyStr:\n    \"\"\"\n    Take a char string and pads it with null bytes until it's length chars.\n    \"\"\"\n    if isinstance(name, bytes):\n        return name + b\"\\x00\" * (length - len(name))\n    return name + \"\\x00\" * (length - len(name))",
                "def _convert_datetime_to_stata_type(fmt: str) -> np.dtype:\n    \"\"\"\n    Convert from one of the stata date formats to a type in TYPE_MAP.\n    \"\"\"\n    if fmt in [\n        \"tc\",\n        \"%tc\",\n        \"td\",\n        \"%td\",\n        \"tw\",\n        \"%tw\",\n        \"tm\",\n        \"%tm\",\n        \"tq\",\n        \"%tq\",\n        \"th\",\n        \"%th\",\n        \"ty\",\n        \"%ty\",\n    ]:\n        return np.float64  # Stata expects doubles for SIFs\n    else:\n        raise NotImplementedError(f\"Format {fmt} not implemented\")",
                "def _maybe_convert_to_int_keys(convert_dates: Dict, varlist: List[Label]) -> Dict:\n    new_dict = {}\n    for key in convert_dates:\n        if not convert_dates[key].startswith(\"%\"):  # make sure proper fmts\n            convert_dates[key] = \"%\" + convert_dates[key]\n        if key in varlist:\n            new_dict.update({varlist.index(key): convert_dates[key]})\n        else:\n            if not isinstance(key, int):\n                raise ValueError(\"convert_dates key must be a column or an integer\")\n            new_dict.update({key: convert_dates[key]})\n    return new_dict",
                "def _dtype_to_stata_type(dtype: np.dtype, column: Series) -> int:\n    \"\"\"\n    Convert dtype types to stata types. Returns the byte of the given ordinal.\n    See TYPE_MAP and comments for an explanation. This is also explained in\n    the dta spec.\n    1 - 244 are strings of this length\n                         Pandas    Stata\n    251 - for int8      byte\n    252 - for int16     int\n    253 - for int32     long\n    254 - for float32   float\n    255 - for double    double\n\n    If there are dates to convert, then dtype will already have the correct\n    type inserted.\n    \"\"\"\n    # TODO: expand to handle datetime to integer conversion\n    if dtype.type == np.object_:  # try to coerce it to the biggest string\n        # not memory efficient, what else could we\n        # do?\n        itemsize = max_len_string_array(ensure_object(column.values))\n        return max(itemsize, 1)\n    elif dtype == np.float64:\n        return 255\n    elif dtype == np.float32:\n        return 254\n    elif dtype == np.int32:\n        return 253\n    elif dtype == np.int16:\n        return 252\n    elif dtype == np.int8:\n        return 251\n    else:  # pragma : no cover\n        raise NotImplementedError(f\"Data type {dtype} not supported.\")",
                "def _dtype_to_default_stata_fmt(\n    dtype, column: Series, dta_version: int = 114, force_strl: bool = False\n) -> str:\n    \"\"\"\n    Map numpy dtype to stata's default format for this type. Not terribly\n    important since users can change this in Stata. Semantics are\n\n    object  -> \"%DDs\" where DD is the length of the string.  If not a string,\n                raise ValueError\n    float64 -> \"%10.0g\"\n    float32 -> \"%9.0g\"\n    int64   -> \"%9.0g\"\n    int32   -> \"%12.0g\"\n    int16   -> \"%8.0g\"\n    int8    -> \"%8.0g\"\n    strl    -> \"%9s\"\n    \"\"\"\n    # TODO: Refactor to combine type with format\n    # TODO: expand this to handle a default datetime format?\n    if dta_version < 117:\n        max_str_len = 244\n    else:\n        max_str_len = 2045\n        if force_strl:\n            return \"%9s\"\n    if dtype.type == np.object_:\n        itemsize = max_len_string_array(ensure_object(column.values))\n        if itemsize > max_str_len:\n            if dta_version >= 117:\n                return \"%9s\"\n            else:\n                raise ValueError(excessive_string_length_error.format(column.name))\n        return \"%\" + str(max(itemsize, 1)) + \"s\"\n    elif dtype == np.float64:\n        return \"%10.0g\"\n    elif dtype == np.float32:\n        return \"%9.0g\"\n    elif dtype == np.int32:\n        return \"%12.0g\"\n    elif dtype == np.int8 or dtype == np.int16:\n        return \"%8.0g\"\n    else:  # pragma : no cover\n        raise NotImplementedError(f\"Data type {dtype} not supported.\")",
                "def _dtype_to_stata_type_117(dtype: np.dtype, column: Series, force_strl: bool) -> int:\n    \"\"\"\n    Converts dtype types to stata types. Returns the byte of the given ordinal.\n    See TYPE_MAP and comments for an explanation. This is also explained in\n    the dta spec.\n    1 - 2045 are strings of this length\n                Pandas    Stata\n    32768 - for object    strL\n    65526 - for int8      byte\n    65527 - for int16     int\n    65528 - for int32     long\n    65529 - for float32   float\n    65530 - for double    double\n\n    If there are dates to convert, then dtype will already have the correct\n    type inserted.\n    \"\"\"\n    # TODO: expand to handle datetime to integer conversion\n    if force_strl:\n        return 32768\n    if dtype.type == np.object_:  # try to coerce it to the biggest string\n        # not memory efficient, what else could we\n        # do?\n        itemsize = max_len_string_array(ensure_object(column.values))\n        itemsize = max(itemsize, 1)\n        if itemsize <= 2045:\n            return itemsize\n        return 32768\n    elif dtype == np.float64:\n        return 65526\n    elif dtype == np.float32:\n        return 65527\n    elif dtype == np.int32:\n        return 65528\n    elif dtype == np.int16:\n        return 65529\n    elif dtype == np.int8:\n        return 65530\n    else:  # pragma : no cover\n        raise NotImplementedError(f\"Data type {dtype} not supported.\")",
                "def _pad_bytes_new(name: Union[str, bytes], length: int) -> bytes:\n    \"\"\"\n    Takes a bytes instance and pads it with null bytes until it's length chars.\n    \"\"\"\n    if isinstance(name, str):\n        name = bytes(name, \"utf-8\")\n    return name + b\"\\x00\" * (length - len(name))",
                "def convert_year_month_safe(year, month) -> Series:\n    \"\"\"\n    Convert year and month to datetimes, using pandas vectorized versions\n    when the date range falls within the range supported by pandas.\n    Otherwise it falls back to a slower but more robust method\n    using datetime.\n    \"\"\"\n    if year.max() < MAX_YEAR and year.min() > MIN_YEAR:\n        return to_datetime(100 * year + month, format=\"%Y%m\")\n    else:\n        index = getattr(year, \"index\", None)\n        return Series(\n            [datetime.datetime(y, m, 1) for y, m in zip(year, month)], index=index\n        )",
                "def convert_year_days_safe(year, days) -> Series:\n    \"\"\"\n    Converts year (e.g. 1999) and days since the start of the year to a\n    datetime or datetime64 Series\n    \"\"\"\n    if year.max() < (MAX_YEAR - 1) and year.min() > MIN_YEAR:\n        return to_datetime(year, format=\"%Y\") + to_timedelta(days, unit=\"d\")\n    else:\n        index = getattr(year, \"index\", None)\n        value = [\n            datetime.datetime(y, 1, 1) + relativedelta(days=int(d))\n            for y, d in zip(year, days)\n        ]\n        return Series(value, index=index)",
                "def convert_delta_safe(base, deltas, unit) -> Series:\n    \"\"\"\n    Convert base dates and deltas to datetimes, using pandas vectorized\n    versions if the deltas satisfy restrictions required to be expressed\n    as dates in pandas.\n    \"\"\"\n    index = getattr(deltas, \"index\", None)\n    if unit == \"d\":\n        if deltas.max() > MAX_DAY_DELTA or deltas.min() < MIN_DAY_DELTA:\n            values = [base + relativedelta(days=int(d)) for d in deltas]\n            return Series(values, index=index)\n    elif unit == \"ms\":\n        if deltas.max() > MAX_MS_DELTA or deltas.min() < MIN_MS_DELTA:\n            values = [\n                base + relativedelta(microseconds=(int(d) * 1000)) for d in deltas\n            ]\n            return Series(values, index=index)\n    else:\n        raise ValueError(\"format not understood\")\n    base = to_datetime(base)\n    deltas = to_timedelta(deltas, unit=unit)\n    return base + deltas",
                "def parse_dates_safe(dates, delta=False, year=False, days=False):\n    d = {}\n    if is_datetime64_dtype(dates.values):\n        if delta:\n            time_delta = dates - stata_epoch\n            d[\"delta\"] = time_delta.values.astype(np.int64) // 1000  # microseconds\n        if days or year:\n            # ignore since mypy reports that DatetimeIndex has no year/month\n            date_index = DatetimeIndex(dates)\n            d[\"year\"] = date_index.year  # type: ignore\n            d[\"month\"] = date_index.month  # type: ignore\n        if days:\n            days_in_ns = dates.astype(np.int64) - to_datetime(\n                d[\"year\"], format=\"%Y\"\n            ).astype(np.int64)\n            d[\"days\"] = days_in_ns // NS_PER_DAY\n\n    elif infer_dtype(dates, skipna=False) == \"datetime\":\n        if delta:\n            delta = dates.values - stata_epoch\n\n            def f(x: datetime.timedelta) -> float:\n                return US_PER_DAY * x.days + 1000000 * x.seconds + x.microseconds\n\n            v = np.vectorize(f)\n            d[\"delta\"] = v(delta)\n        if year:\n            year_month = dates.apply(lambda x: 100 * x.year + x.month)\n            d[\"year\"] = year_month.values // 100\n            d[\"month\"] = year_month.values - d[\"year\"] * 100\n        if days:\n\n            def g(x: datetime.datetime) -> int:\n                return (x - datetime.datetime(x.year, 1, 1)).days\n\n            v = np.vectorize(g)\n            d[\"days\"] = v(dates)\n    else:\n        raise ValueError(\n            \"Columns containing dates must contain either \"\n            \"datetime64, datetime.datetime or null values.\"\n        )\n\n    return DataFrame(d, index=index)",
                "def __init__(self, catarray: Series, encoding: str = \"latin-1\"):\n\n    if encoding not in (\"latin-1\", \"utf-8\"):\n        raise ValueError(\"Only latin-1 and utf-8 are supported.\")\n    self.labname = catarray.name\n    self._encoding = encoding\n    categories = catarray.cat.categories\n    self.value_labels = list(zip(np.arange(len(categories)), categories))\n    self.value_labels.sort(key=lambda x: x[0])\n    self.text_len = 0\n    self.off: List[int] = []\n    self.val: List[int] = []\n    self.txt: List[bytes] = []\n    self.n = 0\n\n    # Compute lengths and setup lists of offsets and labels\n    for vl in self.value_labels:\n        category = vl[1]\n        if not isinstance(category, str):\n            category = str(category)\n            warnings.warn(\n                value_label_mismatch_doc.format(catarray.name),\n                ValueLabelTypeMismatch,\n            )\n        category = category.encode(encoding)\n        self.off.append(self.text_len)\n        self.text_len += len(category) + 1  # +1 for the padding\n        self.val.append(vl[0])\n        self.txt.append(category)\n        self.n += 1\n\n    if self.text_len > 32000:\n        raise ValueError(\n            \"Stata value labels for a single variable must \"\n            \"have a combined length less than 32,000 characters.\"\n        )\n\n    # Ensure int32\n    self.off = np.array(self.off, dtype=np.int32)\n    self.val = np.array(self.val, dtype=np.int32)\n\n    # Total length\n    self.len = 4 + 4 + 4 * self.n + 4 * self.n + self.text_len",
                "def generate_value_label(self, byteorder: str) -> bytes:\n    \"\"\"\n    Generate the binary representation of the value labals.\n\n    Parameters\n    ----------\n    byteorder : str\n        Byte order of the output\n\n    Returns\n    -------\n    value_label : bytes\n        Bytes containing the formatted value label\n    \"\"\"\n    encoding = self._encoding\n    bio = BytesIO()\n    null_byte = b\"\\x00\"\n\n    # len\n    bio.write(struct.pack(byteorder + \"i\", self.len))\n\n    # labname\n    labname = str(self.labname)[:32].encode(encoding)\n    lab_len = 32 if encoding not in (\"utf-8\", \"utf8\") else 128\n    labname = _pad_bytes(labname, lab_len + 1)\n    bio.write(labname)\n\n    # padding - 3 bytes\n    for i in range(3):\n        bio.write(struct.pack(\"c\", null_byte))\n\n    # value_label_table\n    # n - int32\n    bio.write(struct.pack(byteorder + \"i\", self.n))\n\n    # textlen  - int32\n    bio.write(struct.pack(byteorder + \"i\", self.text_len))\n\n    # off - int32 array (n elements)\n    for offset in self.off:\n        bio.write(struct.pack(byteorder + \"i\", offset))\n\n    # val - int32 array (n elements)\n    for value in self.val:\n        bio.write(struct.pack(byteorder + \"i\", value))\n\n    # txt - Text labels, null terminated\n    for text in self.txt:\n        bio.write(text + null_byte)\n\n    bio.seek(0)\n    return bio.read()",
                "def __init__(self, value: Union[int, float]):\n    self._value = value\n    # Conversion to int to avoid hash issues on 32 bit platforms #8968\n    value = int(value) if value < 2147483648 else float(value)\n    self._str = self.MISSING_VALUES[value]",
                "@property\ndef string(self) -> str:\n    \"\"\"\n    The Stata representation of the missing value: '.', '.a'..'.z'\n\n    Returns\n    -------\n    str\n        The representation of the missing value.\n    \"\"\"\n    return self._str",
                "@property\ndef value(self) -> Union[int, float]:\n    \"\"\"\n    The binary representation of the missing value.\n\n    Returns\n    -------\n    {int, float}\n        The binary representation of the missing value.\n    \"\"\"\n    return self._value",
                "def __str__(self) -> str:\n    return self.string",
                "def __repr__(self) -> str:\n    return f\"{type(self)}({self})\"",
                "def __eq__(self, other: Any) -> bool:\n    return (\n        isinstance(other, type(self))\n        and self.string == other.string\n        and self.value == other.value\n    )",
                "@classmethod\ndef get_base_missing_value(cls, dtype: np.dtype) -> Union[int, float]:\n    if dtype == np.int8:\n        value = cls.BASE_MISSING_VALUES[\"int8\"]\n    elif dtype == np.int16:\n        value = cls.BASE_MISSING_VALUES[\"int16\"]\n    elif dtype == np.int32:\n        value = cls.BASE_MISSING_VALUES[\"int32\"]\n    elif dtype == np.float32:\n        value = cls.BASE_MISSING_VALUES[\"float32\"]\n    elif dtype == np.float64:\n        value = cls.BASE_MISSING_VALUES[\"float64\"]\n    else:\n        raise ValueError(\"Unsupported dtype\")\n    return value",
                "def __init__(self):\n\n    # type          code.\n    # --------------------\n    # str1        1 = 0x01\n    # str2        2 = 0x02\n    # ...\n    # str244    244 = 0xf4\n    # byte      251 = 0xfb  (sic)\n    # int       252 = 0xfc\n    # long      253 = 0xfd\n    # float     254 = 0xfe\n    # double    255 = 0xff\n    # --------------------\n    # NOTE: the byte type seems to be reserved for categorical variables\n    # with a label, but the underlying variable is -127 to 100\n    # we're going to drop the label and cast to int\n    self.DTYPE_MAP = dict(\n        list(zip(range(1, 245), [\"a\" + str(i) for i in range(1, 245)]))\n        + [\n            (251, np.int8),\n            (252, np.int16),\n            (253, np.int32),\n            (254, np.float32),\n            (255, np.float64),\n        ]\n    )\n    self.DTYPE_MAP_XML = dict(\n        [\n            (32768, np.uint8),  # Keys to GSO\n            (65526, np.float64),\n            (65527, np.float32),\n            (65528, np.int32),\n            (65529, np.int16),\n            (65530, np.int8),\n        ]\n    )\n    self.TYPE_MAP = list(range(251)) + list(\"bhlfd\")\n    self.TYPE_MAP_XML = dict(\n        [\n            # Not really a Q, unclear how to handle byteswap\n            (32768, \"Q\"),\n            (65526, \"d\"),\n            (65527, \"f\"),\n            (65528, \"l\"),\n            (65529, \"h\"),\n            (65530, \"b\"),\n        ]\n    )\n    # NOTE: technically, some of these are wrong. there are more numbers\n    # that can be represented. it's the 27 ABOVE and BELOW the max listed\n    # numeric data type in [U] 12.2.2 of the 11.2 manual\n    float32_min = b\"\\xff\\xff\\xff\\xfe\"\n    float32_max = b\"\\xff\\xff\\xff\\x7e\"\n    float64_min = b\"\\xff\\xff\\xff\\xff\\xff\\xff\\xef\\xff\"\n    float64_max = b\"\\xff\\xff\\xff\\xff\\xff\\xff\\xdf\\x7f\"\n    self.VALID_RANGE = {\n        \"b\": (-127, 100),\n        \"h\": (-32767, 32740),\n        \"l\": (-2147483647, 2147483620),\n        \"f\": (\n            np.float32(struct.unpack(\"<f\", float32_min)[0]),\n            np.float32(struct.unpack(\"<f\", float32_max)[0]),\n        ),\n        \"d\": (\n            np.float64(struct.unpack(\"<d\", float64_min)[0]),\n            np.float64(struct.unpack(\"<d\", float64_max)[0]),\n        ),\n    }\n\n    self.OLD_TYPE_MAPPING = {\n        98: 251,  # byte\n        105: 252,  # int\n        108: 253,  # long\n        102: 254  # float\n        # don't know old code for double\n    }\n\n    # These missing values are the generic '.' in Stata, and are used\n    # to replace nans\n    self.MISSING_VALUES = {\n        \"b\": 101,\n        \"h\": 32741,\n        \"l\": 2147483621,\n        \"f\": np.float32(struct.unpack(\"<f\", b\"\\x00\\x00\\x00\\x7f\")[0]),\n        \"d\": np.float64(\n            struct.unpack(\"<d\", b\"\\x00\\x00\\x00\\x00\\x00\\x00\\xe0\\x7f\")[0]\n        ),\n    }\n    self.NUMPY_TYPE_MAP = {\n        \"b\": \"i1\",\n        \"h\": \"i2\",\n        \"l\": \"i4\",\n        \"f\": \"f4\",\n        \"d\": \"f8\",\n        \"Q\": \"u8\",\n    }\n\n    # Reserved words cannot be used as variable names\n    self.RESERVED_WORDS = (\n        \"aggregate\",\n        \"array\",\n        \"boolean\",\n        \"break\",\n        \"byte\",\n        \"case\",\n        \"catch\",\n        \"class\",\n        \"colvector\",\n        \"complex\",\n        \"const\",\n        \"continue\",\n        \"default\",\n        \"delegate\",\n        \"delete\",\n        \"do\",\n        \"double\",\n        \"else\",\n        \"eltypedef\",\n        \"end\",\n        \"enum\",\n        \"explicit\",\n        \"export\",\n        \"external\",\n        \"float\",\n        \"for\",\n        \"friend\",\n        \"function\",\n        \"global\",\n        \"goto\",\n        \"if\",\n        \"inline\",\n        \"int\",\n        \"local\",\n        \"long\",\n        \"NULL\",\n        \"pragma\",\n        \"protected\",\n        \"quad\",\n        \"rowvector\",\n        \"short\",\n        \"typedef\",\n        \"typename\",\n        \"virtual\",\n        \"_all\",\n        \"_N\",\n        \"_skip\",\n        \"_b\",\n        \"_pi\",\n        \"str#\",\n        \"in\",\n        \"_pred\",\n        \"strL\",\n        \"_coef\",\n        \"_rc\",\n        \"using\",\n        \"_cons\",\n        \"_se\",\n        \"with\",\n        \"_n\",\n    )",
                "def __init__(\n    self,\n    path_or_buf: FilePathOrBuffer,\n    convert_dates: bool = True,\n    convert_categoricals: bool = True,\n    index_col: Optional[str] = None,\n    convert_missing: bool = False,\n    preserve_dtypes: bool = True,\n    columns: Optional[Sequence[str]] = None,\n    order_categoricals: bool = True,\n    chunksize: Optional[int] = None,\n):\n    super().__init__()\n    self.col_sizes: List[int] = []\n\n    # Arguments to the reader (can be temporarily overridden in\n    # calls to read).\n    self._convert_dates = convert_dates\n    self._convert_categoricals = convert_categoricals\n    self._index_col = index_col\n    self._convert_missing = convert_missing\n    self._preserve_dtypes = preserve_dtypes\n    self._columns = columns\n    self._order_categoricals = order_categoricals\n    self._encoding = \"\"\n    self._chunksize = chunksize\n\n    # State variables for the file\n    self._has_string_data = False\n    self._missing_values = False\n    self._can_read_value_labels = False\n    self._column_selector_set = False\n    self._value_labels_read = False\n    self._data_read = False\n    self._dtype = None\n    self._lines_read = 0\n\n    self._native_byteorder = _set_endianness(sys.byteorder)\n    path_or_buf = stringify_path(path_or_buf)\n    if isinstance(path_or_buf, str):\n        path_or_buf, encoding, _, should_close = get_filepath_or_buffer(path_or_buf)\n\n    if isinstance(path_or_buf, (str, bytes)):\n        self.path_or_buf = open(path_or_buf, \"rb\")\n    elif isinstance(path_or_buf, IOBase):\n        # Copy to BytesIO, and ensure no encoding\n        contents = path_or_buf.read()\n        self.path_or_buf = BytesIO(contents)\n\n    self._read_header()\n    self._setup_dtype()",
                "def __enter__(self) -> \"StataReader\":\n    \"\"\" enter context manager \"\"\"\n    return self",
                "def __exit__(self, exc_type, exc_value, traceback) -> None:\n    \"\"\" exit context manager \"\"\"\n    self.close()",
                "def close(self) -> None:\n    \"\"\" close the handle if its open \"\"\"\n    try:\n        self.path_or_buf.close()\n    except IOError:\n        pass",
                "def _set_encoding(self) -> None:\n    \"\"\"\n    Set string encoding which depends on file version\n    \"\"\"\n    if self.format_version < 118:\n        self._encoding = \"latin-1\"\n    else:\n        self._encoding = \"utf-8\"",
                "def _read_header(self) -> None:\n    first_char = self.path_or_buf.read(1)\n    if struct.unpack(\"c\", first_char)[0] == b\"<\":\n        self._read_new_header()\n    else:\n        self._read_old_header(first_char)\n\n    self.has_string_data = len([x for x in self.typlist if type(x) is int]) > 0\n\n    # calculate size of a data record\n    self.col_sizes = [self._calcsize(typ) for typ in self.typlist]",
                "def _read_new_header(self) -> None:\n    # The first part of the header is common to 117 - 119.\n    self.path_or_buf.read(27)  # stata_dta><header><release>\n    self.format_version = int(self.path_or_buf.read(3))\n    if self.format_version not in [117, 118, 119]:\n        raise ValueError(_version_error.format(version=self.format_version))\n    self._set_encoding()\n    self.path_or_buf.read(21)  # </release><byteorder>\n    self.byteorder = self.path_or_buf.read(3) == b\"MSF\" and \">\" or \"<\"\n    self.path_or_buf.read(15)  # </byteorder><K>\n    nvar_type = \"H\" if self.format_version <= 118 else \"I\"\n    nvar_size = 2 if self.format_version <= 118 else 4\n    self.nvar = struct.unpack(\n        self.byteorder + nvar_type, self.path_or_buf.read(nvar_size)\n    )[0]\n    self.path_or_buf.read(7)  # </K><N>\n\n    self.nobs = self._get_nobs()\n    self.path_or_buf.read(11)  # </N><label>\n    self._data_label = self._get_data_label()\n    self.path_or_buf.read(19)  # </label><timestamp>\n    self.time_stamp = self._get_time_stamp()\n    self.path_or_buf.read(26)  # </timestamp></header><map>\n    self.path_or_buf.read(8)  # 0x0000000000000000\n    self.path_or_buf.read(8)  # position of <map>\n\n    self._seek_vartypes = (\n        struct.unpack(self.byteorder + \"q\", self.path_or_buf.read(8))[0] + 16\n    )\n    self._seek_varnames = (\n        struct.unpack(self.byteorder + \"q\", self.path_or_buf.read(8))[0] + 10\n    )\n    self._seek_sortlist = (\n        struct.unpack(self.byteorder + \"q\", self.path_or_buf.read(8))[0] + 10\n    )\n    self._seek_formats = (\n        struct.unpack(self.byteorder + \"q\", self.path_or_buf.read(8))[0] + 9\n    )\n    self._seek_value_label_names = (\n        struct.unpack(self.byteorder + \"q\", self.path_or_buf.read(8))[0] + 19\n    )\n\n    # Requires version-specific treatment\n    self._seek_variable_labels = self._get_seek_variable_labels()\n\n    self.path_or_buf.read(8)  # <characteristics>\n    self.data_location = (\n        struct.unpack(self.byteorder + \"q\", self.path_or_buf.read(8))[0] + 6\n    )\n    self.seek_strls = (\n        struct.unpack(self.byteorder + \"q\", self.path_or_buf.read(8))[0] + 7\n    )\n    self.seek_value_labels = (\n        struct.unpack(self.byteorder + \"q\", self.path_or_buf.read(8))[0] + 14\n    )\n\n    self.typlist, self.dtyplist = self._get_dtypes(self._seek_vartypes)\n\n    self.path_or_buf.seek(self._seek_varnames)\n    self.varlist = self._get_varlist()\n\n    self.path_or_buf.seek(self._seek_sortlist)\n    self.srtlist = struct.unpack(\n        self.byteorder + (\"h\" * (self.nvar + 1)),\n        self.path_or_buf.read(2 * (self.nvar + 1)),\n    )[:-1]\n\n    self.path_or_buf.seek(self._seek_formats)\n    self.fmtlist = self._get_fmtlist()\n\n    self.path_or_buf.seek(self._seek_value_label_names)\n    self.lbllist = self._get_lbllist()\n\n    self.path_or_buf.seek(self._seek_variable_labels)\n    self._variable_labels = self._get_variable_labels()",
                "def _get_dtypes(\n    self, seek_vartypes: int\n) -> Tuple[List[Union[int, str]], List[Union[int, np.dtype]]]:\n\n    self.path_or_buf.seek(seek_vartypes)\n    raw_typlist = [\n        struct.unpack(self.byteorder + \"H\", self.path_or_buf.read(2))[0]\n        for _ in range(self.nvar)\n    ]\n\n    def f(typ: int) -> Union[int, str]:\n        if typ <= 2045:\n            return typ\n        try:\n            return self.TYPE_MAP_XML[typ]\n        except KeyError:\n            raise ValueError(f\"cannot convert stata types [{typ}]\")\n\n    typlist = [f(x) for x in raw_typlist]\n\n    def g(typ: int) -> Union[str, np.dtype]:\n        if typ <= 2045:\n            return str(typ)\n        try:\n            return self.DTYPE_MAP_XML[typ]\n        except KeyError:\n            raise ValueError(f\"cannot convert stata dtype [{typ}]\")\n\n    dtyplist = [g(x) for x in raw_typlist]\n\n    return typlist, dtyplist",
                "def _get_varlist(self) -> List[str]:\n    # 33 in order formats, 129 in formats 118 and 119\n    b = 33 if self.format_version < 118 else 129\n    return [self._decode(self.path_or_buf.read(b)) for _ in range(self.nvar)]",
                "def _get_fmtlist(self) -> List[str]:\n    if self.format_version >= 118:\n        b = 57\n    elif self.format_version > 113:\n        b = 49\n    elif self.format_version > 104:\n        b = 12\n    else:\n        b = 7\n\n    return [self._decode(self.path_or_buf.read(b)) for _ in range(self.nvar)]",
                "def _get_lbllist(self) -> List[str]:\n    if self.format_version >= 118:\n        b = 129\n    elif self.format_version > 108:\n        b = 33\n    else:\n        b = 9\n    return [self._decode(self.path_or_buf.read(b)) for _ in range(self.nvar)]",
                "def _get_variable_labels(self) -> List[str]:\n    if self.format_version >= 118:\n        vlblist = [\n            self._decode(self.path_or_buf.read(321)) for _ in range(self.nvar)\n        ]\n    elif self.format_version > 105:\n        vlblist = [\n            self._decode(self.path_or_buf.read(81)) for _ in range(self.nvar)\n        ]\n    else:\n        vlblist = [\n            self._decode(self.path_or_buf.read(32)) for _ in range(self.nvar)\n        ]\n    return vlblist",
                "def _get_nobs(self) -> int:\n    if self.format_version >= 118:\n        return struct.unpack(self.byteorder + \"Q\", self.path_or_buf.read(8))[0]\n    else:\n        return struct.unpack(self.byteorder + \"I\", self.path_or_buf.read(4))[0]",
                "def _get_data_label(self) -> str:\n    if self.format_version >= 118:\n        strlen = struct.unpack(self.byteorder + \"H\", self.path_or_buf.read(2))[0]\n        return self._decode(self.path_or_buf.read(strlen))\n    elif self.format_version == 117:\n        strlen = struct.unpack(\"b\", self.path_or_buf.read(1))[0]\n        return self._decode(self.path_or_buf.read(strlen))\n    elif self.format_version > 105:\n        return self._decode(self.path_or_buf.read(81))\n    else:\n        return self._decode(self.path_or_buf.read(32))",
                "def _get_time_stamp(self) -> str:\n    if self.format_version >= 118:\n        strlen = struct.unpack(\"b\", self.path_or_buf.read(1))[0]\n        return self.path_or_buf.read(strlen).decode(\"utf-8\")\n    elif self.format_version == 117:\n        strlen = struct.unpack(\"b\", self.path_or_buf.read(1))[0]\n        return self._decode(self.path_or_buf.read(strlen))\n    elif self.format_version > 104:\n        return self._decode(self.path_or_buf.read(18))\n    else:\n        raise ValueError()",
                "def _get_seek_variable_labels(self) -> int:\n    if self.format_version == 117:\n        self.path_or_buf.read(8)  # <variable_labels>, throw away\n        # Stata 117 data files do not follow the described format.  This is\n        # a work around that uses the previous label, 33 bytes for each\n        # variable, 20 for the closing tag and 17 for the opening tag\n        return self._seek_value_label_names + (33 * self.nvar) + 20 + 17\n    elif self.format_version >= 118:\n        return struct.unpack(self.byteorder + \"q\", self.path_or_buf.read(8))[0] + 17\n    else:\n        raise ValueError()",
                "def _read_old_header(self, first_char: bytes) -> None:\n    self.format_version = struct.unpack(\"b\", first_char)[0]\n    if self.format_version not in [104, 105, 108, 111, 113, 114, 115]:\n        raise ValueError(_version_error.format(version=self.format_version))\n    self._set_encoding()\n    self.byteorder = (\n        struct.unpack(\"b\", self.path_or_buf.read(1))[0] == 0x1 and \">\" or \"<\"\n    )\n    self.filetype = struct.unpack(\"b\", self.path_or_buf.read(1))[0]\n    self.path_or_buf.read(1)  # unused\n\n    self.nvar = struct.unpack(self.byteorder + \"H\", self.path_or_buf.read(2))[0]\n    self.nobs = self._get_nobs()\n\n    self._data_label = self._get_data_label()\n\n    self.time_stamp = self._get_time_stamp()\n\n    # descriptors\n    if self.format_version > 108:\n        typlist = [ord(self.path_or_buf.read(1)) for _ in range(self.nvar)]\n    else:\n        buf = self.path_or_buf.read(self.nvar)\n        typlistb = np.frombuffer(buf, dtype=np.uint8)\n        typlist = []\n        for tp in typlistb:\n            if tp in self.OLD_TYPE_MAPPING:\n                typlist.append(self.OLD_TYPE_MAPPING[tp])\n            else:\n                typlist.append(tp - 127)  # bytes\n\n    try:\n        self.typlist = [self.TYPE_MAP[typ] for typ in typlist]\n    except ValueError:\n        invalid_types = \",\".join(str(x) for x in typlist)\n        raise ValueError(f\"cannot convert stata types [{invalid_types}]\")\n    try:\n        self.dtyplist = [self.DTYPE_MAP[typ] for typ in typlist]\n    except ValueError:\n        invalid_dtypes = \",\".join(str(x) for x in typlist)\n        raise ValueError(f\"cannot convert stata dtypes [{invalid_dtypes}]\")\n\n    if self.format_version > 108:\n        self.varlist = [\n            self._decode(self.path_or_buf.read(33)) for _ in range(self.nvar)\n        ]\n    else:\n        self.varlist = [\n            self._decode(self.path_or_buf.read(9)) for _ in range(self.nvar)\n        ]\n    self.srtlist = struct.unpack(\n        self.byteorder + (\"h\" * (self.nvar + 1)),\n        self.path_or_buf.read(2 * (self.nvar + 1)),\n    )[:-1]\n\n    self.fmtlist = self._get_fmtlist()\n\n    self.lbllist = self._get_lbllist()\n\n    self._variable_labels = self._get_variable_labels()\n\n    # ignore expansion fields (Format 105 and later)\n    # When reading, read five bytes; the last four bytes now tell you\n    # the size of the next read, which you discard.  You then continue\n    # like this until you read 5 bytes of zeros.\n\n    if self.format_version > 104:\n        while True:\n            data_type = struct.unpack(\n                self.byteorder + \"b\", self.path_or_buf.read(1)\n            )[0]\n            if self.format_version > 108:\n                data_len = struct.unpack(\n                    self.byteorder + \"i\", self.path_or_buf.read(4)\n                )[0]\n            else:\n                data_len = struct.unpack(\n                    self.byteorder + \"h\", self.path_or_buf.read(2)\n                )[0]\n            if data_type == 0:\n                break\n            self.path_or_buf.read(data_len)\n\n    # necessary data to continue parsing\n    self.data_location = self.path_or_buf.tell()",
                "def _setup_dtype(self) -> np.dtype:\n    \"\"\"Map between numpy and state dtypes\"\"\"\n    if self._dtype is not None:\n        return self._dtype\n\n    dtypes = []  # Convert struct data types to numpy data type\n    for i, typ in enumerate(self.typlist):\n        if typ in self.NUMPY_TYPE_MAP:\n            dtypes.append((\"s\" + str(i), self.byteorder + self.NUMPY_TYPE_MAP[typ]))\n        else:\n            dtypes.append((\"s\" + str(i), \"S\" + str(typ)))\n    self._dtype = np.dtype(dtypes)\n\n    return self._dtype",
                "def _calcsize(self, fmt: Union[int, str]) -> int:\n    if isinstance(fmt, int):\n        return fmt\n    return struct.calcsize(self.byteorder + fmt)",
                "    def _decode(self, s: bytes) -> str:\n        # have bytes not strings, so must decode\n        s = s.partition(b\"\\0\")[0]\n        try:\n            return s.decode(self._encoding)\n        except UnicodeDecodeError:\n            # GH 25960, fallback to handle incorrect format produced when 117\n            # files are converted to 118 files in Stata\n            encoding = self._encoding\n            msg = f\"\"\"\nOne or more strings in the dta file could not be decoded using {encoding}, and\nso the fallback encoding of latin-1 is being used.  This can happen when a file\nhas been incorrectly encoded by Stata or some other software. You should verify\nthe string values returned are correct.\"\"\"\n            warnings.warn(msg, UnicodeWarning)\n            return s.decode(\"latin-1\")",
                "def _read_value_labels(self) -> None:\n    if self._value_labels_read:\n        # Don't read twice\n        return\n    if self.format_version <= 108:\n        # Value labels are not supported in version 108 and earlier.\n        self._value_labels_read = True\n        self.value_label_dict: Dict[str, Dict[Union[float, int], str]] = {}\n        return\n\n    if self.format_version >= 117:\n        self.path_or_buf.seek(self.seek_value_labels)\n    else:\n        assert self._dtype is not None\n        offset = self.nobs * self._dtype.itemsize\n        self.path_or_buf.seek(self.data_location + offset)\n\n    self._value_labels_read = True\n    self.value_label_dict = {}\n\n    while True:\n        if self.format_version >= 117:\n            if self.path_or_buf.read(5) == b\"</val\":  # <lbl>\n                break  # end of value label table\n\n        slength = self.path_or_buf.read(4)\n        if not slength:\n            break  # end of value label table (format < 117)\n        if self.format_version <= 117:\n            labname = self._decode(self.path_or_buf.read(33))\n        else:\n            labname = self._decode(self.path_or_buf.read(129))\n        self.path_or_buf.read(3)  # padding\n\n        n = struct.unpack(self.byteorder + \"I\", self.path_or_buf.read(4))[0]\n        txtlen = struct.unpack(self.byteorder + \"I\", self.path_or_buf.read(4))[0]\n        off = np.frombuffer(\n            self.path_or_buf.read(4 * n), dtype=self.byteorder + \"i4\", count=n\n        )\n        val = np.frombuffer(\n            self.path_or_buf.read(4 * n), dtype=self.byteorder + \"i4\", count=n\n        )\n        ii = np.argsort(off)\n        off = off[ii]\n        val = val[ii]\n        txt = self.path_or_buf.read(txtlen)\n        self.value_label_dict[labname] = dict()\n        for i in range(n):\n            end = off[i + 1] if i < n - 1 else txtlen\n            self.value_label_dict[labname][val[i]] = self._decode(txt[off[i] : end])\n        if self.format_version >= 117:\n            self.path_or_buf.read(6)  # </lbl>\n    self._value_labels_read = True",
                "def _read_strls(self) -> None:\n    self.path_or_buf.seek(self.seek_strls)\n    # Wrap v_o in a string to allow uint64 values as keys on 32bit OS\n    self.GSO = {\"0\": \"\"}\n    while True:\n        if self.path_or_buf.read(3) != b\"GSO\":\n            break\n\n        if self.format_version == 117:\n            v_o = struct.unpack(self.byteorder + \"Q\", self.path_or_buf.read(8))[0]\n        else:\n            buf = self.path_or_buf.read(12)\n            # Only tested on little endian file on little endian machine.\n            v_size = 2 if self.format_version == 118 else 3\n            if self.byteorder == \"<\":\n                buf = buf[0:v_size] + buf[4 : (12 - v_size)]\n            else:\n                # This path may not be correct, impossible to test\n                buf = buf[0:v_size] + buf[(4 + v_size) :]\n            v_o = struct.unpack(\"Q\", buf)[0]\n        typ = struct.unpack(\"B\", self.path_or_buf.read(1))[0]\n        length = struct.unpack(self.byteorder + \"I\", self.path_or_buf.read(4))[0]\n        va = self.path_or_buf.read(length)\n        if typ == 130:\n            decoded_va = va[0:-1].decode(self._encoding)\n        else:\n            # Stata says typ 129 can be binary, so use str\n            decoded_va = str(va)\n            # Wrap v_o in a string to allow uint64 values as keys on 32bit OS\n        self.GSO[str(v_o)] = decoded_va",
                "def __next__(self) -> DataFrame:\n    return self.read(nrows=self._chunksize or 1)",
                "def get_chunk(self, size: Optional[int] = None) -> DataFrame:\n    \"\"\"\n    Reads lines from Stata file and returns as dataframe\n\n    Parameters\n    ----------\n    size : int, defaults to None\n        Number of lines to read.  If None, reads whole file.\n\n    Returns\n    -------\n    DataFrame\n    \"\"\"\n    if size is None:\n        size = self._chunksize\n    return self.read(nrows=size)",
                "@Appender(_read_method_doc)\ndef read(\n    self,\n    nrows: Optional[int] = None,\n    convert_dates: Optional[bool] = None,\n    convert_categoricals: Optional[bool] = None,\n    index_col: Optional[str] = None,\n    convert_missing: Optional[bool] = None,\n    preserve_dtypes: Optional[bool] = None,\n    columns: Optional[Sequence[str]] = None,\n    order_categoricals: Optional[bool] = None,\n) -> DataFrame:\n    # Handle empty file or chunk.  If reading incrementally raise\n    # StopIteration.  If reading the whole thing return an empty\n    # data frame.\n    if (self.nobs == 0) and (nrows is None):\n        self._can_read_value_labels = True\n        self._data_read = True\n        self.close()\n        return DataFrame(columns=self.varlist)\n\n    # Handle options\n    if convert_dates is None:\n        convert_dates = self._convert_dates\n    if convert_categoricals is None:\n        convert_categoricals = self._convert_categoricals\n    if convert_missing is None:\n        convert_missing = self._convert_missing\n    if preserve_dtypes is None:\n        preserve_dtypes = self._preserve_dtypes\n    if columns is None:\n        columns = self._columns\n    if order_categoricals is None:\n        order_categoricals = self._order_categoricals\n    if index_col is None:\n        index_col = self._index_col\n\n    if nrows is None:\n        nrows = self.nobs\n\n    if (self.format_version >= 117) and (not self._value_labels_read):\n        self._can_read_value_labels = True\n        self._read_strls()\n\n    # Read data\n    assert self._dtype is not None\n    dtype = self._dtype\n    max_read_len = (self.nobs - self._lines_read) * dtype.itemsize\n    read_len = nrows * dtype.itemsize\n    read_len = min(read_len, max_read_len)\n    if read_len <= 0:\n        # Iterator has finished, should never be here unless\n        # we are reading the file incrementally\n        if convert_categoricals:\n            self._read_value_labels()\n        self.close()\n        raise StopIteration\n    offset = self._lines_read * dtype.itemsize\n    self.path_or_buf.seek(self.data_location + offset)\n    read_lines = min(nrows, self.nobs - self._lines_read)\n    data = np.frombuffer(\n        self.path_or_buf.read(read_len), dtype=dtype, count=read_lines\n    )\n\n    self._lines_read += read_lines\n    if self._lines_read == self.nobs:\n        self._can_read_value_labels = True\n        self._data_read = True\n    # if necessary, swap the byte order to native here\n    if self.byteorder != self._native_byteorder:\n        data = data.byteswap().newbyteorder()\n\n    if convert_categoricals:\n        self._read_value_labels()\n\n    if len(data) == 0:\n        data = DataFrame(columns=self.varlist)\n    else:\n        data = DataFrame.from_records(data)\n        data.columns = self.varlist\n\n    # If index is not specified, use actual row number rather than\n    # restarting at 0 for each chunk.\n    if index_col is None:\n        ix = np.arange(self._lines_read - read_lines, self._lines_read)\n        data = data.set_index(ix)\n\n    if columns is not None:\n        try:\n            data = self._do_select_columns(data, columns)\n        except ValueError:\n            self.close()\n            raise\n\n    # Decode strings\n    for col, typ in zip(data, self.typlist):\n        if type(typ) is int:\n            data[col] = data[col].apply(self._decode, convert_dtype=True)\n\n    data = self._insert_strls(data)\n\n    cols_ = np.where(self.dtyplist)[0]\n\n    # Convert columns (if needed) to match input type\n    ix = data.index\n    requires_type_conversion = False\n    data_formatted = []\n    for i in cols_:\n        if self.dtyplist[i] is not None:\n            col = data.columns[i]\n            dtype = data[col].dtype\n            if dtype != np.dtype(object) and dtype != self.dtyplist[i]:\n                requires_type_conversion = True\n                data_formatted.append(\n                    (col, Series(data[col], ix, self.dtyplist[i]))\n                )\n            else:\n                data_formatted.append((col, data[col]))\n    if requires_type_conversion:\n        data = DataFrame.from_dict(dict(data_formatted))\n    del data_formatted\n\n    data = self._do_convert_missing(data, convert_missing)\n\n    if convert_dates:\n\n        def any_startswith(x: str) -> bool:\n            return any(x.startswith(fmt) for fmt in _date_formats)\n\n        cols = np.where([any_startswith(x) for x in self.fmtlist])[0]\n        for i in cols:\n            col = data.columns[i]\n            try:\n                data[col] = _stata_elapsed_date_to_datetime_vec(\n                    data[col], self.fmtlist[i]\n                )\n            except ValueError:\n                self.close()\n                raise\n\n    if convert_categoricals and self.format_version > 108:\n        data = self._do_convert_categoricals(\n            data, self.value_label_dict, self.lbllist, order_categoricals\n        )\n\n    if not preserve_dtypes:\n        retyped_data = []\n        convert = False\n        for col in data:\n            dtype = data[col].dtype\n            if dtype in (np.float16, np.float32):\n                dtype = np.float64\n                convert = True\n            elif dtype in (np.int8, np.int16, np.int32):\n                dtype = np.int64\n                convert = True\n            retyped_data.append((col, data[col].astype(dtype)))\n        if convert:\n            data = DataFrame.from_dict(dict(retyped_data))\n\n    if index_col is not None:\n        data = data.set_index(data.pop(index_col))\n\n    return data",
                "def _do_convert_missing(self, data: DataFrame, convert_missing: bool) -> DataFrame:\n    # Check for missing values, and replace if found\n    replacements = {}\n    for i, colname in enumerate(data):\n        fmt = self.typlist[i]\n        if fmt not in self.VALID_RANGE:\n            continue\n\n        nmin, nmax = self.VALID_RANGE[fmt]\n        series = data[colname]\n        missing = np.logical_or(series < nmin, series > nmax)\n\n        if not missing.any():\n            continue\n\n        if convert_missing:  # Replacement follows Stata notation\n            missing_loc = np.argwhere(missing._ndarray_values)\n            umissing, umissing_loc = np.unique(series[missing], return_inverse=True)\n            replacement = Series(series, dtype=np.object)\n            for j, um in enumerate(umissing):\n                missing_value = StataMissingValue(um)\n\n                loc = missing_loc[umissing_loc == j]\n                replacement.iloc[loc] = missing_value\n        else:  # All replacements are identical\n            dtype = series.dtype\n            if dtype not in (np.float32, np.float64):\n                dtype = np.float64\n            replacement = Series(series, dtype=dtype)\n            replacement[missing] = np.nan\n        replacements[colname] = replacement\n    if replacements:\n        columns = data.columns\n        replacement_df = DataFrame(replacements)\n        replaced = concat([data.drop(replacement_df.columns, 1), replacement_df], 1)\n        data = replaced[columns]\n    return data",
                "def _insert_strls(self, data: DataFrame) -> DataFrame:\n    if not hasattr(self, \"GSO\") or len(self.GSO) == 0:\n        return data\n    for i, typ in enumerate(self.typlist):\n        if typ != \"Q\":\n            continue\n        # Wrap v_o in a string to allow uint64 values as keys on 32bit OS\n        data.iloc[:, i] = [self.GSO[str(k)] for k in data.iloc[:, i]]\n    return data",
                "def _do_select_columns(self, data: DataFrame, columns: Sequence[str]) -> DataFrame:\n\n    if not self._column_selector_set:\n        column_set = set(columns)\n        if len(column_set) != len(columns):\n            raise ValueError(\"columns contains duplicate entries\")\n        unmatched = column_set.difference(data.columns)\n        if unmatched:\n            joined = \", \".join(list(unmatched))\n            raise ValueError(\n                \"The following columns were not \"\n                f\"found in the Stata data set: {joined}\"\n            )\n        # Copy information for retained columns for later processing\n        dtyplist = []\n        typlist = []\n        fmtlist = []\n        lbllist = []\n        for col in columns:\n            i = data.columns.get_loc(col)\n            dtyplist.append(self.dtyplist[i])\n            typlist.append(self.typlist[i])\n            fmtlist.append(self.fmtlist[i])\n            lbllist.append(self.lbllist[i])\n\n        self.dtyplist = dtyplist\n        self.typlist = typlist\n        self.fmtlist = fmtlist\n        self.lbllist = lbllist\n        self._column_selector_set = True\n\n    return data[columns]",
                "    @staticmethod\n    def _do_convert_categoricals(\n        data: DataFrame,\n        value_label_dict: Dict[str, Dict[Union[float, int], str]],\n        lbllist: Sequence[str],\n        order_categoricals: bool,\n    ) -> DataFrame:\n        \"\"\"\n        Converts categorical columns to Categorical type.\n        \"\"\"\n        value_labels = list(value_label_dict.keys())\n        cat_converted_data = []\n        for col, label in zip(data, lbllist):\n            if label in value_labels:\n                # Explicit call with ordered=True\n                cat_data = Categorical(data[col], ordered=order_categoricals)\n                categories = []\n                for category in cat_data.categories:\n                    if category in value_label_dict[label]:\n                        categories.append(value_label_dict[label][category])\n                    else:\n                        categories.append(category)  # Partially labeled\n                try:\n                    cat_data.categories = categories\n                except ValueError:\n                    vc = Series(categories).value_counts()\n                    repeated_cats = list(vc.index[vc > 1])\n                    repeats = \"-\" * 80 + \"\\n\" + \"\\n\".join(repeated_cats)\n                    # GH 25772\n                    msg = f\"\"\"\nValue labels for column {col} are not unique. These cannot be converted to\npandas categoricals.\n\nEither read the file with `convert_categoricals` set to False or use the\nlow level interface in `StataReader` to separately read the values and the\nvalue_labels.\n\nThe repeated labels are:\n{repeats}\n\"\"\"\n                    raise ValueError(msg)\n                # TODO: is the next line needed above in the data(...) method?\n                cat_series = Series(cat_data, index=data.index)\n                cat_converted_data.append((col, cat_series))\n            else:\n                cat_converted_data.append((col, data[col]))\n        data = DataFrame.from_dict(dict(cat_converted_data))\n        return data",
                "@property\ndef data_label(self) -> str:\n    \"\"\"\n    Return data label of Stata file.\n    \"\"\"\n    return self._data_label",
                "def variable_labels(self) -> Dict[str, str]:\n    \"\"\"\n    Return variable labels as a dict, associating each variable name\n    with corresponding label.\n\n    Returns\n    -------\n    dict\n    \"\"\"\n    return dict(zip(self.varlist, self._variable_labels))",
                "def value_labels(self) -> Dict[str, Dict[Union[float, int], str]]:\n    \"\"\"\n    Return a dict, associating each variable name a dict, associating\n    each value its corresponding label.\n\n    Returns\n    -------\n    dict\n    \"\"\"\n    if not self._value_labels_read:\n        self._read_value_labels()\n\n    return self.value_label_dict",
                "def __init__(\n    self,\n    fname: FilePathOrBuffer,\n    data: DataFrame,\n    convert_dates: Optional[Dict[Label, str]] = None,\n    write_index: bool = True,\n    byteorder: Optional[str] = None,\n    time_stamp: Optional[datetime.datetime] = None,\n    data_label: Optional[str] = None,\n    variable_labels: Optional[Dict[Label, str]] = None,\n):\n    super().__init__()\n    self._convert_dates = {} if convert_dates is None else convert_dates\n    self._write_index = write_index\n    self._time_stamp = time_stamp\n    self._data_label = data_label\n    self._variable_labels = variable_labels\n    self._own_file = True\n    # attach nobs, nvars, data, varlist, typlist\n    self._prepare_pandas(data)\n\n    if byteorder is None:\n        byteorder = sys.byteorder\n    self._byteorder = _set_endianness(byteorder)\n    self._fname = stringify_path(fname)\n    self.type_converters = {253: np.int32, 252: np.int16, 251: np.int8}\n    self._converted_names: Dict[Label, str] = {}\n    self._file: Optional[BinaryIO] = None",
                "def _write(self, to_write: str) -> None:\n    \"\"\"\n    Helper to call encode before writing to file for Python 3 compat.\n    \"\"\"\n    assert self._file is not None\n    self._file.write(to_write.encode(self._encoding))",
                "def _write_bytes(self, value: bytes) -> None:\n    \"\"\"\n    Helper to assert file is open before writing.\n    \"\"\"\n    assert self._file is not None\n    self._file.write(value)",
                "def _prepare_categoricals(self, data: DataFrame) -> DataFrame:\n    \"\"\"Check for categorical columns, retain categorical information for\n    Stata file and convert categorical data to int\"\"\"\n\n    is_cat = [is_categorical_dtype(data[col]) for col in data]\n    self._is_col_cat = is_cat\n    self._value_labels: List[StataValueLabel] = []\n    if not any(is_cat):\n        return data\n\n    get_base_missing_value = StataMissingValue.get_base_missing_value\n    data_formatted = []\n    for col, col_is_cat in zip(data, is_cat):\n        if col_is_cat:\n            svl = StataValueLabel(data[col], encoding=self._encoding)\n            self._value_labels.append(svl)\n            dtype = data[col].cat.codes.dtype\n            if dtype == np.int64:\n                raise ValueError(\n                    \"It is not possible to export \"\n                    \"int64-based categorical data to Stata.\"\n                )\n            values = data[col].cat.codes.values.copy()\n\n            # Upcast if needed so that correct missing values can be set\n            if values.max() >= get_base_missing_value(dtype):\n                if dtype == np.int8:\n                    dtype = np.int16\n                elif dtype == np.int16:\n                    dtype = np.int32\n                else:\n                    dtype = np.float64\n                values = np.array(values, dtype=dtype)\n\n            # Replace missing values with Stata missing value for type\n            values[values == -1] = get_base_missing_value(dtype)\n            data_formatted.append((col, values))\n        else:\n            data_formatted.append((col, data[col]))\n    return DataFrame.from_dict(dict(data_formatted))",
                "def _replace_nans(self, data: DataFrame) -> DataFrame:\n    # return data\n    \"\"\"Checks floating point data columns for nans, and replaces these with\n    the generic Stata for missing value (.)\"\"\"\n    for c in data:\n        dtype = data[c].dtype\n        if dtype in (np.float32, np.float64):\n            if dtype == np.float32:\n                replacement = self.MISSING_VALUES[\"f\"]\n            else:\n                replacement = self.MISSING_VALUES[\"d\"]\n            data[c] = data[c].fillna(replacement)\n\n    return data",
                "def _update_strl_names(self) -> None:\n    \"\"\"No-op, forward compatibility\"\"\"\n    pass",
                "def _validate_variable_name(self, name: str) -> str:\n    \"\"\"\n    Validate variable names for Stata export.\n\n    Parameters\n    ----------\n    name : str\n        Variable name\n\n    Returns\n    -------\n    str\n        The validated name with invalid characters replaced with\n        underscores.\n\n    Notes\n    -----\n    Stata 114 and 117 support ascii characters in a-z, A-Z, 0-9\n    and _.\n    \"\"\"\n    for c in name:\n        if (\n            (c < \"A\" or c > \"Z\")\n            and (c < \"a\" or c > \"z\")\n            and (c < \"0\" or c > \"9\")\n            and c != \"_\"\n        ):\n            name = name.replace(c, \"_\")\n    return name",
                "def _check_column_names(self, data: DataFrame) -> DataFrame:\n    \"\"\"\n    Checks column names to ensure that they are valid Stata column names.\n    This includes checks for:\n        * Non-string names\n        * Stata keywords\n        * Variables that start with numbers\n        * Variables with names that are too long\n\n    When an illegal variable name is detected, it is converted, and if\n    dates are exported, the variable name is propagated to the date\n    conversion dictionary\n    \"\"\"\n    converted_names: Dict[Label, str] = {}\n    columns: List[Label] = list(data.columns)\n    original_columns = columns[:]\n\n    duplicate_var_id = 0\n    for j, name in enumerate(columns):\n        orig_name = name\n        if not isinstance(name, str):\n            name = str(name)\n\n        name = self._validate_variable_name(name)\n\n        # Variable name must not be a reserved word\n        if name in self.RESERVED_WORDS:\n            name = \"_\" + name\n\n        # Variable name may not start with a number\n        if \"0\" <= name[0] <= \"9\":\n            name = \"_\" + name\n\n        name = name[: min(len(name), 32)]\n\n        if not name == orig_name:\n            # check for duplicates\n            while columns.count(name) > 0:\n                # prepend ascending number to avoid duplicates\n                name = \"_\" + str(duplicate_var_id) + name\n                name = name[: min(len(name), 32)]\n                duplicate_var_id += 1\n            converted_names[orig_name] = name\n\n        columns[j] = name\n\n    data.columns = Index(columns)\n\n    # Check date conversion, and fix key if needed\n    if self._convert_dates:\n        for c, o in zip(columns, original_columns):\n            if c != o:\n                self._convert_dates[c] = self._convert_dates[o]\n                del self._convert_dates[o]\n\n    if converted_names:\n        conversion_warning = []\n        for orig_name, name in converted_names.items():\n            msg = f\"{orig_name}   ->   {name}\"\n            conversion_warning.append(msg)\n\n        ws = invalid_name_doc.format(\"\\n    \".join(conversion_warning))\n        warnings.warn(ws, InvalidColumnName)\n\n    self._converted_names = converted_names\n    self._update_strl_names()\n\n    return data",
                "def _set_formats_and_types(self, dtypes: Series) -> None:\n    self.fmtlist: List[str] = []\n    self.typlist: List[int] = []\n    for col, dtype in dtypes.items():\n        self.fmtlist.append(_dtype_to_default_stata_fmt(dtype, self.data[col]))\n        self.typlist.append(_dtype_to_stata_type(dtype, self.data[col]))",
                "def _prepare_pandas(self, data: DataFrame) -> None:\n    # NOTE: we might need a different API / class for pandas objects so\n    # we can set different semantics - handle this with a PR to pandas.io\n\n    data = data.copy()\n\n    if self._write_index:\n        temp = data.reset_index()\n        if isinstance(temp, DataFrame):\n            data = temp\n\n    # Ensure column names are strings\n    data = self._check_column_names(data)\n\n    # Check columns for compatibility with stata, upcast if necessary\n    # Raise if outside the supported range\n    data = _cast_to_stata_types(data)\n\n    # Replace NaNs with Stata missing values\n    data = self._replace_nans(data)\n\n    # Convert categoricals to int data, and strip labels\n    data = self._prepare_categoricals(data)\n\n    self.nobs, self.nvar = data.shape\n    self.data = data\n    self.varlist = data.columns.tolist()\n\n    dtypes = data.dtypes\n\n    # Ensure all date columns are converted\n    for col in data:\n        if col in self._convert_dates:\n            continue\n        if is_datetime64_dtype(data[col]):\n            self._convert_dates[col] = \"tc\"\n\n    self._convert_dates = _maybe_convert_to_int_keys(\n        self._convert_dates, self.varlist\n    )\n    for key in self._convert_dates:\n        new_type = _convert_datetime_to_stata_type(self._convert_dates[key])\n        dtypes[key] = np.dtype(new_type)\n\n    # Verify object arrays are strings and encode to bytes\n    self._encode_strings()\n\n    self._set_formats_and_types(dtypes)\n\n    # set the given format for the datetime cols\n    if self._convert_dates is not None:\n        for key in self._convert_dates:\n            if isinstance(key, int):\n                self.fmtlist[key] = self._convert_dates[key]",
                "    def _encode_strings(self) -> None:\n        \"\"\"\n        Encode strings in dta-specific encoding\n\n        Do not encode columns marked for date conversion or for strL\n        conversion. The strL converter independently handles conversion and\n        also accepts empty string arrays.\n        \"\"\"\n        convert_dates = self._convert_dates\n        # _convert_strl is not available in dta 114\n        convert_strl = getattr(self, \"_convert_strl\", [])\n        for i, col in enumerate(self.data):\n            # Skip columns marked for date conversion or strl conversion\n            if i in convert_dates or col in convert_strl:\n                continue\n            column = self.data[col]\n            dtype = column.dtype\n            if dtype.type == np.object_:\n                inferred_dtype = infer_dtype(column, skipna=True)\n                if not ((inferred_dtype == \"string\") or len(column) == 0):\n                    col = column.name\n                    raise ValueError(\n                        f\"\"\"\\\nColumn `{col}` cannot be exported.\\n\\nOnly string-like object arrays\ncontaining all strings or a mix of strings and None can be exported.\nObject arrays containing only null values are prohibited. Other object\ntypes cannot be exported and must first be converted to one of the\nsupported types.\"\"\"\n                    )\n                encoded = self.data[col].str.encode(self._encoding)\n                # If larger than _max_string_length do nothing\n                if (\n                    max_len_string_array(ensure_object(encoded.values))\n                    <= self._max_string_length\n                ):\n                    self.data[col] = encoded",
                "def write_file(self) -> None:\n    self._file, self._own_file = _open_file_binary_write(self._fname)\n    try:\n        self._write_header(data_label=self._data_label, time_stamp=self._time_stamp)\n        self._write_map()\n        self._write_variable_types()\n        self._write_varnames()\n        self._write_sortlist()\n        self._write_formats()\n        self._write_value_label_names()\n        self._write_variable_labels()\n        self._write_expansion_fields()\n        self._write_characteristics()\n        records = self._prepare_data()\n        self._write_data(records)\n        self._write_strls()\n        self._write_value_labels()\n        self._write_file_close_tag()\n        self._write_map()\n    except Exception as exc:\n        self._close()\n        if self._own_file:\n            try:\n                if isinstance(self._fname, (str, Path)):\n                    os.unlink(self._fname)\n            except OSError:\n                warnings.warn(\n                    f\"This save was not successful but {self._fname} could not \"\n                    \"be deleted.  This file is not valid.\",\n                    ResourceWarning,\n                )\n        raise exc\n    else:\n        self._close()",
                "def _close(self) -> None:\n    \"\"\"\n    Close the file if it was created by the writer.\n\n    If a buffer or file-like object was passed in, for example a GzipFile,\n    then leave this file open for the caller to close. In either case,\n    attempt to flush the file contents to ensure they are written to disk\n    (if supported)\n    \"\"\"\n    # Some file-like objects might not support flush\n    assert self._file is not None\n    try:\n        self._file.flush()\n    except AttributeError:\n        pass\n    if self._own_file:\n        self._file.close()",
                "def _write_map(self) -> None:\n    \"\"\"No-op, future compatibility\"\"\"\n    pass",
                "def _write_file_close_tag(self) -> None:\n    \"\"\"No-op, future compatibility\"\"\"\n    pass",
                "def _write_characteristics(self) -> None:\n    \"\"\"No-op, future compatibility\"\"\"\n    pass",
                "def _write_strls(self) -> None:\n    \"\"\"No-op, future compatibility\"\"\"\n    pass",
                "def _write_expansion_fields(self) -> None:\n    \"\"\"Write 5 zeros for expansion fields\"\"\"\n    self._write(_pad_bytes(\"\", 5))",
                "def _write_value_labels(self) -> None:\n    for vl in self._value_labels:\n        self._write_bytes(vl.generate_value_label(self._byteorder))",
                "def _write_header(\n    self,\n    data_label: Optional[str] = None,\n    time_stamp: Optional[datetime.datetime] = None,\n) -> None:\n    byteorder = self._byteorder\n    # ds_format - just use 114\n    self._write_bytes(struct.pack(\"b\", 114))\n    # byteorder\n    self._write(byteorder == \">\" and \"\\x01\" or \"\\x02\")\n    # filetype\n    self._write(\"\\x01\")\n    # unused\n    self._write(\"\\x00\")\n    # number of vars, 2 bytes\n    self._write_bytes(struct.pack(byteorder + \"h\", self.nvar)[:2])\n    # number of obs, 4 bytes\n    self._write_bytes(struct.pack(byteorder + \"i\", self.nobs)[:4])\n    # data label 81 bytes, char, null terminated\n    if data_label is None:\n        self._write_bytes(self._null_terminate_bytes(_pad_bytes(\"\", 80)))\n    else:\n        self._write_bytes(\n            self._null_terminate_bytes(_pad_bytes(data_label[:80], 80))\n        )\n    # time stamp, 18 bytes, char, null terminated\n    # format dd Mon yyyy hh:mm\n    if time_stamp is None:\n        time_stamp = datetime.datetime.now()\n    elif not isinstance(time_stamp, datetime.datetime):\n        raise ValueError(\"time_stamp should be datetime type\")\n    # GH #13856\n    # Avoid locale-specific month conversion\n    months = [\n        \"Jan\",\n        \"Feb\",\n        \"Mar\",\n        \"Apr\",\n        \"May\",\n        \"Jun\",\n        \"Jul\",\n        \"Aug\",\n        \"Sep\",\n        \"Oct\",\n        \"Nov\",\n        \"Dec\",\n    ]\n    month_lookup = {i + 1: month for i, month in enumerate(months)}\n    ts = (\n        time_stamp.strftime(\"%d \")\n        + month_lookup[time_stamp.month]\n        + time_stamp.strftime(\" %Y %H:%M\")\n    )\n    self._write_bytes(self._null_terminate_bytes(ts))",
                "def _write_variable_types(self) -> None:\n    for typ in self.typlist:\n        self._write_bytes(struct.pack(\"B\", typ))",
                "def _write_varnames(self) -> None:\n    # varlist names are checked by _check_column_names\n    # varlist, requires null terminated\n    for name in self.varlist:\n        name = self._null_terminate_str(name)\n        name = _pad_bytes(name[:32], 33)\n        self._write(name)",
                "def _write_sortlist(self) -> None:\n    # srtlist, 2*(nvar+1), int array, encoded by byteorder\n    srtlist = _pad_bytes(\"\", 2 * (self.nvar + 1))\n    self._write(srtlist)",
                "def _write_formats(self) -> None:\n    # fmtlist, 49*nvar, char array\n    for fmt in self.fmtlist:\n        self._write(_pad_bytes(fmt, 49))",
                "def _write_value_label_names(self) -> None:\n    # lbllist, 33*nvar, char array\n    for i in range(self.nvar):\n        # Use variable name when categorical\n        if self._is_col_cat[i]:\n            name = self.varlist[i]\n            name = self._null_terminate_str(name)\n            name = _pad_bytes(name[:32], 33)\n            self._write(name)\n        else:  # Default is empty label\n            self._write(_pad_bytes(\"\", 33))",
                "def _write_variable_labels(self) -> None:\n    # Missing labels are 80 blank characters plus null termination\n    blank = _pad_bytes(\"\", 81)\n\n    if self._variable_labels is None:\n        for i in range(self.nvar):\n            self._write(blank)\n        return\n\n    for col in self.data:\n        if col in self._variable_labels:\n            label = self._variable_labels[col]\n            if len(label) > 80:\n                raise ValueError(\"Variable labels must be 80 characters or fewer\")\n            is_latin1 = all(ord(c) < 256 for c in label)\n            if not is_latin1:\n                raise ValueError(\n                    \"Variable labels must contain only characters that \"\n                    \"can be encoded in Latin-1\"\n                )\n            self._write(_pad_bytes(label, 81))\n        else:\n            self._write(blank)",
                "def _convert_strls(self, data: DataFrame) -> DataFrame:\n    \"\"\"No-op, future compatibility\"\"\"\n    return data",
                "def _prepare_data(self) -> np.recarray:\n    data = self.data\n    typlist = self.typlist\n    convert_dates = self._convert_dates\n    # 1. Convert dates\n    if self._convert_dates is not None:\n        for i, col in enumerate(data):\n            if i in convert_dates:\n                data[col] = _datetime_to_stata_elapsed_vec(\n                    data[col], self.fmtlist[i]\n                )\n    # 2. Convert strls\n    data = self._convert_strls(data)\n\n    # 3. Convert bad string data to '' and pad to correct length\n    dtypes = {}\n    native_byteorder = self._byteorder == _set_endianness(sys.byteorder)\n    for i, col in enumerate(data):\n        typ = typlist[i]\n        if typ <= self._max_string_length:\n            data[col] = data[col].fillna(\"\").apply(_pad_bytes, args=(typ,))\n            stype = f\"S{typ}\"\n            dtypes[col] = stype\n            data[col] = data[col].astype(stype)\n        else:\n            dtype = data[col].dtype\n            if not native_byteorder:\n                dtype = dtype.newbyteorder(self._byteorder)\n            dtypes[col] = dtype\n\n    return data.to_records(index=False, column_dtypes=dtypes)",
                "def _write_data(self, records: np.recarray) -> None:\n    self._write_bytes(records.tobytes())",
                "@staticmethod\ndef _null_terminate_str(s: str) -> str:\n    s += \"\\x00\"\n    return s",
                "def _null_terminate_bytes(self, s: str) -> bytes:\n    return self._null_terminate_str(s).encode(self._encoding)",
                "def __init__(\n    self,\n    df: DataFrame,\n    columns: Sequence[str],\n    version: int = 117,\n    byteorder: Optional[str] = None,\n):\n    if version not in (117, 118, 119):\n        raise ValueError(\"Only dta versions 117, 118 and 119 supported\")\n    self._dta_ver = version\n\n    self.df = df\n    self.columns = columns\n    self._gso_table = {\"\": (0, 0)}\n    if byteorder is None:\n        byteorder = sys.byteorder\n    self._byteorder = _set_endianness(byteorder)\n\n    gso_v_type = \"I\"  # uint32\n    gso_o_type = \"Q\"  # uint64\n    self._encoding = \"utf-8\"\n    if version == 117:\n        o_size = 4\n        gso_o_type = \"I\"  # 117 used uint32\n        self._encoding = \"latin-1\"\n    elif version == 118:\n        o_size = 6\n    else:  # version == 119\n        o_size = 5\n    self._o_offet = 2 ** (8 * (8 - o_size))\n    self._gso_o_type = gso_o_type\n    self._gso_v_type = gso_v_type",
                "def _convert_key(self, key: Tuple[int, int]) -> int:\n    v, o = key\n    return v + self._o_offet * o",
                "def generate_table(self) -> Tuple[Dict[str, Tuple[int, int]], DataFrame]:\n    \"\"\"\n    Generates the GSO lookup table for the DataFrame\n\n    Returns\n    -------\n    gso_table : dict\n        Ordered dictionary using the string found as keys\n        and their lookup position (v,o) as values\n    gso_df : DataFrame\n        DataFrame where strl columns have been converted to\n        (v,o) values\n\n    Notes\n    -----\n    Modifies the DataFrame in-place.\n\n    The DataFrame returned encodes the (v,o) values as uint64s. The\n    encoding depends on the dta version, and can be expressed as\n\n    enc = v + o * 2 ** (o_size * 8)\n\n    so that v is stored in the lower bits and o is in the upper\n    bits. o_size is\n\n      * 117: 4\n      * 118: 6\n      * 119: 5\n    \"\"\"\n\n    gso_table = self._gso_table\n    gso_df = self.df\n    columns = list(gso_df.columns)\n    selected = gso_df[self.columns]\n    col_index = [(col, columns.index(col)) for col in self.columns]\n    keys = np.empty(selected.shape, dtype=np.uint64)\n    for o, (idx, row) in enumerate(selected.iterrows()):\n        for j, (col, v) in enumerate(col_index):\n            val = row[col]\n            # Allow columns with mixed str and None (GH 23633)\n            val = \"\" if val is None else val\n            key = gso_table.get(val, None)\n            if key is None:\n                # Stata prefers human numbers\n                key = (v + 1, o + 1)\n                gso_table[val] = key\n            keys[o, j] = self._convert_key(key)\n    for i, col in enumerate(self.columns):\n        gso_df[col] = keys[:, i]\n\n    return gso_table, gso_df",
                "def generate_blob(self, gso_table: Dict[str, Tuple[int, int]]) -> bytes:\n    \"\"\"\n    Generates the binary blob of GSOs that is written to the dta file.\n\n    Parameters\n    ----------\n    gso_table : dict\n        Ordered dictionary (str, vo)\n\n    Returns\n    -------\n    gso : bytes\n        Binary content of dta file to be placed between strl tags\n\n    Notes\n    -----\n    Output format depends on dta version.  117 uses two uint32s to\n    express v and o while 118+ uses a uint32 for v and a uint64 for o.\n    \"\"\"\n    # Format information\n    # Length includes null term\n    # 117\n    # GSOvvvvooootllllxxxxxxxxxxxxxxx...x\n    #  3  u4  u4 u1 u4  string + null term\n    #\n    # 118, 119\n    # GSOvvvvooooooootllllxxxxxxxxxxxxxxx...x\n    #  3  u4   u8   u1 u4    string + null term\n\n    bio = BytesIO()\n    gso = bytes(\"GSO\", \"ascii\")\n    gso_type = struct.pack(self._byteorder + \"B\", 130)\n    null = struct.pack(self._byteorder + \"B\", 0)\n    v_type = self._byteorder + self._gso_v_type\n    o_type = self._byteorder + self._gso_o_type\n    len_type = self._byteorder + \"I\"\n    for strl, vo in gso_table.items():\n        if vo == (0, 0):\n            continue\n        v, o = vo\n\n        # GSO\n        bio.write(gso)\n\n        # vvvv\n        bio.write(struct.pack(v_type, v))\n\n        # oooo / oooooooo\n        bio.write(struct.pack(o_type, o))\n\n        # t\n        bio.write(gso_type)\n\n        # llll\n        utf8_string = bytes(strl, \"utf-8\")\n        bio.write(struct.pack(len_type, len(utf8_string) + 1))\n\n        # xxx...xxx\n        bio.write(utf8_string)\n        bio.write(null)\n\n    bio.seek(0)\n    return bio.read()",
                "def __init__(\n    self,\n    fname: FilePathOrBuffer,\n    data: DataFrame,\n    convert_dates: Optional[Dict[Label, str]] = None,\n    write_index: bool = True,\n    byteorder: Optional[str] = None,\n    time_stamp: Optional[datetime.datetime] = None,\n    data_label: Optional[str] = None,\n    variable_labels: Optional[Dict[Label, str]] = None,\n    convert_strl: Optional[Sequence[Label]] = None,\n):\n    # Copy to new list since convert_strl might be modified later\n    self._convert_strl: List[Label] = []\n    if convert_strl is not None:\n        self._convert_strl.extend(convert_strl)\n\n    super().__init__(\n        fname,\n        data,\n        convert_dates,\n        write_index,\n        byteorder=byteorder,\n        time_stamp=time_stamp,\n        data_label=data_label,\n        variable_labels=variable_labels,\n    )\n    self._map: Dict[str, int] = {}\n    self._strl_blob = b\"\"",
                "@staticmethod\ndef _tag(val: Union[str, bytes], tag: str) -> bytes:\n    \"\"\"Surround val with <tag></tag>\"\"\"\n    if isinstance(val, str):\n        val = bytes(val, \"utf-8\")\n    return bytes(\"<\" + tag + \">\", \"utf-8\") + val + bytes(\"</\" + tag + \">\", \"utf-8\")",
                "def _update_map(self, tag: str) -> None:\n    \"\"\"Update map location for tag with file position\"\"\"\n    assert self._file is not None\n    self._map[tag] = self._file.tell()",
                "def _write_header(\n    self,\n    data_label: Optional[str] = None,\n    time_stamp: Optional[datetime.datetime] = None,\n) -> None:\n    \"\"\"Write the file header\"\"\"\n    byteorder = self._byteorder\n    self._write_bytes(bytes(\"<stata_dta>\", \"utf-8\"))\n    bio = BytesIO()\n    # ds_format - 117\n    bio.write(self._tag(bytes(str(self._dta_version), \"utf-8\"), \"release\"))\n    # byteorder\n    bio.write(self._tag(byteorder == \">\" and \"MSF\" or \"LSF\", \"byteorder\"))\n    # number of vars, 2 bytes in 117 and 118, 4 byte in 119\n    nvar_type = \"H\" if self._dta_version <= 118 else \"I\"\n    bio.write(self._tag(struct.pack(byteorder + nvar_type, self.nvar), \"K\"))\n    # 117 uses 4 bytes, 118 uses 8\n    nobs_size = \"I\" if self._dta_version == 117 else \"Q\"\n    bio.write(self._tag(struct.pack(byteorder + nobs_size, self.nobs), \"N\"))\n    # data label 81 bytes, char, null terminated\n    label = data_label[:80] if data_label is not None else \"\"\n    encoded_label = label.encode(self._encoding)\n    label_size = \"B\" if self._dta_version == 117 else \"H\"\n    label_len = struct.pack(byteorder + label_size, len(encoded_label))\n    encoded_label = label_len + encoded_label\n    bio.write(self._tag(encoded_label, \"label\"))\n    # time stamp, 18 bytes, char, null terminated\n    # format dd Mon yyyy hh:mm\n    if time_stamp is None:\n        time_stamp = datetime.datetime.now()\n    elif not isinstance(time_stamp, datetime.datetime):\n        raise ValueError(\"time_stamp should be datetime type\")\n    # Avoid locale-specific month conversion\n    months = [\n        \"Jan\",\n        \"Feb\",\n        \"Mar\",\n        \"Apr\",\n        \"May\",\n        \"Jun\",\n        \"Jul\",\n        \"Aug\",\n        \"Sep\",\n        \"Oct\",\n        \"Nov\",\n        \"Dec\",\n    ]\n    month_lookup = {i + 1: month for i, month in enumerate(months)}\n    ts = (\n        time_stamp.strftime(\"%d \")\n        + month_lookup[time_stamp.month]\n        + time_stamp.strftime(\" %Y %H:%M\")\n    )\n    # '\\x11' added due to inspection of Stata file\n    stata_ts = b\"\\x11\" + bytes(ts, \"utf-8\")\n    bio.write(self._tag(stata_ts, \"timestamp\"))\n    bio.seek(0)\n    self._write_bytes(self._tag(bio.read(), \"header\"))",
                "def _write_map(self) -> None:\n    \"\"\"Called twice during file write. The first populates the values in\n    the map with 0s.  The second call writes the final map locations when\n    all blocks have been written.\"\"\"\n    assert self._file is not None\n    if not self._map:\n        self._map = dict(\n            (\n                (\"stata_data\", 0),\n                (\"map\", self._file.tell()),\n                (\"variable_types\", 0),\n                (\"varnames\", 0),\n                (\"sortlist\", 0),\n                (\"formats\", 0),\n                (\"value_label_names\", 0),\n                (\"variable_labels\", 0),\n                (\"characteristics\", 0),\n                (\"data\", 0),\n                (\"strls\", 0),\n                (\"value_labels\", 0),\n                (\"stata_data_close\", 0),\n                (\"end-of-file\", 0),\n            )\n        )\n    # Move to start of map\n    self._file.seek(self._map[\"map\"])\n    bio = BytesIO()\n    for val in self._map.values():\n        bio.write(struct.pack(self._byteorder + \"Q\", val))\n    bio.seek(0)\n    self._write_bytes(self._tag(bio.read(), \"map\"))",
                "def _write_variable_types(self) -> None:\n    self._update_map(\"variable_types\")\n    bio = BytesIO()\n    for typ in self.typlist:\n        bio.write(struct.pack(self._byteorder + \"H\", typ))\n    bio.seek(0)\n    self._write_bytes(self._tag(bio.read(), \"variable_types\"))",
                "def _write_varnames(self) -> None:\n    self._update_map(\"varnames\")\n    bio = BytesIO()\n    # 118 scales by 4 to accommodate utf-8 data worst case encoding\n    vn_len = 32 if self._dta_version == 117 else 128\n    for name in self.varlist:\n        name = self._null_terminate_str(name)\n        name = _pad_bytes_new(name[:32].encode(self._encoding), vn_len + 1)\n        bio.write(name)\n    bio.seek(0)\n    self._write_bytes(self._tag(bio.read(), \"varnames\"))",
                "def _write_sortlist(self) -> None:\n    self._update_map(\"sortlist\")\n    sort_size = 2 if self._dta_version < 119 else 4\n    self._write_bytes(self._tag(b\"\\x00\" * sort_size * (self.nvar + 1), \"sortlist\"))",
                "def _write_formats(self) -> None:\n    self._update_map(\"formats\")\n    bio = BytesIO()\n    fmt_len = 49 if self._dta_version == 117 else 57\n    for fmt in self.fmtlist:\n        bio.write(_pad_bytes_new(fmt.encode(self._encoding), fmt_len))\n    bio.seek(0)\n    self._write_bytes(self._tag(bio.read(), \"formats\"))",
                "def _write_value_label_names(self) -> None:\n    self._update_map(\"value_label_names\")\n    bio = BytesIO()\n    # 118 scales by 4 to accommodate utf-8 data worst case encoding\n    vl_len = 32 if self._dta_version == 117 else 128\n    for i in range(self.nvar):\n        # Use variable name when categorical\n        name = \"\"  # default name\n        if self._is_col_cat[i]:\n            name = self.varlist[i]\n        name = self._null_terminate_str(name)\n        encoded_name = _pad_bytes_new(name[:32].encode(self._encoding), vl_len + 1)\n        bio.write(encoded_name)\n    bio.seek(0)\n    self._write_bytes(self._tag(bio.read(), \"value_label_names\"))",
                "def _write_variable_labels(self) -> None:\n    # Missing labels are 80 blank characters plus null termination\n    self._update_map(\"variable_labels\")\n    bio = BytesIO()\n    # 118 scales by 4 to accommodate utf-8 data worst case encoding\n    vl_len = 80 if self._dta_version == 117 else 320\n    blank = _pad_bytes_new(\"\", vl_len + 1)\n\n    if self._variable_labels is None:\n        for _ in range(self.nvar):\n            bio.write(blank)\n        bio.seek(0)\n        self._write_bytes(self._tag(bio.read(), \"variable_labels\"))\n        return\n\n    for col in self.data:\n        if col in self._variable_labels:\n            label = self._variable_labels[col]\n            if len(label) > 80:\n                raise ValueError(\"Variable labels must be 80 characters or fewer\")\n            try:\n                encoded = label.encode(self._encoding)\n            except UnicodeEncodeError:\n                raise ValueError(\n                    \"Variable labels must contain only characters that \"\n                    f\"can be encoded in {self._encoding}\"\n                )\n\n            bio.write(_pad_bytes_new(encoded, vl_len + 1))\n        else:\n            bio.write(blank)\n    bio.seek(0)\n    self._write_bytes(self._tag(bio.read(), \"variable_labels\"))",
                "def _write_characteristics(self) -> None:\n    self._update_map(\"characteristics\")\n    self._write_bytes(self._tag(b\"\", \"characteristics\"))",
                "def _write_data(self, records) -> None:\n    self._update_map(\"data\")\n    self._write_bytes(b\"<data>\")\n    self._write_bytes(records.tobytes())\n    self._write_bytes(b\"</data>\")",
                "def _write_strls(self) -> None:\n    self._update_map(\"strls\")\n    self._write_bytes(self._tag(self._strl_blob, \"strls\"))",
                "def _write_expansion_fields(self) -> None:\n    \"\"\"No-op in dta 117+\"\"\"\n    pass",
                "def _write_value_labels(self) -> None:\n    self._update_map(\"value_labels\")\n    bio = BytesIO()\n    for vl in self._value_labels:\n        lab = vl.generate_value_label(self._byteorder)\n        lab = self._tag(lab, \"lbl\")\n        bio.write(lab)\n    bio.seek(0)\n    self._write_bytes(self._tag(bio.read(), \"value_labels\"))",
                "def _write_file_close_tag(self) -> None:\n    self._update_map(\"stata_data_close\")\n    self._write_bytes(bytes(\"</stata_dta>\", \"utf-8\"))\n    self._update_map(\"end-of-file\")",
                "def _update_strl_names(self) -> None:\n    \"\"\"Update column names for conversion to strl if they might have been\n    changed to comply with Stata naming rules\"\"\"\n    # Update convert_strl if names changed\n    for orig, new in self._converted_names.items():\n        if orig in self._convert_strl:\n            idx = self._convert_strl.index(orig)\n            self._convert_strl[idx] = new",
                "def _convert_strls(self, data: DataFrame) -> DataFrame:\n    \"\"\"Convert columns to StrLs if either very large or in the\n    convert_strl variable\"\"\"\n    convert_cols = [\n        col\n        for i, col in enumerate(data)\n        if self.typlist[i] == 32768 or col in self._convert_strl\n    ]\n\n    if convert_cols:\n        ssw = StataStrLWriter(data, convert_cols, version=self._dta_version)\n        tab, new_data = ssw.generate_table()\n        data = new_data\n        self._strl_blob = ssw.generate_blob(tab)\n    return data",
                "def _set_formats_and_types(self, dtypes: Series) -> None:\n    self.typlist = []\n    self.fmtlist = []\n    for col, dtype in dtypes.items():\n        force_strl = col in self._convert_strl\n        fmt = _dtype_to_default_stata_fmt(\n            dtype,\n            self.data[col],\n            dta_version=self._dta_version,\n            force_strl=force_strl,\n        )\n        self.fmtlist.append(fmt)\n        self.typlist.append(\n            _dtype_to_stata_type_117(dtype, self.data[col], force_strl)\n        )",
                "def __init__(\n    self,\n    fname: FilePathOrBuffer,\n    data: DataFrame,\n    convert_dates: Optional[Dict[Label, str]] = None,\n    write_index: bool = True,\n    byteorder: Optional[str] = None,\n    time_stamp: Optional[datetime.datetime] = None,\n    data_label: Optional[str] = None,\n    variable_labels: Optional[Dict[Label, str]] = None,\n    convert_strl: Optional[Sequence[Label]] = None,\n    version: Optional[int] = None,\n):\n    if version is None:\n        version = 118 if data.shape[1] <= 32767 else 119\n    elif version not in (118, 119):\n        raise ValueError(\"version must be either 118 or 119.\")\n    elif version == 118 and data.shape[1] > 32767:\n        raise ValueError(\n            \"You must use version 119 for data sets containing more than\"\n            \"32,767 variables\"\n        )\n\n    super().__init__(\n        fname,\n        data,\n        convert_dates=convert_dates,\n        write_index=write_index,\n        byteorder=byteorder,\n        time_stamp=time_stamp,\n        data_label=data_label,\n        variable_labels=variable_labels,\n        convert_strl=convert_strl,\n    )\n    # Override version set in StataWriter117 init\n    self._dta_version = version",
                "def _validate_variable_name(self, name: str) -> str:\n    \"\"\"\n    Validate variable names for Stata export.\n\n    Parameters\n    ----------\n    name : str\n        Variable name\n\n    Returns\n    -------\n    str\n        The validated name with invalid characters replaced with\n        underscores.\n\n    Notes\n    -----\n    Stata 118+ support most unicode characters. The only limitation is in\n    the ascii range where the characters supported are a-z, A-Z, 0-9 and _.\n    \"\"\"\n    # High code points appear to be acceptable\n    for c in name:\n        if (\n            ord(c) < 128\n            and (c < \"A\" or c > \"Z\")\n            and (c < \"a\" or c > \"z\")\n            and (c < \"0\" or c > \"9\")\n            and c != \"_\"\n        ) or 128 <= ord(c) < 256:\n            name = name.replace(c, \"_\")\n\n    return name",
                "def f(typ: int) -> Union[int, str]:\n    if typ <= 2045:\n        return typ\n    try:\n        return self.TYPE_MAP_XML[typ]\n    except KeyError:\n        raise ValueError(f\"cannot convert stata types [{typ}]\")",
                "def g(typ: int) -> Union[str, np.dtype]:\n    if typ <= 2045:\n        return str(typ)\n    try:\n        return self.DTYPE_MAP_XML[typ]\n    except KeyError:\n        raise ValueError(f\"cannot convert stata dtype [{typ}]\")",
                "def any_startswith(x: str) -> bool:\n    return any(x.startswith(fmt) for fmt in _date_formats)",
                "def f(x: datetime.timedelta) -> float:\n    return US_PER_DAY * x.days + 1000000 * x.seconds + x.microseconds",
                "def g(x: datetime.datetime) -> int:\n    return (x - datetime.datetime(x.year, 1, 1)).days"
            ],
            "inscope_function_signatures": [
                "_stata_elapsed_date_to_datetime_vec(dates, fmt) -> Series",
                "_datetime_to_stata_elapsed_vec(dates: Series, fmt: str) -> Series",
                "_cast_to_stata_types(data: DataFrame) -> DataFrame",
                "read_stata(filepath_or_buffer: FilePathOrBuffer, convert_dates: bool=True, convert_categoricals: bool=True, index_col: Optional[str]=None, convert_missing: bool=False, preserve_dtypes: bool=True, columns: Optional[Sequence[str]]=None, order_categoricals: bool=True, chunksize: Optional[int]=None, iterator: bool=False) -> Union[DataFrame, StataReader]",
                "_open_file_binary_write(fname: FilePathOrBuffer) -> Tuple[BinaryIO, bool]",
                "_set_endianness(endianness: str) -> str",
                "_pad_bytes(name: AnyStr, length: int) -> AnyStr",
                "_convert_datetime_to_stata_type(fmt: str) -> np.dtype",
                "_maybe_convert_to_int_keys(convert_dates: Dict, varlist: List[Label]) -> Dict",
                "_dtype_to_stata_type(dtype: np.dtype, column: Series) -> int",
                "_dtype_to_default_stata_fmt(dtype, column: Series, dta_version: int=114, force_strl: bool=False) -> str",
                "_dtype_to_stata_type_117(dtype: np.dtype, column: Series, force_strl: bool) -> int",
                "_pad_bytes_new(name: Union[str, bytes], length: int) -> bytes",
                "convert_year_month_safe(year, month) -> Series",
                "convert_year_days_safe(year, days) -> Series",
                "convert_delta_safe(base, deltas, unit) -> Series",
                "parse_dates_safe(dates, delta=False, year=False, days=False)",
                "__init__(self, catarray: Series, encoding: str='latin-1')",
                "generate_value_label(self, byteorder: str) -> bytes",
                "__init__(self, value: Union[int, float])",
                "string(self) -> str",
                "value(self) -> Union[int, float]",
                "__str__(self) -> str",
                "__repr__(self) -> str",
                "__eq__(self, other: Any) -> bool",
                "get_base_missing_value(cls, dtype: np.dtype) -> Union[int, float]",
                "__init__(self)",
                "__init__(self, path_or_buf: FilePathOrBuffer, convert_dates: bool=True, convert_categoricals: bool=True, index_col: Optional[str]=None, convert_missing: bool=False, preserve_dtypes: bool=True, columns: Optional[Sequence[str]]=None, order_categoricals: bool=True, chunksize: Optional[int]=None)",
                "__enter__(self) -> 'StataReader'",
                "__exit__(self, exc_type, exc_value, traceback) -> None",
                "close(self) -> None",
                "_set_encoding(self) -> None",
                "_read_header(self) -> None",
                "_read_new_header(self) -> None",
                "_get_dtypes(self, seek_vartypes: int) -> Tuple[List[Union[int, str]], List[Union[int, np.dtype]]]",
                "_get_varlist(self) -> List[str]",
                "_get_fmtlist(self) -> List[str]",
                "_get_lbllist(self) -> List[str]",
                "_get_variable_labels(self) -> List[str]",
                "_get_nobs(self) -> int",
                "_get_data_label(self) -> str",
                "_get_time_stamp(self) -> str",
                "_get_seek_variable_labels(self) -> int",
                "_read_old_header(self, first_char: bytes) -> None",
                "_setup_dtype(self) -> np.dtype",
                "_calcsize(self, fmt: Union[int, str]) -> int",
                "_decode(self, s: bytes) -> str",
                "_read_value_labels(self) -> None",
                "_read_strls(self) -> None",
                "__next__(self) -> DataFrame",
                "get_chunk(self, size: Optional[int]=None) -> DataFrame",
                "read(self, nrows: Optional[int]=None, convert_dates: Optional[bool]=None, convert_categoricals: Optional[bool]=None, index_col: Optional[str]=None, convert_missing: Optional[bool]=None, preserve_dtypes: Optional[bool]=None, columns: Optional[Sequence[str]]=None, order_categoricals: Optional[bool]=None) -> DataFrame",
                "_do_convert_missing(self, data: DataFrame, convert_missing: bool) -> DataFrame",
                "_insert_strls(self, data: DataFrame) -> DataFrame",
                "_do_select_columns(self, data: DataFrame, columns: Sequence[str]) -> DataFrame",
                "_do_convert_categoricals(data: DataFrame, value_label_dict: Dict[str, Dict[Union[float, int], str]], lbllist: Sequence[str], order_categoricals: bool) -> DataFrame",
                "data_label(self) -> str",
                "variable_labels(self) -> Dict[str, str]",
                "value_labels(self) -> Dict[str, Dict[Union[float, int], str]]",
                "__init__(self, fname: FilePathOrBuffer, data: DataFrame, convert_dates: Optional[Dict[Label, str]]=None, write_index: bool=True, byteorder: Optional[str]=None, time_stamp: Optional[datetime.datetime]=None, data_label: Optional[str]=None, variable_labels: Optional[Dict[Label, str]]=None)",
                "_write(self, to_write: str) -> None",
                "_write_bytes(self, value: bytes) -> None",
                "_prepare_categoricals(self, data: DataFrame) -> DataFrame",
                "_replace_nans(self, data: DataFrame) -> DataFrame",
                "_update_strl_names(self) -> None",
                "_validate_variable_name(self, name: str) -> str",
                "_check_column_names(self, data: DataFrame) -> DataFrame",
                "_set_formats_and_types(self, dtypes: Series) -> None",
                "_prepare_pandas(self, data: DataFrame) -> None",
                "_encode_strings(self) -> None",
                "write_file(self) -> None",
                "_close(self) -> None",
                "_write_map(self) -> None",
                "_write_file_close_tag(self) -> None",
                "_write_characteristics(self) -> None",
                "_write_strls(self) -> None",
                "_write_expansion_fields(self) -> None",
                "_write_value_labels(self) -> None",
                "_write_header(self, data_label: Optional[str]=None, time_stamp: Optional[datetime.datetime]=None) -> None",
                "_write_variable_types(self) -> None",
                "_write_varnames(self) -> None",
                "_write_sortlist(self) -> None",
                "_write_formats(self) -> None",
                "_write_value_label_names(self) -> None",
                "_write_variable_labels(self) -> None",
                "_convert_strls(self, data: DataFrame) -> DataFrame",
                "_prepare_data(self) -> np.recarray",
                "_write_data(self, records: np.recarray) -> None",
                "_null_terminate_str(s: str) -> str",
                "_null_terminate_bytes(self, s: str) -> bytes",
                "__init__(self, df: DataFrame, columns: Sequence[str], version: int=117, byteorder: Optional[str]=None)",
                "_convert_key(self, key: Tuple[int, int]) -> int",
                "generate_table(self) -> Tuple[Dict[str, Tuple[int, int]], DataFrame]",
                "generate_blob(self, gso_table: Dict[str, Tuple[int, int]]) -> bytes",
                "__init__(self, fname: FilePathOrBuffer, data: DataFrame, convert_dates: Optional[Dict[Label, str]]=None, write_index: bool=True, byteorder: Optional[str]=None, time_stamp: Optional[datetime.datetime]=None, data_label: Optional[str]=None, variable_labels: Optional[Dict[Label, str]]=None, convert_strl: Optional[Sequence[Label]]=None)",
                "_tag(val: Union[str, bytes], tag: str) -> bytes",
                "_update_map(self, tag: str) -> None",
                "_write_header(self, data_label: Optional[str]=None, time_stamp: Optional[datetime.datetime]=None) -> None",
                "_write_map(self) -> None",
                "_write_variable_types(self) -> None",
                "_write_varnames(self) -> None",
                "_write_sortlist(self) -> None",
                "_write_formats(self) -> None",
                "_write_value_label_names(self) -> None",
                "_write_variable_labels(self) -> None",
                "_write_characteristics(self) -> None",
                "_write_data(self, records) -> None",
                "_write_strls(self) -> None",
                "_write_expansion_fields(self) -> None",
                "_write_value_labels(self) -> None",
                "_write_file_close_tag(self) -> None",
                "_update_strl_names(self) -> None",
                "_convert_strls(self, data: DataFrame) -> DataFrame",
                "_set_formats_and_types(self, dtypes: Series) -> None",
                "__init__(self, fname: FilePathOrBuffer, data: DataFrame, convert_dates: Optional[Dict[Label, str]]=None, write_index: bool=True, byteorder: Optional[str]=None, time_stamp: Optional[datetime.datetime]=None, data_label: Optional[str]=None, variable_labels: Optional[Dict[Label, str]]=None, convert_strl: Optional[Sequence[Label]]=None, version: Optional[int]=None)",
                "_validate_variable_name(self, name: str) -> str",
                "f(typ: int) -> Union[int, str]",
                "g(typ: int) -> Union[str, np.dtype]",
                "any_startswith(x: str) -> bool",
                "f(x: datetime.timedelta) -> float",
                "g(x: datetime.datetime) -> int"
            ],
            "variables_in_file": {
                "_version_error": [
                    52,
                    1076,
                    1268
                ],
                "_statafile_processing_params1": [
                    107,
                    59,
                    141,
                    159
                ],
                "_statafile_processing_params2": [
                    160,
                    65,
                    108,
                    142
                ],
                "_chunksize_params": [
                    161,
                    83,
                    109
                ],
                "_iterator_params": [
                    88,
                    110
                ],
                "_read_stata_doc": [
                    92,
                    1821
                ],
                "_read_method_doc": [
                    1493,
                    134
                ],
                "_stata_reader_doc": [
                    981,
                    149
                ],
                "_date_formats": [
                    1620,
                    165
                ],
                "stata_epoch": [
                    320,
                    417,
                    290,
                    356,
                    420,
                    423,
                    168,
                    426,
                    302,
                    402,
                    371,
                    308,
                    404,
                    312,
                    316
                ],
                "datetime.datetime": [
                    384,
                    385,
                    3008,
                    2468,
                    2494,
                    2981,
                    3321,
                    168,
                    238,
                    2094,
                    2943,
                    3007,
                    251,
                    221,
                    222,
                    2493
                ],
                "datetime": [
                    384,
                    385,
                    3008,
                    2468,
                    2494,
                    2981,
                    3321,
                    168,
                    238,
                    2094,
                    373,
                    2943,
                    3007,
                    251,
                    221,
                    222,
                    2493
                ],
                "MIN_YEAR": [
                    233,
                    220,
                    246
                ],
                "MAX_YEAR": [
                    233,
                    220,
                    246
                ],
                "Timestamp.min.year": [
                    220
                ],
                "Timestamp.min": [
                    220,
                    222
                ],
                "Timestamp": [
                    220,
                    221,
                    222
                ],
                "Timestamp.max.year": [
                    220
                ],
                "Timestamp.max": [
                    220,
                    221
                ],
                "MAX_DAY_DELTA": [
                    224,
                    264,
                    221
                ],
                "days": [
                    385,
                    382,
                    358,
                    363,
                    303,
                    304,
                    309,
                    310,
                    247,
                    252,
                    221,
                    222
                ],
                "MIN_DAY_DELTA": [
                    264,
                    222,
                    223
                ],
                "MIN_MS_DELTA": [
                    268,
                    223
                ],
                "MAX_MS_DELTA": [
                    224,
                    268
                ],
                "year.max": [
                    233,
                    246
                ],
                "year": [
                    308,
                    310,
                    312,
                    314,
                    316,
                    318,
                    320,
                    322,
                    324,
                    326,
                    358,
                    233,
                    234,
                    236,
                    238,
                    246,
                    247,
                    249,
                    378,
                    252
                ],
                "year.min": [
                    233,
                    246
                ],
                "to_datetime": [
                    234,
                    364,
                    402,
                    275,
                    247
                ],
                "month": [
                    321,
                    322,
                    234,
                    238,
                    2512,
                    3025,
                    313,
                    314
                ],
                "index": [
                    262,
                    266,
                    395,
                    236,
                    238,
                    398,
                    272,
                    437,
                    249,
                    348,
                    254
                ],
                "getattr": [
                    249,
                    236,
                    262,
                    2361
                ],
                "Series": [
                    256,
                    266,
                    3211,
                    1676,
                    272,
                    400,
                    1938,
                    1686,
                    285,
                    296,
                    174,
                    433,
                    437,
                    1975,
                    2626,
                    1607,
                    584,
                    336,
                    226,
                    1764,
                    237,
                    241,
                    2289,
                    1781,
                    254
                ],
                "y": [
                    251,
                    252,
                    238
                ],
                "m": [
                    238
                ],
                "zip": [
                    835,
                    1804,
                    238,
                    591,
                    1588,
                    1751,
                    252,
                    2270,
                    2142
                ],
                "to_timedelta": [
                    276,
                    247
                ],
                "value": [
                    671,
                    672,
                    802,
                    804,
                    806,
                    551,
                    552,
                    808,
                    810,
                    557,
                    813,
                    560,
                    562,
                    2128,
                    757,
                    759,
                    760,
                    250,
                    254
                ],
                "relativedelta": [
                    265,
                    251,
                    270
                ],
                "int": [
                    384,
                    1158,
                    775,
                    265,
                    1932,
                    270,
                    1806,
                    1168,
                    1938,
                    2963,
                    2710,
                    800,
                    1831,
                    1066,
                    2348,
                    1074,
                    2739,
                    1589,
                    1975,
                    2743,
                    2626,
                    1476,
                    1223,
                    1742,
                    594,
                    595,
                    1366,
                    1367,
                    1496,
                    3325,
                    993,
                    1890,
                    996,
                    1253,
                    2795,
                    2668,
                    1395,
                    756,
                    2291,
                    759,
                    251,
                    1149,
                    1150
                ],
                "d": [
                    388,
                    265,
                    395,
                    270,
                    407,
                    408,
                    413,
                    414,
                    416,
                    417,
                    419,
                    420,
                    422,
                    423,
                    425,
                    426,
                    428,
                    429,
                    353,
                    357,
                    361,
                    362,
                    365,
                    367,
                    252,
                    377,
                    251,
                    380,
                    381
                ],
                "deltas": [
                    262,
                    264,
                    265,
                    268,
                    270,
                    276,
                    277
                ],
                "unit": [
                    267,
                    276,
                    263
                ],
                "deltas.max": [
                    264,
                    268
                ],
                "deltas.min": [
                    264,
                    268
                ],
                "values": [
                    2152,
                    265,
                    266,
                    2155,
                    269,
                    272,
                    2162,
                    2165,
                    2166
                ],
                "base": [
                    290,
                    292,
                    265,
                    270,
                    302,
                    304,
                    275,
                    277
                ],
                "ValueError": [
                    3330,
                    3332,
                    390,
                    2567,
                    2570,
                    1164,
                    1933,
                    274,
                    1298,
                    1300,
                    1174,
                    1303,
                    1305,
                    2714,
                    553,
                    812,
                    431,
                    1583,
                    561,
                    1711,
                    1715,
                    1076,
                    2495,
                    3009,
                    3138,
                    2372,
                    3142,
                    328,
                    587,
                    2005,
                    1629,
                    1887,
                    1251,
                    1763,
                    2148,
                    616,
                    1263,
                    1779,
                    1268
                ],
                "bad_locs": [
                    298,
                    331,
                    281,
                    283,
                    286
                ],
                "np.isnan": [
                    281
                ],
                "np": [
                    512,
                    513,
                    514,
                    515,
                    526,
                    1553,
                    530,
                    2582,
                    537,
                    539,
                    540,
                    542,
                    543,
                    545,
                    547,
                    550,
                    552,
                    1577,
                    557,
                    558,
                    559,
                    2614,
                    1594,
                    2112,
                    2626,
                    1604,
                    591,
                    1622,
                    2646,
                    2654,
                    2656,
                    2658,
                    2147,
                    2660,
                    2662,
                    1643,
                    1644,
                    2156,
                    622,
                    623,
                    1646,
                    1647,
                    2157,
                    2158,
                    2159,
                    2161,
                    2162,
                    1150,
                    2177,
                    2178,
                    1668,
                    1674,
                    1675,
                    1676,
                    1168,
                    1684,
                    1685,
                    1687,
                    2778,
                    1288,
                    281,
                    287,
                    800,
                    801,
                    2338,
                    803,
                    805,
                    807,
                    296,
                    809,
                    2368,
                    325,
                    837,
                    838,
                    839,
                    840,
                    841,
                    1351,
                    846,
                    847,
                    848,
                    849,
                    850,
                    851,
                    1362,
                    357,
                    1899,
                    364,
                    366,
                    878,
                    879,
                    882,
                    883,
                    376,
                    1919,
                    387,
                    901,
                    902,
                    1424,
                    1938,
                    1427,
                    1430,
                    1955,
                    1960,
                    426,
                    1962,
                    1964,
                    1966,
                    1968,
                    433,
                    1999,
                    2007,
                    2009,
                    2011,
                    2013
                ],
                "dates": [
                    388,
                    397,
                    398,
                    400,
                    401,
                    402,
                    404,
                    407,
                    281,
                    411,
                    285,
                    413,
                    287,
                    416,
                    291,
                    419,
                    422,
                    296,
                    425,
                    428,
                    303,
                    308,
                    309,
                    312,
                    313,
                    316,
                    317,
                    320,
                    321,
                    324,
                    325,
                    348,
                    354,
                    356,
                    360,
                    364,
                    369,
                    371,
                    379
                ],
                "has_bad_values": [
                    297,
                    282,
                    284,
                    330
                ],
                "bad_locs.any": [
                    283
                ],
                "data_col": [
                    285,
                    286
                ],
                "dates.astype": [
                    364,
                    287
                ],
                "np.int64": [
                    515,
                    2147,
                    357,
                    364,
                    543,
                    366,
                    1647,
                    287
                ],
                "fmt.startswith": [
                    289,
                    323,
                    293,
                    301,
                    307,
                    311,
                    315,
                    319
                ],
                "fmt": [
                    1921,
                    1666,
                    3216,
                    406,
                    3222,
                    409,
                    3098,
                    3099,
                    412,
                    415,
                    289,
                    418,
                    293,
                    421,
                    424,
                    427,
                    301,
                    431,
                    307,
                    311,
                    315,
                    319,
                    323,
                    328,
                    1620,
                    1367,
                    1368,
                    1369,
                    2539,
                    2540,
                    1903,
                    1662,
                    1663
                ],
                "ms": [
                    291,
                    292
                ],
                "conv_dates": [
                    408,
                    411,
                    414,
                    417,
                    292,
                    420,
                    423,
                    296,
                    298,
                    299,
                    426,
                    429,
                    304,
                    433,
                    435,
                    437,
                    310,
                    314,
                    318,
                    322,
                    326,
                    331,
                    333
                ],
                "convert_delta_safe": [
                    304,
                    292
                ],
                "warnings.warn": [
                    295,
                    1385,
                    2282,
                    2414,
                    567,
                    410,
                    604
                ],
                "warnings": [
                    295,
                    1385,
                    2282,
                    2414,
                    567,
                    410,
                    604
                ],
                "np.object": [
                    296,
                    1676
                ],
                "NaT": [
                    298,
                    331
                ],
                "stata_epoch.year": [
                    320,
                    417,
                    420,
                    423,
                    426,
                    308,
                    312,
                    316
                ],
                "convert_year_days_safe": [
                    310
                ],
                "convert_year_month_safe": [
                    326,
                    314,
                    322,
                    318
                ],
                "quarter_month": [
                    317,
                    318
                ],
                "first_month": [
                    325,
                    326
                ],
                "np.ones_like": [
                    325
                ],
                "str": [
                    1025,
                    2091,
                    2093,
                    2095,
                    2096,
                    2618,
                    2622,
                    2113,
                    2116,
                    584,
                    1619,
                    602,
                    603,
                    2668,
                    2672,
                    628,
                    1150,
                    1158,
                    650,
                    2190,
                    1168,
                    1170,
                    2709,
                    2711,
                    1180,
                    1186,
                    1703,
                    1706,
                    1199,
                    2743,
                    1208,
                    2233,
                    2240,
                    2241,
                    1229,
                    1742,
                    1743,
                    720,
                    2259,
                    1241,
                    2795,
                    2290,
                    3318,
                    3320,
                    3322,
                    763,
                    3323,
                    1789,
                    1795,
                    1806,
                    786,
                    1299,
                    789,
                    3351,
                    1304,
                    1826,
                    1829,
                    835,
                    2380,
                    1359,
                    336,
                    1361,
                    1875,
                    1366,
                    1881,
                    1371,
                    1899,
                    2411,
                    1395,
                    2940,
                    2942,
                    2944,
                    2945,
                    2963,
                    2967,
                    2969,
                    2973,
                    2467,
                    2980,
                    2988,
                    1976,
                    1469,
                    1471,
                    2006,
                    1499,
                    988,
                    1502,
                    991,
                    1022
                ],
                "dates.index": [
                    348,
                    398
                ],
                "NS_PER_DAY": [
                    349,
                    350,
                    367
                ],
                "US_PER_DAY": [
                    374,
                    414,
                    350
                ],
                "is_datetime64_dtype": [
                    401,
                    354,
                    2330
                ],
                "dates.values": [
                    354,
                    371
                ],
                "delta": [
                    371,
                    377,
                    370,
                    355
                ],
                "time_delta": [
                    356,
                    357
                ],
                "time_delta.values.astype": [
                    357
                ],
                "time_delta.values": [
                    357
                ],
                "date_index": [
                    360,
                    361,
                    362
                ],
                "DatetimeIndex": [
                    360
                ],
                "date_index.year": [
                    361
                ],
                "date_index.month": [
                    362
                ],
                "days_in_ns": [
                    364,
                    367
                ],
                "astype": [
                    545,
                    547,
                    426,
                    364,
                    2605,
                    558,
                    1649,
                    534,
                    539,
                    542
                ],
                "infer_dtype": [
                    2369,
                    369
                ],
                "datetime.timedelta": [
                    373
                ],
                "x.days": [
                    374
                ],
                "x": [
                    385,
                    1304,
                    1066,
                    1166,
                    592,
                    1299,
                    1620,
                    374,
                    1622,
                    1176,
                    379
                ],
                "x.seconds": [
                    374
                ],
                "x.microseconds": [
                    374
                ],
                "float": [
                    800,
                    775,
                    1742,
                    1806,
                    720,
                    1395,
                    756,
                    373,
                    759
                ],
                "v": [
                    387,
                    388,
                    2787,
                    2840,
                    2834,
                    2740,
                    2741,
                    376,
                    377,
                    2780
                ],
                "np.vectorize": [
                    376,
                    387
                ],
                "f": [
                    376,
                    1166
                ],
                "year_month": [
                    379,
                    380,
                    381
                ],
                "dates.apply": [
                    379
                ],
                "x.year": [
                    385,
                    379
                ],
                "x.month": [
                    379
                ],
                "year_month.values": [
                    380,
                    381
                ],
                "g": [
                    1176,
                    387
                ],
                "DataFrame": [
                    2304,
                    395,
                    2578,
                    2708,
                    1691,
                    1696,
                    1569,
                    2169,
                    1571,
                    1833,
                    1706,
                    2090,
                    2220,
                    2743,
                    1473,
                    2939,
                    1476,
                    3195,
                    1612,
                    1741,
                    1745,
                    2130,
                    1504,
                    484,
                    1512,
                    1651,
                    3317,
                    2296,
                    1785,
                    1658,
                    2171
                ],
                "bad_loc": [
                    397,
                    399,
                    402,
                    435,
                    404
                ],
                "isna": [
                    397
                ],
                "bad_loc.any": [
                    399
                ],
                "parse_dates_safe": [
                    416,
                    419,
                    422,
                    425,
                    428,
                    407,
                    413
                ],
                "d.delta": [
                    408,
                    414
                ],
                "d.year": [
                    417,
                    420,
                    423,
                    426,
                    429
                ],
                "d.days": [
                    417
                ],
                "d.month": [
                    426,
                    420,
                    423
                ],
                "np.int": [
                    426
                ],
                "np.float64": [
                    2177,
                    902,
                    530,
                    1684,
                    1685,
                    547,
                    550,
                    1960,
                    809,
                    558,
                    559,
                    433,
                    841,
                    847,
                    2007,
                    2654,
                    1644,
                    2161,
                    882,
                    883,
                    1919
                ],
                "missing_value": [
                    1681,
                    434,
                    435,
                    1678
                ],
                "struct.unpack": [
                    1154,
                    901,
                    518,
                    519,
                    903,
                    1422,
                    1423,
                    1315,
                    1061,
                    1451,
                    434,
                    1333,
                    1461,
                    1462,
                    1463,
                    1337,
                    1083,
                    1341,
                    1225,
                    1098,
                    1227,
                    1101,
                    1231,
                    1104,
                    1234,
                    1107,
                    1110,
                    729,
                    731,
                    1243,
                    1118,
                    735,
                    1246,
                    1121,
                    739,
                    1124,
                    741,
                    745,
                    1133,
                    878,
                    879,
                    752,
                    753,
                    882,
                    883,
                    1261,
                    1266,
                    1271,
                    1273,
                    1276
                ],
                "struct": [
                    3073,
                    1154,
                    901,
                    518,
                    647,
                    519,
                    903,
                    2826,
                    2827,
                    1422,
                    1423,
                    657,
                    661,
                    664,
                    2840,
                    2843,
                    668,
                    672,
                    2850,
                    1315,
                    1061,
                    2472,
                    1451,
                    2480,
                    2993,
                    434,
                    2482,
                    2996,
                    1333,
                    1461,
                    1462,
                    1463,
                    1337,
                    3001,
                    1083,
                    1341,
                    3065,
                    1225,
                    1098,
                    1227,
                    1101,
                    1231,
                    1104,
                    1234,
                    1107,
                    1110,
                    729,
                    1369,
                    731,
                    1243,
                    2522,
                    1118,
                    735,
                    736,
                    1121,
                    1246,
                    739,
                    1124,
                    741,
                    745,
                    746,
                    1133,
                    878,
                    879,
                    752,
                    753,
                    882,
                    883,
                    1261,
                    1266,
                    1271,
                    1273,
                    1276
                ],
                "excessive_string_length_error": [
                    440,
                    2005
                ],
                "Warning": [
                    457,
                    468,
                    447
                ],
                "precision_loss_doc": [
                    451,
                    532,
                    549
                ],
                "value_label_mismatch_doc": [
                    605,
                    461
                ],
                "invalid_name_doc": [
                    472,
                    2281
                ],
                "ws": [
                    549,
                    2281,
                    2282,
                    532,
                    566,
                    567,
                    509
                ],
                "conversion_data": [
                    524,
                    511
                ],
                "np.bool": [
                    512
                ],
                "np.int8": [
                    512,
                    513,
                    801,
                    2112,
                    837,
                    2662,
                    2156,
                    1646,
                    1968,
                    851,
                    537,
                    2013
                ],
                "np.uint8": [
                    1288,
                    513,
                    846
                ],
                "np.int16": [
                    2112,
                    513,
                    514,
                    803,
                    2660,
                    838,
                    2157,
                    1646,
                    1966,
                    2158,
                    850,
                    539,
                    540,
                    2013
                ],
                "np.uint16": [
                    514
                ],
                "np.int32": [
                    2112,
                    545,
                    514,
                    515,
                    2658,
                    805,
                    839,
                    1964,
                    622,
                    623,
                    1646,
                    849,
                    2159,
                    2011,
                    542
                ],
                "np.uint32": [
                    515
                ],
                "float32_max": [
                    870,
                    557,
                    518,
                    879
                ],
                "float64_max": [
                    519,
                    872,
                    560,
                    883,
                    563
                ],
                "col": [
                    2563,
                    2564,
                    2565,
                    521,
                    522,
                    526,
                    531,
                    534,
                    538,
                    539,
                    2588,
                    541,
                    542,
                    2590,
                    544,
                    545,
                    2591,
                    547,
                    548,
                    551,
                    2599,
                    554,
                    2602,
                    2604,
                    2605,
                    558,
                    2607,
                    562,
                    2610,
                    1588,
                    1590,
                    3134,
                    3135,
                    3136,
                    1602,
                    1603,
                    1607,
                    1610,
                    2134,
                    1624,
                    1626,
                    1627,
                    2142,
                    2144,
                    2146,
                    2152,
                    1641,
                    1642,
                    1649,
                    2166,
                    2168,
                    3199,
                    3200,
                    3201,
                    3214,
                    3215,
                    3218,
                    3224,
                    1724,
                    1725,
                    1751,
                    2777,
                    1754,
                    2780,
                    2781,
                    2790,
                    2791,
                    1769,
                    2292,
                    2293,
                    1782,
                    2294,
                    1784,
                    2327,
                    2328,
                    2330,
                    2331,
                    2362,
                    2364,
                    2366,
                    2371,
                    2374,
                    2380,
                    2386
                ],
                "data": [
                    521,
                    522,
                    526,
                    1553,
                    531,
                    2580,
                    534,
                    2583,
                    538,
                    1563,
                    539,
                    541,
                    542,
                    2588,
                    544,
                    545,
                    1568,
                    547,
                    548,
                    1569,
                    1571,
                    551,
                    1572,
                    2594,
                    1578,
                    2599,
                    2602,
                    2605,
                    558,
                    1582,
                    2607,
                    1588,
                    2612,
                    1590,
                    1592,
                    569,
                    2106,
                    1597,
                    1602,
                    1603,
                    1607,
                    1610,
                    1612,
                    1615,
                    2134,
                    1624,
                    1626,
                    1627,
                    2138,
                    2142,
                    2144,
                    1634,
                    1635,
                    2146,
                    2152,
                    1641,
                    1642,
                    1649,
                    1651,
                    1654,
                    2168,
                    1656,
                    1661,
                    2175,
                    2176,
                    3200,
                    1667,
                    3205,
                    2182,
                    3207,
                    2184,
                    3209,
                    1690,
                    1692,
                    1693,
                    1694,
                    1698,
                    1703,
                    1704,
                    1712,
                    2234,
                    1725,
                    1737,
                    1751,
                    1754,
                    2266,
                    2590,
                    2591,
                    2287,
                    1781,
                    1784,
                    1785,
                    1786,
                    2300,
                    2303,
                    3328,
                    2305,
                    3331,
                    2308,
                    2312,
                    2315,
                    3339,
                    2318,
                    2320,
                    2321,
                    2322,
                    2324,
                    2327,
                    2330,
                    1851,
                    1854,
                    2955
                ],
                "dtype": [
                    1539,
                    1540,
                    1541,
                    522,
                    525,
                    1550,
                    527,
                    529,
                    1554,
                    534,
                    537,
                    540,
                    543,
                    550,
                    557,
                    559,
                    2607,
                    2609,
                    2610,
                    1603,
                    1604,
                    2646,
                    2654,
                    2656,
                    2146,
                    2147,
                    2658,
                    2660,
                    2662,
                    2665,
                    1642,
                    1643,
                    1644,
                    2155,
                    1646,
                    1647,
                    2156,
                    1649,
                    2157,
                    2158,
                    2159,
                    2161,
                    2162,
                    2165,
                    2176,
                    2177,
                    2178,
                    3214,
                    3217,
                    1683,
                    1684,
                    1685,
                    1686,
                    3224,
                    2292,
                    2293,
                    2294,
                    801,
                    803,
                    805,
                    807,
                    809,
                    2367,
                    2368,
                    1955,
                    1960,
                    1962,
                    1964,
                    1966,
                    1968,
                    1971,
                    1999,
                    2007,
                    2009,
                    2011,
                    2013,
                    2016
                ],
                "c_data": [
                    524,
                    525,
                    526,
                    527,
                    529,
                    530
                ],
                "max": [
                    544,
                    548,
                    551,
                    1959,
                    526,
                    531,
                    2650,
                    2006,
                    538,
                    541
                ],
                "np.iinfo": [
                    526
                ],
                "precision_loss_doc.format": [
                    532,
                    549
                ],
                "min": [
                    544,
                    548,
                    1542,
                    2253,
                    1552,
                    2260,
                    538,
                    541
                ],
                "np.float32": [
                    2656,
                    2177,
                    2178,
                    901,
                    550,
                    807,
                    840,
                    1962,
                    1643,
                    557,
                    878,
                    879,
                    848,
                    1684,
                    2009
                ],
                "np.isinf": [
                    552
                ],
                "PossiblePrecisionLoss": [
                    567
                ],
                "encoding": [
                    608,
                    642,
                    1379,
                    1381,
                    586,
                    650,
                    651,
                    589,
                    1023
                ],
                "self.labname": [
                    650,
                    588
                ],
                "self": [
                    2099,
                    2100,
                    2101,
                    2102,
                    2103,
                    2104,
                    2106,
                    2110,
                    2111,
                    2112,
                    2113,
                    2114,
                    2120,
                    2121,
                    2127,
                    2128,
                    2135,
                    2136,
                    2144,
                    2145,
                    2179,
                    2181,
                    2243,
                    2246,
                    2269,
                    2272,
                    2273,
                    2284,
                    2285,
                    2290,
                    2291,
                    2293,
                    2294,
                    2302,
                    2308,
                    2315,
                    2318,
                    2320,
                    2321,
                    2322,
                    2328,
                    2331,
                    2333,
                    2334,
                    2336,
                    2337,
                    2341,
                    2343,
                    2346,
                    2347,
                    2349,
                    2359,
                    2361,
                    2362,
                    2366,
                    2380,
                    2384,
                    2386,
                    2389,
                    2391,
                    2392,
                    2393,
                    2394,
                    2395,
                    2396,
                    2397,
                    2398,
                    2399,
                    2400,
                    2401,
                    2402,
                    2403,
                    2404,
                    2405,
                    2406,
                    2408,
                    2409,
                    2411,
                    2412,
                    2415,
                    2421,
                    2433,
                    2435,
                    2438,
                    2439,
                    2459,
                    2462,
                    2463,
                    2470,
                    2472,
                    2474,
                    2476,
                    2478,
                    2480,
                    2482,
                    2485,
                    2487,
                    2488,
                    2518,
                    2521,
                    2522,
                    2527,
                    2528,
                    2530,
                    2534,
                    2535,
                    2539,
                    2540,
                    2544,
                    2546,
                    2547,
                    2548,
                    2550,
                    2552,
                    2558,
                    2559,
                    2560,
                    2563,
                    2564,
                    2565,
                    2574,
                    2576,
                    2583,
                    2584,
                    2585,
                    2587,
                    2591,
                    2594,
                    2598,
                    2601,
                    2609,
                    2615,
                    2623,
                    588,
                    589,
                    591,
                    592,
                    593,
                    594,
                    595,
                    596,
                    597,
                    600,
                    609,
                    610,
                    611,
                    612,
                    613,
                    615,
                    622,
                    623,
                    626,
                    642,
                    647,
                    650,
                    661,
                    664,
                    667,
                    2715,
                    2717,
                    2718,
                    671,
                    2719,
                    2722,
                    675,
                    2726,
                    2730,
                    2735,
                    2736,
                    2737,
                    2741,
                    2773,
                    2774,
                    2776,
                    2777,
                    2789,
                    2790,
                    757,
                    760,
                    772,
                    2826,
                    2827,
                    2828,
                    2829,
                    2830,
                    784,
                    787,
                    790,
                    794,
                    795,
                    796,
                    834,
                    844,
                    854,
                    855,
                    873,
                    887,
                    897,
                    2949,
                    2951,
                    906,
                    2963,
                    916,
                    2964,
                    2975,
                    2976,
                    2984,
                    2985,
                    2988,
                    2990,
                    2992,
                    2993,
                    2995,
                    2996,
                    2999,
                    3000,
                    3003,
                    3033,
                    3035,
                    3041,
                    3042,
                    3043,
                    996,
                    3046,
                    1000,
                    1001,
                    1002,
                    1003,
                    1004,
                    1005,
                    1006,
                    1007,
                    1008,
                    1011,
                    1012,
                    1013,
                    1014,
                    1015,
                    1016,
                    1017,
                    1018,
                    3062,
                    1020,
                    3064,
                    3065,
                    3067,
                    3070,
                    3072,
                    1026,
                    3073,
                    3075,
                    1030,
                    3078,
                    1032,
                    1033,
                    3081,
                    3082,
                    3083,
                    1037,
                    3084,
                    3087,
                    1041,
                    3090,
                    3091,
                    3092,
                    1046,
                    3095,
                    3097,
                    3098,
                    3099,
                    3101,
                    1054,
                    1055,
                    3104,
                    1057,
                    3107,
                    1060,
                    3108,
                    1062,
                    3111,
                    1064,
                    3112,
                    1066,
                    3113,
                    3114,
                    1069,
                    3117,
                    1073,
                    1074,
                    1075,
                    1076,
                    1077,
                    1078,
                    1079,
                    1080,
                    1081,
                    1082,
                    1083,
                    1084,
                    3124,
                    1086,
                    3127,
                    1088,
                    1089,
                    1090,
                    1091,
                    1092,
                    1093,
                    1094,
                    1095,
                    3135,
                    1097,
                    1098,
                    3140,
                    1100,
                    1101,
                    3144,
                    1103,
                    1104,
                    3151,
                    1106,
                    1107,
                    3154,
                    1109,
                    1110,
                    3155,
                    3158,
                    3159,
                    1114,
                    3160,
                    1116,
                    1117,
                    1118,
                    3161,
                    1120,
                    1121,
                    3164,
                    1123,
                    1124,
                    3165,
                    3172,
                    1127,
                    3174,
                    1129,
                    1130,
                    3175,
                    1132,
                    1133,
                    1134,
                    1135,
                    3176,
                    3179,
                    1138,
                    1139,
                    3182,
                    1141,
                    1142,
                    3183,
                    1144,
                    1145,
                    3190,
                    3191,
                    3192,
                    3193,
                    1152,
                    3201,
                    1154,
                    1155,
                    3205,
                    3208,
                    1162,
                    3212,
                    3213,
                    3215,
                    3218,
                    3219,
                    1172,
                    3222,
                    3223,
                    3224,
                    1182,
                    1183,
                    1187,
                    1189,
                    1191,
                    1196,
                    1200,
                    1202,
                    1206,
                    1209,
                    1211,
                    1213,
                    1215,
                    1219,
                    1224,
                    1225,
                    1227,
                    1230,
                    1231,
                    1232,
                    1233,
                    1234,
                    1235,
                    1236,
                    1237,
                    1239,
                    1242,
                    1243,
                    1244,
                    1245,
                    1246,
                    1247,
                    1248,
                    1249,
                    1254,
                    1255,
                    1259,
                    1260,
                    1261,
                    1266,
                    1267,
                    1268,
                    1269,
                    1270,
                    1271,
                    1273,
                    1274,
                    1276,
                    1277,
                    1279,
                    1281,
                    1284,
                    1285,
                    1287,
                    1291,
                    1292,
                    1297,
                    3349,
                    1302,
                    1307,
                    1308,
                    1309,
                    1312,
                    1313,
                    1315,
                    1316,
                    1317,
                    1320,
                    1322,
                    1324,
                    1331,
                    1334,
                    1336,
                    1338,
                    1342,
                    1346,
                    1349,
                    1353,
                    1354,
                    1357,
                    1358,
                    1359,
                    1362,
                    1364,
                    3121,
                    1369,
                    1375,
                    1379,
                    1389,
                    1392,
                    1394,
                    1395,
                    1398,
                    1399,
                    1401,
                    1402,
                    1403,
                    3128,
                    1405,
                    1406,
                    1409,
                    1410,
                    1413,
                    1416,
                    1417,
                    3131,
                    1419,
                    1420,
                    1422,
                    1423,
                    1425,
                    1428,
                    3134,
                    1433,
                    1434,
                    1437,
                    1438,
                    1439,
                    1440,
                    1443,
                    3136,
                    1445,
                    1447,
                    1450,
                    1451,
                    1453,
                    1455,
                    1456,
                    1462,
                    1463,
                    1464,
                    1466,
                    1471,
                    1474,
                    1490,
                    1491,
                    1508,
                    1509,
                    1510,
                    1511,
                    1512,
                    1516,
                    1518,
                    1520,
                    1522,
                    1524,
                    1526,
                    1528,
                    1531,
                    1533,
                    1534,
                    1535,
                    1538,
                    1539,
                    1540,
                    1547,
                    1548,
                    1550,
                    1551,
                    1552,
                    1554,
                    1557,
                    1558,
                    1559,
                    1560,
                    1562,
                    1566,
                    1569,
                    1572,
                    1577,
                    1582,
                    1584,
                    1588,
                    1590,
                    1592,
                    1594,
                    1601,
                    1604,
                    1607,
                    1615,
                    1622,
                    1627,
                    1630,
                    1633,
                    1634,
                    1635,
                    1662,
                    1663,
                    1666,
                    3184,
                    1697,
                    1699,
                    1703,
                    1708,
                    1726,
                    1727,
                    1728,
                    1729,
                    1731,
                    1732,
                    1733,
                    1734,
                    1735,
                    1793,
                    1804,
                    1815,
                    1816,
                    1818
                ],
                "catarray.name": [
                    588,
                    605
                ],
                "catarray": [
                    588,
                    605,
                    590
                ],
                "self._encoding": [
                    642,
                    3084,
                    3099,
                    1055,
                    1057,
                    2726,
                    2730,
                    3114,
                    2999,
                    1466,
                    2623,
                    3140,
                    3144,
                    2121,
                    2380,
                    589,
                    1375,
                    2144,
                    1379,
                    1007
                ],
                "categories": [
                    1760,
                    1762,
                    1764,
                    590,
                    591,
                    1755,
                    1758
                ],
                "catarray.cat.categories": [
                    590
                ],
                "catarray.cat": [
                    590
                ],
                "self.value_labels": [
                    592,
                    600,
                    591
                ],
                "list": [
                    835,
                    1765,
                    591,
                    1714,
                    1749,
                    854,
                    2775,
                    2234
                ],
                "np.arange": [
                    1577,
                    591
                ],
                "len": [
                    1568,
                    1697,
                    610,
                    2370,
                    2850,
                    3137,
                    2566,
                    1895,
                    1896,
                    1066,
                    2253,
                    1710,
                    591,
                    2674,
                    2260,
                    3001
                ],
                "self.value_labels.sort": [
                    592
                ],
                "self.text_len": [
                    609,
                    610,
                    615,
                    593,
                    626,
                    664
                ],
                "self.off": [
                    609,
                    594,
                    667,
                    622
                ],
                "List": [
                    1186,
                    996,
                    1924,
                    2949,
                    1199,
                    594,
                    595,
                    596,
                    2290,
                    2291,
                    1208,
                    2234,
                    2136,
                    1180,
                    1150
                ],
                "self.val": [
                    611,
                    671,
                    595,
                    623
                ],
                "self.txt": [
                    612,
                    675,
                    596
                ],
                "bytes": [
                    1025,
                    2825,
                    2967,
                    2970,
                    2971,
                    2849,
                    2985,
                    2988,
                    2622,
                    2123,
                    596,
                    3032,
                    1371,
                    1894,
                    2795,
                    2668,
                    3183,
                    1265,
                    2673,
                    628
                ],
                "self.n": [
                    613,
                    597,
                    626,
                    661
                ],
                "vl": [
                    611,
                    3174,
                    3175,
                    600,
                    601,
                    2462,
                    2463
                ],
                "category": [
                    608,
                    1760,
                    610,
                    612,
                    601,
                    602,
                    603,
                    1756,
                    1757,
                    1758
                ],
                "isinstance": [
                    2240,
                    1025,
                    2304,
                    1027,
                    2494,
                    3008,
                    1894,
                    2411,
                    1932,
                    2348,
                    2672,
                    1875,
                    1367,
                    2969,
                    602,
                    794,
                    1022
                ],
                "value_label_mismatch_doc.format": [
                    605
                ],
                "ValueLabelTypeMismatch": [
                    606
                ],
                "category.encode": [
                    608
                ],
                "self.off.append": [
                    609
                ],
                "self.val.append": [
                    611
                ],
                "self.txt.append": [
                    612
                ],
                "np.array": [
                    2162,
                    622,
                    623
                ],
                "self.len": [
                    626,
                    647
                ],
                "bio": [
                    3073,
                    3074,
                    643,
                    3075,
                    647,
                    2824,
                    3079,
                    653,
                    3085,
                    3086,
                    3087,
                    657,
                    661,
                    2837,
                    2840,
                    664,
                    3096,
                    2843,
                    668,
                    3099,
                    2846,
                    3100,
                    672,
                    3101,
                    2850,
                    3105,
                    676,
                    2853,
                    678,
                    679,
                    2854,
                    2856,
                    2857,
                    2986,
                    2988,
                    3115,
                    2990,
                    3116,
                    3117,
                    2993,
                    3122,
                    2996,
                    3129,
                    3130,
                    3003,
                    3131,
                    3147,
                    3149,
                    3150,
                    3151,
                    3033,
                    3034,
                    3035,
                    3173,
                    3177,
                    3178,
                    3179,
                    3063,
                    3065,
                    3066,
                    3067,
                    3071
                ],
                "BytesIO": [
                    3105,
                    643,
                    3173,
                    1030,
                    3079,
                    2824,
                    2986,
                    3122,
                    3063,
                    3096,
                    3071
                ],
                "null_byte": [
                    657,
                    676,
                    644
                ],
                "bio.write": [
                    3073,
                    647,
                    653,
                    3085,
                    657,
                    661,
                    2837,
                    2840,
                    664,
                    2843,
                    668,
                    3099,
                    2846,
                    672,
                    2850,
                    676,
                    2853,
                    2854,
                    3115,
                    2988,
                    2990,
                    2993,
                    2996,
                    3129,
                    3003,
                    3147,
                    3149,
                    3033,
                    3177,
                    3065
                ],
                "struct.pack": [
                    3073,
                    647,
                    2826,
                    2827,
                    657,
                    661,
                    2840,
                    664,
                    2843,
                    668,
                    672,
                    2850,
                    2472,
                    2480,
                    2993,
                    2482,
                    2996,
                    3001,
                    2522,
                    735,
                    736,
                    745,
                    746,
                    3065
                ],
                "byteorder": [
                    647,
                    2958,
                    3342,
                    661,
                    664,
                    668,
                    672,
                    2720,
                    2721,
                    2722,
                    2470,
                    2984,
                    2474,
                    2990,
                    2480,
                    2993,
                    2482,
                    2996,
                    3001,
                    2108,
                    2109,
                    2110
                ],
                "labname": [
                    1417,
                    650,
                    1419,
                    652,
                    653,
                    1434,
                    1437
                ],
                "encode": [
                    3114,
                    650,
                    3084,
                    2623
                ],
                "lab_len": [
                    651,
                    652
                ],
                "_pad_bytes": [
                    2529,
                    2534,
                    2552,
                    2602,
                    652,
                    2540,
                    2574,
                    2485,
                    2549,
                    2488,
                    2459,
                    2556
                ],
                "i": [
                    3200,
                    3201,
                    656,
                    1435,
                    1436,
                    1437,
                    2588,
                    2589,
                    2591,
                    1699,
                    3108,
                    1703,
                    2599,
                    2600,
                    3111,
                    3112,
                    2362,
                    2364,
                    1725,
                    1726,
                    1727,
                    1600,
                    1601,
                    1602,
                    835,
                    1604,
                    1728,
                    1729,
                    1607,
                    1357,
                    1359,
                    2512,
                    1361,
                    3025,
                    725,
                    726,
                    1623,
                    1624,
                    730,
                    1627,
                    733,
                    734,
                    740,
                    2790,
                    743,
                    744,
                    2791,
                    2544,
                    2546,
                    2547,
                    1661,
                    1662,
                    2559
                ],
                "range": [
                    1155,
                    1285,
                    656,
                    1435,
                    1309,
                    1183,
                    1313,
                    3108,
                    1196,
                    1206,
                    3128,
                    1211,
                    1215,
                    835,
                    1219,
                    725,
                    854,
                    730,
                    740,
                    2544,
                    2559
                ],
                "offset": [
                    668,
                    1550,
                    1551,
                    1402,
                    1403,
                    667
                ],
                "text": [
                    675,
                    676
                ],
                "bio.seek": [
                    3074,
                    3066,
                    3130,
                    678,
                    2856,
                    3178,
                    3116,
                    3086,
                    3150,
                    3034,
                    3100
                ],
                "bio.read": [
                    3075,
                    3067,
                    679,
                    2857,
                    3131,
                    3179,
                    3117,
                    3087,
                    3151,
                    3035,
                    3101
                ],
                "MISSING_VALUES": [
                    742,
                    744,
                    720,
                    724,
                    726,
                    732,
                    734
                ],
                "Dict": [
                    2113,
                    2945,
                    1795,
                    1924,
                    2091,
                    2795,
                    1742,
                    1806,
                    720,
                    2096,
                    1395,
                    2963,
                    3318,
                    2743,
                    2233,
                    3323,
                    2940
                ],
                "bases": [
                    721,
                    722
                ],
                "b": [
                    1188,
                    1190,
                    1192,
                    1194,
                    1196,
                    1201,
                    722,
                    1203,
                    724,
                    1205,
                    726,
                    1206,
                    1182,
                    1183
                ],
                "chr": [
                    744,
                    734,
                    726
                ],
                "float32_base": [
                    728,
                    736,
                    731,
                    752
                ],
                "increment": [
                    729,
                    739,
                    745,
                    735
                ],
                "key": [
                    1926,
                    1927,
                    1928,
                    1929,
                    1930,
                    1932,
                    1934,
                    2336,
                    2337,
                    2338,
                    2347,
                    2348,
                    2349,
                    2740,
                    731,
                    732,
                    734,
                    735,
                    2784,
                    2785,
                    2787,
                    2788,
                    741,
                    742,
                    2789,
                    744,
                    745
                ],
                "int_value": [
                    736,
                    745,
                    746,
                    735
                ],
                "float64_base": [
                    753,
                    738,
                    746,
                    741
                ],
                "BASE_MISSING_VALUES": [
                    748
                ],
                "Union": [
                    800,
                    1158,
                    775,
                    1833,
                    2668,
                    1742,
                    1806,
                    1168,
                    1395,
                    756,
                    1366,
                    2967,
                    1150
                ],
                "self._value": [
                    784,
                    757
                ],
                "self._str": [
                    760,
                    772
                ],
                "self.MISSING_VALUES": [
                    760,
                    897,
                    2179,
                    2181
                ],
                "property": [
                    762,
                    1788,
                    774
                ],
                "self.string": [
                    795,
                    787
                ],
                "type": [
                    794,
                    1066,
                    1589,
                    790
                ],
                "Any": [
                    792
                ],
                "other": [
                    794,
                    795,
                    796
                ],
                "other.string": [
                    795
                ],
                "self.value": [
                    796
                ],
                "other.value": [
                    796
                ],
                "bool": [
                    792,
                    1824,
                    1825,
                    1827,
                    1828,
                    1830,
                    1832,
                    2092,
                    1975,
                    1857,
                    2626,
                    1744,
                    1619,
                    1497,
                    1498,
                    986,
                    987,
                    1501,
                    1500,
                    989,
                    992,
                    990,
                    1503,
                    3319,
                    1658,
                    2941
                ],
                "np.dtype": [
                    800,
                    2338,
                    2626,
                    1604,
                    1351,
                    1899,
                    1168,
                    1362,
                    1938,
                    1150
                ],
                "cls.BASE_MISSING_VALUES": [
                    802,
                    804,
                    806,
                    808,
                    810
                ],
                "cls": [
                    802,
                    804,
                    806,
                    808,
                    810
                ],
                "classmethod": [
                    799
                ],
                "self.DTYPE_MAP": [
                    834,
                    1302
                ],
                "dict": [
                    2169,
                    834,
                    3043,
                    1612,
                    844,
                    1804,
                    1651,
                    855,
                    1785,
                    1434
                ],
                "self.DTYPE_MAP_XML": [
                    1172,
                    844
                ],
                "self.TYPE_MAP": [
                    1297,
                    854
                ],
                "self.TYPE_MAP_XML": [
                    1162,
                    855
                ],
                "float32_min": [
                    869,
                    878
                ],
                "float64_min": [
                    882,
                    871
                ],
                "self.VALID_RANGE": [
                    873,
                    1666,
                    1663
                ],
                "self.OLD_TYPE_MAPPING": [
                    1291,
                    1292,
                    887
                ],
                "self.NUMPY_TYPE_MAP": [
                    906,
                    1358,
                    1359
                ],
                "self.RESERVED_WORDS": [
                    916,
                    2246
                ],
                "StataParser": [
                    2019,
                    980
                ],
                "abc.Iterator": [
                    980
                ],
                "abc": [
                    980
                ],
                "__doc__": [
                    981
                ],
                "FilePathOrBuffer": [
                    1857,
                    2089,
                    3316,
                    985,
                    2938,
                    1823
                ],
                "Optional": [
                    2944,
                    2945,
                    2946,
                    2711,
                    1826,
                    2467,
                    2468,
                    1829,
                    2980,
                    1831,
                    2981,
                    2091,
                    2093,
                    2094,
                    2095,
                    2096,
                    2114,
                    1476,
                    3324,
                    1496,
                    1497,
                    1498,
                    1499,
                    1500,
                    988,
                    1501,
                    1503,
                    1502,
                    993,
                    991,
                    3318,
                    3320,
                    3321,
                    3322,
                    3323,
                    2940,
                    3325,
                    2942,
                    2943
                ],
                "Sequence": [
                    2946,
                    1829,
                    1706,
                    1743,
                    2709,
                    3324,
                    1502,
                    991
                ],
                "__init__": [
                    2953,
                    2098,
                    995,
                    3337
                ],
                "super": [
                    2953,
                    2098,
                    995,
                    3337
                ],
                "self.col_sizes": [
                    996,
                    1069
                ],
                "self._convert_dates": [
                    2272,
                    2273,
                    2336,
                    2337,
                    1000,
                    2587,
                    2346,
                    2347,
                    1516,
                    2349,
                    2099,
                    2359,
                    2328,
                    2585,
                    2333,
                    2331,
                    2269,
                    2334
                ],
                "convert_dates": [
                    1926,
                    1927,
                    1000,
                    1928,
                    1930,
                    1515,
                    1516,
                    1837,
                    1934,
                    2956,
                    3340,
                    1617,
                    2099,
                    2359,
                    2585,
                    2364,
                    2589
                ],
                "self._convert_categoricals": [
                    1001,
                    1518
                ],
                "convert_categoricals": [
                    1633,
                    1001,
                    1546,
                    1517,
                    1518,
                    1838,
                    1565
                ],
                "self._index_col": [
                    1528,
                    1002
                ],
                "index_col": [
                    1576,
                    1002,
                    1839,
                    1653,
                    1654,
                    1527,
                    1528
                ],
                "self._convert_missing": [
                    1520,
                    1003
                ],
                "convert_missing": [
                    1673,
                    1003,
                    1615,
                    1520,
                    1519,
                    1840
                ],
                "self._preserve_dtypes": [
                    1522,
                    1004
                ],
                "preserve_dtypes": [
                    1638,
                    1004,
                    1521,
                    1522,
                    1841
                ],
                "self._columns": [
                    1524,
                    1005
                ],
                "columns": [
                    1690,
                    1693,
                    2718,
                    1580,
                    1709,
                    1582,
                    1710,
                    1842,
                    2234,
                    2235,
                    1724,
                    2238,
                    1737,
                    2257,
                    2775,
                    2264,
                    2777,
                    2266,
                    2270,
                    1005,
                    1523,
                    1524
                ],
                "self._order_categoricals": [
                    1526,
                    1006
                ],
                "order_categoricals": [
                    1635,
                    1006,
                    1843,
                    1525,
                    1526,
                    1754
                ],
                "self._chunksize": [
                    1008,
                    1490,
                    1474
                ],
                "chunksize": [
                    1008,
                    1844,
                    1847
                ],
                "self._has_string_data": [
                    1011
                ],
                "self._missing_values": [
                    1012
                ],
                "self._can_read_value_labels": [
                    1509,
                    1013,
                    1534,
                    1559
                ],
                "self._column_selector_set": [
                    1708,
                    1014,
                    1735
                ],
                "self._value_labels_read": [
                    1440,
                    1533,
                    1815,
                    1389,
                    1394,
                    1015,
                    1405
                ],
                "self._data_read": [
                    1016,
                    1560,
                    1510
                ],
                "self._dtype": [
                    1538,
                    1539,
                    1353,
                    1354,
                    1401,
                    1362,
                    1364,
                    1017,
                    1402
                ],
                "self._lines_read": [
                    1540,
                    1577,
                    1550,
                    1552,
                    1557,
                    1558,
                    1018
                ],
                "self._native_byteorder": [
                    1562,
                    1020
                ],
                "_set_endianness": [
                    2598,
                    2722,
                    1020,
                    2110
                ],
                "sys.byteorder": [
                    2721,
                    1020,
                    2109,
                    2598
                ],
                "sys": [
                    2721,
                    1020,
                    2109,
                    2598
                ],
                "path_or_buf": [
                    1025,
                    1026,
                    1027,
                    1029,
                    1021,
                    1022,
                    1023
                ],
                "stringify_path": [
                    1021,
                    2111
                ],
                "_": [
                    1215,
                    1313,
                    1155,
                    1219,
                    1285,
                    1196,
                    1211,
                    1206,
                    3128,
                    1023,
                    1309,
                    1183
                ],
                "should_close": [
                    1023
                ],
                "get_filepath_or_buffer": [
                    1023
                ],
                "self.path_or_buf": [
                    1026,
                    1030,
                    1551,
                    1554,
                    1046,
                    1060,
                    1073,
                    1074,
                    1078,
                    1079,
                    1080,
                    1084,
                    1086,
                    1089,
                    1091,
                    1093,
                    1094,
                    1095,
                    1098,
                    1101,
                    1104,
                    1107,
                    1110,
                    1116,
                    1118,
                    1121,
                    1124,
                    1129,
                    1132,
                    1135,
                    1138,
                    1141,
                    1144,
                    1152,
                    1154,
                    1183,
                    1196,
                    1206,
                    1211,
                    1215,
                    1219,
                    1225,
                    1227,
                    1231,
                    1232,
                    1234,
                    1235,
                    1237,
                    1239,
                    1243,
                    1244,
                    1246,
                    1247,
                    1249,
                    1255,
                    1261,
                    1271,
                    1273,
                    1274,
                    1276,
                    1285,
                    1287,
                    1309,
                    1313,
                    1317,
                    1334,
                    1338,
                    1342,
                    1346,
                    1349,
                    1399,
                    1403,
                    1410,
                    1413,
                    1417,
                    1419,
                    1420,
                    1422,
                    1423,
                    1425,
                    1428,
                    1433,
                    1439,
                    1443,
                    1447,
                    1451,
                    1453,
                    1462,
                    1463,
                    1464
                ],
                "open": [
                    1026,
                    1876
                ],
                "IOBase": [
                    1027
                ],
                "contents": [
                    1029,
                    1030
                ],
                "path_or_buf.read": [
                    1029
                ],
                "self._read_header": [
                    1032
                ],
                "self._setup_dtype": [
                    1033
                ],
                "self.close": [
                    1511,
                    1548,
                    1584,
                    1041,
                    1630
                ],
                "self.path_or_buf.close": [
                    1046
                ],
                "IOError": [
                    1047
                ],
                "self.format_version": [
                    1409,
                    1284,
                    1416,
                    1307,
                    1182,
                    1054,
                    1438,
                    1187,
                    1189,
                    1191,
                    1450,
                    1455,
                    1200,
                    1074,
                    1075,
                    1076,
                    1202,
                    1331,
                    1336,
                    1209,
                    1081,
                    1082,
                    1213,
                    1224,
                    1230,
                    1233,
                    1236,
                    1242,
                    1245,
                    1248,
                    1633,
                    1254,
                    1260,
                    1392,
                    1266,
                    1267,
                    1268,
                    1398,
                    1533
                ],
                "first_char": [
                    1064,
                    1266,
                    1060,
                    1061
                ],
                "self.path_or_buf.read": [
                    1154,
                    1410,
                    1285,
                    1413,
                    1287,
                    1417,
                    1419,
                    1420,
                    1422,
                    1423,
                    1425,
                    1554,
                    1428,
                    1433,
                    1309,
                    1183,
                    1439,
                    1313,
                    1060,
                    1317,
                    1447,
                    1451,
                    1196,
                    1453,
                    1462,
                    1073,
                    1074,
                    1078,
                    1079,
                    1080,
                    1206,
                    1334,
                    1211,
                    1084,
                    1338,
                    1086,
                    1215,
                    1342,
                    1089,
                    1346,
                    1091,
                    1219,
                    1093,
                    1094,
                    1095,
                    1463,
                    1225,
                    1098,
                    1227,
                    1464,
                    1101,
                    1231,
                    1104,
                    1232,
                    1234,
                    1107,
                    1235,
                    1237,
                    1110,
                    1239,
                    1243,
                    1116,
                    1244,
                    1118,
                    1246,
                    1247,
                    1121,
                    1249,
                    1124,
                    1255,
                    1261,
                    1135,
                    1271,
                    1273,
                    1274,
                    1276
                ],
                "self._read_new_header": [
                    1062
                ],
                "self._read_old_header": [
                    1064
                ],
                "self.has_string_data": [
                    1066
                ],
                "self.typlist": [
                    3072,
                    3201,
                    1699,
                    1732,
                    1127,
                    1066,
                    3212,
                    1357,
                    1069,
                    1297,
                    2291,
                    1588,
                    2294,
                    3223,
                    2584,
                    2521,
                    1662,
                    1727
                ],
                "self._calcsize": [
                    1069
                ],
                "typ": [
                    3072,
                    3073,
                    1159,
                    1160,
                    1162,
                    1164,
                    1169,
                    1170,
                    1297,
                    1172,
                    1174,
                    1302,
                    1699,
                    1700,
                    2600,
                    2601,
                    2602,
                    2603,
                    1069,
                    1588,
                    1589,
                    1462,
                    1465,
                    1357,
                    1358,
                    1359,
                    1361,
                    2521,
                    2522
                ],
                "_version_error.format": [
                    1076,
                    1268
                ],
                "self._set_encoding": [
                    1269,
                    1077
                ],
                "self.byteorder": [
                    1154,
                    1422,
                    1423,
                    1425,
                    1428,
                    1562,
                    1316,
                    1451,
                    1456,
                    1334,
                    1079,
                    1463,
                    1338,
                    1084,
                    1342,
                    1225,
                    1098,
                    1227,
                    1101,
                    1231,
                    1104,
                    1359,
                    1107,
                    1110,
                    1369,
                    1118,
                    1121,
                    1124,
                    1261,
                    1134,
                    1270,
                    1276
                ],
                "nvar_type": [
                    2992,
                    1081,
                    2993,
                    1084
                ],
                "nvar_size": [
                    1082,
                    1084
                ],
                "self.nvar": [
                    1155,
                    1285,
                    1287,
                    2320,
                    3092,
                    1309,
                    1183,
                    1313,
                    1316,
                    1317,
                    3108,
                    1196,
                    2480,
                    2993,
                    1206,
                    3128,
                    1211,
                    1083,
                    1215,
                    1219,
                    2534,
                    1259,
                    1134,
                    1135,
                    2544,
                    1276,
                    2559
                ],
                "self.nobs": [
                    1088,
                    1508,
                    1540,
                    1552,
                    2320,
                    2482,
                    2996,
                    1558,
                    1402,
                    1531,
                    1277
                ],
                "self._get_nobs": [
                    1088,
                    1277
                ],
                "self._data_label": [
                    1793,
                    1090,
                    2102,
                    2391,
                    1279
                ],
                "self._get_data_label": [
                    1090,
                    1279
                ],
                "self.time_stamp": [
                    1281,
                    1092
                ],
                "self._get_time_stamp": [
                    1281,
                    1092
                ],
                "self._seek_vartypes": [
                    1097,
                    1127
                ],
                "self._seek_varnames": [
                    1129,
                    1100
                ],
                "self._seek_sortlist": [
                    1132,
                    1103
                ],
                "self._seek_formats": [
                    1106,
                    1138
                ],
                "self._seek_value_label_names": [
                    1141,
                    1109,
                    1259
                ],
                "self._seek_variable_labels": [
                    1144,
                    1114
                ],
                "self._get_seek_variable_labels": [
                    1114
                ],
                "self.data_location": [
                    1403,
                    1349,
                    1117,
                    1551
                ],
                "self.seek_strls": [
                    1120,
                    1443
                ],
                "self.seek_value_labels": [
                    1123,
                    1399
                ],
                "self.dtyplist": [
                    1601,
                    1731,
                    1604,
                    1127,
                    1607,
                    1302,
                    1594,
                    1726
                ],
                "self._get_dtypes": [
                    1127
                ],
                "self.path_or_buf.seek": [
                    1152,
                    1443,
                    1129,
                    1132,
                    1551,
                    1138,
                    1141,
                    1399,
                    1144,
                    1403
                ],
                "self.varlist": [
                    1312,
                    1569,
                    1572,
                    1512,
                    3112,
                    1130,
                    3082,
                    1804,
                    2322,
                    2547,
                    1308,
                    2334,
                    2527
                ],
                "self._get_varlist": [
                    1130
                ],
                "self.srtlist": [
                    1315,
                    1133
                ],
                "self.fmtlist": [
                    1728,
                    1733,
                    1320,
                    2539,
                    2349,
                    3213,
                    2290,
                    1139,
                    2293,
                    1622,
                    3222,
                    3098,
                    1627,
                    2591
                ],
                "self._get_fmtlist": [
                    1320,
                    1139
                ],
                "self.lbllist": [
                    1729,
                    1635,
                    1734,
                    1322,
                    1142
                ],
                "self._get_lbllist": [
                    1322,
                    1142
                ],
                "self._variable_labels": [
                    3136,
                    2564,
                    2565,
                    1324,
                    1804,
                    3127,
                    2103,
                    1145,
                    2558,
                    3135
                ],
                "self._get_variable_labels": [
                    1145,
                    1324
                ],
                "seek_vartypes": [
                    1152
                ],
                "raw_typlist": [
                    1176,
                    1153,
                    1166
                ],
                "KeyError": [
                    1163,
                    1173
                ],
                "typlist": [
                    1732,
                    1285,
                    2600,
                    1289,
                    2584,
                    1292,
                    1166,
                    1294,
                    1297,
                    1299,
                    1302,
                    1304,
                    1721,
                    1178,
                    1727
                ],
                "dtyplist": [
                    1731,
                    1720,
                    1176,
                    1178,
                    1726
                ],
                "Tuple": [
                    1857,
                    2795,
                    2739,
                    2743,
                    1150
                ],
                "self._decode": [
                    1183,
                    1249,
                    1247,
                    1219,
                    1313,
                    1417,
                    1419,
                    1196,
                    1232,
                    1235,
                    1237,
                    1206,
                    1239,
                    1590,
                    1211,
                    1309,
                    1437,
                    1215
                ],
                "vlblist": [
                    1218,
                    1210,
                    1221,
                    1214
                ],
                "strlen": [
                    1231,
                    1232,
                    1234,
                    1235,
                    1243,
                    1244,
                    1246,
                    1247
                ],
                "decode": [
                    1466,
                    1244
                ],
                "self.filetype": [
                    1273
                ],
                "ord": [
                    2568,
                    3379,
                    1285,
                    3374
                ],
                "buf": [
                    1287,
                    1288,
                    1453,
                    1457,
                    1460,
                    1461
                ],
                "typlistb": [
                    1288,
                    1290
                ],
                "np.frombuffer": [
                    1288,
                    1553,
                    1427,
                    1424
                ],
                "tp": [
                    1290,
                    1291,
                    1292,
                    1294
                ],
                "typlist.append": [
                    1292,
                    1294,
                    1727
                ],
                "invalid_types": [
                    1299,
                    1300
                ],
                "join": [
                    1766,
                    2281,
                    1714,
                    1299,
                    1304
                ],
                "invalid_dtypes": [
                    1304,
                    1305
                ],
                "data_type": [
                    1344,
                    1333
                ],
                "data_len": [
                    1337,
                    1346,
                    1341
                ],
                "self.path_or_buf.tell": [
                    1349
                ],
                "dtypes": [
                    2338,
                    2597,
                    2343,
                    1356,
                    2604,
                    3214,
                    1359,
                    1361,
                    1362,
                    2610,
                    2292,
                    2324,
                    2612
                ],
                "enumerate": [
                    3200,
                    1699,
                    2780,
                    2790,
                    2599,
                    1357,
                    1677,
                    2512,
                    3025,
                    2362,
                    2779,
                    2588,
                    1661,
                    2238
                ],
                "dtypes.append": [
                    1361,
                    1359
                ],
                "struct.calcsize": [
                    1369
                ],
                "s": [
                    1386,
                    2623,
                    2619,
                    2620,
                    1373,
                    1375
                ],
                "s.partition": [
                    1373
                ],
                "s.decode": [
                    1386,
                    1375
                ],
                "UnicodeDecodeError": [
                    1376
                ],
                "msg": [
                    1380,
                    2278,
                    2279,
                    1768,
                    1385,
                    1779
                ],
                "UnicodeWarning": [
                    1385
                ],
                "self.value_label_dict": [
                    1635,
                    1395,
                    1434,
                    1818,
                    1437,
                    1406
                ],
                "self._dtype.itemsize": [
                    1402
                ],
                "slength": [
                    1413,
                    1414
                ],
                "n": [
                    1422,
                    1425,
                    1428,
                    1435,
                    1436
                ],
                "txtlen": [
                    1433,
                    1436,
                    1423
                ],
                "off": [
                    1424,
                    1430,
                    1431,
                    1436,
                    1437
                ],
                "val": [
                    2784,
                    2788,
                    3064,
                    1427,
                    3065,
                    1432,
                    2969,
                    2970,
                    2971,
                    2781,
                    1437,
                    2783
                ],
                "ii": [
                    1432,
                    1430,
                    1431
                ],
                "np.argsort": [
                    1430
                ],
                "txt": [
                    1433,
                    1437
                ],
                "end": [
                    1436,
                    1437
                ],
                "self.GSO": [
                    1697,
                    1703,
                    1445,
                    1471
                ],
                "v_o": [
                    1451,
                    1461,
                    1471
                ],
                "v_size": [
                    1457,
                    1460,
                    1455
                ],
                "length": [
                    1895,
                    1896,
                    2674,
                    1463,
                    1464
                ],
                "va": [
                    1464,
                    1466,
                    1469
                ],
                "decoded_va": [
                    1466,
                    1469,
                    1471
                ],
                "self.read": [
                    1474,
                    1491
                ],
                "size": [
                    1489,
                    1490,
                    1491
                ],
                "nrows": [
                    1508,
                    1541,
                    1552,
                    1530,
                    1531
                ],
                "self._read_strls": [
                    1535
                ],
                "max_read_len": [
                    1540,
                    1542
                ],
                "dtype.itemsize": [
                    1540,
                    1541,
                    1550
                ],
                "read_len": [
                    1554,
                    1541,
                    1542,
                    1543
                ],
                "self._read_value_labels": [
                    1816,
                    1547,
                    1566
                ],
                "StopIteration": [
                    1549
                ],
                "read_lines": [
                    1552,
                    1577,
                    1554,
                    1557
                ],
                "newbyteorder": [
                    1563
                ],
                "data.byteswap": [
                    1563
                ],
                "DataFrame.from_records": [
                    1571
                ],
                "data.columns": [
                    1602,
                    1572,
                    2234,
                    2266,
                    1712,
                    2322,
                    1624,
                    1690,
                    1725
                ],
                "ix": [
                    1577,
                    1578,
                    1597,
                    1607
                ],
                "data.set_index": [
                    1578,
                    1654
                ],
                "self._do_select_columns": [
                    1582
                ],
                "apply": [
                    2602,
                    1590
                ],
                "self._insert_strls": [
                    1592
                ],
                "cols_": [
                    1600,
                    1594
                ],
                "np.where": [
                    1594,
                    1622
                ],
                "data.index": [
                    1781,
                    1597
                ],
                "requires_type_conversion": [
                    1611,
                    1605,
                    1598
                ],
                "data_formatted": [
                    1606,
                    1610,
                    1612,
                    1613,
                    2166,
                    2168,
                    2169,
                    2141,
                    1599
                ],
                "object": [
                    1604
                ],
                "data_formatted.append": [
                    2168,
                    1610,
                    2166,
                    1606
                ],
                "DataFrame.from_dict": [
                    2169,
                    1785,
                    1651,
                    1612
                ],
                "self._do_convert_missing": [
                    1615
                ],
                "any": [
                    2137,
                    1620
                ],
                "x.startswith": [
                    1620
                ],
                "cols": [
                    1622,
                    1623
                ],
                "any_startswith": [
                    1622
                ],
                "_stata_elapsed_date_to_datetime_vec": [
                    1626
                ],
                "self._do_convert_categoricals": [
                    1634
                ],
                "retyped_data": [
                    1649,
                    1651,
                    1639
                ],
                "convert": [
                    1640,
                    1650,
                    1648,
                    1645
                ],
                "np.float16": [
                    1643
                ],
                "retyped_data.append": [
                    1649
                ],
                "data.pop": [
                    1654
                ],
                "Appender": [
                    1821,
                    1493
                ],
                "replacements": [
                    1688,
                    1689,
                    1691,
                    1660
                ],
                "colname": [
                    1688,
                    1667,
                    1661
                ],
                "nmin": [
                    1666,
                    1668
                ],
                "nmax": [
                    1666,
                    1668
                ],
                "series": [
                    1667,
                    1668,
                    1675,
                    1676,
                    1683,
                    1686
                ],
                "missing": [
                    1668,
                    1670,
                    1674,
                    1675,
                    1687
                ],
                "np.logical_or": [
                    1668
                ],
                "missing.any": [
                    1670
                ],
                "missing_loc": [
                    1680,
                    1674
                ],
                "np.argwhere": [
                    1674
                ],
                "missing._ndarray_values": [
                    1674
                ],
                "umissing": [
                    1675,
                    1677
                ],
                "umissing_loc": [
                    1680,
                    1675
                ],
                "np.unique": [
                    1675
                ],
                "replacement": [
                    2179,
                    2181,
                    2182,
                    1676,
                    1681,
                    1686,
                    1687,
                    1688
                ],
                "j": [
                    2789,
                    1677,
                    1680,
                    2264,
                    2780,
                    2238
                ],
                "um": [
                    1677,
                    1678
                ],
                "StataMissingValue": [
                    2140,
                    1678
                ],
                "loc": [
                    1680,
                    1681
                ],
                "replacement.iloc": [
                    1681
                ],
                "series.dtype": [
                    1683
                ],
                "np.nan": [
                    1687
                ],
                "replacement_df": [
                    1691,
                    1692
                ],
                "replaced": [
                    1692,
                    1693
                ],
                "concat": [
                    1692
                ],
                "data.drop": [
                    1692
                ],
                "replacement_df.columns": [
                    1692
                ],
                "hasattr": [
                    1872,
                    1697
                ],
                "data.iloc": [
                    1703
                ],
                "k": [
                    1703
                ],
                "column_set": [
                    1712,
                    1709,
                    1710
                ],
                "set": [
                    1709
                ],
                "unmatched": [
                    1712,
                    1713,
                    1714
                ],
                "column_set.difference": [
                    1712
                ],
                "joined": [
                    1714,
                    1717
                ],
                "fmtlist": [
                    1728,
                    1722,
                    1733
                ],
                "lbllist": [
                    1729,
                    1723,
                    1734,
                    1751
                ],
                "data.columns.get_loc": [
                    1725
                ],
                "dtyplist.append": [
                    1726
                ],
                "fmtlist.append": [
                    1728
                ],
                "lbllist.append": [
                    1729
                ],
                "value_labels": [
                    1752,
                    1749
                ],
                "value_label_dict.keys": [
                    1749
                ],
                "value_label_dict": [
                    1757,
                    1749,
                    1758
                ],
                "cat_converted_data": [
                    1782,
                    1785,
                    1784,
                    1750
                ],
                "label": [
                    3136,
                    3137,
                    3140,
                    2565,
                    2566,
                    2568,
                    2574,
                    2999,
                    2998,
                    1751,
                    1752,
                    1757,
                    1758
                ],
                "cat_data": [
                    1781,
                    1754,
                    1756,
                    1762
                ],
                "Categorical": [
                    1754
                ],
                "cat_data.categories": [
                    1762,
                    1756
                ],
                "categories.append": [
                    1760,
                    1758
                ],
                "vc": [
                    1764,
                    1765
                ],
                "value_counts": [
                    1764
                ],
                "repeated_cats": [
                    1765,
                    1766
                ],
                "vc.index": [
                    1765
                ],
                "repeats": [
                    1777,
                    1766
                ],
                "cat_series": [
                    1781,
                    1782
                ],
                "cat_converted_data.append": [
                    1784,
                    1782
                ],
                "staticmethod": [
                    2617,
                    1739,
                    2966
                ],
                "reader": [
                    1848,
                    1851,
                    1835,
                    1853
                ],
                "StataReader": [
                    1833,
                    1835
                ],
                "filepath_or_buffer": [
                    1836
                ],
                "iterator": [
                    1847
                ],
                "reader.read": [
                    1851
                ],
                "reader.close": [
                    1853
                ],
                "fname": [
                    2954,
                    3338,
                    1872,
                    1874,
                    1875,
                    1876,
                    2111
                ],
                "Path": [
                    2411,
                    1875
                ],
                "TypeError": [
                    1878
                ],
                "BinaryIO": [
                    1857,
                    2114
                ],
                "endianness.lower": [
                    1882,
                    1884
                ],
                "endianness": [
                    1882,
                    1884,
                    1887
                ],
                "AnyStr": [
                    1890
                ],
                "name": [
                    3082,
                    3083,
                    3084,
                    3085,
                    2210,
                    3110,
                    3112,
                    2217,
                    2218,
                    3113,
                    3114,
                    3372,
                    3380,
                    3382,
                    2238,
                    2239,
                    2240,
                    2241,
                    2243,
                    2246,
                    2247,
                    2250,
                    2251,
                    2253,
                    2255,
                    2257,
                    2259,
                    2260,
                    2262,
                    2264,
                    2527,
                    2528,
                    2529,
                    2530,
                    2277,
                    1894,
                    1895,
                    1896,
                    2278,
                    2672,
                    2673,
                    2674,
                    2547,
                    2548,
                    2549,
                    2550
                ],
                "NotImplementedError": [
                    2016,
                    1921,
                    1971,
                    2665
                ],
                "Label": [
                    2113,
                    2945,
                    2946,
                    1924,
                    2949,
                    2091,
                    2096,
                    3324,
                    3318,
                    2233,
                    2234,
                    3323,
                    2940
                ],
                "new_dict": [
                    1930,
                    1925,
                    1934,
                    1935
                ],
                "startswith": [
                    1927
                ],
                "varlist": [
                    1929,
                    1930
                ],
                "new_dict.update": [
                    1930,
                    1934
                ],
                "varlist.index": [
                    1930
                ],
                "dtype.type": [
                    2368,
                    1955,
                    2646,
                    1999
                ],
                "np.object_": [
                    2368,
                    1955,
                    2646,
                    1999
                ],
                "itemsize": [
                    1958,
                    1959,
                    2000,
                    2001,
                    2006,
                    2649,
                    2650,
                    2651,
                    2652
                ],
                "max_len_string_array": [
                    2000,
                    2649,
                    1958,
                    2383
                ],
                "ensure_object": [
                    2000,
                    2649,
                    1958,
                    2383
                ],
                "column.values": [
                    2000,
                    2649,
                    1958
                ],
                "column": [
                    2369,
                    2370,
                    2371,
                    1958,
                    2000,
                    2005,
                    2649,
                    2366,
                    2367
                ],
                "dta_version": [
                    1993,
                    2002
                ],
                "max_str_len": [
                    2001,
                    1994,
                    1996
                ],
                "force_strl": [
                    1997,
                    3215,
                    3220,
                    2644,
                    3224
                ],
                "excessive_string_length_error.format": [
                    2005
                ],
                "column.name": [
                    2371,
                    2005
                ],
                "_max_string_length": [
                    2084,
                    2933
                ],
                "_encoding": [
                    3312,
                    2085
                ],
                "self._write_index": [
                    2100,
                    2302
                ],
                "write_index": [
                    3341,
                    2100,
                    2957
                ],
                "self._time_stamp": [
                    2101,
                    2391
                ],
                "time_stamp": [
                    3008,
                    2959,
                    3343,
                    2514,
                    2515,
                    2516,
                    2101,
                    3006,
                    3027,
                    3028,
                    3029,
                    2492,
                    2493,
                    2494,
                    3007
                ],
                "data_label": [
                    2960,
                    3344,
                    2484,
                    2102,
                    2998,
                    2488
                ],
                "variable_labels": [
                    2961,
                    3345,
                    2103
                ],
                "self._own_file": [
                    2104,
                    2409,
                    2389,
                    2438
                ],
                "self._prepare_pandas": [
                    2106
                ],
                "self._byteorder": [
                    3073,
                    2722,
                    2598,
                    2470,
                    2984,
                    3175,
                    2826,
                    2827,
                    2828,
                    2829,
                    2830,
                    2609,
                    3065,
                    2110,
                    2463
                ],
                "self._fname": [
                    2411,
                    2412,
                    2415,
                    2389,
                    2111
                ],
                "self.type_converters": [
                    2112
                ],
                "self._converted_names": [
                    2113,
                    2284,
                    3190
                ],
                "self._file": [
                    2976,
                    2433,
                    2114,
                    2435,
                    3041,
                    3046,
                    2439,
                    2120,
                    2121,
                    2127,
                    2128,
                    2389,
                    3062,
                    2975
                ],
                "self._file.write": [
                    2128,
                    2121
                ],
                "to_write.encode": [
                    2121
                ],
                "to_write": [
                    2121
                ],
                "is_cat": [
                    2142,
                    2137,
                    2134,
                    2135
                ],
                "is_categorical_dtype": [
                    2134
                ],
                "self._is_col_cat": [
                    2546,
                    3111,
                    2135
                ],
                "self._value_labels": [
                    2136,
                    2145,
                    3174,
                    2462
                ],
                "StataValueLabel": [
                    2136,
                    2144
                ],
                "get_base_missing_value": [
                    2155,
                    2140,
                    2165
                ],
                "StataMissingValue.get_base_missing_value": [
                    2140
                ],
                "col_is_cat": [
                    2142,
                    2143
                ],
                "svl": [
                    2144,
                    2145
                ],
                "self._value_labels.append": [
                    2145
                ],
                "cat.codes.dtype": [
                    2146
                ],
                "cat.codes": [
                    2152,
                    2146
                ],
                "cat": [
                    2152,
                    2146
                ],
                "cat.codes.values.copy": [
                    2152
                ],
                "cat.codes.values": [
                    2152
                ],
                "values.max": [
                    2155
                ],
                "c": [
                    2176,
                    2182,
                    2568,
                    2210,
                    2212,
                    2213,
                    2214,
                    2215,
                    2217,
                    3372,
                    3374,
                    3375,
                    3376,
                    3377,
                    3378,
                    3379,
                    3380,
                    2270,
                    2271,
                    2272,
                    2175
                ],
                "fillna": [
                    2602,
                    2182
                ],
                "name.replace": [
                    2217,
                    3380
                ],
                "converted_names": [
                    2275,
                    2277,
                    2284,
                    2262,
                    2233
                ],
                "original_columns": [
                    2235,
                    2270
                ],
                "duplicate_var_id": [
                    2261,
                    2259,
                    2237
                ],
                "orig_name": [
                    2277,
                    2278,
                    2255,
                    2262,
                    2239
                ],
                "self._validate_variable_name": [
                    2243
                ],
                "columns.count": [
                    2257
                ],
                "Index": [
                    2266
                ],
                "o": [
                    2272,
                    2273,
                    2843,
                    2787,
                    2789,
                    2834,
                    2740,
                    2741,
                    2779,
                    2270,
                    2271
                ],
                "conversion_warning": [
                    2281,
                    2276,
                    2279
                ],
                "converted_names.items": [
                    2277
                ],
                "conversion_warning.append": [
                    2279
                ],
                "invalid_name_doc.format": [
                    2281
                ],
                "InvalidColumnName": [
                    2282
                ],
                "self._update_strl_names": [
                    2285
                ],
                "dtypes.items": [
                    2292,
                    3214
                ],
                "self.fmtlist.append": [
                    2293,
                    3222
                ],
                "_dtype_to_default_stata_fmt": [
                    3216,
                    2293
                ],
                "self.data": [
                    2563,
                    2380,
                    2321,
                    2386,
                    3218,
                    2293,
                    2294,
                    2583,
                    3134,
                    2362,
                    3224,
                    2366
                ],
                "self.typlist.append": [
                    2294,
                    3223
                ],
                "_dtype_to_stata_type": [
                    2294
                ],
                "data.copy": [
                    2300
                ],
                "temp": [
                    2304,
                    2305,
                    2303
                ],
                "data.reset_index": [
                    2303
                ],
                "self._check_column_names": [
                    2308
                ],
                "_cast_to_stata_types": [
                    2312
                ],
                "self._replace_nans": [
                    2315
                ],
                "self._prepare_categoricals": [
                    2318
                ],
                "data.shape": [
                    2320,
                    3328,
                    3331
                ],
                "data.columns.tolist": [
                    2322
                ],
                "data.dtypes": [
                    2324
                ],
                "_maybe_convert_to_int_keys": [
                    2333
                ],
                "new_type": [
                    2337,
                    2338
                ],
                "_convert_datetime_to_stata_type": [
                    2337
                ],
                "self._encode_strings": [
                    2341
                ],
                "self._set_formats_and_types": [
                    2343
                ],
                "convert_strl": [
                    2950,
                    2951,
                    3346,
                    2361,
                    2364
                ],
                "column.dtype": [
                    2367
                ],
                "inferred_dtype": [
                    2369,
                    2370
                ],
                "encoded": [
                    3140,
                    3147,
                    2380,
                    2383,
                    2386
                ],
                "str.encode": [
                    2380
                ],
                "encoded.values": [
                    2383
                ],
                "self._max_string_length": [
                    2384,
                    2601
                ],
                "_open_file_binary_write": [
                    2389
                ],
                "self._write_header": [
                    2391
                ],
                "self._write_map": [
                    2392,
                    2406
                ],
                "self._write_variable_types": [
                    2393
                ],
                "self._write_varnames": [
                    2394
                ],
                "self._write_sortlist": [
                    2395
                ],
                "self._write_formats": [
                    2396
                ],
                "self._write_value_label_names": [
                    2397
                ],
                "self._write_variable_labels": [
                    2398
                ],
                "self._write_expansion_fields": [
                    2399
                ],
                "self._write_characteristics": [
                    2400
                ],
                "records": [
                    3160,
                    2401,
                    2402,
                    2615
                ],
                "self._prepare_data": [
                    2401
                ],
                "self._write_data": [
                    2402
                ],
                "self._write_strls": [
                    2403
                ],
                "self._write_value_labels": [
                    2404
                ],
                "self._write_file_close_tag": [
                    2405
                ],
                "Exception": [
                    2407
                ],
                "self._close": [
                    2408,
                    2421
                ],
                "os.unlink": [
                    2412
                ],
                "os": [
                    2412
                ],
                "OSError": [
                    2413
                ],
                "ResourceWarning": [
                    2417
                ],
                "exc": [
                    2419
                ],
                "self._file.flush": [
                    2435
                ],
                "AttributeError": [
                    2436
                ],
                "self._file.close": [
                    2439
                ],
                "self._write": [
                    2560,
                    2530,
                    2535,
                    2474,
                    2476,
                    2540,
                    2478,
                    2574,
                    2576,
                    2550,
                    2552,
                    2459
                ],
                "self._write_bytes": [
                    3075,
                    3087,
                    3092,
                    3101,
                    2463,
                    2472,
                    2985,
                    3117,
                    2480,
                    2482,
                    2485,
                    2615,
                    2487,
                    3131,
                    3151,
                    3155,
                    2518,
                    3159,
                    3160,
                    3161,
                    2522,
                    3035,
                    3165,
                    3179,
                    3183,
                    3067
                ],
                "vl.generate_value_label": [
                    3175,
                    2463
                ],
                "self._null_terminate_bytes": [
                    2488,
                    2485,
                    2518
                ],
                "datetime.datetime.now": [
                    2493,
                    3007
                ],
                "months": [
                    2512,
                    3025,
                    2498,
                    3011
                ],
                "month_lookup": [
                    2512,
                    3025,
                    2515,
                    3028
                ],
                "ts": [
                    3032,
                    2513,
                    3026,
                    2518
                ],
                "time_stamp.strftime": [
                    2514,
                    3027,
                    2516,
                    3029
                ],
                "time_stamp.month": [
                    2515,
                    3028
                ],
                "self._null_terminate_str": [
                    2528,
                    3113,
                    3083,
                    2548,
                    2623
                ],
                "srtlist": [
                    2534,
                    2535
                ],
                "blank": [
                    2560,
                    3149,
                    2576,
                    3125,
                    3129,
                    2556
                ],
                "is_latin1": [
                    2568,
                    2569
                ],
                "all": [
                    2568
                ],
                "_datetime_to_stata_elapsed_vec": [
                    2590
                ],
                "self._convert_strls": [
                    2594
                ],
                "native_byteorder": [
                    2608,
                    2598
                ],
                "stype": [
                    2603,
                    2604,
                    2605
                ],
                "dtype.newbyteorder": [
                    2609
                ],
                "data.to_records": [
                    2612
                ],
                "np.recarray": [
                    2614,
                    2582
                ],
                "records.tobytes": [
                    3160,
                    2615
                ],
                "version": [
                    3328,
                    3329,
                    3331,
                    2727,
                    2731,
                    3349,
                    2713,
                    2715,
                    3327
                ],
                "self._dta_ver": [
                    2715
                ],
                "self.df": [
                    2717,
                    2774
                ],
                "df": [
                    2717
                ],
                "self.columns": [
                    2776,
                    2777,
                    2718,
                    2790
                ],
                "self._gso_table": [
                    2773,
                    2719
                ],
                "gso_v_type": [
                    2737,
                    2724
                ],
                "gso_o_type": [
                    2736,
                    2729,
                    2725
                ],
                "o_size": [
                    2728,
                    2732,
                    2734,
                    2735
                ],
                "self._o_offet": [
                    2741,
                    2735
                ],
                "self._gso_o_type": [
                    2736,
                    2829
                ],
                "self._gso_v_type": [
                    2737,
                    2828
                ],
                "gso_table": [
                    2784,
                    2788,
                    2793,
                    2831,
                    2773
                ],
                "gso_df": [
                    2791,
                    2793,
                    2774,
                    2775,
                    2776
                ],
                "gso_df.columns": [
                    2775
                ],
                "selected": [
                    2776,
                    2778,
                    2779
                ],
                "col_index": [
                    2777,
                    2780
                ],
                "columns.index": [
                    2777
                ],
                "keys": [
                    2778,
                    2789,
                    2791
                ],
                "np.empty": [
                    2778
                ],
                "selected.shape": [
                    2778
                ],
                "np.uint64": [
                    2778
                ],
                "idx": [
                    3192,
                    3193,
                    2779
                ],
                "row": [
                    2779,
                    2781
                ],
                "selected.iterrows": [
                    2779
                ],
                "gso_table.get": [
                    2784
                ],
                "self._convert_key": [
                    2789
                ],
                "gso": [
                    2825,
                    2837
                ],
                "gso_type": [
                    2826,
                    2846
                ],
                "null": [
                    2827,
                    2854
                ],
                "v_type": [
                    2840,
                    2828
                ],
                "o_type": [
                    2843,
                    2829
                ],
                "len_type": [
                    2850,
                    2830
                ],
                "strl": [
                    2849,
                    2831
                ],
                "vo": [
                    2832,
                    2834,
                    2831
                ],
                "gso_table.items": [
                    2831
                ],
                "utf8_string": [
                    2849,
                    2850,
                    2853
                ],
                "StataWriter": [
                    2860
                ],
                "_dta_version": [
                    2934
                ],
                "self._convert_strl": [
                    3201,
                    2949,
                    2951,
                    3215,
                    3191,
                    3192,
                    3193
                ],
                "self._convert_strl.extend": [
                    2951
                ],
                "self._map": [
                    2976,
                    3042,
                    3043,
                    2963,
                    3062,
                    3064
                ],
                "self._strl_blob": [
                    3208,
                    2964,
                    3165
                ],
                "tag": [
                    2976,
                    2971
                ],
                "self._file.tell": [
                    2976,
                    3046
                ],
                "self._tag": [
                    3075,
                    3087,
                    3092,
                    3101,
                    2988,
                    3117,
                    2990,
                    2993,
                    2996,
                    3131,
                    3003,
                    3151,
                    3155,
                    3033,
                    3035,
                    3165,
                    3176,
                    3179,
                    3067
                ],
                "self._dta_version": [
                    3107,
                    3205,
                    3081,
                    2988,
                    2992,
                    2995,
                    3091,
                    3124,
                    3219,
                    3349,
                    3000,
                    3097
                ],
                "nobs_size": [
                    2995,
                    2996
                ],
                "encoded_label": [
                    3001,
                    3002,
                    3003,
                    2999
                ],
                "label.encode": [
                    3140,
                    2999
                ],
                "label_size": [
                    3000,
                    3001
                ],
                "label_len": [
                    3001,
                    3002
                ],
                "stata_ts": [
                    3032,
                    3033
                ],
                "self._file.seek": [
                    3062
                ],
                "self._map.values": [
                    3064
                ],
                "self._update_map": [
                    3104,
                    3172,
                    3078,
                    3182,
                    3184,
                    3121,
                    3090,
                    3154,
                    3158,
                    3095,
                    3164,
                    3070
                ],
                "vn_len": [
                    3081,
                    3084
                ],
                "_pad_bytes_new": [
                    3114,
                    3147,
                    3084,
                    3125,
                    3099
                ],
                "sort_size": [
                    3091,
                    3092
                ],
                "fmt_len": [
                    3097,
                    3099
                ],
                "fmt.encode": [
                    3099
                ],
                "vl_len": [
                    3107,
                    3114,
                    3147,
                    3124,
                    3125
                ],
                "encoded_name": [
                    3114,
                    3115
                ],
                "UnicodeEncodeError": [
                    3141
                ],
                "lab": [
                    3176,
                    3177,
                    3175
                ],
                "orig": [
                    3192,
                    3190,
                    3191
                ],
                "new": [
                    3193,
                    3190
                ],
                "self._converted_names.items": [
                    3190
                ],
                "self._convert_strl.index": [
                    3192
                ],
                "convert_cols": [
                    3204,
                    3205,
                    3198
                ],
                "ssw": [
                    3208,
                    3205,
                    3206
                ],
                "StataStrLWriter": [
                    3205
                ],
                "tab": [
                    3208,
                    3206
                ],
                "new_data": [
                    3206,
                    3207
                ],
                "ssw.generate_table": [
                    3206
                ],
                "ssw.generate_blob": [
                    3208
                ],
                "_dtype_to_stata_type_117": [
                    3224
                ],
                "StataWriter117": [
                    3228
                ]
            },
            "filtered_variables_in_file": {
                "_version_error": [
                    52,
                    1076,
                    1268
                ],
                "_statafile_processing_params1": [
                    107,
                    59,
                    141,
                    159
                ],
                "_statafile_processing_params2": [
                    160,
                    65,
                    108,
                    142
                ],
                "_chunksize_params": [
                    161,
                    83,
                    109
                ],
                "_iterator_params": [
                    88,
                    110
                ],
                "_read_stata_doc": [
                    92,
                    1821
                ],
                "_read_method_doc": [
                    1493,
                    134
                ],
                "_stata_reader_doc": [
                    981,
                    149
                ],
                "_date_formats": [
                    1620,
                    165
                ],
                "stata_epoch": [
                    320,
                    417,
                    290,
                    356,
                    420,
                    423,
                    168,
                    426,
                    302,
                    402,
                    371,
                    308,
                    404,
                    312,
                    316
                ],
                "datetime.datetime": [
                    384,
                    385,
                    3008,
                    2468,
                    2494,
                    2981,
                    3321,
                    168,
                    238,
                    2094,
                    2943,
                    3007,
                    251,
                    221,
                    222,
                    2493
                ],
                "datetime": [
                    384,
                    385,
                    3008,
                    2468,
                    2494,
                    2981,
                    3321,
                    168,
                    238,
                    2094,
                    373,
                    2943,
                    3007,
                    251,
                    221,
                    222,
                    2493
                ],
                "MIN_YEAR": [
                    233,
                    220,
                    246
                ],
                "MAX_YEAR": [
                    233,
                    220,
                    246
                ],
                "Timestamp.min.year": [
                    220
                ],
                "Timestamp.min": [
                    220,
                    222
                ],
                "Timestamp": [
                    220,
                    221,
                    222
                ],
                "Timestamp.max.year": [
                    220
                ],
                "Timestamp.max": [
                    220,
                    221
                ],
                "MAX_DAY_DELTA": [
                    224,
                    264,
                    221
                ],
                "days": [
                    385,
                    382,
                    358,
                    363,
                    303,
                    304,
                    309,
                    310,
                    247,
                    252,
                    221,
                    222
                ],
                "MIN_DAY_DELTA": [
                    264,
                    222,
                    223
                ],
                "MIN_MS_DELTA": [
                    268,
                    223
                ],
                "MAX_MS_DELTA": [
                    224,
                    268
                ],
                "year.max": [
                    233,
                    246
                ],
                "year": [
                    308,
                    310,
                    312,
                    314,
                    316,
                    318,
                    320,
                    322,
                    324,
                    326,
                    358,
                    233,
                    234,
                    236,
                    238,
                    246,
                    247,
                    249,
                    378,
                    252
                ],
                "year.min": [
                    233,
                    246
                ],
                "to_datetime": [
                    234,
                    364,
                    402,
                    275,
                    247
                ],
                "month": [
                    321,
                    322,
                    234,
                    238,
                    2512,
                    3025,
                    313,
                    314
                ],
                "index": [
                    262,
                    266,
                    395,
                    236,
                    238,
                    398,
                    272,
                    437,
                    249,
                    348,
                    254
                ],
                "Series": [
                    256,
                    266,
                    3211,
                    1676,
                    272,
                    400,
                    1938,
                    1686,
                    285,
                    296,
                    174,
                    433,
                    437,
                    1975,
                    2626,
                    1607,
                    584,
                    336,
                    226,
                    1764,
                    237,
                    241,
                    2289,
                    1781,
                    254
                ],
                "y": [
                    251,
                    252,
                    238
                ],
                "m": [
                    238
                ],
                "to_timedelta": [
                    276,
                    247
                ],
                "value": [
                    671,
                    672,
                    802,
                    804,
                    806,
                    551,
                    552,
                    808,
                    810,
                    557,
                    813,
                    560,
                    562,
                    2128,
                    757,
                    759,
                    760,
                    250,
                    254
                ],
                "relativedelta": [
                    265,
                    251,
                    270
                ],
                "d": [
                    388,
                    265,
                    395,
                    270,
                    407,
                    408,
                    413,
                    414,
                    416,
                    417,
                    419,
                    420,
                    422,
                    423,
                    425,
                    426,
                    428,
                    429,
                    353,
                    357,
                    361,
                    362,
                    365,
                    367,
                    252,
                    377,
                    251,
                    380,
                    381
                ],
                "deltas": [
                    262,
                    264,
                    265,
                    268,
                    270,
                    276,
                    277
                ],
                "unit": [
                    267,
                    276,
                    263
                ],
                "deltas.max": [
                    264,
                    268
                ],
                "deltas.min": [
                    264,
                    268
                ],
                "values": [
                    2152,
                    265,
                    266,
                    2155,
                    269,
                    272,
                    2162,
                    2165,
                    2166
                ],
                "base": [
                    290,
                    292,
                    265,
                    270,
                    302,
                    304,
                    275,
                    277
                ],
                "bad_locs": [
                    298,
                    331,
                    281,
                    283,
                    286
                ],
                "np.isnan": [
                    281
                ],
                "np": [
                    512,
                    513,
                    514,
                    515,
                    526,
                    1553,
                    530,
                    2582,
                    537,
                    539,
                    540,
                    542,
                    543,
                    545,
                    547,
                    550,
                    552,
                    1577,
                    557,
                    558,
                    559,
                    2614,
                    1594,
                    2112,
                    2626,
                    1604,
                    591,
                    1622,
                    2646,
                    2654,
                    2656,
                    2658,
                    2147,
                    2660,
                    2662,
                    1643,
                    1644,
                    2156,
                    622,
                    623,
                    1646,
                    1647,
                    2157,
                    2158,
                    2159,
                    2161,
                    2162,
                    1150,
                    2177,
                    2178,
                    1668,
                    1674,
                    1675,
                    1676,
                    1168,
                    1684,
                    1685,
                    1687,
                    2778,
                    1288,
                    281,
                    287,
                    800,
                    801,
                    2338,
                    803,
                    805,
                    807,
                    296,
                    809,
                    2368,
                    325,
                    837,
                    838,
                    839,
                    840,
                    841,
                    1351,
                    846,
                    847,
                    848,
                    849,
                    850,
                    851,
                    1362,
                    357,
                    1899,
                    364,
                    366,
                    878,
                    879,
                    882,
                    883,
                    376,
                    1919,
                    387,
                    901,
                    902,
                    1424,
                    1938,
                    1427,
                    1430,
                    1955,
                    1960,
                    426,
                    1962,
                    1964,
                    1966,
                    1968,
                    433,
                    1999,
                    2007,
                    2009,
                    2011,
                    2013
                ],
                "dates": [
                    388,
                    397,
                    398,
                    400,
                    401,
                    402,
                    404,
                    407,
                    281,
                    411,
                    285,
                    413,
                    287,
                    416,
                    291,
                    419,
                    422,
                    296,
                    425,
                    428,
                    303,
                    308,
                    309,
                    312,
                    313,
                    316,
                    317,
                    320,
                    321,
                    324,
                    325,
                    348,
                    354,
                    356,
                    360,
                    364,
                    369,
                    371,
                    379
                ],
                "has_bad_values": [
                    297,
                    282,
                    284,
                    330
                ],
                "bad_locs.any": [
                    283
                ],
                "data_col": [
                    285,
                    286
                ],
                "dates.astype": [
                    364,
                    287
                ],
                "np.int64": [
                    515,
                    2147,
                    357,
                    364,
                    543,
                    366,
                    1647,
                    287
                ],
                "fmt.startswith": [
                    289,
                    323,
                    293,
                    301,
                    307,
                    311,
                    315,
                    319
                ],
                "fmt": [
                    1921,
                    1666,
                    3216,
                    406,
                    3222,
                    409,
                    3098,
                    3099,
                    412,
                    415,
                    289,
                    418,
                    293,
                    421,
                    424,
                    427,
                    301,
                    431,
                    307,
                    311,
                    315,
                    319,
                    323,
                    328,
                    1620,
                    1367,
                    1368,
                    1369,
                    2539,
                    2540,
                    1903,
                    1662,
                    1663
                ],
                "ms": [
                    291,
                    292
                ],
                "conv_dates": [
                    408,
                    411,
                    414,
                    417,
                    292,
                    420,
                    423,
                    296,
                    298,
                    299,
                    426,
                    429,
                    304,
                    433,
                    435,
                    437,
                    310,
                    314,
                    318,
                    322,
                    326,
                    331,
                    333
                ],
                "convert_delta_safe": [
                    304,
                    292
                ],
                "warnings.warn": [
                    295,
                    1385,
                    2282,
                    2414,
                    567,
                    410,
                    604
                ],
                "warnings": [
                    295,
                    1385,
                    2282,
                    2414,
                    567,
                    410,
                    604
                ],
                "np.object": [
                    296,
                    1676
                ],
                "NaT": [
                    298,
                    331
                ],
                "stata_epoch.year": [
                    320,
                    417,
                    420,
                    423,
                    426,
                    308,
                    312,
                    316
                ],
                "convert_year_days_safe": [
                    310
                ],
                "convert_year_month_safe": [
                    326,
                    314,
                    322,
                    318
                ],
                "quarter_month": [
                    317,
                    318
                ],
                "first_month": [
                    325,
                    326
                ],
                "np.ones_like": [
                    325
                ],
                "dates.index": [
                    348,
                    398
                ],
                "NS_PER_DAY": [
                    349,
                    350,
                    367
                ],
                "US_PER_DAY": [
                    374,
                    414,
                    350
                ],
                "is_datetime64_dtype": [
                    401,
                    354,
                    2330
                ],
                "dates.values": [
                    354,
                    371
                ],
                "delta": [
                    371,
                    377,
                    370,
                    355
                ],
                "time_delta": [
                    356,
                    357
                ],
                "time_delta.values.astype": [
                    357
                ],
                "time_delta.values": [
                    357
                ],
                "date_index": [
                    360,
                    361,
                    362
                ],
                "DatetimeIndex": [
                    360
                ],
                "date_index.year": [
                    361
                ],
                "date_index.month": [
                    362
                ],
                "days_in_ns": [
                    364,
                    367
                ],
                "astype": [
                    545,
                    547,
                    426,
                    364,
                    2605,
                    558,
                    1649,
                    534,
                    539,
                    542
                ],
                "infer_dtype": [
                    2369,
                    369
                ],
                "datetime.timedelta": [
                    373
                ],
                "x.days": [
                    374
                ],
                "x": [
                    385,
                    1304,
                    1066,
                    1166,
                    592,
                    1299,
                    1620,
                    374,
                    1622,
                    1176,
                    379
                ],
                "x.seconds": [
                    374
                ],
                "x.microseconds": [
                    374
                ],
                "v": [
                    387,
                    388,
                    2787,
                    2840,
                    2834,
                    2740,
                    2741,
                    376,
                    377,
                    2780
                ],
                "np.vectorize": [
                    376,
                    387
                ],
                "f": [
                    376,
                    1166
                ],
                "year_month": [
                    379,
                    380,
                    381
                ],
                "dates.apply": [
                    379
                ],
                "x.year": [
                    385,
                    379
                ],
                "x.month": [
                    379
                ],
                "year_month.values": [
                    380,
                    381
                ],
                "g": [
                    1176,
                    387
                ],
                "DataFrame": [
                    2304,
                    395,
                    2578,
                    2708,
                    1691,
                    1696,
                    1569,
                    2169,
                    1571,
                    1833,
                    1706,
                    2090,
                    2220,
                    2743,
                    1473,
                    2939,
                    1476,
                    3195,
                    1612,
                    1741,
                    1745,
                    2130,
                    1504,
                    484,
                    1512,
                    1651,
                    3317,
                    2296,
                    1785,
                    1658,
                    2171
                ],
                "bad_loc": [
                    397,
                    399,
                    402,
                    435,
                    404
                ],
                "isna": [
                    397
                ],
                "bad_loc.any": [
                    399
                ],
                "parse_dates_safe": [
                    416,
                    419,
                    422,
                    425,
                    428,
                    407,
                    413
                ],
                "d.delta": [
                    408,
                    414
                ],
                "d.year": [
                    417,
                    420,
                    423,
                    426,
                    429
                ],
                "d.days": [
                    417
                ],
                "d.month": [
                    426,
                    420,
                    423
                ],
                "np.int": [
                    426
                ],
                "np.float64": [
                    2177,
                    902,
                    530,
                    1684,
                    1685,
                    547,
                    550,
                    1960,
                    809,
                    558,
                    559,
                    433,
                    841,
                    847,
                    2007,
                    2654,
                    1644,
                    2161,
                    882,
                    883,
                    1919
                ],
                "missing_value": [
                    1681,
                    434,
                    435,
                    1678
                ],
                "struct.unpack": [
                    1154,
                    901,
                    518,
                    519,
                    903,
                    1422,
                    1423,
                    1315,
                    1061,
                    1451,
                    434,
                    1333,
                    1461,
                    1462,
                    1463,
                    1337,
                    1083,
                    1341,
                    1225,
                    1098,
                    1227,
                    1101,
                    1231,
                    1104,
                    1234,
                    1107,
                    1110,
                    729,
                    731,
                    1243,
                    1118,
                    735,
                    1246,
                    1121,
                    739,
                    1124,
                    741,
                    745,
                    1133,
                    878,
                    879,
                    752,
                    753,
                    882,
                    883,
                    1261,
                    1266,
                    1271,
                    1273,
                    1276
                ],
                "struct": [
                    3073,
                    1154,
                    901,
                    518,
                    647,
                    519,
                    903,
                    2826,
                    2827,
                    1422,
                    1423,
                    657,
                    661,
                    664,
                    2840,
                    2843,
                    668,
                    672,
                    2850,
                    1315,
                    1061,
                    2472,
                    1451,
                    2480,
                    2993,
                    434,
                    2482,
                    2996,
                    1333,
                    1461,
                    1462,
                    1463,
                    1337,
                    3001,
                    1083,
                    1341,
                    3065,
                    1225,
                    1098,
                    1227,
                    1101,
                    1231,
                    1104,
                    1234,
                    1107,
                    1110,
                    729,
                    1369,
                    731,
                    1243,
                    2522,
                    1118,
                    735,
                    736,
                    1121,
                    1246,
                    739,
                    1124,
                    741,
                    745,
                    746,
                    1133,
                    878,
                    879,
                    752,
                    753,
                    882,
                    883,
                    1261,
                    1266,
                    1271,
                    1273,
                    1276
                ],
                "excessive_string_length_error": [
                    440,
                    2005
                ],
                "precision_loss_doc": [
                    451,
                    532,
                    549
                ],
                "value_label_mismatch_doc": [
                    605,
                    461
                ],
                "invalid_name_doc": [
                    472,
                    2281
                ],
                "ws": [
                    549,
                    2281,
                    2282,
                    532,
                    566,
                    567,
                    509
                ],
                "conversion_data": [
                    524,
                    511
                ],
                "np.bool": [
                    512
                ],
                "np.int8": [
                    512,
                    513,
                    801,
                    2112,
                    837,
                    2662,
                    2156,
                    1646,
                    1968,
                    851,
                    537,
                    2013
                ],
                "np.uint8": [
                    1288,
                    513,
                    846
                ],
                "np.int16": [
                    2112,
                    513,
                    514,
                    803,
                    2660,
                    838,
                    2157,
                    1646,
                    1966,
                    2158,
                    850,
                    539,
                    540,
                    2013
                ],
                "np.uint16": [
                    514
                ],
                "np.int32": [
                    2112,
                    545,
                    514,
                    515,
                    2658,
                    805,
                    839,
                    1964,
                    622,
                    623,
                    1646,
                    849,
                    2159,
                    2011,
                    542
                ],
                "np.uint32": [
                    515
                ],
                "float32_max": [
                    870,
                    557,
                    518,
                    879
                ],
                "float64_max": [
                    519,
                    872,
                    560,
                    883,
                    563
                ],
                "col": [
                    2563,
                    2564,
                    2565,
                    521,
                    522,
                    526,
                    531,
                    534,
                    538,
                    539,
                    2588,
                    541,
                    542,
                    2590,
                    544,
                    545,
                    2591,
                    547,
                    548,
                    551,
                    2599,
                    554,
                    2602,
                    2604,
                    2605,
                    558,
                    2607,
                    562,
                    2610,
                    1588,
                    1590,
                    3134,
                    3135,
                    3136,
                    1602,
                    1603,
                    1607,
                    1610,
                    2134,
                    1624,
                    1626,
                    1627,
                    2142,
                    2144,
                    2146,
                    2152,
                    1641,
                    1642,
                    1649,
                    2166,
                    2168,
                    3199,
                    3200,
                    3201,
                    3214,
                    3215,
                    3218,
                    3224,
                    1724,
                    1725,
                    1751,
                    2777,
                    1754,
                    2780,
                    2781,
                    2790,
                    2791,
                    1769,
                    2292,
                    2293,
                    1782,
                    2294,
                    1784,
                    2327,
                    2328,
                    2330,
                    2331,
                    2362,
                    2364,
                    2366,
                    2371,
                    2374,
                    2380,
                    2386
                ],
                "data": [
                    521,
                    522,
                    526,
                    1553,
                    531,
                    2580,
                    534,
                    2583,
                    538,
                    1563,
                    539,
                    541,
                    542,
                    2588,
                    544,
                    545,
                    1568,
                    547,
                    548,
                    1569,
                    1571,
                    551,
                    1572,
                    2594,
                    1578,
                    2599,
                    2602,
                    2605,
                    558,
                    1582,
                    2607,
                    1588,
                    2612,
                    1590,
                    1592,
                    569,
                    2106,
                    1597,
                    1602,
                    1603,
                    1607,
                    1610,
                    1612,
                    1615,
                    2134,
                    1624,
                    1626,
                    1627,
                    2138,
                    2142,
                    2144,
                    1634,
                    1635,
                    2146,
                    2152,
                    1641,
                    1642,
                    1649,
                    1651,
                    1654,
                    2168,
                    1656,
                    1661,
                    2175,
                    2176,
                    3200,
                    1667,
                    3205,
                    2182,
                    3207,
                    2184,
                    3209,
                    1690,
                    1692,
                    1693,
                    1694,
                    1698,
                    1703,
                    1704,
                    1712,
                    2234,
                    1725,
                    1737,
                    1751,
                    1754,
                    2266,
                    2590,
                    2591,
                    2287,
                    1781,
                    1784,
                    1785,
                    1786,
                    2300,
                    2303,
                    3328,
                    2305,
                    3331,
                    2308,
                    2312,
                    2315,
                    3339,
                    2318,
                    2320,
                    2321,
                    2322,
                    2324,
                    2327,
                    2330,
                    1851,
                    1854,
                    2955
                ],
                "dtype": [
                    1539,
                    1540,
                    1541,
                    522,
                    525,
                    1550,
                    527,
                    529,
                    1554,
                    534,
                    537,
                    540,
                    543,
                    550,
                    557,
                    559,
                    2607,
                    2609,
                    2610,
                    1603,
                    1604,
                    2646,
                    2654,
                    2656,
                    2146,
                    2147,
                    2658,
                    2660,
                    2662,
                    2665,
                    1642,
                    1643,
                    1644,
                    2155,
                    1646,
                    1647,
                    2156,
                    1649,
                    2157,
                    2158,
                    2159,
                    2161,
                    2162,
                    2165,
                    2176,
                    2177,
                    2178,
                    3214,
                    3217,
                    1683,
                    1684,
                    1685,
                    1686,
                    3224,
                    2292,
                    2293,
                    2294,
                    801,
                    803,
                    805,
                    807,
                    809,
                    2367,
                    2368,
                    1955,
                    1960,
                    1962,
                    1964,
                    1966,
                    1968,
                    1971,
                    1999,
                    2007,
                    2009,
                    2011,
                    2013,
                    2016
                ],
                "c_data": [
                    524,
                    525,
                    526,
                    527,
                    529,
                    530
                ],
                "np.iinfo": [
                    526
                ],
                "precision_loss_doc.format": [
                    532,
                    549
                ],
                "np.float32": [
                    2656,
                    2177,
                    2178,
                    901,
                    550,
                    807,
                    840,
                    1962,
                    1643,
                    557,
                    878,
                    879,
                    848,
                    1684,
                    2009
                ],
                "np.isinf": [
                    552
                ],
                "PossiblePrecisionLoss": [
                    567
                ],
                "encoding": [
                    608,
                    642,
                    1379,
                    1381,
                    586,
                    650,
                    651,
                    589,
                    1023
                ],
                "self.labname": [
                    650,
                    588
                ],
                "self": [
                    2099,
                    2100,
                    2101,
                    2102,
                    2103,
                    2104,
                    2106,
                    2110,
                    2111,
                    2112,
                    2113,
                    2114,
                    2120,
                    2121,
                    2127,
                    2128,
                    2135,
                    2136,
                    2144,
                    2145,
                    2179,
                    2181,
                    2243,
                    2246,
                    2269,
                    2272,
                    2273,
                    2284,
                    2285,
                    2290,
                    2291,
                    2293,
                    2294,
                    2302,
                    2308,
                    2315,
                    2318,
                    2320,
                    2321,
                    2322,
                    2328,
                    2331,
                    2333,
                    2334,
                    2336,
                    2337,
                    2341,
                    2343,
                    2346,
                    2347,
                    2349,
                    2359,
                    2361,
                    2362,
                    2366,
                    2380,
                    2384,
                    2386,
                    2389,
                    2391,
                    2392,
                    2393,
                    2394,
                    2395,
                    2396,
                    2397,
                    2398,
                    2399,
                    2400,
                    2401,
                    2402,
                    2403,
                    2404,
                    2405,
                    2406,
                    2408,
                    2409,
                    2411,
                    2412,
                    2415,
                    2421,
                    2433,
                    2435,
                    2438,
                    2439,
                    2459,
                    2462,
                    2463,
                    2470,
                    2472,
                    2474,
                    2476,
                    2478,
                    2480,
                    2482,
                    2485,
                    2487,
                    2488,
                    2518,
                    2521,
                    2522,
                    2527,
                    2528,
                    2530,
                    2534,
                    2535,
                    2539,
                    2540,
                    2544,
                    2546,
                    2547,
                    2548,
                    2550,
                    2552,
                    2558,
                    2559,
                    2560,
                    2563,
                    2564,
                    2565,
                    2574,
                    2576,
                    2583,
                    2584,
                    2585,
                    2587,
                    2591,
                    2594,
                    2598,
                    2601,
                    2609,
                    2615,
                    2623,
                    588,
                    589,
                    591,
                    592,
                    593,
                    594,
                    595,
                    596,
                    597,
                    600,
                    609,
                    610,
                    611,
                    612,
                    613,
                    615,
                    622,
                    623,
                    626,
                    642,
                    647,
                    650,
                    661,
                    664,
                    667,
                    2715,
                    2717,
                    2718,
                    671,
                    2719,
                    2722,
                    675,
                    2726,
                    2730,
                    2735,
                    2736,
                    2737,
                    2741,
                    2773,
                    2774,
                    2776,
                    2777,
                    2789,
                    2790,
                    757,
                    760,
                    772,
                    2826,
                    2827,
                    2828,
                    2829,
                    2830,
                    784,
                    787,
                    790,
                    794,
                    795,
                    796,
                    834,
                    844,
                    854,
                    855,
                    873,
                    887,
                    897,
                    2949,
                    2951,
                    906,
                    2963,
                    916,
                    2964,
                    2975,
                    2976,
                    2984,
                    2985,
                    2988,
                    2990,
                    2992,
                    2993,
                    2995,
                    2996,
                    2999,
                    3000,
                    3003,
                    3033,
                    3035,
                    3041,
                    3042,
                    3043,
                    996,
                    3046,
                    1000,
                    1001,
                    1002,
                    1003,
                    1004,
                    1005,
                    1006,
                    1007,
                    1008,
                    1011,
                    1012,
                    1013,
                    1014,
                    1015,
                    1016,
                    1017,
                    1018,
                    3062,
                    1020,
                    3064,
                    3065,
                    3067,
                    3070,
                    3072,
                    1026,
                    3073,
                    3075,
                    1030,
                    3078,
                    1032,
                    1033,
                    3081,
                    3082,
                    3083,
                    1037,
                    3084,
                    3087,
                    1041,
                    3090,
                    3091,
                    3092,
                    1046,
                    3095,
                    3097,
                    3098,
                    3099,
                    3101,
                    1054,
                    1055,
                    3104,
                    1057,
                    3107,
                    1060,
                    3108,
                    1062,
                    3111,
                    1064,
                    3112,
                    1066,
                    3113,
                    3114,
                    1069,
                    3117,
                    1073,
                    1074,
                    1075,
                    1076,
                    1077,
                    1078,
                    1079,
                    1080,
                    1081,
                    1082,
                    1083,
                    1084,
                    3124,
                    1086,
                    3127,
                    1088,
                    1089,
                    1090,
                    1091,
                    1092,
                    1093,
                    1094,
                    1095,
                    3135,
                    1097,
                    1098,
                    3140,
                    1100,
                    1101,
                    3144,
                    1103,
                    1104,
                    3151,
                    1106,
                    1107,
                    3154,
                    1109,
                    1110,
                    3155,
                    3158,
                    3159,
                    1114,
                    3160,
                    1116,
                    1117,
                    1118,
                    3161,
                    1120,
                    1121,
                    3164,
                    1123,
                    1124,
                    3165,
                    3172,
                    1127,
                    3174,
                    1129,
                    1130,
                    3175,
                    1132,
                    1133,
                    1134,
                    1135,
                    3176,
                    3179,
                    1138,
                    1139,
                    3182,
                    1141,
                    1142,
                    3183,
                    1144,
                    1145,
                    3190,
                    3191,
                    3192,
                    3193,
                    1152,
                    3201,
                    1154,
                    1155,
                    3205,
                    3208,
                    1162,
                    3212,
                    3213,
                    3215,
                    3218,
                    3219,
                    1172,
                    3222,
                    3223,
                    3224,
                    1182,
                    1183,
                    1187,
                    1189,
                    1191,
                    1196,
                    1200,
                    1202,
                    1206,
                    1209,
                    1211,
                    1213,
                    1215,
                    1219,
                    1224,
                    1225,
                    1227,
                    1230,
                    1231,
                    1232,
                    1233,
                    1234,
                    1235,
                    1236,
                    1237,
                    1239,
                    1242,
                    1243,
                    1244,
                    1245,
                    1246,
                    1247,
                    1248,
                    1249,
                    1254,
                    1255,
                    1259,
                    1260,
                    1261,
                    1266,
                    1267,
                    1268,
                    1269,
                    1270,
                    1271,
                    1273,
                    1274,
                    1276,
                    1277,
                    1279,
                    1281,
                    1284,
                    1285,
                    1287,
                    1291,
                    1292,
                    1297,
                    3349,
                    1302,
                    1307,
                    1308,
                    1309,
                    1312,
                    1313,
                    1315,
                    1316,
                    1317,
                    1320,
                    1322,
                    1324,
                    1331,
                    1334,
                    1336,
                    1338,
                    1342,
                    1346,
                    1349,
                    1353,
                    1354,
                    1357,
                    1358,
                    1359,
                    1362,
                    1364,
                    3121,
                    1369,
                    1375,
                    1379,
                    1389,
                    1392,
                    1394,
                    1395,
                    1398,
                    1399,
                    1401,
                    1402,
                    1403,
                    3128,
                    1405,
                    1406,
                    1409,
                    1410,
                    1413,
                    1416,
                    1417,
                    3131,
                    1419,
                    1420,
                    1422,
                    1423,
                    1425,
                    1428,
                    3134,
                    1433,
                    1434,
                    1437,
                    1438,
                    1439,
                    1440,
                    1443,
                    3136,
                    1445,
                    1447,
                    1450,
                    1451,
                    1453,
                    1455,
                    1456,
                    1462,
                    1463,
                    1464,
                    1466,
                    1471,
                    1474,
                    1490,
                    1491,
                    1508,
                    1509,
                    1510,
                    1511,
                    1512,
                    1516,
                    1518,
                    1520,
                    1522,
                    1524,
                    1526,
                    1528,
                    1531,
                    1533,
                    1534,
                    1535,
                    1538,
                    1539,
                    1540,
                    1547,
                    1548,
                    1550,
                    1551,
                    1552,
                    1554,
                    1557,
                    1558,
                    1559,
                    1560,
                    1562,
                    1566,
                    1569,
                    1572,
                    1577,
                    1582,
                    1584,
                    1588,
                    1590,
                    1592,
                    1594,
                    1601,
                    1604,
                    1607,
                    1615,
                    1622,
                    1627,
                    1630,
                    1633,
                    1634,
                    1635,
                    1662,
                    1663,
                    1666,
                    3184,
                    1697,
                    1699,
                    1703,
                    1708,
                    1726,
                    1727,
                    1728,
                    1729,
                    1731,
                    1732,
                    1733,
                    1734,
                    1735,
                    1793,
                    1804,
                    1815,
                    1816,
                    1818
                ],
                "catarray.name": [
                    588,
                    605
                ],
                "catarray": [
                    588,
                    605,
                    590
                ],
                "self._encoding": [
                    642,
                    3084,
                    3099,
                    1055,
                    1057,
                    2726,
                    2730,
                    3114,
                    2999,
                    1466,
                    2623,
                    3140,
                    3144,
                    2121,
                    2380,
                    589,
                    1375,
                    2144,
                    1379,
                    1007
                ],
                "categories": [
                    1760,
                    1762,
                    1764,
                    590,
                    591,
                    1755,
                    1758
                ],
                "catarray.cat.categories": [
                    590
                ],
                "catarray.cat": [
                    590
                ],
                "self.value_labels": [
                    592,
                    600,
                    591
                ],
                "np.arange": [
                    1577,
                    591
                ],
                "self.value_labels.sort": [
                    592
                ],
                "self.text_len": [
                    609,
                    610,
                    615,
                    593,
                    626,
                    664
                ],
                "self.off": [
                    609,
                    594,
                    667,
                    622
                ],
                "List": [
                    1186,
                    996,
                    1924,
                    2949,
                    1199,
                    594,
                    595,
                    596,
                    2290,
                    2291,
                    1208,
                    2234,
                    2136,
                    1180,
                    1150
                ],
                "self.val": [
                    611,
                    671,
                    595,
                    623
                ],
                "self.txt": [
                    612,
                    675,
                    596
                ],
                "self.n": [
                    613,
                    597,
                    626,
                    661
                ],
                "vl": [
                    611,
                    3174,
                    3175,
                    600,
                    601,
                    2462,
                    2463
                ],
                "category": [
                    608,
                    1760,
                    610,
                    612,
                    601,
                    602,
                    603,
                    1756,
                    1757,
                    1758
                ],
                "value_label_mismatch_doc.format": [
                    605
                ],
                "ValueLabelTypeMismatch": [
                    606
                ],
                "category.encode": [
                    608
                ],
                "self.off.append": [
                    609
                ],
                "self.val.append": [
                    611
                ],
                "self.txt.append": [
                    612
                ],
                "np.array": [
                    2162,
                    622,
                    623
                ],
                "self.len": [
                    626,
                    647
                ],
                "bio": [
                    3073,
                    3074,
                    643,
                    3075,
                    647,
                    2824,
                    3079,
                    653,
                    3085,
                    3086,
                    3087,
                    657,
                    661,
                    2837,
                    2840,
                    664,
                    3096,
                    2843,
                    668,
                    3099,
                    2846,
                    3100,
                    672,
                    3101,
                    2850,
                    3105,
                    676,
                    2853,
                    678,
                    679,
                    2854,
                    2856,
                    2857,
                    2986,
                    2988,
                    3115,
                    2990,
                    3116,
                    3117,
                    2993,
                    3122,
                    2996,
                    3129,
                    3130,
                    3003,
                    3131,
                    3147,
                    3149,
                    3150,
                    3151,
                    3033,
                    3034,
                    3035,
                    3173,
                    3177,
                    3178,
                    3179,
                    3063,
                    3065,
                    3066,
                    3067,
                    3071
                ],
                "BytesIO": [
                    3105,
                    643,
                    3173,
                    1030,
                    3079,
                    2824,
                    2986,
                    3122,
                    3063,
                    3096,
                    3071
                ],
                "null_byte": [
                    657,
                    676,
                    644
                ],
                "bio.write": [
                    3073,
                    647,
                    653,
                    3085,
                    657,
                    661,
                    2837,
                    2840,
                    664,
                    2843,
                    668,
                    3099,
                    2846,
                    672,
                    2850,
                    676,
                    2853,
                    2854,
                    3115,
                    2988,
                    2990,
                    2993,
                    2996,
                    3129,
                    3003,
                    3147,
                    3149,
                    3033,
                    3177,
                    3065
                ],
                "struct.pack": [
                    3073,
                    647,
                    2826,
                    2827,
                    657,
                    661,
                    2840,
                    664,
                    2843,
                    668,
                    672,
                    2850,
                    2472,
                    2480,
                    2993,
                    2482,
                    2996,
                    3001,
                    2522,
                    735,
                    736,
                    745,
                    746,
                    3065
                ],
                "byteorder": [
                    647,
                    2958,
                    3342,
                    661,
                    664,
                    668,
                    672,
                    2720,
                    2721,
                    2722,
                    2470,
                    2984,
                    2474,
                    2990,
                    2480,
                    2993,
                    2482,
                    2996,
                    3001,
                    2108,
                    2109,
                    2110
                ],
                "labname": [
                    1417,
                    650,
                    1419,
                    652,
                    653,
                    1434,
                    1437
                ],
                "encode": [
                    3114,
                    650,
                    3084,
                    2623
                ],
                "lab_len": [
                    651,
                    652
                ],
                "_pad_bytes": [
                    2529,
                    2534,
                    2552,
                    2602,
                    652,
                    2540,
                    2574,
                    2485,
                    2549,
                    2488,
                    2459,
                    2556
                ],
                "i": [
                    3200,
                    3201,
                    656,
                    1435,
                    1436,
                    1437,
                    2588,
                    2589,
                    2591,
                    1699,
                    3108,
                    1703,
                    2599,
                    2600,
                    3111,
                    3112,
                    2362,
                    2364,
                    1725,
                    1726,
                    1727,
                    1600,
                    1601,
                    1602,
                    835,
                    1604,
                    1728,
                    1729,
                    1607,
                    1357,
                    1359,
                    2512,
                    1361,
                    3025,
                    725,
                    726,
                    1623,
                    1624,
                    730,
                    1627,
                    733,
                    734,
                    740,
                    2790,
                    743,
                    744,
                    2791,
                    2544,
                    2546,
                    2547,
                    1661,
                    1662,
                    2559
                ],
                "offset": [
                    668,
                    1550,
                    1551,
                    1402,
                    1403,
                    667
                ],
                "text": [
                    675,
                    676
                ],
                "bio.seek": [
                    3074,
                    3066,
                    3130,
                    678,
                    2856,
                    3178,
                    3116,
                    3086,
                    3150,
                    3034,
                    3100
                ],
                "bio.read": [
                    3075,
                    3067,
                    679,
                    2857,
                    3131,
                    3179,
                    3117,
                    3087,
                    3151,
                    3035,
                    3101
                ],
                "MISSING_VALUES": [
                    742,
                    744,
                    720,
                    724,
                    726,
                    732,
                    734
                ],
                "Dict": [
                    2113,
                    2945,
                    1795,
                    1924,
                    2091,
                    2795,
                    1742,
                    1806,
                    720,
                    2096,
                    1395,
                    2963,
                    3318,
                    2743,
                    2233,
                    3323,
                    2940
                ],
                "bases": [
                    721,
                    722
                ],
                "b": [
                    1188,
                    1190,
                    1192,
                    1194,
                    1196,
                    1201,
                    722,
                    1203,
                    724,
                    1205,
                    726,
                    1206,
                    1182,
                    1183
                ],
                "float32_base": [
                    728,
                    736,
                    731,
                    752
                ],
                "increment": [
                    729,
                    739,
                    745,
                    735
                ],
                "key": [
                    1926,
                    1927,
                    1928,
                    1929,
                    1930,
                    1932,
                    1934,
                    2336,
                    2337,
                    2338,
                    2347,
                    2348,
                    2349,
                    2740,
                    731,
                    732,
                    734,
                    735,
                    2784,
                    2785,
                    2787,
                    2788,
                    741,
                    742,
                    2789,
                    744,
                    745
                ],
                "int_value": [
                    736,
                    745,
                    746,
                    735
                ],
                "float64_base": [
                    753,
                    738,
                    746,
                    741
                ],
                "BASE_MISSING_VALUES": [
                    748
                ],
                "Union": [
                    800,
                    1158,
                    775,
                    1833,
                    2668,
                    1742,
                    1806,
                    1168,
                    1395,
                    756,
                    1366,
                    2967,
                    1150
                ],
                "self._value": [
                    784,
                    757
                ],
                "self._str": [
                    760,
                    772
                ],
                "self.MISSING_VALUES": [
                    760,
                    897,
                    2179,
                    2181
                ],
                "self.string": [
                    795,
                    787
                ],
                "Any": [
                    792
                ],
                "other": [
                    794,
                    795,
                    796
                ],
                "other.string": [
                    795
                ],
                "self.value": [
                    796
                ],
                "other.value": [
                    796
                ],
                "np.dtype": [
                    800,
                    2338,
                    2626,
                    1604,
                    1351,
                    1899,
                    1168,
                    1362,
                    1938,
                    1150
                ],
                "cls.BASE_MISSING_VALUES": [
                    802,
                    804,
                    806,
                    808,
                    810
                ],
                "cls": [
                    802,
                    804,
                    806,
                    808,
                    810
                ],
                "self.DTYPE_MAP": [
                    834,
                    1302
                ],
                "self.DTYPE_MAP_XML": [
                    1172,
                    844
                ],
                "self.TYPE_MAP": [
                    1297,
                    854
                ],
                "self.TYPE_MAP_XML": [
                    1162,
                    855
                ],
                "float32_min": [
                    869,
                    878
                ],
                "float64_min": [
                    882,
                    871
                ],
                "self.VALID_RANGE": [
                    873,
                    1666,
                    1663
                ],
                "self.OLD_TYPE_MAPPING": [
                    1291,
                    1292,
                    887
                ],
                "self.NUMPY_TYPE_MAP": [
                    906,
                    1358,
                    1359
                ],
                "self.RESERVED_WORDS": [
                    916,
                    2246
                ],
                "StataParser": [
                    2019,
                    980
                ],
                "abc.Iterator": [
                    980
                ],
                "abc": [
                    980
                ],
                "FilePathOrBuffer": [
                    1857,
                    2089,
                    3316,
                    985,
                    2938,
                    1823
                ],
                "Optional": [
                    2944,
                    2945,
                    2946,
                    2711,
                    1826,
                    2467,
                    2468,
                    1829,
                    2980,
                    1831,
                    2981,
                    2091,
                    2093,
                    2094,
                    2095,
                    2096,
                    2114,
                    1476,
                    3324,
                    1496,
                    1497,
                    1498,
                    1499,
                    1500,
                    988,
                    1501,
                    1503,
                    1502,
                    993,
                    991,
                    3318,
                    3320,
                    3321,
                    3322,
                    3323,
                    2940,
                    3325,
                    2942,
                    2943
                ],
                "Sequence": [
                    2946,
                    1829,
                    1706,
                    1743,
                    2709,
                    3324,
                    1502,
                    991
                ],
                "__init__": [
                    2953,
                    2098,
                    995,
                    3337
                ],
                "self.col_sizes": [
                    996,
                    1069
                ],
                "self._convert_dates": [
                    2272,
                    2273,
                    2336,
                    2337,
                    1000,
                    2587,
                    2346,
                    2347,
                    1516,
                    2349,
                    2099,
                    2359,
                    2328,
                    2585,
                    2333,
                    2331,
                    2269,
                    2334
                ],
                "convert_dates": [
                    1926,
                    1927,
                    1000,
                    1928,
                    1930,
                    1515,
                    1516,
                    1837,
                    1934,
                    2956,
                    3340,
                    1617,
                    2099,
                    2359,
                    2585,
                    2364,
                    2589
                ],
                "self._convert_categoricals": [
                    1001,
                    1518
                ],
                "convert_categoricals": [
                    1633,
                    1001,
                    1546,
                    1517,
                    1518,
                    1838,
                    1565
                ],
                "self._index_col": [
                    1528,
                    1002
                ],
                "index_col": [
                    1576,
                    1002,
                    1839,
                    1653,
                    1654,
                    1527,
                    1528
                ],
                "self._convert_missing": [
                    1520,
                    1003
                ],
                "convert_missing": [
                    1673,
                    1003,
                    1615,
                    1520,
                    1519,
                    1840
                ],
                "self._preserve_dtypes": [
                    1522,
                    1004
                ],
                "preserve_dtypes": [
                    1638,
                    1004,
                    1521,
                    1522,
                    1841
                ],
                "self._columns": [
                    1524,
                    1005
                ],
                "columns": [
                    1690,
                    1693,
                    2718,
                    1580,
                    1709,
                    1582,
                    1710,
                    1842,
                    2234,
                    2235,
                    1724,
                    2238,
                    1737,
                    2257,
                    2775,
                    2264,
                    2777,
                    2266,
                    2270,
                    1005,
                    1523,
                    1524
                ],
                "self._order_categoricals": [
                    1526,
                    1006
                ],
                "order_categoricals": [
                    1635,
                    1006,
                    1843,
                    1525,
                    1526,
                    1754
                ],
                "self._chunksize": [
                    1008,
                    1490,
                    1474
                ],
                "chunksize": [
                    1008,
                    1844,
                    1847
                ],
                "self._has_string_data": [
                    1011
                ],
                "self._missing_values": [
                    1012
                ],
                "self._can_read_value_labels": [
                    1509,
                    1013,
                    1534,
                    1559
                ],
                "self._column_selector_set": [
                    1708,
                    1014,
                    1735
                ],
                "self._value_labels_read": [
                    1440,
                    1533,
                    1815,
                    1389,
                    1394,
                    1015,
                    1405
                ],
                "self._data_read": [
                    1016,
                    1560,
                    1510
                ],
                "self._dtype": [
                    1538,
                    1539,
                    1353,
                    1354,
                    1401,
                    1362,
                    1364,
                    1017,
                    1402
                ],
                "self._lines_read": [
                    1540,
                    1577,
                    1550,
                    1552,
                    1557,
                    1558,
                    1018
                ],
                "self._native_byteorder": [
                    1562,
                    1020
                ],
                "_set_endianness": [
                    2598,
                    2722,
                    1020,
                    2110
                ],
                "sys.byteorder": [
                    2721,
                    1020,
                    2109,
                    2598
                ],
                "sys": [
                    2721,
                    1020,
                    2109,
                    2598
                ],
                "path_or_buf": [
                    1025,
                    1026,
                    1027,
                    1029,
                    1021,
                    1022,
                    1023
                ],
                "stringify_path": [
                    1021,
                    2111
                ],
                "_": [
                    1215,
                    1313,
                    1155,
                    1219,
                    1285,
                    1196,
                    1211,
                    1206,
                    3128,
                    1023,
                    1309,
                    1183
                ],
                "should_close": [
                    1023
                ],
                "get_filepath_or_buffer": [
                    1023
                ],
                "self.path_or_buf": [
                    1026,
                    1030,
                    1551,
                    1554,
                    1046,
                    1060,
                    1073,
                    1074,
                    1078,
                    1079,
                    1080,
                    1084,
                    1086,
                    1089,
                    1091,
                    1093,
                    1094,
                    1095,
                    1098,
                    1101,
                    1104,
                    1107,
                    1110,
                    1116,
                    1118,
                    1121,
                    1124,
                    1129,
                    1132,
                    1135,
                    1138,
                    1141,
                    1144,
                    1152,
                    1154,
                    1183,
                    1196,
                    1206,
                    1211,
                    1215,
                    1219,
                    1225,
                    1227,
                    1231,
                    1232,
                    1234,
                    1235,
                    1237,
                    1239,
                    1243,
                    1244,
                    1246,
                    1247,
                    1249,
                    1255,
                    1261,
                    1271,
                    1273,
                    1274,
                    1276,
                    1285,
                    1287,
                    1309,
                    1313,
                    1317,
                    1334,
                    1338,
                    1342,
                    1346,
                    1349,
                    1399,
                    1403,
                    1410,
                    1413,
                    1417,
                    1419,
                    1420,
                    1422,
                    1423,
                    1425,
                    1428,
                    1433,
                    1439,
                    1443,
                    1447,
                    1451,
                    1453,
                    1462,
                    1463,
                    1464
                ],
                "IOBase": [
                    1027
                ],
                "contents": [
                    1029,
                    1030
                ],
                "path_or_buf.read": [
                    1029
                ],
                "self._read_header": [
                    1032
                ],
                "self._setup_dtype": [
                    1033
                ],
                "self.close": [
                    1511,
                    1548,
                    1584,
                    1041,
                    1630
                ],
                "self.path_or_buf.close": [
                    1046
                ],
                "self.format_version": [
                    1409,
                    1284,
                    1416,
                    1307,
                    1182,
                    1054,
                    1438,
                    1187,
                    1189,
                    1191,
                    1450,
                    1455,
                    1200,
                    1074,
                    1075,
                    1076,
                    1202,
                    1331,
                    1336,
                    1209,
                    1081,
                    1082,
                    1213,
                    1224,
                    1230,
                    1233,
                    1236,
                    1242,
                    1245,
                    1248,
                    1633,
                    1254,
                    1260,
                    1392,
                    1266,
                    1267,
                    1268,
                    1398,
                    1533
                ],
                "first_char": [
                    1064,
                    1266,
                    1060,
                    1061
                ],
                "self.path_or_buf.read": [
                    1154,
                    1410,
                    1285,
                    1413,
                    1287,
                    1417,
                    1419,
                    1420,
                    1422,
                    1423,
                    1425,
                    1554,
                    1428,
                    1433,
                    1309,
                    1183,
                    1439,
                    1313,
                    1060,
                    1317,
                    1447,
                    1451,
                    1196,
                    1453,
                    1462,
                    1073,
                    1074,
                    1078,
                    1079,
                    1080,
                    1206,
                    1334,
                    1211,
                    1084,
                    1338,
                    1086,
                    1215,
                    1342,
                    1089,
                    1346,
                    1091,
                    1219,
                    1093,
                    1094,
                    1095,
                    1463,
                    1225,
                    1098,
                    1227,
                    1464,
                    1101,
                    1231,
                    1104,
                    1232,
                    1234,
                    1107,
                    1235,
                    1237,
                    1110,
                    1239,
                    1243,
                    1116,
                    1244,
                    1118,
                    1246,
                    1247,
                    1121,
                    1249,
                    1124,
                    1255,
                    1261,
                    1135,
                    1271,
                    1273,
                    1274,
                    1276
                ],
                "self._read_new_header": [
                    1062
                ],
                "self._read_old_header": [
                    1064
                ],
                "self.has_string_data": [
                    1066
                ],
                "self.typlist": [
                    3072,
                    3201,
                    1699,
                    1732,
                    1127,
                    1066,
                    3212,
                    1357,
                    1069,
                    1297,
                    2291,
                    1588,
                    2294,
                    3223,
                    2584,
                    2521,
                    1662,
                    1727
                ],
                "self._calcsize": [
                    1069
                ],
                "typ": [
                    3072,
                    3073,
                    1159,
                    1160,
                    1162,
                    1164,
                    1169,
                    1170,
                    1297,
                    1172,
                    1174,
                    1302,
                    1699,
                    1700,
                    2600,
                    2601,
                    2602,
                    2603,
                    1069,
                    1588,
                    1589,
                    1462,
                    1465,
                    1357,
                    1358,
                    1359,
                    1361,
                    2521,
                    2522
                ],
                "_version_error.format": [
                    1076,
                    1268
                ],
                "self._set_encoding": [
                    1269,
                    1077
                ],
                "self.byteorder": [
                    1154,
                    1422,
                    1423,
                    1425,
                    1428,
                    1562,
                    1316,
                    1451,
                    1456,
                    1334,
                    1079,
                    1463,
                    1338,
                    1084,
                    1342,
                    1225,
                    1098,
                    1227,
                    1101,
                    1231,
                    1104,
                    1359,
                    1107,
                    1110,
                    1369,
                    1118,
                    1121,
                    1124,
                    1261,
                    1134,
                    1270,
                    1276
                ],
                "nvar_type": [
                    2992,
                    1081,
                    2993,
                    1084
                ],
                "nvar_size": [
                    1082,
                    1084
                ],
                "self.nvar": [
                    1155,
                    1285,
                    1287,
                    2320,
                    3092,
                    1309,
                    1183,
                    1313,
                    1316,
                    1317,
                    3108,
                    1196,
                    2480,
                    2993,
                    1206,
                    3128,
                    1211,
                    1083,
                    1215,
                    1219,
                    2534,
                    1259,
                    1134,
                    1135,
                    2544,
                    1276,
                    2559
                ],
                "self.nobs": [
                    1088,
                    1508,
                    1540,
                    1552,
                    2320,
                    2482,
                    2996,
                    1558,
                    1402,
                    1531,
                    1277
                ],
                "self._get_nobs": [
                    1088,
                    1277
                ],
                "self._data_label": [
                    1793,
                    1090,
                    2102,
                    2391,
                    1279
                ],
                "self._get_data_label": [
                    1090,
                    1279
                ],
                "self.time_stamp": [
                    1281,
                    1092
                ],
                "self._get_time_stamp": [
                    1281,
                    1092
                ],
                "self._seek_vartypes": [
                    1097,
                    1127
                ],
                "self._seek_varnames": [
                    1129,
                    1100
                ],
                "self._seek_sortlist": [
                    1132,
                    1103
                ],
                "self._seek_formats": [
                    1106,
                    1138
                ],
                "self._seek_value_label_names": [
                    1141,
                    1109,
                    1259
                ],
                "self._seek_variable_labels": [
                    1144,
                    1114
                ],
                "self._get_seek_variable_labels": [
                    1114
                ],
                "self.data_location": [
                    1403,
                    1349,
                    1117,
                    1551
                ],
                "self.seek_strls": [
                    1120,
                    1443
                ],
                "self.seek_value_labels": [
                    1123,
                    1399
                ],
                "self.dtyplist": [
                    1601,
                    1731,
                    1604,
                    1127,
                    1607,
                    1302,
                    1594,
                    1726
                ],
                "self._get_dtypes": [
                    1127
                ],
                "self.path_or_buf.seek": [
                    1152,
                    1443,
                    1129,
                    1132,
                    1551,
                    1138,
                    1141,
                    1399,
                    1144,
                    1403
                ],
                "self.varlist": [
                    1312,
                    1569,
                    1572,
                    1512,
                    3112,
                    1130,
                    3082,
                    1804,
                    2322,
                    2547,
                    1308,
                    2334,
                    2527
                ],
                "self._get_varlist": [
                    1130
                ],
                "self.srtlist": [
                    1315,
                    1133
                ],
                "self.fmtlist": [
                    1728,
                    1733,
                    1320,
                    2539,
                    2349,
                    3213,
                    2290,
                    1139,
                    2293,
                    1622,
                    3222,
                    3098,
                    1627,
                    2591
                ],
                "self._get_fmtlist": [
                    1320,
                    1139
                ],
                "self.lbllist": [
                    1729,
                    1635,
                    1734,
                    1322,
                    1142
                ],
                "self._get_lbllist": [
                    1322,
                    1142
                ],
                "self._variable_labels": [
                    3136,
                    2564,
                    2565,
                    1324,
                    1804,
                    3127,
                    2103,
                    1145,
                    2558,
                    3135
                ],
                "self._get_variable_labels": [
                    1145,
                    1324
                ],
                "seek_vartypes": [
                    1152
                ],
                "raw_typlist": [
                    1176,
                    1153,
                    1166
                ],
                "typlist": [
                    1732,
                    1285,
                    2600,
                    1289,
                    2584,
                    1292,
                    1166,
                    1294,
                    1297,
                    1299,
                    1302,
                    1304,
                    1721,
                    1178,
                    1727
                ],
                "dtyplist": [
                    1731,
                    1720,
                    1176,
                    1178,
                    1726
                ],
                "Tuple": [
                    1857,
                    2795,
                    2739,
                    2743,
                    1150
                ],
                "self._decode": [
                    1183,
                    1249,
                    1247,
                    1219,
                    1313,
                    1417,
                    1419,
                    1196,
                    1232,
                    1235,
                    1237,
                    1206,
                    1239,
                    1590,
                    1211,
                    1309,
                    1437,
                    1215
                ],
                "vlblist": [
                    1218,
                    1210,
                    1221,
                    1214
                ],
                "strlen": [
                    1231,
                    1232,
                    1234,
                    1235,
                    1243,
                    1244,
                    1246,
                    1247
                ],
                "decode": [
                    1466,
                    1244
                ],
                "self.filetype": [
                    1273
                ],
                "buf": [
                    1287,
                    1288,
                    1453,
                    1457,
                    1460,
                    1461
                ],
                "typlistb": [
                    1288,
                    1290
                ],
                "np.frombuffer": [
                    1288,
                    1553,
                    1427,
                    1424
                ],
                "tp": [
                    1290,
                    1291,
                    1292,
                    1294
                ],
                "typlist.append": [
                    1292,
                    1294,
                    1727
                ],
                "invalid_types": [
                    1299,
                    1300
                ],
                "join": [
                    1766,
                    2281,
                    1714,
                    1299,
                    1304
                ],
                "invalid_dtypes": [
                    1304,
                    1305
                ],
                "data_type": [
                    1344,
                    1333
                ],
                "data_len": [
                    1337,
                    1346,
                    1341
                ],
                "self.path_or_buf.tell": [
                    1349
                ],
                "dtypes": [
                    2338,
                    2597,
                    2343,
                    1356,
                    2604,
                    3214,
                    1359,
                    1361,
                    1362,
                    2610,
                    2292,
                    2324,
                    2612
                ],
                "dtypes.append": [
                    1361,
                    1359
                ],
                "struct.calcsize": [
                    1369
                ],
                "s": [
                    1386,
                    2623,
                    2619,
                    2620,
                    1373,
                    1375
                ],
                "s.partition": [
                    1373
                ],
                "s.decode": [
                    1386,
                    1375
                ],
                "msg": [
                    1380,
                    2278,
                    2279,
                    1768,
                    1385,
                    1779
                ],
                "self.value_label_dict": [
                    1635,
                    1395,
                    1434,
                    1818,
                    1437,
                    1406
                ],
                "self._dtype.itemsize": [
                    1402
                ],
                "slength": [
                    1413,
                    1414
                ],
                "n": [
                    1422,
                    1425,
                    1428,
                    1435,
                    1436
                ],
                "txtlen": [
                    1433,
                    1436,
                    1423
                ],
                "off": [
                    1424,
                    1430,
                    1431,
                    1436,
                    1437
                ],
                "val": [
                    2784,
                    2788,
                    3064,
                    1427,
                    3065,
                    1432,
                    2969,
                    2970,
                    2971,
                    2781,
                    1437,
                    2783
                ],
                "ii": [
                    1432,
                    1430,
                    1431
                ],
                "np.argsort": [
                    1430
                ],
                "txt": [
                    1433,
                    1437
                ],
                "end": [
                    1436,
                    1437
                ],
                "self.GSO": [
                    1697,
                    1703,
                    1445,
                    1471
                ],
                "v_o": [
                    1451,
                    1461,
                    1471
                ],
                "v_size": [
                    1457,
                    1460,
                    1455
                ],
                "length": [
                    1895,
                    1896,
                    2674,
                    1463,
                    1464
                ],
                "va": [
                    1464,
                    1466,
                    1469
                ],
                "decoded_va": [
                    1466,
                    1469,
                    1471
                ],
                "self.read": [
                    1474,
                    1491
                ],
                "size": [
                    1489,
                    1490,
                    1491
                ],
                "nrows": [
                    1508,
                    1541,
                    1552,
                    1530,
                    1531
                ],
                "self._read_strls": [
                    1535
                ],
                "max_read_len": [
                    1540,
                    1542
                ],
                "dtype.itemsize": [
                    1540,
                    1541,
                    1550
                ],
                "read_len": [
                    1554,
                    1541,
                    1542,
                    1543
                ],
                "self._read_value_labels": [
                    1816,
                    1547,
                    1566
                ],
                "read_lines": [
                    1552,
                    1577,
                    1554,
                    1557
                ],
                "newbyteorder": [
                    1563
                ],
                "data.byteswap": [
                    1563
                ],
                "DataFrame.from_records": [
                    1571
                ],
                "data.columns": [
                    1602,
                    1572,
                    2234,
                    2266,
                    1712,
                    2322,
                    1624,
                    1690,
                    1725
                ],
                "ix": [
                    1577,
                    1578,
                    1597,
                    1607
                ],
                "data.set_index": [
                    1578,
                    1654
                ],
                "self._do_select_columns": [
                    1582
                ],
                "apply": [
                    2602,
                    1590
                ],
                "self._insert_strls": [
                    1592
                ],
                "cols_": [
                    1600,
                    1594
                ],
                "np.where": [
                    1594,
                    1622
                ],
                "data.index": [
                    1781,
                    1597
                ],
                "requires_type_conversion": [
                    1611,
                    1605,
                    1598
                ],
                "data_formatted": [
                    1606,
                    1610,
                    1612,
                    1613,
                    2166,
                    2168,
                    2169,
                    2141,
                    1599
                ],
                "data_formatted.append": [
                    2168,
                    1610,
                    2166,
                    1606
                ],
                "DataFrame.from_dict": [
                    2169,
                    1785,
                    1651,
                    1612
                ],
                "self._do_convert_missing": [
                    1615
                ],
                "x.startswith": [
                    1620
                ],
                "cols": [
                    1622,
                    1623
                ],
                "any_startswith": [
                    1622
                ],
                "_stata_elapsed_date_to_datetime_vec": [
                    1626
                ],
                "self._do_convert_categoricals": [
                    1634
                ],
                "retyped_data": [
                    1649,
                    1651,
                    1639
                ],
                "convert": [
                    1640,
                    1650,
                    1648,
                    1645
                ],
                "np.float16": [
                    1643
                ],
                "retyped_data.append": [
                    1649
                ],
                "data.pop": [
                    1654
                ],
                "Appender": [
                    1821,
                    1493
                ],
                "replacements": [
                    1688,
                    1689,
                    1691,
                    1660
                ],
                "colname": [
                    1688,
                    1667,
                    1661
                ],
                "nmin": [
                    1666,
                    1668
                ],
                "nmax": [
                    1666,
                    1668
                ],
                "series": [
                    1667,
                    1668,
                    1675,
                    1676,
                    1683,
                    1686
                ],
                "missing": [
                    1668,
                    1670,
                    1674,
                    1675,
                    1687
                ],
                "np.logical_or": [
                    1668
                ],
                "missing.any": [
                    1670
                ],
                "missing_loc": [
                    1680,
                    1674
                ],
                "np.argwhere": [
                    1674
                ],
                "missing._ndarray_values": [
                    1674
                ],
                "umissing": [
                    1675,
                    1677
                ],
                "umissing_loc": [
                    1680,
                    1675
                ],
                "np.unique": [
                    1675
                ],
                "replacement": [
                    2179,
                    2181,
                    2182,
                    1676,
                    1681,
                    1686,
                    1687,
                    1688
                ],
                "j": [
                    2789,
                    1677,
                    1680,
                    2264,
                    2780,
                    2238
                ],
                "um": [
                    1677,
                    1678
                ],
                "StataMissingValue": [
                    2140,
                    1678
                ],
                "loc": [
                    1680,
                    1681
                ],
                "replacement.iloc": [
                    1681
                ],
                "series.dtype": [
                    1683
                ],
                "np.nan": [
                    1687
                ],
                "replacement_df": [
                    1691,
                    1692
                ],
                "replaced": [
                    1692,
                    1693
                ],
                "concat": [
                    1692
                ],
                "data.drop": [
                    1692
                ],
                "replacement_df.columns": [
                    1692
                ],
                "data.iloc": [
                    1703
                ],
                "k": [
                    1703
                ],
                "column_set": [
                    1712,
                    1709,
                    1710
                ],
                "unmatched": [
                    1712,
                    1713,
                    1714
                ],
                "column_set.difference": [
                    1712
                ],
                "joined": [
                    1714,
                    1717
                ],
                "fmtlist": [
                    1728,
                    1722,
                    1733
                ],
                "lbllist": [
                    1729,
                    1723,
                    1734,
                    1751
                ],
                "data.columns.get_loc": [
                    1725
                ],
                "dtyplist.append": [
                    1726
                ],
                "fmtlist.append": [
                    1728
                ],
                "lbllist.append": [
                    1729
                ],
                "value_labels": [
                    1752,
                    1749
                ],
                "value_label_dict.keys": [
                    1749
                ],
                "value_label_dict": [
                    1757,
                    1749,
                    1758
                ],
                "cat_converted_data": [
                    1782,
                    1785,
                    1784,
                    1750
                ],
                "label": [
                    3136,
                    3137,
                    3140,
                    2565,
                    2566,
                    2568,
                    2574,
                    2999,
                    2998,
                    1751,
                    1752,
                    1757,
                    1758
                ],
                "cat_data": [
                    1781,
                    1754,
                    1756,
                    1762
                ],
                "Categorical": [
                    1754
                ],
                "cat_data.categories": [
                    1762,
                    1756
                ],
                "categories.append": [
                    1760,
                    1758
                ],
                "vc": [
                    1764,
                    1765
                ],
                "value_counts": [
                    1764
                ],
                "repeated_cats": [
                    1765,
                    1766
                ],
                "vc.index": [
                    1765
                ],
                "repeats": [
                    1777,
                    1766
                ],
                "cat_series": [
                    1781,
                    1782
                ],
                "cat_converted_data.append": [
                    1784,
                    1782
                ],
                "reader": [
                    1848,
                    1851,
                    1835,
                    1853
                ],
                "StataReader": [
                    1833,
                    1835
                ],
                "filepath_or_buffer": [
                    1836
                ],
                "iterator": [
                    1847
                ],
                "reader.read": [
                    1851
                ],
                "reader.close": [
                    1853
                ],
                "fname": [
                    2954,
                    3338,
                    1872,
                    1874,
                    1875,
                    1876,
                    2111
                ],
                "Path": [
                    2411,
                    1875
                ],
                "BinaryIO": [
                    1857,
                    2114
                ],
                "endianness.lower": [
                    1882,
                    1884
                ],
                "endianness": [
                    1882,
                    1884,
                    1887
                ],
                "AnyStr": [
                    1890
                ],
                "name": [
                    3082,
                    3083,
                    3084,
                    3085,
                    2210,
                    3110,
                    3112,
                    2217,
                    2218,
                    3113,
                    3114,
                    3372,
                    3380,
                    3382,
                    2238,
                    2239,
                    2240,
                    2241,
                    2243,
                    2246,
                    2247,
                    2250,
                    2251,
                    2253,
                    2255,
                    2257,
                    2259,
                    2260,
                    2262,
                    2264,
                    2527,
                    2528,
                    2529,
                    2530,
                    2277,
                    1894,
                    1895,
                    1896,
                    2278,
                    2672,
                    2673,
                    2674,
                    2547,
                    2548,
                    2549,
                    2550
                ],
                "Label": [
                    2113,
                    2945,
                    2946,
                    1924,
                    2949,
                    2091,
                    2096,
                    3324,
                    3318,
                    2233,
                    2234,
                    3323,
                    2940
                ],
                "new_dict": [
                    1930,
                    1925,
                    1934,
                    1935
                ],
                "startswith": [
                    1927
                ],
                "varlist": [
                    1929,
                    1930
                ],
                "new_dict.update": [
                    1930,
                    1934
                ],
                "varlist.index": [
                    1930
                ],
                "dtype.type": [
                    2368,
                    1955,
                    2646,
                    1999
                ],
                "np.object_": [
                    2368,
                    1955,
                    2646,
                    1999
                ],
                "itemsize": [
                    1958,
                    1959,
                    2000,
                    2001,
                    2006,
                    2649,
                    2650,
                    2651,
                    2652
                ],
                "max_len_string_array": [
                    2000,
                    2649,
                    1958,
                    2383
                ],
                "ensure_object": [
                    2000,
                    2649,
                    1958,
                    2383
                ],
                "column.values": [
                    2000,
                    2649,
                    1958
                ],
                "column": [
                    2369,
                    2370,
                    2371,
                    1958,
                    2000,
                    2005,
                    2649,
                    2366,
                    2367
                ],
                "dta_version": [
                    1993,
                    2002
                ],
                "max_str_len": [
                    2001,
                    1994,
                    1996
                ],
                "force_strl": [
                    1997,
                    3215,
                    3220,
                    2644,
                    3224
                ],
                "excessive_string_length_error.format": [
                    2005
                ],
                "column.name": [
                    2371,
                    2005
                ],
                "_max_string_length": [
                    2084,
                    2933
                ],
                "_encoding": [
                    3312,
                    2085
                ],
                "self._write_index": [
                    2100,
                    2302
                ],
                "write_index": [
                    3341,
                    2100,
                    2957
                ],
                "self._time_stamp": [
                    2101,
                    2391
                ],
                "time_stamp": [
                    3008,
                    2959,
                    3343,
                    2514,
                    2515,
                    2516,
                    2101,
                    3006,
                    3027,
                    3028,
                    3029,
                    2492,
                    2493,
                    2494,
                    3007
                ],
                "data_label": [
                    2960,
                    3344,
                    2484,
                    2102,
                    2998,
                    2488
                ],
                "variable_labels": [
                    2961,
                    3345,
                    2103
                ],
                "self._own_file": [
                    2104,
                    2409,
                    2389,
                    2438
                ],
                "self._prepare_pandas": [
                    2106
                ],
                "self._byteorder": [
                    3073,
                    2722,
                    2598,
                    2470,
                    2984,
                    3175,
                    2826,
                    2827,
                    2828,
                    2829,
                    2830,
                    2609,
                    3065,
                    2110,
                    2463
                ],
                "self._fname": [
                    2411,
                    2412,
                    2415,
                    2389,
                    2111
                ],
                "self.type_converters": [
                    2112
                ],
                "self._converted_names": [
                    2113,
                    2284,
                    3190
                ],
                "self._file": [
                    2976,
                    2433,
                    2114,
                    2435,
                    3041,
                    3046,
                    2439,
                    2120,
                    2121,
                    2127,
                    2128,
                    2389,
                    3062,
                    2975
                ],
                "self._file.write": [
                    2128,
                    2121
                ],
                "to_write.encode": [
                    2121
                ],
                "to_write": [
                    2121
                ],
                "is_cat": [
                    2142,
                    2137,
                    2134,
                    2135
                ],
                "is_categorical_dtype": [
                    2134
                ],
                "self._is_col_cat": [
                    2546,
                    3111,
                    2135
                ],
                "self._value_labels": [
                    2136,
                    2145,
                    3174,
                    2462
                ],
                "StataValueLabel": [
                    2136,
                    2144
                ],
                "get_base_missing_value": [
                    2155,
                    2140,
                    2165
                ],
                "StataMissingValue.get_base_missing_value": [
                    2140
                ],
                "col_is_cat": [
                    2142,
                    2143
                ],
                "svl": [
                    2144,
                    2145
                ],
                "self._value_labels.append": [
                    2145
                ],
                "cat.codes.dtype": [
                    2146
                ],
                "cat.codes": [
                    2152,
                    2146
                ],
                "cat": [
                    2152,
                    2146
                ],
                "cat.codes.values.copy": [
                    2152
                ],
                "cat.codes.values": [
                    2152
                ],
                "values.max": [
                    2155
                ],
                "c": [
                    2176,
                    2182,
                    2568,
                    2210,
                    2212,
                    2213,
                    2214,
                    2215,
                    2217,
                    3372,
                    3374,
                    3375,
                    3376,
                    3377,
                    3378,
                    3379,
                    3380,
                    2270,
                    2271,
                    2272,
                    2175
                ],
                "fillna": [
                    2602,
                    2182
                ],
                "name.replace": [
                    2217,
                    3380
                ],
                "converted_names": [
                    2275,
                    2277,
                    2284,
                    2262,
                    2233
                ],
                "original_columns": [
                    2235,
                    2270
                ],
                "duplicate_var_id": [
                    2261,
                    2259,
                    2237
                ],
                "orig_name": [
                    2277,
                    2278,
                    2255,
                    2262,
                    2239
                ],
                "self._validate_variable_name": [
                    2243
                ],
                "columns.count": [
                    2257
                ],
                "Index": [
                    2266
                ],
                "o": [
                    2272,
                    2273,
                    2843,
                    2787,
                    2789,
                    2834,
                    2740,
                    2741,
                    2779,
                    2270,
                    2271
                ],
                "conversion_warning": [
                    2281,
                    2276,
                    2279
                ],
                "converted_names.items": [
                    2277
                ],
                "conversion_warning.append": [
                    2279
                ],
                "invalid_name_doc.format": [
                    2281
                ],
                "InvalidColumnName": [
                    2282
                ],
                "self._update_strl_names": [
                    2285
                ],
                "dtypes.items": [
                    2292,
                    3214
                ],
                "self.fmtlist.append": [
                    2293,
                    3222
                ],
                "_dtype_to_default_stata_fmt": [
                    3216,
                    2293
                ],
                "self.data": [
                    2563,
                    2380,
                    2321,
                    2386,
                    3218,
                    2293,
                    2294,
                    2583,
                    3134,
                    2362,
                    3224,
                    2366
                ],
                "self.typlist.append": [
                    2294,
                    3223
                ],
                "_dtype_to_stata_type": [
                    2294
                ],
                "data.copy": [
                    2300
                ],
                "temp": [
                    2304,
                    2305,
                    2303
                ],
                "data.reset_index": [
                    2303
                ],
                "self._check_column_names": [
                    2308
                ],
                "_cast_to_stata_types": [
                    2312
                ],
                "self._replace_nans": [
                    2315
                ],
                "self._prepare_categoricals": [
                    2318
                ],
                "data.shape": [
                    2320,
                    3328,
                    3331
                ],
                "data.columns.tolist": [
                    2322
                ],
                "data.dtypes": [
                    2324
                ],
                "_maybe_convert_to_int_keys": [
                    2333
                ],
                "new_type": [
                    2337,
                    2338
                ],
                "_convert_datetime_to_stata_type": [
                    2337
                ],
                "self._encode_strings": [
                    2341
                ],
                "self._set_formats_and_types": [
                    2343
                ],
                "convert_strl": [
                    2950,
                    2951,
                    3346,
                    2361,
                    2364
                ],
                "column.dtype": [
                    2367
                ],
                "inferred_dtype": [
                    2369,
                    2370
                ],
                "encoded": [
                    3140,
                    3147,
                    2380,
                    2383,
                    2386
                ],
                "str.encode": [
                    2380
                ],
                "encoded.values": [
                    2383
                ],
                "self._max_string_length": [
                    2384,
                    2601
                ],
                "_open_file_binary_write": [
                    2389
                ],
                "self._write_header": [
                    2391
                ],
                "self._write_map": [
                    2392,
                    2406
                ],
                "self._write_variable_types": [
                    2393
                ],
                "self._write_varnames": [
                    2394
                ],
                "self._write_sortlist": [
                    2395
                ],
                "self._write_formats": [
                    2396
                ],
                "self._write_value_label_names": [
                    2397
                ],
                "self._write_variable_labels": [
                    2398
                ],
                "self._write_expansion_fields": [
                    2399
                ],
                "self._write_characteristics": [
                    2400
                ],
                "records": [
                    3160,
                    2401,
                    2402,
                    2615
                ],
                "self._prepare_data": [
                    2401
                ],
                "self._write_data": [
                    2402
                ],
                "self._write_strls": [
                    2403
                ],
                "self._write_value_labels": [
                    2404
                ],
                "self._write_file_close_tag": [
                    2405
                ],
                "self._close": [
                    2408,
                    2421
                ],
                "os.unlink": [
                    2412
                ],
                "os": [
                    2412
                ],
                "exc": [
                    2419
                ],
                "self._file.flush": [
                    2435
                ],
                "self._file.close": [
                    2439
                ],
                "self._write": [
                    2560,
                    2530,
                    2535,
                    2474,
                    2476,
                    2540,
                    2478,
                    2574,
                    2576,
                    2550,
                    2552,
                    2459
                ],
                "self._write_bytes": [
                    3075,
                    3087,
                    3092,
                    3101,
                    2463,
                    2472,
                    2985,
                    3117,
                    2480,
                    2482,
                    2485,
                    2615,
                    2487,
                    3131,
                    3151,
                    3155,
                    2518,
                    3159,
                    3160,
                    3161,
                    2522,
                    3035,
                    3165,
                    3179,
                    3183,
                    3067
                ],
                "vl.generate_value_label": [
                    3175,
                    2463
                ],
                "self._null_terminate_bytes": [
                    2488,
                    2485,
                    2518
                ],
                "datetime.datetime.now": [
                    2493,
                    3007
                ],
                "months": [
                    2512,
                    3025,
                    2498,
                    3011
                ],
                "month_lookup": [
                    2512,
                    3025,
                    2515,
                    3028
                ],
                "ts": [
                    3032,
                    2513,
                    3026,
                    2518
                ],
                "time_stamp.strftime": [
                    2514,
                    3027,
                    2516,
                    3029
                ],
                "time_stamp.month": [
                    2515,
                    3028
                ],
                "self._null_terminate_str": [
                    2528,
                    3113,
                    3083,
                    2548,
                    2623
                ],
                "srtlist": [
                    2534,
                    2535
                ],
                "blank": [
                    2560,
                    3149,
                    2576,
                    3125,
                    3129,
                    2556
                ],
                "is_latin1": [
                    2568,
                    2569
                ],
                "_datetime_to_stata_elapsed_vec": [
                    2590
                ],
                "self._convert_strls": [
                    2594
                ],
                "native_byteorder": [
                    2608,
                    2598
                ],
                "stype": [
                    2603,
                    2604,
                    2605
                ],
                "dtype.newbyteorder": [
                    2609
                ],
                "data.to_records": [
                    2612
                ],
                "np.recarray": [
                    2614,
                    2582
                ],
                "records.tobytes": [
                    3160,
                    2615
                ],
                "version": [
                    3328,
                    3329,
                    3331,
                    2727,
                    2731,
                    3349,
                    2713,
                    2715,
                    3327
                ],
                "self._dta_ver": [
                    2715
                ],
                "self.df": [
                    2717,
                    2774
                ],
                "df": [
                    2717
                ],
                "self.columns": [
                    2776,
                    2777,
                    2718,
                    2790
                ],
                "self._gso_table": [
                    2773,
                    2719
                ],
                "gso_v_type": [
                    2737,
                    2724
                ],
                "gso_o_type": [
                    2736,
                    2729,
                    2725
                ],
                "o_size": [
                    2728,
                    2732,
                    2734,
                    2735
                ],
                "self._o_offet": [
                    2741,
                    2735
                ],
                "self._gso_o_type": [
                    2736,
                    2829
                ],
                "self._gso_v_type": [
                    2737,
                    2828
                ],
                "gso_table": [
                    2784,
                    2788,
                    2793,
                    2831,
                    2773
                ],
                "gso_df": [
                    2791,
                    2793,
                    2774,
                    2775,
                    2776
                ],
                "gso_df.columns": [
                    2775
                ],
                "selected": [
                    2776,
                    2778,
                    2779
                ],
                "col_index": [
                    2777,
                    2780
                ],
                "columns.index": [
                    2777
                ],
                "keys": [
                    2778,
                    2789,
                    2791
                ],
                "np.empty": [
                    2778
                ],
                "selected.shape": [
                    2778
                ],
                "np.uint64": [
                    2778
                ],
                "idx": [
                    3192,
                    3193,
                    2779
                ],
                "row": [
                    2779,
                    2781
                ],
                "selected.iterrows": [
                    2779
                ],
                "gso_table.get": [
                    2784
                ],
                "self._convert_key": [
                    2789
                ],
                "gso": [
                    2825,
                    2837
                ],
                "gso_type": [
                    2826,
                    2846
                ],
                "null": [
                    2827,
                    2854
                ],
                "v_type": [
                    2840,
                    2828
                ],
                "o_type": [
                    2843,
                    2829
                ],
                "len_type": [
                    2850,
                    2830
                ],
                "strl": [
                    2849,
                    2831
                ],
                "vo": [
                    2832,
                    2834,
                    2831
                ],
                "gso_table.items": [
                    2831
                ],
                "utf8_string": [
                    2849,
                    2850,
                    2853
                ],
                "StataWriter": [
                    2860
                ],
                "_dta_version": [
                    2934
                ],
                "self._convert_strl": [
                    3201,
                    2949,
                    2951,
                    3215,
                    3191,
                    3192,
                    3193
                ],
                "self._convert_strl.extend": [
                    2951
                ],
                "self._map": [
                    2976,
                    3042,
                    3043,
                    2963,
                    3062,
                    3064
                ],
                "self._strl_blob": [
                    3208,
                    2964,
                    3165
                ],
                "tag": [
                    2976,
                    2971
                ],
                "self._file.tell": [
                    2976,
                    3046
                ],
                "self._tag": [
                    3075,
                    3087,
                    3092,
                    3101,
                    2988,
                    3117,
                    2990,
                    2993,
                    2996,
                    3131,
                    3003,
                    3151,
                    3155,
                    3033,
                    3035,
                    3165,
                    3176,
                    3179,
                    3067
                ],
                "self._dta_version": [
                    3107,
                    3205,
                    3081,
                    2988,
                    2992,
                    2995,
                    3091,
                    3124,
                    3219,
                    3349,
                    3000,
                    3097
                ],
                "nobs_size": [
                    2995,
                    2996
                ],
                "encoded_label": [
                    3001,
                    3002,
                    3003,
                    2999
                ],
                "label.encode": [
                    3140,
                    2999
                ],
                "label_size": [
                    3000,
                    3001
                ],
                "label_len": [
                    3001,
                    3002
                ],
                "stata_ts": [
                    3032,
                    3033
                ],
                "self._file.seek": [
                    3062
                ],
                "self._map.values": [
                    3064
                ],
                "self._update_map": [
                    3104,
                    3172,
                    3078,
                    3182,
                    3184,
                    3121,
                    3090,
                    3154,
                    3158,
                    3095,
                    3164,
                    3070
                ],
                "vn_len": [
                    3081,
                    3084
                ],
                "_pad_bytes_new": [
                    3114,
                    3147,
                    3084,
                    3125,
                    3099
                ],
                "sort_size": [
                    3091,
                    3092
                ],
                "fmt_len": [
                    3097,
                    3099
                ],
                "fmt.encode": [
                    3099
                ],
                "vl_len": [
                    3107,
                    3114,
                    3147,
                    3124,
                    3125
                ],
                "encoded_name": [
                    3114,
                    3115
                ],
                "lab": [
                    3176,
                    3177,
                    3175
                ],
                "orig": [
                    3192,
                    3190,
                    3191
                ],
                "new": [
                    3193,
                    3190
                ],
                "self._converted_names.items": [
                    3190
                ],
                "self._convert_strl.index": [
                    3192
                ],
                "convert_cols": [
                    3204,
                    3205,
                    3198
                ],
                "ssw": [
                    3208,
                    3205,
                    3206
                ],
                "StataStrLWriter": [
                    3205
                ],
                "tab": [
                    3208,
                    3206
                ],
                "new_data": [
                    3206,
                    3207
                ],
                "ssw.generate_table": [
                    3206
                ],
                "ssw.generate_blob": [
                    3208
                ],
                "_dtype_to_stata_type_117": [
                    3224
                ],
                "StataWriter117": [
                    3228
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x11933d880>\nindex = Float64Index([-383655.8021966766,  59791.40122331827,  72903.99110115197,\n              103053.77429687868, 220789.48582566515],\n             dtype='float64')\nobj = -383655.802197    0\n 59791.401223     0\n 72903.991101     2\n 103053.774297    0\n 220789.485826    0\ndtype: int64\nidxr = -383655.802197    0\n 59791.401223     0\n 72903.991101     2\n 103053.774297    0\n 220789.485826    0\ndtype: int64\nidxr_id = 'setitem'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x118f818b0>\nindex = Index(['bueAjsm5hm', 'oCnLcUYyBq', 'WHsBZpsI9J', 'aBzhj9RXsW', 'kWxBuRuods'], dtype='object')\nobj = bueAjsm5hm    0\noCnLcUYyBq    1\nWHsBZpsI9J    0\naBzhj9RXsW    0\nkWxBuRuods    0\ndtype: int64\nidxr = bueAjsm5hm    0\noCnLcUYyBq    1\nWHsBZpsI9J    0\naBzhj9RXsW    0\nkWxBuRuods    0\ndtype: int64\nidxr_id = 'setitem'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x1190c5b80>\nindex = Index(['\u05dc\u05e9\u05d783\u05e5\u05d2\u05dc\u05d3\u05db', '\u05de\u05d8\u05d0\u05db4\u05df\u05db\u05d8\u05d8\u05e5', '\u05d8\u05da\u05e4\u05e22\u05d3\u05d8\u05e83\u05d4', '5\u05d8\u05d8\u05d4\u05d0\u05e7\u05e8\u05d353', '\u05d132\u05e67\u05d5\u05df\u05d6\u05d76'], dtype='object')\nobj = \u05dc\u05e9\u05d783\u05e5\u05d2\u05dc\u05d3\u05db    0\n\u05de\u05d8\u05d0\u05db4\u05df\u05db\u05d8\u05d8\u05e5    0\n\u05d8\u05da\u05e4\u05e22\u05d3\u05d8\u05e83\u05d4    0\n5\u05d8\u05d8\u05d4\u05d0\u05e7\u05e8\u05d353    0\n\u05d132\u05e67\u05d5\u05df\u05d6\u05d76    0\ndtype: int64\nidxr = \u05dc\u05e9\u05d783\u05e5\u05d2\u05dc\u05d3\u05db    0\n\u05de\u05d8\u05d0\u05db4\u05df\u05db\u05d8\u05d8\u05e5    0\n\u05d8\u05da\u05e4\u05e22\u05d3\u05d8\u05e83\u05d4    0\n5\u05d8\u05d8\u05d4\u05d0\u05e7\u05e8\u05d353    0\n\u05d132\u05e67\u05d5\u05df\u05d6\u05d76    0\ndtype: int64\nidxr_id = 'setitem'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x118f9ed60>\nindex = DatetimeIndex(['2000-01-03', '2000-01-04', '2000-01-05', '2000-01-06',\n               '2000-01-07'],\n              dtype='datetime64[ns]', freq='B')\nobj = 2000-01-03    0\n2000-01-04    0\n2000-01-05    0\n2000-01-06    0\n2000-01-07    4\nFreq: B, dtype: int64\nidxr = 2000-01-03    0\n2000-01-04    0\n2000-01-05    0\n2000-01-06    0\n2000-01-07    4\nFreq: B, dtype: int64\nidxr_id = 'setitem'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x1190c59d0>\nindex = PeriodIndex(['2000-01-03', '2000-01-04', '2000-01-05', '2000-01-06',\n             '2000-01-07'],\n            dtype='period[B]', freq='B')\nobj = 2000-01-03    0\n2000-01-04    0\n2000-01-05    0\n2000-01-06    0\n2000-01-07    0\nFreq: B, dtype: int64\nidxr = 2000-01-03    0\n2000-01-04    0\n2000-01-05    0\n2000-01-06    0\n2000-01-07    0\nFreq: B, dtype: int64\nidxr_id = 'setitem'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x119337070>\nindex = TimedeltaIndex(['1 days', '2 days', '3 days', '4 days', '5 days'], dtype='timedelta64[ns]', freq='D')\nobj = 1 days    0\n2 days    0\n3 days    0\n4 days    0\n5 days    0\nFreq: D, dtype: int64\nidxr = 1 days    0\n2 days    0\n3 days    0\n4 days    0\n5 days    0\nFreq: D, dtype: int64\nidxr_id = 'setitem'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x11914d3d0>\nindex = Index([False, True, False, False, False], dtype='object')\nobj = False    0\nTrue     0\nFalse    0\nFalse    0\nFalse    0\ndtype: int64\nidxr = False    0\nTrue     0\nFalse    0\nFalse    0\nFalse    0\ndtype: int64\nidxr_id = 'setitem'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x118f93070>\nindex = CategoricalIndex(['dfSH', 'jp1n', 'Q5aL', 'dfSH', 'jp1n'], categories=['dfSH', 'jp1n', 'Q5aL'], ordered=False, dtype='category')\nobj = dfSH    0\njp1n    0\nQ5aL    0\ndfSH    0\njp1n    0\ndtype: int64\nidxr = dfSH    0\njp1n    0\nQ5aL    0\ndfSH    0\njp1n    0\ndtype: int64\nidxr_id = 'setitem'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x1195435b0>\nindex = Int64Index([0, 1, 2, 3, 4], dtype='int64')\nobj = 0    0\n1    0\n2    0\n3    0\n4    0\ndtype: int64\nidxr = <pandas.core.indexing._iLocIndexer object at 0x119008090>\nidxr_id = 'iloc'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x119016370>\nindex = Float64Index([-383655.8021966766,  59791.40122331827,  72903.99110115197,\n              103053.77429687868, 220789.48582566515],\n             dtype='float64')\nobj = -383655.802197    0\n 59791.401223     0\n 72903.991101     2\n 103053.774297    0\n 220789.485826    0\ndtype: int64\nidxr = <pandas.core.indexing._iLocIndexer object at 0x1190082c0>\nidxr_id = 'iloc'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x11914d280>\nindex = Index(['bueAjsm5hm', 'oCnLcUYyBq', 'WHsBZpsI9J', 'aBzhj9RXsW', 'kWxBuRuods'], dtype='object')\nobj = bueAjsm5hm    0\noCnLcUYyBq    0\nWHsBZpsI9J    0\naBzhj9RXsW    0\nkWxBuRuods    0\ndtype: int64\nidxr = <pandas.core.indexing._iLocIndexer object at 0x1190089a0>\nidxr_id = 'iloc'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x11933ed00>\nindex = Index(['\u05dc\u05e9\u05d783\u05e5\u05d2\u05dc\u05d3\u05db', '\u05de\u05d8\u05d0\u05db4\u05df\u05db\u05d8\u05d8\u05e5', '\u05d8\u05da\u05e4\u05e22\u05d3\u05d8\u05e83\u05d4', '5\u05d8\u05d8\u05d4\u05d0\u05e7\u05e8\u05d353', '\u05d132\u05e67\u05d5\u05df\u05d6\u05d76'], dtype='object')\nobj = \u05dc\u05e9\u05d783\u05e5\u05d2\u05dc\u05d3\u05db    0\n\u05de\u05d8\u05d0\u05db4\u05df\u05db\u05d8\u05d8\u05e5    0\n\u05d8\u05da\u05e4\u05e22\u05d3\u05d8\u05e83\u05d4    2\n5\u05d8\u05d8\u05d4\u05d0\u05e7\u05e8\u05d353    0\n\u05d132\u05e67\u05d5\u05df\u05d6\u05d76    0\ndtype: int64\nidxr = <pandas.core.indexing._iLocIndexer object at 0x119004c70>\nidxr_id = 'iloc'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x1190c54f0>\nindex = DatetimeIndex(['2000-01-03', '2000-01-04', '2000-01-05', '2000-01-06',\n               '2000-01-07'],\n              dtype='datetime64[ns]', freq='B')\nobj = 2000-01-03    0\n2000-01-04    0\n2000-01-05    0\n2000-01-06    0\n2000-01-07    4\nFreq: B, dtype: int64\nidxr = <pandas.core.indexing._iLocIndexer object at 0x119004db0>\nidxr_id = 'iloc'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x118f93e20>\nindex = PeriodIndex(['2000-01-03', '2000-01-04', '2000-01-05', '2000-01-06',\n             '2000-01-07'],\n            dtype='period[B]', freq='B')\nobj = 2000-01-03    0\n2000-01-04    0\n2000-01-05    2\n2000-01-06    3\n2000-01-07    0\nFreq: B, dtype: int64\nidxr = <pandas.core.indexing._iLocIndexer object at 0x118fee4a0>\nidxr_id = 'iloc'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x118f81550>\nindex = TimedeltaIndex(['1 days', '2 days', '3 days', '4 days', '5 days'], dtype='timedelta64[ns]', freq='D')\nobj = 1 days    0\n2 days    0\n3 days    0\n4 days    0\n5 days    4\nFreq: D, dtype: int64\nidxr = <pandas.core.indexing._iLocIndexer object at 0x119004810>\nidxr_id = 'iloc'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x119149100>\nindex = Index([False, True, False, False, False], dtype='object')\nobj = False    0\nTrue     0\nFalse    0\nFalse    0\nFalse    0\ndtype: int64\nidxr = <pandas.core.indexing._iLocIndexer object at 0x119004f40>\nidxr_id = 'iloc'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x1191b8610>\nindex = RangeIndex(start=0, stop=5, step=1)\nobj = 0    0\n1    1\n2    0\n3    0\n4    0\ndtype: int64\nidxr = <pandas.core.indexing._iLocIndexer object at 0x118fee9f0>\nidxr_id = 'iloc'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x118f81850>\nindex = IntervalIndex([(0.0, 20.0], (20.0, 40.0], (40.0, 60.0], (60.0, 80.0], (80.0, 100.0]],\n              closed='right',\n              dtype='interval[float64]')\nobj = (0.0, 20.0]      0\n(20.0, 40.0]     0\n(40.0, 60.0]     0\n(60.0, 80.0]     0\n(80.0, 100.0]    0\ndtype: int64\nidxr = <pandas.core.indexing._iLocIndexer object at 0x1191bb400>\nidxr_id = 'iloc'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x11933e7f0>\nindex = CategoricalIndex(['dfSH', 'jp1n', 'Q5aL', 'dfSH', 'jp1n'], categories=['dfSH', 'jp1n', 'Q5aL'], ordered=False, dtype='category')\nobj = dfSH    0\njp1n    0\nQ5aL    0\ndfSH    0\njp1n    4\ndtype: int64\nidxr = <pandas.core.indexing._iLocIndexer object at 0x119570450>\nidxr_id = 'iloc'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x118f9e100>\nindex = Int64Index([0, 1, 2, 3, 4], dtype='int64')\nobj =           0         1         2         3         4\n0  0.000000  0.000000  0.000000  0.000000  0.000000\n1  0.000000  0...00000  0.000000\n3  0.541105 -0.647605  0.773346 -0.620922  1.212095\n4  0.000000  0.000000  0.000000  0.000000  0.000000\nidxr = <pandas.core.indexing._iLocIndexer object at 0x119571ef0>\nidxr_id = 'iloc'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x11953ff10>\nindex = Float64Index([-383655.8021966766,  59791.40122331827,  72903.99110115197,\n              103053.77429687868, 220789.48582566515],\n             dtype='float64')\nobj =                 -383655.802197   59791.401223   ...   103053.774297   220789.485826\n-383655.802197             0.0    ...          0.0\n 220789.485826             0.0             0.0  ...             0.0             0.0\n\n[5 rows x 5 columns]\nidxr = <pandas.core.indexing._iLocIndexer object at 0x1195a7c70>\nidxr_id = 'iloc'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x119543f10>\nindex = Index(['bueAjsm5hm', 'oCnLcUYyBq', 'WHsBZpsI9J', 'aBzhj9RXsW', 'kWxBuRuods'], dtype='object')\nobj =             bueAjsm5hm  oCnLcUYyBq  WHsBZpsI9J  aBzhj9RXsW  kWxBuRuods\nbueAjsm5hm         0.0         0.0         0.0 ...         0.0         0.0         0.0         0.0\nkWxBuRuods         0.0         0.0         0.0         0.0         0.0\nidxr = <pandas.core.indexing._iLocIndexer object at 0x119571db0>\nidxr_id = 'iloc'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x11916a730>\nindex = Index(['\u05dc\u05e9\u05d783\u05e5\u05d2\u05dc\u05d3\u05db', '\u05de\u05d8\u05d0\u05db4\u05df\u05db\u05d8\u05d8\u05e5', '\u05d8\u05da\u05e4\u05e22\u05d3\u05d8\u05e83\u05d4', '5\u05d8\u05d8\u05d4\u05d0\u05e7\u05e8\u05d353', '\u05d132\u05e67\u05d5\u05df\u05d6\u05d76'], dtype='object')\nobj =             \u05dc\u05e9\u05d783\u05e5\u05d2\u05dc\u05d3\u05db  \u05de\u05d8\u05d0\u05db4\u05df\u05db\u05d8\u05d8\u05e5  \u05d8\u05da\u05e4\u05e22\u05d3\u05d8\u05e83\u05d4  5\u05d8\u05d8\u05d4\u05d0\u05e7\u05e8\u05d353  \u05d132\u05e67\u05d5\u05df\u05d6\u05d76\n\u05dc\u05e9\u05d783\u05e5\u05d2\u05dc\u05d3\u05db    0.000000    0.000000    0.000000 ...   -0.588587    1.117080    0.206391    0.164604\n\u05d132\u05e67\u05d5\u05df\u05d6\u05d76    0.000000    0.000000    0.000000    0.000000    0.000000\nidxr = <pandas.core.indexing._iLocIndexer object at 0x119211770>\nidxr_id = 'iloc'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x11902fb80>\nindex = DatetimeIndex(['2000-01-03', '2000-01-04', '2000-01-05', '2000-01-06',\n               '2000-01-07'],\n              dtype='datetime64[ns]', freq='B')\nobj =             2000-01-03  2000-01-04  2000-01-05  2000-01-06  2000-01-07\n2000-01-03     0.00000    0.000000     0.00000 ...    0.000000     0.00000    0.000000    0.000000\n2000-01-07     0.00000    0.000000     0.00000    0.000000    0.000000\nidxr = <pandas.core.indexing._iLocIndexer object at 0x1190047c0>\nidxr_id = 'iloc'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x1193372b0>\nindex = PeriodIndex(['2000-01-03', '2000-01-04', '2000-01-05', '2000-01-06',\n             '2000-01-07'],\n            dtype='period[B]', freq='B')\nobj =             2000-01-03  2000-01-04  2000-01-05  2000-01-06  2000-01-07\n2000-01-03    0.531656     0.17985    0.014336 ...     0.00000    0.000000    0.000000    0.000000\n2000-01-07    0.000000     0.00000    0.000000    0.000000    0.000000\nidxr = <pandas.core.indexing._iLocIndexer object at 0x119570900>\nidxr_id = 'iloc'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x119592af0>\nindex = TimedeltaIndex(['1 days', '2 days', '3 days', '4 days', '5 days'], dtype='timedelta64[ns]', freq='D')\nobj =         1 days  2 days  3 days  4 days  5 days\n1 days     0.0     0.0     0.0     0.0     0.0\n2 days     0.0     0.0  ...0     0.0     0.0     0.0\n4 days     0.0     0.0     0.0     0.0     0.0\n5 days     0.0     0.0     0.0     0.0     0.0\nidxr = <pandas.core.indexing._iLocIndexer object at 0x119004db0>\nidxr_id = 'iloc'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x1192b2e80>\nindex = Index([False, True, False, False, False], dtype='object')\nobj =        False  True   False  False  False\nFalse    0.0    0.0    0.0    0.0    0.0\nTrue     0.0    0.0    0.0    0.0   ...se    0.0    0.0    0.0    0.0    0.0\nFalse    0.0    0.0    0.0    0.0    0.0\nFalse    0.0    0.0    0.0    0.0    0.0\nidxr = <pandas.core.indexing._iLocIndexer object at 0x1190049f0>\nidxr_id = 'iloc'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x119543a90>\nindex = RangeIndex(start=0, stop=5, step=1)\nobj =      0    1    2    3    4\n0  0.0  0.0  0.0  0.0  0.0\n1  0.0  0.0  0.0  0.0  0.0\n2  0.0  0.0  0.0  0.0  0.0\n3  0.0  0.0  0.0  0.0  0.0\n4  0.0  0.0  0.0  0.0  0.0\nidxr = <pandas.core.indexing._iLocIndexer object at 0x1192e7950>\nidxr_id = 'iloc'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x11933d3d0>\nindex = IntervalIndex([(0.0, 20.0], (20.0, 40.0], (40.0, 60.0], (60.0, 80.0], (80.0, 100.0]],\n              closed='right',\n              dtype='interval[float64]')\nobj =                (0.0, 20.0]  (20.0, 40.0]  ...  (60.0, 80.0]  (80.0, 100.0]\n(0.0, 20.0]            0.0           0.0  ....    0.0            0.0\n(80.0, 100.0]          0.0           0.0  ...           0.0            0.0\n\n[5 rows x 5 columns]\nidxr = <pandas.core.indexing._iLocIndexer object at 0x1190047c0>\nidxr_id = 'iloc'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_62/pandas/tests/indexing/test_indexing.py",
                "test_function": "test_setitem_ndarray_3d",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n\n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n\n        with pytest.raises(err, match=msg):\n            idxr[nd3] = 0",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.indexing.test_indexing.TestFancy object at 0x11914daf0>\nindex = CategoricalIndex(['dfSH', 'jp1n', 'Q5aL', 'dfSH', 'jp1n'], categories=['dfSH', 'jp1n', 'Q5aL'], ordered=False, dtype='category')\nobj =           dfSH      jp1n      Q5aL      dfSH      jp1n\ndfSH  0.000000  0.000000  0.000000  0.000000  0.000000\njp1n  0.... 0.000000\ndfSH  0.000000  0.000000  0.000000  0.000000  0.000000\njp1n  0.000000  0.000000  0.000000  0.000000  0.000000\nidxr = <pandas.core.indexing._iLocIndexer object at 0x118fee810>\nidxr_id = 'iloc'\n\n    @pytest.mark.parametrize(\n        \"index\", tm.all_index_generator(5), ids=lambda x: type(x).__name__\n    )\n    @pytest.mark.parametrize(\n        \"obj\",\n        [\n            lambda i: Series(np.arange(len(i)), index=i),\n            lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n        ],\n        ids=[\"Series\", \"DataFrame\"],\n    )\n    @pytest.mark.parametrize(\n        \"idxr, idxr_id\",\n        [\n            (lambda x: x, \"setitem\"),\n            (lambda x: x.loc, \"loc\"),\n            (lambda x: x.iloc, \"iloc\"),\n        ],\n    )\n    def test_setitem_ndarray_3d(self, index, obj, idxr, idxr_id):\n        # GH 25567\n        obj = obj(index)\n        idxr = idxr(obj)\n        nd3 = np.random.randint(5, size=(2, 2, 2))\n    \n        if idxr_id == \"iloc\":\n            err = ValueError\n            msg = f\"Cannot set values with ndim > {obj.ndim}\"\n        elif (\n            isinstance(index, pd.IntervalIndex)\n            and idxr_id == \"setitem\"\n            and obj.ndim == 1\n        ):\n            err = AttributeError\n            msg = (\n                \"'pandas._libs.interval.IntervalTree' object has no attribute 'get_loc'\"\n            )\n        else:\n            err = ValueError\n            msg = r\"Buffer has wrong number of dimensions \\(expected 1, got 3\\)|\"\n    \n        with pytest.raises(err, match=msg):\n>           idxr[nd3] = 0\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/indexing/test_indexing.py:153: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('index', tm.all_index_generator(5), ids=lambda x: type(x).__name__)",
                    "pytest.mark.parametrize('obj', [lambda i: Series(np.arange(len(i)), index=i), lambda i: DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)], ids=['Series', 'DataFrame'])",
                    "pytest.mark.parametrize('idxr, idxr_id', [(lambda x: x, 'setitem'), (lambda x: x.loc, 'loc'), (lambda x: x.iloc, 'iloc')])"
                ]
            }
        ]
    }
}