{
    "1.1.1": null,
    "1.1.2": null,
    "1.2.1": null,
    "1.2.2": null,
    "1.2.3": null,
    "1.3.1": "/Volumes/JerrySSD/bgp_envs/repos/pandas_51/pandas/core/indexes/category.py",
    "1.3.2": null,
    "1.4.1": [
        "@pytest.mark.parametrize(\"n_categories\", [5, 128])\ndef test_categorical_non_unique_monotonic(n_categories):\n    # GH 28189\n    # With n_categories as 5, we test the int8 case is hit in libjoin,\n    # with n_categories as 128 we test the int16 case.\n    left_index = CategoricalIndex([0] + list(range(n_categories)))\n    df1 = DataFrame(range(n_categories + 1), columns=[\"value\"], index=left_index)\n    df2 = DataFrame(\n        [[6]],\n        columns=[\"value\"],\n        index=CategoricalIndex([0], categories=np.arange(n_categories)),\n    )\n\n    result = merge(df1, df2, how=\"left\", left_index=True, right_index=True)\n    expected = DataFrame(\n        [[i, 6.0] if i < 2 else [i, np.nan] for i in range(n_categories + 1)],\n        columns=[\"value_x\", \"value_y\"],\n        index=left_index,\n    )\n    tm.assert_frame_equal(expected, result)",
        "@pytest.mark.parametrize(\"n_categories\", [5, 128])\ndef test_categorical_non_unique_monotonic(n_categories):\n    # GH 28189\n    # With n_categories as 5, we test the int8 case is hit in libjoin,\n    # with n_categories as 128 we test the int16 case.\n    left_index = CategoricalIndex([0] + list(range(n_categories)))\n    df1 = DataFrame(range(n_categories + 1), columns=[\"value\"], index=left_index)\n    df2 = DataFrame(\n        [[6]],\n        columns=[\"value\"],\n        index=CategoricalIndex([0], categories=np.arange(n_categories)),\n    )\n\n    result = merge(df1, df2, how=\"left\", left_index=True, right_index=True)\n    expected = DataFrame(\n        [[i, 6.0] if i < 2 else [i, np.nan] for i in range(n_categories + 1)],\n        columns=[\"value_x\", \"value_y\"],\n        index=left_index,\n    )\n    tm.assert_frame_equal(expected, result)"
    ],
    "1.4.2": [
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_51/pandas/tests/reshape/merge/test_merge.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_51/pandas/tests/reshape/merge/test_merge.py"
    ],
    "2.1.1": [
        [
            "E           AssertionError: DataFrame.index are different\nE           \nE           DataFrame.index classes are not equivalent\nE           [left]:  CategoricalIndex([0, 0, 1, 2, 3, 4], categories=[0, 1, 2, 3, 4], ordered=False, dtype='category')\nE           [right]: Int64Index([0, 0, 1, 2, 3, 4], dtype='int64')"
        ],
        [
            "E           AssertionError: DataFrame.index are different\nE           \nE           DataFrame.index classes are not equivalent\nE           [left]:  CategoricalIndex([  0,   0,   1,   2,   3,   4,   5,   6,   7,   8,\nE                             ...\nE                             118, 119, 120, 121, 122, 123, 124, 125, 126, 127],\nE                            categories=[0, 1, 2, 3, 4, 5, 6, 7, ...], ordered=False, dtype='category', length=129)\nE           [right]: Int64Index([  0,   0,   1,   2,   3,   4,   5,   6,   7,   8,\nE                       ...\nE                       118, 119, 120, 121, 122, 123, 124, 125, 126, 127],\nE                      dtype='int64', length=129)"
        ]
    ],
    "2.1.2": [
        [
            "n_categories = 5\n\n    @pytest.mark.parametrize(\"n_categories\", [5, 128])\n    def test_categorical_non_unique_monotonic(n_categories):\n        # GH 28189\n        # With n_categories as 5, we test the int8 case is hit in libjoin,\n        # with n_categories as 128 we test the int16 case.\n        left_index = CategoricalIndex([0] + list(range(n_categories)))\n        df1 = DataFrame(range(n_categories + 1), columns=[\"value\"], index=left_index)\n        df2 = DataFrame(\n            [[6]],\n            columns=[\"value\"],\n            index=CategoricalIndex([0], categories=np.arange(n_categories)),\n        )\n    \n        result = merge(df1, df2, how=\"left\", left_index=True, right_index=True)\n        expected = DataFrame(\n            [[i, 6.0] if i < 2 else [i, np.nan] for i in range(n_categories + 1)],\n            columns=[\"value_x\", \"value_y\"],\n            index=left_index,\n        )\n>       tm.assert_frame_equal(expected, result)\n\npandas/tests/reshape/merge/test_merge.py:2187: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = CategoricalIndex([0, 0, 1, 2, 3, 4], categories=[0, 1, 2, 3, 4], ordered=False, dtype='category')\nr = Int64Index([0, 0, 1, 2, 3, 4], dtype='int64'), obj = 'DataFrame.index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n>           assert_class_equal(l, r, exact=exact, obj=obj)",
            "\npandas/_testing.py:623: AssertionError"
        ],
        [
            "n_categories = 128\n\n    @pytest.mark.parametrize(\"n_categories\", [5, 128])\n    def test_categorical_non_unique_monotonic(n_categories):\n        # GH 28189\n        # With n_categories as 5, we test the int8 case is hit in libjoin,\n        # with n_categories as 128 we test the int16 case.\n        left_index = CategoricalIndex([0] + list(range(n_categories)))\n        df1 = DataFrame(range(n_categories + 1), columns=[\"value\"], index=left_index)\n        df2 = DataFrame(\n            [[6]],\n            columns=[\"value\"],\n            index=CategoricalIndex([0], categories=np.arange(n_categories)),\n        )\n    \n        result = merge(df1, df2, how=\"left\", left_index=True, right_index=True)\n        expected = DataFrame(\n            [[i, 6.0] if i < 2 else [i, np.nan] for i in range(n_categories + 1)],\n            columns=[\"value_x\", \"value_y\"],\n            index=left_index,\n        )\n>       tm.assert_frame_equal(expected, result)\n\npandas/tests/reshape/merge/test_merge.py:2187: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = CategoricalIndex([  0,   0,   1,   2,   3,   4,   5,   6,   7,   8,\n                  ...\n                  118, 119, ...125, 126, 127],\n                 categories=[0, 1, 2, 3, 4, 5, 6, 7, ...], ordered=False, dtype='category', length=129)\nr = Int64Index([  0,   0,   1,   2,   3,   4,   5,   6,   7,   8,\n            ...\n            118, 119, 120, 121, 122, 123, 124, 125, 126, 127],\n           dtype='int64', length=129)\nobj = 'DataFrame.index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n>           assert_class_equal(l, r, exact=exact, obj=obj)",
            "\npandas/_testing.py:623: AssertionError"
        ]
    ],
    "2.1.3": null,
    "2.1.4": null,
    "2.1.5": null,
    "2.1.6": null,
    "3.1.1": [
        "Merge on CategoricalIndex fails if left_index=True & right_index=True, but not if on={index}\n"
    ],
    "3.1.2": [
        "Code Sample, a copy-pastable example if possible\nimport pandas as pd\nimport numpy as np\n\npdf = pd.DataFrame({\n    \"idx\": pd.Categorical([\"1\"] * 4),\n    \"value\": [1, 2, 3, 4]\n})\npdf = pdf.set_index(\"idx\")\npdf\nvalue\nidx\t\n1\t1\n1\t2\n1\t3\n1\t4\nagg = pdf.groupby(\"idx\").agg(np.sum)[\"value\"]\nagg\nidx\n1    10\nName: value, dtype: int64\nmerged = pd.merge(pdf, agg, how=\"left\", left_index=True, right_index=True)\nmerged\n---------------------------------------------------------------------------\n\nTypeError                                 Traceback (most recent call last)\n\n<ipython-input-89-5347bee83336> in <module>\n----> 1 merged = pd.merge(pdf, agg, how=\"left\", left_index=True, right_index=True)\n      2 merged\n\n\n/usr/local/lib/python3.7/site-packages/pandas/core/reshape/merge.py in merge(left, right, how, on, left_on, right_on, left_index, right_index, sort, suffixes, copy, indicator, validate)\n     46                          copy=copy, indicator=indicator,\n     47                          validate=validate)\n---> 48     return op.get_result()\n     49 \n     50 \n\n\n/usr/local/lib/python3.7/site-packages/pandas/core/reshape/merge.py in get_result(self)\n    544                 self.left, self.right)\n    545 \n--> 546         join_index, left_indexer, right_indexer = self._get_join_info()\n    547 \n    548         ldata, rdata = self.left._data, self.right._data\n\n\n/usr/local/lib/python3.7/site-packages/pandas/core/reshape/merge.py in _get_join_info(self)\n    742             join_index, left_indexer, right_indexer = \\\n    743                 left_ax.join(right_ax, how=self.how, return_indexers=True,\n--> 744                              sort=self.sort)\n    745         elif self.right_index and self.how == 'left':\n    746             join_index, left_indexer, right_indexer = \\\n\n\n/usr/local/lib/python3.7/site-packages/pandas/core/indexes/base.py in join(self, other, how, level, return_indexers, sort)\n   3291             if self.is_monotonic and other.is_monotonic:\n   3292                 return self._join_monotonic(other, how=how,\n-> 3293                                             return_indexers=return_indexers)\n   3294             else:\n   3295                 return self._join_non_unique(other, how=how,\n\n\n/usr/local/lib/python3.7/site-packages/pandas/core/indexes/base.py in _join_monotonic(self, other, how, return_indexers)\n   3583         else:\n   3584             if how == 'left':\n-> 3585                 join_index, lidx, ridx = self._left_indexer(sv, ov)\n   3586             elif how == 'right':\n   3587                 join_index, ridx, lidx = self._left_indexer(ov, sv)\n\n\n/usr/local/lib/python3.7/site-packages/pandas/core/indexes/base.py in _left_indexer(self, left, right)\n    217 \n    218     def _left_indexer(self, left, right):\n--> 219         return libjoin.left_join_indexer(left, right)\n    220 \n    221     def _inner_indexer(self, left, right):\n\n\npandas/_libs/join.pyx in pandas._libs.join.__pyx_fused_cpdef()\n\n\nTypeError: No matching signature found\nProblem description\nThe problem is triggered in libjoin.left_join_indexer(left, right), where both left and right have dtype(int8), which raises the TypeError: No matching signature found.\n\nInterestingly enough, if you change from\n\npd.merge(pdf, agg, how=\"left\", left_index=True, right_index=True)\n\nto\n\npd.merge(pdf, agg, how=\"left\", on=\"idx\")\n\neverything works fine as demonstrated below.\n\nExpected Output\nmerged = pd.merge(pdf, agg, how=\"left\", on=\"idx\")\nmerged\nvalue_x\tvalue_y\nidx\t\t\n1\t1\t10\n1\t2\t10\n1\t3\t10\n1\t4\t10\n"
    ]
}