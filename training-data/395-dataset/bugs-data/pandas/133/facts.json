{
    "1.1.1": "@Appender(_shared_docs[\"interpolate\"] % _shared_doc_kwargs)\ndef interpolate(\n    self,\n    method=\"linear\",\n    axis=0,\n    limit=None,\n    inplace=False,\n    limit_direction=\"forward\",\n    limit_area=None,\n    downcast=None,\n    **kwargs\n):\n    \n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n\n    if axis == 0:\n        ax = self._info_axis_name\n        _maybe_transposed_self = self\n    elif axis == 1:\n        _maybe_transposed_self = self.T\n        ax = 1\n    else:\n        _maybe_transposed_self = self\n    ax = _maybe_transposed_self._get_axis_number(ax)\n\n    if _maybe_transposed_self.ndim == 2:\n        alt_ax = 1 - ax\n    else:\n        alt_ax = ax\n\n    if isinstance(_maybe_transposed_self.index, MultiIndex) and method != \"linear\":\n        raise ValueError(\n            \"Only `method=linear` interpolation is supported on MultiIndexes.\"\n        )\n\n    if _maybe_transposed_self._data.get_dtype_counts().get(\"object\") == len(\n        _maybe_transposed_self.T\n    ):\n        raise TypeError(\n            \"Cannot interpolate with all object-dtype columns \"\n            \"in the DataFrame. Try setting at least one \"\n            \"column to a numeric dtype.\"\n        )\n\n    # create/use the index\n    if method == \"linear\":\n        # prior default\n        index = np.arange(len(_maybe_transposed_self._get_axis(alt_ax)))\n    else:\n        index = _maybe_transposed_self._get_axis(alt_ax)\n        methods = {\"index\", \"values\", \"nearest\", \"time\"}\n        is_numeric_or_datetime = (\n            is_numeric_dtype(index)\n            or is_datetime64_any_dtype(index)\n            or is_timedelta64_dtype(index)\n        )\n        if method not in methods and not is_numeric_or_datetime:\n            raise ValueError(\n                \"Index column must be numeric or datetime type when \"\n                \"using {method} method other than linear. \"\n                \"Try setting a numeric or datetime index column before \"\n                \"interpolating.\".format(method=method)\n            )\n\n    if isna(index).any():\n        raise NotImplementedError(\n            \"Interpolation with NaNs in the index \"\n            \"has not been implemented. Try filling \"\n            \"those NaNs before interpolating.\"\n        )\n    data = _maybe_transposed_self._data\n    new_data = data.interpolate(\n        method=method,\n        axis=ax,\n        index=index,\n        values=_maybe_transposed_self,\n        limit=limit,\n        limit_direction=limit_direction,\n        limit_area=limit_area,\n        inplace=inplace,\n        downcast=downcast,\n        **kwargs\n    )\n\n    if inplace:\n        if axis == 1:\n            new_data = self._constructor(new_data).T._data\n        self._update_inplace(new_data)\n    else:\n        res = self._constructor(new_data).__finalize__(self)\n        if axis == 1:\n            res = res.T\n        return res\n",
    "1.1.2": "Interpolate values according to different methods.",
    "1.2.1": "class NDFrame(PandasObject, SelectionMixin)",
    "1.2.2": "N-dimensional analogue of DataFrame. Store multi-dimensional in a\nsize-mutable, labeled data structure\n\nParameters\n----------\ndata : BlockManager\naxes : list\ncopy : bool, default False",
    "1.2.3": [
        "_constructor(self)",
        "_get_axis_number(cls, axis)",
        "_get_axis(self, axis)",
        "ndim(self)",
        "get(self, key, default=None)",
        "_update_inplace(self, result, verify_is_copy=True)",
        "__finalize__(self, other, method=None, **kwargs)",
        "get_dtype_counts(self)",
        "interpolate(self, method='linear', axis=0, limit=None, inplace=False, limit_direction='forward', limit_area=None, downcast=None, **kwargs)",
        "isna(self)"
    ],
    "1.3.1": "/Volumes/JerrySSD/bgp_envs/repos/pandas_133/pandas/core/generic.py",
    "1.3.2": [
        "_constructor(self)",
        "_get_axis_number(cls, axis)",
        "_get_axis(self, axis)",
        "ndim(self)",
        "get(self, key, default=None)",
        "_update_inplace(self, result, verify_is_copy=True)",
        "__finalize__(self, other, method=None, **kwargs)",
        "get_dtype_counts(self)",
        "interpolate(self, method='linear', axis=0, limit=None, inplace=False, limit_direction='forward', limit_area=None, downcast=None, **kwargs)",
        "isna(self)"
    ],
    "1.4.1": [
        "    @pytest.mark.parametrize(\n        \"axis_name, axis_number\",\n        [\n            pytest.param(\"rows\", 0, id=\"rows_0\"),\n            pytest.param(\"index\", 0, id=\"index_0\"),\n            pytest.param(\"columns\", 1, id=\"columns_1\"),\n        ],\n    )\n    def test_interp_axis_names(self, axis_name, axis_number):\n        # GH 29132: test axis names\n        data = {0: [0, np.nan, 6], 1: [1, np.nan, 7], 2: [2, 5, 8]}\n\n        df = DataFrame(data, dtype=np.float64)\n        result = df.interpolate(axis=axis_name, method=\"linear\")\n        expected = df.interpolate(axis=axis_number, method=\"linear\")\n        assert_frame_equal(result, expected)",
        "    @pytest.mark.parametrize(\n        \"axis_name, axis_number\",\n        [\n            pytest.param(\"rows\", 0, id=\"rows_0\"),\n            pytest.param(\"index\", 0, id=\"index_0\"),\n            pytest.param(\"columns\", 1, id=\"columns_1\"),\n        ],\n    )\n    def test_interp_axis_names(self, axis_name, axis_number):\n        # GH 29132: test axis names\n        data = {0: [0, np.nan, 6], 1: [1, np.nan, 7], 2: [2, 5, 8]}\n\n        df = DataFrame(data, dtype=np.float64)\n        result = df.interpolate(axis=axis_name, method=\"linear\")\n        expected = df.interpolate(axis=axis_number, method=\"linear\")\n        assert_frame_equal(result, expected)",
        "    @pytest.mark.parametrize(\n        \"axis_name, axis_number\",\n        [\n            pytest.param(\"rows\", 0, id=\"rows_0\"),\n            pytest.param(\"index\", 0, id=\"index_0\"),\n            pytest.param(\"columns\", 1, id=\"columns_1\"),\n        ],\n    )\n    def test_interp_axis_names(self, axis_name, axis_number):\n        # GH 29132: test axis names\n        data = {0: [0, np.nan, 6], 1: [1, np.nan, 7], 2: [2, 5, 8]}\n\n        df = DataFrame(data, dtype=np.float64)\n        result = df.interpolate(axis=axis_name, method=\"linear\")\n        expected = df.interpolate(axis=axis_number, method=\"linear\")\n        assert_frame_equal(result, expected)"
    ],
    "1.4.2": [
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_133/pandas/tests/frame/test_missing.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_133/pandas/tests/frame/test_missing.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_133/pandas/tests/frame/test_missing.py"
    ],
    "2.1.1": [
        [
            "E       UnboundLocalError: local variable 'ax' referenced before assignment"
        ],
        [
            "E       UnboundLocalError: local variable 'ax' referenced before assignment"
        ],
        [
            "E       UnboundLocalError: local variable 'ax' referenced before assignment"
        ]
    ],
    "2.1.2": [
        [
            "self = <pandas.tests.frame.test_missing.TestDataFrameInterpolate object at 0x119961b50>\naxis_name = 'rows', axis_number = 0\n\n    @pytest.mark.parametrize(\n        \"axis_name, axis_number\",\n        [\n            pytest.param(\"rows\", 0, id=\"rows_0\"),\n            pytest.param(\"index\", 0, id=\"index_0\"),\n            pytest.param(\"columns\", 1, id=\"columns_1\"),\n        ],\n    )\n    def test_interp_axis_names(self, axis_name, axis_number):\n        # GH 29132: test axis names\n        data = {0: [0, np.nan, 6], 1: [1, np.nan, 7], 2: [2, 5, 8]}\n    \n        df = DataFrame(data, dtype=np.float64)\n>       result = df.interpolate(axis=axis_name, method=\"linear\")\n\npandas/tests/frame/test_missing.py:894: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself =      0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0\nmethod = 'linear', axis = 'rows', limit = None, inplace = False\nlimit_direction = 'forward', limit_area = None, downcast = None, kwargs = {}\n_maybe_transposed_self =      0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0\n\n    @Appender(_shared_docs[\"interpolate\"] % _shared_doc_kwargs)\n    def interpolate(\n        self,\n        method=\"linear\",\n        axis=0,\n        limit=None,\n        inplace=False,\n        limit_direction=\"forward\",\n        limit_area=None,\n        downcast=None,\n        **kwargs\n    ):\n        \"\"\"\n        Interpolate values according to different methods.\n        \"\"\"\n        inplace = validate_bool_kwarg(inplace, \"inplace\")\n    \n        if axis == 0:\n            ax = self._info_axis_name\n            _maybe_transposed_self = self\n        elif axis == 1:\n            _maybe_transposed_self = self.T\n            ax = 1\n        else:\n            _maybe_transposed_self = self\n>       ax = _maybe_transposed_self._get_axis_number(ax)",
            "\npandas/core/generic.py:7059: UnboundLocalError"
        ],
        [
            "self = <pandas.tests.frame.test_missing.TestDataFrameInterpolate object at 0x119be0e80>\naxis_name = 'index', axis_number = 0\n\n    @pytest.mark.parametrize(\n        \"axis_name, axis_number\",\n        [\n            pytest.param(\"rows\", 0, id=\"rows_0\"),\n            pytest.param(\"index\", 0, id=\"index_0\"),\n            pytest.param(\"columns\", 1, id=\"columns_1\"),\n        ],\n    )\n    def test_interp_axis_names(self, axis_name, axis_number):\n        # GH 29132: test axis names\n        data = {0: [0, np.nan, 6], 1: [1, np.nan, 7], 2: [2, 5, 8]}\n    \n        df = DataFrame(data, dtype=np.float64)\n>       result = df.interpolate(axis=axis_name, method=\"linear\")\n\npandas/tests/frame/test_missing.py:894: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself =      0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0\nmethod = 'linear', axis = 'index', limit = None, inplace = False\nlimit_direction = 'forward', limit_area = None, downcast = None, kwargs = {}\n_maybe_transposed_self =      0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0\n\n    @Appender(_shared_docs[\"interpolate\"] % _shared_doc_kwargs)\n    def interpolate(\n        self,\n        method=\"linear\",\n        axis=0,\n        limit=None,\n        inplace=False,\n        limit_direction=\"forward\",\n        limit_area=None,\n        downcast=None,\n        **kwargs\n    ):\n        \"\"\"\n        Interpolate values according to different methods.\n        \"\"\"\n        inplace = validate_bool_kwarg(inplace, \"inplace\")\n    \n        if axis == 0:\n            ax = self._info_axis_name\n            _maybe_transposed_self = self\n        elif axis == 1:\n            _maybe_transposed_self = self.T\n            ax = 1\n        else:\n            _maybe_transposed_self = self\n>       ax = _maybe_transposed_self._get_axis_number(ax)",
            "\npandas/core/generic.py:7059: UnboundLocalError"
        ],
        [
            "self = <pandas.tests.frame.test_missing.TestDataFrameInterpolate object at 0x119df5520>\naxis_name = 'columns', axis_number = 1\n\n    @pytest.mark.parametrize(\n        \"axis_name, axis_number\",\n        [\n            pytest.param(\"rows\", 0, id=\"rows_0\"),\n            pytest.param(\"index\", 0, id=\"index_0\"),\n            pytest.param(\"columns\", 1, id=\"columns_1\"),\n        ],\n    )\n    def test_interp_axis_names(self, axis_name, axis_number):\n        # GH 29132: test axis names\n        data = {0: [0, np.nan, 6], 1: [1, np.nan, 7], 2: [2, 5, 8]}\n    \n        df = DataFrame(data, dtype=np.float64)\n>       result = df.interpolate(axis=axis_name, method=\"linear\")\n\npandas/tests/frame/test_missing.py:894: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself =      0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0\nmethod = 'linear', axis = 'columns', limit = None, inplace = False\nlimit_direction = 'forward', limit_area = None, downcast = None, kwargs = {}\n_maybe_transposed_self =      0    1    2\n0  0.0  1.0  2.0\n1  NaN  NaN  5.0\n2  6.0  7.0  8.0\n\n    @Appender(_shared_docs[\"interpolate\"] % _shared_doc_kwargs)\n    def interpolate(\n        self,\n        method=\"linear\",\n        axis=0,\n        limit=None,\n        inplace=False,\n        limit_direction=\"forward\",\n        limit_area=None,\n        downcast=None,\n        **kwargs\n    ):\n        \"\"\"\n        Interpolate values according to different methods.\n        \"\"\"\n        inplace = validate_bool_kwarg(inplace, \"inplace\")\n    \n        if axis == 0:\n            ax = self._info_axis_name\n            _maybe_transposed_self = self\n        elif axis == 1:\n            _maybe_transposed_self = self.T\n            ax = 1\n        else:\n            _maybe_transposed_self = self\n>       ax = _maybe_transposed_self._get_axis_number(ax)",
            "\npandas/core/generic.py:7059: UnboundLocalError"
        ]
    ],
    "2.1.3": null,
    "2.1.4": null,
    "2.1.5": null,
    "2.1.6": null,
    "3.1.1": [
        "\n"
    ],
    "3.1.2": [
        "\n"
    ]
}